{"idx": "408", "code": "public void addListener(Listener listener){\n  mListeners.add(listener);\n  notifyServiceDiscovered(mMatchingDrones);\n}\n", "docstring": "add a listener all callbacks of the interface listener will be called within this function should be called in the main thread", "partition": "test"}
{"idx": "2805", "code": "private <T extends CWLResource>List<T> lookForResources(CWLResourceType type,Class<T> clazz){\n  List<T> resources=getRequirements(type,clazz);\n  if (resources == null || resources.size() == 0) {\n    resources=getHints(type,clazz);\n  }\n  return resources;\n}\n", "docstring": "find all resources by type", "partition": "test"}
{"idx": "1317", "code": "public void pushDrawList(PspGeList list){\nsynchronized (drawListQueue) {\n    drawListQueue.add(list);\n  }\n}\n", "docstring": "called from pspge module", "partition": "test"}
{"idx": "4137", "code": "public void writeSI32(int value) throws IOException {\n  flushBits();\n  out.write(value & 0xff);\n  out.write(value >> 8);\n  out.write(value >> 16);\n  out.write(value >> 24);\n  bytesWritten+=4;\n}\n", "docstring": "write a 32 bit signed value", "partition": "test"}
{"idx": "3614", "code": "@Override public void onFullBackup(FullBackupDataOutput output) throws IOException {\n  if (mVolumes != null) {\n    if (DEBUG)     Slog.i(TAG,\"Backing up \" + mVolumes.length + \" shared volumes\");\n    HashSet<String> externalFilesDirFilter=new HashSet<String>();\n    final File externalAndroidRoot=new File(Environment.getExternalStorageDirectory(),Environment.DIRECTORY_ANDROID);\n    externalFilesDirFilter.add(externalAndroidRoot.getCanonicalPath());\n    for (int i=0; i < mVolumes.length; i++) {\n      StorageVolume v=mVolumes[i];\n      String domain=FullBackup.SHARED_PREFIX + i;\n      fullBackupFileTree(null,domain,v.getPath(),externalFilesDirFilter,output);\n    }\n  }\n}\n", "docstring": "full backup of the shared - storage filesystem", "partition": "test"}
{"idx": "4037", "code": "public int cardinality(){\n  int sum=0;\n  for (  long l : this.data)   sum+=Long.bitCount(l);\n  return sum;\n}\n", "docstring": "compute the number of bits set to 1", "partition": "test"}
{"idx": "1626", "code": "GF256Poly addOrSubtract(GF256Poly other){\n  if (!field.equals(other.field)) {\n    throw new IllegalArgumentException(\"GF256Polys do not have same GF256 field\");\n  }\n  if (isZero()) {\n    return other;\n  }\n  if (other.isZero()) {\n    return this;\n  }\n  int[] smallerCoefficients=this.coefficients;\n  int[] largerCoefficients=other.coefficients;\n  if (smallerCoefficients.length > largerCoefficients.length) {\n    int[] temp=smallerCoefficients;\n    smallerCoefficients=largerCoefficients;\n    largerCoefficients=temp;\n  }\n  int[] sumDiff=new int[largerCoefficients.length];\n  int lengthDiff=largerCoefficients.length - smallerCoefficients.length;\n  System.arraycopy(largerCoefficients,0,sumDiff,0,lengthDiff);\n  for (int i=lengthDiff; i < largerCoefficients.length; i++) {\n    sumDiff[i]=GF256.addOrSubtract(smallerCoefficients[i - lengthDiff],largerCoefficients[i]);\n  }\n  return new GF256Poly(field,sumDiff);\n}\n", "docstring": "gf addition or subtraction ( they are identical for a gf ( 2 ^ n )", "partition": "test"}
{"idx": "749", "code": "public static double lnGamma(double alpha){\n  double x=alpha, f=0.0, z;\n  if (x < 7) {\n    f=1;\n    z=x - 1;\n    while (++z < 7) {\n      f*=z;\n    }\n    x=z;\n    f=-Math.log(f);\n  }\n  z=1 / (x * x);\n  return f + (x - 0.5) * Math.log(x) - x + 0.918938533204673 + (((-0.000595238095238 * z + 0.000793650793651) * z - 0.002777777777778) * z + 0.083333333333333) / x;\n}\n", "docstring": "log gamma function : ln ( gamma ( alpha ) ) for alpha > 0 , accurate to 10 decimal places", "partition": "test"}
{"idx": "2035", "code": "public boolean validate(String value,String rule){\n  return (value.equalsIgnoreCase(rule));\n}\n", "docstring": "determines whether the specified string is a valid boolean value", "partition": "test"}
{"idx": "3645", "code": "public static double angle(Coordinate p){\n  return Math.atan2(p.y,p.x);\n}\n", "docstring": "returns the angle that the vector from ( 0 , 0 ) to p , relative to the positive x - axis . the angle is normalized to be in the range ( - pi , pi ", "partition": "test"}
{"idx": "4186", "code": "public static <T>String toString(Collection<T> collection){\n  if (collection == null) {\n    return \"null\";\n  }\n  if (collection.isEmpty()) {\n    return \"\";\n  }\n  StringBuilder buf=new StringBuilder();\n  String delimiter=\"\";\n  for (  T t : collection) {\n    if (t == null) {\n      continue;\n    }\n    buf.append(delimiter);\n    buf.append(t);\n    delimiter=\", \";\n  }\n  return buf.toString();\n}\n", "docstring": "returns a list of the elements invoking tostring on non - null elements .", "partition": "test"}
{"idx": "1329", "code": "private static String expandSystemIdStrictOn(String systemId,String baseSystemId) throws URI.MalformedURIException {\n  URI systemURI=new URI(systemId,true);\n  if (systemURI.isAbsoluteURI()) {\n    return systemId;\n  }\n  URI baseURI=null;\n  if (baseSystemId == null || baseSystemId.length() == 0) {\n    baseURI=getUserDir();\n  }\n else {\n    baseURI=new URI(baseSystemId,true);\n    if (!baseURI.isAbsoluteURI()) {\n      baseURI.absolutize(getUserDir());\n    }\n  }\n  systemURI.absolutize(baseURI);\n  return systemURI.toString();\n}\n", "docstring": "helper method for expandsystemid ( string , string , boolean ) : string", "partition": "test"}
{"idx": "3239", "code": "private void checkHeadingsHierarchy(Elements elements,TestSolutionHandler testSolutionHandler){\n  if (elements.isEmpty()) {\n    testSolutionHandler.addTestSolution(TestSolution.NOT_APPLICABLE);\n    return;\n  }\n  TestSolution checkResult=TestSolution.PASSED;\n  Iterator<Element> iter=elements.iterator();\n  Element element=iter.next();\n  int indexOfReference=getHeaderIndex(element);\n  int currentIndex;\n  int previousIndex=indexOfReference;\n  Element elementOfReference=element;\n  Element previousElement=element;\n  while (iter.hasNext()) {\n    element=iter.next();\n    currentIndex=getHeaderIndex(element);\n    if (currentIndex != -1) {\n      if (currentIndex - previousIndex >= 2) {\n        checkResult=TestSolution.FAILED;\n        addSourceCodeRemark(TestSolution.FAILED,element,HEADER_NOT_HIERARCHICALLY_WELL_DEFINED_MSG,getEvidenceElement(PREVIOUS_H_TAG_INDEX_EE,getEvidenceElementMsg(previousIndex,previousElement)));\n      }\n else       if (currentIndex < indexOfReference) {\n        checkResult=TestSolution.FAILED;\n        addSourceCodeRemark(TestSolution.FAILED,element,HEADER_NOT_HIERARCHICALLY_WELL_DEFINED_MSG,getEvidenceElement(FIRST_H_TAG_INDEX_EE,getEvidenceElementMsg(indexOfReference,elementOfReference)));\n      }\n      previousIndex=currentIndex;\n      previousElement=element;\n    }\n  }\n  testSolutionHandler.addTestSolution(checkResult);\n}\n", "docstring": "this methods checks whether the headings hierarchy is well - structured", "partition": "test"}
{"idx": "1636", "code": "public static String byteArrayToHexString(byte[] block,int offset,int length){\n  StringBuffer buf=new StringBuffer();\n  int len=block.length;\n  length=length + offset;\n  if ((len < length)) {\n    length=len;\n  }\n  for (int i=0 + offset; i < length; i++) {\n    byte2hex(block[i],buf);\n    if (i < length - 1) {\n      buf.append(':');\n    }\n  }\n  return buf.toString();\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2840", "code": "public ChainIterable<T> addItem(@NotNull T item){\n  return (ChainIterable<T>)super.add(Collections.<T>singleton(item));\n}\n", "docstring": "convenience : add an item wrapping it into a singleiterable behind the scenes .", "partition": "test"}
{"idx": "1129", "code": "private static int compareLocales(Locale primary,Locale other){\n  final String lang=primary.getLanguage();\n  if ((lang == null) || !lang.equals(other.getLanguage())) {\n    return 0;\n  }\n  final String country=primary.getCountry();\n  if ((country == null) || !country.equals(other.getCountry())) {\n    return 1;\n  }\n  final String variant=primary.getVariant();\n  if ((variant == null) || !variant.equals(other.getVariant())) {\n    return 2;\n  }\n  return 3;\n}\n", "docstring": "compares a locale against a primary locale . returns higher values for closer matches . a return value of 3 indicates that the locale is an exact match for the primary locale \"'\" s language , country , and variant .", "partition": "test"}
{"idx": "1561", "code": "public JKSSignatureToken(InputStream ksStream,String ksPassword){\n  try {\n    keyStore=KeyStore.getInstance(KeyStore.getDefaultType());\n    password=(ksPassword == null) ? null : ksPassword.toCharArray();\n    keyStore.load(ksStream,password);\n  }\n catch (  Exception e) {\n    throw new DSSException(e);\n  }\n finally {\n    if (ksStream != null) {\n      try {\n        ksStream.close();\n      }\n catch (      IOException e) {\n        logger.error(e.getMessage(),e);\n      }\n    }\n  }\n}\n", "docstring": "creates a signaturetokenconnection with the provided inputstream to java keystore file and password .", "partition": "test"}
{"idx": "3652", "code": "private ResponsePacket executeCount(QueryTemplatePacket template,IJSpace space,Transaction txn) throws SQLException {\n  try {\n    template.setRouting(getRouting());\n    template.setExplainPlan(getExplainPlan());\n    int count=space.count(template,txn,getReadModifier());\n    ResponsePacket response=new ResponsePacket();\n    Object[][] values=new Object[1][1];\n    values[0][0]=count;\n    ResultEntry result=new ResultEntry(new String[]{getCountColumnName()},new String[]{getCountColumnLabel()},new String[]{\"\"},values);\n    response.setResultEntry(result);\n    return response;\n  }\n catch (  Exception e) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,e.getMessage(),e);\n    }\n    throw new SQLException(\"Failed to execute count: \" + e,\"GSP\",-111);\n  }\n}\n", "docstring": "handle read query - check if it is a read query or a readmultiple and execute it", "partition": "test"}
{"idx": "3726", "code": "public Edge findEdgeInSameDirection(Coordinate p0,Coordinate p1){\n  for (int i=0; i < edges.size(); i++) {\n    Edge e=(Edge)edges.get(i);\n    Coordinate[] eCoord=e.getCoordinates();\n    if (matchInSameDirection(p0,p1,eCoord[0],eCoord[1]))     return e;\n    if (matchInSameDirection(p0,p1,eCoord[eCoord.length - 1],eCoord[eCoord.length - 2]))     return e;\n  }\n  return null;\n}\n", "docstring": "returns the edge which starts at p0 and whose first segment is parallel to p1", "partition": "test"}
{"idx": "3907", "code": "@RequestMapping(value=\"/container/{containerId}/application/{applicationName}\",method=RequestMethod.POST) @ResponseBody public JsonResponse createDirectory(@PathVariable final String containerId,@PathVariable final String applicationName,@RequestParam(\"path\") String path) throws ServiceException, CheckException, IOException {\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"containerId:\" + containerId);\n    logger.debug(\"applicationName:\" + applicationName);\n    logger.debug(\"path:\" + path);\n  }\n  fileService.createDirectory(applicationName,containerId,path);\n  return new HttpOk();\n}\n", "docstring": "create resources ( files and folders ) into a container for a path", "partition": "test"}
{"idx": "2692", "code": "public ViterbiPoint(Item item){\n  this.item=item;\n}\n", "docstring": "creates a viterbipoint for the given item . a typical item of choice is a segment item .", "partition": "test"}
{"idx": "3707", "code": "public void damage(double value){\n  setValue(Math.max(0,getValue() - value));\n}\n", "docstring": "damage component by given value .", "partition": "test"}
{"idx": "2745", "code": "void define(MemberDefinition field,int slot,int from,int to){\n  if (from >= to) {\n    return;\n  }\n  for (int i=0; i < len; i++) {\n    if ((locals[i].field == field) && (locals[i].slot == slot) && (from <= locals[i].to)&& (to >= locals[i].from)) {\n      locals[i].from=Math.min(locals[i].from,from);\n      locals[i].to=Math.max(locals[i].to,to);\n      return;\n    }\n  }\n  if (len == locals.length) {\n    LocalVariable newlocals[]=new LocalVariable[len * 2];\n    System.arraycopy(locals,0,newlocals,0,len);\n    locals=newlocals;\n  }\n  locals[len++]=new LocalVariable(field,slot,from,to);\n}\n", "docstring": "define a new local variable . merge entries where possible .", "partition": "test"}
{"idx": "2125", "code": "public void addScriptFinishedListener(ScriptExecutionListener l){\n  m_FinishedListeners.add(l);\n}\n", "docstring": "adds the given listener to its internal list .", "partition": "test"}
{"idx": "906", "code": "public Hashtable<IPoint,List<ILineSegment>> intersections(Iterator<ILineSegment> it){\n  Collection<ILineSegment> c=new ArrayList<ILineSegment>();\n  while (it.hasNext()) {\n    c.add(it.next());\n  }\n  return intersections(c.toArray(new ILineSegment[]{}));\n}\n", "docstring": "compute the intersection of all segments when given an iterator of segments .", "partition": "test"}
{"idx": "2369", "code": "@Override public boolean addOutputSensor(String sensorName,int state){\n  OutputSensor outputSensor=new OutputSensor(sensorName);\n  if (!outputSensor.setState(state)) {\n    return false;\n  }\n  _outputSensorList.add(outputSensor);\n  return true;\n}\n", "docstring": "add an output sensor to this route", "partition": "test"}
{"idx": "1288", "code": "public IVariable[] extractRobotDebugVariables(final int stackTraceId,final Map<String,Object> newVariables){\n  final RobotDebugVariablesContext currentVariablesContext=findCurrentVariablesContext(stackTraceId);\n  Map<String,IVariable> previousVariablesMap=initPreviousVariablesState(currentVariablesContext);\n  final Map<String,IVariable> nonGlobalVariablesMap=new LinkedHashMap<>();\n  if (previousVariablesMap == null) {\n    initNewNonGlobalVariables(newVariables,nonGlobalVariablesMap);\n  }\n else {\n    initVariablesComparingWithPreviousState(newVariables,previousVariablesMap,nonGlobalVariablesMap);\n  }\n  final LinkedList<IVariable> currentVariablesList=createCurrentVariablesList(nonGlobalVariablesMap);\n  saveCurrentVariablesState(stackTraceId,currentVariablesContext,nonGlobalVariablesMap);\n  return currentVariablesList.toArray(new IVariable[currentVariablesList.size()]);\n}\n", "docstring": "extract and sort variables for given stacktrace level . every level of stacktrace has its own context in previousvariables map . current variables are compared with previous state . if current level of stacktrace has not any previous state , then previous state will be variables from level below . this is for saving previous order of variables in higher levels .", "partition": "test"}
{"idx": "64", "code": "protected void create_y_axis(int i){\n  Log.e(\"index vlaue\",i + \"\");\n  float ver_height=((graphheight / label_size) * i) + border;\n  if (i == largest_value_set.size() - 1)   canvas.drawLine(horstart,ver_height,width - (border),ver_height,paint);\n else   canvas.drawLine(horstart,ver_height,border,ver_height,paint);\n  paint.setColor(Color.BLACK);\n  int Y_labels=(int)size - 1 - i;\n  String y_labels=String.format(\"%.1f\",Y_labels * y_axis_ratio);\n  paint.setTextAlign(Paint.Align.RIGHT);\n  canvas.drawText(y_labels,horstart - 15,ver_height - 10,paint);\n  paint.setTextAlign(Paint.Align.LEFT);\n}\n", "docstring": "this function is used to plot the y axis and its breakdown with value . uses drawline ( ) method to create the y axis and lines to show breakdown of y axis and drawtext ( ) method to plot labels related with breakdowns", "partition": "test"}
{"idx": "440", "code": "public void emitRetainedVars(GenerateJsVisitor gen){\n  if (!retainedVars.isEmpty()) {\n    gen.out(\"var \");\n    boolean first=true;\n    for (    String varName : retainedVars) {\n      if (!first) {\n        gen.out(\",\");\n      }\n      first=false;\n      gen.out(varName);\n    }\n    gen.endLine(true);\n    retainedVars.clear();\n  }\n}\n", "docstring": "writes all retained variables to the output of the specified generator , then clears them .", "partition": "test"}
{"idx": "258", "code": "public void hspan(double start,double end,Paint color,String legend){\n  LegendText legendText=new LegendText(color,legend);\n  comments.add(legendText);\n  plotElements.add(new HSpan(start,end,color,legendText));\n}\n", "docstring": "draws a horizontal span into the graph and optionally adds a legend .", "partition": "test"}
{"idx": "3698", "code": "public void deleteResourceConfig(String clusterName,ResourceType resourceType,String dsName) throws ConfigurationException {\n  if (getClusterHome() == null) {\n    throw new ConfigurationException(\"No home directory found from which to configure resources.\");\n  }\n  File resources=getDir(getResourceConfigDirName(getClusterHome(),clusterName,resourceType));\n  String delFileName=resources.getAbsolutePath() + File.separator + dsName+ \".properties\";\n  delFile(delFileName);\n}\n", "docstring": "delete a specific resource configuration .", "partition": "test"}
{"idx": "4254", "code": "public static String toString(final URI uri,final Charset encoding) throws IOException {\n  return IOUtils.toString(uri.toURL(),Charsets.toCharset(encoding));\n}\n", "docstring": "gets the contents at the given uri .", "partition": "test"}
{"idx": "2859", "code": "public HttpRequest contentLength(final String value){\n  return contentLength(Integer.parseInt(value));\n}\n", "docstring": "set the \"'\" content - length \"'\" request header to the given value", "partition": "test"}
{"idx": "2179", "code": "public void addZoneChangeListener(ZoneChangeListener listener){\n  zoneChangeListeners.add(listener);\n}\n", "docstring": "add a listener to be called when the player changes zone .", "partition": "test"}
{"idx": "3548", "code": "public void update(GL10 gl){\n  if (taskQueue.size() > 0) {\n    GLResorceTask res;\n    while ((res=taskQueue.poll()) != null) {\n      res.perform(gl);\n    }\n  }\n}\n", "docstring": "method is called from update cycle , perform all tasks in gl thread", "partition": "test"}
{"idx": "545", "code": "public AtomicDoubleArray(int length){\n  larray=new AtomicLongArray(length);\n  long ZERO=Double.doubleToRawLongBits(0.0);\n  for (int i=0; i < length; i++)   larray.set(i,ZERO);\n}\n", "docstring": "creates a new atomicdoublearray of the given length , with all values initialized to zero", "partition": "test"}
{"idx": "4023", "code": "public static String decode(AbstractMessage msg,Boolean ext,int header){\n  if (ext == false) {\n    return decode(msg);\n  }\n  return \"Bootloader Message Type: \" + header;\n}\n", "docstring": "return a string representation of a decoded cbus message", "partition": "test"}
{"idx": "1493", "code": "private double normalDens(double x,double mean,double stdDev){\n  double diff=x - mean;\n  return (1 / (m_normConst * stdDev)) * Math.exp(-(diff * diff / (2 * stdDev * stdDev)));\n}\n", "docstring": "density function of normal distribution .", "partition": "test"}
{"idx": "1192", "code": "@Override public AbstractScannedResult scanBlocklet(BlocksChunkHolder blocksChunkHolder) throws QueryExecutionException {\n  try {\n    fillScannedResult(blocksChunkHolder);\n  }\n catch (  FilterUnsupportedException e) {\n    throw new QueryExecutionException(e.getMessage());\n  }\n  return scannedResult;\n}\n", "docstring": "below method will be used to process the block", "partition": "test"}
{"idx": "802", "code": "public boolean verifyXMLSignature(org.w3c.dom.Element element,java.lang.String certAlias) throws XMLSignatureException {\n  return verifyXMLSignature(element,DEF_ID_ATTRIBUTE,certAlias);\n}\n", "docstring": "verify the signature of the xml document", "partition": "test"}
{"idx": "3393", "code": "public static double rootMeansSquaredError(double[] real,double[] predicted){\n  double ret=0.0;\n  for (int i=0; i < real.length; i++) {\n    ret+=Math.pow((real[i] - predicted[i]),2);\n  }\n  return Math.sqrt(ret / real.length);\n}\n", "docstring": "this returns the root mean squared error of two data sets", "partition": "test"}
{"idx": "144", "code": "protected void processMouseEvent(MouseEvent e){\n  if (myInplaceComponent != null && (MouseEvent.MOUSE_PRESSED == e.getID() || MouseEvent.MOUSE_RELEASED == e.getID())) {\n    finishEditing(true);\n  }\n  super.processMouseEvent(e);\n}\n", "docstring": "when there is an inplace editor we \" listen \" all mouse event and finish editing by any mouse_pressed or mouse_released event . we are acting like yet another glass pane over the standard glass layer .", "partition": "test"}
{"idx": "2812", "code": "public void postProcess(){\n  if (foreignColumnName != null) {\n    foreignAutoRefresh=true;\n  }\n  if (foreignAutoRefresh && maxForeignAutoRefreshLevel == DatabaseField.NO_MAX_FOREIGN_AUTO_REFRESH_LEVEL_SPECIFIED) {\n    maxForeignAutoRefreshLevel=DatabaseField.DEFAULT_MAX_FOREIGN_AUTO_REFRESH_LEVEL;\n  }\n}\n", "docstring": "process the settings when we are going to consume them .", "partition": "test"}
{"idx": "95", "code": "private static void insertValue(final Map<String,List<String>> paramsMap,final String paramVal,final String parameterName){\n  if (paramVal != null) {\n    List<String> list=new ArrayList<>();\n    list.add(paramVal);\n    paramsMap.put(parameterName,list);\n  }\n}\n", "docstring": "puts the given parameter value into a new list object then adds it to the map .", "partition": "test"}
{"idx": "673", "code": "public static int randGaussian(final int mean,final int sd){\n  return (int)(rand.nextGaussian() * sd + mean);\n}\n", "docstring": "generates a normally distributed random number and rounds it .", "partition": "test"}
{"idx": "3634", "code": "private void onTrackPointStart(Attributes attributes){\n  latitude=attributes.getValue(ATTRIBUTE_LAT);\n  longitude=attributes.getValue(ATTRIBUTE_LON);\n  altitude=null;\n  time=null;\n}\n", "docstring": "on track point start .", "partition": "test"}
{"idx": "790", "code": "void release(){\n  imageLoader.cancelPendingRequests();\n  loading=new boolean[noxItems.size()];\n}\n", "docstring": "cancels all the pending noxitem downloads to the imageloader .", "partition": "test"}
{"idx": "812", "code": "public FST(String fileName,String encoding,boolean verbose) throws IOException {\n  FileInputStream fis=new FileInputStream(fileName);\n  try {\n    loadHeaderless(fis,encoding,verbose);\n  }\n  finally {\n    fis.close();\n  }\n}\n", "docstring": "initialise the finite state transducer .", "partition": "test"}
{"idx": "3661", "code": "@Override public void flush(){\n  FlushTask task;\nsynchronized (logRecords) {\n    task=new FlushTask(new ArrayList<String>(logRecords));\n    logRecords.clear();\n  }\n  task.run();\n}\n", "docstring": "flushes the buffered logrecords .", "partition": "test"}
{"idx": "1694", "code": "private void destinationTypeChanged(){\n  if (m_Exp == null)   return;\n  String str=\"\";\n  if (m_ResultsDestinationCBox.getSelectedItem() == DEST_DATABASE_TEXT) {\n    m_ResultsDestinationPathLabel.setText(\"URL:\");\n    str=m_destinationDatabaseURL;\n    m_BrowseDestinationButton.setEnabled(true);\n    m_BrowseDestinationButton.setText(\"User...\");\n  }\n else {\n    m_ResultsDestinationPathLabel.setText(\"Filename:\");\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      int ind=m_destinationFilename.lastIndexOf(\".csv\");\n      if (ind > -1) {\n        m_destinationFilename=m_destinationFilename.substring(0,ind) + \".arff\";\n      }\n    }\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      int ind=m_destinationFilename.lastIndexOf(\".arff\");\n      if (ind > -1) {\n        m_destinationFilename=m_destinationFilename.substring(0,ind) + \".csv\";\n      }\n    }\n    str=m_destinationFilename;\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      int ind=str.lastIndexOf(\".csv\");\n      if (ind > -1) {\n        str=str.substring(0,ind) + \".arff\";\n      }\n    }\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      int ind=str.lastIndexOf(\".arff\");\n      if (ind > -1) {\n        str=str.substring(0,ind) + \".csv\";\n      }\n    }\n    m_BrowseDestinationButton.setEnabled(true);\n    m_BrowseDestinationButton.setText(\"Browse...\");\n  }\n  if (m_ResultsDestinationCBox.getSelectedItem() == DEST_DATABASE_TEXT) {\n    DatabaseResultListener drl=null;\n    try {\n      drl=new DatabaseResultListener();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n    drl.setDatabaseURL(m_destinationDatabaseURL);\n    m_Exp.setResultListener(drl);\n  }\n else {\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      InstancesResultListener irl=new InstancesResultListener();\n      if (!m_destinationFilename.equals(\"\")) {\n        irl.setOutputFile(new File(m_destinationFilename));\n      }\n      m_Exp.setResultListener(irl);\n    }\n else     if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      CSVResultListener crl=new CSVResultListener();\n      if (!m_destinationFilename.equals(\"\")) {\n        crl.setOutputFile(new File(m_destinationFilename));\n      }\n      m_Exp.setResultListener(crl);\n    }\n  }\n  m_ResultsDestinationPathTField.setText(str);\n  m_Support.firePropertyChange(\"\",null,null);\n}\n", "docstring": "responds to a change in the destination type .", "partition": "test"}
{"idx": "839", "code": "public Builder addEmail(Email email){\n  emails.add(email);\n  return this;\n}\n", "docstring": "adds or updates a emil of an existing user if the . getvalue ( ) already exists a update will be done . if not a new one will be added", "partition": "test"}
{"idx": "3761", "code": "public void filledEllipse(double x,double y,double semiMajorAxis,double semiMinorAxis){\n  if (semiMajorAxis < 0)   throw new IllegalArgumentException(\"ellipse semimajor axis can\\'t be negative\");\n  if (semiMinorAxis < 0)   throw new IllegalArgumentException(\"ellipse semiminor axis can\\'t be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * semiMajorAxis);\n  double hs=factorY(2 * semiMinorAxis);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.fill(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "docstring": "draws an ellipse with given semimajor and semiminor axes , centered on ( x , y ) .", "partition": "test"}
{"idx": "3186", "code": "private static void convertToHTML40(AttributeSet from,MutableAttributeSet to){\n  Enumeration keys=from.getAttributeNames();\n  String value=\"\";\n  while (keys.hasMoreElements()) {\n    Object key=keys.nextElement();\n    if (key instanceof CSS.Attribute) {\n      value=value + \" \" + key+ \"=\"+ from.getAttribute(key)+ \";\";\n    }\n else {\n      to.addAttribute(key,from.getAttribute(key));\n    }\n  }\n  if (value.length() > 0) {\n    to.addAttribute(HTML.Attribute.STYLE,value);\n  }\n}\n", "docstring": "copies the given attributeset to a new set , converting any css attributes found to arguments of an html style attribute .", "partition": "test"}
{"idx": "2966", "code": "public void resetCount(){\n  msgCnt.set(0);\n}\n", "docstring": "resets counter to zero .", "partition": "test"}
{"idx": "933", "code": "public static int encodeCacheFlags(Collection<GridClientCacheFlag> flagSet){\n  int bits=0;\n  if (flagSet.contains(GridClientCacheFlag.SKIP_STORE))   bits|=1;\n  return bits;\n}\n", "docstring": "encodes cache flags to bit map .", "partition": "test"}
{"idx": "835", "code": "private static boolean isIdentifierName(String k){\n  int n=k.length();\n  if (n == 0) {\n    return false;\n  }\n  if (!Character.isJavaIdentifierStart(k.charAt(0))) {\n    return false;\n  }\n  for (int i=1; i < n; ++i) {\n    if (!Character.isJavaIdentifierPart(k.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "an ecmascript identifiername is an identifier or reserved word . this is approximate to avoid bringing in extra dependencies .", "partition": "test"}
{"idx": "649", "code": "public synchronized void schedulePeriodicTask(TimerTask task,long period){\n  try {\n    m_timer.scheduleAtFixedRate(task,0,period);\n  }\n catch (  IllegalStateException ie) {\n    m_timer=new Timer();\n    m_timer.scheduleAtFixedRate(task,0,period);\n  }\n}\n", "docstring": "schedule a task that starts immediately", "partition": "test"}
{"idx": "1628", "code": "public static long firstFieldOffset(Class clazz){\n  long minSize=roundUpTo8(headerSize(clazz));\n  while (clazz != Object.class) {\n    for (    Field f : clazz.getDeclaredFields()) {\n      if ((f.getModifiers() & Modifier.STATIC) == 0) {\n        long offset=unsafe.objectFieldOffset(f);\n        if (offset < minSize) {\n          minSize=offset;\n        }\n      }\n    }\n    clazz=clazz.getSuperclass();\n  }\n  return minSize;\n}\n", "docstring": "returns the offset of the first field in the range [ headersize , sizeof ", "partition": "test"}
{"idx": "3767", "code": "private void sortChildren(final JCriteriumTreeNode parentNode){\n  final List<JCriteriumTreeNode> operators=new ArrayList<JCriteriumTreeNode>();\n  final List<JCriteriumTreeNode> conditions=new ArrayList<JCriteriumTreeNode>();\n  final List<JCriteriumTreeNode> minus=new ArrayList<JCriteriumTreeNode>();\n  final Enumeration<?> children=parentNode.children();\n  while (children.hasMoreElements()) {\n    final JCriteriumTreeNode child=(JCriteriumTreeNode)children.nextElement();\n    final ICriterium type=child.getCriterium();\n    if (type instanceof CConditionCriterium) {\n      conditions.add(child);\n    }\n else {\n      operators.add(child);\n    }\n  }\n  parentNode.removeAllChildren();\n  for (  final JCriteriumTreeNode child : operators) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n  for (  final JCriteriumTreeNode child : conditions) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n  for (  final JCriteriumTreeNode child : minus) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n}\n", "docstring": "sorts visible tree nodes .", "partition": "test"}
{"idx": "517", "code": "public SdpException(Throwable rootCause){\n  super(rootCause.getLocalizedMessage());\n}\n", "docstring": "constructs a new sdpexception as a result of a system exception and uses the localized system exception message .", "partition": "test"}
{"idx": "2584", "code": "private static HashMap<BasicBlockPair,HashSet<Register>> findSplitPoints(IR ir,LiveAnalysis live,LSTGraph lst){\n  HashMap<BasicBlockPair,HashSet<Register>> result=new HashMap<BasicBlockPair,HashSet<Register>>(10);\n  for (Enumeration<GraphNode> e=lst.enumerateNodes(); e.hasMoreElements(); ) {\n    LSTNode node=(LSTNode)e.nextElement();\n    BasicBlock header=node.getHeader();\n    BitVector loop=node.getLoop();\n    if (loop == null)     continue;\n    for (Enumeration<BasicBlock> in=header.getIn(); in.hasMoreElements(); ) {\n      BasicBlock bb=in.nextElement();\n      if (loop.get(bb.getNumber()))       continue;\n      HashSet<Register> liveRegisters=live.getLiveRegistersOnEdge(bb,header);\n      for (      Register r : liveRegisters) {\n        if (r.isSymbolic()) {\n          HashSet<Register> s=findOrCreateSplitSet(result,bb,header);\n          s.add(r);\n        }\n      }\n    }\n    for (int i=0; i < loop.length(); i++) {\n      if (loop.get(i)) {\n        BasicBlock bb=ir.getBasicBlock(i);\n        for (Enumeration<BasicBlock> out=bb.getNormalOut(); out.hasMoreElements(); ) {\n          BasicBlock dest=out.nextElement();\n          if (loop.get(dest.getNumber()))           continue;\n          HashSet<Register> liveRegisters=live.getLiveRegistersOnEdge(bb,dest);\n          for (          Register r : liveRegisters) {\n            if (r.isSymbolic()) {\n              HashSet<Register> s=findOrCreateSplitSet(result,bb,dest);\n              s.add(r);\n            }\n          }\n        }\n      }\n    }\n  }\n  addEntriesForInfrequentBlocks(ir,live,result);\n  return result;\n}\n", "docstring": "find the points the ir where live ranges should be split .", "partition": "test"}
{"idx": "74", "code": "public static int unixTimestamp(){\n  return (int)(System.currentTimeMillis() / 1000L);\n}\n", "docstring": "get the seconds since 1970 - 01 - 01 00 : 00 : 00 utc . see http : / / dev . mysql . com / doc / refman / 5 . 1 / en / date - and - time - functions . html # function_unix - timestamp", "partition": "test"}
{"idx": "1976", "code": "public GTSEncoder(long baseTimestamp){\n  this.baseTimestamp=baseTimestamp;\n  this.stream=new ByteArrayOutputStream();\n  this.wrappingKey=null;\n}\n", "docstring": "create an encoder using the given timestamp as its base . base timestamp may be used to encode value timestamps as deltas .", "partition": "test"}
{"idx": "2747", "code": "public void mousePressed(MouseEvent e){\n  int nclicks=SwingUtilities2.getAdjustedClickCount(getComponent(),e);\n  if (SwingUtilities.isLeftMouseButton(e)) {\n    if (e.isConsumed()) {\n      shouldHandleRelease=true;\n    }\n else {\n      shouldHandleRelease=false;\n      adjustCaretAndFocus(e);\n      if (nclicks == 2 && SwingUtilities2.canEventAccessSystemClipboard(e)) {\n        selectWord(e);\n      }\n    }\n  }\n}\n", "docstring": "if button 1 is pressed , this is implemented to request focus on the associated text component , and to set the caret position . if the shift key is held down , the caret will be moved , potentially resulting in a selection , otherwise the caret position will be set to the new location . if the component is not enabled , there will be no request for focus .", "partition": "test"}
{"idx": "1357", "code": "public static void checkNotEmpty(String string){\n  if (string.isEmpty()) {\n    throw new NullPointerException();\n  }\n}\n", "docstring": "ensures that an string reference passed as a parameter to the calling method is not empty .", "partition": "test"}
{"idx": "3689", "code": "public static void o(Zdiagmat D){\n  o(D,Parameters.OutputFieldWidth,Parameters.OutputFracPlaces);\n}\n", "docstring": "prints a zdiagmat in default format .", "partition": "test"}
{"idx": "1437", "code": "public void insertOrRefresh(final KBucketEntry newEntry){\n  if (newEntry == null)   return;\n  List<KBucketEntry> entriesRef=entries;\n  for (  KBucketEntry existing : entriesRef) {\n    if (existing.equals(newEntry)) {\n      existing.mergeInTimestamps(newEntry);\n      return;\n    }\n    if (existing.matchIPorID(newEntry)) {\n      DHT.logInfo(\"new node \" + newEntry + \" claims same ID or IP as \"+ existing+ \", might be impersonation attack or IP change. ignoring until old entry times out\");\n      return;\n    }\n  }\n  if (newEntry.verifiedReachable()) {\n    if (entriesRef.size() < DHTConstants.MAX_ENTRIES_PER_BUCKET) {\n      modifyMainBucket(null,newEntry);\n      return;\n    }\n    if (replaceBadEntry(newEntry))     return;\n    KBucketEntry youngest=entriesRef.get(entriesRef.size() - 1);\n    if (youngest.getCreationTime() > newEntry.getCreationTime() || newEntry.getRTT() * 2.5 < youngest.getRTT()) {\n      modifyMainBucket(youngest,newEntry);\n      insertInReplacementBucket(youngest);\n      return;\n    }\n  }\n  insertInReplacementBucket(newEntry);\n}\n", "docstring": "notify bucket of new incoming packet from a node , perform update or insert existing nodes where appropriate", "partition": "test"}
{"idx": "576", "code": "public final boolean equals(Object object){\n  if (object == null) {\n    return false;\n  }\n  if (!(object instanceof KnowledgeEdge)) {\n    return false;\n  }\n  KnowledgeEdge pair=(KnowledgeEdge)object;\n  return from.equals(pair.from) && to.equals(pair.to);\n}\n", "docstring": "reteurns true if ( from1 , to1 ) = = ( from2 , to2 ) .", "partition": "test"}
{"idx": "1717", "code": "public String requestStatistics(){\n  sb.setLength(0);\n  makeStringBuffer(sb);\n  return sb.toString();\n}\n", "docstring": "a method for other parts of the application to get stats the command processor uses this to report stats on request", "partition": "test"}
{"idx": "1681", "code": "public int scheduledQueueSize(){\n  return schedulerQueueSize.get();\n}\n", "docstring": "get the total number of scheduled requests .", "partition": "test"}
{"idx": "3043", "code": "@Nullable public AvdInfo createOrUpdateAvd(@Nullable AvdInfo currentInfo,@NotNull String avdName,@NotNull Device device,@NotNull SystemImageDescription systemImageDescription,@NotNull ScreenOrientation orientation,boolean isCircular,@Nullable String sdCard,@Nullable File skinFolder,@NotNull Map<String,String> hardwareProperties,boolean createSnapshot){\n  if (!initIfNecessary()) {\n    return null;\n  }\n  File avdFolder;\n  try {\n    if (currentInfo != null) {\n      avdFolder=new File(currentInfo.getDataFolderPath());\n    }\n else {\n      avdFolder=AvdInfo.getDefaultAvdFolder(myAvdManager,avdName,myFileOp,true);\n    }\n  }\n catch (  AndroidLocation.AndroidLocationException e) {\n    IJ_LOG.error(\"Could not create AVD \" + avdName,e);\n    return null;\n  }\n  Dimension resolution=device.getScreenSize(orientation);\n  assert resolution != null;\n  String skinName=null;\n  if (skinFolder == null && isCircular) {\n    skinFolder=getRoundSkin(systemImageDescription);\n  }\n  if (FileUtil.filesEqual(skinFolder,AvdWizardUtils.NO_SKIN)) {\n    skinFolder=null;\n  }\n  if (skinFolder == null) {\n    skinName=String.format(\"%dx%d\",Math.round(resolution.getWidth()),Math.round(resolution.getHeight()));\n  }\n  if (orientation == ScreenOrientation.LANDSCAPE) {\n    hardwareProperties.put(HardwareProperties.HW_INITIAL_ORIENTATION,ScreenOrientation.LANDSCAPE.getShortDisplayValue().toLowerCase(Locale.ROOT));\n  }\n  if (currentInfo != null && !avdName.equals(currentInfo.getName())) {\n    boolean success=myAvdManager.moveAvd(currentInfo,avdName,currentInfo.getDataFolderPath(),SDK_LOG);\n    if (!success) {\n      return null;\n    }\n  }\n  return myAvdManager.createAvd(avdFolder,avdName,systemImageDescription.getSystemImage(),skinFolder,skinName,sdCard,hardwareProperties,device.getBootProps(),createSnapshot,false,currentInfo != null,SDK_LOG);\n}\n", "docstring": "update the given avd with the new settings or create one if no avd is specified . returns the created avd .", "partition": "test"}
{"idx": "3876", "code": "public static int update(String sql,Object[] args){\n  Connection c=null;\n  PreparedStatement p=null;\n  try {\n    c=getConnection();\n    if (c == null)     return -1;\n    p=c.prepareStatement(sql);\n    int order=1;\n    if (args != null) {\n      for (int i=0; i < args.length; i++) {\n        Object o=args[i];\n        setParameter(p,order++,o);\n      }\n    }\n    return p.executeUpdate();\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(sql + toString(args),e);\n  }\n finally {\n    close(p,c);\n  }\n  return 0;\n}\n", "docstring": "update the data using the sql sentence .", "partition": "test"}
{"idx": "2969", "code": "public boolean is_same(Object obj){\n  if (this == obj)   return true;\n  if (obj == null)   return false;\n  if (getClass() != obj.getClass())   return false;\n  HouseNumber other=(HouseNumber)obj;\n  if (number == null) {\n    if (name == null) {\n      if (other.name != null)       return false;\n    }\n else     if (!name.equals(other.name))     return false;\n  }\n else   if (!number.equals(other.number))   return false;\n  if (street == null) {\n    if (other.street != null)     return false;\n  }\n else   if (!street.equals(other.street))   return false;\n  return true;\n}\n", "docstring": "check if address are content identical if number are equals and street ( if number is null , we look at the name )", "partition": "test"}
{"idx": "1088", "code": "public void auditCallhome(OperationTypeEnum auditType,String operationalStatus,String description,Object... descparams){\n  _auditMgr.recordAuditLog(null,null,EVENT_SERVICE_TYPE,auditType,System.currentTimeMillis(),operationalStatus,description,descparams);\n}\n", "docstring": "record audit log for callhome service", "partition": "test"}
{"idx": "349", "code": "public File[] selectImportFiles(final String title,boolean multipleSelection,FileNameExtensionFilter[] fileNameExtensionFilters){\n  if (Boolean.parseBoolean(System.getProperty(\"use.native.choosers\",Boolean.toString(OSType.isMac())))) {\n    FileDialog importDialog=fileDialogs.get(title);\n    if (importDialog == null) {\n      importDialog=new FileDialog(this,title,FileDialog.LOAD);\n      fileDialogs.put(title,importDialog);\n    }\n    importDialog.setVisible(true);\n    if (importDialog.getFile() != null) {\n      return new File[]{new File(importDialog.getDirectory(),importDialog.getFile())};\n    }\n  }\n else {\n    JFileChooser importChooser=fileChoosers.get(title);\n    if (importChooser == null) {\n      importChooser=new JFileChooser(Utils.getCWD());\n      importChooser.setMultiSelectionEnabled(multipleSelection);\n      for (      FileNameExtensionFilter fileNameExtensionFilter : fileNameExtensionFilters) {\n        importChooser.setFileFilter(fileNameExtensionFilter);\n      }\n      importChooser.setDialogTitle(title);\n      fileChoosers.put(title,importChooser);\n    }\n    int returnVal=importChooser.showOpenDialog(this);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n      if (importChooser.isMultiSelectionEnabled()) {\n        return importChooser.getSelectedFiles();\n      }\n else {\n        return new File[]{importChooser.getSelectedFile()};\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "use the native file dialog on the mac because the swing one is bad . on linux , the native one is bad . no preference on windows .", "partition": "test"}
{"idx": "3988", "code": "public static void initUrbanSimZoneWriter(Config config){\n  UrbanSimParameterConfigModuleV3 module=(UrbanSimParameterConfigModuleV3)config.getModule(UrbanSimParameterConfigModuleV3.GROUP_NAME);\n  try {\n    log.info(\"Initializing UrbanSimParcelCSVWriter ...\");\n    parcelWriter=IOUtils.getBufferedWriter(module.getMATSim4OpusTemp() + FILE_NAME);\n    log.info(\"Writing data into \" + module.getMATSim4OpusTemp() + FILE_NAME+ \" ...\");\n    parcelWriter.write(InternalConstants.PARCEL_ID + \",\" + ACCESSIBILITY_BY_FREESPEED+ \",\"+ ACCESSIBILITY_BY_CAR+ \",\"+ ACCESSIBILITY_BY_BIKE+ \",\"+ ACCESSIBILITY_BY_WALK+ \",\"+ ACCESSIBILITY_BY_PT);\n    parcelWriter.newLine();\n    log.info(\"... done!\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "writes the header for zones csv file", "partition": "test"}
{"idx": "3390", "code": "private void sendNextMessageOverNetwork() throws Exception {\n  RawData raw=outgoing.take();\n  if (raw == null)   throw new NullPointerException();\n  sendNext(raw);\n}\n", "docstring": "get the next message from the outgoing queue and send it over the network .", "partition": "test"}
{"idx": "2985", "code": "private void drawCombat(final Graphics2D g2d,final int x,final int y,final int width,final int height){\n  Rectangle2D wrect=entity.getArea();\n  final Rectangle srect=new Rectangle((int)(wrect.getX() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getY() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getWidth() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getHeight() * IGameScreen.SIZE_UNIT_PIXELS));\n  int circleHeight=(int)((srect.height - 2) / SQRT2);\n  circleHeight=Math.max(circleHeight,srect.height - IGameScreen.SIZE_UNIT_PIXELS / 2);\n  if (entity.isAttacking(User.get())) {\n    g2d.setColor(RING_COLOR_ORANGE);\n    g2d.drawOval(srect.x - 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    g2d.drawOval(srect.x,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    g2d.drawOval(srect.x + 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    drawShadedOval(g2d,srect.x + 1,srect.y + srect.height - circleHeight + 1,srect.width - 2,circleHeight - 2,RING_COLOR_ORANGE,true,false);\n  }\n  if (entity.isBeingAttacked()) {\n    Color lineColor;\n    g2d.setColor(RING_COLOR_RED);\n    if (entity.isAttacking(User.get())) {\n      lineColor=RING_COLOR_RED;\n      drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_RED,false,true);\n    }\n else {\n      lineColor=RING_COLOR_DARK_RED;\n      g2d.drawOval(srect.x - 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      g2d.drawOval(srect.x,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      g2d.drawOval(srect.x + 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      drawShadedOval(g2d,srect.x + 1,srect.y + srect.height - circleHeight + 1,srect.width - 2,circleHeight - 2,RING_COLOR_RED,true,false);\n      drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_ORANGE,false,false);\n    }\n    EnumSet<Direction> directions=EnumSet.noneOf(Direction.class);\n    for (    Entity attacker : entity.getAttackers()) {\n      directions.add(Direction.getAreaDirectionTowardsArea(entity.getArea(),attacker.getArea()));\n    }\n    drawArrows(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,directions,lineColor);\n  }\n else   if (entity.isAttacking(User.get())) {\n    drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_ORANGE,false,false);\n  }\n  drawAttack(g2d,x,y,width,height);\n  if (entity.isDefending()) {\n    final int sx=srect.x + srect.width - ICON_OFFSET;\n    final int sy=y + height - 2 * ICON_OFFSET;\nswitch (entity.getResolution()) {\ncase BLOCKED:\n      blockedSprite.draw(g2d,sx,sy);\n    break;\ncase MISSED:\n  missedSprite.draw(g2d,sx,sy);\nbreak;\ncase HIT:\nhitSprite.draw(g2d,sx,sy);\nbreak;\ndefault :\n}\n}\n}\n", "docstring": "draw the combat indicators .", "partition": "test"}
{"idx": "847", "code": "public static void clearAssertionInformation(){\n  _AssertInfos.clear();\n  _AssertOccured=false;\n}\n", "docstring": "clears internal assertion information storage", "partition": "test"}
{"idx": "4135", "code": "public void circle(double x,double y,double r){\n  if (r < 0)   throw new IllegalArgumentException(\"circle radius can\\'t be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * r);\n  double hs=factorY(2 * r);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "docstring": "draws a circle of radius r , centered on ( x , y ) .", "partition": "test"}
{"idx": "410", "code": "private double[] parseVector(String s){\n  String[] entries=WHITESPACE_PATTERN.split(s);\n  double[] d=new double[entries.length];\n  for (int i=0; i < entries.length; i++) {\n    try {\n      d[i]=ParseUtil.parseDouble(entries[i]);\n    }\n catch (    NumberFormatException e) {\n      throw new AbortException(\"Could not parse vector.\");\n    }\n  }\n  return d;\n}\n", "docstring": "parse a string into a vector . todo : move this into utility package ?", "partition": "test"}
{"idx": "2046", "code": "public void classLoaderInit(DynamicClassLoader loader){\n  EnvLoaderListener listener=_listenerRef.get();\n  if (listener != null)   listener.classLoaderInit(loader);\n}\n", "docstring": "handles the case where a class loader is activated .", "partition": "test"}
{"idx": "1324", "code": "@Override public int read(char b[],int off,int len) throws IOException {\n  ensureOpen();\n  if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return 0;\n  }\n  if (pos >= count) {\n    return -1;\n  }\n  if (pos + len > count) {\n    len=count - pos;\n  }\n  if (len <= 0) {\n    return 0;\n  }\n  System.arraycopy(buf,pos,b,off,len);\n  pos+=len;\n  return len;\n}\n", "docstring": "reads characters into a portion of an array .", "partition": "test"}
{"idx": "3228", "code": "private void start(HttpServletRequest request,HttpServletResponse response) throws IOException {\n  String label=request.getParameter(\"start\");\n  String detail=request.getParameter(\"detail\");\n  MonKey key=getMonKey(label,detail,DEFAULT_UNITS);\n  startMon(key);\n  PrintWriter out=response.getWriter();\n  out.println(OK + \": start successfully called on - \" + label);\n}\n", "docstring": "start a monitor by providing a summary label and optionally a detail string . note this won \"'\" t be called unless a label was passed .", "partition": "test"}
{"idx": "795", "code": "public static boolean isFullCopyRestorable(Volume volume,DbClient dbClient){\n  boolean result=false;\n  String replicaState=volume.getReplicaState();\n  if (isVolumeFullCopy(volume,dbClient) && replicaState != null && !replicaState.isEmpty()) {\n    ReplicationState state=ReplicationState.getEnumValue(replicaState);\n    if (state != null && state == ReplicationState.SYNCHRONIZED) {\n      result=true;\n    }\n  }\n  return result;\n}\n", "docstring": "check if the full copy volume could be restored .", "partition": "test"}
{"idx": "455", "code": "public void writeLinkedKml(final String filename,final KmlType kml){\n  if (filename.equals(\"doc.kml\")) {\n    throw new IllegalArgumentException(\"The filename \\'doc.kml\\' is reserved for the primary kml.\");\n  }\n  if (filename.equals(\"main.kml\")) {\n    throw new IllegalArgumentException(\"The filename \\'main.kml\\' is reserved for the main kml.\");\n  }\n  writeKml(filename,kml);\n}\n", "docstring": "adds the specified kml - object to the file .", "partition": "test"}
{"idx": "81", "code": "public void testDivideRoundHalfUpPos(){\n  String a=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=-24;\n  String b=\"7472334223847623782375469293018787918347987234564568\";\n  int bScale=13;\n  String c=\"1.24390557635720517122423359799284E+53\";\n  int resScale=-21;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  BigDecimal result=aNumber.divide(bNumber,resScale,BigDecimal.ROUND_HALF_UP);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",resScale,result.scale());\n}\n", "docstring": "divide : rounding mode is round_half_up , result is positive ; distance = - 1", "partition": "test"}
{"idx": "165", "code": "private void checkInteriorIntersections(){\n  for (Iterator i=segStrings.iterator(); i.hasNext(); ) {\n    SegmentString ss0=(SegmentString)i.next();\n    for (Iterator j=segStrings.iterator(); j.hasNext(); ) {\n      SegmentString ss1=(SegmentString)j.next();\n      checkInteriorIntersections(ss0,ss1);\n    }\n  }\n}\n", "docstring": "checks all pairs of segments for intersections at an interior point of a segment", "partition": "test"}
{"idx": "1991", "code": "public synchronized boolean add(E e,boolean hasNext){\n  while (mInternalQueue.size() >= mMaxSize && !mClosed) {\n    notifyAll();\n    try {\n      wait(TIMEOUT);\n    }\n catch (    InterruptedException e1) {\n      mClosed=true;\n      ProgramState.checkAbort();\n      throw new IllegalStateException(\"Interrupted but program not aborting?\",e1);\n    }\n    ProgramState.checkAbort();\n  }\n  if (mClosed) {\n    return true;\n  }\n  final boolean wasEmpty=mInternalQueue.isEmpty();\n  mHasNext=hasNext;\n  mInternalQueue.add(e);\n  if (wasEmpty) {\n    notifyAll();\n  }\n  return true;\n}\n", "docstring": "add method which also set whether there is a next value", "partition": "test"}
{"idx": "531", "code": "protected String format(Object o){\n  return o.toString();\n}\n", "docstring": "default object formatter using object . tostring ( ) .", "partition": "test"}
{"idx": "3293", "code": "public void addAll(Collection<? extends T> collection){\n  if (mEventDelegate != null)   mEventDelegate.addData(collection == null ? 0 : collection.size());\n  if (collection != null && collection.size() != 0) {\nsynchronized (mLock) {\n      mObjects.addAll(collection);\n    }\n  }\n  if (mNotifyOnChange)   notifyDataSetChanged();\n}\n", "docstring": "adds the specified collection at the end of the array .", "partition": "test"}
{"idx": "555", "code": "private void updateActions(final INaviAddressSpace addressSpace){\n  m_loadAddressSpaceAction.setEnabled(!addressSpace.isLoaded());\n}\n", "docstring": "updates the menu actions depending on the state of the given address space .", "partition": "test"}
{"idx": "3543", "code": "public static <T>List<T> rest(List<T> l){\n  return l.subList(1,l.size());\n}\n", "docstring": "get a sublist of all of the elements in the list except for first .", "partition": "test"}
{"idx": "3522", "code": "private JsonObject createRequest(Map<String,Object> headers,String uri,HttpMethod method,JsonObject payload){\n  JsonObject request=new JsonObject();\n  JsonArray jsonHeaders=new JsonArray();\n  headers.forEach(null);\n  request.put(\"headers\",jsonHeaders);\n  request.put(\"uri\",uri);\n  request.put(\"method\",method.toString());\n  request.put(\"payload\",payload);\n  return request;\n}\n", "docstring": "creates a new request with the given parameters .", "partition": "test"}
{"idx": "4219", "code": "public void addLayer(final LayerDefinition layer){\n  layer.setMap(this);\n  layers.add(layer);\n}\n", "docstring": "adds a new layer to the map .", "partition": "test"}
{"idx": "260", "code": "public static IKeyBuilder newInstance(int capacity,CollatorEnum collatorChoice,Locale locale,Object strength,DecompositionEnum mode){\n  if (collatorChoice == CollatorEnum.ASCII) {\n    return new KeyBuilder(capacity);\n  }\n  if (locale == null) {\n    locale=Locale.getDefault();\n    if (log.isInfoEnabled())     log.info(\"Using default locale: \" + locale.getDisplayName());\n  }\n  final boolean icu=collatorChoice == CollatorEnum.ICU;\n  if (icu && !DefaultKeyBuilderFactory.isICUAvailable()) {\n    throw new UnsupportedOperationException(DefaultKeyBuilderFactory.ICU_NOT_AVAILABLE);\n  }\n  final byte[] buf=createBuffer(capacity);\n  final int len=0;\nswitch (collatorChoice) {\ncase ICU:\n    return new KeyBuilder(new ICUSortKeyGenerator(locale,strength,mode),len,buf);\ncase JDK:\n  return new KeyBuilder(new JDKSortKeyGenerator(locale,strength,mode),len,buf);\ndefault :\nthrow new UnsupportedOperationException(\"Collator not supported: \" + collatorChoice);\n}\n}\n", "docstring": "create a new instance that optionally supports unicode sort keys .", "partition": "test"}
{"idx": "2345", "code": "public boolean addToActiveList(DownloadInfoRunnable downloadInfoRunnable){\n  return activeListHasRoom() && mActiveList.add(downloadInfoRunnable);\n}\n", "docstring": "tries to add a download object to the active list . will not work if the max number of downloads is already reached .", "partition": "test"}
{"idx": "1189", "code": "public void removeColumn(Column column){\n  if (column != null) {\n    columns.remove(column);\n  }\n}\n", "docstring": "removes the given column .", "partition": "test"}
{"idx": "931", "code": "public void playMedia(boolean showPlayerWindow){\n  String filename=stopAndPrepareFilename();\n  if (filename.length() > 0) {\n    MPlayerMediator mplayerMediator=MPlayerMediator.instance();\n    if (mplayerMediator != null) {\n      mplayerMediator.showPlayerWindow(showPlayerWindow);\n    }\n    mplayer.open(filename,getAdjustedVolume());\n  }\n  notifyState(getState());\n}\n", "docstring": "force showing or not the media player window", "partition": "test"}
{"idx": "3359", "code": "public void accept(AbstractReporter r){\n  r.testStart(this);\n  r.browserInfoEntry(browserInfoEntry);\n  Iterator<LogEntry> entryIterator=logEntries.iterator();\n  while (entryIterator.hasNext()) {\n    LogEntry entry=entryIterator.next();\n    if (!entryIterator.hasNext()) {\n      entry.setLast(true);\n    }\n    visit(entry,r);\n  }\n  r.testEnd(this);\n}\n", "docstring": "implementation of visitor pattern . takes the report for a guided tour through all information stored in the testinfo instance , from start of the test to all entries to test end . it is up to a particular implementation of the reporter to react to different types of test info and log entries . < br > also , detects the last log entry on the fly .", "partition": "test"}
{"idx": "407", "code": "public boolean isLeaf(Object nd){\n  Node node=(Node)nd;\n  return !node.hasChildNodes();\n}\n", "docstring": "gets the leaf attribute of the domtreemodel object", "partition": "test"}
{"idx": "2339", "code": "public DrawingAttributes(){\n  propertyChangeSupport=new PropertyChangeSupport(this);\n}\n", "docstring": "create a drawingattributes with the default settings - clear fill paint and pattern , sold black edge line of width 1 .", "partition": "test"}
{"idx": "2744", "code": "public static void join(final AsyncInvocation<?> async,final long timeoutMilliseconds){\n  join(async.getThread(),timeoutMilliseconds);\n}\n", "docstring": "wait for a thread to join .", "partition": "test"}
{"idx": "3001", "code": "public static void logStackTrace(Level level,Throwable throwable){\n  logStackTrace(level,throwable,null);\n}\n", "docstring": "logs the stack trace for the given throwable if logger is initialized else prints the stack trace using system . out .", "partition": "test"}
{"idx": "2899", "code": "public void printBytes(byte[] data,int offset,int length) throws IOException {\n  int i;\n  for (; length >= 3; length-=3) {\n    int chunk=(((data[offset] & 0xff) << 16) + ((data[offset + 1] & 0xff) << 8) + (data[offset + 2] & 0xff));\n    os.write(base64encode(chunk >> 18));\n    os.write(base64encode(chunk >> 12));\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    offset+=3;\n  }\n  if (length == 2) {\n    int chunk=((data[offset] & 0xff) << 8) + (data[offset + 1] & 0xff);\n    os.write(base64encode(chunk >> 12));\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    os.write('=');\n  }\n else   if (length == 1) {\n    int chunk=data[offset] & 0xff;\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    os.write('=');\n    os.write('=');\n  }\n}\n", "docstring": "prints a byte array to the stream , properly encoded in base64 .", "partition": "test"}
{"idx": "898", "code": "protected void tearDown(){\n  try {\n    ds.close();\n    sds.close();\n  }\n catch (  Exception e) {\n  }\n}\n", "docstring": "tears down the fixture , for example , close a network connection . this method is called after a test is executed .", "partition": "test"}
{"idx": "3182", "code": "public InSpacePredicate(Object... values){\n  _inValues=new HashSet<Object>();\n  for (  Object value : values) {\n    _inValues.add(value);\n  }\n}\n", "docstring": "creates an in predicate using the specified values .", "partition": "test"}
{"idx": "3580", "code": "public boolean isRouteToDestValid(Block protecting,Block destination){\n  if (protecting == destination) {\n    log.debug(\"protecting and destination blocks are the same therefore we need to check if we have a valid neighbour\");\n    if (getAdjacency(protecting) != null) {\n      return true;\n    }\n  }\n else   if (getValidRoute(protecting,destination) != null) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "is the route to the destination block , going via our neighbouring block valid . ie does the block have a route registered via neighbour \" protecting \" to the destination block .", "partition": "test"}
{"idx": "1684", "code": "public void testMultiplyDiffScalePosNeg(){\n  String a=\"1231212478987482988429808779810457634781384756794987\";\n  int aScale=10;\n  String b=\"747233429293018787918347987234564568\";\n  int bScale=-10;\n  String c=\"920003122862175749786430095741145455670101391569026662845893091880727173060570190220616\";\n  int cScale=0;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  BigDecimal result=aNumber.multiply(bNumber);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",cScale,result.scale());\n}\n", "docstring": "multiply two numbers of different scales", "partition": "test"}
{"idx": "263", "code": "@Override public void addRelations(Task task,Iterable<ObjectId> projectIds,String fieldName){\n  List<Project> newProjectList=new LinkedList<>();\n  Iterable<Project> projectsToAdd=projectRepository.findAll(projectIds,null);\n  for (  Project project : projectsToAdd) {\n    newProjectList.add(project);\n  }\n  try {\n    if (PropertyUtils.getProperty(task,fieldName) != null) {\n      Iterable<Project> projects=(Iterable<Project>)PropertyUtils.getProperty(task,fieldName);\n      for (      Project project : projects) {\n        newProjectList.add(project);\n      }\n    }\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  try {\n    PropertyUtils.setProperty(task,fieldName,newProjectList);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  taskRepository.save(task);\n}\n", "docstring": "a simple implementation of the addrelations method which presents the general concept of the method . it should not be used in production because of possible race condition - production ready code should perform an atomic operation .", "partition": "test"}
{"idx": "2207", "code": "public void appendSplitElement(Fragment aSplit){\n  splits.add(aSplit);\n}\n", "docstring": "adds a split element at the end", "partition": "test"}
{"idx": "3549", "code": "public static double[] HPDInterval(double proportion,double[] x,int[] indices){\n  double minRange=Double.MAX_VALUE;\n  int hpdIndex=0;\n  final int diff=(int)Math.round(proportion * (double)x.length);\n  for (int i=0; i <= (x.length - diff); i++) {\n    final double minValue=x[indices[i]];\n    final double maxValue=x[indices[i + diff - 1]];\n    final double range=Math.abs(maxValue - minValue);\n    if (range < minRange) {\n      minRange=range;\n      hpdIndex=i;\n    }\n  }\n  return new double[]{x[indices[hpdIndex]],x[indices[hpdIndex + diff - 1]]};\n}\n", "docstring": "determine the highest posterior density for a list of values . the hpd is the smallest interval containing the required amount of elements .", "partition": "test"}
{"idx": "183", "code": "public Statement between(Object former,Object later){\n  statement.append(\" BETWEEN \");\n  append(former);\n  statement.append(\" AND \");\n  append(later);\n  return this;\n}\n", "docstring": "appending the between operator clause .", "partition": "test"}
{"idx": "483", "code": "private Parameters(){\n  for (Iterator i=arguments.iterator(); i.hasNext(); ) {\n    String arg=(String)i.next();\n    arg=arg.toLowerCase();\n    if (!arg.startsWith(\"-\"))     throw new IllegalArgumentException(\"Command-line argument does not start with \\'-\\': \" + arg);\n    int colonIndex=arg.indexOf(\":\");\n    String key;\n    String value;\n    if (colonIndex >= 0) {\n      key=arg.substring(1,colonIndex);\n      value=arg.substring(colonIndex + 1);\n    }\n else {\n      key=arg.substring(1);\n      value=\"\";\n    }\n    if (!allowedKeys.contains(key))     throw new IllegalArgumentException(\"Unrecognized command-line argument: \" + arg.substring(1) + \". Valid arguments are: \"+ StringUtil.toCommaDelimitedString(allowedKeys));\n    hashtable.put(key,value);\n  }\n  for (Iterator i=requiredKeys.iterator(); i.hasNext(); ) {\n    String requiredKey=(String)i.next();\n    if (!hashtable.containsKey(requiredKey))     throw new IllegalArgumentException(\"Required command-line argument is missing: \" + requiredKey);\n  }\n}\n", "docstring": "creates a parameters object for the given main - method arguments .", "partition": "test"}
{"idx": "346", "code": "public static boolean containIP(int cidrPrefix,int cidrMaskBits,int ip){\n  boolean matched=true;\n  int bitsToShift=32 - cidrMaskBits;\n  if (bitsToShift > 0) {\n    cidrPrefix=cidrPrefix >> bitsToShift;\n    ip=ip >> bitsToShift;\n    cidrPrefix=cidrPrefix << bitsToShift;\n    ip=ip << bitsToShift;\n  }\n  if (cidrPrefix != ip) {\n    matched=false;\n  }\n  return matched;\n}\n", "docstring": "check whether the cidr address contains the ip address", "partition": "test"}
{"idx": "3989", "code": "public final void delayTask(@NotNull TransactionRunnable task){\n  myDelayedTasks.add(task);\n}\n", "docstring": "delay task to be executed after refresh", "partition": "test"}
{"idx": "1972", "code": "private void destroyBeans(Map<String,Object> viewMap,Map<String,ViewScopeContextObject> contextMap){\n  ArrayList<String> removalNameList=new ArrayList<>();\n  if (contextMap != null) {\n    for (    Map.Entry<String,ViewScopeContextObject> entry : contextMap.entrySet()) {\n      String passivationCapableId=entry.getKey();\n      Contextual contextual=beanManager.getPassivationCapableBean(passivationCapableId);\n      ViewScopeContextObject contextObject=entry.getValue();\n      CreationalContext creationalContext=beanManager.createCreationalContext(contextual);\n      contextual.destroy(viewMap.get(contextObject.getName()),creationalContext);\n      removalNameList.add(contextObject.getName());\n    }\n    Iterator<String> removalNames=removalNameList.iterator();\n    while (removalNames.hasNext()) {\n      String name=removalNames.next();\n      viewMap.remove(name);\n    }\n    contextMap.clear();\n  }\n}\n", "docstring": "destroy the view scoped beans for the given view and context map .", "partition": "test"}
{"idx": "3447", "code": "public static List<File> findFilesInDir(File directory,FilenameFilter filter){\n  Vector<File> files=new Vector<File>();\n  File[] entries=directory.listFiles();\n  for (  File entry : entries) {\n    if (filter == null || filter.accept(directory,entry.getName())) {\n      files.add(entry);\n    }\n    if (entry.isDirectory()) {\n      files.addAll(findFilesInDir(entry,filter));\n    }\n  }\n  return files;\n}\n", "docstring": "given a java . io . file representing a directory , list all the files underneath that directory matching the given filenamefilter .", "partition": "test"}
{"idx": "3458", "code": "public static String generateNativeGuidForStoragePortFromIndication(String sourceInstanceSystemName,String portNetworkId){\n  String[] splitedString=sourceInstanceSystemName.split(Constants.PATH_DELIMITER_REGEX);\n  return String.format(\"%s+%s+PORT+%s\",splitedString[0],splitedString[1],portNetworkId);\n}\n", "docstring": "fc port value from indication sourceinstancesystemname : symmetrix + 000198700406 + fa - 1e iscsi port value from indication sourceinstancesystemname : symmetrix + 000198700406 + se - 1g", "partition": "test"}
{"idx": "2546", "code": "private void loadBinary(DataInputStream is) throws IOException {\n  if (is.readInt() != MAGIC) {\n    throw new Error(\"Bad magic in db\");\n  }\n  if (is.readInt() != VERSION) {\n    throw new Error(\"Bad VERSION in db\");\n  }\n  continuityWeight=is.readInt();\n  optimalCoupling=is.readInt();\n  extendSelections=is.readInt();\n  joinMethod=is.readInt();\n  joinWeightShift=is.readInt();\n  int weightLength=is.readInt();\n  joinWeights=new int[weightLength];\n  for (int i=0; i < joinWeights.length; i++) {\n    joinWeights[i]=is.readInt();\n  }\n  int unitsLength=is.readInt();\n  units=new DatabaseClusterUnit[unitsLength];\n  for (int i=0; i < units.length; i++) {\n    units[i]=new DatabaseClusterUnit(is);\n  }\n  int unitTypesLength=is.readInt();\n  unitTypes=new UnitType[unitTypesLength];\n  for (int i=0; i < unitTypes.length; i++) {\n    unitTypes[i]=new UnitType(is);\n  }\n  sts=new SampleSet(is);\n  mcep=new SampleSet(is);\n  int numCarts=is.readInt();\n  cartMap=new HashMap();\n  for (int i=0; i < numCarts; i++) {\n    String name=Utilities.getString(is);\n    CART cart=CARTImpl.loadBinary(is);\n    cartMap.put(name,cart);\n    if (defaultCart == null) {\n      defaultCart=cart;\n    }\n  }\n}\n", "docstring": "loads the database from the given input stream .", "partition": "test"}
{"idx": "3948", "code": "public void configs(SwtPlatform... platforms){\n  configs(Arrays.asList(platforms));\n}\n", "docstring": "adds the given location to be the target for artifacts .", "partition": "test"}
{"idx": "1252", "code": "static TemplateModelException newMethodArgInvalidValueException(String methodName,int argIdx,Object... details){\n  return new _TemplateModelException(methodName,\"(...) argument #\",Integer.valueOf(argIdx + 1),\" had invalid value: \",details);\n}\n", "docstring": "the type of the argument was good , but it \"'\" s value wasn \"'\" t .", "partition": "test"}
{"idx": "449", "code": "public MultiTermQuery(final String field){\n  this.field=Objects.requireNonNull(field,\"field must not be null\");\n}\n", "docstring": "constructs a query matching terms that cannot be represented with a single term .", "partition": "test"}
{"idx": "1796", "code": "@JsonCreator public DataSourceMetadata(@JsonProperty(\"name\") String name,@JsonProperty(\"properties\") Map<String,String> properties,@JsonProperty(\"segments\") List<DataSegment> segments){\n  this.name=name;\n  this.properties=Collections.unmodifiableMap(properties);\n  this.segments=Collections.unmodifiableList(segments);\n}\n", "docstring": "store the full metadata for a druid data source , mainly as a list of segments .", "partition": "test"}
{"idx": "751", "code": "static CipherSuite valueOf(int id1,int id2){\n  id1&=0xff;\n  id2&=0xff;\n  int id=(id1 << 8) | id2;\n  CipherSuite c=idMap.get(id);\n  if (c == null) {\n    String h1=Integer.toString(id1,16);\n    String h2=Integer.toString(id2,16);\n    c=new CipherSuite(\"Unknown 0x\" + h1 + \":0x\"+ h2,id);\n  }\n  return c;\n}\n", "docstring": "return a ciphersuite with the given id . a temporary object is constructed if the id is unknown . use isavailable ( ) to verify that the ciphersuite can actually be used .", "partition": "test"}
{"idx": "627", "code": "public static String[] split(String original,String separator){\n  Vector nodes=new Vector();\n  int index=original.indexOf(separator);\n  while (index >= 0) {\n    nodes.addElement(original.substring(0,index));\n    original=original.substring(index + separator.length());\n    index=original.indexOf(separator);\n  }\n  nodes.addElement(original);\n  String[] ret=new String[nodes.size()];\n  for (int i=0; i < nodes.size(); i++) {\n    ret[i]=(String)nodes.elementAt(i);\n  }\n  return ret;\n}\n", "docstring": "provides a utility method breaks a given string to array of string according to the given separator", "partition": "test"}
{"idx": "1590", "code": "private void ensureBufferCapacity(int desiredCapacity){\n  int capacity=pixelBuffer.length;\n  while (capacity < desiredCapacity) {\n    capacity*=2;\n  }\n  if (capacity > pixelBuffer.length) {\n    pixelBuffer=new byte[capacity];\n  }\n}\n", "docstring": "grow the pixel buffer if necessary . using this method instead of allocating a new buffer every time a frame is grabbed improves performance by reducing the frequency of garbage collections . in a simple test , the unmodified version of ipcameraframegrabber caused about 200mb of allocations within 13 seconds . in this version , almost no additional heap space is typically allocated per frame . the downside to this is that the returned frames can \"'\" t really be modified , so this probably won \"'\" t go upstream , but it \"'\" s useful for us because in grip we don \"'\" t operate on images in - place .", "partition": "test"}
{"idx": "1022", "code": "public Date modifiedDate(String path) throws IllegalStateException, IOException, FTPIllegalReplyException, FTPException {\nsynchronized (lock) {\n    if (!connected) {\n      throw new IllegalStateException(\"Client not connected\");\n    }\n    if (!authenticated) {\n      throw new IllegalStateException(\"Client not authenticated\");\n    }\n    communication.sendFTPCommand(\"MDTM \" + path);\n    FTPReply r=communication.readFTPReply();\n    touchAutoNoopTimer();\n    if (!r.isSuccessCode()) {\n      throw new FTPException(r);\n    }\n    String[] messages=r.getMessages();\n    if (messages.length != 1) {\n      throw new FTPIllegalReplyException();\n    }\n else {\n      try {\n        return MDTM_DATE_FORMAT.parse(messages[0]);\n      }\n catch (      ParseException e) {\n        throw new FTPIllegalReplyException();\n      }\n    }\n  }\n}\n", "docstring": "this method asks and returns the last modification date of a file or directory .", "partition": "test"}
{"idx": "206", "code": "private static void _trustAllHttpsCertificates(){\n  SSLContext context;\n  if (_trustManagers == null) {\n    _trustManagers=new TrustManager[]{new FakeX509TrustManager()};\n  }\n  try {\n    context=SSLContext.getInstance(\"SSL\");\n    context.init(null,_trustManagers,new SecureRandom());\n  }\n catch (  GeneralSecurityException gse) {\n    throw new IllegalStateException(gse.getMessage());\n  }\n  HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n}\n", "docstring": "set the default x509 trust manager to an instance of a fake class that trust all certificates , even the self - signed ones .", "partition": "test"}
{"idx": "3413", "code": "public GetBufferedRandomAccessSource(IRandomAccessSource source){\n  this.source=source;\n  this.getBuffer=new byte[(int)Math.min(Math.max(source.length() / 4,1),4096)];\n  this.getBufferStart=-1;\n  this.getBufferEnd=-1;\n}\n", "docstring": "constructs a new offsetrandomaccesssource", "partition": "test"}
{"idx": "487", "code": "public static byte[] randomBytes(int size){\n  byte[] bytes=new byte[size];\n  seededRandom.nextBytes(bytes);\n  return bytes;\n}\n", "docstring": "generate an array of random bytes", "partition": "test"}
{"idx": "702", "code": "String format(Object obj,StringBuffer toAppendTo) throws IllegalArgumentException {\n  Date source=null;\n  if (obj instanceof Date) {\n    source=(Date)obj;\n  }\n else   if (obj instanceof String) {\n    try {\n      source=parse((String)obj);\n    }\n catch (    ParseException pe) {\n      throw new RuntimeException(pe.toString());\n    }\n  }\n  if (source == null) {\n    throw new IllegalArgumentException((obj == null) ? \"null\" : obj.toString());\n  }\n  return format(source,toAppendTo);\n}\n", "docstring": "format a given object .", "partition": "test"}
{"idx": "1241", "code": "public void register(GridCacheTtlManager mgr){\nsynchronized (mux) {\n    if (cleanupWorker == null)     startCleanupWorker();\n    mgrs.add(mgr);\n  }\n}\n", "docstring": "register ttl manager of cache for periodical check on expired entries .", "partition": "test"}
{"idx": "2407", "code": "void purgeLastArticles(int amountToPurge){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  String query=\"_id IN ( SELECT _id FROM \" + TABLE_ARTICLES + \" WHERE isPublished=0 AND isStarred=0 ORDER BY updateDate DESC LIMIT -1 OFFSET \"+ (Utils.ARTICLE_LIMIT - amountToPurge + \")\");\n  safelyDeleteArticles(query,null);\n  Log.d(TAG,\"purgeLastArticles took \" + (System.currentTimeMillis() - time) + \"ms\");\n}\n", "docstring": "delete given amount of last updated articles from db . published and starred articles are ignored so the configured limit is not an exact upper limit to the number of articles in the database .", "partition": "test"}
{"idx": "1720", "code": "public static String slurpURLNoExceptions(URL u,String encoding){\n  try {\n    return slurpURL(u,encoding);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return null;\n  }\n}\n", "docstring": "returns all the text at the given url .", "partition": "test"}
{"idx": "1663", "code": "@Override public void processNewLines(String[] lines){\n  for (  String line : lines) {\n    if (line.startsWith(\"idx\")) {\n      continue;\n    }\n    if (line.contains(\"No such file\")) {\n      myIsFileMissing=true;\n      return;\n    }\n    String[] values=line.split(LINE_SPLIT_REGEX);\n    if (values.length < INDEX_OF_TX_BYTES) {\n      continue;\n    }\n    try {\n      int lineUid=Integer.parseInt(values[INDEX_OF_UID]);\n      if (myUid == lineUid) {\n        int tempRxBytes=Integer.parseInt(values[INDEX_OF_RX_BYTES]);\n        int tempTxBytes=Integer.parseInt(values[INDEX_OF_TX_BYTES]);\n        if (tempRxBytes < 0 || tempTxBytes < 0) {\n          LOG.warning(String.format(\"Negative rxBytes %1$d and/or txBytes %2$d in %3$s\",tempRxBytes,tempTxBytes,line));\n          continue;\n        }\n        myRxBytes+=tempRxBytes;\n        myTxBytes+=tempTxBytes;\n      }\n    }\n catch (    NumberFormatException e) {\n      LOG.warning(String.format(\"Expected int value, instead got uid %1$s, rxBytes %2$s, txBytes %3$s in %4$s\",values[INDEX_OF_UID],values[INDEX_OF_RX_BYTES],values[INDEX_OF_TX_BYTES],line));\n    }\n  }\n}\n", "docstring": "processes the stats line to sum up all network stats belonging to the uid .", "partition": "test"}
{"idx": "2392", "code": "private static void addItemsToList(int startIndex,int endIndex){\n  for (int i=startIndex; i < endIndex; i++) {\n    values.add(new Integer(i));\n  }\n}\n", "docstring": "adds the items to the list . items added to the list are numbers and letters .", "partition": "test"}
{"idx": "2581", "code": "public static String toRegex(String glob,String separator){\n  checkNotNull(separator,\"separator must be non-null\");\n  checkArgument(separator.length() == 1,\"separator must be a single character: %s\",separator);\n  return toRegex(glob,separator.charAt(0));\n}\n", "docstring": "converts the given glob pattern into a regular expression .", "partition": "test"}
{"idx": "378", "code": "static Object ensureNotNull(Location location,Object value){\n  if (value == null) {\n    throw new EvalException(location,\"Snippet runtime does not support null values.\");\n  }\n  return value;\n}\n", "docstring": "ensure the given value is not null and return it .", "partition": "test"}
{"idx": "1573", "code": "public ThreadPool(String name,int poolSize){\n  this.poolSize=poolSize;\n  this.poolName=name;\n  taskList=new LinkedList<Runnable>();\n  threads=new WorkerThread[poolSize];\n  createThreads();\n}\n", "docstring": "constructs a thread pool with given parameters .", "partition": "test"}
{"idx": "1732", "code": "public void testSetNull() throws Exception {\n  PreparedStatement stmt=connection.prepareStatement(\"INSERT INTO test_blob(id, bin_data) VALUES(?, ?)\");\n  try {\n    stmt.setInt(1,1);\n    stmt.setBytes(2,null);\n    stmt.executeUpdate();\n    stmt.setInt(1,2);\n    stmt.setBinaryStream(2,null,0);\n    stmt.executeUpdate();\n    stmt.setInt(1,3);\n    stmt.setString(2,null);\n    stmt.executeUpdate();\n  }\n  finally {\n    stmt.close();\n  }\n}\n", "docstring": "this method checks if we correctly handle assigning null values to blobs .", "partition": "test"}
{"idx": "4150", "code": "public void onIdleBegin(){\n  _idleCount.incrementAndGet();\n}\n", "docstring": "called by the thread before going into the idle state .", "partition": "test"}
{"idx": "3305", "code": "public boolean canGetInt(){\n  return canGet(int.class);\n}\n", "docstring": "indicates if convenience get method can be called without an exception being thrown for the int type .", "partition": "test"}
{"idx": "58", "code": "public String fadeAudio(String path,String type,double fadeInLength,double stopTime,double fadeOutLength) throws IOException {\n  final List<String> curves=Arrays.asList(new String[]{\"q\",\"h\",\"t\",\"l\",\"p\"});\n  if (!curves.contains(type)) {\n    throw new RuntimeException(\"fadeAudio: passed invalid type: \" + type);\n  }\n  File file=new File(path);\n  String outFile=file.getCanonicalPath() + \"_faded.wav\";\n  ArrayList<String> cmd=new ArrayList<String>();\n  cmd.add(soxBin);\n  cmd.add(path);\n  cmd.add(outFile);\n  cmd.add(\"fade\");\n  cmd.add(type);\n  cmd.add(fadeInLength + \"\");\n  if (stopTime != -1)   cmd.add(stopTime + \"\");\n  if (fadeOutLength != -1)   cmd.add(fadeOutLength + \"\");\n  try {\n    int rc=execSox(cmd,callback);\n    if (rc != 0) {\n      outFile=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return outFile;\n}\n", "docstring": "fade audio file sox < path > outfile fade < type > < fadeinlength > < stoptime > < fadeoutlength >", "partition": "test"}
{"idx": "4093", "code": "@SneakyThrows public void addKeyToKeystore(KeyStore keyStore,X509Certificate cert,RSAPrivateKey privateKey,String alias,String password){\n  KeyStore.PasswordProtection pass=new KeyStore.PasswordProtection(password.toCharArray());\n  Certificate[] certificateChain={cert};\n  keyStore.setEntry(alias,new KeyStore.PrivateKeyEntry(privateKey,certificateChain),pass);\n}\n", "docstring": "based on a public certificate , private key , alias and password , this method will load the certificate and private key as an entry into the keystore , and it will set the provided alias and password to the keystore entry .", "partition": "test"}
{"idx": "2848", "code": "public boolean initDialog(){\n  log.config(\"\");\n  gbc.anchor=GridBagConstraints.NORTHWEST;\n  gbc.weightx=0;\n  gbc.weighty=0;\n  gbc.gridy=m_line++;\n  gbc.gridx=0;\n  gbc.gridwidth=1;\n  gbc.insets=nullInset;\n  gbc.fill=GridBagConstraints.HORIZONTAL;\n  centerPanel.add(Box.createVerticalStrut(10),gbc);\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = \\'Y\\' \"+ \"                 AND p.IsActive = \\'Y\\' \"+ \"                 AND l.IsActive = \\'Y\\' \"+ \"                 AND cl.IsActive = \\'Y\\' \"+ \"                 AND pp.ASP_Status = \\'S\\') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = \\'Y\\' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = \\'S\\') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = \\'Y\\' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = \\'H\\')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, p.ReadOnlyLogic, p.DisplayLogic, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive=\\'Y\\' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, p.ReadOnlyLogic, p.DisplayLogic, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language=\\'\" + Env.getAD_Language(Env.getCtx()) + \"\\'\"+ \" AND p.IsActive=\\'Y\\' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs);\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_vEditors.size() || m_mFields2.size() != m_vEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    gbc.gridy=m_line++;\n    centerPanel.add(Box.createVerticalStrut(10),gbc);\n    gbc.gridx=3;\n    centerPanel.add(Box.createHorizontalStrut(12),gbc);\n    AEnv.positionCenterWindow(m_frame,this);\n  }\n else   dispose();\n  return hasFields;\n}\n", "docstring": "read fields to display", "partition": "test"}
{"idx": "1463", "code": "public void registerManufacturerSpecificBuilder(int companyId,ADManufacturerSpecificBuilder builder){\n  if (companyId < 0 || 0xFFFF < companyId) {\n    String message=String.format(\"\\'companyId\\' is out of the valid range: %d\",companyId);\n    throw new IllegalArgumentException(message);\n  }\n  if (builder == null) {\n    return;\n  }\n  Integer key=Integer.valueOf(companyId);\n  List<ADManufacturerSpecificBuilder> builders=mMSBuilders.get(key);\n  if (builders == null) {\n    builders=new ArrayList<ADManufacturerSpecificBuilder>();\n    mMSBuilders.put(key,builders);\n  }\n  builders.add(0,builder);\n}\n", "docstring": "register a builder for the company id . the given builder is added at the beginning of the list of the builders for the company id .", "partition": "test"}
{"idx": "2676", "code": "public static boolean equals(boolean[] field1,boolean[] field2){\n  if (field1 == null || field1.length == 0) {\n    return field2 == null || field2.length == 0;\n  }\n else {\n    return Arrays.equals(field1,field2);\n  }\n}\n", "docstring": "checks repeated boolean field equality ; null - value and 0 - length fields are considered equal .", "partition": "test"}
{"idx": "1764", "code": "final public void println(char v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    out.write(v);\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a character followed by a newline .", "partition": "test"}
{"idx": "1276", "code": "protected void cutSelectedBean(){\n  if (Debug.debugging(\"beanbox\"))   Debug.output(\"Enter> cutSelectedBean\");\n  if (selectedBean == null || selectedBeanLocation == null) {\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"selectedBean=\" + selectedBean);\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"selectedBeanLocation=\" + selectedBeanLocation);\n    clearSelection();\n    return;\n  }\n  try {\n    serBean=new ByteArrayOutputStream();\n    ObjectOutputStream oos=new ObjectOutputStream(serBean);\n    oos.writeObject(selectedBean);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    clearSelection();\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"Exit> copySelectedBean\");\n    return;\n  }\n  cutBean=selectedBean;\n  selectedBeanBox.showCut(selectedBean);\n  if (Debug.debugging(\"beanbox\"))   Debug.output(\"Exit> cutSelectedBean\");\n}\n", "docstring": "this method is called when the user chooses to cut a bean by some means such by by pressing ctrl - x . this method tries to serialize the selected bean . if no bean is selected or the bean is not serializable , this method is a no - op .", "partition": "test"}
{"idx": "3204", "code": "public boolean isLeaf(){\n  return children == null || children.isEmpty();\n}\n", "docstring": "true , if the node is a leaf .", "partition": "test"}
{"idx": "991", "code": "public String render(ValueExpr theExpr) throws Exception {\n  theExpr.visit(this);\n  return mBuffer.toString();\n}\n", "docstring": "return the rendering of the valueexpr object", "partition": "test"}
{"idx": "3105", "code": "public boolean isNumericalRun(String pin){\n  final int len=pin.length();\n  int prevDigit=Character.digit(pin.charAt(0),10);\n  int prevDiff=Integer.MAX_VALUE;\n  boolean isRun=true;\n  for (int i=1; isRun && i < len; i++) {\n    final int digit=Character.digit(pin.charAt(i),10);\n    final int diff=digit - prevDigit;\n    if (prevDiff != Integer.MAX_VALUE && diff != prevDiff) {\n      isRun=false;\n    }\n    prevDiff=diff;\n    prevDigit=digit;\n  }\n  return isRun;\n}\n", "docstring": "tests the string to see if it contains a numeric run . for example , \" 123456 \" , \" 0000 \" , \" 9876 \" , and \" 2468 \" would all match .", "partition": "test"}
{"idx": "1913", "code": "public final ArrayList<Move> removeNonOptimal(Position pos,ArrayList<Move> moveList){\n  ArrayList<Move> optimalMoves=new ArrayList<Move>();\n  ArrayList<Move> unknownMoves=new ArrayList<Move>();\n  final int MATE0=100000;\n  int bestScore=-1000000;\n  UndoInfo ui=new UndoInfo();\n  for (  Move m : moveList) {\n    pos.makeMove(m,ui);\n    int pliesToDraw=Math.max(100 - pos.halfMoveClock,1);\n    GtbProbeResult res=gtbProbe(pos);\n    pos.unMakeMove(m,ui);\n    if (res.result == GtbProbeResult.UNKNOWN) {\n      unknownMoves.add(m);\n    }\n else {\n      int wScore;\n      if (res.result == GtbProbeResult.WMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=MATE0 - res.pliesToMate;\n else         wScore=1;\n      }\n else       if (res.result == GtbProbeResult.BMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=-(MATE0 - res.pliesToMate);\n else         wScore=-1;\n      }\n else {\n        wScore=0;\n      }\n      int score=pos.whiteMove ? wScore : -wScore;\n      if (score > bestScore) {\n        optimalMoves.clear();\n        optimalMoves.add(m);\n        bestScore=score;\n      }\n else       if (score == bestScore) {\n        optimalMoves.add(m);\n      }\n else {\n      }\n    }\n  }\n  for (  Move m : unknownMoves)   optimalMoves.add(m);\n  return (optimalMoves.size() < moveList.size()) ? optimalMoves : null;\n}\n", "docstring": "return a list of all moves in movelist that are not known to be non - optimal . returns null if no legal move could be excluded .", "partition": "test"}
{"idx": "1485", "code": "public UpdateClause addAssignment(Expression expression){\n  assignments.add(new Assignment(expression));\n  return this;\n}\n", "docstring": "adds a property to set to the clause .", "partition": "test"}
{"idx": "1131", "code": "public boolean equals(Object obj){\n  if (obj instanceof MSort) {\n    MSort ms=(MSort)obj;\n    if (data == ms.data)     return true;\n  }\n  return false;\n}\n", "docstring": "equal ( based on data , ignores index )", "partition": "test"}
{"idx": "3873", "code": "public void waitForDecodingToFinish(){\n  while (isDecoding) {\n    try {\n      Thread.sleep(100);\n    }\n catch (    final InterruptedException e) {\n      LogWriter.writeLog(\"Exception: \" + e.getMessage());\n      isDecoding=false;\n    }\n  }\n}\n", "docstring": "wait for decoding to finish", "partition": "test"}
{"idx": "2272", "code": "public static void drawVerticalMarginIndicator(Graphics2D g,String text,int x,int y1,int y2){\n  if (y1 > y2) {\n    int temp=y1;\n    y1=y2;\n    y2=temp;\n  }\n  if (text == null) {\n    g.drawLine(x,y1,x,y2);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    return;\n  }\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=4;\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int th=(int)bounds.getHeight();\n  int offset=3 * CONNECTION_ARROW_SIZE;\n  int h=((y2 - y1) - (th + 2 * padding)) / 2;\n  if (h <= padding) {\n    g.drawLine(x,y1,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2) + offset,y2 - h - padding);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y1,x + CONNECTION_ARROW_SIZE,y1);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y2,x + CONNECTION_ARROW_SIZE,y2);\n  }\n else {\n    g.drawLine(x,y1,x,y1 + h);\n    g.drawLine(x,y2 - h,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2),y2 - h - padding);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n  }\n}\n", "docstring": "utility function to draw a vertical margin indicator", "partition": "test"}
{"idx": "1806", "code": "public void start(){\n  if (setState(EnumSet.of(TaskState.INITIAL,TaskState.QUEUED),TaskState.RUNNING)) {\n    DHT.logDebug(\"Starting Task: \" + toString());\n    startTime=System.currentTimeMillis();\n    try {\n      serializedUpdate.run();\n    }\n catch (    Exception e) {\n      DHT.log(e,LogLevel.Error);\n    }\n  }\n}\n", "docstring": "start the task , to be used when a task is queued .", "partition": "test"}
{"idx": "1772", "code": "public boolean isDebuggingFinest(){\n  return logger.isLoggable(Level.FINEST);\n}\n", "docstring": "test whether to log \"'\" debug \"'\" at \"'\" finest \"'\" level", "partition": "test"}
{"idx": "1032", "code": "@Override public void readExternal(ObjectInput in) throws IOException {\n  path=IgfsUtils.readPath(in);\n  blockSize=in.readInt();\n  grpBlockSize=in.readLong();\n  len=in.readLong();\n  props=U.readStringMap(in);\n  accessTime=in.readLong();\n  modificationTime=in.readLong();\n  flags=in.readByte();\n}\n", "docstring": "reads object from data input .", "partition": "test"}
{"idx": "3385", "code": "private void addExtentEntry(){\n  extentModel.addNewEntry();\n  removeExtentButton.setEnabled(false);\n}\n", "docstring": "adds a new extent entry .", "partition": "test"}
{"idx": "428", "code": "private DiffPart decodeAdd(final int blockSize_S,final int blockSize_L) throws UnsupportedEncodingException, DecodingException {\n  if (blockSize_S < 1 || blockSize_L < 1) {\n    throw new DecodingException(\"Invalid value for blockSize_S: \" + blockSize_S + \" or blockSize_L: \"+ blockSize_L);\n  }\n  int s=r.read(blockSize_S);\n  int l=r.read(blockSize_L);\n  ByteArrayOutputStream output=new ByteArrayOutputStream();\n  for (int i=0; i < l; i++) {\n    output.write(r.readByte());\n  }\n  DiffPart part=new DiffPart(DiffAction.INSERT);\n  part.setStart(s);\n  part.setText(output.toString(WIKIPEDIA_ENCODING));\n  return part;\n}\n", "docstring": "decodes an add operation .", "partition": "test"}
{"idx": "288", "code": "private int distBetweenPoints(int x1,int z1,int x2,int z2,boolean bAllowDiags){\n  int w=Math.abs(x2 - x1);\n  int h=Math.abs(z2 - z1);\n  if (bAllowDiags) {\n    if (w < h)     w=0;\n else     h=0;\n  }\n  return w + h + 1;\n}\n", "docstring": "calculate the number of cells on the shortest path between ( x1 , z1 ) and ( x2 , z2 )", "partition": "test"}
{"idx": "1099", "code": "public static int countCSSPrimitiveNames(){\n  return ALL_PRIMITIVE_PROPERTY_NAMES.size();\n}\n", "docstring": "returns a count of all css primitive ( non - shorthand ) properties known to this class .", "partition": "test"}
{"idx": "179", "code": "public ContentImpl createCompoundPackageContent(OleBlobImpl blob,String prettyName,String className,String typeName,ByteBuffer blobBb,int dataBlockLen){\n  return new CompoundContentImpl(blob,prettyName,className,typeName,blobBb.position(),dataBlockLen);\n}\n", "docstring": "creates a nes compoundcontent for the given blob information .", "partition": "test"}
{"idx": "1591", "code": "public static <K,V>ConcurrentMap<K,V> newConcurrentMapWithAggressiveConcurrency(){\n  return new ConcurrentHashMap<>(16,0.75f,aggressiveConcurrencyLevel);\n}\n", "docstring": "creates a new chm with an aggressive concurrency level , aimed at high concurrent update rate long living maps .", "partition": "test"}
{"idx": "1136", "code": "private void loadManifest(){\n  if (_isManifestRead)   return;\nsynchronized (this) {\n    if (_isManifestRead)     return;\n    try {\n      _manifest=_jarPath.getManifest();\n      if (_manifest == null)       return;\n      Attributes attr=_manifest.getMainAttributes();\n      if (attr != null)       addManifestPackage(\"\",attr);\n      Map<String,Attributes> entries=_manifest.getEntries();\n      for (      Map.Entry<String,Attributes> entry : entries.entrySet()) {\n        String pkg=entry.getKey();\n        attr=entry.getValue();\n        if (attr == null)         continue;\n        addManifestPackage(pkg,attr);\n      }\n    }\n catch (    IOException e) {\n      log.log(Level.WARNING,e.toString(),e);\n    }\n finally {\n      _isManifestRead=true;\n    }\n  }\n}\n", "docstring": "reads the jar \"'\" s manifest .", "partition": "test"}
{"idx": "1896", "code": "protected void loadValue(String sValue){\n  try {\n    value=Byte.parseByte(sValue.trim());\n  }\n catch (  NumberFormatException nfe) {\n    revertToDefault();\n  }\n}\n", "docstring": "load value from property string value", "partition": "test"}
{"idx": "2291", "code": "private void addReplicationFactor(Operation op){\n  op.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n}\n", "docstring": "authorization related operations should take effect on all replicas , before they complete . this method adds a special header that sets the quorum level to all available nodes , avoiding a race where a client can reach a node that has not yet received latest authorization changes , even if it received success from this auth helper class", "partition": "test"}
{"idx": "2630", "code": "public void add(int index,int element){\n  checkRangeIncludingEndpoint(index);\n  ensureCapacity(size + 1);\n  int numtomove=size - index;\n  System.arraycopy(array,index,array,index + 1,numtomove);\n  array[index]=element;\n  size++;\n}\n", "docstring": "inserts the specified element at the specified position in this list . shifts the element currently at that position ( if any ) and any subsequent elements to the right ( adds one to their indices ) .", "partition": "test"}
{"idx": "1653", "code": "public void centerHorizontal(ArrayList<Integer> nodes){\n  if (m_bNeedsUndoAction) {\n    addUndoAction(new centerHorizontalAction(nodes));\n  }\n  int nMinY=-1;\n  int nMaxY=-1;\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nY=getPositionY(nodes.get(iNode));\n    if (nY < nMinY || iNode == 0) {\n      nMinY=nY;\n    }\n    if (nY > nMaxY || iNode == 0) {\n      nMaxY=nY;\n    }\n  }\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nNode=nodes.get(iNode);\n    m_nPositionY.set(nNode,(nMinY + nMaxY) / 2);\n  }\n}\n", "docstring": "center set of nodes half way between left and right most node in the list", "partition": "test"}
{"idx": "3380", "code": "public static int indexOfLastSeparator(String filename){\n  if (filename == null)   return -1;\n  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos,lastWindowsPos);\n}\n", "docstring": "returns the index of the last directory separator character . < p > this method will handle a file in either unix or windows format . the position of the last forward or backslash is returned . < p > the output will be the same irrespective of the machine that the code is running on .", "partition": "test"}
{"idx": "583", "code": "public ArbitraryLengthPathNode(final TermNode left,final TermNode right,final VarNode tVarLeft,final VarNode tVarRight,final long lowerBound,final long upperBound){\n  this(new BOp[]{new JoinGroupNode()},NV.asMap(new NV(Annotations.LEFT_TERM,left),new NV(Annotations.RIGHT_TERM,right),new NV(Annotations.TRANSITIVITY_VAR_LEFT,tVarLeft),new NV(Annotations.TRANSITIVITY_VAR_RIGHT,tVarRight),new NV(Annotations.DROP_VARS,new ArrayList<VarNode>()),new NV(Annotations.LOWER_BOUND,lowerBound),new NV(Annotations.UPPER_BOUND,upperBound)));\n  final Set<VarNode> dropVars=new LinkedHashSet<>();\n  dropVars.add(tVarLeft);\n  dropVars.add(tVarRight);\n  setProperty(Annotations.DROP_VARS,dropVars);\n}\n", "docstring": "fully construct an arbitrary length path node with all required annotations .", "partition": "test"}
{"idx": "1817", "code": "public static String toXml(final Config toConvert,Boolean prettyXml) throws JAXBException, IOException {\n  String retVal=\"\";\n  try (StringWriter writer=new StringWriter()){\n    toXml(toConvert,writer,prettyXml);\n    retVal=writer.toString();\n    return retVal;\n  }\n }\n", "docstring": "converts config to xml ,", "partition": "test"}
{"idx": "2220", "code": "@Override public boolean dragTo(Selector obj,Selector destObj,int steps) throws UiObjectNotFoundException, NotImplementedException {\n  return dragTo(device.findObject(obj.toUiSelector()),destObj,steps);\n}\n", "docstring": "drags this object to a destination uiobject . the number of steps specified in your input parameter can influence the drag speed , and varying speeds may impact the results . consider evaluating different speeds when using this method in your tests .", "partition": "test"}
{"idx": "2161", "code": "QName toQName(Class<?> outputClass){\n  String localPart;\n  String namespaceUri;\n  if (outputClass.isAnnotationPresent(XmlRootElement.class)) {\n    XmlRootElement annotation=outputClass.getAnnotation(XmlRootElement.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else   if (outputClass.isAnnotationPresent(XmlType.class)) {\n    XmlType annotation=outputClass.getAnnotation(XmlType.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else {\n    throw new IllegalArgumentException(\"Outputclass [\" + outputClass + \"] is \"+ \"neither annotated with @XmlRootElement nor @XmlType\");\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {\n    localPart=ClassUtils.getShortNameAsProperty(outputClass);\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {\n    Package outputClassPackage=outputClass.getPackage();\n    if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {\n      XmlSchema annotation=outputClassPackage.getAnnotation(XmlSchema.class);\n      namespaceUri=annotation.namespace();\n    }\n else {\n      namespaceUri=XMLConstants.NULL_NS_URI;\n    }\n  }\n  return new QName(namespaceUri,localPart);\n}\n", "docstring": "returns the qualified name for the given class , according to the mapping rules in the jaxb specification .", "partition": "test"}
{"idx": "953", "code": "private static <T extends AbstractBlockBase<T>>void enqueueSuccessors(T block,PriorityQueue<T> worklist,BitSet visitedBlocks){\n  for (  T successor : block.getSuccessors()) {\n    if (!visitedBlocks.get(successor.getId())) {\n      visitedBlocks.set(successor.getId());\n      worklist.add(successor);\n    }\n  }\n}\n", "docstring": "add successor blocks into the given work list if they are not already marked as visited .", "partition": "test"}
{"idx": "3191", "code": "private void updateLegends(){\n  if (m_span == null) {\n    m_span=new JPanel();\n  }\n  JPanel padder=new JPanel();\n  JPanel padd2=new JPanel();\n  m_span.setPreferredSize(new Dimension(m_span.getPreferredSize().width,(m_plots.size() + 1) * 20));\n  m_span.setMaximumSize(new Dimension(m_span.getPreferredSize().width,(m_plots.size() + 1) * 20));\n  LegendEntry tmp;\n  GridBagLayout gb=new GridBagLayout();\n  GridBagLayout gb2=new GridBagLayout();\n  GridBagConstraints constraints=new GridBagConstraints();\n  m_span.removeAll();\n  padder.setLayout(gb);\n  m_span.setLayout(gb2);\n  constraints.anchor=GridBagConstraints.CENTER;\n  constraints.gridx=0;\n  constraints.gridy=0;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.insets=new Insets(0,0,0,0);\n  padder.add(m_span,constraints);\n  constraints.gridx=0;\n  constraints.gridy=1;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.BOTH;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.weighty=5;\n  constraints.insets=new Insets(0,0,0,0);\n  padder.add(padd2,constraints);\n  constraints.weighty=0;\n  setViewportView(padder);\n  constraints.anchor=GridBagConstraints.CENTER;\n  constraints.gridx=0;\n  constraints.gridy=0;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.weighty=5;\n  constraints.insets=new Insets(2,4,2,4);\n  for (int i=0; i < m_plots.size(); i++) {\n    tmp=new LegendEntry(m_plots.get(i),i);\n    constraints.gridy=i;\n    m_span.add(tmp,constraints);\n  }\n}\n", "docstring": "redraw the panel with the legend entries", "partition": "test"}
{"idx": "1863", "code": "public void testAddServletWithNameAndJspFile() throws Exception {\n  String xml=WEBAPP_TEST_HEADER + \"\" + \"</web-app>\";\n  WebXml webXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(xml.getBytes(\"UTF-8\")),getEntityResolver());\n  WebXmlUtils.addJspFile(webXml,\"s1\",\"s1.jsp\");\n  assertTrue(WebXmlUtils.hasServlet(webXml,\"s1\"));\n}\n", "docstring": "tests whether a single servlet can be added using the method that takes a string for the servlet name and a string for the jsp file .", "partition": "test"}
{"idx": "1221", "code": "public void drawContours(Mat img,Color color){\n  Drawing.drawContours(img,contours,color);\n}\n", "docstring": "draw contours matched by the blob detector", "partition": "test"}
{"idx": "3604", "code": "public void add(final CreatureRespawnPoint point){\n  respawnPoints.add(point);\n}\n", "docstring": "add a creature respawn point to the zone .", "partition": "test"}
{"idx": "1", "code": "public static int unionSize(long[] x,long[] y){\n  final int lx=x.length, ly=y.length;\n  final int min=(lx < ly) ? lx : ly;\n  int i=0, res=0;\n  for (; i < min; i++) {\n    res+=Long.bitCount(x[i] | y[i]);\n  }\n  for (; i < lx; i++) {\n    res+=Long.bitCount(x[i]);\n  }\n  for (; i < ly; i++) {\n    res+=Long.bitCount(y[i]);\n  }\n  return res;\n}\n", "docstring": "compute the union size of two bitsets .", "partition": "test"}
{"idx": "3883", "code": "public boolean containsCategory(String category){\n  return !hiddenBugCategorySet.contains(category);\n}\n", "docstring": "returns false if the given category is hidden in the project filter settings .", "partition": "test"}
{"idx": "4003", "code": "private Activity checkActivity(){\n  Activity activity=mActivity.get();\n  if (activity == null) {\n    throw new IllegalStateException(\"No activity set. Either subclass PermisoActivity or call Permiso.setActivity() in onCreate() and onResume() of your Activity.\");\n  }\n  return activity;\n}\n", "docstring": "ensures that our weakreference to the activity is still valid . if it isn \"'\" t , throw an exception saying that the activity needs to be set .", "partition": "test"}
{"idx": "819", "code": "public void testEmptyOrNullBlob() throws Exception {\n  try {\n    PreparedStatement stmt=connection.prepareStatement(\"INSERT INTO test_blob(id, bin_data) VALUES(?, ?)\");\n    try {\n      stmt.setInt(1,3);\n      stmt.setBytes(2,new byte[0]);\n      int insertedCount=stmt.executeUpdate();\n      assertTrue(\"Should insert one row.\",insertedCount == 1);\n      stmt.setInt(1,4);\n      stmt.setNull(2,Types.BINARY);\n      insertedCount=stmt.executeUpdate();\n      assertTrue(\"Should insert one row.\",insertedCount == 1);\n    }\n  finally {\n      stmt.close();\n    }\n    stmt=connection.prepareStatement(\"SELECT bin_data FROM test_blob WHERE id = ?\");\n    stmt.setInt(1,3);\n    try {\n      ResultSet rs=stmt.executeQuery();\n      assertTrue(\"Should select at least one row.\",rs.next());\n      assertTrue(\"Result should byte[0]\",Arrays.equals(rs.getBytes(1),new byte[0]));\n      rs.close();\n      stmt.setInt(1,4);\n      rs=stmt.executeQuery();\n      assertTrue(\"Should select at least one row.\",rs.next());\n      assertTrue(\"Result should byte[0]\",rs.getObject(1) == null);\n      rs.close();\n    }\n  finally {\n      stmt.close();\n    }\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n    throw ex;\n  }\n}\n", "docstring": "test if driver returns correctly empty and null blobs .", "partition": "test"}
{"idx": "2628", "code": "protected double computeStdDev(Instance inst,Matrix k) throws Exception {\n  double kappa=m_kernel.eval(-1,-1,inst) + m_deltaSquared;\n  double s=0;\n  int n=m_L.length;\n  for (int i=0; i < n; i++) {\n    double t=0;\n    for (int j=0; j < n; j++) {\n      t-=k.get(j,0) * (i > j ? m_L[i][j] : m_L[j][i]);\n    }\n    s+=t * k.get(i,0);\n  }\n  double sigma=m_delta;\n  if (kappa > s) {\n    sigma=Math.sqrt(kappa - s);\n  }\n  return sigma;\n}\n", "docstring": "computes standard deviation for given instance , without transforming target back into original space .", "partition": "test"}
{"idx": "3153", "code": "protected static void postProcessFlood(IHex[] hexSet,int modifier){\n  int n;\n  IHex field;\n  ITerrainFactory f=Terrains.getTerrainFactory();\n  for (n=0; n < hexSet.length; n++) {\n    field=hexSet[n];\n    int elev=field.getLevel() - modifier;\n    if ((elev == 0) && !(field.containsTerrain(Terrains.WATER)) && !(field.containsTerrain(Terrains.PAVEMENT))) {\n      field.addTerrain(f.createTerrain(Terrains.SWAMP,1));\n    }\n else     if (elev < 0) {\n      if (elev < -4) {\n        elev=-4;\n      }\n      field.removeAllTerrains();\n      field.addTerrain(f.createTerrain(Terrains.WATER,-elev));\n      field.setLevel(modifier);\n    }\n  }\n}\n", "docstring": "flood negative hex levels shoreline / salt marshes effect works best with more elevation", "partition": "test"}
{"idx": "3315", "code": "protected Connection openH2Connection(boolean autocommit) throws SQLException {\n  System.setProperty(\"h2.serializeJavaObject\",\"false\");\n  String dbName=\"test\";\n  Connection conn=DriverManager.getConnection(\"jdbc:h2:mem:\" + dbName + \";DB_CLOSE_DELAY=-1\");\n  conn.setAutoCommit(autocommit);\n  return conn;\n}\n", "docstring": "gets connection from a pool .", "partition": "test"}
{"idx": "1426", "code": "public void invoke(InputStream is,OutputStream os,SerializerFactory serializerFactory) throws Exception {\n  boolean isDebug=false;\n  if (isDebugInvoke()) {\n    isDebug=true;\n    PrintWriter dbg=createDebugPrintWriter();\n    HessianDebugInputStream dIs=new HessianDebugInputStream(is,dbg);\n    dIs.startTop2();\n    is=dIs;\n    HessianDebugOutputStream dOs=new HessianDebugOutputStream(os,dbg);\n    dOs.startTop2();\n    os=dOs;\n  }\n  HessianInputFactory.HeaderType header=_inputFactory.readHeader(is);\n  AbstractHessianInput in;\n  AbstractHessianOutput out;\nswitch (header) {\ncase CALL_1_REPLY_1:\n    in=_hessianFactory.createHessianInput(is);\n  out=_hessianFactory.createHessianOutput(os);\nbreak;\ncase CALL_1_REPLY_2:\nin=_hessianFactory.createHessianInput(is);\nout=_hessianFactory.createHessian2Output(os);\nbreak;\ncase HESSIAN_2:\nin=_hessianFactory.createHessian2Input(is);\nin.readCall();\nout=_hessianFactory.createHessian2Output(os);\nbreak;\ndefault :\nthrow new IllegalStateException(header + \" is an unknown Hessian call\");\n}\nif (serializerFactory != null) {\nin.setSerializerFactory(serializerFactory);\nout.setSerializerFactory(serializerFactory);\n}\ntry {\ninvoke(_service,in,out);\n}\n  finally {\nin.close();\nout.close();\nif (isDebug) os.close();\n}\n}\n", "docstring": "invoke the object with the request from the input stream .", "partition": "test"}
{"idx": "1999", "code": "@NotNull private Optional<TypeConversion> findConversionFromDbValue(@NotNull Type source,@NotNull Type target){\n  if (isAssignable(target,source))   return Optional.of(TypeConversion.identity());\n  Optional<TypeConversion> directConversion=typeConversionRegistry.findConversionFromDbValue(source,target);\n  if (directConversion.isPresent())   return directConversion;\n  Optional<TypeConversion> arrayConversion=findArrayConversion(source,target);\n  if (arrayConversion.isPresent())   return arrayConversion;\n  Optional<TypeConversion> optionalConversion=findOptionalConversion(source,target);\n  if (optionalConversion.isPresent())   return optionalConversion;\n  Optional<TypeConversion> enumConversion=findEnumConversion(target);\n  if (enumConversion.isPresent())   return enumConversion;\n  return Optional.empty();\n}\n", "docstring": "returns conversion for converting value of source to target , or returns null if there \"'\" s no such conversion .", "partition": "test"}
{"idx": "1914", "code": "public static void executeRandomModifiableVariableModification(ModifiableVariableHolder object){\n  Field field=object.getRandomModifiableVariableField();\n  executeModifiableVariableModification(object,field);\n}\n", "docstring": "picks a random modifiable variable and executes a random modification on this variable .", "partition": "test"}
{"idx": "156", "code": "public IgfsPath(URI uri){\n  A.notNull(uri,\"uri\");\n  path=normalizePath(uri.getPath());\n}\n", "docstring": "constructs a path from an uri", "partition": "test"}
{"idx": "3226", "code": "public Optional<BlazeVertex> vertex(final String vertexId){\n  try (final CloseableIterator<Vertex> it=vertices(vertexId)){\n    final Optional<BlazeVertex> v=it.hasNext() ? Optional.of((BlazeVertex)it.next()) : Optional.empty();\n    if (it.hasNext()) {\n      throw new IllegalStateException(\"Multiple vertices found with id: \" + vertexId);\n    }\n    return v;\n  }\n }\n", "docstring": "lookup a vertex by id .", "partition": "test"}
{"idx": "3536", "code": "public boolean hasItem(T object){\nsynchronized (mLock) {\n    return source.contains(object);\n  }\n}\n", "docstring": "determine if the object provide is in this adapter", "partition": "test"}
{"idx": "3931", "code": "public static void registerDefaultResolvers(){\nsynchronized (resolverList) {\n    resolverList.add(new ResourceResolver(new ResolverFragment()));\n    resolverList.add(new ResourceResolver(new ResolverLocalFilesystem()));\n    resolverList.add(new ResourceResolver(new ResolverXPointer()));\n    resolverList.add(new ResourceResolver(new ResolverDirectHTTP()));\n  }\n}\n", "docstring": "this method registers the default resolvers .", "partition": "test"}
{"idx": "2277", "code": "public void initialize(Context context,HapticFeedbackController hapticFeedbackController,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){\n  if (mTimeInitialized) {\n    Log.e(TAG,\"Time has already been initialized.\");\n    return;\n  }\n  mHapticFeedbackController=hapticFeedbackController;\n  mIs24HourMode=is24HourMode;\n  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;\n  mCircleView.initialize(context,mHideAmPm);\n  mCircleView.invalidate();\n  if (!mHideAmPm) {\n    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);\n    mAmPmCirclesView.invalidate();\n  }\n  Resources res=context.getResources();\n  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};\n  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};\n  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};\n  String[] hoursTexts=new String[12];\n  String[] innerHoursTexts=new String[12];\n  String[] minutesTexts=new String[12];\n  for (int i=0; i < 12; i++) {\n    hoursTexts[i]=is24HourMode ? String.format(\"%02d\",hours_24[i]) : String.format(\"%d\",hours[i]);\n    innerHoursTexts[i]=String.format(\"%d\",hours[i]);\n    minutesTexts[i]=String.format(\"%02d\",minutes[i]);\n  }\n  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);\n  mHourRadialTextsView.invalidate();\n  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);\n  mMinuteRadialTextsView.invalidate();\n  setValueForItem(HOUR_INDEX,initialHoursOfDay);\n  setValueForItem(MINUTE_INDEX,initialMinutes);\n  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;\n  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));\n  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;\n  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);\n  mTimeInitialized=true;\n}\n", "docstring": "initialize the layout with starting values .", "partition": "test"}
{"idx": "750", "code": "public void startTicker(long delay,boolean rightToLeft){\n  if (!tickerEnabled) {\n    return;\n  }\n  if (!isCellRenderer()) {\n    Form parent=getComponentForm();\n    if (parent != null) {\n      parent.registerAnimatedInternal(this);\n    }\n  }\n  tickerStartTime=System.currentTimeMillis();\n  tickerDelay=delay;\n  tickerRunning=true;\n  this.rightToLeft=rightToLeft;\n  if (isRTL()) {\n    this.rightToLeft=!this.rightToLeft;\n  }\n}\n", "docstring": "this method will start the text ticker", "partition": "test"}
{"idx": "3021", "code": "public static BigInteger CRT(List<BigInteger> congs,List<BigInteger> moduli){\n  BigInteger[] cs=ArrayConverter.convertListToArray(congs);\n  BigInteger[] ms=ArrayConverter.convertListToArray(moduli);\n  return CRT(cs,ms);\n}\n", "docstring": "computes chinese reminder theorem : x = = congs [ i ", "partition": "test"}
{"idx": "2172", "code": "public static String parseDiskString(String input){\n  String delims=\"[ ]+\";\n  String[] tokens=input.split(delims);\n  return tokens[0];\n}\n", "docstring": "get the disk name out from the input string .", "partition": "test"}
{"idx": "729", "code": "public void append(String string){\n  for (int i=0; i < string.length(); i++)   append(string.charAt(i));\n}\n", "docstring": "appends an int ( little endian ) in the buffer", "partition": "test"}
{"idx": "3688", "code": "public static boolean isPropositionSymbolIdentifierPart(char ch){\n  return Character.isJavaIdentifierPart(ch);\n}\n", "docstring": "determine if the given character is part of a proposition symbol .", "partition": "test"}
{"idx": "4256", "code": "void hideBorder(){\n  Insets insets=getInsets();\n  setBorder(BorderFactory.createEmptyBorder(insets.top,insets.left,insets.bottom,insets.right));\n}\n", "docstring": "hide the special border of the title bar .", "partition": "test"}
{"idx": "1414", "code": "public void recordBeginning(){\n  final String msg=\"Usage beginning module=\" + mModuleName + \" runId=\"+ mRunId;\n  mUsageMessages.add(msg);\n  Diagnostic.developerLog(msg);\n  mClient.recordBeginning(mModuleName,mRunId);\n}\n", "docstring": "records a start usage logging message to whichever logging endpoint is configured", "partition": "test"}
{"idx": "2491", "code": "public static String fromTag(ByteArrayTag tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  byte value : tag.getValue()) {\n    ByteTag b=new ByteTag(value);\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromTag(b));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}\n", "docstring": "creates a mojangson string from the given bytearray tag .", "partition": "test"}
{"idx": "1669", "code": "public String random(Object omin,Object omax){\n  int min=FunctionHandler.getInt(omin);\n  int max=FunctionHandler.getInt(omax);\n  if (max > min) {\n    return Integer.toString(rnd.nextInt(max - min) + min);\n  }\n  return \"0\";\n}\n", "docstring": "returns a random number between min ( inclusive ) and max ( exclusive )", "partition": "test"}
{"idx": "2008", "code": "public void add(String methodName,List<Expression> parameters){\n  chain.add(new DotExpressionItem(methodName,parameters,false));\n}\n", "docstring": "add a method to the chain of methods after the dot .", "partition": "test"}
{"idx": "1343", "code": "public void removeSelectionListener(final SelectionListener listener){\n  checkWidget();\n  if (listener == null) {\n    SWT.error(SWT.ERROR_NULL_ARGUMENT);\n  }\n  listOfSelectionListeners.remove(listener);\n}\n", "docstring": "removes the listener from the collection of listeners who will be notified when the control is selected by the user .", "partition": "test"}
{"idx": "2528", "code": "public boolean equalsDefault(){\n  return (Double.doubleToLongBits(value) == 0);\n}\n", "docstring": "check if the expression is equal to its default static value", "partition": "test"}
{"idx": "2843", "code": "@Override public List<String> allKeys(){\n  List<String> nameFiles=new ArrayList<>();\n  File[] files=cacheDirectory.listFiles();\n  if (files == null)   return nameFiles;\n  for (  File file : files) {\n    if (file.isFile()) {\n      nameFiles.add(file.getName());\n    }\n  }\n  return nameFiles;\n}\n", "docstring": "retrieve the names from all files in dir", "partition": "test"}
{"idx": "3505", "code": "@Override public void do_after_propagation(){\n  for (  HeapInsIntervalManager im : new_pts.values()) {\n    im.flush();\n  }\n  new_pts=new HashMap<AllocNode,HeapInsIntervalManager>();\n}\n", "docstring": "remember to clean the is_new flag", "partition": "test"}
{"idx": "1289", "code": "public ResourcesPoet addInteger(String name,String value){\n  Element bool=document.createElement(\"integer\");\n  bool.setAttribute(\"name\",name);\n  bool.appendChild(document.createTextNode(String.valueOf(value)));\n  resourceElement.appendChild(bool);\n  return this;\n}\n", "docstring": "add an integer to the config", "partition": "test"}
{"idx": "1473", "code": "public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    AuthPropertiesModel model=(AuthPropertiesModel)getModel();\n    Map original=model.getValues();\n    AMPropertySheet ps=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n    model.setValues(ps.getAttributeValues(original,true,model));\n    setInlineAlertMessage(CCAlert.TYPE_INFO,\"message.information\",\"authentication.profile.updated\");\n  }\n catch (  AMConsoleException a) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",a.getMessage());\n  }\n  forwardTo();\n}\n", "docstring": "handles save button request .", "partition": "test"}
{"idx": "3421", "code": "public void remove(IAdaptable a){\n  children.remove(a);\n}\n", "docstring": "adds the given adaptable object to this list .", "partition": "test"}
{"idx": "3978", "code": "private List<String> fetchFileCosIdList() throws SOSFailure {\n  final String methodName=\"fetchFileCosIdList(): \";\n  log.trace(methodName + \"Entry\");\n  final String FILE_COS_URI=\"/file/vpools\";\n  List<String> fileCosIdList=new ArrayList<String>();\n  try {\n    CoSList cosElemList=_client.queryObject(FILE_COS_URI,CoSList.class);\n    if (cosElemList != null && cosElemList.getCosElements() != null) {\n      for (      CoSElement elem : cosElemList.getCosElements()) {\n        if (elem != null) {\n          fileCosIdList.add(elem.getId());\n        }\n      }\n    }\n    log.trace(methodName + \"File CoS Ids: \" + fileCosIdList);\n    if (cosElemList != null && fileCosIdList != null) {\n      log.trace(methodName + \"Exit returning cos list of size[\" + fileCosIdList.size()+ \"]\");\n      return fileCosIdList;\n    }\n    log.trace(methodName + \"Exit returning cos list of size[0]\");\n    return new ArrayList<String>();\n  }\n catch (  NoSuchAlgorithmException e) {\n    log.error(methodName + \"NoSuchAlgorithmException occured\",e);\n    throw new SOSFailure(e);\n  }\ncatch (  UniformInterfaceException e) {\n    log.error(methodName + \"UniformInterfaceException occured\",e);\n    throw new SOSFailure(e);\n  }\n}\n", "docstring": "returns list of file cos ids", "partition": "test"}
{"idx": "1631", "code": "public static void upgradeServerInstance(SSOToken ssoToken,String instanceName,String instanceId,Map<String,String> upgradedValues) throws SMSException, SSOException, ConfigurationException, IOException {\n  ServiceConfig sc=getServerConfig(ssoToken,instanceName);\n  if (sc != null) {\n    Map map=sc.getAttributes();\n    map.remove(ATTR_PARENT_SITE_ID);\n    Set newSet=getPropertiesSet(upgradedValues);\n    map.put(ATTR_SERVER_CONFIG,newSet);\n    sc.setAttributes(map);\n  }\n else {\n    throw new ConfigurationException(\"Unable to upgrade server \" + \"default properties: no properties found!\");\n  }\n}\n", "docstring": "upgrades a server instance .", "partition": "test"}
{"idx": "4165", "code": "protected void deleteTypeVertex(AtlasVertex instanceVertex,DataTypes.TypeCategory typeCategory,boolean force) throws AtlasException {\nswitch (typeCategory) {\ncase STRUCT:\ncase TRAIT:\n    deleteTypeVertex(instanceVertex,force);\n  break;\ncase CLASS:\ndeleteEntities(Collections.singletonList(instanceVertex));\nbreak;\ndefault :\nthrow new IllegalStateException(\"Type category \" + typeCategory + \" not handled\");\n}\n}\n", "docstring": "deletes a type vertex - can be entity ( class type ) or just vertex ( struct / trait type )", "partition": "test"}
{"idx": "2987", "code": "private static Pair<String,String> postIndexedLSR(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2,final String immediateNodeValue){\n  final String address=environment.getNextVariableString();\n  final String tmpVar1=environment.getNextVariableString();\n  final String tmpVar2=environment.getNextVariableString();\n  final String index=environment.getNextVariableString();\n  long baseOffset=offset;\n  instructions.add(ReilHelpers.createStr(baseOffset++,dw,registerNodeValue1,dw,address));\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dw,registerNodeValue2,dw,\"-\" + immediateNodeValue,qw,tmpVar1));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,qw,tmpVar1,dw,dWordBitMask,dw,index));\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue1,dw,index,dw,tmpVar2));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dw,tmpVar2,dw,dWordBitMask,dw,registerNodeValue1));\n  return new Pair<String,String>(address,registerNodeValue1);\n}\n", "docstring": "operation : [ < rn > ", "partition": "test"}
{"idx": "2480", "code": "default ClassDeclaration asClass(){\n  throw new UnsupportedOperationException(String.format(\"%s is not a class\",this));\n}\n", "docstring": "return this as a classdeclaration or throw unsupportedoperationexception .", "partition": "test"}
{"idx": "1643", "code": "public void forward(HttpServerRequest request){\n  forward(request,null);\n}\n", "docstring": "handles the request and forwards it to the hook specific destination .", "partition": "test"}
{"idx": "705", "code": "protected boolean matchesFilter(final String input,final String[] filter){\n  for (  final String match : filter) {\n    if (!input.contains(match))     return false;\n  }\n  return true;\n}\n", "docstring": "checks if all keywords in filter array are in input", "partition": "test"}
{"idx": "4069", "code": "public CompletableFuture<NewFile> run(){\n  LOG.log(Level.FINE,\"starting optimized file creation for {0} files\",files.size());\n  CompletableFuture<NewFile> fileCreation=new CompletableFuture<>();\n  final List<TSData> fjpFiles=this.files;\n  TASK_POOL.execute(null);\nsynchronized (OUTSTANDING) {\n    OUTSTANDING.add(fileCreation);\n  }\n  this.files=new LinkedList<>();\n  return fileCreation;\n}\n", "docstring": "start creating the optimized file . this operation resets the state of the optimizer task , so it can be re - used for subsequent invocations .", "partition": "test"}
{"idx": "4136", "code": "final public void println(double v){\n  Writer out=this.out;\n  if (out == null)   return;\n  print(v);\n  try {\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a double followed by a newline .", "partition": "test"}
{"idx": "1106", "code": "private static void updateWindowUI(Window window){\n  SwingUtilities.updateComponentTreeUI(window);\n  Window ownedWins[]=window.getOwnedWindows();\n  for (  Window ownedWin : ownedWins) {\n    updateWindowUI(ownedWin);\n  }\n}\n", "docstring": "updates the ui of the passed in window and all its children .", "partition": "test"}
{"idx": "318", "code": "protected boolean isServerTransaction(){\n  return this instanceof SIPServerTransaction;\n}\n", "docstring": "a shortcut way of telling if we are a server transaction .", "partition": "test"}
{"idx": "2928", "code": "public int countArray(String[] array){\n  return array.length;\n}\n", "docstring": "counts the size of an array .", "partition": "test"}
{"idx": "426", "code": "public FromClause(Stream streamOne,OuterJoinQualifier outerJoinQualifier,Stream streamTwo){\n  this(streamOne);\n  add(streamTwo);\n  outerJoinQualifiers.add(outerJoinQualifier);\n}\n", "docstring": "ctor for an outer join between two streams .", "partition": "test"}
{"idx": "990", "code": "private static byte[] generateSeed(){\n  try {\n    final ByteArrayOutputStream seedBuffer=new ByteArrayOutputStream();\n    final DataOutputStream seedBufferOut=new DataOutputStream(seedBuffer);\n    seedBufferOut.writeLong(System.currentTimeMillis());\n    seedBufferOut.writeLong(System.nanoTime());\n    seedBufferOut.writeInt(Process.myPid());\n    seedBufferOut.writeInt(Process.myUid());\n    seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);\n    seedBufferOut.close();\n    return seedBuffer.toByteArray();\n  }\n catch (  final IOException e) {\n    throw new SecurityException(\"Failed to generate seed\",e);\n  }\n}\n", "docstring": "generates a device - and invocation - specific seed to be mixed into the linux prng .", "partition": "test"}
{"idx": "382", "code": "public void addPreferencesButton(){\n  JButton prefsButton=new JButton(\"Prefs\");\n  prefsButton.setHideActionText(true);\n  prefsButton.setAction(RasterPlotActions.getPropertiesDialogAction(this));\n  buttonPanel.add(prefsButton);\n}\n", "docstring": "add button for showing preferences .", "partition": "test"}
{"idx": "3950", "code": "private View fillFromSelection(int selectedLeft,int childrenLeft,int childrenRight){\n  if (DEBUG)   Log.i(TAG,\"fillFromSelection() selectedLeft: \" + selectedLeft + \" childrenLeft: \"+ childrenLeft+ CHILDREN_RIGHT+ childrenRight+ M_FIRST_POSITION+ mFirstPosition);\n  final int fadingEdgeLength=getHorizontalFadingEdgeLength();\n  final int selectedPosition=mSelectedPosition;\n  final int numRows=mNumRows;\n  final int horizontalSpacing=mHorizontalSpacing;\n  int columnStart;\n  int columnEnd=-1;\n  if (!mStackFromBottom) {\n    columnStart=selectedPosition - (selectedPosition % numRows);\n  }\n else {\n    int invertedSelection=mItemCount - 1 - selectedPosition;\n    columnEnd=mItemCount - 1 - (invertedSelection - (invertedSelection % numRows));\n    columnStart=Math.max(0,columnEnd - numRows + 1);\n  }\n  View sel;\n  View referenceView;\n  int leftSelectionPixel=getLeftSelectionPixel(childrenLeft,fadingEdgeLength,columnStart);\n  int rightSelectionPixel=getRightSelectionPixel(childrenRight,fadingEdgeLength,numRows,columnStart);\n  sel=makeColumn(mStackFromBottom ? columnEnd : columnStart,selectedLeft,true);\n  mFirstPosition=columnStart;\n  referenceView=mReferenceView;\n  adjustForLeftFadingEdge(referenceView,leftSelectionPixel,rightSelectionPixel);\n  adjustForRightFadingEdge(referenceView,leftSelectionPixel,rightSelectionPixel);\n  if (!mStackFromBottom) {\n    fillLeft(columnStart - numRows,referenceView.getLeft() - horizontalSpacing);\n    adjustViewsLeftOrRight();\n    fillRight(columnStart + numRows,referenceView.getRight() + horizontalSpacing);\n  }\n else {\n    fillRight(columnEnd + numRows,referenceView.getRight() + horizontalSpacing);\n    adjustViewsLeftOrRight();\n    fillLeft(columnStart - 1,referenceView.getLeft() - horizontalSpacing);\n  }\n  return sel;\n}\n", "docstring": "fills the grid based on positioning the new selection at a specific location . the selection may be moved so that it does not intersect the faded edges . the grid is then filled upwards and downwards from there .", "partition": "test"}
{"idx": "172", "code": "private boolean hasNext(Pattern pattern){\n  if (!hasNext()) {\n    return false;\n  }\n  Matcher matcher=pattern.matcher(gserValue.substring(pos,length));\n  return matcher.find();\n}\n", "docstring": "determines if the remaining gser string matches the provided pattern .", "partition": "test"}
{"idx": "2841", "code": "private void updateStateView(int itCount,Collection<Individual<Double>> gen){\n  Platform.runLater(null);\n  simPaneCtrl.waitAfterStep();\n}\n", "docstring": "caution : while the background thread should be slowed down , updates of the gui have to be done in the gui thread !", "partition": "test"}
{"idx": "636", "code": "@Deprecated public static Integer Integer(int i){\n  return Integer.valueOf(i);\n}\n", "docstring": "return a integer object with same value", "partition": "test"}
{"idx": "1332", "code": "protected static Long convertUuidToLong(UUID uuid){\n  if (uuid == null) {\n    return null;\n  }\n  Long convertedUuid;\n  if (uuid.version() == 1) {\n    convertedUuid=uuid.timestamp();\n  }\n else {\n    convertedUuid=uuid.getMostSignificantBits();\n  }\n  return convertedUuid;\n}\n", "docstring": "converts a uuid to a long for bucketing purposes . order of input and output values is preserved as long .", "partition": "test"}
{"idx": "262", "code": "Connection openNewConnection() throws SQLException {\n  Connection newConn=DriverManager.getConnection(url,user,password);\n  if (url.startsWith(\"jdbc:derby:\")) {\n    try (Statement s=newConn.createStatement()){\n    }\n   }\n else   if (url.startsWith(\"jdbc:hsqldb:\")) {\n    try (Statement s=newConn.createStatement()){\n      s.execute(\"SET WRITE_DELAY 1\");\n    }\n   }\n  return newConn;\n}\n", "docstring": "open a new database connection . this connection must be closed by calling conn . close ( ) .", "partition": "test"}
{"idx": "1124", "code": "public void init(String prefix,java.net.URL url){\n  try {\n    java.io.InputStream in=url.openStream();\n    Properties props=new Properties();\n    props.load(in);\n    init(getLayers(prefix,props));\n  }\n catch (  java.net.MalformedURLException murle) {\n    logger.warning(\"LayerHandler.init(URL): \" + url + \" is not a valid URL\");\n  }\ncatch (  java.io.IOException e) {\n    logger.warning(\"LayerHandler.init(URL): Caught an IOException\");\n  }\n}\n", "docstring": "initialize the layerhandler by having it construct it \"'\" s layers from a url containing an openmap . properties file .", "partition": "test"}
{"idx": "2329", "code": "private void growSpine(){\n  spine=new int[(spine.length << 1) + 1];\n  threshold=(int)(spine.length * loadFactor);\n  Arrays.fill(spine,-1);\n  for (int i=0; i < size; i++) {\n    insert(objs[i],i);\n  }\n}\n", "docstring": "expands the hash \" spine \" - - equivalent to increasing the number of buckets in a conventional hash table .", "partition": "test"}
{"idx": "1582", "code": "public Tasker addTask(Task task){\n  tasks.add(task);\n  lastAddedTask=task;\n  return this;\n}\n", "docstring": "add a new task", "partition": "test"}
{"idx": "4243", "code": "public CallChainInfo(SootMethod m,Stmt s,String type){\n  this.type=type;\n  this.link=\"as_call\";\n  this.method=m;\n  this.stmt=s;\n  calls=1;\n  if (type.equals(\"syscall\"))   syscalls=1;\n}\n", "docstring": "creates a call from stmt s to sootmethod m", "partition": "test"}
{"idx": "3100", "code": "public CProjectConfiguration(final INaviProject project,final ListenerProvider<IProjectListener> listeners,final SQLProvider provider,final int projectId,final String name,final String description,final Date creationDate,final Date modificationDate,final List<DebuggerTemplate> assignedDebuggers){\n  m_project=project;\n  m_listeners=listeners;\n  m_provider=provider;\n  m_id=projectId;\n  m_name=name;\n  m_description=description;\n  m_creationDate=new Date(creationDate.getTime());\n  m_modificationDate=new Date(modificationDate.getTime());\n  m_assignedDebuggers=new ArrayList<DebuggerTemplate>(assignedDebuggers);\n}\n", "docstring": "creates a new configuration object .", "partition": "test"}
{"idx": "1924", "code": "private void pathStyleHelper(String style,String offset){\n  if (style == null) {\n    return;\n  }\n  if (style.equals(\"none\")) {\n    strokePaint.setPathEffect(null);\n    return;\n  }\n  StringTokenizer st=new StringTokenizer(style,\" ,\");\n  int count=st.countTokens();\n  float[] intervals=new float[(count & 1) == 1 ? count * 2 : count];\n  float max=0;\n  float current=1f;\n  int i=0;\n  while (st.hasMoreTokens()) {\n    intervals[i++]=current=toFloat(st.nextToken(),current);\n    max+=current;\n  }\n  for (int start=0; i < intervals.length; i++, start++) {\n    max+=intervals[i]=intervals[start];\n  }\n  float off=0f;\n  if (offset != null) {\n    try {\n      off=Float.parseFloat(offset) % max;\n    }\n catch (    NumberFormatException e) {\n    }\n  }\n  strokePaint.setPathEffect(new DashPathEffect(intervals,off));\n}\n", "docstring": "set the path style ( if any ) stroke - dasharray = \" n1 , n2 , . . . \" stroke - dashoffset = n", "partition": "test"}
{"idx": "2731", "code": "public static Format generateFormat(String codec){\n  return (Format)SUPPORTED_CODECS.get(codec.toLowerCase());\n}\n", "docstring": "generate the format associated to the codec name", "partition": "test"}
{"idx": "2909", "code": "public double calculateExcitatoryRatio(){\n  excitatoryRatio=exSynapseSet.size() / (double)size();\n  if (Double.isNaN(excitatoryRatio)) {\n    return 0;\n  }\n  return excitatoryRatio;\n}\n", "docstring": "if a randomize operation changes the ratio of excitatory to inhibitory synapses , this method can be called to change the excitatoryratio to reflect this value . this happens rarely , and generally speaking is not recommended outside prototyping .", "partition": "test"}
{"idx": "3211", "code": "public void track(File file,Object marker,FileDeleteStrategy deleteStrategy){\n  if (file == null) {\n    throw new NullPointerException(\"The file must not be null\");\n  }\n  addTracker(file.getPath(),marker,deleteStrategy);\n}\n", "docstring": "track the specified file , using the provided marker , deleting the file when the marker instance is garbage collected . the speified deletion strategy is used .", "partition": "test"}
{"idx": "298", "code": "public synchronized void reloadConfiguration(){\n  properties=null;\n  finalParameters.clear();\n}\n", "docstring": "reload configuration from previously added resources . this method will clear all the configuration read from the added resources , and final parameters . this will make the resources to be read again before accessing the values . values that are added via set methods will overlay values read from the resources .", "partition": "test"}
{"idx": "489", "code": "protected void arraycopy(byte[] buf,int pos,int length){\n  mMessage.write(buf,pos,length);\n  mPosition=mPosition + length;\n}\n", "docstring": "copy buf to mmessage .", "partition": "test"}
{"idx": "2768", "code": "public void testPutGetRemove() throws Exception {\n  initStore(2);\n  Set<Integer> exp;\n  try {\n    exp=runPutGetRemoveMultithreaded(10,10);\n  }\n  finally {\n    shutdownStore();\n  }\n  Map<Integer,String> map=delegate.getMap();\n  Collection<Integer> extra=new HashSet<>(map.keySet());\n  extra.removeAll(exp);\n  assertTrue(\"The underlying store contains extra keys: \" + extra,extra.isEmpty());\n  Collection<Integer> missing=new HashSet<>(exp);\n  missing.removeAll(map.keySet());\n  assertTrue(\"Missing keys in the underlying store: \" + missing,missing.isEmpty());\n  for (  Integer key : exp)   assertEquals(\"Invalid value for key \" + key,\"val\" + key,map.get(key));\n}\n", "docstring": "this test performs complex set of operations on store from multiple threads .", "partition": "test"}
{"idx": "766", "code": "public static synchronized DataSourceViewsManager sharedInstance(){\n  if (sharedInstance == null)   sharedInstance=new DataSourceViewsManager();\n  return sharedInstance;\n}\n", "docstring": "returns singleton instance of datasourceviewsmanager .", "partition": "test"}
{"idx": "2907", "code": "public static String[] parseTitle(String title){\n  String v[]={\"\",\"\"};\n  if (title == null)   return v;\n  Pattern p=Pattern.compile(\"(.*)\\\\\\\\s+\\\\\\\\(?([0-9]{4})\\\\\\\\)?\",Pattern.CASE_INSENSITIVE);\n  Matcher m=p.matcher(title);\n  if (m.find()) {\n    v[0]=m.group(1);\n    v[1]=m.group(2);\n  }\n else {\n    v[0]=title;\n  }\n  return v;\n}\n", "docstring": "return a 2 element array . 0 = title ; 1 = date parses the title in the format title year or title ( year )", "partition": "test"}
{"idx": "976", "code": "private Element createIDPEntityDescriptor(boolean exportPrivateData) throws Exception {\n  Element entEle=doc.createElementNS(null,SAMLNames.ENTDESCRIPTOR);\n  String id=idmClient.getEntityID(tenantName);\n  String alias=idmClient.getLocalIDPAlias(tenantName);\n  if (id == null) {\n    id=tenantName;\n  }\n  entEle.setAttribute(SAMLNames.ENTID,id);\n  Element idpSSO=createIDPSSODescriptor(exportPrivateData);\n  entEle.appendChild(idpSSO);\n  if (exportPrivateData) {\n    if (alias == null || alias.isEmpty()) {\n      alias=id;\n    }\n    Element orgEle=createOrganization(tenantName,tenantName,alias,SAMLNames.ENGLISH);\n    entEle.appendChild(orgEle);\n  }\n  return entEle;\n}\n", "docstring": "create extension element of entitydescriptor in dom .", "partition": "test"}
{"idx": "443", "code": "public Iterable<ServiceDescriptor> listServices(){\n  ArrayList<ServiceDescriptor> serviceDescriptors=new ArrayList<ServiceDescriptor>();\n  for (  FileDescriptor fileDescriptor : fileDescriptors) {\n    serviceDescriptors.addAll(fileDescriptor.getServices());\n  }\n  return serviceDescriptors;\n}\n", "docstring": "lists all of the services found in the file descriptors", "partition": "test"}
{"idx": "4082", "code": "private double[][] xPrime(int t){\n  double[][] x=new double[1][getNumLags() * numVars];\n  for (int i=0; i < getNumLags(); i++) {\n    double[][] yPrime=yPrime(t - i - 1);\n    System.arraycopy(yPrime[0],0,x[0],i * numVars,numVars);\n  }\n  return x;\n}\n", "docstring": "constructs the x ( t ) vector .", "partition": "test"}
{"idx": "3814", "code": "boolean destroyVolume(boolean force){\n  NaElement elem=new NaElement(\"volume-destroy\");\n  elem.addNewChild(\"force\",Boolean.toString(force));\n  elem.addNewChild(\"name\",name);\n  try {\n    server.invokeElem(elem);\n    return true;\n  }\n catch (  Exception e) {\n    String msg=\"Failed to destroy volume: \" + name;\n    log.error(msg,e);\n    throw new NetAppException(msg,e);\n  }\n}\n", "docstring": "destroys a volume , releasing all storage blocks assigned to it .", "partition": "test"}
{"idx": "2425", "code": "public synchronized void checkAccess(LicenseCheckerCallback callback){\n  if (mPolicy.allowAccess()) {\n    Log.i(TAG,\"Using cached license response\");\n    callback.allow(Policy.LICENSED);\n  }\n else {\n    LicenseValidator validator=new LicenseValidator(mPolicy,new NullDeviceLimiter(),callback,generateNonce(),mPackageName,mVersionCode);\n    if (mService == null) {\n      Log.i(TAG,\"Binding to licensing service.\");\n      try {\n        boolean bindResult=mContext.bindService(new Intent(new String(Base64.decode(\"Y29tLmFuZHJvaWQudmVuZGluZy5saWNlbnNpbmcuSUxpY2Vuc2luZ1NlcnZpY2U=\"))),this,Context.BIND_AUTO_CREATE);\n        if (bindResult) {\n          mPendingChecks.offer(validator);\n        }\n else {\n          Log.e(TAG,\"Could not bind to service.\");\n          handleServiceConnectionError(validator);\n        }\n      }\n catch (      SecurityException e) {\n        callback.applicationError(LicenseCheckerCallback.ERROR_MISSING_PERMISSION);\n      }\ncatch (      Base64DecoderException e) {\n        e.printStackTrace();\n      }\n    }\n else {\n      mPendingChecks.offer(validator);\n      runChecks();\n    }\n  }\n}\n", "docstring": "checks if the user should have access to the app . binds the service if necessary . < p > note : this call uses a trivially obfuscated string ( base64 - encoded ) . for best security , we recommend obfuscating the string that is passed into bindservice using another method of your own devising . < p > source string : \" com . android . vending . licensing . ilicensingservice \" < p >", "partition": "test"}
{"idx": "1294", "code": "private void shutdown(){\n  if (nbestListWriter != null) {\n    logger.info(\"Closing n-best writer\");\n    nbestListWriter.close();\n  }\n  if (alignmentWriter != null) {\n    logger.info(\"Closing alignment writer\");\n    alignmentWriter.close();\n  }\n}\n", "docstring": "free resources and cleanup .", "partition": "test"}
{"idx": "2379", "code": "@Override public IChatMessage sendMessage(final String text) throws RemoteException {\n  if (TextUtils.isEmpty(text)) {\n    throw new ServerApiIllegalArgumentException(\"GroupChat message must not be null or empty!\");\n  }\n  int messageLength=text.length();\n  int maxMessageLength=mRcsSettings.getMaxGroupChatMessageLength();\n  if (messageLength > maxMessageLength) {\n    throw new ServerApiIllegalArgumentException(\"chat message length: \" + messageLength + \" exceeds max group chat message length: \"+ maxMessageLength+ \"!\");\n  }\n  if (!isAllowedToSendMessage()) {\n    throw new ServerApiPermissionDeniedException(\"Not allowed to send GroupChat message on the connected IMS server!\");\n  }\n  try {\n    mImService.removeGroupChatComposingStatus(mChatId);\n    long timestamp=System.currentTimeMillis();\n    final ChatMessage msg=ChatUtils.createTextMessage(null,text,timestamp,timestamp);\n    ChatMessagePersistedStorageAccessor persistedStorage=new ChatMessagePersistedStorageAccessor(mMessagingLog,msg.getMessageId(),msg.getRemoteContact(),text,msg.getMimeType(),mChatId,Direction.OUTGOING);\n    addOutgoingGroupChatMessage(msg,Content.Status.QUEUED,Content.ReasonCode.UNSPECIFIED);\n    if (!mChatService.isGroupChatActive(mChatId)) {\n      mChatService.setGroupChatStateAndReasonCode(mChatId,GroupChat.State.STARTED,GroupChat.ReasonCode.UNSPECIFIED);\n    }\n    mImService.tryToDequeueGroupChatMessagesAndGroupFileTransfers(mChatId);\n    return new ChatMessageImpl(persistedStorage);\n  }\n catch (  ServerApiBaseException e) {\n    if (!e.shouldNotBeLogged()) {\n      sLogger.error(ExceptionUtil.getFullStackTrace(e));\n    }\n    throw e;\n  }\ncatch (  Exception e) {\n    sLogger.error(ExceptionUtil.getFullStackTrace(e));\n    throw new ServerApiGenericException(e);\n  }\n}\n", "docstring": "sends a text message to the group", "partition": "test"}
{"idx": "53", "code": "@HLEUnimplemented @HLEFunction(nid=0x3C37A7A6,version=150,checkInsideInterrupt=true) public int sceMpegNextAvcRpAu(@CheckArgument(\"checkMpegHandle\") int mpeg,int streamUid){\n  if (!streamMap.containsKey(streamUid)) {\n    log.warn(String.format(\"sceMpegNextAvcRpAu bad stream 0x%X\",streamUid));\n    return -1;\n  }\n  int result=hleMpegGetAvcAu(null);\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceMpegNextAvcRpAu returning 0x%08X\",result));\n    }\n    return result;\n  }\n  videoFrameCount++;\n  startedMpeg=true;\n  return 0;\n}\n", "docstring": "scempegnextavcrpau - skip one video frame", "partition": "test"}
{"idx": "4191", "code": "public String[] parseConfiguration(File xmlFile) throws SAXException, IOException {\n  Document document=builder.parse(xmlFile);\n  return (parseConfiguration(document));\n}\n", "docstring": "parse an xml configuration from a file", "partition": "test"}
{"idx": "3057", "code": "void handleSwfLoadedEvent(SwfLoadedEvent e){\n  dumpSwfLoadedLine(e);\n}\n", "docstring": "called when a swf has been loaded by the player", "partition": "test"}
{"idx": "1372", "code": "public UidRange[] parseUidRange() throws DecodingException {\n  CharacterValidator validator=new MessageSetCharValidator();\n  String nextWord=consumeWord(validator,true);\n  int commaPos=nextWord.indexOf(',');\n  if (commaPos == -1) {\n    return new UidRange[]{parseUidRange(nextWord)};\n  }\n  ArrayList<UidRange> rangeList=new ArrayList<UidRange>();\n  int pos=0;\n  while (commaPos != -1) {\n    String range=nextWord.substring(pos,commaPos);\n    UidRange set=parseUidRange(range);\n    rangeList.add(set);\n    pos=commaPos + 1;\n    commaPos=nextWord.indexOf(',',pos);\n  }\n  String range=nextWord.substring(pos);\n  rangeList.add(parseUidRange(range));\n  List<UidRange> merged=UidRange.mergeRanges(rangeList);\n  return merged.toArray(new UidRange[merged.size()]);\n}\n", "docstring": "reads a \" message set \" argument , and parses into an idset . this also support the use of $ as sequence - set as stated in searchres rfc5182", "partition": "test"}
{"idx": "2759", "code": "public int compare(String s1,String s2){\n  final Matcher match1=MATCH_ID_PATTERN.matcher(s1);\n  final Matcher match2=MATCH_ID_PATTERN.matcher(s2);\n  final boolean match1matches=match1.matches();\n  final boolean match2matches=match2.matches();\n  if (match1matches ^ match2matches) {\n    return (match1matches) ? 1 : -1;\n  }\n else   if (match1matches && match2matches) {\n    int signature1=Integer.parseInt(match1.group(1));\n    int signature2=Integer.parseInt(match2.group(1));\n    int comparison=(signature1 < signature2) ? -1 : (signature1 > signature2) ? 1 : 0;\n    if (comparison == 0) {\n      int start1=Integer.parseInt(match1.group(2));\n      int start2=Integer.parseInt(match2.group(2));\n      comparison=(start1 < start2) ? -1 : (start1 > start2) ? 1 : 0;\n    }\n    if (comparison == 0) {\n      int end1=Integer.parseInt(match1.group(3));\n      int end2=Integer.parseInt(match2.group(3));\n      comparison=(end1 < end2) ? -1 : (end1 > end2) ? 1 : 0;\n    }\n    return comparison;\n  }\n else {\n    int seqLength1=s1.length(), n2=s2.length();\n    for (int i1=0, i2=0; i1 < seqLength1 && i2 < n2; i1++, i2++) {\n      char c1=s1.charAt(i1);\n      char c2=s2.charAt(i2);\n      if (c1 != c2) {\n        c1=Character.toUpperCase(c1);\n        c2=Character.toUpperCase(c2);\n        if (c1 != c2) {\n          c1=Character.toLowerCase(c1);\n          c2=Character.toLowerCase(c2);\n          if (c1 != c2) {\n            return c1 - c2;\n          }\n        }\n      }\n    }\n    return seqLength1 - n2;\n  }\n}\n", "docstring": "sorts on the following : < p / > 1 . the integer used to uniquely identify the signature 2 . earliest start position 3 . earliest stop position", "partition": "test"}
{"idx": "528", "code": "public synchronized Future<V> submit(Callable<V> task) throws RejectedExecutionException {\n  return pool.submit(task);\n}\n", "docstring": "submits a task for execution .", "partition": "test"}
{"idx": "3039", "code": "private void init(){\n  startController=new PourStartController();\n  startController.setCheckView(this);\n  waveController=new WaveController();\n  waveController.setCheckView(this);\n  PourFinishController finishController=new PourFinishController();\n  finishController.setCheckView(this);\n  TickController tickController=new TickController();\n  tickController.setCheckView(this);\n  List<BaseController> finishControllers=new ArrayList<>();\n  finishControllers.add(finishController);\n  finishControllers.add(tickController);\n  this.finishControllers=finishControllers;\n}\n", "docstring": "basic animations to build the liquidbutton", "partition": "test"}
{"idx": "840", "code": "public static HashProvider best(HashParameters params){\n  return best(params,EnumSet.of(HashSupport.STATEFUL));\n}\n", "docstring": "returns the best hash provider supporting at least a stateful implementation of a hash function with the given parameters .", "partition": "test"}
{"idx": "1213", "code": "public Optional<T> last(){\n  Iterator<T> iterator=iterator();\n  T value=null;\n  while (iterator.hasNext())   value=iterator.next();\n  return Optional.of(value);\n}\n", "docstring": "convert an iterable stream into one last item of the stream .", "partition": "test"}
{"idx": "3199", "code": "private synchronized IMqttToken removeMqttToken(Bundle data){\n  String activityToken=data.getString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);\n  if (activityToken != null) {\n    int tokenNumber=Integer.parseInt(activityToken);\n    IMqttToken token=tokenMap.get(tokenNumber);\n    tokenMap.delete(tokenNumber);\n    return token;\n  }\n  return null;\n}\n", "docstring": "get a token identified by a string , and remove it from our map", "partition": "test"}
{"idx": "2031", "code": "public boolean isSetQueueSize(){\n  return __isset_bit_vector.get(__QUEUESIZE_ISSET_ID);\n}\n", "docstring": "returns true if field queuesize is set ( has been assigned a value ) and false otherwise", "partition": "test"}
{"idx": "2016", "code": "private int calculateTotalHeight(float starSize,int numberOfStars,float starsSeparation,boolean padding){\n  return Math.round(starSize) + (padding ? getPaddingTop() + getPaddingBottom() : 0);\n}\n", "docstring": "calculates total height to occupy based on several parameters", "partition": "test"}
{"idx": "2957", "code": "private String formatNode(RightThreadedBinaryNode<T> node){\n  RightThreadedBinaryNode<T> n;\n  StringBuilder response=new StringBuilder(\"(\");\n  if ((n=node.getLeftSon()) != null) {\n    response.append(formatNode(n));\n  }\n  response.append(node.toString());\n  if ((n=node.getRightSon()) != null) {\n    response.append(formatNode(n));\n  }\n  response.append(\")\");\n  return response.toString();\n}\n", "docstring": "format the node , recursively .", "partition": "test"}
{"idx": "3539", "code": "private void onSchemaComplexType(Element schemaComplexType,DatatypeElementFactory elementFactory){\n  Iterator<Element> iter=schemaComplexType.elementIterator(XSD_ATTRIBUTE);\n  while (iter.hasNext()) {\n    Element xsdAttribute=iter.next();\n    String name=xsdAttribute.attributeValue(\"name\");\n    QName qname=getQName(name);\n    XSDatatype dataType=dataTypeForXsdAttribute(xsdAttribute);\n    if (dataType != null) {\n      elementFactory.setAttributeXSDatatype(qname,dataType);\n    }\n  }\n  Element schemaSequence=schemaComplexType.element(XSD_SEQUENCE);\n  if (schemaSequence != null) {\n    onChildElements(schemaSequence,elementFactory);\n  }\n  Element schemaChoice=schemaComplexType.element(XSD_CHOICE);\n  if (schemaChoice != null) {\n    onChildElements(schemaChoice,elementFactory);\n  }\n  Element schemaAll=schemaComplexType.element(XSD_ALL);\n  if (schemaAll != null) {\n    onChildElements(schemaAll,elementFactory);\n  }\n}\n", "docstring": "processes an xml schema & lt ; complextypegt ; tag", "partition": "test"}
{"idx": "651", "code": "protected void checkRowIndex(final int row) throws MathIllegalArgumentException {\n  if (row < 0 || row >= getRowDimension()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.ROW_INDEX,row,0,getRowDimension() - 1);\n  }\n}\n", "docstring": "check if a row index is valid .", "partition": "test"}
{"idx": "1755", "code": "public static boolean createFolder(@SuppressWarnings(\"UnusedParameters\") Context mContext,String path,String folderName){\n  File SDCardRoot=new File(path,folderName);\n  if (!SDCardRoot.exists()) {\n    return SDCardRoot.mkdir();\n  }\n  return false;\n}\n", "docstring": "use to create folder in your directory", "partition": "test"}
{"idx": "254", "code": "public NavMouseMode(boolean shouldConsumeEvents){\n  super(modeID,shouldConsumeEvents);\n  setModeCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n  rectAttributes.setLinePaint(Color.GRAY);\n  rectAttributes.setMattingPaint(Color.LIGHT_GRAY);\n  rectAttributes.setMatted(true);\n}\n", "docstring": "construct a navmousemode . lets you set the consume mode . if the events are consumed , then a mouseevent is sent only to the first mapmouselistener that successfully processes the event . if they are not consumed , then all of the listeners get a chance to act on the event .", "partition": "test"}
{"idx": "2093", "code": "@CalledOnlyBy(AmidstThread.FRAGMENT_LOADER) public void processQueues(){\n  Dimension dimension=dimensionSetting.get();\n  updateLayerManager(dimension);\n  processRecycleQueue();\n  Fragment fragment;\n  while ((fragment=loadingQueue.poll()) != null) {\n    loadFragment(dimension,fragment);\n    dimension=dimensionSetting.get();\n    updateLayerManager(dimension);\n    processRecycleQueue();\n  }\n  layerManager.clearInvalidatedLayers();\n}\n", "docstring": "it is important that the dimension setting is the same while a fragment is loaded by different fragment loaders . this is why the dimension setting is read by the fragment loader thread .", "partition": "test"}
{"idx": "3477", "code": "private boolean isMediaTypeSupported(String media){\n  for (int i=0; i < SUPPORTED_MEDIA_TYPES.length; i++) {\n    if (media.equalsIgnoreCase(SUPPORTED_MEDIA_TYPES[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the specified css media type is unsupported , false otherwise", "partition": "test"}
{"idx": "3832", "code": "public void contentsChanged(ListDataEvent e){\n  Object oldSelection=selectedItemReminder;\n  Object newSelection=dataModel.getSelectedItem();\n  if (oldSelection == null || !oldSelection.equals(newSelection)) {\n    selectedItemChanged();\n    if (!selectingItem) {\n      fireActionEvent();\n    }\n  }\n}\n", "docstring": "this method is public as an implementation side effect . do not call or override .", "partition": "test"}
{"idx": "728", "code": "protected SizeRequirements calculateMinorAxisRequirements(int axis,SizeRequirements r){\n  updateGrid();\n  calculateColumnRequirements(axis);\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  long min=0;\n  long pref=0;\n  int n=columnRequirements.length;\n  for (int i=0; i < n; i++) {\n    SizeRequirements req=columnRequirements[i];\n    min+=req.minimum;\n    pref+=req.preferred;\n  }\n  int adjust=(n + 1) * cellSpacing + 2 * borderWidth;\n  min+=adjust;\n  pref+=adjust;\n  r.minimum=(int)min;\n  r.preferred=(int)pref;\n  r.maximum=(int)pref;\n  AttributeSet attr=getAttributes();\n  CSS.LengthValue cssWidth=(CSS.LengthValue)attr.getAttribute(CSS.Attribute.WIDTH);\n  if (BlockView.spanSetFromAttributes(axis,r,cssWidth,null)) {\n    if (r.minimum < (int)min) {\n      r.maximum=r.minimum=r.preferred=(int)min;\n    }\n  }\n  totalColumnRequirements.minimum=r.minimum;\n  totalColumnRequirements.preferred=r.preferred;\n  totalColumnRequirements.maximum=r.maximum;\n  Object o=attr.getAttribute(CSS.Attribute.TEXT_ALIGN);\n  if (o != null) {\n    String ta=o.toString();\n    if (ta.equals(\"left\")) {\n      r.alignment=0;\n    }\n else     if (ta.equals(\"center\")) {\n      r.alignment=0.5f;\n    }\n else     if (ta.equals(\"right\")) {\n      r.alignment=1;\n    }\n else {\n      r.alignment=0;\n    }\n  }\n else {\n    r.alignment=0;\n  }\n  return r;\n}\n", "docstring": "calculate the requirements for the minor axis . this is called by the superclass whenever the requirements need to be updated ( i . e . a preferencechanged was messaged through this view ) . < p > this is implemented to calculate the requirements as the sum of the requirements of the columns and then adjust it if the css width or height attribute is specified and applicable to the axis .", "partition": "test"}
{"idx": "1169", "code": "private void generateUniformIntegerExamples(Instances format,int numInstances,SubspaceClusterDefinition cl,String cName){\n  Instance example=null;\n  int numAtts=m_NumAttributes;\n  if (getClassFlag()) {\n    numAtts++;\n  }\n  example=new DenseInstance(numAtts);\n  example.setDataset(format);\n  boolean[] attributes=cl.getAttributes();\n  double[] minValue=cl.getMinValue();\n  double[] maxValue=cl.getMaxValue();\n  int[] minInt=new int[minValue.length];\n  int[] maxInt=new int[maxValue.length];\n  int[] intValue=new int[maxValue.length];\n  int[] numInt=new int[minValue.length];\n  int num=1;\n  for (int i=0; i < minValue.length; i++) {\n    minInt[i]=(int)Math.ceil(minValue[i]);\n    maxInt[i]=(int)Math.floor(maxValue[i]);\n    numInt[i]=(maxInt[i] - minInt[i] + 1);\n    num=num * numInt[i];\n  }\n  int numEach=numInstances / num;\n  int rest=numInstances - numEach * num;\n  for (int i=0; i < m_NumAttributes; i++) {\n    if (attributes[i]) {\n      example.setValue(i,minInt[i]);\n      intValue[i]=minInt[i];\n    }\n else {\n      example.setMissing(i);\n    }\n  }\n  if (getClassFlag()) {\n    example.setClassValue(cName);\n  }\n  int added=0;\n  int attr=0;\n  do {\n    for (int k=0; k < numEach; k++) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n    }\n    if (rest > 0) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n      rest--;\n    }\n    if (added >= numInstances) {\n      break;\n    }\n    boolean done=false;\n    do {\n      if (attributes[attr] && (intValue[attr] + 1 <= maxInt[attr])) {\n        intValue[attr]++;\n        done=true;\n      }\n else {\n        attr++;\n      }\n    }\n while (!done);\n    example.setValue(attr,intValue[attr]);\n  }\n while (added < numInstances);\n}\n", "docstring": "generate examples for a uniform cluster dataset .", "partition": "test"}
{"idx": "1883", "code": "public final boolean isExceptionHandlerEquivalent(BasicBlock other){\n  if (exceptionHandlers != other.exceptionHandlers) {\n    Enumeration<BasicBlock> e1=getExceptionHandlers();\n    Enumeration<BasicBlock> e2=other.getExceptionHandlers();\n    while (e1.hasMoreElements()) {\n      if (!e2.hasMoreElements())       return false;\n      if (e1.nextElement() != e2.nextElement())       return false;\n    }\n    if (e2.hasMoreElements())     return false;\n  }\n  return true;\n}\n", "docstring": "compare the in scope exception handlers of two blocks .", "partition": "test"}
{"idx": "1748", "code": "private Map<URI,Map<URI,Map<String,List<URI>>>> createDeviceToCGMapFromDescriptors(List<VolumeDescriptor> addDescriptors,List<VolumeDescriptor> removeDescriptors){\n  Map<URI,Map<URI,Map<String,List<URI>>>> deviceToCGMap=new HashMap<URI,Map<URI,Map<String,List<URI>>>>();\n  for (  VolumeDescriptor descr : addDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToAdd=volumesToUpdate.get(ADD_VOLUMES_TO_CG_KEY);\n    if (volumesToAdd == null) {\n      volumesToAdd=new ArrayList<URI>();\n      volumesToUpdate.put(ADD_VOLUMES_TO_CG_KEY,volumesToAdd);\n    }\n    volumesToAdd.add(descr.getVolumeURI());\n  }\n  for (  VolumeDescriptor descr : removeDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToRemove=volumesToUpdate.get(REMOVE_VOLUMES_FROM_CG_KEY);\n    if (volumesToRemove == null) {\n      volumesToRemove=new ArrayList<URI>();\n      volumesToUpdate.put(REMOVE_VOLUMES_FROM_CG_KEY,volumesToRemove);\n    }\n    volumesToRemove.add(descr.getVolumeURI());\n  }\n  return deviceToCGMap;\n}\n", "docstring": "convenience method to create a map device to cg to volume to add and remove . we want the map to contain both the volumes to add and remove segregated by device and also by cg . the map will look like the below : device uri - - > cg uri - - - - > add - > list of volumes to add from this cg for this device - - - - > remove - > list of volumes to remove from this cg for this device", "partition": "test"}
{"idx": "985", "code": "@NotNull private File resolveName(@NotNull String name) throws IOException {\n  File file;\n  if (name.startsWith(ROOT)) {\n    file=new File(myTemplateRootFolder,name.substring(ROOT.length()));\n  }\n else   if (myLastTemplateFolders != null) {\n    file=new File(myLastTemplateFolders.peek(),name);\n  }\n else {\n    file=new File(myTemplateRootFolder,name);\n  }\n  return file.getCanonicalFile();\n}\n", "docstring": "resolve a freemarker name reference .", "partition": "test"}
{"idx": "1799", "code": "public Node(String permission,boolean value,boolean override,long expireAt,String server,String world,ContextSet contexts){\n  if (permission == null || permission.equals(\"\")) {\n    throw new IllegalArgumentException(\"Empty permission\");\n  }\n  if (server != null && (server.equalsIgnoreCase(\"global\") || server.equals(\"\"))) {\n    server=null;\n  }\n  if (world != null && world.equals(\"\")) {\n    world=null;\n  }\n  if (world != null && server == null) {\n    server=\"global\";\n  }\n  this.permission=permission;\n  this.value=value;\n  this.override=override;\n  this.expireAt=expireAt;\n  this.server=server;\n  this.world=world;\n  this.contexts=contexts == null ? ContextSet.empty() : contexts.makeImmutable();\n}\n", "docstring": "make an immutable node instance", "partition": "test"}
{"idx": "2306", "code": "public static Direction directionForArrowKey(KeyEvent e){\n  int index=Math.max(0,Math.min(e.getKeyCode(),KeyEvent.VK_DOWN) - KeyEvent.VK_LEFT);\n  return Direction.values()[index];\n}\n", "docstring": "returns a direction corresponding to the specified arrow key . if the event does not map to one of the 4 keyboard arrows , the returned direction will be either left or down .", "partition": "test"}
{"idx": "895", "code": "public IntArrayList(int[] data){\n  array=new int[(int)(data.length * 1.1) + 1];\n  size=data.length;\n  System.arraycopy(data,0,array,0,size);\n}\n", "docstring": "constructs a list containing the elements of the specified array . the list instance has an initial capacity of 110 % the size of the specified array .", "partition": "test"}
{"idx": "1375", "code": "private static boolean createNaviDirectory(){\n  final File dir=new File(ConfigHelper.getConfigurationDirectory(Constants.COMPANY_NAME,Constants.PROJECT_NAME));\n  return dir.exists() || dir.mkdir();\n}\n", "docstring": "creates the configuration directory if it does not already exist .", "partition": "test"}
{"idx": "3210", "code": "public void loadLayout(File oFile,boolean newTab){\n  loadLayout(oFile,newTab,false);\n}\n", "docstring": "load a layout from a file . supports loading binary and xml serialized flow files", "partition": "test"}
{"idx": "3073", "code": "private void loadFileRecursively(String path,Map<String,ThriftFileElement> loadedFiles) throws IOException {\n  ThriftFileElement element=null;\n  File dir=null;\n  File file=findFirstExisting(path,null);\n  if (file != null) {\n    file=file.getCanonicalFile();\n    if (loadedFiles.containsKey(file.getAbsolutePath())) {\n      return;\n    }\n    dir=file.getParentFile();\n    element=loadSingleFile(file.getParentFile(),file.getName());\n  }\n  if (element == null) {\n    throw new FileNotFoundException(\"Failed to locate \" + path + \" in \"+ includePaths);\n  }\n  loadedFiles.put(file.getAbsolutePath(),element);\n  ImmutableList<IncludeElement> includes=element.includes();\n  if (includes.size() > 0) {\n    includePaths.addFirst(dir);\n    for (    IncludeElement include : includes) {\n      if (!include.isCpp()) {\n        loadFileRecursively(include.path(),loadedFiles);\n      }\n    }\n    includePaths.removeFirst();\n  }\n}\n", "docstring": "loads and parses a thrift file and all files included ( both directly and transitively ) by it .", "partition": "test"}
{"idx": "3524", "code": "static WindowsFileAttributes readAttributes(long handle) throws WindowsException {\n  NativeBuffer buffer=NativeBuffers.getNativeBuffer(SIZEOF_FILE_INFORMATION);\n  try {\n    long address=buffer.address();\n    GetFileInformationByHandle(handle,address);\n    int reparseTag=0;\n    int fileAttrs=unsafe.getInt(address + OFFSETOF_FILE_INFORMATION_ATTRIBUTES);\n    if (isReparsePoint(fileAttrs)) {\n      int size=MAXIMUM_REPARSE_DATA_BUFFER_SIZE;\n      NativeBuffer reparseBuffer=NativeBuffers.getNativeBuffer(size);\n      try {\n        DeviceIoControlGetReparsePoint(handle,reparseBuffer.address(),size);\n        reparseTag=(int)unsafe.getLong(reparseBuffer.address());\n      }\n  finally {\n        reparseBuffer.release();\n      }\n    }\n    return fromFileInformation(address,reparseTag);\n  }\n  finally {\n    buffer.release();\n  }\n}\n", "docstring": "reads the attributes of an open file", "partition": "test"}
{"idx": "2081", "code": "public final void close(LsServerPacket closePacket,boolean forced){\nsynchronized (guard) {\n    if (isWriteDisabled()) {\n      return;\n    }\n    log.debug(\"sending packet: \" + closePacket + \" and closing connection after that.\");\n    pendingClose=true;\n    isForcedClosing=forced;\n    sendMsgQueue.clear();\n    sendMsgQueue.addLast(closePacket);\n    enableWriteInterest();\n  }\n}\n", "docstring": "its guaranted that closepacket will be sent before closing connection , but all past and future packets wont . connection will be closed [ by dispatcher thread ", "partition": "test"}
{"idx": "3700", "code": "private void createGui(){\n  for (  final IResultsPanel panel : m_factory) {\n    m_tabbedPane.addTab(panel.getTitle(),panel.getComponent());\n  }\n  add(m_tabbedPane,BorderLayout.CENTER);\n  m_tabbedPane.setVisible(true);\n}\n", "docstring": "creates the sub - components of the panel .", "partition": "test"}
{"idx": "2132", "code": "static private double calcLogProb(int numAppear,double mu){\n  final double sigma=calcSigmaFromMu(mu);\n  final double logNumAppear=Math.log(numAppear);\n  final double overMu=Math.max(logNumAppear - mu,0.0);\n  final double res=-(1.0 / 2) * (overMu * overMu) / (sigma * sigma) - s_logSqrtTwoPi - Math.log(sigma);\n  assert (res <= 0);\n  return res;\n}\n", "docstring": "calculate the log probability given the message \"'\" s logarithm is normally distributed . note , here we take the natural logarithm of the normal distribution ( lognormal distribution ) which using log properties and rules turns into the equation whose value gets stored in res .", "partition": "test"}
{"idx": "3249", "code": "public static Geometry bufferBySegments(Geometry g,double distance){\n  Geometry segs=LineHandlingFunctions.extractSegments(g);\n  double posDist=Math.abs(distance);\n  Geometry segBuf=bufferByComponents(segs,posDist);\n  if (distance < 0.0)   return g.difference(segBuf);\n  return g.union(segBuf);\n}\n", "docstring": "buffer polygons by buffering the individual boundary segments and either unioning or differencing them .", "partition": "test"}
{"idx": "887", "code": "public static boolean arrayEquals(Object x,Object y,double tolf,double told){\n  if (x == null && y == null) {\n    return true;\n  }\n  if (x == null || y == null) {\n    return false;\n  }\n  Class<?> xClass=x.getClass();\n  Class<?> yClass=y.getClass();\n  if (xClass != yClass) {\n    return false;\n  }\n  if (!xClass.isArray()) {\n    return x.equals(y);\n  }\n else {\n    if (xClass.equals(int[].class)) {\n      return Arrays.equals((int[])x,(int[])y);\n    }\n else     if (xClass.equals(double[].class)) {\n      if (told == 0) {\n        return Arrays.equals((double[])x,(double[])y);\n      }\n else {\n        return doubleArrayEquals((double[])x,(double[])y,told);\n      }\n    }\n else     if (xClass.equals(long[].class)) {\n      return Arrays.equals((long[])x,(long[])y);\n    }\n else     if (xClass.equals(float[].class)) {\n      if (tolf == 0) {\n        return Arrays.equals((float[])x,(float[])y);\n      }\n else {\n        return floatArrayEquals((float[])x,(float[])y,(float)tolf);\n      }\n    }\n else     if (xClass.equals(byte[].class)) {\n      return Arrays.equals((byte[])x,(byte[])y);\n    }\n else     if (xClass.equals(short[].class)) {\n      return Arrays.equals((short[])x,(short[])y);\n    }\n else     if (xClass.equals(char[].class)) {\n      return Arrays.equals((char[])x,(char[])y);\n    }\n else     if (xClass.equals(boolean[].class)) {\n      return Arrays.equals((boolean[])x,(boolean[])y);\n    }\n else {\n      Object[] xo=(Object[])x;\n      Object[] yo=(Object[])y;\n      if (xo.length != yo.length) {\n        return false;\n      }\n      for (int i=0; i < xo.length; i+=1) {\n        if (!arrayEquals(xo[i],yo[i],tolf,told)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n", "docstring": "are two objects equal ? arrays have the standard object equals method which only returns true if the two object are the same . this method returns true if every element of the arrays match . the inputs may be of any dimensionality . the dimensionality and dimensions of the arrays must match as well as any elements . if the elements are non - primitive . non - tiledimageoperation objects , then the equals method is called for each element . if both elements are multi - dimensional arrays , then the method recurses .", "partition": "test"}
{"idx": "1016", "code": "public Connection(final InetSocketAddress peerAddress){\n  this(peerAddress,(Handshaker)null);\n}\n", "docstring": "creates a new connection to a given peer .", "partition": "test"}
{"idx": "1239", "code": "public void removeSensorSelectionListener(SensorSelectionListener listener){\n  listenerList.remove(SensorSelectionListener.class,listener);\n}\n", "docstring": "remove the specified sensor selection listener .", "partition": "test"}
{"idx": "3122", "code": "private double prediction(Instance inst){\n  double[] normalizedInstance=normalizedInstance(inst);\n  double normalizedPrediction=prediction(normalizedInstance);\n  return denormalizedPrediction(normalizedPrediction);\n}\n", "docstring": "output the prediction made by this perceptron on the given instance", "partition": "test"}
{"idx": "2705", "code": "protected static SyncToken createSyncToken(String dateString,@Nullable String uuid){\n  try {\n    return new SyncToken(DB_DATE_FORMAT.parse(dateString),uuid);\n  }\n catch (  ParseException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "creates a sync token , and converts any thrown exceptions to runtimeexceptions so it can be used for static fields .", "partition": "test"}
{"idx": "4007", "code": "public void init(){\n  _tokenMgmtExecutor.scheduleWithFixedDelay(new ExpiredTokenCleaner(),1,_maxLifeValuesHolder.getMaxTokenIdleTimeInMins(),TimeUnit.MINUTES);\n  _tokenMgmtExecutor.scheduleWithFixedDelay(new TokenKeysUpdater(),1,FOREIGN_TOKEN_KEYS_BUNDLE_REFRESH_RATE_IN_MINS,TimeUnit.MINUTES);\n}\n", "docstring": "initializer , startup the background expired token deletion thread and key updater thread ( no op unless multi vdc )", "partition": "test"}
{"idx": "1047", "code": "private static Pair<String,String> offsetLSR(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2,final String immediateNodeValue){\n  final String address=environment.getNextVariableString();\n  final String tmpVar1=environment.getNextVariableString();\n  final String tmpVar2=environment.getNextVariableString();\n  final String index=environment.getNextVariableString();\n  long baseOffset=offset;\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dw,registerNodeValue2,dw,\"-\" + immediateNodeValue,qw,tmpVar1));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,qw,tmpVar1,dw,dWordBitMask,dw,index));\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue1,dw,index,dw,tmpVar2));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dw,tmpVar2,dw,dWordBitMask,dw,address));\n  return new Pair<String,String>(address,registerNodeValue1);\n}\n", "docstring": "operation : [ < rn > , + / - < rm > , lsr # < shift_imm > ", "partition": "test"}
{"idx": "1389", "code": "public static synchronized void it(String description,UnsafeBlock block){\n  it(description,identity(),block);\n}\n", "docstring": "defines a new example .", "partition": "test"}
{"idx": "1578", "code": "public static int find(byte[] a,int fromIndex,int toIndex,byte[] key){\n  int result=-1;\n  int sublen=key.length;\n  int maxpos, first, sp=0;\n  maxpos=Math.min(toIndex,a.length) - sublen;\n  for (first=fromIndex; sp != sublen && first <= maxpos; first++) {\n    first=find(a,first,maxpos,key[0]);\n    if ((first < 0) || (first > maxpos)) {\n      break;\n    }\n    for (sp=1; sp < sublen; sp++) {\n      if (a[first + sp] != key[sp]) {\n        sp=sublen;\n      }\n    }\n  }\n  if (sublen == 0) {\n    result=0;\n  }\n else   if (sp == sublen) {\n    result=(first - 1);\n  }\n  return result;\n}\n", "docstring": "look for a sequence of bytes in a byte array .", "partition": "test"}
{"idx": "1678", "code": "protected double LLToWorldReturningLon(double lat,double lon,Point2D lp){\n  double phi_deg=lat;\n  double phi=ProjMath.degToRad(phi_deg);\n  double lamba_deg=lon;\n  double lamba=ProjMath.degToRad(lamba_deg);\n  double dlamda=lamba - lamdaf;\n  if (dlamda > Math.PI) {\n    dlamda-=MoreMath.TWO_PI_D;\n  }\n else   if (dlamda < -Math.PI) {\n    dlamda+=MoreMath.TWO_PI_D;\n  }\n  double e=ellps.ecc;\n  double r=0.0d;\n  if (!MoreMath.approximately_equal(Math.abs(phi),MoreMath.HALF_PI,EPS10)) {\n    double t=lambTsfn(phi,Math.sin(phi),e);\n    r=ellps.radius * F * Math.pow(t,n);\n  }\n  double theta=n * dlamda;\n  double easting=falseEasting + r * Math.sin(theta - alpha);\n  double northing=falseNorthing + rf - r * Math.cos(theta - alpha);\n  lp.setLocation(easting,northing);\n  return dlamda;\n}\n", "docstring": "lltoworld that returns normalized longitude in radians , to be used for more calculations in some methods . do not provide a null lp here if you want the world coordinates provided back to you .", "partition": "test"}
{"idx": "1971", "code": "public void cacheResolvedMethod(Class clas,Class[] types,Method method){\n  if (Interpreter.DEBUG)   Interpreter.debug(\"cacheResolvedMethod putting: \" + clas + \" \"+ method);\n  SignatureKey sk=new SignatureKey(clas,method.getName(),types);\n  if (Modifier.isStatic(method.getModifiers()))   resolvedStaticMethods.put(sk,method);\n else   resolvedObjectMethods.put(sk,method);\n}\n", "docstring": "cache a resolved ( possibly overloaded ) method based on the argument types used to invoke it , subject to classloader change . static and object methods are cached separately to support fast lookup in the general case where either will do .", "partition": "test"}
{"idx": "3709", "code": "public Graph(){\n  roots=new ArrayList<Node>();\n  nodes=new ArrayList<Node>();\n  string=\"\";\n}\n", "docstring": "constructs an empty graph", "partition": "test"}
{"idx": "394", "code": "@SuppressWarnings(\"unchecked\") public void testProjectionPredicateDifferentClassLoaders() throws Exception {\n  final Ignite ignite3=startGrid(3);\n  URL[] clsLdrUrls;\n  try {\n    clsLdrUrls=new URL[]{new URL(GridTestProperties.getProperty(\"p2p.uri.cls\"))};\n  }\n catch (  MalformedURLException e) {\n    throw new RuntimeException(\"Define property p2p.uri.cls\",e);\n  }\n  ClassLoader ldr1=new URLClassLoader(clsLdrUrls,getClass().getClassLoader());\n  Class taskCls=ldr1.loadClass(\"org.apache.ignite.tests.p2p.JobStealingTask\");\n  Class nodeFilterCls=ldr1.loadClass(\"org.apache.ignite.tests.p2p.ExcludeNodeFilter\");\n  IgnitePredicate<ClusterNode> nodeFilter=(IgnitePredicate<ClusterNode>)nodeFilterCls.getConstructor(UUID.class).newInstance(ignite2.cluster().localNode().id());\n  Map<UUID,Integer> ret=(Map<UUID,Integer>)executeAsync(compute(ignite1.cluster().forPredicate(nodeFilter)),taskCls,null).get(TASK_EXEC_TIMEOUT_MS);\n  assert ret != null;\n  assert ret.get(ignite1.cluster().localNode().id()) != null && ret.get(ignite1.cluster().localNode().id()) == 2 : ret.get(ignite1.cluster().localNode().id());\n  assert ret.get(ignite3.cluster().localNode().id()) != null && ret.get(ignite3.cluster().localNode().id()) == 2 : ret.get(ignite3.cluster().localNode().id());\n}\n", "docstring": "tests job stealing with peer deployment and different class loaders .", "partition": "test"}
{"idx": "2619", "code": "public static byte[] decode2(String encoded){\n  if (encoded == null) {\n    return null;\n  }\n  char[] base64Data=encoded.toCharArray();\n  int len=removeWhiteSpace(base64Data);\n  if (len % FOURBYTE != 0) {\n    return null;\n  }\n  int numberQuadruple=(len / FOURBYTE);\n  if (numberQuadruple == 0) {\n    return new byte[0];\n  }\n  byte decodedData[]=null;\n  byte b1=0, b2=0, b3=0, b4=0;\n  char d1=0, d2=0, d3=0, d4=0;\n  int i=0;\n  int encodedIndex=0;\n  int dataIndex=0;\n  decodedData=new byte[(numberQuadruple) * 3];\n  for (; i < numberQuadruple - 1; i++) {\n    if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++])) || !isData((d3=base64Data[dataIndex++]))|| !isData((d4=base64Data[dataIndex++]))) {\n      return null;\n    }\n    b1=base64Alphabet[d1];\n    b2=base64Alphabet[d2];\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++]))) {\n    return null;\n  }\n  b1=base64Alphabet[d1];\n  b2=base64Alphabet[d2];\n  d3=base64Data[dataIndex++];\n  d4=base64Data[dataIndex++];\n  if (!isData((d3)) || !isData((d4))) {\n    if (isPad(d3) && isPad(d4)) {\n      if ((b2 & 0xf) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 1];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex]=(byte)(b1 << 2 | b2 >> 4);\n      return tmp;\n    }\n else     if (!isPad(d3) && isPad(d4)) {\n      b3=base64Alphabet[d3];\n      if ((b3 & 0x3) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 2];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n      tmp[encodedIndex]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n      return tmp;\n    }\n else {\n      return null;\n    }\n  }\n else {\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  return decodedData;\n}\n", "docstring": "decodes base64 data into octects", "partition": "test"}
{"idx": "3400", "code": "public static Source fromURL(URL url,Charset cs) throws IOException {\n  URI uri;\n  try {\n    uri=url.toURI();\n  }\n catch (  URISyntaxException e) {\n    throw new IOException(\"Illegal URI\",e);\n  }\n  try (InputStream is=url.openStream()){\n    return fromStream(is,uri,cs);\n  }\n }\n", "docstring": "creates a new source object from a url", "partition": "test"}
{"idx": "2", "code": "public void testReverseOrder4() throws Exception {\n  UUID id=UUID.randomUUID();\n  GridCacheAdapter<String,String> cache=grid.internalCache();\n  GridCacheContext<String,String> ctx=cache.context();\n  GridCacheTestEntryEx entry1=new GridCacheTestEntryEx(ctx,\"1\");\n  GridCacheTestEntryEx entry2=new GridCacheTestEntryEx(ctx,\"2\");\n  GridCacheVersion ver1=version(1);\n  GridCacheVersion ver2=version(2);\n  GridCacheVersion ver3=version(3);\n  GridCacheMvccCandidate v3k1=entry1.addLocal(3,ver3,0,true,false);\n  GridCacheMvccCandidate v3k2=entry2.addLocal(3,ver3,0,true,false);\n  linkCandidates(ctx,v3k1,v3k2);\n  entry1.readyLocal(ver3);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,false,false,false);\n  GridCacheMvccCandidate v1k1=entry1.addLocal(4,ver1,0,true,true);\n  GridCacheMvccCandidate v1k2=entry2.addLocal(4,ver1,0,true,true);\n  linkCandidates(ctx,v1k1,v1k2);\n  entry1.readyLocal(ver1);\n  entry2.readyLocal(ver1);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,false,false,false);\n  checkLocal(v1k1,ver1,true,false,false);\n  checkLocal(v1k2,ver1,true,false,false);\n  GridCacheMvccCandidate v2k2=entry2.addRemote(id,5,ver2,0,false,false);\n  checkRemote(v2k2,ver2,false,false);\n  entry2.readyLocal(v3k2);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,true,true,false);\n}\n", "docstring": "tests local candidates with remote version in the middle on key2 .", "partition": "test"}
{"idx": "2038", "code": "static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {\n  int data=in.readInt();\n  Month month=Month.of(data >>> 28);\n  int dom=((data & (63 << 22)) >>> 22) - 32;\n  int dowByte=(data & (7 << 19)) >>> 19;\n  DayOfWeek dow=dowByte == 0 ? null : DayOfWeek.of(dowByte);\n  int timeByte=(data & (31 << 14)) >>> 14;\n  TimeDefinition defn=TimeDefinition.values()[(data & (3 << 12)) >>> 12];\n  int stdByte=(data & (255 << 4)) >>> 4;\n  int beforeByte=(data & (3 << 2)) >>> 2;\n  int afterByte=(data & 3);\n  LocalTime time=(timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24,0));\n  ZoneOffset std=(stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));\n  ZoneOffset before=(beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));\n  ZoneOffset after=(afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));\n  return ZoneOffsetTransitionRule.of(month,dom,dow,time,timeByte == 24,defn,std,before,after);\n}\n", "docstring": "reads the state from the stream .", "partition": "test"}
{"idx": "250", "code": "public static String toBits(final long x){\n  final StringBuilder sb=new StringBuilder();\n  long t=x;\n  for (int i=0; i < 64; i++) {\n    if ((i & 7) == 0 && i > 0) {\n      sb.append(\":\");\n    }\n    sb.append(t < 0 ? \"1\" : \"0\");\n    t=t << 1;\n  }\n  assert t == 0;\n  return sb.toString();\n}\n", "docstring": "convert a number into a bit string with separators between each group of 8 .", "partition": "test"}
{"idx": "2502", "code": "private static TranslationResult extractRegister(final ITranslationEnvironment environment,final long offset,final String subRegister) throws InternalTranslationException {\n  final ArrayList<ReilInstruction> instructions=new ArrayList<ReilInstruction>();\n  final String parentRegister=getParentRegister(subRegister);\n  final OperandSize archSize=environment.getArchitectureSize();\n  if (isHigher8BitRegister(subRegister)) {\n    final String maskResult=environment.getNextVariableString();\n    final String shiftResult=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAnd(offset,archSize,parentRegister,OperandSize.WORD,\"65280\",OperandSize.WORD,maskResult));\n    instructions.add(ReilHelpers.createBsh(offset + 1,OperandSize.WORD,maskResult,OperandSize.WORD,\"-8\",OperandSize.BYTE,shiftResult));\n    return new TranslationResult(shiftResult,OperandSize.BYTE,TranslationResultType.REGISTER,null,instructions,offset);\n  }\n else {\n    final OperandSize subRegisterSize=getRegisterSize(subRegister);\n    final String mask=String.valueOf(TranslationHelpers.getAllBitsMask(subRegisterSize));\n    final String result=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAnd(offset,archSize,parentRegister,subRegisterSize,mask,subRegisterSize,result));\n    return new TranslationResult(result,subRegisterSize,TranslationResultType.REGISTER,null,instructions,offset);\n  }\n}\n", "docstring": "extracts a subregister ( like ax , al , ah ) from a parent register ( like eax )", "partition": "test"}
{"idx": "2347", "code": "private boolean isUpperCaseCamelCaseHunk(String hunk){\n  if (hunk.length() < 2)   return false;\n  for (int i=0; i < hunk.length(); i++) {\n    if (!isLegalChar(hunk.charAt(i)))     return false;\n  }\n  return true;\n}\n", "docstring": "true if hunk is longer than 1 character and all letters in the hunk are uppercase . false if not .", "partition": "test"}
{"idx": "2981", "code": "default B withDefault(String key,int value){\n  return withDefault(key,Integer.toString(value));\n}\n", "docstring": "if there is no field with the specified key , then associate the given value with the specified key .", "partition": "test"}
{"idx": "4016", "code": "private void initMapLayer(){\n  float zoom=getInitZoom(mapView.getWidth(),mapView.getHeight(),image.getWidth(),image.getHeight());\n  Log.i(TAG,Float.toString(zoom));\n  mapView.setCurrentZoom(zoom,0,0);\n  float width=mapView.getWidth() - zoom * image.getWidth();\n  float height=mapView.getHeight() - zoom * image.getHeight();\n  mapView.translate(width / 2,height / 2);\n}\n", "docstring": "init map image layer", "partition": "test"}
{"idx": "3848", "code": "protected static void drawDataPoint(double x,double y,double xprev,double yprev,int size,int shape,Graphics gx){\n  drawDataPoint(x,y,size,shape,gx);\n  gx.drawLine((int)x,(int)y,(int)xprev,(int)yprev);\n}\n", "docstring": "draws a data point at a given set of panel coordinates at a given size and connects a line to the previous point .", "partition": "test"}
{"idx": "3075", "code": "@Override public boolean add(IMessage message){\n  return add(message,false);\n}\n", "docstring": "this adds a message object to the internal message cache .", "partition": "test"}
{"idx": "4009", "code": "public String toString(){\n  return \"BeanMap<\" + String.valueOf(bean) + \">\";\n}\n", "docstring": "renders a string representation of this object .", "partition": "test"}
{"idx": "3115", "code": "private void removeTvShow(TvShow tvShow){\nsynchronized (root) {\n    TvShowTreeNode child=(TvShowTreeNode)nodeMap.get(tvShow);\n    DefaultMutableTreeNode parent=root;\n    if (child != null) {\n      int index=getIndexOfChild(parent,child);\n      nodeMap.remove(tvShow);\n      for (      TvShowEpisode episode : new ArrayList<>(tvShow.getEpisodes())) {\n        nodeMap.remove(episode);\n        episode.removePropertyChangeListener(propertyChangeListener);\n      }\n      tvShow.removePropertyChangeListener(propertyChangeListener);\n      child.removeAllChildren();\n      child.removeFromParent();\n      if (index > -1) {\n        TreeModelEvent event=new TreeModelEvent(this,parent.getPath(),new int[]{index},new Object[]{child});\n        for (        TreeModelListener listener : listeners) {\n          try {\n            listener.treeNodesRemoved(event);\n          }\n catch (          NullPointerException|ArrayIndexOutOfBoundsException npe) {\n          }\n        }\n      }\n    }\n  }\n}\n", "docstring": "removes the tv show .", "partition": "test"}
{"idx": "4224", "code": "public void fireEvent(final SPARQLUpdateEvent e){\n  if (isReadOnly())   throw new UnsupportedOperationException();\n  if (e == null)   throw new IllegalArgumentException();\n  if (listeners.isEmpty()) {\n    return;\n  }\n  final ISPARQLUpdateListener[] a=listeners.toArray(new ISPARQLUpdateListener[0]);\n  for (  ISPARQLUpdateListener l : a) {\n    final ISPARQLUpdateListener listener=l;\n    try {\n      listener.updateEvent(e);\n    }\n catch (    Throwable t) {\n      if (InnerCause.isInnerCause(t,InterruptedException.class)) {\n        throw new RuntimeException(t);\n      }\n      log.error(t,t);\n    }\n  }\n}\n", "docstring": "send an event to all registered listeners .", "partition": "test"}
{"idx": "2262", "code": "public static String toString(Document hostDoc) throws IOException {\n  try {\n    StringWriter out=new StringWriter();\n    DOMSource domSource=new DOMSource(hostDoc);\n    StreamResult streamResult=new StreamResult(out);\n    TransformerFactory tf=TransformerFactory.newInstance();\n    Transformer serializer=tf.newTransformer();\n    serializer.setOutputProperty(OutputKeys.ENCODING,ENC.name());\n    serializer.setOutputProperty(OutputKeys.METHOD,\"html\");\n    serializer.setOutputProperty(OutputKeys.INDENT,\"no\");\n    serializer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC,HtmlDomUtil.HTML_STRICT);\n    serializer.transform(domSource,streamResult);\n    return out.toString();\n  }\n catch (  TransformerException e) {\n    IOException r=new IOException(\"Error transforming page\");\n    r.initCause(e);\n    throw r;\n  }\n}\n", "docstring": "convert a document to a string , assuming later encoding to utf - 8 .", "partition": "test"}
{"idx": "3969", "code": "public void add(T item){\nsynchronized (lock) {\n    items.add(identifiedItemFactory.create(item));\n  }\n  notifyDataSetChanged();\n}\n", "docstring": "adds the specified item at the end of the array .", "partition": "test"}
{"idx": "647", "code": "public ResourceQueue(final NonBlockingLockManagerWithNewDesign<R> lockService,final R resource){\n  if (lockService == null)   throw new IllegalArgumentException();\n  if (resource == null)   throw new IllegalArgumentException();\n  this.lockService=lockService;\n  this.resource=resource;\n  this.queue=new LinkedBlockingQueue<T>();\n  this.statisticsTask=new QueueSizeMovingAverageTask(resource.toString(),queue);\n}\n", "docstring": "create a queue of lock requests for a resource .", "partition": "test"}
{"idx": "1023", "code": "public boolean importPkcs8(){\n  return jrbPkcs8.isSelected();\n}\n", "docstring": "has the user chosen to import from pkcs # 8 private key and certificate file combination ?", "partition": "test"}
{"idx": "3791", "code": "protected void calculateDestination(IFile uxf,ICompilationUnit referencingCompilationUnit,Destination dest) throws CoreException {\n  IFile uxfDest=calculateImgDestination(uxf,referencingCompilationUnit);\n  if (uxfDest != null) {\n    dest.imgFileDestination=uxfDest;\n  }\n}\n", "docstring": "calculate the destination of the given umlet diagram . return null if the diagram reference does not need to be updated", "partition": "test"}
{"idx": "1559", "code": "public static synchronized MBeanInfo testCompliance(final Class<?> baseClass,Class<?> mbeanInterface) throws NotCompliantMBeanException {\n  if (mbeanInterface == null)   mbeanInterface=getStandardMBeanInterface(baseClass);\n  ReflectUtil.checkPackageAccess(mbeanInterface);\n  MBeanIntrospector<?> introspector=StandardMBeanIntrospector.getInstance();\n  return getClassMBeanInfo(introspector,baseClass,mbeanInterface);\n}\n", "docstring": "basic method for testing if a given class is a jmx compliant standard mbean . this method is only called by the legacy code in com . sun . management . jmx .", "partition": "test"}
{"idx": "1713", "code": "public HttpRequest ifModifiedSince(final long value){\n  connection.setIfModifiedSince(value);\n  return this;\n}\n", "docstring": "set the \"'\" if - modified - since \"'\" request header to the given value", "partition": "test"}
{"idx": "3702", "code": "public SGenItemProviderAdapterFactory(){\n  supportedTypes.add(IEditingDomainItemProvider.class);\n  supportedTypes.add(IStructuredItemContentProvider.class);\n  supportedTypes.add(ITreeItemContentProvider.class);\n  supportedTypes.add(IItemLabelProvider.class);\n  supportedTypes.add(IItemPropertySource.class);\n}\n", "docstring": "this constructs an instance . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "3083", "code": "public List<Interface> showInterface() throws NetworkDeviceControllerException {\n  List<Interface> interfaces=new ArrayList<Interface>();\n  SSHPrompt[] prompts={SSHPrompt.POUND,SSHPrompt.GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  SSHPrompt prompt=sendWaitFor(MDSDialogProperties.getString(\"MDSDialog.showInterface.cmd\"),60000,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showInterface.interfacename.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.Portdescription.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.PortWWN.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.PortmodeFCID.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.Portvsan.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.Portmode.match\")};\n  String[] groups=new String[10];\n  Interface intf=null;\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      intf=new Interface(groups[0]);\n    intf.setStatus(groups[1]);\n  interfaces.add(intf);\nbreak;\ncase 1:\nintf.setDescription(groups[0]);\nbreak;\ncase 2:\nintf.setWwpn(groups[0]);\nbreak;\ncase 3:\nintf.setMode(groups[0]);\nintf.setFcid(groups[1]);\nbreak;\ncase 4:\nintf.setVsan(groups[0]);\nbreak;\ncase 5:\nintf.setMode(groups[0]);\nbreak;\n}\n}\nreturn interfaces;\n}\n", "docstring": "issues the \" show interface \" command and collects in information into a list of interfaces . for now only parses fiber channel interfaces starting with \" fc \" , e . g . fc1 / 1 , fc2 / 20 , . . . this method is not currently used .", "partition": "test"}
{"idx": "3121", "code": "protected OSXAdapter(String proxySignature,Object target,Method handler){\n  this.proxySignature=proxySignature;\n  this.targetObject=target;\n  this.targetMethod=handler;\n}\n", "docstring": "each osxadapter has the name of the eawt method it intends to listen for ( handleabout , for example ) , the object that will ultimately perform the task , and the method to be called on that object .", "partition": "test"}
{"idx": "1762", "code": "public static boolean expressionIsTrue(double leftSide,Operator operator,double rightSide){\n  final String expression=leftSide + operator.getMathematicalOperator() + rightSide;\n  return expressionIsTrue(expression);\n}\n", "docstring": "evaluates whether an expression is true or false .", "partition": "test"}
{"idx": "3617", "code": "public void translateAndAppendPending(int backoff) throws UnsupportedEncodingException {\n  int bufferEnd=current - backoff;\n  int len=bufferEnd - complete;\n  output.append(new String(input,offset + complete,len,charset));\n  complete=bufferEnd;\n}\n", "docstring": "translate pending bytes using selected character set . bytes are translated up to current position minus the backoff value .", "partition": "test"}
{"idx": "1616", "code": "public CharBuffer delete(int start,int end){\n  int length=length();\n  if (start < 0 || end < start || length < start)   throw new StringIndexOutOfBoundsException();\n  end=Math.min(length,end);\n  int tail=length - end;\n  char[] buffer=buffer();\n  for (int i=0; i < tail; i++) {\n    buffer[start + i]=buffer[end + i];\n  }\n  length(length - (end - start));\n  return this;\n}\n", "docstring": "deletes characters from the buffer .", "partition": "test"}
{"idx": "2235", "code": "public Boolean exists(String email){\n  for (  Person person : people) {\n    if (email.equals(person.getEmail())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "given an email checks if the person exists in the manager .", "partition": "test"}
{"idx": "2876", "code": "public void append(byte[] bytes){\n  append(bytes,0,bytes.length);\n}\n", "docstring": "append specified bytes to the buffer", "partition": "test"}
{"idx": "1058", "code": "public static DereferenceAliasesPolicy valueOf(final int intValue){\n  if (intValue < 0 || intValue >= ELEMENTS.length) {\n    return null;\n  }\n  return ELEMENTS[intValue];\n}\n", "docstring": "returns the alias dereferencing policy having the specified integer value as defined in rfc 4511 section 4 . 5 . 1 .", "partition": "test"}
{"idx": "460", "code": "private void registerNewClient(JsonObject jData){\n  Client newClient=gson.fromJson(jData,Client.class);\n  if (newClient.isValid()) {\n    addClient(newClient);\n    broadcastNewClient(newClient);\n    sendClientList(newClient);\n  }\n else {\n    logger.log(Level.WARNING,\"Could not unpack received data into a Client.\");\n  }\n}\n", "docstring": "create client from given json data , add client to client list , broadcast newly registered client to all previously registered clients and send client list to new client .", "partition": "test"}
{"idx": "1902", "code": "private void copyDirectory(File source,File dest) throws IOException {\n  for (  File f : source.listFiles()) {\n    File sourceFile=new File(source,f.getName());\n    File destFile=new File(dest,f.getName());\n    if (f.isDirectory()) {\n      destFile.mkdirs();\n      copyDirectory(sourceFile,destFile);\n    }\n else     copyFile(sourceFile,destFile);\n  }\n}\n", "docstring": "copy an entire directory from one location to another . this is used in file dumping .", "partition": "test"}
{"idx": "771", "code": "public void poll(final TcpSocketStatisticsHandler handler){\n  this.statisticsHandler=handler;\n  try {\n    fileLoader.load();\n    final ByteBuffer buffer=fileLoader.getBuffer();\n    lineParser.reset();\n    lineParser.handleToken(buffer,buffer.position(),buffer.limit());\n  }\n  finally {\n    this.statisticsHandler=null;\n  }\n  monitoredSockets.purgeEntriesOlderThan(updateCount);\n  updateCount++;\n}\n", "docstring": "read from monitored file , report any changed values for monitored socket statistics . not thread - safe , only call from a single thread .", "partition": "test"}
{"idx": "2481", "code": "private static String partitionSpecToName(Map<String,String> spec){\n  StringBuilder sb=new StringBuilder();\n  for (  Map.Entry<String,String> entry : spec.entrySet()) {\n    if (sb.length() != 0) {\n      sb.append(\"/\");\n    }\n    sb.append(entry.getKey() + \"=\" + entry.getValue());\n  }\n  return sb.toString();\n}\n", "docstring": "converts a map of partition key - value pairs to a name . note that special characters are not escaped unlike in production , and the order of the key is dictated by the iteration order for the map .", "partition": "test"}
{"idx": "2554", "code": "public void createDiskAsync(final String projectId,final DiskCreateSpec diskCreateSpec,final FutureCallback<Task> responseCallback) throws IOException {\n  final String path=String.format(\"%s/%s/disks\",getBasePath(),projectId);\n  createObjectAsync(path,serializeObjectAsJson(diskCreateSpec),responseCallback);\n}\n", "docstring": "create a disk in the specified project .", "partition": "test"}
{"idx": "2259", "code": "public static byte[] escape(final byte[] bytes){\n  final byte[] temp=new byte[2 * bytes.length];\n  int currentPosition=0;\n  for (  final byte b : bytes) {\n    if (b == ESCAPE_CHAR) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=REPLACEMENT_CHAR;\n    }\n else     if (b == DELIMITER) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=ESCAPE_CHAR;\n    }\n else {\n      temp[currentPosition++]=b;\n    }\n  }\n  final byte[] escaped=new byte[currentPosition];\n  System.arraycopy(temp,0,escaped,0,currentPosition);\n  return escaped;\n}\n", "docstring": "escapes the provided string so that it no longer contains the constants . delimiter character .", "partition": "test"}
{"idx": "2296", "code": "public JKTagMapping(final String sourceQName,final String targetQName,final JKNamespace namespace){\n  logger.info(String.format(\"creating TagMapping with sourceTag(%s) and (%s)\",sourceQName,targetQName));\n  this.sourceQName=sourceQName;\n  this.targetQName=targetQName;\n  this.namespace=namespace;\n  this.auto=true;\n}\n", "docstring": "instantiates a new jk tag mapping .", "partition": "test"}
{"idx": "1728", "code": "public void reset(){\n  engineReset();\n  state=INITIAL;\n}\n", "docstring": "resets the digest for further use .", "partition": "test"}
{"idx": "3302", "code": "public void requestPasswordForShareViaLink(boolean createShare){\n  SharePasswordDialogFragment dialog=SharePasswordDialogFragment.newInstance(mFile,createShare);\n  dialog.show(getFragmentManager(),SharePasswordDialogFragment.PASSWORD_FRAGMENT);\n}\n", "docstring": "starts a dialog that requests a password to the user to protect a share link .", "partition": "test"}
{"idx": "2202", "code": "public static double bufferDistanceError(int quadSegs){\n  double alpha=Math.PI / 2.0 / quadSegs;\n  return 1 - Math.cos(alpha / 2.0);\n}\n", "docstring": "computes the maximum distance error due to a given level of approximation to a true arc .", "partition": "test"}
{"idx": "1521", "code": "public String toEPL(EPStatementFormatter formatter){\n  StringWriter writer=new StringWriter();\n  toEPL(formatter,writer);\n  return writer.toString();\n}\n", "docstring": "rendering using the provided formatter .", "partition": "test"}
{"idx": "2198", "code": "public ComputeTaskCancelledException(Throwable cause){\n  this(cause.getMessage(),cause);\n}\n", "docstring": "creates new task cancellation exception given throwable as a cause and source of error message .", "partition": "test"}
{"idx": "3116", "code": "private ComplianceFeature checkEncryptPolicy(org.wso2.emm.agent.beans.Operation operation){\n  boolean encryptStatus=(devicePolicyManager.getStorageEncryptionStatus() != devicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED && devicePolicyManager.getStorageEncryptionStatus() != devicePolicyManager.ENCRYPTION_STATUS_INACTIVE);\n  if ((operation.isEnabled() && encryptStatus) || (!operation.isEnabled() && !encryptStatus)) {\n    policy.setCompliance(true);\n  }\n else {\n    policy.setCompliance(false);\n    policy.setMessage(resources.getString(R.string.error_encrypt_policy));\n  }\n  return policy;\n}\n", "docstring": "checks device encrypt policy on the device ( device external storage encryption ) .", "partition": "test"}
{"idx": "3029", "code": "public static boolean isIntentAvailable(Context context,String action){\n  final PackageManager packageManager=context.getPackageManager();\n  final Intent intent=new Intent(action);\n  Log.d(MP_TAG,\"Looking for intent \" + action);\n  List<ResolveInfo> list=packageManager.queryIntentServices(intent,PackageManager.MATCH_DEFAULT_ONLY);\n  return list.size() > 0;\n}\n", "docstring": "indicates whether the specified action can be used as an intent . this method queries the package manager for installed packages that can respond to an intent with the specified action . if no suitable package is found , this method returns false .", "partition": "test"}
{"idx": "3603", "code": "protected void newFastClockMinute(){\n  for (int i=delayedTrains.size() - 1; i >= 0; i--) {\n    ActiveTrain at=delayedTrains.get(i);\n    if ((!at.getStarted()) && at.getDelayedStart() != ActiveTrain.NODELAY) {\n      if (at.getDelayedStart() == ActiveTrain.TIMEDDELAY) {\n        if (isFastClockTimeGE(at.getDepartureTimeHr(),at.getDepartureTimeMin())) {\n          at.setStarted();\n          delayedTrains.remove(i);\n          if (_AutoAllocate) {\n            autoAllocate.scanAllocationRequestList(allocationRequests);\n          }\n        }\n      }\n    }\n else     if (at.getStarted() && at.getStatus() == ActiveTrain.READY && at.reachedRestartPoint()) {\n      if (isFastClockTimeGE(at.getRestartDepartHr(),at.getRestartDepartMin())) {\n        at.restart();\n        delayedTrains.remove(i);\n        if (_AutoAllocate) {\n          autoAllocate.scanAllocationRequestList(allocationRequests);\n        }\n      }\n    }\n  }\n}\n", "docstring": "handle activity that is triggered by the fast clock", "partition": "test"}
{"idx": "1840", "code": "public boolean grabInput(){\n  if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {\n    grabLog.fine(\"Grab input on {0}\",this);\n  }\n  XToolkit.awtLock();\n  try {\n    if (XAwtState.getGrabWindow() == this && XAwtState.isManualGrab()) {\n      grabLog.fine(\"    Already Grabbed\");\n      return true;\n    }\n    XBaseWindow prevGrabWindow=XAwtState.getGrabWindow();\n    final int eventMask=(int)(XConstants.ButtonPressMask | XConstants.ButtonReleaseMask | XConstants.EnterWindowMask| XConstants.LeaveWindowMask| XConstants.PointerMotionMask| XConstants.ButtonMotionMask);\n    final int ownerEvents=1;\n    if (!XToolkit.getSunAwtDisableGrab()) {\n      int ptrGrab=XlibWrapper.XGrabPointer(XToolkit.getDisplay(),getContentWindow(),ownerEvents,eventMask,XConstants.GrabModeAsync,XConstants.GrabModeAsync,XConstants.None,(XWM.isMotif() ? XToolkit.arrowCursor : XConstants.None),XConstants.CurrentTime);\n      if (ptrGrab != XConstants.GrabSuccess) {\n        XlibWrapper.XUngrabPointer(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XAwtState.setGrabWindow(null);\n        grabLog.fine(\"    Grab Failure - mouse\");\n        return false;\n      }\n      int keyGrab=XlibWrapper.XGrabKeyboard(XToolkit.getDisplay(),getContentWindow(),ownerEvents,XConstants.GrabModeAsync,XConstants.GrabModeAsync,XConstants.CurrentTime);\n      if (keyGrab != XConstants.GrabSuccess) {\n        XlibWrapper.XUngrabPointer(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XlibWrapper.XUngrabKeyboard(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XAwtState.setGrabWindow(null);\n        grabLog.fine(\"    Grab Failure - keyboard\");\n        return false;\n      }\n    }\n    if (prevGrabWindow != null) {\n      prevGrabWindow.ungrabInputImpl();\n    }\n    XAwtState.setGrabWindow(this);\n    grabLog.fine(\"    Grab - success\");\n    return true;\n  }\n  finally {\n    XToolkit.awtUnlock();\n  }\n}\n", "docstring": "we should always grab both keyboard and pointer to control event flow on popups . this also simplifies synthetic grab implementation . the active grab overrides activated automatic grab .", "partition": "test"}
{"idx": "3759", "code": "private static ServiceTicketResponse checkGetNfcServiceTicketResponse(ServiceTicketResponse serviceTicketResponse) throws RpcException {\n  logger.info(\"Checking {}\",serviceTicketResponse);\nswitch (serviceTicketResponse.getResult()) {\ncase OK:\n    break;\ncase SYSTEM_ERROR:\n  throw new SystemErrorException(serviceTicketResponse.getError());\ncase NOT_FOUND:\nthrow new DatastoreNotFoundException(serviceTicketResponse.getError());\ndefault :\nthrow new RpcException(String.format(\"Unknown result: %s\",serviceTicketResponse.getError()));\n}\nreturn serviceTicketResponse;\n}\n", "docstring": "this method validates a serviceticketresponse object , raising an exception if the response reflects an operation failure .", "partition": "test"}
{"idx": "2706", "code": "private static boolean equalsHandlesNulls(Object a,Object b){\n  return a == b || (a != null && a.equals(b));\n}\n", "docstring": "returns true if a and b are equal or are both null .", "partition": "test"}
{"idx": "2964", "code": "public static Date convertISO8601toDate(String dateString) throws ParseException {\n  DateFormat dateFormat=new SimpleDateFormat(\"yyyy-MM-dd\\'T\\'HH:mm:ss\");\n  Date date=dateFormat.parse(dateString);\n  return date;\n}\n", "docstring": "method that converts a an iso 8601 string to java date", "partition": "test"}
{"idx": "352", "code": "public static ParsedSql parseSqlStatement(String sql){\n  Set<String> namedParameters=new HashSet<String>();\n  ParsedSql parsedSql=new ParsedSql(sql);\n  char[] statement=sql.toCharArray();\n  int namedParameterCount=0;\n  int unnamedParameterCount=0;\n  int totalParameterCount=0;\n  int i=0;\n  while (i < statement.length) {\n    int skipToPosition=skipCommentsAndQuotes(statement,i);\n    if (i != skipToPosition) {\n      if (skipToPosition >= statement.length) {\n        break;\n      }\n      i=skipToPosition;\n    }\n    char c=statement[i];\n    if (c == ':' || c == '&') {\n      int j=i + 1;\n      if (j < statement.length && statement[j] == ':' && c == ':') {\n        i=i + 2;\n        continue;\n      }\n      while (j < statement.length && !isParameterSeparator(statement[j])) {\n        j++;\n      }\n      if (j - i > 1) {\n        String parameter=sql.substring(i + 1,j);\n        if (!namedParameters.contains(parameter)) {\n          namedParameters.add(parameter);\n          namedParameterCount++;\n        }\n        parsedSql.addNamedParameter(parameter,i,j);\n        totalParameterCount++;\n      }\n      i=j - 1;\n    }\n else {\n      if (c == '?') {\n        unnamedParameterCount++;\n        totalParameterCount++;\n      }\n    }\n    i++;\n  }\n  parsedSql.setNamedParameterCount(namedParameterCount);\n  parsedSql.setUnnamedParameterCount(unnamedParameterCount);\n  parsedSql.setTotalParameterCount(totalParameterCount);\n  return parsedSql;\n}\n", "docstring": "parse the sql statement and locate any placeholders or named parameters . named parameters are substituted for a jdbc placeholder .", "partition": "test"}
{"idx": "700", "code": "public synchronized int totalRecoverFiles(){\n  int total=0;\n  for (  File file : fileDetails.values()) {\n    if (file.reused() == false) {\n      total++;\n    }\n  }\n  return total;\n}\n", "docstring": "total number of files to be recovered ( potentially not yet done )", "partition": "test"}
{"idx": "491", "code": "private void handleSelection(View view,Item item,int position){\n  if (!item.isSelectable()) {\n    return;\n  }\n  if (item.isSelected() && !mAllowDeselection) {\n    return;\n  }\n  boolean selected=false;\n  if (mPositionBasedStateManagement) {\n    selected=mSelections.contains(position);\n  }\n else {\n    selected=item.isSelected();\n  }\n  if (mSelectWithItemUpdate || view == null) {\n    if (!mMultiSelect) {\n      deselect();\n    }\n    if (selected) {\n      deselect(position);\n    }\n else {\n      select(position);\n    }\n  }\n else {\n    if (!mMultiSelect) {\n      if (mPositionBasedStateManagement) {\n        Iterator<Integer> entries=mSelections.iterator();\n        while (entries.hasNext()) {\n          Integer pos=entries.next();\n          if (pos != position) {\n            deselect(pos,entries);\n          }\n        }\n      }\n else {\n        Set<Integer> selections=getSelections();\n        for (        int pos : selections) {\n          if (pos != position) {\n            deselect(pos);\n          }\n        }\n      }\n    }\n    item.withSetSelected(!selected);\n    view.setSelected(!selected);\n    if (mSelectionListener != null)     mSelectionListener.onSelectionChanged(item,!selected);\n    if (mPositionBasedStateManagement) {\n      if (selected) {\n        if (mSelections.contains(position)) {\n          mSelections.remove(position);\n        }\n      }\n else {\n        mSelections.add(position);\n      }\n    }\n  }\n}\n", "docstring": "handles the selection and deselects item if multiselect is disabled", "partition": "test"}
{"idx": "3125", "code": "public int rgbFor(int pixel){\n  return surfaceType.rgbFor(pixel,colorModel);\n}\n", "docstring": "returns the argb representation for the specified integer value which is packed in the format of the associated colormodel .", "partition": "test"}
{"idx": "2968", "code": "public static void copyAssets(Context context,String assetsFilename,File file,String mode) throws IOException, InterruptedException {\n  String abi=Build.CPU_ABI;\n  String libraryName;\n  if (abi.equalsIgnoreCase(\"armeabi\")) {\n    libraryName=\"armeabi\";\n  }\n else   if (abi.equalsIgnoreCase(\"x86\")) {\n    libraryName=\"x86\";\n  }\n else   if (abi.contains(\"armeabi-v7\")) {\n    libraryName=\"armeabi-v7a\";\n  }\n else {\n    return;\n  }\n  AssetManager manager=context.getAssets();\n  final InputStream is=manager.open(libraryName + \"/\" + assetsFilename);\n  copyFile(file,is,mode);\n}\n", "docstring": "copy file in assets into destination file", "partition": "test"}
{"idx": "3455", "code": "@Override public boolean deleteLeftWord(){\n  mInputConnection.beginBatchEdit();\n  if (mInputConnection.getSelectedText(0) != null) {\n    mInputConnection.commitText(\"\",0);\n  }\n else {\n    CharSequence beforeCursor=mInputConnection.getTextBeforeCursor(MAX_DELETABLE_CONTEXT,0);\n    if (beforeCursor != null) {\n      int beforeCursorLength=beforeCursor.length();\n      Matcher m=WHITESPACE_AND_TOKEN.matcher(beforeCursor);\n      int lastIndex=0;\n      while (m.find()) {\n        lastIndex=beforeCursorLength == m.end() ? m.start() : m.end();\n      }\n      if (lastIndex > 0) {\n        mInputConnection.deleteSurroundingText(beforeCursorLength - lastIndex,0);\n      }\n else       if (beforeCursorLength < MAX_DELETABLE_CONTEXT) {\n        mInputConnection.deleteSurroundingText(beforeCursorLength,0);\n      }\n    }\n  }\n  mInputConnection.endBatchEdit();\n  return true;\n}\n", "docstring": "deletes all characters up to the leftmost whitespace from the cursor ( including the whitespace ) . if something is selected then delete the selection . todo : maybe expensive ?", "partition": "test"}
{"idx": "1658", "code": "public static boolean isConnectedUsingWifi(){\n  Context context=FeApp.getAppContext();\n  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo ni=cm.getActiveNetworkInfo();\n  return ni != null && ni.isConnected() == true && ni.getType() == ConnectivityManager.TYPE_WIFI;\n}\n", "docstring": "checks to see if we are connected using wifi", "partition": "test"}
{"idx": "590", "code": "public void testInvokeAny4() throws Throwable {\n  CountDownLatch latch=new CountDownLatch(1);\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    List<Callable<String>> l=new ArrayList<Callable<String>>();\n    l.add(latchAwaitingStringTask(latch));\n    l.add(null);\n    try {\n      e.invokeAny(l);\n      shouldThrow();\n    }\n catch (    NullPointerException success) {\n    }\n    latch.countDown();\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "invokeany ( c ) throws nullpointerexception if c has null elements", "partition": "test"}
{"idx": "4065", "code": "private int calculateGraidentChannel(int sourceChannel,int destChannel,int distance,int offset){\n  if (sourceChannel == destChannel) {\n    return sourceChannel;\n  }\n  float ratio=((float)offset) / ((float)distance);\n  int pos=(int)(Math.abs(sourceChannel - destChannel) * ratio);\n  if (sourceChannel > destChannel) {\n    return sourceChannel - pos;\n  }\n else {\n    return sourceChannel + pos;\n  }\n}\n", "docstring": "converts the color channel value according to the offest within the distance", "partition": "test"}
{"idx": "2596", "code": "private void navigateToDump(){\n  TreePath currentPath=tree.getSelectionPath();\n  tree.setSelectionPath(currentPath.getParentPath());\n  tree.scrollPathToVisible(currentPath.getParentPath());\n}\n", "docstring": "navigate to root node of currently active dump", "partition": "test"}
{"idx": "1541", "code": "protected void defineLabels(){\n  labelsValues=calcLabels();\n  if (handleValues)   labels=getLabelsFromValues();\n else   labels=getLabelsFromData();\n  nLabels=labels.size();\n}\n", "docstring": "defines what will be the axis labels", "partition": "test"}
{"idx": "742", "code": "public void add(IPoint pt){\n  if (inProgress) {\n    throw new ConcurrentModificationException(\"Can\\'t add point while iterator in progress\");\n  }\n  points.add(pt);\n}\n", "docstring": "add point to the result set .", "partition": "test"}
{"idx": "3081", "code": "public Joiner join(Class<? extends DataObject> clazz,String alias,URI... ids){\n  return join(clazz,alias,new ArrayList<URI>(Arrays.asList(ids)));\n}\n", "docstring": "starts a new query not related to a previous class query .", "partition": "test"}
{"idx": "3720", "code": "@Override public final void onHeatmapFailed(){\n  updatePending=false;\n}\n", "docstring": "callback function when heatmap generation has failed", "partition": "test"}
{"idx": "1509", "code": "public double doOperation() throws OperatorFailedException {\n  double logq;\n  final NodeRef root=tree.getRoot();\n  final double oldTreeHeight=tree.getNodeHeight(root);\n  NodeRef i;\n  do {\n    i=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n  }\n while (root == i);\n  final NodeRef iP=tree.getParent(i);\n  final NodeRef CiP=getOtherChild(tree,iP,i);\n  final NodeRef PiP=tree.getParent(iP);\n  final double delta=getDelta();\n  final double oldHeight=tree.getNodeHeight(iP);\n  final double newHeight=oldHeight + delta;\n  if (delta > 0) {\n    if (PiP != null && tree.getNodeHeight(PiP) < newHeight) {\n      NodeRef newParent=PiP;\n      NodeRef newChild=iP;\n      while (tree.getNodeHeight(newParent) < newHeight) {\n        newChild=newParent;\n        newParent=tree.getParent(newParent);\n        if (newParent == null)         break;\n      }\n      tree.beginTreeEdit();\n      if (tree.isRoot(newChild)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.setRoot(iP);\n        if (tree.hasNodeTraits()) {\n          tree.swapAllTraits(newChild,iP);\n        }\n        if (tree.hasRates()) {\n          final double rootNodeRate=tree.getNodeRate(newChild);\n          tree.setNodeRate(newChild,tree.getNodeRate(iP));\n          tree.setNodeRate(iP,rootNodeRate);\n        }\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      final int possibleSources=intersectingEdges(tree,newChild,oldHeight,null);\n      logq=-Math.log(possibleSources);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logq=0.0;\n    }\n  }\n else {\n    if (tree.getNodeHeight(i) > newHeight) {\n      return Double.NEGATIVE_INFINITY;\n    }\n    if (tree.getNodeHeight(CiP) > newHeight) {\n      List<NodeRef> newChildren=new ArrayList<NodeRef>();\n      final int possibleDestinations=intersectingEdges(tree,CiP,newHeight,newChildren);\n      if (newChildren.size() == 0) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      final int childIndex=MathUtils.nextInt(newChildren.size());\n      NodeRef newChild=newChildren.get(childIndex);\n      NodeRef newParent=tree.getParent(newChild);\n      tree.beginTreeEdit();\n      if (tree.isRoot(iP)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(newParent,iP);\n        tree.setRoot(CiP);\n        if (tree.hasNodeTraits()) {\n          tree.swapAllTraits(iP,CiP);\n        }\n        if (tree.hasRates()) {\n          final double rootNodeRate=tree.getNodeRate(iP);\n          tree.setNodeRate(iP,tree.getNodeRate(CiP));\n          tree.setNodeRate(CiP,rootNodeRate);\n        }\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      logq=Math.log(possibleDestinations);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logq=0.0;\n    }\n  }\n  if (swapInRandomRate) {\n    final NodeRef j=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n    if (j != i) {\n      final double tmp=tree.getNodeRate(i);\n      tree.setNodeRate(i,tree.getNodeRate(j));\n      tree.setNodeRate(j,tmp);\n    }\n  }\n  if (swapInRandomTrait) {\n    final NodeRef j=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n    if (j != i) {\n      tree.swapAllTraits(i,j);\n    }\n  }\n  if (logq == Double.NEGATIVE_INFINITY)   throw new OperatorFailedException(\"invalid slide\");\n  if (scaledDirichletBranches) {\n    if (oldTreeHeight != tree.getNodeHeight(tree.getRoot()))     throw new OperatorFailedException(\"Temporarily disabled.\");\n  }\n  return logq;\n}\n", "docstring": "do a probablistic subtree slide move .", "partition": "test"}
{"idx": "572", "code": "public void addResponseCodeListener(ActionListener a){\n  responseCodeListeners.addElement(a);\n}\n", "docstring": "adds a response listener on the requests", "partition": "test"}
{"idx": "3662", "code": "public static ArrayList<Page> pageCreatorButtons(ArrayList<Page> pages,Item manualType){\n  ArrayList<Page> newPages=new ArrayList<>();\n  int pageAmount=pages.size();\n  int times=0;\n  while (pageAmount > 0) {\n    ArrayList<Page> pagesTemp=new ArrayList<>();\n    pagesTemp.addAll(pages.subList(7 * times,(pageAmount > 7 ? 7 + 7 * times : 7 * times + pageAmount)));\n    int height=0;\n    ArrayList<ManualWidgetBase> widgets=new ArrayList<>();\n    for (    Page page : pagesTemp) {\n      widgets.add(new ButtonWidget(15,10 + height,page));\n      height+=20;\n    }\n    newPages.add(new Page(\"index\" + times,(ArrayList<ManualWidgetBase>)widgets.clone(),false,manualType));\n    widgets.clear();\n    pagesTemp.clear();\n    pageAmount-=7;\n    times++;\n  }\n  return newPages;\n}\n", "docstring": "creates the button pages for a category", "partition": "test"}
{"idx": "3944", "code": "public static EnergyNetwork initNetwork(){\n  Random random=new Random(System.currentTimeMillis());\n  int id=random.nextInt();\n  while (usedIds.contains(id)) {\n    id=random.nextInt();\n  }\n  ;\n  EnergyNetwork net=new EnergyNetwork();\n  usedIds.add(id);\n  net.networkID=id;\n  return net;\n}\n", "docstring": "create a new network and get an id", "partition": "test"}
{"idx": "2399", "code": "public void addGeoKey(XTIFFField geoKey){\n  geoKeyIndex.put(new Integer(geoKey.getTag()),geoKey);\n  hasGeoKeys=true;\n}\n", "docstring": "add an existing geokey to the directory .", "partition": "test"}
{"idx": "1424", "code": "private void stop(HttpServletRequest request,HttpServletResponse response) throws IOException {\n  PrintWriter out=response.getWriter();\n  String label=request.getParameter(\"stop\");\n  Monitor mon=removeMon(label,null,DEFAULT_UNITS);\n  if (mon == null) {\n    out.println(ERROR + \": stop requires that an existing label is passed in.  For example: curl http://localhost:8080/jamon/Mon?stop=mylabel\");\n  }\n else {\n    mon.stop();\n    out.println(OK + \": stop successfully called on - \" + mon);\n  }\n}\n", "docstring": "stop a previously started monitor if it exists .", "partition": "test"}
{"idx": "71", "code": "@Pure public Atom annotationInterfaceToAnnotationClass(){\n  byte[] annotationClassName_tmp=new byte[val.length + 2];\n  System.arraycopy(val,0,annotationClassName_tmp,0,val.length - 1);\n  annotationClassName_tmp[val.length - 1]='$';\n  annotationClassName_tmp[val.length]='$';\n  annotationClassName_tmp[val.length + 1]=';';\n  return Atom.findOrCreateUtf8Atom(annotationClassName_tmp);\n}\n", "docstring": "creates an annotation name from a class name . for example lfoo . bar ; becomes lfoo . bar $ $ ; nb in sun vms the annotation name of the first annotation is $ proxy1 . classpath may later rely on this to implement serialization correctly .", "partition": "test"}
{"idx": "2398", "code": "public void presentLicenses(boolean preAccept){\n  LicenseSet licenses=licenseModule.getRequiredLicenses();\n  if (preAccept) {\n    licenses.acceptAll();\n  }\n else {\n    for (    License license : licenses) {\n      if (license.isAccepted()) {\n        continue;\n      }\n      user.show(\"\");\n      user.show(license.getLicenseText());\n      String input=user.ask(\"prompt\");\n      if (input != null && YES.startsWith(input.toLowerCase())) {\n        license.accept();\n      }\n else {\n        license.reject();\n      }\n    }\n  }\n}\n", "docstring": "present the licenses to the user - if the preaccept parameter is set , then simply display them through system . out . otherwise display each one and confirm that the user agrees before displaying the next . finally , check that all licenses have been agreed to before continuing .", "partition": "test"}
{"idx": "1686", "code": "protected AbstractCategoryItemLabelGenerator(String labelFormat,DateFormat formatter){\n  ParamChecks.nullNotPermitted(labelFormat,\"labelFormat\");\n  ParamChecks.nullNotPermitted(formatter,\"formatter\");\n  this.labelFormat=labelFormat;\n  this.numberFormat=null;\n  this.percentFormat=NumberFormat.getPercentInstance();\n  this.dateFormat=formatter;\n  this.nullValueString=\"-\";\n}\n", "docstring": "creates a label generator with the specified date formatter .", "partition": "test"}
{"idx": "947", "code": "private static void createCombinedTrace(final TraceList newTrace,final List<TraceList> traces,final Set<BreakpointAddress> addresses){\n  final Set<BreakpointAddress> visitedAddresses=new LinkedHashSet<BreakpointAddress>();\n  for (  final TraceList trace : traces) {\n    for (    final ITraceEvent event : trace) {\n      final BreakpointAddress address=event.getOffset();\n      if (!addresses.contains(address)) {\n        continue;\n      }\n      if (visitedAddresses.contains(address)) {\n        continue;\n      }\n      visitedAddresses.add(address);\n      newTrace.addEvent(event);\n    }\n  }\n}\n", "docstring": "fills a combined trace from the events of multiple input traces .", "partition": "test"}
{"idx": "2592", "code": "public void print(int inum){\n  print(String.valueOf(inum));\n}\n", "docstring": "prints the string representation of the specified integer to the target .", "partition": "test"}
{"idx": "2441", "code": "public boolean makeBackupFile(String directory,File file){\n  if (file == null) {\n    log.info(\"No file to backup\");\n  }\n else   if (file.canWrite()) {\n    String backupFullName=directory + File.separator + createFileNameWithDate(file.getName());\n    if (log.isDebugEnabled()) {\n      log.debug(\"new backup file: \" + backupFullName);\n    }\n    File backupFile=findFile(backupFullName);\n    if (backupFile != null) {\n      if (backupFile.delete()) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"deleted backup file \" + backupFullName);\n        }\n      }\n    }\n else {\n      backupFile=new File(backupFullName);\n    }\n    File parentDir=backupFile.getParentFile();\n    if (!parentDir.exists()) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"creating backup directory: \" + parentDir.getName());\n      }\n      if (!parentDir.mkdirs()) {\n        log.error(\"backup directory not created\");\n        return false;\n      }\n    }\n    if (file.renameTo(new File(backupFullName))) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"created new backup file \" + backupFullName);\n      }\n    }\n else {\n      if (log.isDebugEnabled()) {\n        log.debug(\"could not create backup file \" + backupFullName);\n      }\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "move original file to backup directory .", "partition": "test"}
{"idx": "1601", "code": "public void append(int key,E value){\n  if (mSize != 0 && key <= mKeys[mSize - 1]) {\n    put(key,value);\n    return;\n  }\n  if (mGarbage && mSize >= mKeys.length) {\n    gc();\n  }\n  int pos=mSize;\n  if (pos >= mKeys.length) {\n    int n=idealIntArraySize(pos + 1);\n    int[] nkeys=new int[n];\n    Object[] nvalues=new Object[n];\n    System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n    System.arraycopy(mValues,0,nvalues,0,mValues.length);\n    mKeys=nkeys;\n    mValues=nvalues;\n  }\n  mKeys[pos]=key;\n  mValues[pos]=value;\n  mSize=pos + 1;\n}\n", "docstring": "puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .", "partition": "test"}
{"idx": "3675", "code": "protected void sendLogEvent(String component,String message,Callback<Object> callback){\n  String syslogMessage=String.format(Locale.US,\"<22>%s %s %s:%s\",getSysLogFormattedDate(),utils.getApplicationName(context),component,message);\n  sendDataOverUDP(syslogMessage,callback);\n}\n", "docstring": "create properly formatted message to send over udp that acts like a syslog message syslog format : \" & lt ; priority & gt ; timestamp orange_link blue_link : message \" details : http : / / en . wikipedia . org / wiki / syslog # priority", "partition": "test"}
{"idx": "3813", "code": "public void addLifecycleListener(LifecycleListener lifecycleListener){\n  if (!lifecycleListeners.contains(lifecycleListener)) {\n    lifecycleListeners.add(lifecycleListener);\n  }\n}\n", "docstring": "adds a listener for all of this controller \"'\" s lifecycle events", "partition": "test"}
{"idx": "2806", "code": "@Override public boolean release(int decrement){\n  if (isEmpty) {\n    return false;\n  }\n  if (decrement < 1) {\n    throw new IllegalStateException(String.format(\"release(%d) argument is not positive. Buffer Info: %s\",decrement,toVerboseString()));\n  }\n  final int refCnt=ledger.decrement(decrement);\n  if (BaseAllocator.DEBUG) {\n    historicalLog.recordEvent(\"release(%d). original value: %d\",decrement,refCnt + decrement);\n  }\n  if (refCnt < 0) {\n    throw new IllegalStateException(String.format(\"ArrowBuf[%d] refCnt has gone negative. Buffer Info: %s\",id,toVerboseString()));\n  }\n  return refCnt == 0;\n}\n", "docstring": "release the provided number of reference counts .", "partition": "test"}
{"idx": "1930", "code": "public void update(long dt,float ratioY){\n  double step=2 * Math.PI / POINTS_PER_CIRCLE;\n  angle+=dt * BUBBLE_D_ANGLE;\n  float fromX=startX + (float)(0.05f * Math.sin(angle));\n  float toX=fromX + size;\n  float fromY=this.fromY + dt * speed;\n  float toY=fromY + size;\n  centerY+=dt * virtualSpeed;\n  getColor()[3]=(TOP_Y - centerY / TOP_Y);\n  vertexBuffer.put(0,Utils.normalizeGl(0,fromX,toX));\n  vertexBuffer.put(1,Utils.normalizeGl(centerY * ratioY,fromY,toY));\n  for (int i=1; i <= POINTS_PER_CIRCLE; i++) {\n    vertexBuffer.put(COORDS_PER_VERTEX * i,Utils.normalizeGl((float)Math.sin(-Math.PI + step * i),fromX,toX));\n    vertexBuffer.put(COORDS_PER_VERTEX * i + 1,Utils.normalizeGl((float)Math.cos(-Math.PI + step * i) * ratioY,fromY,toY));\n  }\n  this.fromY=fromY;\n}\n", "docstring": "update position of bubble .", "partition": "test"}
{"idx": "4155", "code": "public static int findNext(String str,char separator,char escapeChar,int start,StringBuilder split){\n  int numPreEscapes=0;\n  for (int i=start; i < str.length(); i++) {\n    char curChar=str.charAt(i);\n    if (numPreEscapes == 0 && curChar == separator) {\n      return i;\n    }\n else {\n      split.append(curChar);\n      numPreEscapes=(curChar == escapeChar) ? (++numPreEscapes) % 2 : 0;\n    }\n  }\n  return -1;\n}\n", "docstring": "finds the first occurrence of the separator character ignoring the escaped separators starting from the index . note the substring between the index and the position of the separator is passed .", "partition": "test"}
{"idx": "2301", "code": "protected int read(InputStream inputStream,byte[] buffer,char divider) throws IOException {\n  int index=0;\n  do {\n    byte readByte=(byte)(0x000000FF & inputStream.read());\n    if (readByte == -1 || readByte == (byte)divider) {\n      return index;\n    }\n    buffer[index]=readByte;\n    index++;\n  }\n while (index < buffer.length);\n  return index;\n}\n", "docstring": "reads bytes from a given file reader until either a certain character is read , the buffer is completely filled or the end of file is reached .", "partition": "test"}
{"idx": "4039", "code": "public static void i(String msg,Object... args){\n  if (!allowI)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "docstring": "send an info log message", "partition": "test"}
{"idx": "2096", "code": "public void initGL(){\n  mEglCore=new EglCore(null,EglCore.FLAG_RECORDABLE | EglCore.FLAG_TRY_GLES3);\n  mWindowSurface=new WindowSurface(mEglCore,mSurfaceTexture);\n  mWindowSurface.makeCurrent();\n  mRecordSurface=new WindowSurface(mEglCore,mMediaRecorder.getSurface(),false);\n  initGLComponents();\n}\n", "docstring": "initialize all necessary components for gles rendering , creating window surfaces for drawing the preview as well as the surface that will be used by mediarecorder for recording", "partition": "test"}
{"idx": "2875", "code": "private boolean isFileValid(File file,String methodName){\n  if (file == null) {\n    Log.printConcatLine(name,\".\",methodName,\": Warning - the given file is null.\");\n    return false;\n  }\n  String fileName=file.getName();\n  if (fileName == null || fileName.length() == 0) {\n    Log.printConcatLine(name,\".\" + methodName,\": Warning - invalid file name.\");\n    return false;\n  }\n  return true;\n}\n", "docstring": "check if the file is valid or not . this method checks whether the given file or the file name of the file is valid . the method name parameter is used for debugging purposes , to output in which method an error has occurred .", "partition": "test"}
{"idx": "3196", "code": "public void initializeActiveSlotsList(String slots){\n  if (activeSlotsList == null) {\n    activeSlotsList=new ArrayList<String>();\n  }\n  for (  String s : slots.split(\";\")) {\n    activeSlotsList.add(s);\n  }\n}\n", "docstring": "add slots to list where slotactivateditem can be activated when equipped .", "partition": "test"}
{"idx": "154", "code": "private static String[] scanForSources(final File sourceDir,final Set<String> sourceIncludes,final Set<String> sourceExcludes){\n  final DirectoryScanner ds=new DirectoryScanner();\n  ds.setFollowSymlinks(true);\n  ds.setBasedir(sourceDir);\n  ds.setIncludes(sourceIncludes.toArray(new String[sourceIncludes.size()]));\n  ds.setExcludes(sourceExcludes.toArray(new String[sourceExcludes.size()]));\n  ds.addDefaultExcludes();\n  try {\n    ds.scan();\n  }\n catch (  IllegalStateException e) {\n    return new String[0];\n  }\n  return ds.getIncludedFiles();\n}\n", "docstring": "scans a single source dir for sources and includes only the files whose name match the patterns in sourceincludes and excludes all files whose names match the patterns in sourceexcludes", "partition": "test"}
{"idx": "1701", "code": "private synchronized void loadHexImage(IHex hex){\n  hexTileset.assignMatch(hex,boardview);\n  hexTileset.trackHexImages(hex,tracker);\n}\n", "docstring": "loads the image ( s ) for this hex into the tracker .", "partition": "test"}
{"idx": "3475", "code": "private void parse(String path) throws Exception {\n  if (path != null) {\n    count=path.length();\n    data=new char[count];\n    path.getChars(0,count,data,0);\n  }\n  path();\n}\n", "docstring": "this method is used to parse the provided xpath expression . when parsing the expression this will trim any references to the root context , also any trailing slashes are removed . an exception is thrown if the path is invalid .", "partition": "test"}
{"idx": "4025", "code": "public final int hashCode(){\n  return System.identityHashCode(this);\n}\n", "docstring": "the hash code for all sunhints . value objects will be the same as the system identity code of the object as defined by the system . identityhashcode ( ) method .", "partition": "test"}
{"idx": "4099", "code": "@Override public void write(String str){\n  int start=0;\n  while (start < str.length()) {\n    int end=Math.min(start + MAX_MESSAGE_LENGTH,str.length());\n    Log.i(TAG,str.substring(start,end));\n    start=end;\n  }\n}\n", "docstring": "writes the given string to android logcat .", "partition": "test"}
{"idx": "1225", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return NOTE_ID;\ncase 2:\n  return CLASS_NAME;\ncase 3:\nreturn INTERPRETER_CONTEXT;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "3355", "code": "public static void writeBcdNumber(OutputStream os,String number) throws IOException {\n  int bcd=0x00;\n  int n=0;\n  for (int i=0; i < number.length(); i++) {\nswitch (number.charAt(i)) {\ncase '0':\n      bcd|=0x00;\n    break;\ncase '1':\n  bcd|=0x10;\nbreak;\ncase '2':\nbcd|=0x20;\nbreak;\ncase '3':\nbcd|=0x30;\nbreak;\ncase '4':\nbcd|=0x40;\nbreak;\ncase '5':\nbcd|=0x50;\nbreak;\ncase '6':\nbcd|=0x60;\nbreak;\ncase '7':\nbcd|=0x70;\nbreak;\ncase '8':\nbcd|=0x80;\nbreak;\ncase '9':\nbcd|=0x90;\nbreak;\ncase '*':\nbcd|=0xA0;\nbreak;\ncase '#':\nbcd|=0xB0;\nbreak;\ncase 'a':\nbcd|=0xC0;\nbreak;\ncase 'b':\nbcd|=0xE0;\nbreak;\n}\nn++;\nif (n == 2) {\nos.write(bcd);\nn=0;\nbcd=0x00;\n}\n else {\nbcd>>=4;\n}\n}\nif (n == 1) {\nbcd|=0xF0;\nos.write(bcd);\n}\n}\n", "docstring": "writes the given phonenumber to the stream ( bcd coded )", "partition": "test"}
{"idx": "1733", "code": "EgDemandDetails insertPenalty(final BigDecimal chqBouncePenalty,final Module module){\n  EgDemandDetails demandDetail=null;\n  if (chqBouncePenalty != null && chqBouncePenalty.compareTo(BigDecimal.ZERO) > 0) {\n    final Installment currInstallment=getCurrentInstallment(module);\n    final EgDemandReasonMaster egDemandReasonMaster=demandGenericDao.getDemandReasonMasterByCode(DEMANDRSN_CODE_CHQ_BOUNCE_PENALTY,module);\n    if (egDemandReasonMaster == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason Master is null in method  insertPenalty\");\n    final EgDemandReason egDemandReason=demandGenericDao.getDmdReasonByDmdReasonMsterInstallAndMod(egDemandReasonMaster,currInstallment,module);\n    if (egDemandReason == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason is null in method  insertPenalty \");\n    demandDetail=EgDemandDetails.fromReasonAndAmounts(chqBouncePenalty,egDemandReason,BigDecimal.ZERO);\n  }\n  return demandDetail;\n}\n", "docstring": "method used to insert penalty in egdemanddetail table . penalty amount will be calculated depending upon the cheque amount .", "partition": "test"}
{"idx": "4149", "code": "public void rederiveColor(){\n  Color src=UIManager.getColor(uiDefaultParentName);\n  if (src != null) {\n    float[] tmp=Color.RGBtoHSB(src.getRed(),src.getGreen(),src.getBlue(),null);\n    tmp[0]=clamp(tmp[0] + hOffset);\n    tmp[1]=clamp(tmp[1] + sOffset);\n    tmp[2]=clamp(tmp[2] + bOffset);\n    int alpha=clamp(src.getAlpha() + aOffset);\n    argbValue=(Color.HSBtoRGB(tmp[0],tmp[1],tmp[2]) & 0xFFFFFF) | (alpha << 24);\n  }\n else {\n    float[] tmp=new float[3];\n    tmp[0]=clamp(hOffset);\n    tmp[1]=clamp(sOffset);\n    tmp[2]=clamp(bOffset);\n    int alpha=clamp(aOffset);\n    argbValue=(Color.HSBtoRGB(tmp[0],tmp[1],tmp[2]) & 0xFFFFFF) | (alpha << 24);\n  }\n}\n", "docstring": "recalculate the derived color from the uimanager parent color and offsets", "partition": "test"}
{"idx": "1566", "code": "public static int calculateRMSLevel(short[] audioData,int numframes){\n  long lSum=0;\n  int numread=0;\n  for (  short s : audioData) {\n    lSum=lSum + s;\n    numread++;\n    if (numread == numframes)     break;\n  }\n  double dAvg=lSum / numframes;\n  double sumMeanSquare=0d;\n  numread=0;\n  for (  short anAudioData : audioData) {\n    sumMeanSquare=sumMeanSquare + Math.pow(anAudioData - dAvg,2d);\n    numread++;\n    if (numread == numframes)     break;\n  }\n  double averageMeanSquare=sumMeanSquare / numframes;\n  return (int)(Math.pow(averageMeanSquare,0.5d) + 0.5);\n}\n", "docstring": "calculates the rms audio level from the provided short sample extract", "partition": "test"}
{"idx": "785", "code": "protected void generateFields(){\n  for (Iterator<Element> iterator=mElements.iterator(); iterator.hasNext(); ) {\n    Element element=iterator.next();\n    if (!element.used) {\n      iterator.remove();\n      continue;\n    }\n    PsiField[] fields=mClass.getFields();\n    boolean duplicateField=false;\n    for (    PsiField field : fields) {\n      String name=field.getName();\n      if (name != null && name.equals(element.getFieldName())) {\n        duplicateField=true;\n        break;\n      }\n    }\n    if (duplicateField) {\n      iterator.remove();\n      continue;\n    }\n    mClass.add(mFactory.createFieldFromText(\"private \" + element.name + \" \"+ element.getFieldName()+ \";\",mClass));\n  }\n}\n", "docstring": "create fields for injections inside main class", "partition": "test"}
{"idx": "211", "code": "public void initializeOwnerReferencesForField(StateManager sm,FieldMetaData fmd){\n  if (fmd.getAssociationType() == FieldMetaData.ONE_TO_MANY) {\n    Collection<?> collection=(Collection<?>)sm.fetch(fmd.getIndex());\n    if (collection != null) {\n      for (      Object item : collection) {\n        if (item != null) {\n          _relationsManager.setOwnerStateManagerForPersistentInstance(item,sm,fmd);\n        }\n      }\n    }\n  }\n else   if (fmd.getAssociationType() == FieldMetaData.ONE_TO_ONE || fmd.isEmbeddedPC()) {\n    Object value=sm.fetch(fmd.getIndex());\n    if (value != null) {\n      _relationsManager.setOwnerStateManagerForPersistentInstance(value,sm,fmd);\n    }\n  }\n}\n", "docstring": "sets the provided state manager as the owner for the provided field value .", "partition": "test"}
{"idx": "3561", "code": "public Debug(String clientID,ClientComms comms){\n  this.clientID=clientID;\n  this.comms=comms;\n  log.setResourceName(clientID);\n}\n", "docstring": "set the debug facility up for a specific client", "partition": "test"}
{"idx": "3815", "code": "private boolean validateCooldownSetting(String appId,AutoScalerPolicyTrigger policyTrigger,String triggerId){\n  AutoScalingDataStore stateStore=AutoScalingDataStoreFactory.getAutoScalingDataStore();\n  AppAutoScaleState appState=null;\n  appState=stateStore.getScalingState(appId);\n  if (appState == null) {\n    return true;\n  }\n else   if ((appState.getInstanceCountState() != ScalingStateManager.SCALING_STATE_COMPLETED) && (appState.getInstanceCountState() != ScalingStateManager.SCALING_STATE_FAILED)) {\n    long lastStartTime=appState.getLastActionStartTime();\n    long currentTime=System.currentTimeMillis();\n    boolean timeExpired=(currentTime - lastStartTime) > this.eventTimeout;\n    if (timeExpired) {\n      logger.debug(\"True: Last scaling action is not completed but it\\'s time expired for application \" + appId + \".\");\n      return true;\n    }\n    logger.debug(\"False: Last scaling action is not completed for application \" + appId + \".\");\n    return false;\n  }\n else {\n    long cooldownEndtime=appState.getLastActionEndTime() + 1000L * getCooldownSecs(policyTrigger,triggerId);\n    if (System.currentTimeMillis() < cooldownEndtime) {\n      logger.debug(\"False: It\\'s cooldown time for application \" + appId + \". No scaling in action.\");\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "checks if the app should be scaled in / out according to cooldown settings", "partition": "test"}
{"idx": "4090", "code": "public ServiceID(DataInput in) throws IOException {\n  this.mostSig=in.readLong();\n  this.leastSig=in.readLong();\n}\n", "docstring": "reads in 16 bytes in standard network byte order .", "partition": "test"}
{"idx": "2948", "code": "private Environment(){\n  throw ContractUtils.unreachable();\n}\n", "docstring": "make sure nobody can instantiate the class", "partition": "test"}
{"idx": "3957", "code": "public double[] arrayCopy(){\n  double[] array=new double[length()];\n  for (  IndexValue iv : this)   array[iv.getIndex()]=iv.getValue();\n  return array;\n}\n", "docstring": "creates a new array that contains all the values of this vector in the appropriate indices", "partition": "test"}
{"idx": "3198", "code": "public static String hide(final String key){\n  return isHidden(key) ? key : HIDDEN_PREFIX.concat(key);\n}\n", "docstring": "turn the provided key into a hidden key . if the key is already a hidden key , return key .", "partition": "test"}
{"idx": "2079", "code": "public boolean isNetworkConnected(){\n  ConnectivityManager connectivityManager=(ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE);\n  NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo();\n  return networkInfo != null && networkInfo.isConnectedOrConnecting();\n}\n", "docstring": "check the current active network is available .", "partition": "test"}
{"idx": "51", "code": "public byte[] toBytes(){\n  try {\n    ByteArrayOutputStream out=new ByteArrayOutputStream();\n    _field.store(out,null);\n    return out.toByteArray();\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "docstring": "serializes this nested object into byte [ ", "partition": "test"}
{"idx": "1970", "code": "public void next(){\n  if (iterator.hasNext()) {\n    View currentView=iterator.next();\n    if (isUsingDefaultListener())     currentView.setOnClickListener(null);\n    if (iterator.nextIndex() < mViews.size()) {\n      View nextView=mViews.get(iterator.nextIndex());\n      if (isUsingDefaultListener())       nextView.setOnClickListener(listener);\n      ControllerAnimator animator=getDefaultForwardAnimation();\n      animator.setOldView(currentView);\n      animator.setNewView(nextView);\n      currentView.startAnimation(animator);\n      if (iterator.nextIndex() == mViews.size() - 1)       if (hasControllerListener())       mListener.onEndReached();\n    }\n else {\n      if (mLoop) {\n        iterator=mViews.listIterator();\n        View nextView=mViews.get(0);\n        if (mUseDefaultListener)         nextView.setOnClickListener(listener);\n        ControllerAnimator animator=getDefaultForwardAnimation();\n        animator.setOldView(currentView);\n        animator.setNewView(nextView);\n        currentView.startAnimation(animator);\n      }\n    }\n  }\n}\n", "docstring": "go to the next view", "partition": "test"}
{"idx": "1624", "code": "public int compare(Object o1,Object o2){\n  return comparator.compare(o1,o2);\n}\n", "docstring": "call the comparator on the column", "partition": "test"}
{"idx": "3453", "code": "public void testCompareNegNeg2(){\n  byte aBytes[]={10,20,30,40,50,60,70,10,20,30};\n  byte bBytes[]={12,56,100,-2,-76,89,45,91,3,-15,35,26,3,91};\n  int aSign=-1;\n  int bSign=-1;\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  assertEquals(1,aNumber.compareTo(bNumber));\n}\n", "docstring": "compareto ( biginteger a ) . compare two negative numbers . the first is less in absolute value .", "partition": "test"}
{"idx": "1974", "code": "@Override public Node item(int index){\n  return (nodes != null && index < nodes.size()) ? (Node)(nodes.get(index)) : null;\n}\n", "docstring": "retrieve an item from the map by 0 - based index .", "partition": "test"}
{"idx": "1316", "code": "public void test_simplePrematureClose(){\n  Striterator iter=new Striterator(m_data.iterator());\n  int i=0;\n  while (iter.hasNext()) {\n    iter.next();\n    if (++i == 10) {\n      iter.close();\n      assertTrue(!iter.hasNext());\n    }\n  }\n  assertTrue(!iter.isOpen());\n  assertTrue(i == 10);\n}\n", "docstring": "test that striterator returns false for hasnext ( ) after close ( )", "partition": "test"}
{"idx": "2952", "code": "synchronized public void failOn(Failure fail){\n  if (failures == null) {\n    failures=new ArrayList<>();\n  }\n  failures.add(fail);\n}\n", "docstring": "add a failure object to the list of objects to be evaluated at every potential failure point", "partition": "test"}
{"idx": "3427", "code": "public static <T>ArrayList<T> read(InputStream fileStream,String charsetName,ITransformer<String,T> transformer) throws FileNotFoundException {\n  Scanner scanner=new Scanner(fileStream,charsetName);\n  ArrayList<T> list=new ArrayList<>();\n  while (scanner.hasNextLine()) {\n    String line=scanner.nextLine();\n    list.add(transformer.transform(line));\n  }\n  scanner.close();\n  return list;\n}\n", "docstring": "this function reads an inputstream line - by - line and converts each line into an object using a transformer that is passed as a parameter .", "partition": "test"}
{"idx": "4187", "code": "public static float between(float val,float min,float max){\n  return Math.max(Math.min(val,max),min);\n}\n", "docstring": "check if value within allowed range .", "partition": "test"}
{"idx": "4218", "code": "private String pickCharset(){\n  if (charset != null) {\n    return charset;\n  }\n else   if (utf8Supported) {\n    return \"UTF-8\";\n  }\n else {\n    return System.getProperty(\"file.encoding\");\n  }\n}\n", "docstring": "returns the name of the charset that should be used in textual transmissions .", "partition": "test"}
{"idx": "1078", "code": "private static double pythonTime(){\n  return System.currentTimeMillis() / 1000;\n}\n", "docstring": "returns the current millis the same way as python does since this is what \"'\" s stored in the replay files * yay * .", "partition": "test"}
{"idx": "348", "code": "protected int checkKnownCookie(){\n  int retVal=0;\n  debug.message(\"{}.checkKnownCookie:\",ADAPTIVE);\n  HttpServletRequest req=getHttpServletRequest();\n  if (req != null) {\n    Cookie cookie=CookieUtils.getCookieFromReq(req,knownCookieName);\n    if (cookie != null) {\n      if (knownCookieValue.equalsIgnoreCase(CookieUtils.getCookieValue(cookie))) {\n        retVal=knownCookieScore;\n      }\n    }\n  }\n  if (knownCookieValue == null) {\n    knownCookieValue=\"1\";\n  }\n  if (knownCookieSave) {\n    postAuthNMap.put(\"COOKIENAME\",knownCookieName);\n    postAuthNMap.put(\"COOKIEVALUE\",knownCookieValue);\n  }\n  if (!knownCookieInvert) {\n    retVal=knownCookieScore - retVal;\n  }\n  return retVal;\n}\n", "docstring": "check to see if the client has a cookie with optional value", "partition": "test"}
{"idx": "1944", "code": "public List<CountryRO> viewAddressCountryOptions(final ShoppingCart cart,final Shop shop,final String addressType){\n  final List<Country> countries=addressBookFacade.getAllCountries(shop.getCode(),addressType);\n  return map(countries,CountryRO.class,Country.class);\n}\n", "docstring": "common address book function .", "partition": "test"}
{"idx": "2569", "code": "protected void writeExternalForeignKeyDropStmt(Table table,ForeignKey foreignKey,StringBuilder ddl){\n  writeTableAlterStmt(table,ddl);\n  ddl.append(\"DROP CONSTRAINT \");\n  printIdentifier(getForeignKeyName(table,foreignKey),ddl);\n  printEndOfStatement(ddl);\n}\n", "docstring": "generates the statement to drop a foreignkey constraint from the database using an alter table statement .", "partition": "test"}
{"idx": "3915", "code": "public static boolean isFileTypeSupported(int fileType){\n  List providers=getMidiFileWriters();\n  for (int i=0; i < providers.size(); i++) {\n    MidiFileWriter writer=(MidiFileWriter)providers.get(i);\n    if (writer.isFileTypeSupported(fileType)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "indicates whether file writing support for the specified midi file type is provided by the system .", "partition": "test"}
{"idx": "794", "code": "DeleteEvent(@NonNull JSONObject json) throws JSONException {\n  super(TYPE_DELETE,json);\n  if (TextUtils.isEmpty(mBlockId)) {\n    throw new JSONException(TYPENAME_DELETE + \" requires \" + JSON_BLOCK_ID);\n  }\n  mOldXml=json.optString(JSON_OLD_VALUE);\n  JSONArray ids=json.getJSONArray(JSON_IDS);\n  int count=ids.length();\n  List<String> temp=new ArrayList<>(count);\n  for (int i=0; i < count; ++i) {\n    temp.add(ids.getString(i));\n  }\n  mIds=Collections.unmodifiableList(temp);\n}\n", "docstring": "constructs a deleteevent from the json serialized representation .", "partition": "test"}
{"idx": "3501", "code": "public static String escapeRegex(final String regex){\n  Matcher match=REGEX_CHARS.matcher(regex);\n  return match.replaceAll(\"\\\\\\\\\\\\\\\\$1\");\n}\n", "docstring": "this function will escape special characters within a string to ensure that the string will not be parsed as a regular expression . this is helpful with accepting using input that needs to be used in functions that take a regular expression as an argument ( such as string . replaceall ( ) , or string . split ( ) ) .", "partition": "test"}
{"idx": "5", "code": "private static boolean isDoubleEqual(double value,double valueToCompare){\n  return (Math.abs(value - valueToCompare) < 0.001);\n}\n", "docstring": "checks if is double values are equal .", "partition": "test"}
{"idx": "3181", "code": "static MethodHandle makeCollectArguments(MethodHandle target,MethodHandle collector,int collectArgPos,boolean retainOriginalArgs){\n  MethodType targetType=target.type();\n  MethodType collectorType=collector.type();\n  int collectArgCount=collectorType.parameterCount();\n  Class<?> collectValType=collectorType.returnType();\n  int collectValCount=(collectValType == void.class ? 0 : 1);\n  MethodType srcType=targetType.dropParameterTypes(collectArgPos,collectArgPos + collectValCount);\n  if (!retainOriginalArgs) {\n    srcType=srcType.insertParameterTypes(collectArgPos,collectorType.parameterList());\n  }\n  MethodType lambdaType=srcType.invokerType();\n  Name[] names=arguments(2,lambdaType);\n  final int collectNamePos=names.length - 2;\n  final int targetNamePos=names.length - 1;\n  Name[] collectorArgs=Arrays.copyOfRange(names,1 + collectArgPos,1 + collectArgPos + collectArgCount);\n  names[collectNamePos]=new Name(collector,(Object[])collectorArgs);\n  Name[] targetArgs=new Name[targetType.parameterCount()];\n  int inputArgPos=1;\n  int targetArgPos=0;\n  int chunk=collectArgPos;\n  System.arraycopy(names,inputArgPos,targetArgs,targetArgPos,chunk);\n  inputArgPos+=chunk;\n  targetArgPos+=chunk;\n  if (collectValType != void.class) {\n    targetArgs[targetArgPos++]=names[collectNamePos];\n  }\n  chunk=collectArgCount;\n  if (retainOriginalArgs) {\n    System.arraycopy(names,inputArgPos,targetArgs,targetArgPos,chunk);\n    targetArgPos+=chunk;\n  }\n  inputArgPos+=chunk;\n  chunk=targetArgs.length - targetArgPos;\n  System.arraycopy(names,inputArgPos,targetArgs,targetArgPos,chunk);\n  assert (inputArgPos + chunk == collectNamePos);\n  names[targetNamePos]=new Name(target,(Object[])targetArgs);\n  LambdaForm form=new LambdaForm(\"collect\",lambdaType.parameterCount(),names);\n  return SimpleMethodHandle.make(srcType,form);\n}\n", "docstring": "factory method : collect or filter selected argument ( s ) .", "partition": "test"}
{"idx": "406", "code": "private void deselect(final int index,final boolean shouldFireEvents){\n  checkWidget();\n  if (index < 0 || index >= items.size()) {\n    return;\n  }\n  final DLItem item=selection.remove(index);\n  if (shouldFireEvents) {\n    fireSelectionEvent(item);\n  }\n  final List<DLItem> deselectedItems=new ArrayList<DLItem>();\n  item.setLastAction(LAST_ACTION.DESELECTION);\n  deselectedItems.add(item);\n  if (shouldFireEvents) {\n    fireSelectionChangeEvent(deselectedItems);\n  }\n  redrawTables();\n}\n", "docstring": "deselects the item at the given zero - relative index in the receiver . if the item at the index was already deselected , it remains deselected . indices that are out of range are ignored .", "partition": "test"}
{"idx": "3692", "code": "public String toChars(int[] indices){\n  StringBuilder s=new StringBuilder(indices.length);\n  for (int i=0; i < indices.length; i++)   s.append(toChar(indices[i]));\n  return s.toString();\n}\n", "docstring": "returns the characters corresponding to the argument indices .", "partition": "test"}
{"idx": "1417", "code": "public void addSplitEdges(List edgeList){\n  addEndpoints();\n  Iterator it=iterator();\n  EdgeIntersection eiPrev=(EdgeIntersection)it.next();\n  while (it.hasNext()) {\n    EdgeIntersection ei=(EdgeIntersection)it.next();\n    Edge newEdge=createSplitEdge(eiPrev,ei);\n    edgeList.add(newEdge);\n    eiPrev=ei;\n  }\n}\n", "docstring": "creates new edges for all the edges that the intersections in this list split the parent edge into . adds the edges to the input list ( this is so a single list can be used to accumulate all split edges for a geometry ) .", "partition": "test"}
{"idx": "2330", "code": "public void reconnect(){\n  if (opened && !allowConnectionRecovery) {\n    return;\n  }\n  reconnectwait thread=new reconnectwait();\n  thread.start();\n  try {\n    thread.join();\n  }\n catch (  InterruptedException e) {\n    log.error(\"Unable to join to the reconnection thread \" + e.getMessage());\n  }\n  if (!opened) {\n    log.error(\"Failed to re-establish connectivity\");\n  }\n else {\n    log.info(\"Reconnected to \" + getCurrentPortName());\n    resetupConnection();\n  }\n}\n", "docstring": "attempts to reconnect to a failed server", "partition": "test"}
{"idx": "3070", "code": "public TvShowUpdateDatasourceTask(String datasource){\n  super(BUNDLE.getString(\"update.datasource\") + \" (\" + datasource+ \")\");\n  tvShowList=TvShowList.getInstance();\n  dataSources=new ArrayList<>(1);\n  dataSources.add(datasource);\n}\n", "docstring": "instantiates a new scrape task - to update a single datasource", "partition": "test"}
{"idx": "3157", "code": "@Override public boolean isEnabled(){\n  if ((attributeSelectionPanel != null) && !isValueOnly()) {\n    return attributeSelectionPanel.isEnabled();\n  }\n else {\n    if (this.crsComboBox != null) {\n      return crsComboBox.isEnabled();\n    }\n  }\n  return false;\n}\n", "docstring": "checks if is enabled .", "partition": "test"}
{"idx": "3758", "code": "public static @CheckForNull ClassDescriptor createClassDescriptorFromFieldSignature(String signature){\n  int start=signature.indexOf('L');\n  if (start < 0) {\n    return null;\n  }\n  int end=signature.indexOf(';',start);\n  if (end < 0) {\n    return null;\n  }\n  return createClassDescriptor(signature.substring(start + 1,end));\n}\n", "docstring": "create a class descriptor from a field signature", "partition": "test"}
{"idx": "643", "code": "public Point2D inverseTransform(Point2D src,Point2D dst){\n  try {\n    src.setLocation(src.getX() + rotXOffset,src.getY() + rotYOffset);\n    dst=rotTransform.inverseTransform(src,dst);\n  }\n catch (  NoninvertibleTransformException e) {\n    logger.log(Level.FINE,e.getMessage(),e);\n  }\n  return dst;\n}\n", "docstring": "returns dst , the unrotated pixel location of the map .", "partition": "test"}
{"idx": "2696", "code": "public void addToQueue(Var var){\n  addToQueue(Collections.singleton(var));\n}\n", "docstring": "add a single var to the queue", "partition": "test"}
{"idx": "927", "code": "private static String extractClientName(String clientId,String host){\n  String hostExcludedId=\"\";\n  if ((isIPv6(host) || isIPv4(host)) && clientId.startsWith(host)) {\n    hostExcludedId=clientId.substring(host.length());\n  }\n else {\n    int firstDotIndex=host.indexOf(\".\");\n    if (firstDotIndex != -1) {\n      String hostShortName=host.substring(0,firstDotIndex);\n      hostExcludedId=clientId.substring(hostShortName.length());\n    }\n  }\n  String vmPIDAndKindRegex=\"\\\\\\\\(\\\\\\\\w+:\\\\\\\\w+\\\\\\\\)\";\n  String regex=\"(\\\\\\\\<ec\\\\\\\\>)?:[0-9]+(:\\\\\\\\w+){2}+\";\n  String name=NOT_AVAILABLE;\n  String temp=hostExcludedId;\n  int openIndex=temp.indexOf(\"(\");\n  if (openIndex != -1) {\n    regex=vmPIDAndKindRegex + regex;\n  }\n  if (temp.matches(regex)) {\n    String[] splitted=temp.split(\":\");\n    name=splitted[splitted.length - 1];\n  }\n  return name;\n}\n", "docstring": "excludes the host name from the client id and returns the string . if the host name can not be detected , returns an empty string . typically , the client id looks like : host ( vm_pid : vm_kind ) : port : random_string : client_name extracts the client name from the client id . if the client id is not in the expected format , returns \"'\" n / a \"'\"", "partition": "test"}
{"idx": "4057", "code": "private void emitUntil(@Nonnegative int taskCountAllowed) throws IOException {\n  try {\n    while (emitQueue.size() > taskCountAllowed) {\n      Future<byte[]> future=emitQueue.remove();\n      byte[] toWrite=future.get();\n      blockSizes.add(toWrite.length);\n      out.write(toWrite);\n    }\n    tryEmit();\n  }\n catch (  ExecutionException e) {\n    throw new IOException(e);\n  }\ncatch (  InterruptedException e) {\n    throw new InterruptedIOException();\n  }\n}\n", "docstring": "emits any opportunistically available blocks . furthermore , emits blocks until the number of executing tasks is less than taskcountallowed .", "partition": "test"}
{"idx": "778", "code": "public boolean isLoginSet(){\n  return (username != null && (password != null && !username.equals(\"\") && !password.equals(\"\"))) || oauth;\n}\n", "docstring": "return true if either login / pass is set or if oauth is enabled", "partition": "test"}
{"idx": "2578", "code": "private int determineTargetPage(int currentPage,float pageOffset,int velocity,int deltaX){\n  int targetPage;\n  if (Math.abs(deltaX) > flingDistance && Math.abs(velocity) > minimumVelocity) {\n    if (virtualPos < 0) {\n      targetPage=velocity > 0 ? currentPage : currentPage + 1;\n    }\n else {\n      targetPage=velocity > 0 ? currentPage + 1 : currentPage;\n    }\n  }\n else {\n    final float truncator=currentPage >= currentItem ? 0.4f : 0.6f;\n    targetPage=(int)(currentPage + pageOffset + truncator);\n  }\n  if (items.size() > 0) {\n    final ItemInfo firstItem=items.get(0);\n    final ItemInfo lastItem=items.get(items.size() - 1);\n    targetPage=Math.max(firstItem.position,Math.min(targetPage,lastItem.position));\n  }\n  if (targetPage > currentPage && onCardChangeListener != null) {\n    onCardChangeListener.onCardDismissed(currentPage,virtualPos > 0);\n  }\n  return targetPage;\n}\n", "docstring": "figure out what the target page would be given current scroll and velocity .", "partition": "test"}
{"idx": "3405", "code": "protected void createFile(ZipEntry entry){\n  IPath pathname=new Path(entry.getName());\n  ZipEntry parent;\n  if (pathname.segmentCount() == 1) {\n    parent=root;\n  }\n else {\n    parent=(ZipEntry)directoryEntryCache.get(pathname.removeLastSegments(1));\n  }\n  addToChildren(parent,entry);\n}\n", "docstring": "creates a new file zip entry with the specified name .", "partition": "test"}
{"idx": "1418", "code": "public MemBasedCache(int maxCacheSizeInBytes){\n  mMaxCacheSizeInBytes=maxCacheSizeInBytes;\n  mDataEntries=new LinkedHashMap<String,CacheHeader>(16,.75f,true);\n}\n", "docstring": "constructs an instance of the membasedcache .", "partition": "test"}
{"idx": "2495", "code": "public void testEmptyIndex() throws Exception {\n  IndexSearcher empty=newSearcher(new MultiReader());\n  Query query=new TermQuery(new Term(\"contents\",\"foo\"));\n  Sort sort=new Sort();\n  TopDocs td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"int\",SortField.Type.INT),SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"string\",SortField.Type.STRING,true),SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"string_val\",SortField.Type.STRING_VAL,true),SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"float\",SortField.Type.FLOAT),new SortField(\"string\",SortField.Type.STRING));\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n}\n", "docstring": "test sorts when there \"'\" s nothing in the index", "partition": "test"}
{"idx": "1186", "code": "@PostConstruct public void init(){\n  configurationViews.add(defaultDistributionSetTypeLayout);\n  configurationViews.add(authenticationConfigurationView);\n  configurationViews.add(pollingConfigurationView);\n}\n", "docstring": "init method adds all configuration views to the list of views .", "partition": "test"}
{"idx": "238", "code": "@Deprecated public void unlock(LockState<T> lockState){\n  if (lockState == null) {\n    throw new IllegalArgumentException(\"lockState is null\");\n  }\n  if (lockState.setLock != this) {\n    throw new IllegalArgumentException(\"The lockState passed was not from this instance\");\n  }\n  if (lockState.thread != Thread.currentThread()) {\n    throw new IllegalArgumentException(\"The thread that created this lockState is not the same as the one unlocking it\");\n  }\n  threadSet.remove(Thread.currentThread());\n  for (  ReentrantLock lock : lockState.locks) {\n    lock.unlock();\n  }\n}\n", "docstring": "unlocks the objects acquired from locking . this method should always be in a finally block immediately after the lock . if you try to unlock from another thread , no objects are unlocked .", "partition": "test"}
{"idx": "1247", "code": "public static String generateScaleMarkers(int proteinLength,int maxNumScaleMarkers){\n  if (maxNumScaleMarkers < 2) {\n    maxNumScaleMarkers=2;\n  }\n  int scale=calcScale(proteinLength,maxNumScaleMarkers);\n  StringBuilder sb=new StringBuilder(\"0\");\n  int index=0;\n  int numRemaining=proteinLength;\n  while (index <= proteinLength) {\n    index+=scale;\n    numRemaining-=scale;\n    sb.append(\",\");\n    if ((numRemaining > 0) && (numRemaining < scale)) {\n      if (numRemaining < (scale / 2)) {\n        sb.append(proteinLength);\n        break;\n      }\n    }\n    if (index >= proteinLength) {\n      sb.append(proteinLength);\n    }\n else {\n      sb.append(index);\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "generate a string of comma - separated numbers that will be used to mark the scale of the match diagram .", "partition": "test"}
{"idx": "2098", "code": "Builder addLenient(String line){\n  int index=line.indexOf(\":\",1);\n  if (index != -1) {\n    return addLenient(line.substring(0,index),line.substring(index + 1));\n  }\n else   if (line.startsWith(\":\")) {\n    return addLenient(\"\",line.substring(1));\n  }\n else {\n    return addLenient(\"\",line);\n  }\n}\n", "docstring": "add a header line without any validation . only appropriate for headers from the remote peer or cache .", "partition": "test"}
{"idx": "3673", "code": "public static Set<String> readStopwordsPath(Path path,boolean lowercase) throws IOException {\n  return readStopwordsInputStream(Files.newInputStream(path),lowercase);\n}\n", "docstring": "read a file containing stopwords ( one per line ) . < p > empty lines and lines starting with ( \" # \" ) are filtered out .", "partition": "test"}
{"idx": "2305", "code": "private void loadUserInfoIntoActionBar(){\n  if (!TextUtils.isEmpty(mWithUserImage)) {\n    Utils.loadCircularImage(getActivity(),mWithImageView,mWithUserImage,AvatarBitmapTransformation.AvatarSize.NORMAL);\n  }\n}\n", "docstring": "loads the user image into the action bar profile pic", "partition": "test"}
{"idx": "2445", "code": "public void removeRegion(Region r){\n  regions.remove(r);\n}\n", "docstring": "include a region in the model", "partition": "test"}
{"idx": "4200", "code": "public static boolean looksLikeAListStyleType(String val){\n  return LIST_TYPES.indexOf(val) >= 0;\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "3888", "code": "static void pauseThread(long duration){\n  try {\n    Thread.sleep(duration);\n  }\n catch (  Exception e) {\n    s_logger.warn(\"Exception while trying to sleep\",e);\n  }\n}\n", "docstring": "simple puts the thread to sleep for the passed duration .", "partition": "test"}
{"idx": "796", "code": "private final static String[] readQDStrings(String string,int[] pos) throws NamingException {\n  return readQDescrs(string,pos);\n}\n", "docstring": "dstring = 1 * utf8 qdstring = whsp \" \"'\" \" dstring \" \"'\" \" whsp qdstringlist = [ qdstring * ( qdstring ) ", "partition": "test"}
{"idx": "989", "code": "public long sigignore(){\n  return Long.parseLong(fields[32]);\n}\n", "docstring": "the bitmap of ignored signals , displayed as a decimal number . obsolete , because it does not provide information on real - time signals ; use / proc / [ pid ", "partition": "test"}
{"idx": "4031", "code": "public StopwatchCPU(){\n  threadTimer=ManagementFactory.getThreadMXBean();\n  start=threadTimer.getCurrentThreadCpuTime();\n}\n", "docstring": "initializes a new stopwatch .", "partition": "test"}
{"idx": "2695", "code": "public static <T>ParallelPublisher<T> from(Publisher<? extends T> source,boolean ordered,int parallelism){\n  return from(source,ordered,parallelism,Px.bufferSize(),Px.defaultQueueSupplier(Px.bufferSize()));\n}\n", "docstring": "take a publisher and prepare to consume it on parallallism number of \"'\" rails \"'\" , possibly ordered and round - robin fashion .", "partition": "test"}
{"idx": "2839", "code": "private static int convertToInt(String value,int defaultValue){\n  String trim=value.trim();\n  if (trim.length() == 0) {\n    return defaultValue;\n  }\n  return Integer.parseInt(trim);\n}\n", "docstring": "convert a string to an int treating empty strings as the default value .", "partition": "test"}
{"idx": "2874", "code": "public void randomize(){\n  randomizeIncomingWeights();\n  normalizeIncomingWeights();\n}\n", "docstring": "randomize and normalize weights .", "partition": "test"}
{"idx": "1222", "code": "public static void saveX509Cert(String certStr,File certFile) throws IOException {\n  BufferedWriter writer=new BufferedWriter(new FileWriter(certFile));\n  writer.write(BEGIN_CERT);\n  writer.newLine();\n  writer.write(certStr);\n  writer.newLine();\n  writer.write(END_CERT);\n  writer.newLine();\n  writer.close();\n}\n", "docstring": "save a certificate to a file in base 64 binary format with begin and end strings", "partition": "test"}
{"idx": "2743", "code": "public static <T>void updateMappingToImmutableSet(Map<T,Set<AnnotationMirror>> map,T key,Set<AnnotationMirror> newQual){\n  Set<AnnotationMirror> result=AnnotationUtils.createAnnotationSet();\n  if (!map.containsKey(key)) {\n    result.addAll(newQual);\n  }\n else {\n    result.addAll(map.get(key));\n    result.addAll(newQual);\n  }\n  map.put(key,Collections.unmodifiableSet(result));\n}\n", "docstring": "see checkers . types . qualifierhierarchy # updatemappingtomutableset ( qualifierhierarchy , map , object , annotationmirror ) ( not linked because it is in an independent project .", "partition": "test"}
{"idx": "3681", "code": "public void addAll(int index,int[] data){\n  int dataLen=data.length;\n  if (dataLen == 0) {\n    return;\n  }\n  int newcap=size + (int)(dataLen * 1.1) + 1;\n  ensureCapacity(newcap);\n  System.arraycopy(array,index,array,index + dataLen,size - index);\n  System.arraycopy(data,0,array,index,dataLen);\n  size+=dataLen;\n}\n", "docstring": "appends all of the elements in the specified array at the specified position in this list .", "partition": "test"}
{"idx": "4044", "code": "private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getName(),getMask(actions));\n}\n", "docstring": "readobject is called to restore the state of the servicepermission from a stream .", "partition": "test"}
{"idx": "683", "code": "public synchronized void removeBatchClustererListener(BatchClustererListener cl){\n  m_batchClustererListeners.remove(cl);\n}\n", "docstring": "remove a batch clusterer listener", "partition": "test"}
{"idx": "1118", "code": "final public void println(long v){\n  Writer out=this.out;\n  if (out == null)   return;\n  print(v);\n  try {\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a long followed by a newline .", "partition": "test"}
{"idx": "1448", "code": "public boolean packageHasAnnotation(Annotation annotation){\n  try {\n    Package pkg=type.getPackage();\n    if (pkg == null) {\n      return false;\n    }\n    String className=pkg.getName() + \".package-info\";\n    Class<?> packageType=Class.forName(className);\n    AnnotationAccessor accessor=new AnnotationAccessor(supportedAnnotations,packageType,ignoreAnnotationFailure);\n    return accessor.typeHas(annotation);\n  }\n catch (  ClassNotFoundException e) {\n    return false;\n  }\n}\n", "docstring": "determines whether the package in which t resides has a particular annotation .", "partition": "test"}
{"idx": "4036", "code": "public static Set<URI> fetchRPTargetVirtualPools(DbClient dbClient){\n  Set<URI> rpProtectedTargetVPools=new HashSet<URI>();\n  try {\n    List<URI> vpoolProtectionSettingsURIs=dbClient.queryByType(VpoolProtectionVarraySettings.class,true);\n    Iterator<VpoolProtectionVarraySettings> vPoolProtectionSettingsItr=dbClient.queryIterativeObjects(VpoolProtectionVarraySettings.class,vpoolProtectionSettingsURIs,true);\n    while (vPoolProtectionSettingsItr.hasNext()) {\n      VpoolProtectionVarraySettings rSetting=vPoolProtectionSettingsItr.next();\n      if (null != rSetting && !NullColumnValueGetter.isNullURI(rSetting.getVirtualPool())) {\n        rpProtectedTargetVPools.add(rSetting.getVirtualPool());\n      }\n    }\n  }\n catch (  Exception ex) {\n    _log.error(\"Exception occurred while fetching RP enabled virtualpools\",ex);\n  }\n  return rpProtectedTargetVPools;\n}\n", "docstring": "fetch the rp protected target virtual pool uris .", "partition": "test"}
{"idx": "1043", "code": "public synchronized void removePropertyChangeListener(PropertyChangeListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "removes a property change listener .", "partition": "test"}
{"idx": "2446", "code": "public static void silentCloseInputStream(InputStream is){\n  try {\n    if (is != null) {\n      is.close();\n    }\n  }\n catch (  IOException e) {\n    log.w(LOG_TAG,\"Cannot close input stream\",e);\n  }\n}\n", "docstring": "a utility function to close an input stream without raising an exception .", "partition": "test"}
{"idx": "2543", "code": "protected synchronized void start(long curPrimaryGen) throws IOException {\n  if (state.equals(\"init\") == false) {\n    throw new IllegalStateException(\"already started\");\n  }\n  message(\"top: now start\");\n  try {\n    String segmentsFileName=SegmentInfos.getLastCommitSegmentsFileName(dir);\n    long maxPendingGen=-1;\n    for (    String fileName : dir.listAll()) {\n      if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        long gen=Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length() + 1),Character.MAX_RADIX);\n        if (gen > maxPendingGen) {\n          maxPendingGen=gen;\n        }\n      }\n    }\n    SegmentInfos infos;\n    if (segmentsFileName == null) {\n      infos=new SegmentInfos();\n      message(\"top: init: no segments in index\");\n    }\n else {\n      message(\"top: init: read existing segments commit \" + segmentsFileName);\n      infos=SegmentInfos.readCommit(dir,segmentsFileName);\n      message(\"top: init: segments: \" + infos.toString() + \" version=\"+ infos.getVersion());\n      Collection<String> indexFiles=infos.files(false);\n      lastCommitFiles.add(segmentsFileName);\n      lastCommitFiles.addAll(indexFiles);\n      deleter.incRef(lastCommitFiles);\n      lastNRTFiles.addAll(indexFiles);\n      deleter.incRef(lastNRTFiles);\n      message(\"top: commitFiles=\" + lastCommitFiles);\n      message(\"top: nrtFiles=\" + lastNRTFiles);\n    }\n    message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    deleter.deleteUnknownFiles(segmentsFileName);\n    message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    String s=infos.getUserData().get(PRIMARY_GEN_KEY);\n    long myPrimaryGen;\n    if (s == null) {\n      assert infos.size() == 0;\n      myPrimaryGen=-1;\n    }\n else {\n      myPrimaryGen=Long.parseLong(s);\n    }\n    message(\"top: myPrimaryGen=\" + myPrimaryGen);\n    boolean doCommit;\n    if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n      assert myPrimaryGen < curPrimaryGen;\n      final long initSyncStartNS=System.nanoTime();\n      message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen + \" vs curPrimaryGen=\"+ curPrimaryGen+ \"; sync now before mgr init\");\n      CopyJob job=null;\n      message(\"top: now delete starting commit point \" + segmentsFileName);\n      assert deleter.getRefCount(segmentsFileName) == 1;\n      deleter.decRef(Collections.singleton(segmentsFileName));\n      if (dir instanceof FSDirectory && ((FSDirectory)dir).checkPendingDeletions()) {\n        throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n      }\n      boolean didRemove=lastCommitFiles.remove(segmentsFileName);\n      assert didRemove;\n      while (true) {\n        job=newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\"+ infos.getVersion(),null,null,true,null);\n        job.start();\n        message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n        try {\n          job.runBlocking();\n          job.finish();\n          break;\n        }\n catch (        IOException ioe) {\n          job.cancel(\"startup failed\",ioe);\n          if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n            message(\"top: failed to copy: \" + ioe + \"; retrying\");\n          }\n else {\n            throw ioe;\n          }\n        }\n      }\n      lastPrimaryGen=job.getCopyState().primaryGen;\n      byte[] infosBytes=job.getCopyState().infosBytes;\n      SegmentInfos syncInfos=SegmentInfos.readCommit(dir,new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\",job.getCopyState().infosBytes)),job.getCopyState().gen);\n      syncInfos.updateGeneration(infos);\n      infos=syncInfos;\n      assert infos.getVersion() == job.getCopyState().version;\n      message(\"  version=\" + infos.getVersion() + \" segments=\"+ infos.toString());\n      message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n      deleter.incRef(job.getFileNames());\n      message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n      deleter.decRef(lastNRTFiles);\n      lastNRTFiles.clear();\n      lastNRTFiles.addAll(job.getFileNames());\n      message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n      lastFileMetaData=job.getCopyState().files;\n      message(String.format(Locale.ROOT,\"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",id,(System.nanoTime() - initSyncStartNS) / 1000000000.0,bytesToString(job.getTotalBytesCopied()),job.getCopyState().version));\n      doCommit=true;\n    }\n else {\n      doCommit=false;\n      lastPrimaryGen=curPrimaryGen;\n      message(\"top: same primary as before\");\n    }\n    if (infos.getGeneration() < maxPendingGen) {\n      message(\"top: move infos generation from \" + infos.getGeneration() + \" to \"+ maxPendingGen);\n      infos.setNextWriteGeneration(maxPendingGen);\n    }\n    sendNewReplica();\n    mgr=new SegmentInfosSearcherManager(dir,this,infos,searcherFactory);\n    IndexSearcher searcher=mgr.acquire();\n    try {\n      int hitCount=searcher.count(new TermQuery(new Term(\"marker\",\"marker\")));\n      message(\"top: marker count=\" + hitCount + \" version=\"+ ((DirectoryReader)searcher.getIndexReader()).getVersion());\n    }\n  finally {\n      mgr.release(searcher);\n    }\n    if (doCommit) {\n      commit();\n    }\n    message(\"top: done start\");\n    state=\"idle\";\n  }\n catch (  Throwable t) {\n    if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n      message(\"exc on start:\");\n      t.printStackTrace(printStream);\n    }\n else {\n      dir.close();\n    }\n    IOUtils.reThrow(t);\n  }\n}\n", "docstring": "start up this replica , which possibly requires heavy copying of files from the primary node , if we were down for a long time", "partition": "test"}
{"idx": "45", "code": "private static boolean checkValue(String val) throws MalformedObjectNameException {\n  if (val == null)   throw new NullPointerException(\"Invalid value (null)\");\n  final int len=val.length();\n  if (len == 0)   return false;\n  final char[] s=val.toCharArray();\n  final int[] result=parseValue(s,0);\n  final int endValue=result[0];\n  final boolean value_pattern=result[1] == 1;\n  if (endValue < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + s[endValue] + \"\\'\");\n  return value_pattern;\n}\n", "docstring": "check if the supplied value is a valid value .", "partition": "test"}
{"idx": "1515", "code": "public static final double calcNiceNumber(final double RANGE,final boolean ROUND){\n  double niceFraction;\n  double exponent=Math.floor(Math.log10(RANGE));\n  double fraction=RANGE / Math.pow(10,exponent);\n  if (ROUND) {\n    if (Double.compare(fraction,1.5) < 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,3) < 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,7) < 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n else {\n    if (Double.compare(fraction,1) <= 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,2) <= 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,5) <= 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n  return niceFraction * Math.pow(10,exponent);\n}\n", "docstring": "returns a \" nicescaling \" number approximately equal to the range . rounds the number if round = = true . takes the ceiling if round = false .", "partition": "test"}
{"idx": "2820", "code": "public static CheckIndex.Status checkIndex(Directory dir) throws IOException {\n  return checkIndex(dir,true);\n}\n", "docstring": "this runs the checkindex tool on the index in . if any issues are hit , a runtimeexception is thrown ; else , true is returned .", "partition": "test"}
{"idx": "726", "code": "public void configureLocalServices(){\n  clientMemo.setLnTrafficController(this);\n  clientMemo.configureCommandStation(LnCommandStationType.COMMAND_STATION_DCS100,false,false);\n  clientMemo.configureManagers();\n}\n", "docstring": "set up all of the other objects to operate with a server connected to this application .", "partition": "test"}
{"idx": "1026", "code": "private void calculateD(double[] b){\n  int length=mExtremalIndices.size() - 1;\n  mD=new double[length];\n  for (int k=0; k < length; k++) {\n    mD[k]=b[k] * (mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(k)] - mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(length)]);\n  }\n}\n", "docstring": "calculates the set of d values for the current extremal index set . implements oppenheim / schafer discrete time signal processing , 3e , 2016 , equation 116c", "partition": "test"}
{"idx": "3119", "code": "protected static void invalidateSwitchPoints(){\n  if (LOG_ENABLED) {\n    LOG.info(\"invalidating switch point\");\n  }\nsynchronized (IndyInterface.class) {\n    SwitchPoint old=switchPoint;\n    switchPoint=new SwitchPoint();\n    SwitchPoint.invalidateAll(new SwitchPoint[]{old});\n  }\n}\n", "docstring": "callback for constant meta class update change", "partition": "test"}
{"idx": "19", "code": "public String toString(){\n  final StringBuffer s=new StringBuffer();\n  final int size=size();\n  for (int i=0; i < size; i++)   s.append(getInt(i));\n  return s.toString();\n}\n", "docstring": "returns a string representation of this vector . < p > note that this string representation shows the bit of index 0 at the leftmost position .", "partition": "test"}
{"idx": "3033", "code": "public Set<WordToken> nearestWords(final int distance,final WordToken... start){\n  return nearestWords(distance,null,Arrays.asList(start));\n}\n", "docstring": "find the nearest neighbours within dependency distance links of the provided start dependencies .", "partition": "test"}
{"idx": "3107", "code": "public static boolean isResourceReference(String str){\n  return str.startsWith(BIG_QUOTE_LEFT) && str.endsWith(BIG_QUOTE_RIGHT) && str.charAt(1) == AT.charAt(0);\n}\n", "docstring": "return the str is resource reference or not .", "partition": "test"}
{"idx": "2738", "code": "public static int update(String where,Object[] args,V sets,Class<? extends Bean> t){\n  Table mapping=(Table)t.getAnnotation(Table.class);\n  if (mapping == null) {\n    if (log.isErrorEnabled())     log.error(\"mapping missed in [\" + t + \"] declaretion\");\n    return -1;\n  }\n  if (!X.isEmpty(mapping.name())) {\n    return updateTable(mapping.name(),where,args,sets);\n  }\n  return -1;\n}\n", "docstring": "update the data using values", "partition": "test"}
{"idx": "2883", "code": "public GeoServerWPSClient(GeoServerConnection connection){\n  this.connection=connection;\n}\n", "docstring": "instantiates a new geo server wps client .", "partition": "test"}
{"idx": "603", "code": "public static long fromInet4Address(final InetAddress inetAddress){\n  ensureIsInet4Address(inetAddress);\n  return Integer.toUnsignedLong(inetAddress.hashCode());\n}\n", "docstring": "pack ipv4 address and match - all socket flag into a long .", "partition": "test"}
{"idx": "4183", "code": "@Override public synchronized void start(){\n  if (running) {\n    return;\n  }\n  LOGGER.info(\"Starting server\");\n  if (endpoints.isEmpty()) {\n    int port=config.getInt(NetworkConfig.Keys.COAP_PORT);\n    LOGGER.log(Level.INFO,\"No endpoints have been defined for server, setting up server endpoint on default port {0}\",port);\n    addEndpoint(new CoapEndpoint(port,this.config));\n  }\n  int started=0;\n  for (  Endpoint ep : endpoints) {\n    try {\n      ep.start();\n      ++started;\n    }\n catch (    IOException e) {\n      LOGGER.log(Level.SEVERE,\"Cannot start server endpoint [\" + ep.getAddress() + \"]\",e);\n    }\n  }\n  if (started == 0) {\n    throw new IllegalStateException(\"None of the server endpoints could be started\");\n  }\n else {\n    running=true;\n  }\n}\n", "docstring": "starts the server by starting all endpoints this server is assigned to . each endpoint binds to its port . if no endpoint is assigned to the server , an endpoint is started on the port defined in the config .", "partition": "test"}
{"idx": "3139", "code": "public boolean isEmpty(){\n  return mSelectedWidgets.isEmpty();\n}\n", "docstring": "check if the selection is empty", "partition": "test"}
{"idx": "2447", "code": "@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {\n  if (requestID == null && localName.equals(\"batchRequest\")) {\n    requestID=attributes.getValue(\"requestID\");\n  }\n  super.startElement(uri,localName,qName,attributes);\n}\n", "docstring": "this function fetches the requestid value of the batchrequest xml element and call the default implementation ( super ) .", "partition": "test"}
{"idx": "123", "code": "protected void handle(Exception exception,String title,String message){\n  Utils.handleError(getShell(),exception,title,message);\n}\n", "docstring": "shows the given errors to the user .", "partition": "test"}
{"idx": "145", "code": "protected boolean hasAllTables() throws CouldntLoadDataException, InvalidDatabaseException {\n  NaviLogger.info(\"Checking the existence of the BinNavi database tables\");\n  final int counter=PostgreSQLHelpers.getTableCount(getConnection(),Lists.newArrayList(TABLES));\n  if (counter == 0) {\n    return false;\n  }\n else   if (counter == TABLES.length) {\n    return true;\n  }\n else {\n    throw new InvalidDatabaseException(String.format(\"Invalid database state (%d of %d tables found)\",counter,TABLES.length));\n  }\n}\n", "docstring": "makes sure that all required binnavi database tables exist . this method tries to find out whether the database is empty or already initialized ( or inconsistent ) .", "partition": "test"}
{"idx": "274", "code": "public CStatusPanel(final BackEndDebuggerProvider debuggerProvider){\n  super(new BorderLayout());\n  Preconditions.checkNotNull(debuggerProvider,\"IE1094: Debugger provider argument can not be null\");\n  m_label.setForeground(Color.BLACK);\n  add(m_label);\n  m_synchronizer=new CStatusLabelSynchronizer(m_label,debuggerProvider);\n}\n", "docstring": "creates a new status panel .", "partition": "test"}
{"idx": "560", "code": "public PlaPointFloat change_size(double p_new_size){\n  if (v_x == 0 && v_y == 0) {\n    return this;\n  }\n  double length=Math.sqrt(v_x * v_x + v_y * v_y);\n  double new_x=(v_x * p_new_size) / length;\n  double new_y=(v_y * p_new_size) / length;\n  return new PlaPointFloat(new_x,new_y);\n}\n", "docstring": "approximates a floatpoint on the line from zero to this point with distance p_new_length from zero .", "partition": "test"}
{"idx": "2021", "code": "public synchronized void init(){\n  init=true;\n  for (  String mapName : store.getMapNames()) {\n    if (mapName.startsWith(\"temp.\")) {\n      MVMap<Object,Integer> temp=openTempMap(mapName);\n      store.removeMap(temp);\n    }\n  }\nsynchronized (undoLog) {\n    if (undoLog.size() > 0) {\n      for (      Long key : undoLog.keySet()) {\n        int transactionId=getTransactionId(key);\n        openTransactions.set(transactionId);\n      }\n    }\n  }\n}\n", "docstring": "initialize the store . this is needed before a transaction can be opened . if the transaction store is corrupt , this method can throw an exception , in which case the store can only be used for reading .", "partition": "test"}
{"idx": "1313", "code": "public static void closeQuietly(final Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    final RuntimeException rethrown) {\n      throw rethrown;\n    }\ncatch (    final Exception ignored) {\n    }\n  }\n}\n", "docstring": "closes \"'\" closeable \"'\" , ignoring any checked exceptions . does nothing if \"'\" closeable \"'\" is null .", "partition": "test"}
{"idx": "569", "code": "public PartialCorrelationPdf(int n,int k){\n  this.n=n;\n  this.k=k;\n  double gammaRatio=gammaRatio(n,k);\n  this.constant=(1 / Math.pow(Math.PI,0.5)) * gammaRatio;\n  this.outsideExp=(double)(n - k - 2) / 2.0;\n}\n", "docstring": "constructs a new zero partial correlation distribution function with the given values for n and k .", "partition": "test"}
{"idx": "3415", "code": "@Override protected void drawAxisLine(Graphics2D g2,double cursor,Rectangle2D dataArea,RectangleEdge edge){\n  Line2D axisLine=null;\n  double c=cursor;\n  if (edge == RectangleEdge.TOP) {\n    axisLine=new Line2D.Double(dataArea.getX(),c,dataArea.getMaxX(),c);\n  }\n else   if (edge == RectangleEdge.BOTTOM) {\n    axisLine=new Line2D.Double(dataArea.getX(),c,dataArea.getMaxX(),c);\n  }\n else   if (edge == RectangleEdge.LEFT) {\n    axisLine=new Line2D.Double(c,dataArea.getY(),c,dataArea.getMaxY());\n  }\n else   if (edge == RectangleEdge.RIGHT) {\n    axisLine=new Line2D.Double(c,dataArea.getY(),c,dataArea.getMaxY());\n  }\n  g2.setPaint(getAxisLinePaint());\n  g2.setStroke(getAxisLineStroke());\n  Object saved=g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_NORMALIZE);\n  g2.draw(axisLine);\n  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,saved);\n  boolean drawUpOrRight=false;\n  boolean drawDownOrLeft=false;\n  if (this.positiveArrowVisible) {\n    if (this.inverted) {\n      drawDownOrLeft=true;\n    }\n else {\n      drawUpOrRight=true;\n    }\n  }\n  if (this.negativeArrowVisible) {\n    if (this.inverted) {\n      drawUpOrRight=true;\n    }\n else {\n      drawDownOrLeft=true;\n    }\n  }\n  if (drawUpOrRight) {\n    double x=0.0;\n    double y=0.0;\n    Shape arrow=null;\n    if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n      x=dataArea.getMaxX();\n      y=cursor;\n      arrow=this.rightArrow;\n    }\n else     if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n      x=cursor;\n      y=dataArea.getMinY();\n      arrow=this.upArrow;\n    }\n    AffineTransform transformer=new AffineTransform();\n    transformer.setToTranslation(x,y);\n    Shape shape=transformer.createTransformedShape(arrow);\n    g2.fill(shape);\n    g2.draw(shape);\n  }\n  if (drawDownOrLeft) {\n    double x=0.0;\n    double y=0.0;\n    Shape arrow=null;\n    if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n      x=dataArea.getMinX();\n      y=cursor;\n      arrow=this.leftArrow;\n    }\n else     if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n      x=cursor;\n      y=dataArea.getMaxY();\n      arrow=this.downArrow;\n    }\n    AffineTransform transformer=new AffineTransform();\n    transformer.setToTranslation(x,y);\n    Shape shape=transformer.createTransformedShape(arrow);\n    g2.fill(shape);\n    g2.draw(shape);\n  }\n}\n", "docstring": "draws an axis line at the current cursor position and edge .", "partition": "test"}
{"idx": "2282", "code": "private Map<String,List<Zone>> selectZonesForInitiatorsAndPorts(NetworkLite network,Map<String,List<Zone>> wwnToZones,Map<String,StoragePort> initiatorPortsMap){\n  Map<String,List<Zone>> filteredMap=new HashMap<String,List<Zone>>();\n  Zone zone=null;\n  List<Zone> zones=null;\n  for (  String initiatorWwn : wwnToZones.keySet()) {\n    for (    String portWwn : initiatorPortsMap.keySet()) {\n      zone=_networkScheduler.selectExistingZoneForInitiatorPort(network,initiatorWwn,portWwn,wwnToZones.get(initiatorWwn));\n      if (zone != null) {\n        zones=filteredMap.get(initiatorWwn);\n        if (zones == null) {\n          zones=new ArrayList<>();\n          filteredMap.put(initiatorWwn,zones);\n        }\n        zones.add(zone);\n      }\n    }\n  }\n  return filteredMap;\n}\n", "docstring": "given the map of all existing zones for a set on initiators and ports , this function selects the zones that should be used by vipr .", "partition": "test"}
{"idx": "275", "code": "@Override public boolean open(String access){\n  if (access.equals(\"r\")) {\n    try {\n      iStream=new FileImageInputStream(new File(filePath));\n      parser=new LabelParser();\n      metadata=parser.parseHeader(iStream);\n      iStream.close();\n      iStream=null;\n    }\n catch (    IOException e) {\n      try {\n        iStream.close();\n      }\n catch (      Exception x) {\n      }\n      return (false);\n    }\n  }\n  return (super.open(access));\n}\n", "docstring": "open the pds file .", "partition": "test"}
{"idx": "1592", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenee != null || !eventName.equals(\"instance\")) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection with respect to the named event", "partition": "test"}
{"idx": "3445", "code": "public String generateMinimalMATSimConfig(){\n  Config config=new Config();\n  ConfigGroup ippcm=config.createModule(MatrixBasedPtRouterConfigGroup.GROUP_NAME);\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.PT_STOPS,this.ptStops);\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.USING_PT_STOPS,\"tRue\");\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.PT_TRAVEL_TIMES_AND_DISTANCES_SWITCH,this.useTravelTimesAndDistances);\n  ChangeModeConfigGroup changeModeConfig=ConfigUtils.addOrGetModule(config,ChangeModeConfigGroup.CONFIG_MODULE,ChangeModeConfigGroup.class);\n  String[] str={\"car\",\"pt\"};\n  changeModeConfig.setModes(str);\n  return writeConfigFile(config);\n}\n", "docstring": "generates the external matsim config file with the specified parameter settings", "partition": "test"}
{"idx": "2072", "code": "public boolean isValidTemplate(){\n  return isValidTemplate(template);\n}\n", "docstring": "validates this template to see if its valid for plugin v3 . 10 or higher .", "partition": "test"}
{"idx": "2506", "code": "static void removeAllPhis(IR ir){\n  for (Instruction s=ir.firstInstructionInCodeOrder(), sentinel=ir.lastInstructionInCodeOrder(), nextInstr=null; s != sentinel; s=nextInstr) {\n    nextInstr=s.nextInstructionInCodeOrder();\n    if (Phi.conforms(s))     s.remove();\n  }\n}\n", "docstring": "remove all phi instructions from the ir .", "partition": "test"}
{"idx": "2321", "code": "public ActivityMonitorSample(){\n  initComponents();\n  ownerARadio.setActionCommand(\"A\");\n  ownerBRadio.setActionCommand(\"B\");\n  ownerCRadio.setActionCommand(\"C\");\n  indicatorA.setActivityOwner(\"A\");\n  indicatorB.setActivityOwner(\"B\");\n  indicatorC.setActivityOwner(\"C\");\n  JActivityWindow.getInstance();\n}\n", "docstring": "creates new form activitymonitorsample", "partition": "test"}
{"idx": "285", "code": "protected void parseAndAddMapTileSet(URL tileSetProperties) throws IOException, MalformedURLException {\n  Properties descProps=new Properties();\n  Logger logger=getLogger();\n  logger.info(\"going to read props\");\n  InputStream descURLStream=tileSetProperties.openStream();\n  descProps.load(descURLStream);\n  logger.info(\"loaded \" + tileSetProperties.toString() + \" \"+ descProps.toString());\n  MapTileSet mts=createMapTileSetFromProperties(descProps);\n  if (mts != null && mts.allGood()) {\n    String mtsName=mts.getName();\n    mapTileSets.put(mts.getName(),mts);\n    logger.info(\"Adding \" + mtsName + \" dataset\");\n  }\n  descURLStream.close();\n}\n", "docstring": "given a url to a properties file describing a maptileset , create it and add it to the list .", "partition": "test"}
{"idx": "2236", "code": "private double maxIgnoreNaN(double a,double b){\n  if (Double.isNaN(a)) {\n    return b;\n  }\n  if (Double.isNaN(b)) {\n    return a;\n  }\n else {\n    return Math.max(a,b);\n  }\n}\n", "docstring": "a function to find the maximum of two values , but ignoring any double . nan values .", "partition": "test"}
{"idx": "1495", "code": "@Override protected void tearDown() throws NamingException, JMSException {\n  NamingEnumeration<Binding> iter=context.listBindings(\"\");\n  while (iter.hasMore()) {\n    Binding binding=iter.next();\n    Object connFactory=binding.getObject();\n    if (connFactory instanceof ActiveMQConnectionFactory) {\n    }\n  }\n}\n", "docstring": "stops all existing activemqconnectionfactory in context .", "partition": "test"}
{"idx": "929", "code": "public static boolean isPlaceAction(InventoryAction action){\nswitch (action) {\ncase SWAP_WITH_CURSOR:\ncase PLACE_ONE:\ncase PLACE_ALL:\ncase PLACE_SOME:\n    return true;\n}\nreturn false;\n}\n", "docstring": "check if a given inventoryaction involves placing items into the slot .", "partition": "test"}
{"idx": "2045", "code": "protected final void drawArrowHead(Graphics2D g,int x,int y,int sgn){\n  g.setStroke(Strokes.getStroke(StrokeType.SOLID,1));\n  int size=diagram().arrowSize;\nswitch (headType) {\ncase CLOSED:\n    Polygon p=new Polygon(new int[]{x,x + sgn * size,x + sgn * size,x},new int[]{y,y - size,y + size,y},4);\n  g.fillPolygon(p);\nbreak;\ncase OPEN:\ng.drawLine(x,y,x + sgn * size,y - size);\ng.drawLine(x,y,x + sgn * size,y + size);\nbreak;\ncase ROUNDED:\nint left=sgn == -1 ? x - 2 * size : x;\nint top=y - size;\ng.fillArc(left,top,size * 2,size * 2,90,sgn * 180);\n}\n}\n", "docstring": "draws the head of a message arrow onto the diagram display .", "partition": "test"}
{"idx": "1854", "code": "public static Calendar reduceCalendar(Calendar calendar){\n  calendar.set(Calendar.MILLISECOND,0);\n  calendar.set(Calendar.SECOND,0);\n  calendar.set(Calendar.MINUTE,0);\n  calendar.set(Calendar.HOUR,0);\n  calendar.set(Calendar.HOUR_OF_DAY,0);\n  return calendar;\n}\n", "docstring": "sets the supplied calendar object with 0 values for fields lower than days", "partition": "test"}
{"idx": "2034", "code": "public static final IndexCreatedEvent createTestIndexCreationStatusWithBulkDataHit(){\n  IndexCreatedEvent toReturn=new IndexCreatedEvent(UUID.randomUUID(),new Date(),new Date(),createTestIndexWithBulkDataHit(),1000,0);\n  toReturn.calculateValues();\n  return toReturn;\n}\n", "docstring": "creates at test indexcreatedevent .", "partition": "test"}
{"idx": "539", "code": "public HubLinkMapping(String fileName,int numberOfHubs,Network network){\n  this.numberOfHubs=numberOfHubs;\n  if (fileName.contains(\".mappingTable.\")) {\n    readMappingTable(fileName);\n    unMappedLinksAtZeroHub=true;\n    return;\n  }\n  handleUnmappedLinksStart();\n  try {\n    FileReader fr=new FileReader(fileName);\n    BufferedReader br=new BufferedReader(fr);\n    String line;\n    StringTokenizer tokenizer;\n    String token;\n    int linkId;\n    line=br.readLine();\n    while (line != null) {\n      tokenizer=new StringTokenizer(line);\n      for (int i=0; i < this.numberOfHubs; i++) {\n        token=tokenizer.nextToken();\n        linkId=(int)Double.parseDouble(token);\n        linkHubMapping.put(Integer.toString(linkId),i);\n      }\n      if (tokenizer.hasMoreTokens()) {\n        throw new RuntimeException(\"the number of hubs is wrong\");\n      }\n      line=br.readLine();\n    }\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error reading the hub link mapping file\");\n  }\n  linkHubMapping.remove(\"-1\");\n  handleUnmappedLinksEnd(network);\n}\n", "docstring": "reads the mappings from the file . the file has columns ( first column for first hub and all the links corresponding to that hub below it )", "partition": "test"}
{"idx": "1210", "code": "static void appendToPointerHierarchy(final BaseType type,final BaseType pointer){\n  Preconditions.checkNotNull(type,\"Error: type argument can not be null.\");\n  Preconditions.checkNotNull(pointer,\"Error: pointer argument can not be null.\");\n  Preconditions.checkArgument(type != pointer,\"Error: Can not establish pointer relation between identical types.\");\n  Preconditions.checkArgument(pointer.pointedToBy != type,\"Error: Can not establish circular pointer relation.\");\n  Preconditions.checkArgument(type.pointsTo != pointer,\"Error: Can not establish circular pointer relation.\");\n  pointer.pointsTo=type;\n  type.pointedToBy=pointer;\n}\n", "docstring": "appends a base type to the pointer hierarchy just below parent , e . g . if type is an int then pointer must be an int * . the \" bottom \" element in this hierarchy is the value type , followed by the pointer types .", "partition": "test"}
{"idx": "4192", "code": "private double empiricalHSIC(TetradMatrix Ky,TetradMatrix Kx,TetradMatrix Kz,int m){\n  TetradMatrix Kyx=Ky.times(Kx);\n  TetradMatrix Kyz=Ky.times(Kz);\n  TetradMatrix Kzx=Kz.times(Kx);\n  TetradMatrix Kzreg=Kz.copy();\n  for (int i=0; i < m; i++) {\n    double ent=(Kzreg.get(i,i) + this.regularizer);\n    Kzreg.set(i,i,ent);\n  }\n  TetradMatrix A=Kzreg.inverse();\n  Kzreg=A.times(A);\n  TetradMatrix Kyzzregzx=new TetradMatrix(m,m);\n  A=Kyz.times(Kzreg);\n  Kyzzregzx=A.times(Kzx);\n  TetradMatrix Kyzzregzxzzregz=Kyzzregzx.copy();\n  Kyzzregzxzzregz=Kyzzregzx.times(Kz);\n  A=Kyzzregzxzzregz.times(Kzreg);\n  Kyzzregzxzzregz=A.times(Kz);\n  double empHSIC=0.0;\n  for (int i=0; i < m; i++) {\n    empHSIC+=Kyx.get(i,i);\n    empHSIC+=(-2 * Kyzzregzx.get(i,i));\n    empHSIC+=Kyzzregzxzzregz.get(i,i);\n  }\n  empHSIC/=Math.pow(m - 1,2);\n  double Bz=0.0;\n  for (int i=0; i < (m - 1); i++) {\n    for (int j=(i + 1); j < m; j++) {\n      Bz+=Math.pow(Kz.get(i,j),2);\n      Bz+=Math.pow(Kz.get(j,i),2);\n    }\n  }\n  Bz=(m * (m - 1)) / Bz;\n  empHSIC*=Bz;\n  return empHSIC;\n}\n", "docstring": "empirical conditional hilbert - schmidt dependence measure y and x given z", "partition": "test"}
{"idx": "3351", "code": "public void testConfigFileProperty() throws Exception {\n  File configHome=new File(configuration.getHome());\n  assertTrue(\"Could not find a proper configuration home.\",configHome.exists() && configHome.isDirectory());\n  File existingFile=createFile(configHome,\"existingfile\",\"helloworld\");\n  assertEquals(\"helloworld\",readFile(existingFile));\n  String fileName=\"testConfigfile\";\n  String fileContents=\"Hello @message@ \";\n  File file=createFile(configFileDirectory,fileName,fileContents);\n  FileConfig configFile=new FileConfig();\n  configFile.setFile(getAbsolutePath(file));\n  configFile.setToFile(\"existingfile\");\n  configFile.setOverwrite(false);\n  configFile.setConfigfile(false);\n  configuration.setProperty(\"message\",\"world\");\n  configuration.setConfigFileProperty(configFile);\n  configuration.doConfigure(null);\n  File copiedFile=new File(configuration.getHome() + \"/existingfile\");\n  assertTrue(\"Cannot find the expected copied file\",copiedFile.exists());\n  assertEquals(\"Hello world \",readFile(copiedFile));\n}\n", "docstring": "test configuration file property .", "partition": "test"}
{"idx": "1906", "code": "@Override public StateConnection onCloseRead(){\n  ConnectionProtocol request=request();\n  if (request != null) {\n    request.onCloseRead();\n  }\n  _sequenceClose.set(_sequenceRead.get());\n  if (_sequenceFlush.get() < _sequenceClose.get()) {\n    _isClosePending.set(true);\n    if (_sequenceFlush.get() < _sequenceClose.get()) {\n      return StateConnection.CLOSE_READ_S;\n    }\n else {\n      _isClosePending.set(false);\n      return StateConnection.CLOSE;\n    }\n  }\n else {\n    return StateConnection.CLOSE;\n  }\n}\n", "docstring": "called by reader thread on reader end of file .", "partition": "test"}
{"idx": "1878", "code": "@LayoutlibDelegate static long currentThreadTimeMillis(){\n  return System.currentTimeMillis();\n}\n", "docstring": "returns milliseconds running in the current thread .", "partition": "test"}
{"idx": "1138", "code": "public void addColumn(int idx,Column column){\n  if (column != null) {\n    columns.add(idx,column);\n  }\n}\n", "docstring": "adds the given column at the specified position .", "partition": "test"}
{"idx": "3972", "code": "public Builder deleteEntitlements(){\n  deleteFields.add(\"entitlements\");\n  return this;\n}\n", "docstring": "deletes all entitlements of a existing user", "partition": "test"}
{"idx": "3627", "code": "protected abstract void bindItem(DataBoundViewHolder<T> holder,int position,List<Object> payloads);\n", "docstring": "override this method to handle binding your items into views", "partition": "test"}
{"idx": "1035", "code": "public boolean isLastInvoice(){\n  String cm=getCostingMethod();\n  return cm != null && cm.equals(COSTINGMETHOD_LastInvoice);\n}\n", "docstring": "is last invoice costing method", "partition": "test"}
{"idx": "3271", "code": "public Object assignIdValue(Object data,Number val,ObjectCache objectCache) throws SQLException {\n  Object idVal=dataPersister.convertIdNumber(val);\n  if (idVal == null) {\n    throw new SQLException(\"Invalid class \" + dataPersister + \" for sequence-id \"+ this);\n  }\n else {\n    assignField(data,idVal,false,objectCache);\n    return idVal;\n  }\n}\n", "docstring": "assign an id value to this field .", "partition": "test"}
{"idx": "869", "code": "protected final void writeS(ByteBuffer buf,String text){\n  if (text == null) {\n    buf.putChar('\\\\000');\n  }\n else {\n    final int len=text.length();\n    for (int i=0; i < len; i++) {\n      buf.putChar(text.charAt(i));\n    }\n    buf.putChar('\\\\000');\n  }\n}\n", "docstring": "write string to buffer", "partition": "test"}
{"idx": "2563", "code": "public ArrayFieldVector(FieldVector<T> v1,T[] v2) throws NullArgumentException {\n  MathUtils.checkNotNull(v1);\n  MathUtils.checkNotNull(v2);\n  field=v1.getField();\n  final T[] v1Data=(v1 instanceof ArrayFieldVector) ? ((ArrayFieldVector<T>)v1).data : v1.toArray();\n  data=MathArrays.buildArray(field,v1Data.length + v2.length);\n  System.arraycopy(v1Data,0,data,0,v1Data.length);\n  System.arraycopy(v2,0,data,v1Data.length,v2.length);\n}\n", "docstring": "construct a vector by appending one vector to another vector .", "partition": "test"}
{"idx": "10", "code": "private void validateSqlStatement(String sql,int jdbcStatementIndex){\n  Assert.isTrue(StringUtils.isNotBlank(sql),\"JDBC statement [\" + jdbcStatementIndex + \"] SQL is required\");\n}\n", "docstring": "validates the given sql statement where its position in the list of statement is the given index . this method does not validate sql syntax .", "partition": "test"}
{"idx": "2131", "code": "public DeltaCRLIndicatorExtension(int crlNum) throws IOException {\n  super(PKIXExtensions.DeltaCRLIndicator_Id,true,BigInteger.valueOf(crlNum),NAME,LABEL);\n}\n", "docstring": "creates a delta crl indicator extension with the integer value . the criticality is set to true .", "partition": "test"}
{"idx": "273", "code": "@Override public void error(String domain,String key,XMLParseException exception) throws XNIException {\n  if (fErrorHandler != null) {\n    SAXParseException saxException=createSAXParseException(exception);\n    try {\n      fErrorHandler.error(saxException);\n    }\n catch (    SAXParseException e) {\n      throw createXMLParseException(e);\n    }\ncatch (    SAXException e) {\n      throw createXNIException(e);\n    }\n  }\n}\n", "docstring": "reports an error . errors are non - fatal and usually signify that the document is invalid with respect to its grammar ( s ) .", "partition": "test"}
{"idx": "3290", "code": "public void testThenAcceptBoth_exceptionalCompletion() throws Throwable {\n  for (  ExecutionMode m : ExecutionMode.values())   for (  boolean fFirst : new boolean[]{true,false})   for (  boolean failFirst : new boolean[]{true,false})   for (  Integer v1 : new Integer[]{1,null}) {\n    final CompletableFuture<Integer> f=new CompletableFuture<>();\n    final CompletableFuture<Integer> g=new CompletableFuture<>();\n    final CFException ex=new CFException();\n    final SubtractAction r1=new SubtractAction(m);\n    final SubtractAction r2=new SubtractAction(m);\n    final SubtractAction r3=new SubtractAction(m);\n    final CompletableFuture<Integer> fst=fFirst ? f : g;\n    final CompletableFuture<Integer> snd=!fFirst ? f : g;\n    final Callable<Boolean> complete1=failFirst ? null : null;\n    final Callable<Boolean> complete2=failFirst ? null : null;\n    final CompletableFuture<Void> h1=m.thenAcceptBoth(f,g,r1);\n    assertTrue(complete1.call());\n    final CompletableFuture<Void> h2=m.thenAcceptBoth(f,g,r2);\n    checkIncomplete(h1);\n    checkIncomplete(h2);\n    assertTrue(complete2.call());\n    final CompletableFuture<Void> h3=m.thenAcceptBoth(f,g,r3);\n    checkCompletedWithWrappedException(h1,ex);\n    checkCompletedWithWrappedException(h2,ex);\n    checkCompletedWithWrappedException(h3,ex);\n    r1.assertNotInvoked();\n    r2.assertNotInvoked();\n    r3.assertNotInvoked();\n    checkCompletedNormally(failFirst ? snd : fst,v1);\n    checkCompletedExceptionally(failFirst ? fst : snd,ex);\n  }\n}\n", "docstring": "thenacceptboth result completes exceptionally after exceptional completion of either source", "partition": "test"}
{"idx": "1457", "code": "private int[] createEpochMonths(int epochDay,int minYear,int maxYear,Map<Integer,int[]> years){\n  int numMonths=(maxYear - minYear + 1) * 12 + 1;\n  int epochMonth=0;\n  int[] epochMonths=new int[numMonths];\n  minMonthLength=Integer.MAX_VALUE;\n  maxMonthLength=Integer.MIN_VALUE;\n  for (int year=minYear; year <= maxYear; year++) {\n    int[] months=years.get(year);\n    for (int month=0; month < 12; month++) {\n      int length=months[month];\n      epochMonths[epochMonth++]=epochDay;\n      if (length < 29 || length > 32) {\n        throw new IllegalArgumentException(\"Invalid month length in year: \" + minYear);\n      }\n      epochDay+=length;\n      minMonthLength=Math.min(minMonthLength,length);\n      maxMonthLength=Math.max(maxMonthLength,length);\n    }\n  }\n  epochMonths[epochMonth++]=epochDay;\n  if (epochMonth != epochMonths.length) {\n    throw new IllegalStateException(\"Did not fill epochMonths exactly: ndx = \" + epochMonth + \" should be \"+ epochMonths.length);\n  }\n  return epochMonths;\n}\n", "docstring": "converts the map of year to month lengths ranging from minyear to maxyear into a linear contiguous array of epochdays . the index is the hijrahmonth computed from year and month and offset by minyear . the value of each entry is the epochday corresponding to the first day of the month .", "partition": "test"}
{"idx": "3240", "code": "public void mouseWheelMoved(MouseWheelEvent e){\n  boolean accepted=checkModifiers(e);\n  if (accepted == true) {\n    VisualizationViewer<?,?> vv=(VisualizationViewer<?,?>)e.getSource();\n    Point2D mouse=e.getPoint();\n    Point2D center=vv.getCenter();\n    int amount=e.getWheelRotation();\n    if (zoomAtMouse) {\n      if (amount > 0) {\n        scaler.scale(vv,in,mouse);\n      }\n else       if (amount < 0) {\n        scaler.scale(vv,out,mouse);\n      }\n    }\n else {\n      if (amount > 0) {\n        scaler.scale(vv,in,center);\n      }\n else       if (amount < 0) {\n        scaler.scale(vv,out,center);\n      }\n    }\n    e.consume();\n    vv.repaint();\n  }\n}\n", "docstring": "zoom the display in or out , depending on the direction of the mouse wheel motion .", "partition": "test"}
{"idx": "1579", "code": "private void addSyntheticEdge(Collection<GraphEdge> result,GraphEdge original,GraphNode head,GraphNode tail){\n  result.add(new GraphEdge(head,tail,original.getRelation()));\n}\n", "docstring": "synthesize a new edge , and add it to the result . the new edge goes from head to tail , and it \"'\" s relationship type is obtained from the original edge .", "partition": "test"}
{"idx": "1270", "code": "private int append(FileSystem fs,Configuration conf,Path src,PrintWriter writer,int currentRecordNumber) throws IOException {\n  BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(src)));\n  try {\n    String line=reader.readLine();\n    while (line != null) {\n      if (line.startsWith(\"Recno:: \")) {\n        line=\"Recno:: \" + currentRecordNumber++;\n      }\n      writer.println(line);\n      line=reader.readLine();\n    }\n    return currentRecordNumber;\n  }\n  finally {\n    reader.close();\n  }\n}\n", "docstring": "appends two files and updates the recno counter", "partition": "test"}
{"idx": "2434", "code": "public void writeGolomb(int divisor,int value){\n  int q=value / divisor;\n  for (int i=0; i < q; i++) {\n    writeBit(1);\n  }\n  writeBit(0);\n  int r=value - q * divisor;\n  int bit=31 - Integer.numberOfLeadingZeros(divisor - 1);\n  if (r < ((2 << bit) - divisor)) {\n    bit--;\n  }\n else {\n    r+=(2 << bit) - divisor;\n  }\n  for (; bit >= 0; bit--) {\n    writeBit((r >>> bit) & 1);\n  }\n}\n", "docstring": "write the golomb code of a value .", "partition": "test"}
{"idx": "50", "code": "public void handleRequest(RequestContext rc) throws CLIException {\n  super.handleRequest(rc);\n  ldapLogin();\n  SSOToken adminSSOToken=getAdminSSOToken();\n  IOutput outputWriter=getOutputWriter();\n  String realm=getStringOptionValue(IArgument.REALM_NAME);\n  String patternType=getStringOptionValue(IArgument.AGENT_TYPE);\n  String filter=getStringOptionValue(IArgument.FILTER);\n  if (patternType == null) {\n    patternType=\"\";\n  }\n  if ((filter == null) || (filter.length() == 0)) {\n    filter=\"*\";\n  }\n  String[] params={realm,patternType,filter};\n  writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"ATTEMPT_LIST_AGENTS\",params);\n  try {\n    AMIdentityRepository amir=new AMIdentityRepository(adminSSOToken,realm);\n    IdSearchResults isr=amir.searchIdentities(IdType.AGENTONLY,filter,new IdSearchControl());\n    Set results=isr.getSearchResults();\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        if (!matchType(amid,patternType)) {\n          i.remove();\n        }\n      }\n    }\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        Object[] args={amid.getName(),amid.getUniversalId()};\n        outputWriter.printlnMessage(MessageFormat.format(getResourceString(\"format-search-agent-results\"),args));\n      }\n    }\n else {\n      outputWriter.printlnMessage(getResourceString(\"search-agent-no-entries\"));\n    }\n    writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"SUCCEED_LIST_AGENTS\",params);\n  }\n catch (  IdRepoException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\ncatch (  SSOException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\n}\n", "docstring": "services a commandline request .", "partition": "test"}
{"idx": "631", "code": "public boolean isFull(){\n  if (maxSize > 0 && notifications.size() >= maxSize) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "check whether this matcher has reached \" max - size \" or not .", "partition": "test"}
{"idx": "1581", "code": "private static byte[] WindowsRegEnumKeyEx1(int hKey,int subKeyIndex,int maxKeyLength){\n  byte[] result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "retries regenumkeyex ( ) max_attempts times before giving up .", "partition": "test"}
{"idx": "2356", "code": "public void testIsDuplicateString(){\n  int count=10000;\n  ActiveMQMessageAudit audit=new ActiveMQMessageAudit();\n  IdGenerator idGen=new IdGenerator();\n  List<String> list=new ArrayList<>();\n  for (int i=0; i < count; i++) {\n    String id=idGen.generateId();\n    list.add(id);\n    assertFalse(audit.isDuplicate(id));\n  }\n  List<String> windowList=list.subList(list.size() - 1 - audit.getAuditDepth(),list.size() - 1);\n  for (  String id : windowList) {\n    assertTrue(\"duplicate, id:\" + id,audit.isDuplicate(id));\n  }\n}\n", "docstring": "test case for isduplicate", "partition": "test"}
{"idx": "2736", "code": "public void onChildThreadResumeEnd(){\n  _threadCount.getAndDecrement();\n  wake();\n}\n", "docstring": "end housekeeping for a child thread managed by the launcher \"'\" s housekeeping , but not spawned by the launcher itself , e . g . comet , websocket , keepalive .", "partition": "test"}
{"idx": "281", "code": "private void stretchViewVertically(View view,int crossSize){\n  LayoutParams lp=(LayoutParams)view.getLayoutParams();\n  int newHeight=crossSize - lp.topMargin - lp.bottomMargin;\n  newHeight=Math.max(newHeight,0);\n  view.measure(MeasureSpec.makeMeasureSpec(view.getMeasuredWidth(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(newHeight,MeasureSpec.EXACTLY));\n}\n", "docstring": "expand the view vertically to the size of the crosssize ( considering the view margins )", "partition": "test"}
{"idx": "2353", "code": "private void storeLastUsed(){\n  put(LAST_USE,(int)(System.currentTimeMillis() / 1000));\n}\n", "docstring": "store current system time as the last used", "partition": "test"}
{"idx": "3777", "code": "private void createGui(){\n  final JPanel topPanel=new JPanel(new BorderLayout());\n  final JPanel innerTopPanel=new JPanel(new BorderLayout());\n  innerTopPanel.add(m_stdEditPanel);\n  topPanel.add(innerTopPanel);\n  final JPanel debuggerChooserPanel=new JPanel(new BorderLayout());\n  debuggerChooserPanel.setBorder(new TitledBorder(\"Project Debuggers\"));\n  m_checkedList=new JCheckedListbox<>(new Vector<DebuggerTemplate>(),false);\n  updateCheckedListPanel();\n  final JScrollPane debuggerScrollPane=new JScrollPane(m_checkedList);\n  m_checkedListPanel.add(debuggerScrollPane);\n  debuggerChooserPanel.add(m_checkedListPanel,BorderLayout.CENTER);\n  debuggerChooserPanel.setMinimumSize(new Dimension(0,128));\n  debuggerChooserPanel.setPreferredSize(new Dimension(0,128));\n  innerTopPanel.add(debuggerChooserPanel,BorderLayout.SOUTH);\n  final JPanel buttonPanel=new JPanel(new GridLayout(1,2));\n  buttonPanel.setBorder(new EmptyBorder(0,0,5,2));\n  buttonPanel.add(new JPanel());\n  buttonPanel.add(m_saveButton);\n  topPanel.add(buttonPanel,BorderLayout.SOUTH);\n  final JPanel bottomPanel=new CAddressSpacesTablePanel(m_table);\n  final JScrollPane scrollPane=new JScrollPane(m_table);\n  bottomPanel.setBorder(m_titledBorder);\n  setBorder(new EmptyBorder(0,0,0,1));\n  bottomPanel.add(scrollPane);\n  final JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topPanel,bottomPanel);\n  splitPane.setOneTouchExpandable(true);\n  splitPane.setDividerLocation(splitPane.getMinimumDividerLocation());\n  splitPane.setResizeWeight(0.5);\n  add(splitPane);\n}\n", "docstring": "creates the elements of this component .", "partition": "test"}
{"idx": "1734", "code": "public SampleInfo(ByteBuffer bb) throws IOException {\n  numberOfChannels=bb.getInt();\n  sampleRate=bb.getInt();\n  coeffMin=bb.getFloat();\n  coeffRange=bb.getFloat();\n  postEmphasis=bb.getFloat();\n  residualFold=bb.getInt();\n}\n", "docstring": "constructs a sample info from the given byte buffer .", "partition": "test"}
{"idx": "856", "code": "public static boolean isJavaScriptEnabled(HttpServletRequest request){\n  HttpSession session=request.getSession();\n  Boolean javaScriptEnabled=(Boolean)session.getAttribute(\"javaScriptEnabled\");\n  if (javaScriptEnabled != null) {\n    return javaScriptEnabled.booleanValue();\n  }\n  return false;\n}\n", "docstring": "returns true if the user has javascript enabled .", "partition": "test"}
{"idx": "1966", "code": "public static String serializeDigestResponse(Map<String,String> paramMap){\n  StringBuilder sb=new StringBuilder(\"Digest \");\n  boolean prefixComma=false;\n  for (  Map.Entry<String,String> entry : paramMap.entrySet()) {\n    if (!prefixComma) {\n      prefixComma=true;\n    }\n else {\n      sb.append(\", \");\n    }\n    sb.append(entry.getKey());\n    sb.append(\"=\");\n    sb.append(entry.getValue());\n  }\n  return sb.toString();\n}\n", "docstring": "serialize a parameter map into a digest response . this is used as the \" authorization \" header in the request . all parameters in the supplied map will be added to the header .", "partition": "test"}
{"idx": "987", "code": "public static String[] decodeArray(String encodedArray){\n  String[] items=encodedArray.split(\"_\\\\\\\\.\");\n  ArrayList<String> list=new ArrayList<String>();\n  for (int i=0; i < items.length; i++) {\n    String item=items[i];\n    item=gsub(\"__\",\"_\",item);\n    if (!item.equals(\"\")) {\n      list.add(item);\n    }\n  }\n  return list.toArray(new String[list.size()]);\n}\n", "docstring": "decodes a string generated by encodearray .", "partition": "test"}
{"idx": "3381", "code": "@Category(FlakyTest.class) @Test public void test_FPAmetadataFetch(){\n  final Host host=Host.getHost(0);\n  VM server1=host.getVM(0);\n  VM server2=host.getVM(1);\n  VM server3=host.getVM(2);\n  VM server4=host.getVM(3);\n  Boolean simpleFPR=false;\n  final int portLocator=AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n  final String hostLocator=NetworkUtils.getServerHostName(server1.getHost());\n  final String locator=hostLocator + \"[\" + portLocator+ \"]\";\n  server3.invoke(null);\n  try {\n    List<FixedPartitionAttributes> fpaList=new ArrayList<FixedPartitionAttributes>();\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q1\",true,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q2\",false,3));\n    Integer port1=(Integer)server1.invoke(null);\n    fpaList.clear();\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q3\",true,3));\n    Integer port2=(Integer)server2.invoke(null);\n    fpaList.clear();\n    createClientWithLocator(hostLocator,portLocator);\n    putIntoPartitionedRegionsThreeQs();\n    getFromPartitionedRegionsFor3Qs();\n    Wait.pause(2000);\n    server1.invoke(null);\n    server2.invoke(null);\n    int totalBucketOnServer=0;\n    totalBucketOnServer+=(Integer)server1.invoke(null);\n    totalBucketOnServer+=(Integer)server2.invoke(null);\n    int currentRedundancy=1;\n    verifyMetadata(totalBucketOnServer,currentRedundancy);\n    updateIntoSinglePRFor3Qs();\n    fpaList.clear();\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q4\",true,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q2\",true,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q1\",false,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q3\",false,3));\n    Integer port4=(Integer)server4.invoke(null);\n    Wait.pause(2000);\n    putIntoPartitionedRegions();\n    getFromPartitionedRegions();\n    Wait.pause(2000);\n    server1.invoke(null);\n    server2.invoke(null);\n    server4.invoke(null);\n    totalBucketOnServer=0;\n    totalBucketOnServer+=(Integer)server1.invoke(null);\n    totalBucketOnServer+=(Integer)server2.invoke(null);\n    totalBucketOnServer+=(Integer)server4.invoke(null);\n    updateIntoSinglePR();\n  }\n  finally {\n    server3.invoke(null);\n  }\n}\n", "docstring": "this test will check to see if all the partitionattributes are sent to the client . in case one partition comes late , we should fetch that when there is a network hop because of that partitioned region . this test will create 3 servers with partition . do some operations on them . validate that the metadata are fetched and then later up one more partition and do some operations on them . it should fetch new fpa .", "partition": "test"}
{"idx": "2381", "code": "public DockNodeEventHandler(Node node){\n  this.node=node;\n}\n", "docstring": "creates a default dock node event handler that will help this dock pane track the current docking area .", "partition": "test"}
{"idx": "3574", "code": "public void displayChanged(){\n  executeDisplayChangedOnEDT(getGraphicsConfiguration());\n}\n", "docstring": "from the displaychangedlistener interface ; called from x11graphicsdevice when the display mode has been changed .", "partition": "test"}
{"idx": "1040", "code": "public static boolean isAttribute(Object objValue){\n  if (objValue instanceof String) {\n    String stringValue=(String)objValue;\n    if (stringValue.startsWith(ATTRIBUTE_START) && stringValue.endsWith(ATTRIBUTE_END)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if string is actually an attribute .", "partition": "test"}
{"idx": "1776", "code": "public static void renderFlattenedAnnotation(final PdfObject form,final DynamicVectorRenderer current,final int pageNumber,final int rotation){\n  final BufferedImage image=AnnotationFactory.getIcon(form);\n  if (image != null) {\n    final GraphicsState gs=new GraphicsState();\n    final int iconHeight=image.getHeight();\n    final int iconWidth=image.getWidth();\n    final float[] rect=form.getFloatArray(PdfDictionary.Rect);\n    if (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Text) {\n      rect[2]=rect[0] + iconWidth;\n      rect[1]=rect[3] - iconHeight;\n      form.setFloatArray(PdfDictionary.Rect,rect);\n    }\nswitch (rotation % 360) {\ncase 0:\n      gs.CTM=new float[][]{{iconWidth,0,1},{0,iconHeight,1},{0,0,0}};\n    gs.x=rect[0];\n  gs.y=rect[3] - iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] - iconHeight;\nbreak;\ncase 90:\ngs.CTM=new float[][]{{0,iconWidth,1},{-iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] + iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] + iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\ncase 180:\ngs.CTM=new float[][]{{-iconWidth,0,1},{0,-iconHeight,1},{0,0,0}};\ngs.x=rect[0];\ngs.y=rect[3] + iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] + iconHeight;\nbreak;\ncase 270:\ngs.CTM=new float[][]{{0,-iconWidth,1},{iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] - iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] - iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\n}\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Darken);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Darken);\n}\ncurrent.drawImage(pageNumber,image,gs,false,form.getObjectRefAsString(),-1);\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Normal);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Normal);\n}\n}\n}\n", "docstring": "method to create an icon to represent the annotation and render it .", "partition": "test"}
{"idx": "218", "code": "void onItemDismissed(final int position){\n  final T removed=mData.get(position);\n  final boolean wasRemoved=remove(position);\n  if (wasRemoved && mDataChangeListener != null) {\n    mDataChangeListener.onItemRemoved(removed,position);\n  }\n}\n", "docstring": "dismisses item from the given position .", "partition": "test"}
{"idx": "1093", "code": "public void ensureCapacity(int mincap){\n  if (mincap > array.length) {\n    int newcap=((array.length * 3) >> 1) + 1;\n    int[] olddata=array;\n    array=new int[newcap < mincap ? mincap : newcap];\n    System.arraycopy(olddata,0,array,0,size);\n  }\n}\n", "docstring": "increases the capacity of this arraylist instance , if necessary , to ensure that it can hold at least the number of elements specified by the minimum capacity argument .", "partition": "test"}
{"idx": "306", "code": "static long checkPreambleSize(Memory mem){\n  final long cap=mem.getCapacity();\n  if (cap < 8) {\n    throwNotBigEnough(cap,8);\n  }\n  final long pre0=mem.getLong(0);\n  final int preLongs=(int)(pre0 & 0X3FL);\n  final int required=Math.max(preLongs << 3,8);\n  if (cap < required) {\n    throwNotBigEnough(cap,required);\n  }\n  return pre0;\n}\n", "docstring": "checks memory for capacity to hold the preamble and returns the first 8 bytes .", "partition": "test"}
{"idx": "3718", "code": "public Object pack(){\n  if (collection) {\n    List l=(List)value;\n    if (Types.isArray(type)) {\n      Object[] o=(Object[])Array.newInstance(itemType,l.size());\n      l.toArray(o);\n      return o;\n    }\n  }\n  return value;\n}\n", "docstring": "based on accumulated value , produce a value for this property .", "partition": "test"}
{"idx": "3751", "code": "public ObjectName preRegister(MBeanServer server,ObjectName name) throws Exception {\n  setMBeanServer(server);\n  if (name == null) {\n    name=new ObjectName(server.getDefaultDomain() + \":\" + ServiceName.MLET);\n  }\n  this.mletObjectName=name;\n  return this.mletObjectName;\n}\n", "docstring": "allows the m - let to perform any operations it needs before being registered in the mbean server . if the objectname is null , the m - let provides a default name for its registration & lt ; defaultdomain & gt ; : type = mlet", "partition": "test"}
{"idx": "1064", "code": "protected void preAddInterruptibly(Object o) throws InterruptedException {\n}\n", "docstring": "called before the specified object is added to this queue .", "partition": "test"}
{"idx": "3218", "code": "public static double max(double[] data){\n  double max=Double.NaN;\n  for (int i=0; i < data.length; i++) {\n    if (Double.isNaN(data[i]))     continue;\n    if (Double.isNaN(max) || data[i] > max)     max=data[i];\n  }\n  return max;\n}\n", "docstring": "find the maximum of all elements in the array , ignoring elements that are nan .", "partition": "test"}
{"idx": "3774", "code": "private void drawArc(Canvas canvas){\n  if (mCurrentDashMode.equals(DASH_MODE.DOWNLOAD)) {\n    mnIndeterminateStartPosition+=(1 - mnProgress) * mnStartSpeed;\n    if ((mnIndeterminateStartPosition > CIRCULAR_FACTOR) || (mnIndeterminateStartPosition < 0)) {\n      mnIndeterminateStartPosition=0;\n    }\n    Rect currRect=new Rect();\n    getLocalVisibleRect(currRect);\n    float nRingBoundaryInner=mnRingRadius - (mnRingWidth / 2) - (mnArcWidth / 2);\n    mArcRect.set(mnViewCenter - nRingBoundaryInner,mnViewCenter - nRingBoundaryInner,mnViewCenter + nRingBoundaryInner,mnViewCenter + nRingBoundaryInner);\n    mPaint.setColor(mArcColor);\n    mPaint.setStyle(Paint.Style.STROKE);\n    mPaint.setStrokeWidth(mnArcWidth);\n    mPaint.setStrokeCap(Paint.Cap.ROUND);\n    canvas.drawArc(mArcRect,mnIndeterminateStartPosition,mnArcLength,false,mPaint);\n  }\n}\n", "docstring": "draw the arc around the ring only for the download mode", "partition": "test"}
{"idx": "4206", "code": "private void myAdd(LinkedList<Integer> l,int i){\n  l.add(i);\n}\n", "docstring": "for debugging purposes , it \"'\" s useful to insert print statements here .", "partition": "test"}
{"idx": "2064", "code": "static double computeDesiredEllipsoidMagnitude(final PlanetModel planetModel,final double x,final double y,final double z){\n  return 1.0 / Math.sqrt(x * x * planetModel.inverseAbSquared + y * y * planetModel.inverseAbSquared + z * z * planetModel.inverseCSquared);\n}\n", "docstring": "compute the desired magnitude of a unit vector projected to a given planet model .", "partition": "test"}
{"idx": "1373", "code": "private String replaceSuffix(String value,String toReplace,String changeTo){\n  String vvalue;\n  if ((value == null) || (toReplace == null) || (changeTo == null)) {\n    return value;\n  }\n  vvalue=removeSuffix(value,toReplace);\n  if (value.equals(vvalue)) {\n    return value;\n  }\n else {\n    return vvalue + changeTo;\n  }\n}\n", "docstring": "replace a string suffix by another", "partition": "test"}
{"idx": "370", "code": "private void insertUsedContextPrefixes(){\n  int unknownPrefixesCount=unknownPrefixesInXMLLiteral.size();\n  if (unknownPrefixesCount > 0) {\n    StringBuilder contextPrefixes=new StringBuilder(1024);\n    ElementInfo topElement=peekStack();\n    for (int i=0; i < unknownPrefixesCount; i++) {\n      String prefix=unknownPrefixesInXMLLiteral.get(i);\n      String namespace=topElement.getNamespace(prefix);\n      if (namespace != null) {\n        appendNamespaceDecl(contextPrefixes,prefix,namespace);\n      }\n    }\n    int endOfFirstStartTag=charBuf.indexOf(\">\");\n    charBuf.insert(endOfFirstStartTag,contextPrefixes.toString());\n  }\n  unknownPrefixesInXMLLiteral.clear();\n}\n", "docstring": "inserts prefix mappings from an xml literal \"'\" s context for all prefixes that are used in the xml literal and that are not defined in the xml literal itself .", "partition": "test"}
{"idx": "442", "code": "public static boolean isSnapshotFullCopySupported(URI blockSnapURI,DbClient dbClient){\n  BlockSnapshot blockObj=dbClient.queryObject(BlockSnapshot.class,blockSnapURI);\n  StorageSystem storage=dbClient.queryObject(StorageSystem.class,blockObj.getStorageController());\n  return (storage != null && (storage.deviceIsType(Type.openstack) || storage.deviceIsType(Type.vnxblock) || storage.deviceIsType(Type.ibmxiv)|| storage.deviceIsType(Type.vmax)));\n}\n", "docstring": "check if the storage system type is openstack , vnxblock , vmax or ibmxiv . snapshot full copy is supported only on these storage systems .", "partition": "test"}
{"idx": "2552", "code": "public void build(SolrCore core,SolrIndexSearcher searcher) throws IOException {\n  LOG.info(\"build()\");\n  dictionary=dictionaryFactory.create(core,searcher);\n  lookup.build(dictionary);\n  if (storeDir != null) {\n    File target=new File(storeDir,factory.storeFileName());\n    if (!lookup.store(new FileOutputStream(target))) {\n      LOG.error(\"Store Lookup build failed\");\n    }\n else {\n      LOG.info(\"Stored suggest data to: \" + target.getAbsolutePath());\n    }\n  }\n}\n", "docstring": "build the underlying lucene suggester", "partition": "test"}
{"idx": "1610", "code": "private void collectText(){\n  if (textNodeCount > 1) {\n    firstTextNode.setText(textBuffer.toString());\n  }\n  textNodeCount=0;\n}\n", "docstring": "this method breaks concatenation mode . as a side effect it copies the concatenated string to the first text node", "partition": "test"}
{"idx": "2623", "code": "public static synchronized void addPropertyChangeListener(PropertyChangeListener l){\n  if (!listeners.contains(l)) {\n    listeners.add(l);\n  }\n}\n", "docstring": "register for notification on changes to specific types", "partition": "test"}
{"idx": "3898", "code": "public Class<?> loadClass(String name) throws ClassNotFoundException {\n  return Class.forName(name);\n}\n", "docstring": "return the class with the given name .", "partition": "test"}
{"idx": "3889", "code": "final public void println(String v){\n  try {\n    _out.println(v);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "writes a string followed by a newline .", "partition": "test"}
{"idx": "4268", "code": "public String rightStr(String str,int length){\n  return str.substring(Math.max(0,str.length() - length));\n}\n", "docstring": "returns a substring of the given string , representing the \"'\" length \"'\" most - right characters", "partition": "test"}
{"idx": "3684", "code": "public void paintRect(Graphics g,JComponent c,int x,int y,int w,int h){\n  Rectangle bounds=c.getBounds();\n  check(bounds);\n  g.drawImage(m_backImage,x,y,x + w,h + y,x,y,x + w,y + h,c);\n}\n", "docstring": "paint / copy background to component rectangle", "partition": "test"}
{"idx": "3534", "code": "public void treeExpanded(TreeExpansionEvent event){\n  inspectorWindow.updateView(Director.ALL);\n}\n", "docstring": "called whenever an item in the tree has been expanded .", "partition": "test"}
{"idx": "1813", "code": "public static TestResult execJavac(String toCompile,File dir,String jflexTestVersion){\n  Project p=new Project();\n  Javac javac=new Javac();\n  Path path=new Path(p,dir.toString());\n  javac.setProject(p);\n  javac.setSrcdir(path);\n  javac.setDestdir(dir);\n  javac.setTarget(javaVersion);\n  javac.setSource(javaVersion);\n  javac.setSourcepath(new Path(p,\"\"));\n  javac.setIncludes(toCompile);\n  Path classPath=javac.createClasspath();\n  classPath.setPath(System.getProperty(\"user.home\") + \"/.m2/repository/de/jflex/jflex/\" + jflexTestVersion+ \"/jflex-\"+ jflexTestVersion+ \".jar\");\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  PrintStream outSafe=System.err;\n  System.setErr(new PrintStream(out));\n  try {\n    javac.execute();\n    return new TestResult(out.toString(),true);\n  }\n catch (  BuildException e) {\n    return new TestResult(e + System.getProperty(\"line.separator\") + out.toString(),false);\n  }\n finally {\n    System.setErr(outSafe);\n  }\n}\n", "docstring": "call javac on tocompile in input dir . if tocompile is null , all * . java files below dir will be compiled .", "partition": "test"}
{"idx": "3723", "code": "protected synchronized void write(long offset,byte[] b) throws IOException {\n  if (byteBuffer != null) {\n    byteBuffer.position((int)offset);\n    byteBuffer.put(b);\n  }\n else {\n    throw new IOException(\"Write failed, file \" + getPath() + \" not mapped for I/O\");\n  }\n}\n", "docstring": "writes bytes to the underlying rrd file on the disk", "partition": "test"}
{"idx": "3512", "code": "private void validateStoragePolicySelection(StoragePolicySelection storagePolicySelection){\n  Assert.notNull(storagePolicySelection,\"A storage policy selection must be specified.\");\n  businessObjectDataHelper.validateBusinessObjectDataKey(storagePolicySelection.getBusinessObjectDataKey(),true,true);\n  storagePolicyHelper.validateStoragePolicyKey(storagePolicySelection.getStoragePolicyKey());\n  Assert.notNull(storagePolicySelection.getStoragePolicyVersion(),\"A storage policy version must be specified.\");\n}\n", "docstring": "validates the storage policy selection . this method also trims the request parameters .", "partition": "test"}
{"idx": "4196", "code": "public PathHandler(String path){\n  this(Paths.get(path));\n}\n", "docstring": "convenience method to create a path . calls init ( ) automatically .", "partition": "test"}
{"idx": "110", "code": "protected void processConnectionEvent(ConnectionEvent event){\n  for (Enumeration<ConnectionListener> e=connectionListeners.elements(); e.hasMoreElements(); ) {\n    ConnectionListener l=e.nextElement();\nswitch (event.getType()) {\ncase ConnectionEvent.CONNECTED:\n      l.connected((ConnectedEvent)event);\n    break;\ncase ConnectionEvent.DISCONNECTED:\n  l.disconnected((DisconnectedEvent)event);\nbreak;\ncase ConnectionEvent.PACKET_RECEIVED:\nl.packetReceived((PacketReceivedEvent)event);\nbreak;\n}\n}\n}\n", "docstring": "processes game events occurring on this connection by dispatching them to any registered gamelistener objects .", "partition": "test"}
{"idx": "1562", "code": "protected void writeLocation(String loc) throws IOException {\n  hadAnnotations|=(loc != null);\n  locOut.writeObject(loc);\n}\n", "docstring": "overrides marshaloutputstream . writelocation implementation to write annotations to the location stream .", "partition": "test"}
{"idx": "4246", "code": "public static void resetContext(){\n  contexts.set(null);\n}\n", "docstring": "resets the current context", "partition": "test"}
{"idx": "2760", "code": "private static int loadBuildNumber(Context context,PackageManager packageManager){\n  try {\n    ApplicationInfo appInfo=packageManager.getApplicationInfo(context.getPackageName(),PackageManager.GET_META_DATA);\n    Bundle metaData=appInfo.metaData;\n    if (metaData != null) {\n      return metaData.getInt(BUNDLE_BUILD_NUMBER,0);\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    L.e(\"Exception thrown when accessing the application info:\");\n    e.printStackTrace();\n  }\n  return 0;\n}\n", "docstring": "helper method to load the build number from the androidmanifest .", "partition": "test"}
{"idx": "2429", "code": "public void clear(){\n  m_Model.clear();\n  setButtons(null);\n}\n", "docstring": "clears the content of the panel", "partition": "test"}
{"idx": "1353", "code": "public static boolean createNewFile(File targetFile){\n  if (targetFile.exists())   targetFile.delete();\n  try {\n    return targetFile.createNewFile();\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n", "docstring": "create a new file , if the file exists , delete and create again .", "partition": "test"}
{"idx": "2723", "code": "protected void addFieldNameTranslation(EmbeddableMapping embeddableMapping,String overrideName,DatabaseField overrideField,MappingAccessor aggregatesAccessor){\n  DatabaseMapping aggregatesMapping=aggregatesAccessor.getMapping();\n  DatabaseField aggregatesMappingField=aggregatesMapping.getField();\n  if (aggregatesAccessor.isId()) {\n    updatePrimaryKeyField(aggregatesAccessor,overrideField);\n  }\n  if (overrideName.contains(\".\")) {\n    embeddableMapping.addNestedFieldTranslation(overrideName,overrideField,aggregatesMappingField.getName());\n  }\n else {\n    embeddableMapping.addFieldTranslation(overrideField,aggregatesMappingField.getName());\n  }\n}\n", "docstring": "internal : process an attribute override for either an embedded object mapping , or an element collection mapping containing embeddable objects .", "partition": "test"}
{"idx": "1084", "code": "private void populateNavDrawer(){\n  mNavDrawerItems.clear();\n  mNavDrawerItems.add(NAVDRAWER_ITEM_HOME);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SEPARATOR);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_FOLLOWING);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_SHOTS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_BUCKETS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_PROJECTS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_TEAMS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_LIKES);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SEPARATOR_SPECIAL);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SETTINGS);\n  createNavDrawerItems();\n}\n", "docstring": "populates the navigation drawer with the appropriate items .", "partition": "test"}
{"idx": "3454", "code": "public void deletePoint(int position){\n  int renderType=poly.getRenderType();\n  Projection proj=getProjection();\n  boolean needToHookUp=false;\n  if (position <= 0 && isEnclosed()) {\n    enclose(false);\n    needToHookUp=true;\n  }\n  if (renderType == OMGraphic.RENDERTYPE_LATLON) {\n    Debug.message(\"eomg\",\"EditableOMPoly: removing point from lat/lon poly\");\n    if (proj != null) {\n      double[] ll=poly.getLatLonArray();\n      double[] newll=new double[ll.length - 2];\n      int actualPosition=(position == Integer.MAX_VALUE ? ll.length : position * 2);\n      if (actualPosition >= ll.length) {\n        System.arraycopy(ll,0,newll,0,ll.length - 2);\n        position=(ll.length - 2) / 2;\n      }\n else       if (actualPosition <= 0) {\n        System.arraycopy(ll,2,newll,0,ll.length - 2);\n        position=0;\n      }\n else {\n        System.arraycopy(ll,0,newll,0,actualPosition);\n        System.arraycopy(ll,actualPosition + 2,newll,actualPosition,ll.length - actualPosition - 2);\n      }\n      poly.setLocation(newll,poly.getUnits());\n    }\n  }\n else {\n    Debug.message(\"eomg\",\"EditableOMPoly: removing point from x/y or offset poly\");\n    int currentLength=poly.xs.length;\n    int[] newxs=new int[currentLength - 1];\n    int[] newys=new int[currentLength - 1];\n    if (position >= currentLength) {\n      System.arraycopy(poly.xs,0,newxs,0,currentLength - 1);\n      System.arraycopy(poly.ys,0,newys,0,currentLength - 1);\n      position=currentLength - 1;\n    }\n else     if (position <= 0) {\n      System.arraycopy(poly.xs,1,newxs,0,currentLength - 1);\n      System.arraycopy(poly.ys,1,newys,0,currentLength - 1);\n      position=0;\n    }\n else {\n      System.arraycopy(poly.xs,0,newxs,0,position);\n      System.arraycopy(poly.xs,position + 1,newxs,position,currentLength - position - 1);\n      System.arraycopy(poly.ys,0,newys,0,position);\n      System.arraycopy(poly.ys,position + 1,newys,position,currentLength - position - 1);\n    }\n    if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n      poly.setLocation(poly.lat,poly.lon,poly.getUnits(),newxs,newys);\n    }\n else {\n      poly.setLocation(newxs,newys);\n    }\n  }\n  if (proj != null) {\n    poly.regenerate(proj);\n  }\n  GrabPoint gp=(GrabPoint)polyGrabPoints.remove(position);\n  if (gpo != null && gp != null) {\n    gpo.removeGrabPoint(gp);\n  }\n  if (needToHookUp) {\n    enclose(true);\n  }\n}\n", "docstring": "delete a point at a certain point in the polygon coordinate list . if the position is less than zero , the deleted point will be the starting point . if the position is greater than the list of current points , the point will be deleted from the end of the poly .", "partition": "test"}
{"idx": "3465", "code": "protected void initStreamBufferSize(){\n  String streamBufferSizeParam=getInitParameter(\"streamBufferSize\");\n  setStreamBufferSize((streamBufferSizeParam == null) ? DEFAULT_STREAM_BUFFER_SIZE : Integer.parseInt(streamBufferSizeParam));\n  if (isDebug()) {\n    log(\"streamBufferSize: \" + getStreamBufferSize());\n  }\n}\n", "docstring": "initializer for property streambuffersize .", "partition": "test"}
{"idx": "2682", "code": "@Nullable private static Bitmap extractThumbnail(Bitmap source,int width,int height){\n  return extractThumbnail(source,width,height,OPTIONS_NONE);\n}\n", "docstring": "creates a centered bitmap of the desired size .", "partition": "test"}
{"idx": "2497", "code": "public PdfPage addAnnotation(PdfAnnotation annotation){\n  return addAnnotation(-1,annotation,true);\n}\n", "docstring": "adds specified annotation to the end of annotations array and tagged it . may be used in chain .", "partition": "test"}
{"idx": "2180", "code": "public void write(final int b) throws IOException {\n  if (m_store == null) {\n    throw new IllegalStateException(ERR_NO_STORE);\n  }\n  if (m_isSaved) {\n    throw new IllegalStateException(ERR_ALREADY_SAVED);\n  }\n  if (m_count == m_blobThreshold && !m_writingHdr) {\n    if (m_blobHeader == null) {\n      m_blobHeader=new ArrayList<Integer>();\n    }\n    final int curAddr=(int)m_store.alloc(m_buf,m_count,m_context);\n    m_blobHeader.add(curAddr);\n    m_count=0;\n  }\n  m_buf[m_count++]=(byte)b;\n  m_bytesWritten++;\n}\n", "docstring": "write a single byte this is the one place where the blob threshold is handled and its done one byte at a time so should be easy enough , we no longer store continuation addresses , instead we allocate blob allocations via a blob header block .", "partition": "test"}
{"idx": "1497", "code": "@Deprecated public static String Collection2String(Collection<?> in,String separator){\n  if (in == null) {\n    return null;\n  }\n  return Iterator2String(in.iterator(),separator);\n}\n", "docstring": "this concatenates the elements of a collection in a string", "partition": "test"}
{"idx": "854", "code": "public EncoderTestSuiteBuilder valid(int min,int max){\n  _valid.set(min,max + 1);\n  _invalid.clear(min,max + 1);\n  _encoded.clear(min,max + 1);\n  return this;\n}\n", "docstring": "tells the builder that a range of code - points is valid .", "partition": "test"}
{"idx": "4067", "code": "public static void addStartupListener(StartUpListener s){\n  m_StartupListeners.add(s);\n}\n", "docstring": "add a listener to be notified when startup is complete .", "partition": "test"}
{"idx": "722", "code": "public void init() throws Exception {\n  loadParameterFromZK();\n  _invalidLoginCleanupExecutor.scheduleWithFixedDelay(new InvalidLoginCleaner(),CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS,CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS,TimeUnit.MINUTES);\n  _log.info(\"Max invalid login attempts from the same client IP: {}\",_maxAuthnLoginAttemtsCount);\n  _log.info(\"Life time in minutes of invalid login records for a client IP: {}\",_maxAuthnLoginAttemtsLifeTimeInMins);\n  _log.info(\"Cleanup thread schedule interval: {} minutes\",CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS);\n}\n", "docstring": "initialize the background task to be run every hour . at each run that task will walk through the invalid login records and clean all expired records .", "partition": "test"}
{"idx": "2458", "code": "protected Expression findExpression(String source){\n  if (source != null && source.length() > 0) {\n    source=source.trim();\n    if (source.length() == 0) {\n      return null;\n    }\n    String leftSide=source;\n    String rightSide=null;\n    Connector op=findOp(leftSide);\n    if (op != null) {\n      rightSide=op.getRightSide(leftSide);\n      leftSide=leftSide.substring(0,op.sourceLoc);\n      Expression leftExpression=findExpression(leftSide);\n      Expression rightExpression=findExpression(rightSide);\n      if (leftExpression != null) {\n        op.addExpr(leftExpression);\n      }\n      if (rightExpression != null) {\n        op.addExpr(rightExpression);\n      }\n      return op;\n    }\n    op=findMiniOp(leftSide);\n    if (op != null) {\n      rightSide=op.getRightSide(leftSide);\n      leftSide=leftSide.substring(0,op.sourceLoc);\n      Expression leftExpression=findExpression(leftSide);\n      Expression rightExpression=findExpression(rightSide);\n      if (leftExpression != null) {\n        op.addExpr(leftExpression);\n      }\n      if (rightExpression != null) {\n        op.addExpr(rightExpression);\n      }\n      return op;\n    }\n    if (logger.isLoggable(Level.FINER)) {\n      logger.finer(\"need to break up: \" + source);\n    }\n    return findMathOp(source);\n  }\n  return null;\n}\n", "docstring": "recursive parsing statement . keys on connectors ( and , or ) and builds expressions based on those . then looks for mini connectors ( and , or ) and builds on those . of course , there might just be one expression here , one that is separated by an operator .", "partition": "test"}
{"idx": "280", "code": "public void freeObject(int id){\n  if (cacheId == id) {\n    cacheId=-1;\n    cache=null;\n  }\n  map.remove(id);\n}\n", "docstring": "remove an object from the map .", "partition": "test"}
{"idx": "876", "code": "@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"FE_FLOATING_POINT_EQUALITY\",justification=\"equality is specifically \\'Unchanged\\' here\") public void changeLocoSpeed(DccThrottle t,Block blk,float speed){\n  if (blk == referenced && speed == desiredSpeedStep) {\n    return;\n  }\n  float blockLength=blk.getLengthMm();\n  if (blk == referenced) {\n    distanceRemaining=distanceRemaining - getDistanceTravelled(_throttle.getIsForward(),_throttle.getSpeedSetting(),((float)(System.nanoTime() - lastTimeTimerStarted) / 1000000000));\n    blockLength=distanceRemaining;\n    log.debug(\"Block passed is the same as we are currently processing\");\n  }\n else {\n    referenced=blk;\n  }\n  changeLocoSpeed(t,blockLength,speed);\n}\n", "docstring": "set speed of a throttle to a speeed set by a float , using the block for the length details", "partition": "test"}
{"idx": "2184", "code": "@AfterMethod public void tearDown() throws Exception {\n  Throwable t=threadFailure.getAndSet(null);\n  if (t != null) {\n    if (t instanceof Error)     throw (Error)t;\n else     if (t instanceof RuntimeException)     throw (RuntimeException)t;\n else     if (t instanceof Exception)     throw (Exception)t;\n else {\n      AssertionFailedError afe=new AssertionFailedError(t.toString());\n      afe.initCause(t);\n      throw afe;\n    }\n  }\n  if (Thread.interrupted())   tearDownFail(\"interrupt status set in main thread\");\n  checkForkJoinPoolThreadLeaks();\n}\n", "docstring": "extra checks that get done for all test cases . triggers test case failure if any thread assertions have failed , by rethrowing , in the test harness thread , any exception recorded earlier by threadrecordfailure . triggers test case failure if interrupt status is set in the main thread .", "partition": "test"}
{"idx": "2644", "code": "private Token toASIToken(ILeafNode leaf){\n  if (leaf.isHidden()) {\n    return newSemicolonToken(leaf);\n  }\n else {\n    if (!leafNodes.hasNext()) {\n      int tokenType=tokenTypeMapper.getInternalTokenType(leaf);\n      int semicolonTokenType=tokenTypeMapper.getInternalTokenType(semicolon);\n      if (tokenType == semicolonTokenType) {\n        return new CommonToken(semicolonTokenType,leaf.getText());\n      }\n      if (leaf.getTotalEndOffset() == endOffset) {\n        leafNodes=Iterators.emptyIterator();\n        return new CommonToken(tokenType,leaf.getText());\n      }\n      next=new CommonToken(semicolonTokenType,leaf.getText());\n      return new CommonToken(tokenType,leaf.getText());\n    }\n else     if (leaf.getGrammarElement() == rightCurlyInBlock || leaf.getGrammarElement() == rightCurlyInArrowExpression) {\n      int tokenType=tokenTypeMapper.getInternalTokenType(leaf);\n      next=new CommonToken(tokenType);\n      return new CommonToken(tokenTypeMapper.getInternalTokenType(semicolon),leaf.getText());\n    }\n else {\n      return newSemicolonToken(leaf);\n    }\n  }\n}\n", "docstring": "produces either one or two tokens from the given leaf which represents a location where the production parser inserted a semicolon .", "partition": "test"}
{"idx": "1650", "code": "private <T>BindingAmp<T> findObjectBinding(Key<T> key){\n  Objects.requireNonNull(key);\n  if (key.qualifiers().length != 1) {\n    throw new IllegalArgumentException();\n  }\n  return (BindingAmp)findBinding(Key.of(Object.class,key.qualifiers()[0]));\n}\n", "docstring": "returns an object producer .", "partition": "test"}
{"idx": "1296", "code": "public List<Map<String,String>> list(Database conn) throws SQLException {\n  ResultSet rs=null;\n  Statement statement=conn.createStatement();\n  List<Map<String,String>> shardToChannels=new ArrayList<Map<String,String>>();\n  try {\n    rs=statement.executeQuery(select);\n    while (rs.next()) {\n      Map<String,String> shard=new HashMap<String,String>();\n      shard.put(ShardChannelTable.SHARD_ID_COL,rs.getString(ShardChannelTable.SHARD_ID_COL));\n      shard.put(ShardChannelTable.CHANNEL_COL,rs.getString(ShardChannelTable.CHANNEL_COL));\n      shardToChannels.add(shard);\n    }\n  }\n  finally {\n    close(rs);\n    close(statement);\n  }\n  return shardToChannels;\n}\n", "docstring": "return a list of currently known shard / channel assignments .", "partition": "test"}
{"idx": "3261", "code": "public NarClassLoader(final File narWorkingDirectory) throws ClassNotFoundException, IOException {\n  super(new URL[0]);\n  this.narWorkingDirectory=narWorkingDirectory;\n  updateClasspath(narWorkingDirectory);\n}\n", "docstring": "construct a nar class loader .", "partition": "test"}
{"idx": "3174", "code": "public static int[][] deep_copy(int M[][]){\n  int[][] C=new int[M.length][];\n  for (int i=0; i < C.length; i++) {\n    C[i]=Arrays.copyOf(M[i],M[i].length);\n  }\n  return C;\n}\n", "docstring": "deep copy - make a deep copy of m [ ", "partition": "test"}
{"idx": "1420", "code": "public void enableOverview(boolean b){\n  if (overviewItem != null) {\n    overviewItem.setEnabled(b);\n  }\n}\n", "docstring": "enable / disable the overview menu .", "partition": "test"}
{"idx": "1274", "code": "public Shape createCheckMark(final int x,final int y,final int w,final int h){\n  double xf=w / 12.0;\n  double hf=h / 12.0;\n  path.reset();\n  path.moveTo(x,y + 7.0 * hf);\n  path.lineTo(x + 2.0 * xf,y + 7.0 * hf);\n  path.lineTo(x + 4.75 * xf,y + 10.0 * hf);\n  path.lineTo(x + 9.0 * xf,y);\n  path.lineTo(x + 11.0 * xf,y);\n  path.lineTo(x + 5.0 * xf,y + 12.0 * hf);\n  path.closePath();\n  return path;\n}\n", "docstring": "return a path for a check mark .", "partition": "test"}
{"idx": "1367", "code": "public boolean hasStatus(final StatusID status){\n  return statuses.contains(status);\n}\n", "docstring": "check if the entity has a certain status .", "partition": "test"}
{"idx": "2590", "code": "public boolean looksLikeNumberComing(){\n  if (n >= s.length())   return false;\n  return Character.isDigit(s.charAt(n));\n}\n", "docstring": "peeks the next char , without gobbling it . tells us if it \"'\" s a digit or not .", "partition": "test"}
{"idx": "4185", "code": "protected void clearResult(){\n  md.clearResult();\n  localizationResult.setText(\"<HTML>Result: <BR><BR><BR></HTML>\");\n}\n", "docstring": "clears the result that may has been set .", "partition": "test"}
{"idx": "3679", "code": "public ThreadRegisterValues(final ThreadRegisters values){\n  m_tid=values.getTid();\n  for (  final RegisterValue value : values.getRegisters()) {\n    m_values.add(new Register(value));\n  }\n}\n", "docstring": "creates a new thread register values object .", "partition": "test"}
{"idx": "2128", "code": "public void CONT(int sessionNumber) throws Exception {\n  this.maxSessionNumber=Math.max(this.maxSessionNumber,sessionNumber);\n  testElements.add(new ContinuationElement(sessionNumber));\n}\n", "docstring": "adds a continuation . to allow one thread to be used for testing .", "partition": "test"}
{"idx": "712", "code": "private boolean tryQueueCurrentBuffer(long elapsedWaiting){\n  if (currentBuffer.isEmpty())   return true;\n  if (isOpen && neverPubQueue.size() < neverPubCapacity) {\n    neverPubQueue.add(currentBuffer);\n    totalQueuedRecords.addAndGet(currentBuffer.sizeRecords());\n    totalQueuedBuffers.incrementAndGet();\n    onQueueBufferSuccess(currentBuffer,elapsedWaiting);\n    currentBuffer=new RecordBuffer<>(flow);\n    return true;\n  }\n else   if (elapsedWaiting > 0) {\n    onQueueBufferTimeout(currentBuffer,elapsedWaiting);\n    return false;\n  }\n else   return false;\n}\n", "docstring": "keep private . call only when holding lock .", "partition": "test"}
{"idx": "2159", "code": "public void addDefinition(ICOSDefinition cosDef) throws UMSException {\n  if (!(cosDef instanceof DirectCOSDefinition)) {\n    String msg=i18n.getString(IUMSConstants.INVALID_COSDEFINITION);\n    throw new UMSException(msg);\n  }\n  String[] cosAttributes=cosDef.getCOSAttributes();\n  AbstractCollection aList=(AbstractCollection)Arrays.asList(ICOSDefinition.qualifiers);\n  for (int i=0; i < cosAttributes.length; i++) {\n    String cosAttribute=null;\n    String qualifier=null;\n    StringTokenizer st=new StringTokenizer(cosAttributes[i]);\n    if (st.hasMoreTokens()) {\n      cosAttribute=st.nextToken();\n    }\n    if (cosAttribute == null) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n    if (st.hasMoreTokens())     qualifier=st.nextToken();\n    if (qualifier == null) {\n      qualifier=ICOSDefinition.qualifiers[ICOSDefinition.DEFAULT];\n      cosDef.removeCOSAttribute(cosAttribute);\n      cosDef.addCOSAttribute(cosAttribute,ICOSDefinition.DEFAULT);\n    }\n    if (!aList.contains(qualifier)) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n  }\n  PersistentObject po=(PersistentObject)cosDef;\n  _parentObject.addChild(po);\n}\n", "docstring": "this method adds a cos definition to the persistent store . the definition is added under the specified \" guid \" parameter .", "partition": "test"}
{"idx": "3811", "code": "public Builder deleteDisplayName(){\n  deleteFields.add(\"displayName\");\n  return this;\n}\n", "docstring": "deletes the display name of a existing user", "partition": "test"}
{"idx": "935", "code": "@Override public void addValue(double value,double weight){\n  m_WeightedSum+=value * weight;\n  m_WeightedSumSquared+=value * value * weight;\n  m_SumOfWeights+=weight;\n  if (m_TM.get(value) == null) {\n    m_TM.put(value,weight);\n  }\n else {\n    m_TM.put(value,m_TM.get(value) + weight);\n  }\n}\n", "docstring": "adds a value to the density estimator .", "partition": "test"}
{"idx": "900", "code": "public boolean controlRunTrain(int idx){\n  if (log.isDebugEnabled()) {\n    log.debug(\"controlRunTrain= \" + idx + \" runMode= \"+ _runMode+ \" - warrant= \"+ getDisplayName());\n  }\n  boolean ret=true;\n  int oldIndex=-MODE_MANUAL;\n  if (_engineer == null) {\nswitch (idx) {\ncase HALT:\ncase RESUME:\ncase RETRY:\n      ret=false;\n    break;\ncase ABORT:\n  if (_runMode == Warrant.MODE_LEARN) {\n    firePropertyChange(\"abortLearn\",Integer.valueOf(-MODE_LEARN),Integer.valueOf(_idxCurrentOrder));\n  }\n else {\n    stopWarrant(true);\n  }\nbreak;\n}\n}\n else {\nsynchronized (_engineer) {\noldIndex=_engineer.getRunState();\nswitch (idx) {\ncase HALT:\n_engineer.setHalt(true);\nbreak;\ncase RESUME:\n_engineer.setHalt(false);\nrestart();\nret=moveIntoNextBlock(MID);\nbreak;\ncase RETRY:\nBlockOrder bo=getBlockOrderAt(_idxCurrentOrder + 1);\nret=false;\nif (bo != null) {\nOBlock b=bo.getBlock();\nif (b.allocate(this) == null && (b.getState() & OBlock.OCCUPIED) != 0) {\n_idxCurrentOrder++;\nif (b.equals(_stoppingBlock)) {\n_stoppingBlock.removePropertyChangeListener(this);\n_stoppingBlock=null;\n}\nbo.setPath(this);\nrestart();\ngoingActive(b);\nret=true;\n}\n}\nbreak;\ncase ABORT:\nstopWarrant(true);\nbreak;\n}\n}\n}\nif (ret) {\nfirePropertyChange(\"controlChange\",Integer.valueOf(oldIndex),Integer.valueOf(idx));\n}\nreturn ret;\n}\n", "docstring": "pause and resume auto - running train or abort any allocation state _engineer . abort ( ) calls setrunmode ( mode_none , . . . ) which calls deallocate all .", "partition": "test"}
{"idx": "3933", "code": "private void release(ByteArray byteArray){\nsynchronized (syncRoot) {\n    if (availableByteArrays.size() >= maxAvailableArraysCount) {\n      return;\n    }\n    if (!availableByteArrays.contains(byteArray)) {\n      availableByteArrays.add(byteArray);\n    }\n  }\n}\n", "docstring": "releases specified byte array", "partition": "test"}
{"idx": "3621", "code": "public StorageEntity createStorageEntity(String storageName,StoragePlatformEntity storagePlatformEntity,List<Attribute> attributes){\n  StorageEntity storageEntity=new StorageEntity();\n  storageEntity.setName(storageName);\n  storageEntity.setStoragePlatform(storagePlatformEntity);\n  if (!CollectionUtils.isEmpty(attributes)) {\n    List<StorageAttributeEntity> attributeEntities=new ArrayList<>();\n    storageEntity.setAttributes(attributeEntities);\n    for (    Attribute attribute : attributes) {\n      StorageAttributeEntity attributeEntity=new StorageAttributeEntity();\n      attributeEntities.add(attributeEntity);\n      attributeEntity.setStorage(storageEntity);\n      attributeEntity.setName(attribute.getName());\n      attributeEntity.setValue(attribute.getValue());\n    }\n  }\n  return storageDao.saveAndRefresh(storageEntity);\n}\n", "docstring": "creates and persists a new storage entity .", "partition": "test"}
{"idx": "109", "code": "public static void checkValid(double[] x){\n  for (  double v : x) {\n    if (Double.isNaN(v)) {\n      throw new RuntimeException(\"Invalid entry \" + v);\n    }\n  }\n}\n", "docstring": "loop and ensure all elements are non - infiite and non - nan , throws an exception if one is", "partition": "test"}
{"idx": "4159", "code": "public static boolean doCacheHeaderValidation(final SolrQueryRequest solrReq,final HttpServletRequest req,final Method reqMethod,final HttpServletResponse resp){\n  if (Method.POST == reqMethod || Method.OTHER == reqMethod) {\n    return false;\n  }\n  final long lastMod=HttpCacheHeaderUtil.calcLastModified(solrReq);\n  final String etag=HttpCacheHeaderUtil.calcEtag(solrReq);\n  resp.setDateHeader(\"Last-Modified\",lastMod);\n  resp.setHeader(\"ETag\",etag);\n  if (checkETagValidators(req,resp,reqMethod,etag)) {\n    return true;\n  }\n  if (checkLastModValidators(req,resp,lastMod)) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "sets http response cache validator headers appropriately and validates the http request against these using any conditional request headers . if the request contains conditional headers , and those headers indicate a match with the current known state of the system , this method will return \" true \" indicating that a 304 status code can be returned , and no further processing is needed .", "partition": "test"}
{"idx": "2606", "code": "public static ObjectOutputStream newObjectOutputStream(Path self) throws IOException {\n  return new ObjectOutputStream(Files.newOutputStream(self));\n}\n", "docstring": "create an object output stream for this path .", "partition": "test"}
{"idx": "184", "code": "public byte[] encode1(final String s){\n  final ByteArrayBuffer tmp=new ByteArrayBuffer(s.length());\n  final int nwritten=uc.encode(s,tmp);\n  final int npack=LongPacker.getByteLength(nwritten);\n  final byte[] a=new byte[npack + nwritten];\n  final DataOutputBuffer dob=new DataOutputBuffer(0,a);\n  try {\n    dob.packLong(nwritten);\n    dob.append(tmp.array(),0,tmp.pos());\n    return a;\n  }\n  finally {\n    try {\n      dob.close();\n    }\n catch (    IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "docstring": "encode a unicode string .", "partition": "test"}
{"idx": "3943", "code": "public static byte[] readData(final URL url) throws IOException {\n  try (InputStream input=url.openStream()){\n    return readData(input);\n  }\n }\n", "docstring": "reads all the data from the supplied url into a byte array .", "partition": "test"}
{"idx": "3558", "code": "protected void addHeaders(HttpURLConnection connection,String tenantId){\n  if (tenantId == null) {\n    tenantId=PropertyUtil.getProperty(PropertyUtil.HAWKULAR_TENANT);\n  }\n  if (tenantId != null) {\n    connection.setRequestProperty(HAWKULAR_TENANT,tenantId);\n  }\n  if (authorization == null && username != null) {\n    String authString=username + \":\" + password;\n    String encoded=encoder.encodeToString(authString.getBytes());\n    authorization=\"Basic \" + encoded;\n  }\n  if (authorization != null) {\n    connection.setRequestProperty(\"Authorization\",authorization);\n  }\n}\n", "docstring": "add the header values to the supplied connection .", "partition": "test"}
{"idx": "1345", "code": "public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  submitCycle=true;\n  EntitiesModel model=(EntitiesModel)getModel();\n  AMPropertySheet prop=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n  String universalId=(String)getPageSessionAttribute(UNIVERSAL_ID);\n  try {\n    Map oldValues=model.getAttributeValues(universalId,false);\n    Map values=prop.getAttributeValues(oldValues,true,model);\n    String curRealm=(String)getPageSessionAttribute(AMAdminConstants.CURRENT_REALM);\n    model.modifyEntity(curRealm,universalId,values);\n    setInlineAlertMessage(CCAlert.TYPE_INFO,\"message.information\",\"message.updated\");\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n  forwardTo();\n}\n", "docstring": "handles create realm request .", "partition": "test"}
{"idx": "1933", "code": "private void updatePodcastPublicationDateAndLastMediaUrl(Episode episode,Podcast podcast){\n  Date podcastPublicationDate=podcast.getPublicationDate();\n  boolean episodePubDateIsMoreRecent=episode.getPublicationDate() != null && (podcastPublicationDate == null || podcastPublicationDate.before(episode.getPublicationDate()));\n  if (episodePubDateIsMoreRecent) {\n    podcast.setPublicationDate(episode.getPublicationDate());\n    podcast.setLastEpisodeMediaUrl(episode.getMediaUrl());\n  }\n}\n", "docstring": "set the podcast \"'\" s publication date to the episode \"'\" s if it is more recent", "partition": "test"}
{"idx": "3721", "code": "@SuppressLint(\"NewApi\") @Nullable public static Drawable inflate(boolean forceSystemHandlingWhenPossible,@NonNull Resources resources,@DrawableRes int id){\n  boolean systemHandling=isSystemHandling(forceSystemHandlingWhenPossible);\n  Log.d(LOG_TAG,String.format(\"Inflating resource with id #0x%s (system handling: %s)\",Integer.toHexString(id),systemHandling));\n  if (systemHandling) {\n    return resources.getDrawable(id,null);\n  }\n  try {\n    return VectorDrawable.create(resources,id);\n  }\n catch (  Resources.NotFoundException e) {\n    return null;\n  }\n}\n", "docstring": "inflate a drawable from a vector xml resource .", "partition": "test"}
{"idx": "605", "code": "public List<GenericEntry> retrieveAllAccountInfoRequests(Date fromDate) throws AppsForYourDomainException, IOException, ServiceException {\n  String url=BASE_URL + \"account/\" + domain;\n  if (fromDate != null) {\n    url+=\"?fromDate=\" + DATE_FORMAT.format(fromDate);\n  }\n  return getAllPages(new URL(url),GenericFeed.class);\n}\n", "docstring": "retrieve all the account info requests from the given start date .", "partition": "test"}
{"idx": "4184", "code": "public boolean retainAll(AbstractFloatList other){\n  if (other.size() == 0) {\n    if (size == 0)     return false;\n    setSize(0);\n    return true;\n  }\n  int limit=other.size() - 1;\n  int j=0;\n  for (int i=0; i < size; i++) {\n    if (other.indexOfFromTo(getQuick(i),0,limit) >= 0)     setQuick(j++,getQuick(i));\n  }\n  boolean modified=(j != size);\n  setSize(j);\n  return modified;\n}\n", "docstring": "retains ( keeps ) only the elements in the receiver that are contained in the specified other list . in other words , removes from the receiver all of its elements that are not contained in the specified other list .", "partition": "test"}
{"idx": "464", "code": "EdgeMap<Block> findLoops(Deque<Block> code,Map<Block,Block> idom,SetMap<Block,Edge> pred){\n  EdgeMap<Block> loops=new EdgeMap<Block>();\n  for (  Block b : code)   for (  Edge s : b.succ())   if (isLoop(s,idom)) {\n    verboseStatus(\"backedge \" + s);\n    Block h=s.to;\n    Set<Block> loop=loops.get(h);\n    Set<Block> work=new TreeSet<Block>();\n    for (    Edge p : pred.get(h)) {\n      if (isLoop(p,idom) && !loop.contains(p.from) && p.from != h) {\n        loop.add(p.from);\n        work.add(p.from);\n      }\n    }\n    while (!work.isEmpty()) {\n      Block x=getBlock(work);\n      for (      Edge p : pred.get(x)) {\n        if (p.from != h && !loop.contains(p.from)) {\n          loop.add(p.from);\n          work.add(p.from);\n        }\n      }\n    }\n  }\n  return loops;\n}\n", "docstring": "loop code layout the loop is defined by the back edge from t - > h . h ( header ) is the source of the back edge . we want h at the bottom of the loop and t at the top . lay the blocks out in dfs order starting with t and skipping any blocks that aren \"'\" t part of the loop . prefer to have fall - through blocks that are part of the loop .", "partition": "test"}
{"idx": "1269", "code": "public void saveBootProp() throws IOException {\n  if (!bootProp.equals(bootPropOrg)) {\n    final String propFile=jarFolder + \"jar.properties\";\n    final OutputStream os=new FileOutputStream(propFile);\n    try {\n      bootProp.store(os,\"Stendhal Boot Configuration\");\n    }\n  finally {\n      os.close();\n    }\n  }\n}\n", "docstring": "saves modified boot properties to disk .", "partition": "test"}
{"idx": "2335", "code": "public PickingGraphMousePlugin(int selectionModifiers,int addToSelectionModifiers){\n  super(selectionModifiers);\n  this.addToSelectionModifiers=addToSelectionModifiers;\n  this.lensPaintable=new LensPaintable();\n  this.cursor=Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);\n}\n", "docstring": "create an instance with overides", "partition": "test"}
{"idx": "3173", "code": "public void addToDictionary(String s){\n  if (!getAutoComplete())   return;\n  if (dict == null) {\n    setUp();\n    this.dict=createDefaultDictionary();\n  }\n  dict.addEntry(s.trim());\n}\n", "docstring": "adds the specified string to the underlying dictionary", "partition": "test"}
{"idx": "4070", "code": "private static Key createDESKey(byte[] bytes,int offset){\n  byte[] keyBytes=new byte[7];\n  System.arraycopy(bytes,offset,keyBytes,0,7);\n  byte[] material=new byte[8];\n  material[0]=keyBytes[0];\n  material[1]=(byte)(keyBytes[0] << 7 | (keyBytes[1] & 0xff) >>> 1);\n  material[2]=(byte)(keyBytes[1] << 6 | (keyBytes[2] & 0xff) >>> 2);\n  material[3]=(byte)(keyBytes[2] << 5 | (keyBytes[3] & 0xff) >>> 3);\n  material[4]=(byte)(keyBytes[3] << 4 | (keyBytes[4] & 0xff) >>> 4);\n  material[5]=(byte)(keyBytes[4] << 3 | (keyBytes[5] & 0xff) >>> 5);\n  material[6]=(byte)(keyBytes[5] << 2 | (keyBytes[6] & 0xff) >>> 6);\n  material[7]=(byte)(keyBytes[6] << 1);\n  oddParity(material);\n  return new SecretKeySpec(material,\"DES\");\n}\n", "docstring": "creates a des encryption key from the given key material .", "partition": "test"}
{"idx": "588", "code": "public void expandAll(){\n  cancelEditing();\n  final TreeModel tm=getModel();\n  final Object root=tm.getRoot();\n  if (root != null) {\n    expandAllPaths(new TreePath(root),tm);\n  }\n}\n", "docstring": "expands all paths in the tree .", "partition": "test"}
{"idx": "1928", "code": "public Namespace(PrincipalUser creator,String qualifier,PrincipalUser owner,Set<PrincipalUser> users){\n  super(creator);\n  setQualifier(qualifier);\n  setOwner(owner);\n  if (users != null && !users.isEmpty()) {\n    setUsers(users);\n  }\n  addUser(owner);\n}\n", "docstring": "creates a new namespace object .", "partition": "test"}
{"idx": "471", "code": "public void drawRenderedImage(RenderedImage img,AffineTransform xform){\n  if (img == null) {\n    return;\n  }\n  mPrintMetrics.drawImage(this,img);\n  mDrawingArea.addInfinite();\n}\n", "docstring": "draws an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics2d . the given transformation is applied to the image before the transform attribute in the graphics2d state is applied . the rendering attributes applied include the clip , transform , and composite attributes . note that the result is undefined , if the given transform is noninvertible .", "partition": "test"}
{"idx": "772", "code": "public int compareTo(CharBuffer otherBuffer){\n  int compareRemaining=(remaining() < otherBuffer.remaining()) ? remaining() : otherBuffer.remaining();\n  int thisPos=position;\n  int otherPos=otherBuffer.position;\n  char thisByte, otherByte;\n  while (compareRemaining > 0) {\n    thisByte=get(thisPos);\n    otherByte=otherBuffer.get(otherPos);\n    if (thisByte != otherByte) {\n      return thisByte < otherByte ? -1 : 1;\n    }\n    thisPos++;\n    otherPos++;\n    compareRemaining--;\n  }\n  return remaining() - otherBuffer.remaining();\n}\n", "docstring": "compare the remaining chars of this buffer to another char buffer \"'\" s remaining chars .", "partition": "test"}
{"idx": "3145", "code": "private Element createEndPoint(String name,String attrBinding,String attrLocation,String attrResponseLocation) throws DOMException {\n  if (name == null) {\n    throw new IllegalArgumentException(\"Null name\");\n  }\n  if (attrBinding == null) {\n    throw new IllegalArgumentException(\"Null binding\");\n  }\n  if (attrLocation == null) {\n    throw new IllegalArgumentException(\"Null location\");\n  }\n  Element endPt=doc.createElement(name);\n  endPt.setAttribute(SAMLNames.BINDING,attrBinding);\n  endPt.setAttribute(SAMLNames.LOCATION,attrLocation);\n  if (attrResponseLocation != null) {\n    endPt.setAttribute(SAMLNames.RESPLOC,attrResponseLocation);\n  }\n  return endPt;\n}\n", "docstring": "create end point element in dom .", "partition": "test"}
{"idx": "3110", "code": "public void addInterface(String interfaceName){\n  short interfaceIndex=itsConstantPool.addClass(interfaceName);\n  itsInterfaces.add(Short.valueOf(interfaceIndex));\n}\n", "docstring": "add an interface implemented by this class . this method may be called multiple times for classes that implement multiple interfaces .", "partition": "test"}
{"idx": "3466", "code": "public void registerSensor(Sensor s,int i){\n  if ((i < 0) || (i > ((numInputCards() * bitsPerCard) - 1)) || (i > MAXSENSORS)) {\n    log.error(\"Unexpected sensor ordinal in registerSensor: \" + Integer.toString(i + 1));\n    return;\n  }\n  hasActiveSensors=true;\n  if (sensorArray[i] == null) {\n    sensorArray[i]=s;\n    if (lastUsedSensor < i) {\n      lastUsedSensor=i;\n    }\n  }\n else {\n    log.warn(\"multiple registration of same sensor: CS\" + Integer.toString((getNodeAddress() * SerialSensorManager.SENSORSPERUA) + i + 1));\n  }\n}\n", "docstring": "the numbers here are 0 to maxsensors , not 1 to maxsensors .", "partition": "test"}
{"idx": "3651", "code": "public Builder server(String server){\n  if (server.endsWith(\"/\") == false) {\n    server=server + \"/\";\n  }\n  this.server=server;\n  return this;\n}\n", "docstring": "set the server url to be used by parse . this method is only required if you intend to use a different api server than the one at api . parse . com .", "partition": "test"}
{"idx": "3329", "code": "private static ClassNode makeType(ClassNode cn,boolean usingClass){\n  if (usingClass) {\n    ClassNode clazzType=CLASS_Type.getPlainNodeReference();\n    clazzType.setGenericsTypes(new GenericsType[]{new GenericsType(cn)});\n    return clazzType;\n  }\n else {\n    return cn;\n  }\n}\n", "docstring": "wrap type in class & lt ; & gt ; if usingclass = = true", "partition": "test"}
{"idx": "3968", "code": "public static InputStream streamFromString(String location) throws IOException {\n  InputStream is=null;\n  URL url=urlFromString(location,null,false);\n  if (url != null) {\n    is=url.openStream();\n  }\n else {\n    File f=new File(location);\n    if (f.exists())     is=new FileInputStream(f);\n  }\n  if (is == null) {\n    return null;\n  }\n else   if (isGZipFile(location)) {\n    return new GZIPInputStream(is);\n  }\n else {\n    return is;\n  }\n}\n", "docstring": "get an input string corresponding to the given location string . the string will first be resolved to a url and an input stream will be requested from the url connection . if this fails , the location will be resolved against the file system . also , if a gzip file is found , the input stream will also be wrapped by a gzipinputstream . if the location string can not be resolved , a null value is returned", "partition": "test"}
{"idx": "1314", "code": "public static void pushEncryptedMessage(final TextSecureEnvelope envelope){\n  while (true) {\n    try {\n      queue.put(envelope);\n      return;\n    }\n catch (    final InterruptedException e) {\n    }\n  }\n}\n", "docstring": "adds an encrypted message to the queue . it will be automatically decrypted .", "partition": "test"}
{"idx": "3276", "code": "@Override public boolean equals(Object x,Object y) throws HibernateException {\n  if (x == null) {\n    return y == null;\n  }\n  return x.equals(y);\n}\n", "docstring": "compare two instances of the class mapped by this type for persistence \" equality \" . equality of the persistent state .", "partition": "test"}
{"idx": "660", "code": "public void addAssignedVirtualArrays(Set<String> virtualArrayURIs){\n  if ((virtualArrayURIs != null) && (!virtualArrayURIs.isEmpty())) {\n    HashSet<String> addVirtualArrays=new HashSet<String>();\n    addVirtualArrays.addAll(virtualArrayURIs);\n    if (_assignedVirtualArrays == null) {\n      setAssignedVirtualArrays(new StringSet());\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n else {\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n    updateVirtualArrayTags();\n  }\n}\n", "docstring": "adds the passed virtual array uris to the set of virtual array uris assigned to the resources by the user .", "partition": "test"}
{"idx": "475", "code": "public File createNewFolder(File containingDir) throws IOException {\n  if (containingDir == null) {\n    throw new IOException(\"Containing directory is null:\");\n  }\n  File newFolder=createFileObject(containingDir,newFolderString);\n  int i=2;\n  while (newFolder.exists() && i < 100) {\n    newFolder=createFileObject(containingDir,MessageFormat.format(newFolderNextString,new Integer(i)));\n    i++;\n  }\n  if (newFolder.exists()) {\n    throw new IOException(\"Directory already exists:\" + newFolder.getAbsolutePath());\n  }\n else {\n    newFolder.mkdirs();\n  }\n  return newFolder;\n}\n", "docstring": "creates a new folder with a default folder name .", "partition": "test"}
{"idx": "1435", "code": "public boolean addNode(Lop node){\n  if (nodes.contains(node))   return false;\n  nodes.add(node);\n  return true;\n}\n", "docstring": "method to add a node to the dag .", "partition": "test"}
{"idx": "1087", "code": "public static Byte[] valuesOf(byte[] array){\n  Byte[] dest=new Byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Byte.valueOf(array[i]);\n  }\n  return dest;\n}\n", "docstring": "converts to object array .", "partition": "test"}
{"idx": "2910", "code": "public void rootRemoved(ISVNRepositoryLocation root){\n  Iterator it=listeners.iterator();\n  while (it.hasNext()) {\n    IRepositoryListener listener=(IRepositoryListener)it.next();\n    listener.repositoryRemoved(root);\n  }\n}\n", "docstring": "a repository root has been removed .", "partition": "test"}
{"idx": "2150", "code": "public static boolean isMiddleMouseButton(MouseEvent anEvent){\n  return ((anEvent.getModifiersEx() & InputEvent.BUTTON2_DOWN_MASK) != 0 || anEvent.getButton() == MouseEvent.BUTTON2);\n}\n", "docstring": "returns true if the mouse event specifies the middle mouse button .", "partition": "test"}
{"idx": "2338", "code": "private boolean announce(String[] groups){\n  if (dataPackets == null || !lastLocator.equals(myLocator) || !Arrays.equals(lastGroups,groups)) {\n    List<DatagramPacket> packets=new ArrayList<DatagramPacket>();\n    Discovery disco;\n    try {\n      disco=getDiscovery(multicastAnnouncementConstraints.chooseProtocolVersion());\n    }\n catch (    DiscoveryProtocolException e) {\n      throw new AssertionError(e);\n    }\n    EncodeIterator ei=disco.encodeMulticastAnnouncement(new MulticastAnnouncement(announcementSeqNo++,myLocator.getHost(),myLocator.getPort(),groups,myServiceID),multicastAnnouncementConstraints.getMulticastMaxPacketSize(DEFAULT_MAX_PACKET_SIZE),multicastAnnouncementConstraints.getUnfulfilledConstraints());\n    while (ei.hasNext()) {\n      try {\n        packets.addAll(Arrays.asList(ei.next()));\n      }\n catch (      Exception e) {\n        logger.log((e instanceof UnsupportedConstraintException) ? Levels.HANDLED : Level.INFO,\"exception encoding multicast\" + \" announcement\",e);\n      }\n    }\n    lastLocator=myLocator;\n    lastGroups=groups;\n    dataPackets=packets.toArray(new DatagramPacket[packets.size()]);\n  }\n  try {\n    send(dataPackets);\n  }\n catch (  InterruptedIOException e) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "announce membership in the specified groups , and return false if interrupted , otherwise return true . this method is run from synchronized run method in thread .", "partition": "test"}
{"idx": "1107", "code": "public ArrayList<ConstraintWidget> findWidgets(WidgetContainer container,int x,int y,int width,int height){\n  ArrayList<ConstraintWidget> found=new ArrayList<>();\n  Rectangle area=new Rectangle(x,y,width,height);\n  for (  ConstraintWidget widget : container.getChildren()) {\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n    if (!decorator.isVisible()) {\n      continue;\n    }\n    Rectangle bounds=new Rectangle(widget.getDrawX(),widget.getDrawY(),widget.getWidth(),widget.getHeight());\n    if (area.intersects(bounds)) {\n      found.add(widget);\n    }\n  }\n  return found;\n}\n", "docstring": "gather all the widgets contained in the area specified and return them as an array , taking the decorator visibility in account", "partition": "test"}
{"idx": "3636", "code": "public void commit(IResource[] resources,String comment,boolean keepLocks,IProgressMonitor monitor) throws TeamException {\n  if (monitor == null) {\n    monitor=new NullProgressMonitor();\n  }\n  Map table=getProviderMapping(resources);\n  Set keySet=table.keySet();\n  monitor.beginTask(\"\",keySet.size() * 1000);\n  monitor.setTaskName(Policy.bind(\"RepositoryManager.committing\"));\n  Iterator iterator=keySet.iterator();\n  while (iterator.hasNext()) {\n    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1000);\n    SVNTeamProvider provider=(SVNTeamProvider)iterator.next();\n    List list=(List)table.get(provider);\n    IResource[] providerResources=(IResource[])list.toArray(new IResource[list.size()]);\n    provider.checkin(providerResources,comment,keepLocks,IResource.DEPTH_INFINITE,subMonitor);\n  }\n}\n", "docstring": "commit the given resources to their associated providers .", "partition": "test"}
{"idx": "1387", "code": "public static PlainText plain(short text){\n  return plain(Integer.toString(text));\n}\n", "docstring": "creates a new plaintext component with the given short", "partition": "test"}
{"idx": "1034", "code": "public double adjustedPow10(double val){\n  boolean negFlag=(val < 0.0);\n  if (negFlag) {\n    val=-val;\n  }\n  double res;\n  if (val < 1.0) {\n    res=(Math.pow(10,val + 1.0) - 10.0) / 9.0;\n  }\n else {\n    res=Math.pow(10,val);\n  }\n  return negFlag ? (-res) : res;\n}\n", "docstring": "returns an adjusted power of 10 value for graphing purposes . the first adjustment is that negative values are changed to positive during the calculations , and then the answer is negated at the end . the second is that , for values less than 1 , a progressive logarithmic offset is subtracted such that at 0 the returned result is also 0 .", "partition": "test"}
{"idx": "3386", "code": "private TransportNetwork checkCached(String networkId){\n  try {\n    String filename=networkId + \"_\" + R5Version.version+ \".dat\";\n    File cacheLocation=new File(cacheDir,networkId + \"_\" + R5Version.version+ \".dat\");\n    if (cacheLocation.exists())     LOG.info(\"Found locally-cached TransportNetwork at {}\",cacheLocation);\n else {\n      LOG.info(\"No locally cached transport network at {}.\",cacheLocation);\n      if (sourceBucket != null) {\n        LOG.info(\"Checking for cached transport network on S3.\");\n        S3Object tn;\n        try {\n          tn=s3.getObject(sourceBucket,filename);\n        }\n catch (        AmazonServiceException ex) {\n          LOG.info(\"No cached transport network was found in S3. It will be built from scratch.\");\n          return null;\n        }\n        cacheDir.mkdirs();\n        LOG.info(\"Copying pre-built transport network from S3 to local file {}\",cacheLocation);\n        FileOutputStream fos=new FileOutputStream(cacheLocation);\n        InputStream is=tn.getObjectContent();\n        try {\n          ByteStreams.copy(is,fos);\n        }\n  finally {\n          is.close();\n          fos.close();\n        }\n      }\n else {\n        LOG.info(\"Transport network was not found\");\n        return null;\n      }\n    }\n    LOG.info(\"Loading cached transport network at {}\",cacheLocation);\n    FileInputStream fis=new FileInputStream(cacheLocation);\n    try {\n      return TransportNetwork.read(fis);\n    }\n  finally {\n      fis.close();\n    }\n  }\n catch (  Exception e) {\n    LOG.error(\"Exception occurred retrieving cached transport network\",e);\n    return null;\n  }\n}\n", "docstring": "if this transport network is already built and cached , fetch it quick", "partition": "test"}
{"idx": "1844", "code": "public MessageCapture(final Logger logger,final boolean captureEntity){\n  this(logger,captureEntity,false);\n}\n", "docstring": "builds a new messagecapture .", "partition": "test"}
{"idx": "1534", "code": "protected void sendDataToReceiver(ResultReceiver receiver,Intent originalIntent,Serializable data){\n  if (receiver != null && data != null) {\n    Bundle bundle=new Bundle();\n    bundle.putParcelable(ServiceReceiver.EXTRA_ORIGINAL_INTENT,originalIntent);\n    bundle.putSerializable(ServiceReceiver.EXTRA_DATA,data);\n    receiver.send(ServiceReceiver.STATUS_DATA,bundle);\n  }\n}\n", "docstring": "sends data to the receiver , usually the creator of the service intent .", "partition": "test"}
{"idx": "267", "code": "private double calculateEntropy(double... masses){\n  double res=0;\n  for (  double d : masses) {\n    res-=(d == 0) ? 0 : d * Math.log(d);\n  }\n  return res / LOG2;\n}\n", "docstring": "calculates the entropy corresponding to the input masses .", "partition": "test"}
{"idx": "707", "code": "private void createMissingValues(){\n  String sql=\"SELECT ra.A_RegistrationAttribute_ID \" + \"FROM A_RegistrationAttribute ra\" + \" LEFT OUTER JOIN A_RegistrationProduct rp ON (rp.A_RegistrationAttribute_ID=ra.A_RegistrationAttribute_ID)\"+ \" LEFT OUTER JOIN A_Registration r ON (r.M_Product_ID=rp.M_Product_ID) \"+ \"WHERE r.A_Registration_ID=?\"+ \" AND NOT EXISTS (SELECT A_RegistrationAttribute_ID FROM A_RegistrationValue v \"+ \"WHERE ra.A_RegistrationAttribute_ID=v.A_RegistrationAttribute_ID AND r.A_Registration_ID=v.A_Registration_ID)\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getA_Registration_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRegistrationValue v=new MRegistrationValue(this,rs.getInt(1),\"?\");\n      v.saveEx();\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,null,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n}\n", "docstring": "create missing attribute values", "partition": "test"}
{"idx": "2158", "code": "public long inactiveTimeMillis(){\n  return System.currentTimeMillis() - lastTimeMillis;\n}\n", "docstring": "returns the number of milliseconds this session has been inactive .", "partition": "test"}
{"idx": "3303", "code": "private void forceOutOfMemory(){\n  ArrayList junk=new ArrayList();\n  for (; ; ) {\n    junk.add(new long[100000]);\n  }\n}\n", "docstring": "allocate objects until death", "partition": "test"}
{"idx": "3764", "code": "public static boolean canBeRandomized(Class clazz){\n  return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.equals(String.class) || clazz.equals(IDiscordClient.class);\n}\n", "docstring": "checks if the class is supported to be randomized without recursion .", "partition": "test"}
{"idx": "899", "code": "public String substring(String subject,int start,int stop){\n  if (stop == -1 || stop >= subject.length()) {\n    return subject.substring(start);\n  }\n  return subject.substring(start,stop);\n}\n", "docstring": "get a substring from a string", "partition": "test"}
{"idx": "1683", "code": "private void addLimitedMitreJoin(LineSegment offset0,LineSegment offset1,double distance,double mitreLimit){\n  Coordinate basePt=seg0.p1;\n  double ang0=Angle.angle(basePt,seg0.p0);\n  double ang1=Angle.angle(basePt,seg1.p1);\n  double angDiff=Angle.angleBetweenOriented(seg0.p0,basePt,seg1.p1);\n  double angDiffHalf=angDiff / 2;\n  double midAng=Angle.normalize(ang0 + angDiffHalf);\n  double mitreMidAng=Angle.normalize(midAng + Math.PI);\n  double mitreDist=mitreLimit * distance;\n  double bevelDelta=mitreDist * Math.abs(Math.sin(angDiffHalf));\n  double bevelHalfLen=distance - bevelDelta;\n  double bevelMidX=basePt.x + mitreDist * Math.cos(mitreMidAng);\n  double bevelMidY=basePt.y + mitreDist * Math.sin(mitreMidAng);\n  Coordinate bevelMidPt=new Coordinate(bevelMidX,bevelMidY);\n  LineSegment mitreMidLine=new LineSegment(basePt,bevelMidPt);\n  Coordinate bevelEndLeft=mitreMidLine.pointAlongOffset(1.0,bevelHalfLen);\n  Coordinate bevelEndRight=mitreMidLine.pointAlongOffset(1.0,-bevelHalfLen);\n  if (side == Position.LEFT) {\n    segList.addPt(bevelEndLeft);\n    segList.addPt(bevelEndRight);\n  }\n else {\n    segList.addPt(bevelEndRight);\n    segList.addPt(bevelEndLeft);\n  }\n}\n", "docstring": "adds a limited mitre join connecting the two reflex offset segments . a limited mitre is a mitre which is beveled at the distance determined by the mitre ratio limit .", "partition": "test"}
{"idx": "3494", "code": "public File makeAcceptable(File pathname){\n  if (accept(pathname)) {\n    return pathname;\n  }\n else {\n    return new File(pathname.getPath() + '.' + defaultExtension);\n  }\n}\n", "docstring": "appends the extension to the filename , in case it is missing .", "partition": "test"}
{"idx": "249", "code": "protected int drawNextEventTimeDiff(){\n  int timeDiff=msgInterval[0] == msgInterval[1] ? 0 : rng.nextInt(msgInterval[1] - msgInterval[0]);\n  return msgInterval[0] + timeDiff;\n}\n", "docstring": "generates a ( random ) time difference between two events", "partition": "test"}
{"idx": "4094", "code": "public boolean needsReload(File file){\n  return fFilesToReoad.contains(file);\n}\n", "docstring": "returns true if the given indicator file needs to be reloaded .", "partition": "test"}
{"idx": "2718", "code": "protected boolean isCompatible(Taxa taxa,List<Taxon> availableTaxa){\n  for (int i=0; i < taxa.getTaxonCount(); i++) {\n    Taxon taxon=taxa.getTaxon(i);\n    if (!availableTaxa.contains(taxon)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "returns true if taxa are all found in availabletaxa", "partition": "test"}
{"idx": "205", "code": "public Result result(SqlNode node,Collection<Clause> clauses,RelNode rel){\n  final String alias2=SqlValidatorUtil.getAlias(node,-1);\n  final String alias3=alias2 != null ? alias2 : \"t\";\n  final String alias4=SqlValidatorUtil.uniquify(alias3,aliasSet,SqlValidatorUtil.EXPR_SUGGESTER);\n  final String alias5=alias2 == null || !alias2.equals(alias4) ? alias4 : null;\n  return new Result(node,clauses,alias5,Collections.singletonList(Pair.of(alias4,rel.getRowType())));\n}\n", "docstring": "creates a result based on a single relational expression .", "partition": "test"}
{"idx": "954", "code": "public void addRole(String role){\n  if (role != null) {\n    roles.add(role);\n  }\n}\n", "docstring": "add a role to this user .", "partition": "test"}
{"idx": "1599", "code": "public static void performSaveAs(String schemaPrefixFileName,String selFilePath,ContainerConfig containerConfig){\n  try {\n    File fileWithDefaultConfiguration=createContainerSchemaFile(schemaPrefixFileName,selFilePath);\n    updateFile(containerConfig,fileWithDefaultConfiguration.getPath(),schemaPrefixFileName);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "save content of containerconfig instance into xml file ( schema or configuration ) .", "partition": "test"}
{"idx": "133", "code": "private void checkPendingCustomMessages(){\n  if (joiningNodes.isEmpty() && isLocalNodeCoordinator()) {\n    TcpDiscoveryCustomEventMessage msg;\n    while ((msg=pendingCustomMsgs.poll()) != null) {\n      processCustomMessage(msg);\n      if (msg.verified())       msgHist.add(msg);\n    }\n  }\n}\n", "docstring": "checks and flushes custom event messages if no nodes are attempting to join the grid .", "partition": "test"}
{"idx": "2490", "code": "@Override public SelectableChannel selectableChannel(){\n  return socketChannel;\n}\n", "docstring": "returns the socketchannel underlying this socketcommchannel", "partition": "test"}
{"idx": "626", "code": "@Override protected void commitToInput(){\n  JmxBeanSensorAssignment assignment=getInput();\n  if (null != assignment) {\n    assignment.setDomain(domainText.getText());\n    assignment.setObjectNameParameters(new HashMap<>(parametersMap));\n    if (allAttributesButton.getSelection()) {\n      assignment.setAttributes(Collections.<String>emptySet());\n    }\n else {\n      assignment.setAttributes(new HashSet<>(attributesSet));\n    }\n  }\n}\n", "docstring": "commits changes in page to input .", "partition": "test"}
{"idx": "873", "code": "private static int compareVersion(String versionStr1,String versionStr2){\n  if (versionStr1 == null) {\n    throw new MLContextException(\"First version argument to compareVersion() is null\");\n  }\n  if (versionStr2 == null) {\n    throw new MLContextException(\"Second version argument to compareVersion() is null\");\n  }\n  Scanner scanner1=null;\n  Scanner scanner2=null;\n  try {\n    scanner1=new Scanner(versionStr1);\n    scanner2=new Scanner(versionStr2);\n    scanner1.useDelimiter(\"\\\\\\\\.\");\n    scanner2.useDelimiter(\"\\\\\\\\.\");\n    while (scanner1.hasNextInt() && scanner2.hasNextInt()) {\n      int version1=scanner1.nextInt();\n      int version2=scanner2.nextInt();\n      if (version1 < version2) {\n        return -1;\n      }\n else       if (version1 > version2) {\n        return 1;\n      }\n    }\n    return scanner1.hasNextInt() ? 1 : 0;\n  }\n  finally {\n    scanner1.close();\n    scanner2.close();\n  }\n}\n", "docstring": "compare two version strings ( ie , \" 1 . 4 . 0 \" and \" 1 . 4 . 1 \" ) .", "partition": "test"}
{"idx": "1164", "code": "public RootBlockView(final boolean rootBlock0,final ByteBuffer buf,final ChecksumUtility checker) throws RootBlockException {\n  if (buf == null)   throw new IllegalArgumentException();\n  if (buf.remaining() != SIZEOF_ROOT_BLOCK) {\n    throw new IllegalArgumentException(\"Expecting \" + SIZEOF_ROOT_BLOCK + \" remaining, actual=\"+ buf.remaining());\n  }\n  this.buf=buf.asReadOnlyBuffer();\n  this.rootBlock0=rootBlock0;\nswitch (getStoreType()) {\ncase RW:\n{\n      am=new RWAddressManager(null);\n      break;\n    }\ncase WORM:\n{\n    final int offsetBits=getOffsetBits();\n    am=new WormAddressManager(offsetBits);\n    break;\n  }\ndefault :\nthrow new RootBlockException(\"Unknown storeType=\" + getStoreType());\n}\nif (checker == null) {\nlog.warn(\"Checksum will not be validated\");\n}\nthis.checker=checker;\nvalid();\n}\n", "docstring": "create a new read - only view from the supplied buffer .", "partition": "test"}
{"idx": "3223", "code": "public boolean doTransaction(DB db,Object threadstate) throws WorkloadException {\n  boolean ret=true;\n  long st=System.nanoTime();\n  String op=operationchooser.nextString();\n  if (op.compareTo(\"READ\") == 0) {\n    ret=doTransactionRead(db);\n  }\n else   if (op.compareTo(\"UPDATE\") == 0) {\n    ret=doTransactionUpdate(db);\n  }\n else   if (op.compareTo(\"INSERT\") == 0) {\n    ret=doTransactionInsert(db);\n  }\n else   if (op.compareTo(\"SCAN\") == 0) {\n    ret=doTransactionScan(db);\n  }\n else {\n    ret=doTransactionReadModifyWrite(db);\n  }\n  long en=System.nanoTime();\n  _measurements.measure(_operations.get(op),(int)((en - st) / 1000));\n  if (ret)   _measurements.reportReturnCode(_operations.get(op),-1);\n else {\n    _measurements.reportReturnCode(_operations.get(op),0);\n  }\n  actualopcount.addAndGet(1);\n  return ret;\n}\n", "docstring": "do one transaction operation . because it will be called concurrently from multiple client threads , this function must be thread safe . however , avoid synchronized , or the threads will block waiting for each other , and it will be difficult to reach the target throughput . ideally , this function would have no side effects other than db operations .", "partition": "test"}
{"idx": "1513", "code": "private void saveAndClose(boolean save){\n  content.setEnabled(false);\n  if (timer != null) {\n    timer.cancel();\n    timer=null;\n  }\n  if (timerNextSync != null) {\n    timerNextSync.cancel();\n    timerNextSync=null;\n  }\n  if (save) {\n    Log.d(LOG_TAG,\"saveAndClose with SAVE\");\n    saveData(null);\n  }\n else {\n    Log.d(LOG_TAG,\"saveAndClose WITHOUT save\");\n  }\n  Intent data=new Intent();\n  data.setAction(Intent.ACTION_VIEW);\n  data.putExtra(PARAM_NOTE,note);\n  data.putExtra(PARAM_NOTE_POSITION,notePosition);\n  setResult(RESULT_OK,data);\n  finish();\n}\n", "docstring": "saves all changes and closes the activity", "partition": "test"}
{"idx": "3308", "code": "private void warning(String msg,Throwable th){\n  warning(msg);\n  th.printStackTrace();\n}\n", "docstring": "used internally to log a message about the class at level warning , in case an exception was thrown", "partition": "test"}
{"idx": "3991", "code": "private void captureDifferentString(String oldString,String newString,Map<String,String> map,String appName){\n  Reject.ifNull(appName);\n  Reject.ifNull(map);\n  if (oldString == null ? newString != null : !oldString.equals(newString)) {\n    map.put(appName,newString);\n  }\n}\n", "docstring": "adds entries to the passed in map , using the supplied appname as the key . the value is a new , empty set if both oldset and newset are null , or newset if the contents of oldset and newset differ . if the two sets are the same , no entries are added to the map .", "partition": "test"}
{"idx": "3592", "code": "public void collapseTree(){\n  for (int i=1; i < tree.getRowCount(); ++i) {\n    tree.collapseRow(i);\n  }\n}\n", "docstring": "collapse the tree so that only the root node is visible .", "partition": "test"}
{"idx": "3342", "code": "void wakeOut(){\n  OnAvailable outFlow=_outFlow;\n  if (outFlow == null) {\n    return;\n  }\n  if (_creditsIn <= _queue.head()) {\n    return;\n  }\n  StateOutPipe stateOld;\n  StateOutPipe stateNew;\n  do {\n    stateOld=_stateOutRef.get();\n    if (!stateOld.isFull()) {\n      return;\n    }\n    stateNew=stateOld.toWake();\n  }\n while (!_stateOutRef.compareAndSet(stateOld,stateNew));\n  try (OutboxAmp outbox=OutboxAmp.currentOrCreate(_outRef.services())){\n    Objects.requireNonNull(outbox);\n    PipeWakeOutMessage<T> msg=new PipeWakeOutMessage<>(outbox,_outRef,this,outFlow);\n    outbox.offer(msg);\n  }\n }\n", "docstring": "notify the reader of available space in the pipe . if the writer is asleep , wake it .", "partition": "test"}
{"idx": "3424", "code": "@MethodDesc(description=\"Stops the replicator service\",usage=\"stop\") public void stop() throws Exception {\n  try {\n    handleEventSynchronous(new StopEvent());\n    if (doneLatch != null) {\n      doneLatch.countDown();\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Stop operation failed\",e);\n    throw new Exception(e.toString());\n  }\n}\n", "docstring": "stop replicator node manager jmx service .", "partition": "test"}
{"idx": "3901", "code": "private Object createInner(SimpleObject post,RequestContext context) throws ResponseException {\n  try {\n    String xml=completeXform(convertUuidsToIds(post));\n    File file=File.createTempFile(\"projectbuendia\",null);\n    processor.processXForm(xml,file.getAbsolutePath(),true,context.getRequest());\n  }\n catch (  IOException e) {\n    throw new GenericRestException(\"Error storing xform data\",e);\n  }\ncatch (  ResponseException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new ConversionException(\"Error processing xform data\",e);\n  }\n  Encounter encounter=guessEncounterFromXformSubmission(post);\n  if (encounter == null) {\n    return post;\n  }\n  SimpleObject returnJson=new SimpleObject();\n  EncounterResource.populateJsonProperties(encounter,returnJson);\n  return returnJson;\n}\n", "docstring": "accepts a submitted form instance .", "partition": "test"}
{"idx": "2263", "code": "public MongoClient clientForMembers(ServerAddress... seeds){\n  List<ServerAddress> addresses=new ArrayList<>();\n  for (  ServerAddress seedAddress : seeds) {\n    if (seedAddress != null)     addresses.add(seedAddress);\n  }\n  return clientForMembers(addresses);\n}\n", "docstring": "obtain a client connection to the replica set or cluster . the supplied addresses are used as seeds , and once a connection is established it will discover all of the members .", "partition": "test"}
{"idx": "2148", "code": "public OsmElement pasteFrom(){\n  List<Way> ways=storage.getWays();\n  List<Node> nodes=storage.getNodes();\n  if (mode == Mode.CUT) {\n    reset();\n    if (ways != null && ways.size() == 1) {\n      Way w=ways.get(0);\n      w.setState(savedState);\n      for (      Node nd : w.getNodes()) {\n        Log.d(\"PasteFrom\",\"Restoring state for \" + nd.getOsmId());\n        nd.setState(savedNdState.get(nd));\n      }\n      return w;\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      Node n=nodes.get(0);\n      n.setState(savedState);\n      return n;\n    }\n  }\n else {\n    if (ways != null && ways.size() == 1) {\n      return ways.get(0);\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      return nodes.get(0);\n    }\n  }\n  return null;\n}\n", "docstring": "returns whatever is in the clipboard", "partition": "test"}
{"idx": "76", "code": "public ZipStreamImpl openReadImpl(PathImpl path) throws IOException {\n  String pathName=path.getPath();\n  return openReadImpl(pathName);\n}\n", "docstring": "opens a stream to an entry in the jar .", "partition": "test"}
{"idx": "43", "code": "private static native boolean renderFrame(int[] pixels,long gifFileInPtr,int[] metaData);\n", "docstring": "decodes a frame if needed .", "partition": "test"}
{"idx": "2762", "code": "protected HttpURLConnection configureRequest(final HttpURLConnection request){\n  if (credentials != null)   request.setRequestProperty(HEADER_AUTHORIZATION,credentials);\n  request.setRequestProperty(HEADER_USER_AGENT,userAgent);\n  request.setRequestProperty(HEADER_ACCEPT,getHeaderAccept());\n  return request;\n}\n", "docstring": "configure request with standard headers", "partition": "test"}
{"idx": "2854", "code": "public static <T,U extends Closeable>T withCloseable(U self,@ClosureParams(value=FirstParam.class) Closure<T> action) throws IOException {\n  try {\n    T result=action.call(self);\n    Closeable temp=self;\n    self=null;\n    temp.close();\n    return result;\n  }\n  finally {\n    DefaultGroovyMethodsSupport.closeWithWarning(self);\n  }\n}\n", "docstring": "allows this closeable to be used within the closure , ensuring that it is closed once the closure has been executed and before this method returns .", "partition": "test"}
{"idx": "838", "code": "@SuppressWarnings(\"rawtypes\") protected KafkaSpoutWrapper createKafkaSpout(Map conf,TopologyContext context,SpoutOutputCollector collector,final String topic,String schemeClsName,SpoutSpec spoutSpec,Map<String,StreamDefinition> sds) throws Exception {\n  String kafkaBrokerZkQuorum=config.getString(\"spout.kafkaBrokerZkQuorum\");\n  BrokerHosts hosts=null;\n  if (config.hasPath(\"spout.kafkaBrokerZkBasePath\")) {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum,config.getString(\"spout.kafkaBrokerZkBasePath\"));\n  }\n else {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum);\n  }\n  String transactionZkRoot=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_ROOT;\n  if (config.hasPath(\"spout.stormKafkaTransactionZkPath\")) {\n    transactionZkRoot=config.getString(\"spout.stormKafkaTransactionZkPath\");\n  }\n  String zkStateTransactionRelPath=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_RELATIVE_PATH;\n  if (config.hasPath(\"spout.stormKafkaEagleConsumer\")) {\n    zkStateTransactionRelPath=config.getString(\"spout.stormKafkaEagleConsumer\");\n  }\n  SpoutConfig spoutConfig=new SpoutConfig(hosts,topic,transactionZkRoot,zkStateTransactionRelPath + \"/\" + topic+ \"/\"+ topologyId);\n  boolean stormKafkaUseSameZkQuorumWithKafkaBroker=config.getBoolean(\"spout.stormKafkaUseSameZkQuorumWithKafkaBroker\");\n  if (stormKafkaUseSameZkQuorumWithKafkaBroker) {\n    ZkServerPortUtils utils=new ZkServerPortUtils(kafkaBrokerZkQuorum);\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n else {\n    ZkServerPortUtils utils=new ZkServerPortUtils(config.getString(\"spout.stormKafkaTransactionZkQuorum\"));\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n  spoutConfig.stateUpdateIntervalMs=config.hasPath(\"spout.stormKafkaStateUpdateIntervalMs\") ? config.getInt(\"spout.stormKafkaStateUpdateIntervalMs\") : 2000;\n  spoutConfig.fetchSizeBytes=config.hasPath(\"spout.stormKafkaFetchSizeBytes\") ? config.getInt(\"spout.stormKafkaFetchSizeBytes\") : 1048586;\n  if (config.hasPath(\"spout.stormKafkaStartOffsetTime\")) {\n    spoutConfig.startOffsetTime=config.getInt(\"spout.stormKafkaStartOffsetTime\");\n  }\n  spoutConfig.scheme=createMultiScheme(conf,topic,schemeClsName);\n  KafkaSpoutWrapper wrapper=new KafkaSpoutWrapper(spoutConfig,kafkaSpoutMetric);\n  SpoutOutputCollectorWrapper collectorWrapper=new SpoutOutputCollectorWrapper(this,collector,topic,spoutSpec,numOfRouterBolts,sds,this.serializer);\n  wrapper.open(conf,context,collectorWrapper);\n  if (LOG.isInfoEnabled()) {\n    LOG.info(\"create and open kafka wrapper: topic {}, scheme class{} \",topic,schemeClsName);\n  }\n  return wrapper;\n}\n", "docstring": "make this method protected to make sure unit test can work well q : where to persist consumer state , i . e . what offset has been consumed for each topic and partition a : stormkafkatransactionzkpath + \" / \" + consumerid + \" / \" + topic + \" / \" + topologyid + \" / \" + partitionid note1 : partitionmanager . committedpath for composing zkstate path , _spoutconfig . zkroot + \" / \" + _spoutconfig . id + \" / \" + _partition . getid ( ) ; consumerid by default is eagleconsumer unless it is specified by \" stormkafkaeagleconsumer \" note2 : put topologyid as part of zkstate because one topic by design can be consumed by multiple topologies so one topology needs to know processed offset for itself < p > todo : should avoid use config . get in deep calling stack , should generate config bean as early as possible", "partition": "test"}
{"idx": "834", "code": "public static String encode(Serializable o){\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\n  try {\n    ObjectOutputStream oos=new ObjectOutputStream(bos);\n    try {\n      oos.writeObject(o);\n      oos.flush();\n    }\n  finally {\n      oos.close();\n    }\n    return Base64.encodeBytes(bos.toByteArray());\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "encode a object to a base64 string", "partition": "test"}
{"idx": "3856", "code": "public PutIndexTemplateRequest aliases(XContentBuilder source){\n  return aliases(source.bytes());\n}\n", "docstring": "sets the aliases that will be associated with the index when it gets created", "partition": "test"}
{"idx": "1869", "code": "public void send(XTraceReport report){\n  outgoing.offer(report);\n}\n", "docstring": "enqueues the provided report to be sent by the reporting thread", "partition": "test"}
{"idx": "3986", "code": "public default void addFile(final ContentProvider contentProvider,final String fileName,final EntryInformation entryInformation) throws IOException {\n  addFile(contentProvider,fileName,entryInformation,Optional.empty());\n}\n", "docstring": "add a file to the binary package", "partition": "test"}
{"idx": "2431", "code": "public void shutdown(){\n  running=false;\n  if (networkThreads != null) {\n    for (    NetworkThread n : networkThreads) {\n      n.stopped=true;\n    }\n  }\n  networkThreads=null;\nsynchronized (LOCK) {\n    LOCK.notifyAll();\n  }\n}\n", "docstring": "shuts down the network thread , this will trigger failures if you have network requests", "partition": "test"}
{"idx": "2270", "code": "private static final void checkQueueForDependenciesAndExecuteUnblockedTasks(){\n  List<ProgressThread> toRemove=new LinkedList<>();\nsynchronized (LOCK) {\n    for (    ProgressThread pg : queuedThreads) {\n      if (!pg.isBlockedByDependencies()) {\n        if (!pg.isWaiting()) {\n          toRemove.add(pg);\n          EXECUTOR.execute(pg.makeWrapper());\n        }\n      }\n    }\n  }\n  for (  ProgressThread pg : toRemove) {\nsynchronized (LOCK) {\n      queuedThreads.remove(pg);\n    }\n  }\n}\n", "docstring": "checks the currently queued tasks if there are ones which are no longer blocked by dependencies and executes them .", "partition": "test"}
{"idx": "2318", "code": "public AllocationSite(int line,int column){\nsynchronized (sites) {\n    this.id=sites.size();\n    sites.add(this);\n  }\n  this.line=line;\n  this.column=column;\n}\n", "docstring": "create an allocation site for a given source code line / column .", "partition": "test"}
{"idx": "1380", "code": "public DCryptoStrength(JFrame parent) throws CryptoException {\n  super(parent,res.getString(\"DCryptoStrength.Title\"),ModalityType.DOCUMENT_MODAL);\n  initComponents();\n}\n", "docstring": "creates a new dcryptostrength dialog where the parent is a frame .", "partition": "test"}
{"idx": "3597", "code": "@RequestMapping(value=\"/{bookmarkId}\",method=RequestMethod.PUT) public ResponseEntity<Bookmark> editBookmark(@PathVariable(value=\"username\") String username,@PathVariable(value=\"bookmarkId\") int bookmarkId,@RequestBody String json) throws IOException, BookmarkNotFoundException, IllegalAccessException, InvocationTargetException {\n  Optional<Bookmark> optional=bookmarksRepository.findByIdAndUserUsername(bookmarkId,username);\n  if (optional.isPresent()) {\n    ObjectMapper mapper=new ObjectMapper();\n    Map<String,String> changeMap=mapper.readValue(json,HashMap.class);\n    Bookmark bookmark=optional.get();\n    BeanUtils.populate(bookmark,changeMap);\n    bookmark=bookmarksRepository.save(bookmark);\n    return new ResponseEntity<>(bookmark,HttpStatus.OK);\n  }\n else {\n    throw new BookmarkNotFoundException(\"Bookmark not found id = \" + bookmarkId);\n  }\n}\n", "docstring": "a method to edit a bookmark .", "partition": "test"}
{"idx": "2949", "code": "public void removePhoto(PhotoEntity photo){\n  photos.remove(photo);\n}\n", "docstring": "removes the given photo from this user", "partition": "test"}
{"idx": "1897", "code": "public static Map<String,String> allNamespaces(SOAPElement ele){\n  Map<String,String> nsList=new TreeMap<String,String>();\n  log.trace(\"Starting Namespace Lookup in \" + ele.getNodeName());\n  allNamespaces(ele,nsList);\n  log.trace(\"Namespace Lookup done: \" + nsList);\n  return nsList;\n}\n", "docstring": "returns a list of all namespaces below an element ( recursive )", "partition": "test"}
{"idx": "2730", "code": "public static double logpdf(double x,double mu,double shape){\n  if (!(x > 0) || x == Double.POSITIVE_INFINITY) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  final double v=(x - mu) / mu;\n  return v < Double.MAX_VALUE ? 0.5 * Math.log(shape / (MathUtil.TWOPI * x * x* x)) - shape * v * v / (2. * x) : Double.NEGATIVE_INFINITY;\n}\n", "docstring": "probability density function of the wald distribution .", "partition": "test"}
{"idx": "3", "code": "@Override public void closingOK(){\n  List<AddUserFields.AttributeSpec> specs=new ArrayList<AddUserFields.AttributeSpec>();\n  for (int i=0; i < m_listModel.size(); i++) {\n    AddUserFields.AttributeSpec a=(AddUserFields.AttributeSpec)m_listModel.elementAt(i);\n    specs.add(a);\n  }\n  if (m_modifyL != null) {\n    m_modifyL.setModifiedStatus(AddUserFieldsCustomizer.this,true);\n  }\n  m_filter.setAttributeSpecs(specs);\n}\n", "docstring": "actions to perform when the user has closed the dialog with the ok button .", "partition": "test"}
{"idx": "2141", "code": "public String betToString(){\n  final StringBuilder sb=new StringBuilder();\n  sb.append(amount);\n  sb.append(\" \");\n  sb.append(itemName);\n  sb.append(\" on \");\n  sb.append(target);\n  return sb.toString();\n}\n", "docstring": "converts the bet into a string .", "partition": "test"}
{"idx": "2026", "code": "public void finishFragments(){\n  for (  Fragment comment : closingFragments) {\n    finishFragment(comment);\n  }\n  closingFragments.clear();\n}\n", "docstring": "sets all the closing fragments into finished state .", "partition": "test"}
{"idx": "2930", "code": "public double[] popy(double x_[]){\n  return popY(new double[][]{x_})[0];\n}\n", "docstring": "forward pass - given input x_ , get output y_ .", "partition": "test"}
{"idx": "708", "code": "private static String normalisePath(String path){\n  return path.replace('\\\\\\\\','/');\n}\n", "docstring": "this method replaces all \\\\ to / .", "partition": "test"}
{"idx": "1983", "code": "private String trimUrl(String uri){\n  if (uri == null)   return \"\";\n  if (uri.endsWith(\"/\"))   uri=uri.substring(0,uri.length() - 1);\n  return uri;\n}\n", "docstring": "trim the url , by removing an extra \"'\" / \"'\" at the end of the url and also make it lowercase < p >", "partition": "test"}
{"idx": "1279", "code": "private void ensureSize(){\n  if (children == EMPTY_CHILDREN) {\n    children=new FPNode[1];\n    return;\n  }\n  int newsize=children.length == 1 ? INITIAL_SIZE : (children.length << 1);\n  children=Arrays.copyOf(children,newsize);\n}\n", "docstring": "ensure we have enough storage .", "partition": "test"}
{"idx": "2423", "code": "private static void insertCommentsInNode(Node node,List<Comment> commentsToAttribute){\n  if (commentsToAttribute.size() == 0)   return;\n  List<Node> children=node.getChildrenNodes();\n  PositionUtils.sortByBeginPosition(children);\n  for (  Node child : children) {\n    List<Comment> commentsInsideChild=new LinkedList<Comment>();\n    for (    Comment c : commentsToAttribute) {\n      if (PositionUtils.nodeContains(child,c,_doNotConsiderAnnotationsAsNodeStartForCodeAttribution)) {\n        commentsInsideChild.add(c);\n      }\n    }\n    commentsToAttribute.removeAll(commentsInsideChild);\n    insertCommentsInNode(child,commentsInsideChild);\n  }\n  List<Comment> attributedComments=new LinkedList<Comment>();\n  for (  Comment comment : commentsToAttribute) {\n    if (comment.isLineComment()) {\n      for (      Node child : children) {\n        if (child.getEndLine() == comment.getBeginLine()) {\n          if (attributeLineCommentToNodeOrChild(child,comment.asLineComment())) {\n            attributedComments.add(comment);\n          }\n        }\n      }\n    }\n  }\n  Comment previousComment=null;\n  attributedComments=new LinkedList<Comment>();\n  List<Node> childrenAndComments=new LinkedList<Node>();\n  childrenAndComments.addAll(children);\n  childrenAndComments.addAll(commentsToAttribute);\n  PositionUtils.sortByBeginPosition(childrenAndComments,_doNotConsiderAnnotationsAsNodeStartForCodeAttribution);\n  for (  Node thing : childrenAndComments) {\n    if (thing instanceof Comment) {\n      previousComment=(Comment)thing;\n      if (!previousComment.isOrphan()) {\n        previousComment=null;\n      }\n    }\n else {\n      if (previousComment != null && !thing.hasComment()) {\n        if (!_doNotAssignCommentsPreceedingEmptyLines || !thereAreLinesBetween(previousComment,thing)) {\n          thing.setComment(previousComment);\n          attributedComments.add(previousComment);\n          previousComment=null;\n        }\n      }\n    }\n  }\n  commentsToAttribute.removeAll(attributedComments);\n  for (  Comment c : commentsToAttribute) {\n    if (c.isOrphan()) {\n      node.addOrphanComment(c);\n    }\n  }\n}\n", "docstring": "this method try to attributes the nodes received to child of the node . it returns the node that were not attributed .", "partition": "test"}
{"idx": "1510", "code": "MarkerSegment findMarkerSegment(Class cls,boolean first){\n  if (first) {\n    Iterator iter=markerSequence.iterator();\n    while (iter.hasNext()) {\n      MarkerSegment seg=(MarkerSegment)iter.next();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n else {\n    ListIterator iter=markerSequence.listIterator(markerSequence.size());\n    while (iter.hasPrevious()) {\n      MarkerSegment seg=(MarkerSegment)iter.previous();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "returns the first or last markersegment object in the list of the given class , or null if none is found .", "partition": "test"}
{"idx": "3812", "code": "private void waitForIteratorsCleared(IgniteCache<String,Integer> cache,int secs) throws InterruptedException {\n  for (int i=0; i < secs; i++) {\n    try {\n      cache.size();\n      checkIteratorsCleared();\n    }\n catch (    AssertionFailedError e) {\n      if (i == 9) {\n        for (int j=0; j < gridCount(); j++)         executeOnLocalOrRemoteJvm(j,new PrintIteratorStateTask());\n        throw e;\n      }\n      log.info(\"Iterators not cleared, will wait\");\n      Thread.sleep(1000);\n    }\n  }\n}\n", "docstring": "checks iterators are cleared .", "partition": "test"}
{"idx": "3600", "code": "public static Object[] findMethodWithListParameters(Object service,String methodName,List<?> args){\n  Object[] arguments=new Object[args.size()];\n  for (int i=0; i < args.size(); i++) {\n    arguments[i]=args.get(i);\n  }\n  return findMethodWithListParameters(service,methodName,arguments);\n}\n", "docstring": "returns ( method , params ) for the given service or ( null , null ) if no method was found .", "partition": "test"}
{"idx": "3279", "code": "public void testFindSpringOpenLdapWithLimit(){\n  LdapProxy proxy=getLdapOpenLdap();\n  List result=null;\n  int limit=1;\n  try {\n    result=proxy.find(getLdapSearchVO(\"\",limit,\"cn\",\"ngomila\",null,LdapScopeConstants.SCOPE_SUBTREE));\n  }\n catch (  Exception e) {\n  }\n  assertNotNull(result);\n  if (result != null) {\n    assertEquals(limit,result.size());\n  }\n}\n", "docstring": "test de busqueda open ldap con limite", "partition": "test"}
{"idx": "3313", "code": "public void showScores(boolean flag){\n  mShowScores=flag;\n  SwingUtilities.invokeLater(null);\n}\n", "docstring": "set whether to show scores on the plot lines", "partition": "test"}
{"idx": "2803", "code": "static void dispose(long pData,long pConfigInfo){\n  OGLRenderQueue rq=OGLRenderQueue.getInstance();\n  rq.lock();\n  try {\n    OGLContext.setScratchSurface(pConfigInfo);\n    RenderBuffer buf=rq.getBuffer();\n    rq.ensureCapacityAndAlignment(12,4);\n    buf.putInt(DISPOSE_SURFACE);\n    buf.putLong(pData);\n    rq.flushNow();\n  }\n  finally {\n    rq.unlock();\n  }\n}\n", "docstring": "disposes the native resources associated with the given oglsurfacedata ( referenced by the pdata parameter ) . this method is invoked from the native dispose ( ) method from the disposer thread when the java - level oglsurfacedata object is about to go away . note that we also pass a reference to the native glx / wglgraphicsconfiginfo ( pconfiginfo ) for the purposes of making a context current .", "partition": "test"}
{"idx": "3979", "code": "public void monitor(ScalingStateMonitorTask task){\n  taskQueue.add(task);\n  startMonitor();\n}\n", "docstring": "adds a monitor task to the queue", "partition": "test"}
{"idx": "2746", "code": "protected Connection openConnection(boolean autocommit) throws SQLException {\n  Connection conn=dataSrc.getConnection();\n  conn.setAutoCommit(autocommit);\n  return conn;\n}\n", "docstring": "gets connection from a pool .", "partition": "test"}
{"idx": "1557", "code": "public boolean registerUser(String username,String password,String uri) throws DataAccessException {\n  if (checkUsernameExists(username)) {\n    return false;\n  }\n  storeUser(username,password,uri);\n  return true;\n}\n", "docstring": "attempts to register the username , password combination . checks if username not already exist . returns true if successful , false otherwise .", "partition": "test"}
{"idx": "1810", "code": "private void parseFirstConsonant(){\n  Iterator iter=alFirstConsonants.iterator();\n  while (iter.hasNext()) {\n    String strFirstCon=(String)iter.next();\n    if (strSyllable.startsWith(strFirstCon,iCurPos)) {\n      strFirstConsonant=strFirstCon;\n      iCurPos+=strFirstCon.length();\n      return;\n    }\n  }\n  strFirstConsonant=ZERO;\n}\n", "docstring": "parses the first consonant .", "partition": "test"}
{"idx": "1399", "code": "@Override public String toString(){\n  return getTitle();\n}\n", "docstring": "tostring . used for jcombobox in movie editor", "partition": "test"}
{"idx": "1476", "code": "public ISO9796d2PSSSigner(AsymmetricBlockCipher cipher,Digest digest,int saltLength,boolean implicit){\n  this.cipher=cipher;\n  this.digest=digest;\n  this.hLen=digest.getDigestSize();\n  this.saltLength=saltLength;\n  if (implicit) {\n    trailer=TRAILER_IMPLICIT;\n  }\n else {\n    Integer trailerObj=(Integer)trailerMap.get(digest.getAlgorithmName());\n    if (trailerObj != null) {\n      trailer=trailerObj.intValue();\n    }\n else {\n      throw new IllegalArgumentException(\"no valid trailer for digest\");\n    }\n  }\n}\n", "docstring": "generate a signer for the with either implicit or explicit trailers for iso9796 - 2 , scheme 2 or 3 .", "partition": "test"}
{"idx": "3371", "code": "public String[] showVersion() throws NetworkDeviceControllerException {\n  String[] returnVal=new String[2];\n  SSHPrompt[] prompts={SSHPrompt.MDS_POUND,SSHPrompt.MDS_GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  SSHPrompt prompt=sendWaitFor(MDSDialogProperties.getString(\"MDSDialog.showVersion.cmd\"),10000,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showVersion.version.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.MDS.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.Nexus.match\")};\n  String[] groups=new String[2];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      returnVal[1]=groups[0];\n    break;\ncase 1:\n  returnVal[0]=groups[0];\nbreak;\ncase 2:\nreturnVal[0]=groups[0];\nbreak;\n}\n}\nreturn returnVal;\n}\n", "docstring": "returns the device type and software version", "partition": "test"}
{"idx": "4240", "code": "public void importFromChange(Change sourceChange){\n  if (sourceChange.revision() > 0) {\n    this.revisionId=new NumericLiteralImpl(sourceChange.revision());\n  }\n  if (sourceChange.timestamp() != null) {\n    Date date=sourceChange.timestamp();\n    Calendar c=Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"),Locale.ROOT);\n    c.setTime(date);\n    this.lastModified=new LiteralImpl(DatatypeConverter.printDate(c),XMLSchema.DATETIME);\n  }\n}\n", "docstring": "import revision data from change object .", "partition": "test"}
{"idx": "2363", "code": "public static double logOfBase(double number,int base){\n  return Math.log(number) / Math.log(base);\n}\n", "docstring": "gets the log at a certain base of a number .", "partition": "test"}
{"idx": "3345", "code": "public KafkaMessageListenerContainer(ConsumerFactory<K,V> consumerFactory,ContainerProperties containerProperties,TopicPartitionInitialOffset... topicPartitions){\n  super(containerProperties);\n  Assert.notNull(consumerFactory,\"A ConsumerFactory must be provided\");\n  this.consumerFactory=consumerFactory;\n  if (topicPartitions != null) {\n    this.topicPartitions=Arrays.copyOf(topicPartitions,topicPartitions.length);\n  }\n else {\n    this.topicPartitions=containerProperties.getTopicPartitions();\n  }\n}\n", "docstring": "construct an instance with the supplied configuration properties and specific topics / partitions / initialoffsets .", "partition": "test"}
{"idx": "648", "code": "public void encodeAndSign(X500Name subject,Signature signature) throws CertificateException, IOException, SignatureException {\n  DerOutputStream out, scratch;\n  byte[] certificateRequestInfo;\n  byte[] sig;\n  if (encoded != null)   throw new SignatureException(\"request is already signed\");\n  this.subject=subject;\n  scratch=new DerOutputStream();\n  scratch.putInteger(BigInteger.ZERO);\n  subject.encode(scratch);\n  scratch.write(subjectPublicKeyInfo.getEncoded());\n  attributeSet.encode(scratch);\n  out=new DerOutputStream();\n  out.write(DerValue.tag_Sequence,scratch);\n  certificateRequestInfo=out.toByteArray();\n  scratch=out;\n  signature.update(certificateRequestInfo,0,certificateRequestInfo.length);\n  sig=signature.sign();\n  AlgorithmId algId=null;\n  try {\n    algId=AlgorithmId.get(signature.getAlgorithm());\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    throw new SignatureException(nsae);\n  }\n  algId.encode(scratch);\n  scratch.putBitString(sig);\n  out=new DerOutputStream();\n  out.write(DerValue.tag_Sequence,scratch);\n  encoded=out.toByteArray();\n}\n", "docstring": "create the signed certificate request . this will later be retrieved in either string or binary format .", "partition": "test"}
{"idx": "3152", "code": "public void addComposite(TransformTreeNode node){\n  parts.add(node);\n}\n", "docstring": "adds a composite operation to the transform node . < p > as soon as a node is added , the transform node is considered a composite operation instead of a primitive transform .", "partition": "test"}
{"idx": "3020", "code": "public static void restorePreviousOutAndErrStream(){\n  if (!alreadyMuted) {\n    return;\n  }\n  System.setOut(latestOut);\n  System.setErr(latestErr);\n  alreadyMuted=false;\n}\n", "docstring": "allow again printing to previous streams that were muted", "partition": "test"}
{"idx": "2261", "code": "protected void drawChartValuesText(Canvas canvas,XYSeries series,XYSeriesRenderer renderer,Paint paint,List<Float> points,int seriesIndex,int startIndex){\n  if (points.size() > 1) {\n    float previousPointX=points.get(0);\n    float previousPointY=points.get(1);\n    for (int k=0; k < points.size(); k+=2) {\n      if (k == 2) {\n        if (Math.abs(points.get(2) - points.get(0)) > renderer.getDisplayChartValuesDistance() || Math.abs(points.get(3) - points.get(1)) > renderer.getDisplayChartValuesDistance()) {\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex)),points.get(0),points.get(1) - renderer.getChartValuesSpacing(),paint,0);\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + 1)),points.get(2),points.get(3) - renderer.getChartValuesSpacing(),paint,0);\n          previousPointX=points.get(2);\n          previousPointY=points.get(3);\n        }\n      }\n else       if (k > 2) {\n        if (Math.abs(points.get(k) - previousPointX) > renderer.getDisplayChartValuesDistance() || Math.abs(points.get(k + 1) - previousPointY) > renderer.getDisplayChartValuesDistance()) {\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + k / 2)),points.get(k),points.get(k + 1) - renderer.getChartValuesSpacing(),paint,0);\n          previousPointX=points.get(k);\n          previousPointY=points.get(k + 1);\n        }\n      }\n    }\n  }\n else {\n    for (int k=0; k < points.size(); k+=2) {\n      drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + k / 2)),points.get(k),points.get(k + 1) - renderer.getChartValuesSpacing(),paint,0);\n    }\n  }\n}\n", "docstring": "the graphical representation of the series values as text .", "partition": "test"}
{"idx": "3192", "code": "public static byte[] readDex(File file) throws IOException {\n  return readDex(file.toPath());\n}\n", "docstring": "read the dex file from file , if the file is a zip file , it will return the content of classes . dex in the zip file .", "partition": "test"}
{"idx": "1828", "code": "@SuppressWarnings(\"deprecation\") public Object readMatrixOld(Element node) throws Exception {\n  weka.core.Matrix matrix;\n  weka.core.matrix.Matrix matrixNew;\n  if (DEBUG) {\n    trace(new Throwable(),node.getAttribute(ATT_NAME));\n  }\n  m_CurrentNode=node;\n  matrixNew=(weka.core.matrix.Matrix)readMatrix(node);\n  matrix=new weka.core.Matrix(matrixNew.getArrayCopy());\n  return matrix;\n}\n", "docstring": "builds the matrix ( old ) from the given dom node .", "partition": "test"}
{"idx": "162", "code": "public static void register(String algorithmURI,Class<? extends SignatureAlgorithmSpi> implementingClass) throws AlgorithmAlreadyRegisteredException, ClassNotFoundException, XMLSignatureException {\n  JavaUtils.checkRegisterPermission();\n  if (log.isLoggable(java.util.logging.Level.FINE)) {\n    log.log(java.util.logging.Level.FINE,\"Try to register \" + algorithmURI + \" \"+ implementingClass);\n  }\n  Class<? extends SignatureAlgorithmSpi> registeredClass=algorithmHash.get(algorithmURI);\n  if (registeredClass != null) {\n    Object exArgs[]={algorithmURI,registeredClass};\n    throw new AlgorithmAlreadyRegisteredException(\"algorithm.alreadyRegistered\",exArgs);\n  }\n  algorithmHash.put(algorithmURI,implementingClass);\n}\n", "docstring": "registers implementing class of the transform algorithm with algorithmuri", "partition": "test"}
{"idx": "1223", "code": "public void clearOnCentralPositionChangedListener(){\n  mOnCentralPositionChangedListeners.clear();\n}\n", "docstring": "clear all listeners that listening the central item of the list changes event .", "partition": "test"}
{"idx": "926", "code": "public void putStyle(String styleId,StyleSelector styleSelector){\n  try {\n    int id=Integer.parseInt(styleId);\n    mMaxStyleId=Math.max(mMaxStyleId,id);\n  }\n catch (  NumberFormatException e) {\n  }\n  mStyles.put(styleId,styleSelector);\n}\n", "docstring": "put the styleselector ( style or stylemap ) in the list of shared styles , associated to its styleid", "partition": "test"}
{"idx": "2748", "code": "public Object apply(String source,int lineNo,int columnNo,Object funcBody,Vector paramNames,Vector arguments) throws BSFException {\n  Object object=eval(source,lineNo,columnNo,funcBody);\n  if (object instanceof Closure) {\n    Closure closure=(Closure)object;\n    return closure.call(arguments.toArray());\n  }\n  return object;\n}\n", "docstring": "allow an anonymous function to be declared and invoked", "partition": "test"}
{"idx": "2533", "code": "public void addLast(StatementSequence statements){\n  if (statements != null) {\n    sequence.addAll(statements.sequence);\n  }\n}\n", "docstring": "adds a sequence of statements to the end of this sequence when the sequence object is not null , otherwise does nothing .", "partition": "test"}
{"idx": "1818", "code": "private static List<Vector2D> buildQuadrilateral(final Vector2D... points){\n  List<Vector2D> quadrilateral=new ArrayList<Vector2D>();\n  for (  Vector2D p : points) {\n    if (!quadrilateral.contains(p)) {\n      quadrilateral.add(p);\n    }\n  }\n  return quadrilateral;\n}\n", "docstring": "build the convex quadrilateral with the found corner points ( with min / max x / y coordinates ) .", "partition": "test"}
{"idx": "379", "code": "private static String padRight(String s,int minLength){\n  return String.format(\"%1$-\" + minLength + \"s\",s);\n}\n", "docstring": "adds padding to the end of a string with a repeating character if the string \"'\" s length is less than the minimum length", "partition": "test"}
{"idx": "3404", "code": "public <T extends IntentionAction & LocalQuickFix>void registerBatchFix(@NotNull T fix,@Nullable TextRange range,@Nullable final HighlightDisplayKey key){\n  if (range == null) {\n    range=new TextRange(myStartOffset,myEndOffset);\n  }\n  if (myBatchFixes == null) {\n    myBatchFixes=new ArrayList<QuickFixInfo>();\n  }\n  myBatchFixes.add(new QuickFixInfo(fix,range,key));\n}\n", "docstring": "registers a quickfix which would be available during batch mode only , in particular during com . intellij . codeinspection . defaulthighlightvisitorbasedinspection run", "partition": "test"}
{"idx": "2175", "code": "public static PersistentSearchRequestControl newControl(final boolean isCritical,final boolean changesOnly,final boolean returnECs,final PersistentSearchChangeType... changeTypes){\n  Reject.ifNull((Object)changeTypes);\n  return newControl(isCritical,changesOnly,returnECs,Arrays.asList(changeTypes));\n}\n", "docstring": "creates a new persistent search request control .", "partition": "test"}
{"idx": "1226", "code": "public static boolean isStanza(Packet packet){\n  if (packet instanceof Message)   return true;\n  if (packet instanceof IQ)   return true;\n  if (packet instanceof Presence)   return true;\n  return false;\n}\n", "docstring": "returns true if the packet is a stanza as defined in rfc - 6121 - a message , iq or presence packet .", "partition": "test"}
{"idx": "3461", "code": "static void updateStyle(JTextComponent c,SeaGlassContext context,String prefix){\n  SeaGlassStyle style=(SeaGlassStyle)context.getStyle();\n  Color color=c.getCaretColor();\n  if (color == null || color instanceof UIResource) {\n    c.setCaretColor((Color)style.get(context,prefix + \".caretForeground\"));\n  }\n  Color fg=c.getForeground();\n  if (fg == null || fg instanceof UIResource) {\n    fg=style.getColorForState(context,ColorType.TEXT_FOREGROUND);\n    if (fg != null) {\n      c.setForeground(fg);\n    }\n  }\n  Object ar=style.get(context,prefix + \".caretAspectRatio\");\n  if (ar instanceof Number) {\n    c.putClientProperty(\"caretAspectRatio\",ar);\n  }\n  context.setComponentState(SELECTED | FOCUSED);\n  Color s=c.getSelectionColor();\n  if (s == null || s instanceof UIResource) {\n    c.setSelectionColor(style.getColor(context,ColorType.TEXT_BACKGROUND));\n  }\n  Color sfg=c.getSelectedTextColor();\n  if (sfg == null || sfg instanceof UIResource) {\n    c.setSelectedTextColor(style.getColor(context,ColorType.TEXT_FOREGROUND));\n  }\n  context.setComponentState(DISABLED);\n  Color dfg=c.getDisabledTextColor();\n  if (dfg == null || dfg instanceof UIResource) {\n    c.setDisabledTextColor(style.getColor(context,ColorType.TEXT_FOREGROUND));\n  }\n  Insets margin=c.getMargin();\n  if (margin == null || margin instanceof UIResource) {\n    margin=(Insets)style.get(context,prefix + \".margin\");\n    if (margin == null) {\n      margin=SeaGlassLookAndFeel.EMPTY_UIRESOURCE_INSETS;\n    }\n    c.setMargin(margin);\n  }\n  Caret caret=c.getCaret();\n  if (caret instanceof UIResource) {\n    Object o=style.get(context,prefix + \".caretBlinkRate\");\n    if (o != null && o instanceof Integer) {\n      Integer rate=(Integer)o;\n      caret.setBlinkRate(rate.intValue());\n    }\n  }\n}\n", "docstring": "private method to update styles .", "partition": "test"}
{"idx": "3719", "code": "public void removeRequest(InterruptRequest interruptRequest){\nsynchronized (interruptRequestQueue) {\n    interruptRequestQueue.remove(interruptRequest);\n  }\n}\n", "docstring": "this is the way to remove a specific request object", "partition": "test"}
{"idx": "4247", "code": "public static Object convertToParameterValues(Object object){\n  Collection<Object> collection;\n  if (object instanceof Object[]) {\n    collection=Arrays.asList((Object[])object);\n  }\n else   if (object instanceof Collection) {\n    collection=(Collection<Object>)object;\n  }\n else {\n    LOGGER.warn(\"Unable to convert value, ignoring\");\n    return new Object[]{};\n  }\n  List<Object> s=new LinkedList<Object>();\n  for (  Object o : collection) {\n    Object converted=convertToParameterValue(o);\n    if (converted instanceof Object[]) {\n      s.addAll(Arrays.asList((Object[])converted));\n    }\n else {\n      s.add(converted);\n    }\n  }\n  return s.toArray(new Object[s.size()]);\n}\n", "docstring": "converts an array / collection of values ( the object ) to a parameter values array . resources should not be converted . use via converttoparametervalue ( to deal with non - lists )", "partition": "test"}
{"idx": "4053", "code": "public Token nextRegex(Pattern pattern){\n  if (!hasNextRegex(pattern))   throw new IllegalStateException(\"No more occurrences found!\");\n  Matcher matcher=anyMentionPattern.matcher(remaining);\n  if (!matcher.find())   throw new IllegalStateException(\"Couldn\\'t find any matches!\");\n  final int start=currentPosition + matcher.start();\n  final int end=currentPosition + matcher.end();\n  stepTo(end);\n  return new Token(this,start,end);\n}\n", "docstring": "returns the next occurrence of the regular expression , stepping forward the tokenizer to the next line .", "partition": "test"}
{"idx": "1094", "code": "public void invalidateAndUnmap(ByteBuffer... bufs) throws IOException {\n  if (cleaner != null) {\n    invalidated=true;\n    barrier.lazySet(0);\n    Thread.yield();\n    for (    ByteBuffer b : bufs) {\n      cleaner.freeBuffer(resourceDescription,b);\n    }\n  }\n}\n", "docstring": "invalidates this guard and unmaps ( if supported ) .", "partition": "test"}
{"idx": "3065", "code": "public T allowedUsers(User... users){\n  List<User> usersList=Arrays.asList(users);\n  this.userPredicate=null;\n  return instance();\n}\n", "docstring": "allow a list of users to use this menu", "partition": "test"}
{"idx": "1180", "code": "public int evalRPN(String[] tokens){\n  if (tokens == null || tokens.length == 0)   return 0;\n  Stack<String> s=new Stack<String>();\n  int len=tokens.length;\n  for (int i=0; i < len; i++) {\n    String cur=tokens[i];\n    if (isOperator(cur)) {\n      int t2=Integer.parseInt(s.pop());\n      int t1=Integer.parseInt(s.pop());\n      int res=calculate(t1,t2,cur);\n      s.push(Integer.toString(res));\n    }\n else     s.push(cur);\n  }\n  return Integer.valueOf(s.peek());\n}\n", "docstring": "assign a priority for each operators use a stack to store them note the numbers can be negative we evaluate the expression left - to - right and push operands onto the stack until we encounter an operator , which we pop the top two values from the stack . we then evaluate the operator , with the values as arguments and push the result back onto the stack .", "partition": "test"}
{"idx": "2703", "code": "private double mean(double[] vec){\n  double result=0;\n  for (int i=0; i < vec.length; i++)   result+=vec[i];\n  return result / vec.length;\n}\n", "docstring": "the mean of the values in the double array", "partition": "test"}
{"idx": "27", "code": "public void updateView(){\n  if (fInputElement != null && fParentComposite != null) {\n    IndicatorViewState oldState=fStateMap.get(fInputElement);\n    boolean reload=fFilesToReoad.contains(fInputElement);\n    if (reload || oldState == null) {\n      JsonObject jsonObject=DroidsafePluginUtilities.parseIndicatorFile(fInputElement);\n      if (jsonObject == null)       return;\n      fFilesToReoad.remove(fInputElement);\n      fState=new IndicatorViewState(fInputElement,jsonObject,getSecuritySpec(),oldState);\n      fStateMap.put(fInputElement,fState);\n    }\n else {\n      fState=oldState;\n    }\n    setPartName(fState.indicatorType);\n    showPage(PAGE_VIEWER);\n    fTreeViewer.setInput(fState.jsonObject);\n    if (fTreeViewer.getSorter() == null)     sortByField(getSortByField());\n  }\n else {\n    setPartName(DEFAULT_PART_NAME);\n  }\n}\n", "docstring": "update the content of the outline view .", "partition": "test"}
{"idx": "2396", "code": "public LDIFEntryReader(final String... ldifLines){\n  super(Arrays.asList(ldifLines));\n}\n", "docstring": "creates a new ldif entry reader which will read lines of ldif from the provided array of ldif lines .", "partition": "test"}
{"idx": "4213", "code": "public void addAll(OVector v){\n  expandFor(size + v.size - 1,null);\n  System.arraycopy(v.vector,0,vector,size - v.size,v.size);\n}\n", "docstring": "adds all the values in the given vector to the end of this vector , expanding its capacity as necessary .", "partition": "test"}
{"idx": "390", "code": "public boolean isStable(){\n  return myFeatures.contains(FEATURE_STABLE);\n}\n", "docstring": "returns true if gapis is considered stable ( non - experimental ) :", "partition": "test"}
{"idx": "1949", "code": "public static UiResult openUrl(URI uri){\n  return openUrl(uri.toString());\n}\n", "docstring": "launch url in a new window .", "partition": "test"}
{"idx": "1103", "code": "public static @CheckForNull @SlashedClassName String fromFieldSignature(String signature){\n  if (signature.charAt(0) != 'L') {\n    return null;\n  }\n  return signature.substring(1,signature.length() - 1);\n}\n", "docstring": "converts from signature to slashed class name ( e . g . , from ljava / lang / string ; to java / lang / string ) . returns null if it is the signature for an array or primitive type .", "partition": "test"}
{"idx": "2904", "code": "public ClassAnnotator(URL[] codebase,Properties props){\n  if (props != null)   properties.putAll(props);\n  setAnnotationURLs(codebase);\n}\n", "docstring": "constructs a new classannotator for the specified codebase urls", "partition": "test"}
{"idx": "529", "code": "private void checkBucketName(String name) throws InvalidBucketNameException {\n  if (name == null) {\n    throw new InvalidBucketNameException(NULL_STRING,\"null bucket name\");\n  }\n  if (name.length() < 3 || name.length() > 63) {\n    String msg=\"bucket name must be at least 3 and no more than 63 characters long\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n  if (name.matches(\"\\\\\\\\.\\\\\\\\.\")) {\n    String msg=\"bucket name cannot contain successive periods. For more information refer \" + \"http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n  if (!name.matches(\"^[a-z0-9][a-z0-9\\\\\\\\.\\\\\\\\-]+[a-z0-9]$\")) {\n    String msg=\"bucket name does not follow Amazon S3 standards. For more information refer \" + \"http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n}\n", "docstring": "validates if given bucket name is dns compatible .", "partition": "test"}
{"idx": "3229", "code": "public double norm(){\n  double sum=0;\n  for (int i=0; i < components.length; i++)   sum+=components[i] * components[i];\n  return Math.sqrt(sum);\n}\n", "docstring": "computes the norm of a vector .", "partition": "test"}
{"idx": "928", "code": "public static <T>FastFuture<T> fromCompletableFuture(final CompletableFuture<T> cf){\n  final FastFuture<T> f=new FastFuture<>();\n  cf.thenAccept(null);\n  cf.exceptionally(null);\n  return f;\n}\n", "docstring": "internal conversion method to convert completablefutures to fastfuture .", "partition": "test"}
{"idx": "1738", "code": "public PutIndexTemplateRequest mapping(String type,Object... source){\n  mapping(type,PutMappingRequest.buildFromSimplifiedDef(type,source));\n  return this;\n}\n", "docstring": "a specialized simplified mapping source method , takes the form of simple properties definition : ( \" field1 \" , \" type = string , store = true \" ) .", "partition": "test"}
{"idx": "3894", "code": "public ProjectImporter(final File rootFolder){\n  assertNotNull(\"Root folder cannot be null.\",rootFolder);\n  assertTrue(\"Root folder does not exist: \" + rootFolder,rootFolder.exists());\n  assertTrue(\"Root folder must be a folder. But was a file: \" + rootFolder,rootFolder.isDirectory());\n  assertTrue(\"Root folder directory content cannot be read: \" + rootFolder,rootFolder.canRead());\n  assertTrue(\"No files were found in the directory: \" + rootFolder,null != rootFolder.listFiles());\n  this.rootFolder=rootFolder;\n}\n", "docstring": "creates a project importer with the root folder of all projects that has to be imported for the test .", "partition": "test"}
{"idx": "232", "code": "public void checkBackupInfo(final File backupInfoFile,boolean backupInMultiVdc){\n  try (InputStream fis=new FileInputStream(backupInfoFile)){\n    Properties properties=new Properties();\n    properties.load(fis);\n    checkVersion(properties);\n    checkHosts(properties,backupInMultiVdc);\n  }\n catch (  IOException ex) {\n    log.warn(\"Unable to check backup Info\",ex);\n  }\n}\n", "docstring": "checks version and ips", "partition": "test"}
{"idx": "117", "code": "public final static NameValuePair parseNameValuePair(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=SaveHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  SaveParserCursor cursor=new SaveParserCursor(0,value.length());\n  return parser.parseNameValuePair(buffer,cursor);\n}\n", "docstring": "parses a name - value - pair with the given parser .", "partition": "test"}
{"idx": "2384", "code": "@Deprecated public static NetworkParameters testNet(){\n  return TestNet3Params.get();\n}\n", "docstring": "alias for testnet3params . get ( ) , use that instead .", "partition": "test"}
{"idx": "2589", "code": "public boolean handleFile(File file){\n  if (DEBUG) {\n    logger.fine(\"searching finds: \" + file.getAbsolutePath());\n  }\n  filenames.add(file);\n  return true;\n}\n", "docstring": "when a file is found , add it .", "partition": "test"}
{"idx": "633", "code": "public boolean isToRead(){\n  Iterator<VariableValue> i=variables.iterator();\n  while (i.hasNext()) {\n    VariableValue v=i.next();\n    if (v.isToRead()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "this variable needs to be read if any of it \"'\" s subsidiary variables needs to be read .", "partition": "test"}
{"idx": "227", "code": "public void record(RecordBuilderImpl recordBuilder){\n  storeBitmap(recordBuilder);\n  OutputStream viewHierarchyDump=null;\n  try {\n    viewHierarchyDump=mAlbum.openViewHierarchyFile(recordBuilder.getName());\n    mViewHierarchy.deflate(recordBuilder.getView(),viewHierarchyDump);\n    mAlbum.addRecord(recordBuilder);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    if (viewHierarchyDump != null) {\n      try {\n        viewHierarchyDump.close();\n      }\n catch (      IOException e) {\n        Log.e(\"ScreenshotImpl\",\"Exception closing viewHierarchyDump\",e);\n      }\n    }\n  }\n}\n", "docstring": "records the recordbuilderimpl , and verifies if required", "partition": "test"}
{"idx": "783", "code": "private Configuration prepareJobForCancelling() throws Exception {\n  prepareFile(\"/testFile\",1500);\n  executedTasks.set(0);\n  cancelledTasks.set(0);\n  failMapperId.set(0);\n  splitsCount.set(0);\n  Configuration cfg=new Configuration();\n  setupFileSystems(cfg);\n  Job job=Job.getInstance(cfg);\n  job.setOutputKeyClass(Text.class);\n  job.setOutputValueClass(IntWritable.class);\n  job.setMapperClass(CancellingTestMapper.class);\n  job.setNumReduceTasks(0);\n  job.setInputFormatClass(InFormat.class);\n  FileInputFormat.setInputPaths(job,new Path(\"igfs://:\" + getTestGridName(0) + \"@/\"));\n  FileOutputFormat.setOutputPath(job,new Path(\"igfs://:\" + getTestGridName(0) + \"@/output/\"));\n  job.setJarByClass(getClass());\n  return job.getConfiguration();\n}\n", "docstring": "prepare job with mappers to cancel .", "partition": "test"}
{"idx": "453", "code": "public static boolean isAccessorPair(TMember member,TMember member2){\n  return (member instanceof TGetter && member2 instanceof TSetter) || (member instanceof TSetter && member2 instanceof TGetter);\n}\n", "docstring": "returns true if one of the members is a getter and the other one is a setter . no further validation such as name or owner comparison is done as this is expected to be done in the client already .", "partition": "test"}
{"idx": "3775", "code": "public static String formatDateTime(java.util.Date date,String format,String locale,String timeZone){\n  SimpleDateFormat dateFormat=getDateFormat(format,locale,timeZone);\nsynchronized (dateFormat) {\n    return dateFormat.format(date);\n  }\n}\n", "docstring": "formats a date using a format string .", "partition": "test"}
{"idx": "4064", "code": "public void deleteItem(int position){\n  if (!isDataListEmpty() && position >= 0 && position < mDataList.size()) {\n    mDataList.remove(position);\n    notifyItemRemoved(position);\n  }\n}\n", "docstring": "delete an item by position", "partition": "test"}
{"idx": "1856", "code": "public static Coordinate ptNotInList(Coordinate[] testPts,Coordinate[] pts){\n  for (int i=0; i < testPts.length; i++) {\n    Coordinate testPt=testPts[i];\n    if (!isInList(testPt,pts))     return testPt;\n  }\n  return null;\n}\n", "docstring": "finds a point in a list of points which is not contained in another list of points", "partition": "test"}
{"idx": "2422", "code": "private int parseLinkLabel(){\n  String m=match(LINK_LABEL);\n  return m == null ? 0 : m.length();\n}\n", "docstring": "attempt to parse a link label , returning number of characters parsed .", "partition": "test"}
{"idx": "413", "code": "public static List<BatchResponse> postWithSingleRequest(final RequestSpecification requestSpec,final ResponseSpecification responseSpec,final BatchRequest br){\n  final List<BatchRequest> batchRequests=new ArrayList<>();\n  batchRequests.add(br);\n  final String jsonifiedRequest=BatchHelper.toJsonString(batchRequests);\n  final List<BatchResponse> response=BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,responseSpec,jsonifiedRequest);\n  Assert.assertNotNull(response);\n  Assert.assertTrue(response.size() > 0);\n  return response;\n}\n", "docstring": "returns a batchresponse based on the given batchrequest , by posting the request to the server .", "partition": "test"}
{"idx": "3467", "code": "public static Number asNumber(String value,Supplier<Number> defaultValueProvider){\n  if (value != null) {\n    try {\n      return Short.valueOf(value);\n    }\n catch (    NumberFormatException e1) {\n      try {\n        return Integer.valueOf(value);\n      }\n catch (      NumberFormatException e2) {\n        try {\n          return Long.valueOf(value);\n        }\n catch (        NumberFormatException e3) {\n          try {\n            return Float.valueOf(value);\n          }\n catch (          NumberFormatException e4) {\n            try {\n              return Double.valueOf(value);\n            }\n catch (            NumberFormatException e5) {\n              try {\n                return new BigInteger(value);\n              }\n catch (              NumberFormatException e6) {\n                try {\n                  return new BigDecimal(value);\n                }\n catch (                NumberFormatException e7) {\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return defaultValueProvider != null ? defaultValueProvider.get() : null;\n}\n", "docstring": "parse the supplied string as a number .", "partition": "test"}
{"idx": "1773", "code": "private static void sort1(int[] x,int off,int len){\n  if (len < 7) {\n    for (int i=off; i < len + off; i++)     for (int j=i; j > off && x[j - 1] > x[j]; j--)     swap(x,j,j - 1);\n    return;\n  }\n  int m=off + (len >> 1);\n  if (len > 7) {\n    int l=off;\n    int n=off + len - 1;\n    if (len > 40) {\n      int s=len / 8;\n      l=med3(x,l,l + s,l + 2 * s);\n      m=med3(x,m - s,m,m + s);\n      n=med3(x,n - 2 * s,n - s,n);\n    }\n    m=med3(x,l,m,n);\n  }\n  int v=x[m];\n  int a=off, b=a, c=off + len - 1, d=c;\n  while (true) {\n    while (b <= c && x[b] <= v) {\n      if (x[b] == v)       swap(x,a++,b);\n      b++;\n    }\n    while (c >= b && x[c] >= v) {\n      if (x[c] == v)       swap(x,c,d--);\n      c--;\n    }\n    if (b > c)     break;\n    swap(x,b++,c--);\n  }\n  int s, n=off + len;\n  s=Math.min(a - off,b - a);\n  vecswap(x,off,b - s,s);\n  s=Math.min(d - c,n - d - 1);\n  vecswap(x,b,n - s,s);\n  if ((s=b - a) > 1)   sort1(x,off,s);\n  if ((s=d - c) > 1)   sort1(x,n - s,s);\n}\n", "docstring": "sorts the specified sub - array of integers into ascending order .", "partition": "test"}
{"idx": "2977", "code": "protected void engineUpdate(byte b) throws SignatureException {\n  messageDigest.update(b);\n  needsReset=true;\n}\n", "docstring": "updates the data to be signed or verified using the specified byte .", "partition": "test"}
{"idx": "2028", "code": "public Collection<Node> matchingScenariosAndExamples(final Feature feature){\n  final List<ScenarioDefinition> allScenarios=feature.getScenarioDefinitions();\n  final List<Node> matchingScenariosAndExamples=new LinkedList<Node>();\n  for (  final ScenarioDefinition scenario : allScenarios) {\n    final Set<Tag> allTagsForScenario=new HashSet<Tag>(scenario.getTags());\n    allTagsForScenario.addAll(feature.getTags());\n    if (scenario instanceof ScenarioOutline) {\n      matchingScenariosAndExamples.addAll(matchingExamples((ScenarioOutline)scenario,allTagsForScenario));\n    }\n else {\n      if (matches(allTagsForScenario)) {\n        matchingScenariosAndExamples.add(scenario);\n      }\n    }\n  }\n  return matchingScenariosAndExamples;\n}\n", "docstring": "find the scenarios that match the required tags in the feature .", "partition": "test"}
{"idx": "692", "code": "public static void registerDecayableObject(Decayable obj){\n  decayObjects.add(obj);\n}\n", "docstring": "registers an object that should be decayed . the passed object will have its decay method called when the decaying thread decides it is time for the system to decay .", "partition": "test"}
{"idx": "2975", "code": "public static boolean hasSuppressed(@Nullable Throwable t,@Nullable Class<? extends Throwable> cls){\n  if (t == null || cls == null)   return false;\n  if (t.getSuppressed() != null) {\n    for (    Throwable th : t.getSuppressed()) {\n      if (cls.isAssignableFrom(th.getClass()))       return true;\n      if (hasSuppressed(th,cls))       return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if passed throwable has given class in one of the suppressed exceptions .", "partition": "test"}
{"idx": "1787", "code": "public void writeField(final String name,final float value) throws java.io.IOException {\n  writeField(name,Float.toString(value));\n}\n", "docstring": "writes an float field value .", "partition": "test"}
{"idx": "4028", "code": "public ScriptBuilder data(byte[] data){\n  if (data.length == 0)   return smallNum(0);\n else   return data(chunks.size(),data);\n}\n", "docstring": "adds a copy of the given byte array as a data element ( i . e . pushdata ) at the end of the program .", "partition": "test"}
{"idx": "3141", "code": "protected abstract C newParcelableAdapterInstance(List<Object> items);\n", "docstring": "create a new instance of your parcelableadapter using the provided list of items .", "partition": "test"}
{"idx": "1641", "code": "HttpRequestWrapper(HttpServletRequest request){\n  super(request);\n}\n", "docstring": "constructs a request object wrapping the given request .", "partition": "test"}
{"idx": "2631", "code": "public MultiplexManager(DataStore... dataStores){\n  this.dataStores=Arrays.asList(dataStores);\n}\n", "docstring": "create a single datastore to handle provided managers within a single transaction .", "partition": "test"}
{"idx": "3483", "code": "public static LowMemoryWatcher register(@NotNull Runnable runnable){\n  return new LowMemoryWatcher(runnable);\n}\n", "docstring": "registers a runnable to run on low memory events", "partition": "test"}
{"idx": "701", "code": "@Override @Timed public void deleteAssignment(Experiment experiment,User.ID userID,Context context,Application.Name appName,Assignment currentAssignment){\n  deleteUserFromLookUp(experiment.getID(),userID,context);\n  boolean countUp=false;\n  assignmentsCountExecutor.execute(new AssignmentCountEnvelope(assignmentsRepository,experimentRepository,dbRepository,experiment,currentAssignment,countUp,eventLog,null,assignUserToExport,assignBucketCount));\n  deleteAssignmentOld(experiment.getID(),userID,context,appName,currentAssignment.getBucketLabel());\n  removeIndexUserToExperiment(userID,experiment.getID(),context,appName);\n  removeIndexUserToBucket(userID,experiment.getID(),context,currentAssignment.getBucketLabel());\n  removeIndexExperimentsToUser(userID,experiment.getID(),context,appName);\n}\n", "docstring": "deletes the existing assignment between a user and an experiment .", "partition": "test"}
{"idx": "3958", "code": "public static void delete(Path path){\n  if (path != null) {\n    path=path.toAbsolutePath();\n    if (inTargetDir(path)) {\n      try {\n        IoUtil.delete(path);\n      }\n catch (      IOException e) {\n        printError(\"Unable to remove \\'\" + path.toAbsolutePath() + \"\\'\",e);\n      }\n    }\n else {\n      printError(\"Will not remove directory that is outside test target area: \" + path);\n    }\n  }\n}\n", "docstring": "a method that will delete a file or folder only if it is within the \"'\" target \"'\" directory ( for safety ) . folders are removed recursively .", "partition": "test"}
{"idx": "2808", "code": "public UniformDistribution estimate(double min,double max,final int count){\n  double grow=(count > 1) ? 0.5 * (max - min) / (count - 1) : 0.;\n  return new UniformDistribution(Math.max(min - grow,-Double.MAX_VALUE),Math.min(max + grow,Double.MAX_VALUE));\n}\n", "docstring": "estimate from simple characteristics .", "partition": "test"}
{"idx": "580", "code": "public boolean step(){\n  long current=System.currentTimeMillis();\n  if (mStart == 0 || (current - mStart < 0)) {\n    mProgress=0;\n  }\n else   if (current - mStart > mDuration) {\n    if (mLoop) {\n      mProgress=0;\n      start();\n      return true;\n    }\n    mProgress=1;\n    return false;\n  }\n else {\n    mProgress=(current - mStart) / (double)mDuration;\n  }\n  return true;\n}\n", "docstring": "step in the animation . will compute the current progress as well .", "partition": "test"}
{"idx": "2095", "code": "void ReconstructPrivateSubrs(int Font,IndexBaseItem[] fdPrivateBase,OffsetItem[] fdSubrs){\n  for (int i=0; i < fonts[Font].fdprivateLengths.length; i++) {\n    if (fdSubrs[i] != null && fonts[Font].PrivateSubrsOffset[i] >= 0) {\n      OutputList.addLast(new SubrMarkerItem(fdSubrs[i],fdPrivateBase[i]));\n      if (NewLSubrsIndex[i] != null)       OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(rasFactory.createSource(NewLSubrsIndex[i])),0,NewLSubrsIndex[i].length));\n    }\n  }\n}\n", "docstring": "function adds the new lsubrs dicts ( only for the fds used ) to the list", "partition": "test"}
{"idx": "3682", "code": "public int read(byte[] b) throws java.io.IOException {\n  return read(b,0,b.length);\n}\n", "docstring": "reads some number of bytes from the input stream and stores them into the buffer array b . the number of bytes actually read is returned as an integer . this method blocks until input data is available , end of file is detected , or an exception is thrown . if b is null , a nullpointerexception is thrown . if the length of b is zero , then no bytes are read and 0 is returned ; otherwise , there is an attempt to read at least one byte . if no byte is available because the stream is at end of file , the value - 1 is returned ; otherwise , at least one byte is read and stored into b . the first byte read is stored into element b [ 0 ", "partition": "test"}
{"idx": "1397", "code": "public RepositoryLocation(String repositoryName,String[] pathComponents) throws MalformedRepositoryLocationException {\n  if (repositoryName == null || repositoryName.isEmpty()) {\n    throw new MalformedRepositoryLocationException(\"repositoryName must not contain null or empty!\");\n  }\n  if (pathComponents == null) {\n    throw new MalformedRepositoryLocationException(\"pathComponents must not be null!\");\n  }\n  for (  String pathComp : pathComponents) {\n    if (pathComp == null || pathComp.isEmpty()) {\n      throw new MalformedRepositoryLocationException(\"path must not contain null or empty strings!\");\n    }\n  }\n  this.repositoryName=repositoryName;\n  this.path=pathComponents;\n}\n", "docstring": "creates a repositorylocation for a given repository and a set of path components which will be concatenated by a / .", "partition": "test"}
{"idx": "1802", "code": "@Override public void openElement(String tagName){\n  XMLElement newElement=new XMLElement();\n  newElement.setName(tagName);\n  current.addChild(newElement);\n  stack.push(current);\n  current=newElement;\n}\n", "docstring": "puts a new element into the dom document . the new element is added as a child to the current element in the dom document . then it becomes the current element . the element must be closed using closeelement .", "partition": "test"}
{"idx": "2716", "code": "public static List<String> splitPath(File file){\n  List<String> output=new ArrayList<>();\n  File current=file;\n  while (current != null) {\n    output.add(current.getName());\n    current=current.getParentFile();\n  }\n  Collections.reverse(output);\n  return output;\n}\n", "docstring": "split a file into a list of directories ending with the file name", "partition": "test"}
{"idx": "3842", "code": "public void testConstructorSignBytesZeroNull2(){\n  byte aBytes[]={};\n  int aSign=0;\n  byte rBytes[]={0};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=aNumber.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",0,aNumber.signum());\n}\n", "docstring": "create a zero number from a sign and an array of zero length . the sign is 0 .", "partition": "test"}
{"idx": "3399", "code": "void internalAddRootEntry(ProjectComparisonEntry entry){\n  entries.add(entry);\n}\n", "docstring": "should only be invoked from projectcomparisonentry", "partition": "test"}
{"idx": "3608", "code": "@Override public List<Period> generateRollingPeriods(DateTimeUnit dateTimeUnit){\n  Calendar cal=getCalendar();\n  dateTimeUnit.setDay(1);\n  dateTimeUnit=cal.minusMonths(dateTimeUnit,11);\n  List<Period> periods=Lists.newArrayList();\n  for (int i=0; i < 12; i++) {\n    periods.add(createPeriod(dateTimeUnit,cal));\n    dateTimeUnit=cal.plusMonths(dateTimeUnit,1);\n  }\n  return periods;\n}\n", "docstring": "generates the last 12 months where the last one is the month which the given date is inside .", "partition": "test"}
{"idx": "917", "code": "private boolean hasNewFollowers(List<Follower> followers){\n  return !followers.isEmpty() && followers.get(0).newFollower;\n}\n", "docstring": "checks if this has new followers . only checks the first follower in the list , because followers at the end might be new , even though they actually are not ( if someone unfollows , older followers might show up for the first time this session ) .", "partition": "test"}
{"idx": "3760", "code": "public void schedule(TimerTask task,long delay){\n  if (delay < 0)   throw new IllegalArgumentException(\"Negative delay.\");\n  sched(task,System.currentTimeMillis() + delay,0);\n}\n", "docstring": "schedules the specified task for execution after the specified delay .", "partition": "test"}
{"idx": "974", "code": "private void verifyBlockMirrorMigration() throws Exception {\n  log.info(\"Verifying BlockMirror migration.\");\n  Iterator<BlockMirror> blockMirrorItr=_dbClient.queryIterativeObjects(BlockMirror.class,blockMirrorURIs);\n  List<BlockObject> blockObjects=new ArrayList<BlockObject>();\n  while (blockMirrorItr.hasNext()) {\n    blockObjects.add(blockMirrorItr.next());\n  }\n  verifyBlockObjects(blockObjects);\n}\n", "docstring": "verify the blockmirror objects have been migrated correctly .", "partition": "test"}
{"idx": "3749", "code": "public void addParseTemplate(String parseTemplate){\n  parseTemplates.add(parseTemplate);\n}\n", "docstring": "adds a template which should be \" parsed \" while the parsing process .", "partition": "test"}
{"idx": "2254", "code": "void saveAsync(DocumentEntity entity,Consumer<DocumentEntity> callBack) throws ExecuteAsyncQueryException, UnsupportedOperationException ;\n", "docstring": "saves an entity asynchronously", "partition": "test"}
{"idx": "3013", "code": "private void checkWidth(final int[] rect){\n  final int x1=rect[0];\n  final int y2=rect[1];\n  final int y1=y2 + rect[3];\n  final int x2=x1 + rect[2];\n  if (x1 < pageX1) {\n    pageX1=x1;\n  }\n  if (x2 > pageX2) {\n    pageX2=x2;\n  }\n  if (y1 > pageY1) {\n    pageY1=y1;\n  }\n  if (y2 < pageY2) {\n    pageY2=y2;\n  }\n}\n", "docstring": "track actual size of shape", "partition": "test"}
{"idx": "1830", "code": "public CoreTokenException(int errorCode){\n  this.errorCode=errorCode;\n  this.message=getLocalizedMessage(Locale.getDefault());\n}\n", "docstring": "creates a core token service exception .", "partition": "test"}
{"idx": "1723", "code": "private void paintForegroundDisabled(Graphics2D g,int width,int height){\n  Shape s=decodeArrowPath(width,height);\n  g.setPaint(disabledColor);\n  g.fill(s);\n}\n", "docstring": "paint the arrow in disabled state .", "partition": "test"}
{"idx": "2737", "code": "public static void registerTransportMBean(String containerName){\n  MBeanServer mBeanServer=getMBeanServer(containerName);\n  if (mBeanServer == null)   return;\n  TransportProtocolMonitorMBean transportConnectionsInfoMBean=new TransportProtocolMonitor();\n  ObjectName objName=TransportConstants.createTransportMBeanObjectName(containerName);\n  if (!mBeanServer.isRegistered(objName)) {\n    try {\n      mBeanServer.registerMBean(transportConnectionsInfoMBean,objName);\n    }\n catch (    InstanceAlreadyExistsException e) {\n      if (_logger.isLoggable(Level.CONFIG)) {\n        _logger.config(alreadyRegistredTransportMBeanMessage + containerName + \">\");\n      }\n    }\ncatch (    NotCompliantMBeanException e) {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\ncatch (    MBeanRegistrationException e) {\n      if (_logger.isLoggable(Level.SEVERE)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(successfulTransportMBeanRegistrationMessage + containerName + \">\");\n    }\n  }\n else {\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(alreadyRegistredTransportMBeanMessage);\n    }\n  }\n}\n", "docstring": "create management bean for jspace container .", "partition": "test"}
{"idx": "3294", "code": "public static void resetCurrentFileList(String logName){\n  currentFileList.remove(PREFIX + logName);\n}\n", "docstring": "reset the current file list for the logger .", "partition": "test"}
{"idx": "2637", "code": "public String chooseServerAlias(String keyType,Principal[] issuers,Socket socket){\n  return defaultX509KM.chooseServerAlias(keyType,issuers,socket);\n}\n", "docstring": "returns an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .", "partition": "test"}
{"idx": "3131", "code": "protected final void merge(@NotNull Set<LocalResourceRepository> visited,@NotNull ResourceType type,@NotNull SetMultimap<String,String> seenQualifiers,@NotNull ListMultimap<String,ResourceItem> result){\n  if (visited.contains(this)) {\n    return;\n  }\n  visited.add(this);\n  doMerge(visited,type,seenQualifiers,result);\n}\n", "docstring": "if this repository has not already been visited , merge its items of the given type into result .", "partition": "test"}
{"idx": "505", "code": "@Override public boolean isEnabled(){\n  if ((attributeSelectionPanel != null) && !isValueOnly()) {\n    return attributeSelectionPanel.isEnabled();\n  }\n else {\n    if (slider != null) {\n      return slider.isEnabled();\n    }\n  }\n  return false;\n}\n", "docstring": "checks if is enabled .", "partition": "test"}
{"idx": "2216", "code": "protected void writeTransform(AffineTransform t) throws IOException {\n  pageStream.matrix(t);\n}\n", "docstring": "write the given transformation matrix to the file .", "partition": "test"}
{"idx": "3410", "code": "private void sendUpdateHeartbeats(){\n  HeartbeatServiceLocal heartbeat=_bartender.getHeartbeatLocal();\n  if (heartbeat != null) {\n    heartbeat.updateHeartbeats();\n  }\n}\n", "docstring": "send a heartbeat with the updated pods to other servers in the cluster . this call wakes the heartbeat service to send the actual heartbeat .", "partition": "test"}
{"idx": "1741", "code": "public SiteStatusCheckThreadImpl(){\n  super();\n  urlCheckers=new HashMap();\n}\n", "docstring": "constructs a sitestatuscheckthreadimpl object based on the configured parameter com . sun . identity . sitemonitor . sitestatuscheck . class .", "partition": "test"}
{"idx": "1149", "code": "@Override public void increment(double coord,short val){\n  int bin=getBinNr(coord);\n  if (bin < 0) {\n    if (size - bin > data.length) {\n      short[] tmpdata=new short[growSize(data.length,size - bin)];\n      System.arraycopy(data,0,tmpdata,-bin,size);\n      data=tmpdata;\n    }\n else {\n      System.arraycopy(data,0,data,-bin,size);\n      Arrays.fill(data,0,-bin,(short)0);\n    }\n    data[0]=val;\n    assert (data.length >= size - bin);\n    offset-=bin;\n    size-=bin;\n  }\n else   if (bin >= data.length) {\n    short[] tmpdata=new short[growSize(data.length,bin + 1)];\n    System.arraycopy(data,0,tmpdata,0,size);\n    tmpdata[bin]=val;\n    data=tmpdata;\n    size=bin + 1;\n    max=Double.MAX_VALUE;\n  }\n else {\n    if (bin >= size) {\n      size=bin + 1;\n    }\n    data[bin]+=val;\n  }\n}\n", "docstring": "increment the value of a bin .", "partition": "test"}
{"idx": "3067", "code": "static CopyState readCopyState(DataInput in) throws IOException {\n  byte[] infosBytes=new byte[in.readVInt()];\n  in.readBytes(infosBytes,0,infosBytes.length);\n  long gen=in.readVLong();\n  long version=in.readVLong();\n  Map<String,FileMetaData> files=readFilesMetaData(in);\n  int count=in.readVInt();\n  Set<String> completedMergeFiles=new HashSet<>();\n  for (int i=0; i < count; i++) {\n    completedMergeFiles.add(in.readString());\n  }\n  long primaryGen=in.readVLong();\n  return new CopyState(files,version,gen,infosBytes,completedMergeFiles,primaryGen,null);\n}\n", "docstring": "pulls copystate off the wire", "partition": "test"}
{"idx": "737", "code": "protected void smartInsertAfterBracket(IDocument document,DocumentCommand command){\n  if (command.offset == -1 || document.getLength() == 0) {\n    return;\n  }\n  try {\n    int p=(command.offset == document.getLength() ? command.offset - 1 : command.offset);\n    int line=document.getLineOfOffset(p);\n    int start=document.getLineOffset(line);\n    int whiteend=findEndOfWhiteSpace(document,start,command.offset);\n    if (whiteend == command.offset) {\n      int indLine=findMatchingOpenBracket(document,line,command.offset,1);\n      if (indLine != -1 && indLine != line) {\n        StringBuffer replaceText=new StringBuffer(getIndentOfLine(document,indLine));\n        replaceText.append(document.get(whiteend,command.offset - whiteend));\n        replaceText.append(command.text);\n        command.length=command.offset - start;\n        command.offset=start;\n        command.text=replaceText.toString();\n      }\n    }\n  }\n catch (  BadLocationException e) {\n    GWTPluginLog.logError(e);\n  }\n}\n", "docstring": "set the indent of a bracket based on the command provided in the supplied document .", "partition": "test"}
{"idx": "2084", "code": "public void writeLong(long value) throws IOException {\n  checkWritePrimitiveTypes();\n  primitiveTypes.writeLong(value);\n}\n", "docstring": "writes a long ( 64 bit ) to the target stream .", "partition": "test"}
{"idx": "1311", "code": "public void addRoll(MMRandom rng){\n  int result=rng.randomInt(this.faces) + this.min;\n  all.addElement(new Integer(result));\n  this.total+=result;\n  if (keep != -1 && all.size() >= keep) {\n    this.total=0;\n    Collections.sort(all,Collections.reverseOrder());\n    for (int i=0; i < keep; i++) {\n      this.total+=all.get(i);\n    }\n  }\n}\n", "docstring": "add the result from the given rng source .", "partition": "test"}
{"idx": "1518", "code": "public void sendMetric(final String name,final double value){\n  logger.debug(String.format(\"sendMetric(%s, %f)\",name,value));\n  if (telemetryClient != null) {\n    telemetryClient.trackMetric(name,value);\n  }\n}\n", "docstring": "call sendmetric to track the new value of the named metric .", "partition": "test"}
{"idx": "872", "code": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (!(o instanceof PrototypeSize)) {\n    return false;\n  }\n  PrototypeSize size=(PrototypeSize)o;\n  return prototype.equals(size.prototype);\n}\n", "docstring": "indicates whether some other constantsize is \" equal to \" this one .", "partition": "test"}
{"idx": "2456", "code": "public Block(boolean multiPush){\n  this(multiPush,\"block\",null,Arrays.asList(\"scrape-1\",\"scrape-2\"));\n}\n", "docstring": "create a new block with default style at ( startx , starty )", "partition": "test"}
{"idx": "2892", "code": "public boolean isLessThenOrEqualTo(Percent Percent){\n  assertDefined();\n  BigDecimal thisValue=notNull(this);\n  BigDecimal parameter=notNull(Percent);\n  return (thisValue.compareTo(parameter) <= 0);\n}\n", "docstring": "compares two percent objects .", "partition": "test"}
{"idx": "3722", "code": "public static long objectFieldOffset(Field field){\n  return UNSAFE.objectFieldOffset(field);\n}\n", "docstring": "returns object field offset .", "partition": "test"}
{"idx": "2852", "code": "public void swap(int i,int j){\n  x.assertTrue(i < list.size());\n  x.assertTrue(j < list.size());\n  list.set(i,list.set(j,list.get(i)));\n}\n", "docstring": "swaps in place the elements at the specified positions in the specified list . ( if the specified positions are equal , invoking this method leaves the list unchanged . )", "partition": "test"}
{"idx": "1751", "code": "public void removeAddress(AddressEntity address){\n  addresses.remove(address);\n}\n", "docstring": "removes the given address from this user", "partition": "test"}
{"idx": "2000", "code": "private boolean advanceApiUpTo(TreeSet<AreaPanelInfo> sortedApiTree,AreaPanelInfo api,int time){\n  AreaPanel ap=api.ap();\n  TimeTree rootTt=ap.getTimeTree();\n  TimeTree tt=rootTt.getEncompassigTimeTreeOrMaxTimeTreeBeforeTime(time,true);\n  if (tt == null || tt.id == api.currTtId)   return false;\n  sortedApiTree.remove(api);\n  if (api.setTt(tt,Integer.MAX_VALUE))   sortedApiTree.add(api);\n  return true;\n}\n", "docstring": "moves api to the latest value before time .", "partition": "test"}
{"idx": "1665", "code": "public void readData(DataInput din) throws IOException {\n  din.readShort();\n  count=din.readUnsignedShort();\n  registers=new InputRegister[count];\n  for (int i=0; i < count; i++) {\n    registers[i]=new SimpleInputRegister(din.readShort());\n  }\n}\n", "docstring": "readdata - - input the modbus message from din . if there was a header , such as for modbus / tcp , it will have been read already .", "partition": "test"}
{"idx": "190", "code": "public StreamInfoManager(TwitchApi api,StreamInfoListener listener){\n  this.listener=listener;\n  this.api=api;\n  pendingRequests=new HashMap<>();\n  invalidStreamInfo=new StreamInfo(\"invalid\",listener);\n  invalidStreamInfo.setRequested();\n}\n", "docstring": "create a new manager object .", "partition": "test"}
{"idx": "342", "code": "public void write(ByteBuffer buffer) throws IOException {\n  buffer.position(0);\n  if (mFileChannel.size() + buffer.capacity() < mMaxSize) {\n    while (buffer.hasRemaining()) {\n      mFileChannel.write(buffer);\n    }\n    updateWaveFileSize();\n  }\n else {\n    int remaining=(int)(mMaxSize - mFileChannel.size());\n    remaining-=(int)(remaining % mAudioFormat.getFrameSize());\n    byte[] bytes=buffer.array();\n    ByteBuffer current=ByteBuffer.wrap(Arrays.copyOf(bytes,remaining));\n    ByteBuffer next=ByteBuffer.wrap(Arrays.copyOfRange(bytes,remaining,bytes.length));\n    while (current.hasRemaining()) {\n      mFileChannel.write(current);\n    }\n    updateWaveFileSize();\n    rollover();\n    while (next.hasRemaining()) {\n      mFileChannel.write(next);\n    }\n    updateWaveFileSize();\n  }\n}\n", "docstring": "writes the buffer contents to the file . assumes that the buffer is full and the first byte of data is at position 0 .", "partition": "test"}
{"idx": "3893", "code": "private boolean rContainsRMInstruction(ProgramBlock pb,String varName){\n  if (pb instanceof WhileProgramBlock) {\n    WhileProgramBlock tmp=(WhileProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocks())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof IfProgramBlock) {\n    IfProgramBlock tmp=(IfProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocksIfBody())     if (rContainsRMInstruction(c,varName))     return true;\n    for (    ProgramBlock c : tmp.getChildBlocksElseBody())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof ForProgramBlock) {\n    ForProgramBlock tmp=(ForProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocks())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof FunctionProgramBlock) {\n  }\n else {\n    for (    Instruction inst : pb.getInstructions()) {\n      String instStr=inst.toString();\n      if (instStr.contains(\"rmfilevar\" + Lop.OPERAND_DELIMITOR + varName) || instStr.contains(\"rmvar\" + Lop.OPERAND_DELIMITOR + varName)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "determines if the given program block includes a rmvar or rmfilevar instruction for the given varname .", "partition": "test"}
{"idx": "3207", "code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n  s.writeInt(attrs.size());\n  Enumeration<Attribute> attrEnum=attrs.elements();\n  while (attrEnum.hasMoreElements()) {\n    s.writeObject(attrEnum.nextElement());\n  }\n}\n", "docstring": "overridden to avoid exposing implementation details .", "partition": "test"}
{"idx": "706", "code": "public IStatus run(IProgressMonitor monitor){\n  InputStream input=null;\n  FileOutputStream output=null;\n  IStatus jobStatus=Status.OK_STATUS;\n  byte[] b=new byte[1024];\n  int bytesRead;\n  try {\n    HttpURLConnection connection=(HttpURLConnection)url.openConnection();\n    input=url.openStream();\n    long totalBytesRead=0L;\n    int responseStatusCode=connection.getResponseCode();\n    if (responseStatusCode >= HttpURLConnection.HTTP_BAD_REQUEST) {\n      jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,MessageFormat.format(\"Remote ServerError: {0} ({1})\",responseStatusCode,connection.getResponseMessage()));\n    }\n    long contentLength=connection.getContentLength();\n    output=new FileOutputStream(target);\n    monitor.beginTask(\"Downloading \" + url.toString(),(int)contentLength);\n    while (jobStatus == Status.OK_STATUS) {\n      if (contentLength > 0 && totalBytesRead >= contentLength) {\n        break;\n      }\n      bytesRead=input.read(b);\n      if (bytesRead == -1) {\n        break;\n      }\n      output.write(b,0,bytesRead);\n      totalBytesRead+=bytesRead;\n      monitor.worked(bytesRead);\n      if (monitor.isCanceled()) {\n        jobStatus=Status.CANCEL_STATUS;\n        break;\n      }\n    }\n  }\n catch (  MalformedURLException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"Malformed URL: \" + url.toExternalForm(),e);\n  }\ncatch (  IOException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"IO error while downloading \" + url.toExternalForm(),e);\n  }\n  closeStreams(input,output);\n  return jobStatus;\n}\n", "docstring": "executes the downloadrunnable using the provided monitor to update the user and provide cancel capabilities .", "partition": "test"}
{"idx": "4181", "code": "@Override public void close() throws IOException {\n  input.close();\n}\n", "docstring": "closes this stream . this implementation closes the source stream .", "partition": "test"}
{"idx": "4174", "code": "public Set<String> find(T object){\n  if (!locations.containsKey(object)) {\n    locations.put(object,new HashSet<>());\n  }\n  return Collections.unmodifiableSet(locations.get(object));\n}\n", "docstring": "find the names of a given object .", "partition": "test"}
{"idx": "3740", "code": "public boolean next() throws EOFException {\n  if (limit >= fileSize) {\n    throw new EOFException(\"End of file was reached\");\n  }\n  if (mem.getLongVolatile(Structure.Limit) <= limit) {\n    return false;\n  }\n  byte commit=mem.getByteVolatile(limit);\n  byte rollback=mem.getByteVolatile(limit + Length.Commit);\n  if (rollback == Rollback.Set) {\n    limit+=Length.RecordHeader + recordSize;\n    timeoutCounter=0;\n    timerStart=0;\n    return false;\n  }\n  if (commit == Commit.Set) {\n    timeoutCounter=0;\n    timerStart=0;\n    return true;\n  }\n  timeoutCounter++;\n  if (timeoutCounter >= MAX_TIMEOUT_COUNT) {\n    if (timerStart == 0) {\n      timerStart=System.currentTimeMillis();\n    }\n else {\n      if (System.currentTimeMillis() - timerStart >= maxTimeout) {\n        mem.putByteVolatile(limit + Length.Commit,Rollback.Set);\n        limit+=Length.RecordHeader + recordSize;\n        timeoutCounter=0;\n        timerStart=0;\n        return false;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "steps forward to the next record if there \"'\" s one available . the method has a timeout for how long it will wait for the commit field to be set . when the timeout is reached it will set the roll back field and skip over the record .", "partition": "test"}
{"idx": "2452", "code": "public void addBreakpointListener(final BreakpointListener listener){\n  breakpointListeners.add(listener);\n}\n", "docstring": "adds a breakpoint listener .", "partition": "test"}
{"idx": "2022", "code": "public static TDoubleDoubleHashMap createCumulativeHistogram(TDoubleDoubleHashMap histogram){\n  double[] keys=histogram.keys();\n  Arrays.sort(keys);\n  double sum=0;\n  for (  double key : keys) {\n    double val=histogram.get(key);\n    sum+=val;\n    histogram.put(key,sum);\n  }\n  return histogram;\n}\n", "docstring": "creates a cumulative histogram where each bin height is the sum of the previous bin \"'\" s height and the current bin \"'\" s height .", "partition": "test"}
{"idx": "663", "code": "<T>List<T> concatValues(final T[]... data){\n  final List<T> rv=new ArrayList<>();\n  for (  T[] values : data) {\n    rv.addAll(Arrays.asList(values));\n  }\n  return rv;\n}\n", "docstring": "helper for concatenating several arrays .", "partition": "test"}
{"idx": "1725", "code": "@Override public boolean hasNext(){\n  log.log(Level.FINE,\"hasNext()\");\n  boolean result=(nextEvent != null);\n  log.log(Level.FINE,\"hasNext(): {0}\",result);\n  return result;\n}\n", "docstring": "check if there are more events . returns true if there are more events and false otherwise .", "partition": "test"}
{"idx": "1206", "code": "private SublimeBaseMenuItem addInternal(int pivotID,Positioned positioned,SublimeBaseMenuItem newItem){\n  int newItemGroupId=newItem.getGroupId();\n  checkExistenceOfGroup(newItemGroupId);\n  int pivotIndex=findItemIndex(pivotID);\n  SublimeBaseMenuItem pivot=mItems.get(pivotIndex);\n  if (newItem.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n    checkIfGroupHeaderAlreadyExistsForGroup(newItemGroupId);\n    int index=findGroupIndex(newItemGroupId);\n    if (index >= 0) {\n      mItems.add(index,newItem);\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivot.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(newItemGroupId)) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n else {\n    if (newItemGroupId != NO_GROUP_ID) {\n      int lastGroupIndex=findLastGroupIndex(newItemGroupId);\n      if (lastGroupIndex == mItems.size()) {\n        if (positioned == Positioned.BEFORE) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n else         if (positioned == Positioned.AFTER) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n      }\n else {\n        if (newItemGroupId == pivot.getGroupId()) {\n          if (positioned == Positioned.BEFORE) {\n            if (pivot.getItemType() != SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n              mItems.add(pivotIndex,newItem);\n            }\n else {\n              mItems.add(lastGroupIndex + 1,newItem);\n            }\n          }\n else           if (positioned == Positioned.AFTER) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n        }\n else {\n          mItems.add(lastGroupIndex + 1,newItem);\n        }\n      }\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || findGroupIndex(pivot.getGroupId()) == pivotIndex) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n  onItemsChanged();\n  return newItem;\n}\n", "docstring": "adds an item to the menu and positions it using the given ` pivot ` .", "partition": "test"}
{"idx": "3680", "code": "public LauncherDiscoveryRequestBuilder configurationParameters(Map<String,String> configurationParameters){\n  Preconditions.notNull(configurationParameters,\"configuration parameters map must not be null\");\n  configurationParameters.forEach(null);\n  return this;\n}\n", "docstring": "add all of the supplied configuration parameters to the request .", "partition": "test"}
{"idx": "2504", "code": "public Interceptor[] buildMethodInterceptors(Method method){\n  Interceptors before=method.getAnnotation(Interceptors.class);\n  return before != null ? createInterceptors(before) : NULL_INTERCEPTOR_ARRAY;\n}\n", "docstring": "build interceptors of method", "partition": "test"}
{"idx": "3949", "code": "protected int checkIPRange(){\n  int retVal=0;\n  String ipVersion;\n  String ipType;\n  Map<String,String> holdDetails;\n  for (  String nextIP : IPRangeRange) {\n    try {\n      holdDetails=checkIPVersion(nextIP);\n    }\n catch (    IllegalArgumentException e) {\n      if (debug.warningEnabled()) {\n        debug.warning(\"{}.checkIPRange: IP type could not be validated. IP={}\",ADAPTIVE,nextIP,e);\n      }\n      continue;\n    }\n    ipVersion=holdDetails.get(IP_Version);\n    ipType=holdDetails.get(IP_TYPE);\n    if (ipVersion.equalsIgnoreCase(IP_V6) && ValidateIPaddress.isIPv6(clientIP)) {\n      if (debug.messageEnabled()) {\n        debug.message(\"{}.checkIPRange: {} --> {}\",ADAPTIVE,clientIP,nextIP);\n        debug.message(\"IP version is: {}\",IP_V6);\n        debug.message(\"Client IP is: {}\",IPv6Address.fromString(clientIP));\n      }\n      if (ipType.equalsIgnoreCase(\"Range\")) {\n        String first=holdDetails.get(IP_START);\n        String last=holdDetails.get(IP_END);\n        IPv6AddressRange iPv6AddressRange=IPv6AddressRange.fromFirstAndLast(IPv6Address.fromString(first),IPv6Address.fromString(last));\n        if (iPv6AddressRange.contains(IPv6Address.fromString(clientIP))) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n else       if (ipType.equalsIgnoreCase(\"CIDR\")) {\n        IPv6Network iPv6Network=IPv6Network.fromString(nextIP);\n        if (iPv6Network.contains(IPv6Address.fromString(clientIP))) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n else {\n        IPv6Address iPv6AddressNextIP=IPv6Address.fromString(nextIP);\n        if (iPv6AddressNextIP.compareTo(IPv6Address.fromString(clientIP)) == 0) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n    }\n else     if (ipVersion.equalsIgnoreCase(IP_V4) && ValidateIPaddress.isIPv4(clientIP)) {\n      if (debug.messageEnabled()) {\n        debug.message(\"{}.checkIPRange: {} --> {}\",ADAPTIVE,clientIP,nextIP);\n        debug.message(\"IP version is: {}\",IP_V4);\n        debug.message(\"Client IP is: {}\",clientIP);\n      }\n      IPRange theRange=new IPRange(nextIP);\n      if (theRange.inRange(clientIP)) {\n        retVal=IPRangeScore;\n        break;\n      }\n    }\n  }\n  if (!IPRangeInvert) {\n    retVal=IPRangeScore - retVal;\n  }\n  return retVal;\n}\n", "docstring": "check to see if the ip address is within the ranges specified range can be in the form of : x . x . x . x / yy or x . x . x . x - y . y . y . y . or x : x : x : x : x : x : x : x / yy or x : x : x : x : x : x : x : x - y : y : y : y : y : y : y : y there can be multiple ranges passed in", "partition": "test"}
{"idx": "4118", "code": "public final double distance(){\n  return Math.sqrt(distance_square());\n}\n", "docstring": "the \" size \" of the line from 0 , 0 to x , y", "partition": "test"}
{"idx": "182", "code": "@Deprecated public void append(final String name,final String value){\n  List<String> l=map.get(name);\n  if (l != null) {\n    l.add(value);\n  }\n else {\n    l=Lists.newArrayList(value);\n    map.put(name,l);\n  }\n}\n", "docstring": "add a new value for name", "partition": "test"}
{"idx": "2352", "code": "protected void doResumeUpdates(){\n  Calendar cal=Calendar.getInstance(Locale.getDefault());\n  mFirstDayOfWeek=cal.getFirstDayOfWeek() - 1;\n  mShowWeekNumber=false;\n  updateHeader();\n  goTo(mSelectedDay.toMillis(true),false,false,false);\n  mAdapter.setSelectedDay(mSelectedDay);\n  mTodayUpdater.run();\n}\n", "docstring": "updates the user preference fields . override this to use a different preference space .", "partition": "test"}
{"idx": "2838", "code": "public double distance(Point2D pt){\n  final double x_distance=(pt.getX() - x) * (pt.getX() - x);\n  final double y_distance=(pt.getY() - y) * (pt.getY() - y);\n  return Math.sqrt(x_distance + y_distance);\n}\n", "docstring": "returns the euclidean distance between a specified point and this point .", "partition": "test"}
{"idx": "2512", "code": "final void putByte(int offset,byte value){\n  unsafe.putByte(offset + address,value);\n}\n", "docstring": "writes a byte at the specified offset from this native object \"'\" s base address .", "partition": "test"}
{"idx": "125", "code": "private void paintForegroundEnabled(Graphics2D g,int width,int height){\n  Shape s=decodeArrowPath(width,height);\n  g.setPaint(enabledColor);\n  g.fill(s);\n}\n", "docstring": "paint the arrow in enabled state .", "partition": "test"}
{"idx": "1104", "code": "private void paintPreview(int dx,int dy,float zoomfactor){\n  if (image != null) {\n    Graphics2D g2=(Graphics2D)getGraphics();\n    UColor bg=renderer.getBackgroundColor();\n    g2.setBackground(new Color(bg.getRed(),bg.getGreen(),bg.getBlue(),bg.getAlpha()));\n    int newWidth=Math.round(image.getWidth(null) * zoomfactor);\n    int newHeight=(int)Math.round(image.getHeight(null) * zoomfactor);\n    g2.drawImage(image,dx,dy,newWidth,newHeight,null);\n    if (dx > 0)     g2.clearRect(0,0,dx,getHeight());\n else     g2.clearRect(getWidth() + dx,0,getWidth(),getHeight());\n    if (dy > 0)     g2.clearRect(0,0,getWidth(),dy);\n else     g2.clearRect(0,getHeight() + dy,getWidth(),getHeight());\n  }\n}\n", "docstring": "draws the off - screen image if exists at position ( dx , dy ) scaled by the specified factor .", "partition": "test"}
{"idx": "3436", "code": "boolean nextSource() throws IOException {\n  if (mSourceIt.hasNext()) {\n    final InputStream is=mSourceIt.next();\n    if (is == null) {\n      mSource=null;\n      return false;\n    }\n else {\n      mSource=new BufferedInputStream(is,FileUtils.BUFFERED_STREAM_SIZE);\n    }\n    mSourceClosed=false;\n    mInputBufferPosition=0;\n    mInputBufferLength=0;\n    mBufferLength=0;\n    mBufferPosition=0;\n    return true;\n  }\n  if (mSource != null) {\n    mSource.close();\n  }\n  mSource=null;\n  return false;\n}\n", "docstring": "step to the next input stream .", "partition": "test"}
{"idx": "1071", "code": "protected void run_ThreadSizeLoop() throws Exception {\n  for (int i=25; i <= 100; i+=25) {\n    setNumWorkers(i);\n    try {\n      Thread.sleep(60 * 1000);\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}\n", "docstring": "a simple method to do nothing very much . this is used in determining static memory consumption .", "partition": "test"}
{"idx": "3668", "code": "@Override protected Node removeFromFrontier(){\n  cleanUpFrontier();\n  Node result=frontier.remove();\n  updateMetrics(frontier.size());\n  setExplored(result);\n  return result;\n}\n", "docstring": "cleans up the head of the frontier , removes the first node of a non - explored state from the head of the frontier , adds it to the corresponding explored map , and returns the node .", "partition": "test"}
{"idx": "2226", "code": "public boolean equalsChars(String a,int ai,String b,int bi,boolean ignoreCase){\n  char ca=a.charAt(ai);\n  char cb=b.charAt(bi);\n  if (ignoreCase) {\n    ca=Character.toUpperCase(ca);\n    cb=Character.toUpperCase(cb);\n  }\n  return ca == cb;\n}\n", "docstring": "compare two characters in a string .", "partition": "test"}
{"idx": "2583", "code": "public static String[] splitWithoutEscaped(String str,char separatorChar,boolean retainEmpty){\n  int len=str.length();\n  if (len == 0) {\n    return new String[0];\n  }\n  List<String> list=new ArrayList<String>();\n  int i=0;\n  int start=0;\n  boolean match=false;\n  while (i < len) {\n    if (str.charAt(i) == '\\\\\\\\') {\n      match=true;\n      i+=2;\n    }\n else     if (str.charAt(i) == separatorChar) {\n      if (retainEmpty || match) {\n        list.add(str.substring(start,i));\n        match=false;\n      }\n      start=++i;\n    }\n else {\n      match=true;\n      i++;\n    }\n  }\n  if (retainEmpty || match) {\n    list.add(str.substring(start,i));\n  }\n  return list.toArray(new String[list.size()]);\n}\n", "docstring": "does not take into account escaped separators", "partition": "test"}
{"idx": "1689", "code": "private void cacheAttribute(String attrId,byte[][] values){\n  String cacheKey=name + \"|\" + attrId;\n  valueCache.put(cacheKey,values);\n}\n", "docstring": "add the values to the cache .", "partition": "test"}
{"idx": "1187", "code": "@Override public void start(){\n  for (int i=0; i < threadCount; ++i) {\n    Set<SystemStreamPartition> threadSsps=new HashSet<SystemStreamPartition>();\n    for (    SystemStreamPartition ssp : ssps) {\n      if (Math.abs(ssp.hashCode()) % threadCount == i) {\n        threadSsps.add(ssp);\n      }\n    }\n    Thread thread=new Thread(new MockSystemConsumerRunnable(threadSsps),\"MockSystemConsumer-\" + i);\n    thread.setDaemon(true);\n    threads.add(thread);\n    thread.start();\n  }\n}\n", "docstring": "assign systemstreampartitions to all of the threads , and start them up to begin simulating consuming messages .", "partition": "test"}
{"idx": "547", "code": "private static BufferedImage makeSquare(BufferedImage input){\n  if (input.getHeight() == input.getWidth()) {\n    return input;\n  }\n else {\n    int max=Math.max(input.getHeight(),input.getWidth());\n    int dx=(max - input.getWidth()) / 2;\n    int dy=(max - input.getHeight()) / 2;\n    return createImg(max,max,input.getType(),null);\n  }\n}\n", "docstring": "returns an image where the input image is centered .", "partition": "test"}
{"idx": "3912", "code": "private ImageData awtToSwt(final BufferedImage bufferedImage,final int width,final int height){\n  final int[] awtPixels=new int[width * height];\n  final ImageData swtImageData=new ImageData(width,height,24,PALETTE_DATA);\n  swtImageData.transparentPixel=TRANSPARENT_COLOR;\n  final int step=swtImageData.depth / 8;\n  final byte[] data=swtImageData.data;\n  bufferedImage.getRGB(0,0,width,height,awtPixels,0,width);\n  for (int i=0; i < height; i++) {\n    int idx=(0 + i) * swtImageData.bytesPerLine + 0 * step;\n    for (int j=0; j < width; j++) {\n      final int rgb=awtPixels[j + i * width];\n      for (int k=swtImageData.depth - 8; k >= 0; k-=8) {\n        data[idx++]=(byte)(rgb >> k & 0xFF);\n      }\n    }\n  }\n  return swtImageData;\n}\n", "docstring": "transform a java2d bufferedimage to a swt image .", "partition": "test"}
{"idx": "1027", "code": "public static byte[] base64decode(String coded){\n  if (null == coded)   return null;\n  byte[] src=coded.getBytes();\n  int len=src.length;\n  int dlen=len - (len / 77);\n  dlen=(dlen >>> 2) + (dlen >>> 1);\n  int rem=0;\n  if (61 == src[len - 1])   rem++;\n  if (61 == src[len - 2])   rem++;\n  dlen-=rem;\n  byte[] dst=new byte[dlen];\n  int pos=0;\n  int dpos=0;\n  int col=0;\n  len-=4;\n  while (pos < len) {\n    byte b0=_base64de[src[pos++]];\n    byte b1=_base64de[src[pos++]];\n    byte b2=_base64de[src[pos++]];\n    byte b3=_base64de[src[pos++]];\n    if (B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3)     throw new RuntimeException(\"Invalid character at or around position \" + pos);\n    dst[dpos++]=(byte)((b0 << 2) | ((b1 >>> 4) & 0x03));\n    dst[dpos++]=(byte)((b1 << 4) | ((b2 >>> 2) & 0x0f));\n    dst[dpos++]=(byte)((b2 << 6) | (b3 & 0x3f));\n    col+=4;\n    if (76 == col) {\n      if (10 != src[pos++])       throw new RuntimeException(\"No linefeed found at position \" + (pos - 1));\n      col=0;\n    }\n  }\n  byte b0=_base64de[src[pos++]];\n  byte b1=_base64de[src[pos++]];\n  byte b2=_base64de[src[pos++]];\n  byte b3=_base64de[src[pos++]];\n  if (B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3)   throw new RuntimeException(\"Invalid character at or around position \" + pos);\n  dst[dpos++]=(byte)((b0 << 2) | ((b1 >>> 4) & 0x03));\n  if (2 == rem)   return dst;\n  dst[dpos++]=(byte)((b1 << 4) | ((b2 >>> 2) & 0x0f));\n  if (1 == rem)   return dst;\n  dst[dpos++]=(byte)((b2 << 6) | (b3 & 0x3f));\n  return dst;\n}\n", "docstring": "decodes a base64 encoded string . < br / > ( cf . rfc 1341 section 5 . 2 ) note : this decoder silently ignores all legal line breaks in the input and throws a runtimeexception on any illegal input . this impl slightly outperforms sun \"'\" s decoder on 1 . 3 and heavily outperforms it on 1 . 4 ( about a third faster ) .", "partition": "test"}
{"idx": "3963", "code": "public static String formatDps(final double dps){\n  return \"(\" + String.format(\"%.2f\",dps) + \" dps)\";\n}\n", "docstring": "formats given dps ( = damage per second ) to a readable string . with braces .", "partition": "test"}
{"idx": "3887", "code": "public void requestAfterExplanation(@NonNull String[] permissions){\n  ArrayList<String> permissionsToRequest=new ArrayList<>();\n  for (  String permissionName : permissions) {\n    if (isPermissionDeclined(permissionName)) {\n      permissionsToRequest.add(permissionName);\n    }\n else {\n      permissionCallback.onPermissionPreGranted(permissionName);\n    }\n  }\n  if (permissionsToRequest.isEmpty())   return;\n  permissions=permissionsToRequest.toArray(new String[permissionsToRequest.size()]);\n  context.requestPermissions(permissions,REQUEST_PERMISSIONS);\n}\n", "docstring": "to be called when explanation is presented to the user", "partition": "test"}
{"idx": "3660", "code": "@Override public int read(byte[] buf,int offset,int len) throws IOException {\n  int available=_available;\n  if (available > 0) {\n    len=Math.min(len,available);\n    len=_next.read(buf,offset,len);\n    if (len > 0) {\n      _available-=len;\n    }\n  }\n else   if (available == 0) {\n    _available=readChunkLength();\n    if (_available > 0) {\n      len=Math.min(len,_available);\n      len=_next.read(buf,offset,len);\n      if (len > 0)       _available-=len;\n    }\n else {\n      _available=-1;\n      len=-1;\n    }\n  }\n else {\n    len=-1;\n  }\n  return len;\n}\n", "docstring": "reads more data from the input stream .", "partition": "test"}
{"idx": "2677", "code": "public void toFront(final WorkflowAnnotation anno){\n  if (anno == null) {\n    throw new IllegalArgumentException(\"anno must not be null!\");\n  }\nsynchronized (lock) {\n    if (annotationsDrawOrder.remove(anno)) {\n      annotationsDrawOrder.add(anno);\n    }\n    if (annotationsEventOrder.remove(anno)) {\n      annotationsEventOrder.add(0,anno);\n    }\n  }\n}\n", "docstring": "bring the given annotation to the front . that annotation will be drawn over all other annotations as well as recieve events first .", "partition": "test"}
{"idx": "4033", "code": "public void addCondition(final Condition condition){\n  conditions.add(condition);\n  condition.setId(conditionIdCounter++);\n}\n", "docstring": "will add the condition to the list .", "partition": "test"}
{"idx": "1730", "code": "public static double phred(double error){\n  return -10 * Math.log10(error);\n}\n", "docstring": "get a phred - scaled quality value corresponding to the supplied error rate .", "partition": "test"}
{"idx": "386", "code": "@Override public boolean flingBackward(Selector obj,boolean isVertical) throws UiObjectNotFoundException {\n  UiScrollable scrollable=new UiScrollable(obj.toUiSelector());\n  if (isVertical)   scrollable.setAsVerticalList();\n else   scrollable.setAsHorizontalList();\n  return scrollable.flingBackward();\n}\n", "docstring": "performs a backwards fling action with the default number of fling steps ( 5 ) . if the swipe direction is set to vertical , then the swipe will be performed from top to bottom . if the swipe direction is set to horizontal , then the swipes will be performed from left to right . make sure to take into account devices configured with right - to - left languages like arabic and hebrew .", "partition": "test"}
{"idx": "4169", "code": "public int compareTo(NamedMediaType other){\n  return _name.compareTo(other._name);\n}\n", "docstring": "compares this namedmediatype to another .", "partition": "test"}
{"idx": "2056", "code": "public Builder untilDate(Date date){\n  untilDate=QUERY_DATE.format(date);\n  return this;\n}\n", "docstring": "returns tweets generated before the given date . date should be formatted as yyyy - mm - dd . keep in mind that the search index may not go back as far as the date you specify here .", "partition": "test"}
{"idx": "1468", "code": "public String prepOperand(String label,DataType dt,ValueType vt,boolean literal){\n  StringBuilder sb=new StringBuilder();\n  sb.append(label);\n  sb.append(Lop.DATATYPE_PREFIX);\n  sb.append(dt);\n  sb.append(Lop.VALUETYPE_PREFIX);\n  sb.append(vt);\n  sb.append(Lop.LITERAL_PREFIX);\n  sb.append(literal);\n  return sb.toString();\n}\n", "docstring": "method to prepare instruction operand with given parameters .", "partition": "test"}
{"idx": "2298", "code": "private void ensureFileOpen(){\n  if (savingDisabled) {\n    Log.e(TAG,\"Saving disabled but tried to ensureFileOpen\");\n    return;\n  }\n  if (saveFileStream != null)   return;\n  File saveFile=new File(ctx.getFilesDir(),SAVEFILE);\n  try {\n    FileOutputStream fileOutput=null;\n    DataOutputStream out=null;\n    if (saveFile.exists()) {\n      fileOutput=ctx.openFileOutput(SAVEFILE,Context.MODE_APPEND);\n      out=new DataOutputStream(new BufferedOutputStream(fileOutput));\n    }\n else {\n      fileOutput=ctx.openFileOutput(SAVEFILE,Context.MODE_PRIVATE);\n      out=new DataOutputStream(new BufferedOutputStream(fileOutput));\n      out.writeInt(TrackPoint.FORMAT_VERSION);\n      savedTrackPoints=0;\n    }\n    saveFileStream=out;\n  }\n catch (  Exception e) {\n    markSavingBroken(\"Failed to open track save file\",e);\n  }\n}\n", "docstring": "opens the savefilestream if necessary", "partition": "test"}
{"idx": "1556", "code": "public static byte[] unwrapVCF(File sourceFile,File tmpFile) throws FileNotFoundException, IOException {\n  ZipArchiveInputStream in=null;\n  FileOutputStream fos=null;\n  String hmacString=null;\n  try {\n    in=new ZipArchiveInputStream(new FileInputStream(sourceFile));\n    ArchiveEntry entry;\n    in.getNextEntry();\n    fos=new FileOutputStream(tmpFile);\n    IOUtils.copy(in,fos);\n    entry=in.getNextEntry();\n    hmacString=entry.getName();\n    return Utils.hexToBytes(hmacString);\n  }\n catch (  StringIndexOutOfBoundsException e) {\n    logger.error(\"Error parsing hmac: \" + hmacString + \" is no valid hex String\",e);\n    throw e;\n  }\ncatch (  Exception e) {\n    logger.error(\"Error unwrapping VCF file\",e);\n    throw e;\n  }\n finally {\n    if (fos != null) {\n      fos.flush();\n      fos.close();\n    }\n    if (in != null) {\n      in.close();\n    }\n  }\n}\n", "docstring": "method extracts the vcf file stored within the zipped import file to the given destination file . it further returns the corresponding hmac stored within the archive .", "partition": "test"}
{"idx": "4244", "code": "public void startPlayback(){\n  Log.d(TAG,\">> startPlayback\");\n  if (null == mRecordFile) {\n    Log.e(TAG,\"no file to playback!\");\n    return;\n  }\n  mPlayer=new MediaPlayer();\n  try {\n    mPlayer.setDataSource(mRecordFile.getAbsolutePath());\n    Log.d(TAG,\"MediaPlayer.setDataSource(\" + mRecordFile.getAbsolutePath() + \")\");\n    mPlayer.setOnCompletionListener(this);\n    mPlayer.setOnErrorListener(this);\n    mPlayer.prepare();\n    Log.d(TAG,\"MediaPlayer.prepare()\");\n    mPlayer.start();\n  }\n catch (  IOException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\ncatch (  IllegalArgumentException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\ncatch (  SecurityException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\ncatch (  IllegalStateException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\n  setState(STATE_PLAYBACK);\n  Log.d(TAG,\"<< startPlayback\");\n}\n", "docstring": "play current recorded file , if failed notify error message to caller , if success update fm recorder state", "partition": "test"}
{"idx": "2690", "code": "public boolean writeData(PdxWriter writer,Object obj){\n  if (isRelevant(obj.getClass())) {\n    writeData(writer,obj,getClassInfo(obj.getClass()));\n    return true;\n  }\n  return false;\n}\n", "docstring": "using the given pdxwriter , write out the relevant fields for the object instance passed in .", "partition": "test"}
{"idx": "1765", "code": "public void test_write_correctRejection_emptyRecord(){\n  final IRawStore store=getStore();\n  try {\n    try {\n      store.write(ByteBuffer.wrap(new byte[]{}));\n      fail(\"Expecting: \" + IllegalArgumentException.class);\n    }\n catch (    IllegalArgumentException ex) {\n      if (log.isInfoEnabled())       log.info(\"Ignoring expected exception: \" + ex);\n    }\n    try {\n      final ByteBuffer buf=ByteBuffer.wrap(new byte[2]);\n      buf.position(buf.limit());\n      store.write(buf);\n      fail(\"Expecting: \" + IllegalArgumentException.class);\n    }\n catch (    IllegalArgumentException ex) {\n      if (log.isInfoEnabled())       log.info(\"Ignoring expected exception: \" + ex);\n    }\n  }\n  finally {\n    store.destroy();\n  }\n}\n", "docstring": "test verifies correct rejection of a write operation when the caller supplies an empty buffer ( no bytes remaining ) .", "partition": "test"}
{"idx": "3511", "code": "public static int readInt(final JSONArray jsonArray,final int index,final boolean required,final boolean notNull) throws JSONException {\n  if (required) {\n    return jsonArray.getInt(index);\n  }\n  if (notNull && jsonArray.isNull(index)) {\n    throw new JSONException(String.format(Locale.US,NULL_VALUE_FORMAT_ARRAY,index));\n  }\n  int value=0;\n  if (!jsonArray.isNull(index)) {\n    value=jsonArray.getInt(index);\n  }\n  return value;\n}\n", "docstring": "reads the int value from the json array for specified index", "partition": "test"}
{"idx": "253", "code": "private void loadTranslationsCacheIfEmpty(){\n  if (translationCache.isEmpty()) {\n    for (    ObjectTranslation translation : translations) {\n      if (translation.getLocale() != null && translation.getProperty() != null && !StringUtils.isEmpty(translation.getValue())) {\n        String key=ObjectTranslation.getCacheKey(translation.getLocale(),translation.getProperty());\n        translationCache.put(key,translation.getValue());\n      }\n    }\n  }\n}\n", "docstring": "populates the translationscache map unless it is already populated .", "partition": "test"}
{"idx": "236", "code": "public static String toUpperCase(String src){\n  if (src == null) {\n    return null;\n  }\n else {\n    return src.toUpperCase();\n  }\n}\n", "docstring": "safely convert the string to uppercase .", "partition": "test"}
{"idx": "945", "code": "public void readConfig(String filename) throws FileNotFoundException {\n  if (filename == null || filename.equals(\"\"))   return;\n  readConfig(new FileReader(filename));\n}\n", "docstring": "read the specified file and parse the configuration .", "partition": "test"}
{"idx": "1584", "code": "public void sort(){\n  throwIfImmutable();\n  if (!sorted) {\n    Arrays.sort(values,0,size);\n    sorted=true;\n  }\n}\n", "docstring": "sorts the elements in the list in - place .", "partition": "test"}
{"idx": "4105", "code": "public static boolean isCglibRenamedMethod(Method renamedMethod){\n  String name=renamedMethod.getName();\n  if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\n    int i=name.length() - 1;\n    while (i >= 0 && Character.isDigit(name.charAt(i))) {\n      i--;\n    }\n    return ((i > CGLIB_RENAMED_METHOD_PREFIX.length()) && (i < name.length() - 1) && (name.charAt(i) == '$'));\n  }\n  return false;\n}\n", "docstring": "determine whether the given method is a cglib \"'\" renamed \"'\" method , following the pattern \" cglib $ methodname $ 0 \" .", "partition": "test"}
{"idx": "216", "code": "public void ascendTree(){\n  if (null != parentPath) {\n    parentPath.append(PARENT_PATH);\n    return;\n  }\n  File parentTree=calcParentTree();\n  if (null != parentTree) {\n    treeFile=parentTree;\n    return;\n  }\n  parentPath=new StringBuilder(provideLastName());\n  parentPath.append(PARENT_PATH);\n}\n", "docstring": "move higher in the tree , beyond even an apparent root of tree .", "partition": "test"}
{"idx": "955", "code": "public CModulesCheckBoxPanel(final CModulesTableModel modulesTableModel){\n  super(new BorderLayout());\n  final JCheckBox checkBox=new JCheckBox(\"Show full module paths\");\n  checkBox.addItemListener(new InternalCheckboxListener());\n  add(checkBox);\n  m_modulesTableModel=modulesTableModel;\n}\n", "docstring": "creates the checkbox panel to control if full paths should be shown in the modules table .", "partition": "test"}
{"idx": "2751", "code": "public boolean consumeEncumbranceBudget(final Map<String,Object> detailsMap){\n  if (detailsMap == null)   throw new ValidationException(Arrays.asList(new ValidationError(\"required input is null\",\"required input is null\")));\n  detailsMap.put(Constants.CONSUMEORRELEASE,true);\n  final BigDecimal bd=getDetails(detailsMap);\n  return bd.intValue() == 1;\n}\n", "docstring": "this api is to check whether the planning budget is available or not . for the amount passed if there is sufficient budget available api will return true . else it will return false . at any point the budgetavailable will show the right picture of how much more we can plan for . < p > assumptions - 1 ) on load of the budget there will be budgetavailable amount loaded using the multiplier factor . 2 ) on load of supplementary budget budget available is recalculated and updated . < p > for the sake of audit we should be updating the budgetusage object with the reference object and the moduleid and amount for any budget consumed . this will be used for reporting as to which object consumed how much and when .", "partition": "test"}
{"idx": "1780", "code": "private boolean findRoot(final ODEStateInterpolator interpolator,final double ta,final double ga,final double tb,final double gb){\n  check(ga == 0.0 || gb == 0.0 || (ga > 0.0 && gb < 0.0) || (ga < 0.0 && gb > 0.0));\n  final UnivariateFunction f=null;\n  double beforeRootT=Double.NaN, beforeRootG=Double.NaN;\n  double afterRootT=ta, afterRootG=0.0;\n  if (ta == tb) {\n    beforeRootT=ta;\n    beforeRootG=ga;\n    afterRootT=shiftedBy(beforeRootT,convergence);\n    afterRootG=f.value(afterRootT);\n  }\n else   if (ga != 0.0 && gb == 0.0) {\n    beforeRootT=tb;\n    beforeRootG=gb;\n    afterRootT=shiftedBy(beforeRootT,convergence);\n    afterRootG=f.value(afterRootT);\n  }\n else   if (ga != 0.0) {\n    final double newGa=f.value(ta);\n    if (ga > 0 != newGa > 0) {\n      beforeRootT=ta;\n      beforeRootG=newGa;\n      afterRootT=minTime(shiftedBy(beforeRootT,convergence),tb);\n      afterRootG=f.value(afterRootT);\n    }\n  }\n  double loopT=ta, loopG=ga;\n  while ((afterRootG == 0.0 || afterRootG > 0.0 == g0Positive) && strictlyAfter(afterRootT,tb)) {\n    if (loopG == 0.0) {\n      beforeRootT=loopT;\n      beforeRootG=loopG;\n      afterRootT=minTime(shiftedBy(beforeRootT,convergence),tb);\n      afterRootG=f.value(afterRootT);\n    }\n else {\n      if (forward) {\n        final Interval interval=solver.solveInterval(maxIterationCount,f,loopT,tb);\n        beforeRootT=interval.getLeftAbscissa();\n        beforeRootG=interval.getLeftValue();\n        afterRootT=interval.getRightAbscissa();\n        afterRootG=interval.getRightValue();\n      }\n else {\n        final Interval interval=solver.solveInterval(maxIterationCount,f,tb,loopT);\n        beforeRootT=interval.getRightAbscissa();\n        beforeRootG=interval.getRightValue();\n        afterRootT=interval.getLeftAbscissa();\n        afterRootG=interval.getLeftValue();\n      }\n    }\n    if (beforeRootT == afterRootT) {\n      afterRootT=nextAfter(afterRootT);\n      afterRootG=f.value(afterRootT);\n    }\n    check((forward && afterRootT > beforeRootT) || (!forward && afterRootT < beforeRootT));\n    loopT=afterRootT;\n    loopG=afterRootG;\n  }\n  if (afterRootG == 0.0 || afterRootG > 0.0 == g0Positive) {\n    return false;\n  }\n else {\n    check(!Double.isNaN(beforeRootT) && !Double.isNaN(beforeRootG));\n    increasing=!g0Positive;\n    pendingEventTime=beforeRootT;\n    stopTime=beforeRootG == 0.0 ? beforeRootT : afterRootT;\n    pendingEvent=true;\n    afterEvent=afterRootT;\n    afterG=afterRootG;\n    check(afterG > 0 == increasing);\n    check(increasing == gb >= ga);\n    return true;\n  }\n}\n", "docstring": "find a root in a bracketing interval . < p > when calling this method one of the following must be true . either ga = = 0 , gb = = 0 , ( ga < 0 and gb > 0 ) , or ( ga > 0 and gb < 0 ) .", "partition": "test"}
{"idx": "853", "code": "@Override public boolean isArmed(){\n  return other.isArmed();\n}\n", "docstring": "all these methods simply delegate to the \" other \" model that is being decorated .", "partition": "test"}
{"idx": "320", "code": "public static void assumeTrue(BooleanSupplier assumptionSupplier,Supplier<String> messageSupplier) throws TestAbortedException {\n  if (!assumptionSupplier.getAsBoolean()) {\n    throwTestAbortedException(messageSupplier.get());\n  }\n}\n", "docstring": "validate the given assumption .", "partition": "test"}
{"idx": "3556", "code": "private static int ipToBytes(String ip,byte[] bytes,boolean mustHave4) throws IPMatcherException {\n  String[] parts=ip.split(\"\\\\\\\\.\");\n  if (parts.length > 4 || mustHave4 && parts.length != 4) {\n    throw new IPMatcherException(\"Malformed IP specification \" + ip);\n  }\n  try {\n    for (int i=0; i < parts.length; i++) {\n      int p=Integer.parseInt(parts[i]);\n      if (p < 0 || p > 255) {\n        throw new IPMatcherException(\"Malformed IP specification \" + ip);\n      }\n      bytes[i]=(byte)(p < 128 ? p : p - 256);\n    }\n  }\n catch (  NumberFormatException nfe) {\n    throw new IPMatcherException(\"Malformed IP specification \" + ip,nfe);\n  }\n  return parts.length;\n}\n", "docstring": "fill out a given four - byte array with the ipv4 address specified in the given string", "partition": "test"}
{"idx": "3745", "code": "protected int read(SpeechRecord recorder,byte[] buffer){\n  int len=buffer.length;\n  int numOfBytes=recorder.read(buffer,0,len);\n  int status=getStatus(numOfBytes,len);\n  if (status == 0) {\n    System.arraycopy(buffer,0,mRecording,mRecordedLength,numOfBytes);\n    mRecordedLength+=len;\n  }\n  return status;\n}\n", "docstring": "copy data from the given recorder into the given buffer , and append to the complete recording . public int read ( byte [ ", "partition": "test"}
{"idx": "2438", "code": "protected void prepare(){\n  for (  ProcessInfoParameter para : getParameter()) {\n    String name=para.getParameterName();\n    if (para.getParameter() == null)     ;\n else     if (name.equals(PARAM_M_Warehouse_ID))     p_M_Warehouse_ID=para.getParameterAsInt();\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n  p_C_Invoice_ID=getRecord_ID();\n}\n", "docstring": "prepare - e . g . , get parameters .", "partition": "test"}
{"idx": "1525", "code": "public int read(long fileOffset,byte[] buffer,int offset,int length) throws IOException {\n  _file.seek(fileOffset);\n  return _file.read(buffer,offset,length);\n}\n", "docstring": "reads a block from a given location .", "partition": "test"}
{"idx": "331", "code": "@Override protected void onDraw(Canvas canvas){\n  super.onDraw(canvas);\n  if (mBitmapShader == null)   return;\n  canvas.drawCircle(mCenterX,mCenterY,mCoverRadius,mCoverPaint);\n  canvas.drawCircle(mCenterX,mCenterY,mCoverRadius,mCoverFrontPaint);\n  mDurationText=secondsToTime(mDurationSecondsCurrent);\n  mDurationPaint.getTextBounds(mDurationText,0,mDurationText.length(),mRectDuration);\n  canvas.drawText(mDurationText,(mCenterX - (mRectDuration.width() / 2.0f)),(mCenterY + (mRectDuration.height() / 2.0f)),mDurationPaint);\n  if (mBitmapUnselectedAction1 != null && mBitmapSelectedAction1 != null) {\n    canvas.drawBitmap(isAction1Selected ? mBitmapSelectedAction1 : mBitmapUnselectedAction1,(mCenterX - (5 * (mCenterX / 13.0f))),mCenterY + (mCenterY / 3.0f) - (mCenterY / 13.0f),mActionPaint);\n  }\n  if (mBitmapUnselectedAction2 != null && mBitmapSelectedAction2 != null) {\n    canvas.drawBitmap(isAction2Selected ? mBitmapSelectedAction2 : mBitmapUnselectedAction2,mCenterX - (mCenterX / 13.0f),mCenterY + (mCenterY / 3.0f) - (mCenterY / 13.0f),mActionPaint);\n  }\n  if (mBitmapUnselectedAction3 != null && mBitmapSelectedAction3 != null) {\n    canvas.drawBitmap(isAction3Selected ? mBitmapSelectedAction3 : mBitmapUnselectedAction3,(int)(mCenterX + (3 * (mCenterX / 13.0f))),mCenterY + (mCenterY / 3.0f) - (mCenterY / 13.0f),mActionPaint);\n  }\n  canvas.drawArc(mProgressRectF,0,360,false,mPaintEmptyProgress);\n  canvas.drawArc(mProgressRectF,270,calculatePastProgress(),false,mPaintLoadedProgress);\n  canvas.drawCircle((float)(mCenterX + ((mCenterX - 20.0f) * Math.cos(Math.toRadians(calculatePastProgress() - 90)))),(float)(mCenterY + ((mCenterX - 20.0f) * Math.sin(Math.toRadians(calculatePastProgress() - 90)))),mRadiusToggle,mPaintProgressToggle);\n}\n", "docstring": "what magic happens . 1 - draw image cover in circle 2 - draw black shadow on it to make seconds and icons more visible 3 - draw duration center of image . 4 - put icon / s on it 5 - draw progress", "partition": "test"}
{"idx": "1697", "code": "public static Query newPrefixQuery(String field,InetAddress value,int prefixLength){\n  if (value == null) {\n    throw new IllegalArgumentException(\"InetAddress must not be null\");\n  }\n  if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {\n    throw new IllegalArgumentException(\"illegal prefixLength \\'\" + prefixLength + \"\\'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges\");\n  }\n  byte lower[]=value.getAddress();\n  byte upper[]=value.getAddress();\n  for (int i=prefixLength; i < 8 * lower.length; i++) {\n    int m=1 << (7 - (i & 7));\n    lower[i >> 3]&=~m;\n    upper[i >> 3]|=m;\n  }\n  try {\n    return newRangeQuery(field,InetAddress.getByAddress(lower),InetAddress.getByAddress(upper));\n  }\n catch (  UnknownHostException e) {\n    throw new AssertionError(e);\n  }\n}\n", "docstring": "create a prefix query for matching a cidr network range .", "partition": "test"}
{"idx": "829", "code": "public static void registerOperators(String name,InputStream operatorsXML,ClassLoader classLoader){\n  registerOperators(name,operatorsXML,classLoader,null);\n}\n", "docstring": "registers all operators from a given xml input stream . closes the stream .", "partition": "test"}
{"idx": "2801", "code": "public void save() throws IOException {\n  if (!props.isEmpty()) {\n    ConfigurationUtil.saveConfigurationProperties(props,propsFile,false);\n  }\n  ConfigurationUtil.saveConfigurationProperties(props,new File(propsFile.getParentFile(),propsFile.getName() + \".default\"),true);\n}\n", "docstring": "saves the currently known settings .", "partition": "test"}
{"idx": "3140", "code": "public void close() throws IOException {\n  if (!closed) {\n    try {\n      finish();\n    }\n  finally {\n      out.close();\n      closed=true;\n    }\n  }\n}\n", "docstring": "writes any remaining uncompressed data to the output stream and closes the underlying output stream .", "partition": "test"}
{"idx": "2181", "code": "public StartListener(Object resource){\n  _resource=resource;\n}\n", "docstring": "creates the new start listener .", "partition": "test"}
{"idx": "3737", "code": "private void loadSubmissions(){\n  submissions.clear();\n  String[] users=JPlagCentral.usersList();\n  for (int i=0; i < users.length; i++) {\n    AccessStructure[] subm=JPlagCentral.listAccessStructures(users[i]);\n    if (subm != null && subm.length != 0) {\n      for (int j=0; j < subm.length; j++) {\n        submissions.add(subm[j]);\n      }\n    }\n  }\n}\n", "docstring": "used to actualize the vector containing all submissions", "partition": "test"}
{"idx": "2453", "code": "public void update(Graphics g){\n  if (isShowing()) {\n    if (!(peer instanceof LightweightPeer)) {\n      g.clearRect(0,0,width,height);\n    }\n    paint(g);\n  }\n}\n", "docstring": "updates the container . this forwards the update to any lightweight components that are children of this container . if this method is reimplemented , super . update ( g ) should be called so that lightweight components are properly rendered . if a child component is entirely clipped by the current clipping setting in g , update ( ) will not be forwarded to that child .", "partition": "test"}
{"idx": "3179", "code": "public void testSortsAccordingNumberOfAttributes() throws Exception {\n  XppDom dom1=XppFactory.buildDom(\"<dom/>\");\n  XppDom dom2=XppFactory.buildDom(\"<dom a=\\'1\\'/>\");\n  assertEquals(-1,comparator.compare(dom1,dom2));\n  assertEquals(\"/dom::count(@*)\",xpath.get());\n  assertEquals(1,comparator.compare(dom2,dom1));\n  assertEquals(\"/dom::count(@*)\",xpath.get());\n}\n", "docstring": "tests comparison of different number of attributes .", "partition": "test"}
{"idx": "3846", "code": "@HLEFunction(nid=0xD1E0A01E,version=150,checkInsideInterrupt=true) public int __sceSasSetGrain(int sasCore,int grain){\n  checkSasHandleGood(sasCore);\n  grainSamples=grain;\n  return 0;\n}\n", "docstring": "set the number of samples generated by one __scesascore call .", "partition": "test"}
{"idx": "2809", "code": "public static RepositoryMetaData readFrom(StreamInput in) throws IOException {\n  String name=in.readString();\n  String type=in.readString();\n  Settings settings=Settings.readSettingsFromStream(in);\n  return new RepositoryMetaData(name,type,settings);\n}\n", "docstring": "reads repository metadata from stream input", "partition": "test"}
{"idx": "1177", "code": "private void assertDescribedResource(final BigdataValue describedResource,final IDescribeCache describeCache,final TestHelper h){\n  final Graph actualGraph=describeCache.lookup(describedResource.getIV());\n  assertNotNull(actualGraph);\n  final Set<Statement> expectedGraph=getExpectedDescription(describedResource,h);\n  h.compareGraphs(new HashSet<Statement>(actualGraph),expectedGraph);\n  for (  Statement stmt : actualGraph) {\n    assertTrue(stmt instanceof BigdataStatement);\n    final BigdataStatement st=(BigdataStatement)stmt;\n    assertNotNull(st.s());\n    assertNotNull(st.p());\n    assertNotNull(st.o());\n    if (st.getContext() != null) {\n      assertNotNull(st.c());\n    }\n  }\n}\n", "docstring": "assert that a resource is described by the cache .", "partition": "test"}
{"idx": "3194", "code": "void generateWhile(Tree.WhileStatement that){\n  Tree.WhileClause whileClause=that.getWhileClause();\n  List<VarHolder> vars=specialConditionsAndBlock(whileClause.getConditionList(),whileClause.getBlock(),\"while\",false);\n  for (  VarHolder v : vars) {\n    v.forget();\n  }\n}\n", "docstring": "generates js code for a whilestatement .", "partition": "test"}
{"idx": "1695", "code": "public static InputStream tryGzipInput(InputStream in) throws IOException {\n  if (!in.markSupported()) {\n    PushbackInputStream pb=new PushbackInputStream(in,16);\n    in=pb;\n    byte[] magic={0,0};\n    pb.read(magic);\n    pb.unread(magic);\n    if (magic[0] == 31 && magic[1] == -117) {\n      return new GZIPInputStream(pb);\n    }\n    return in;\n  }\n  in.mark(16);\n  boolean isgzip=(in.read() == 31 && in.read() == -117);\n  in.reset();\n  if (isgzip) {\n    in=new GZIPInputStream(in);\n  }\n  return in;\n}\n", "docstring": "try to open a stream as gzip , if it starts with the gzip magic . todo : move to utils package .", "partition": "test"}
{"idx": "2779", "code": "public static double toDegrees(double x){\n  if (Double.isInfinite(x) || x == 0.0) {\n    return x;\n  }\n  final double facta=57.2957763671875;\n  final double factb=3.145894820876798E-6;\n  double xa=doubleHighPart(x);\n  double xb=x - xa;\n  return xb * factb + xb * facta + xa * factb + xa * facta;\n}\n", "docstring": "convert radians to degrees , with error of less than 0 . 5 ulp", "partition": "test"}
{"idx": "1941", "code": "public void select_all(){\n  Arrays.fill(sel_array,true);\n}\n", "docstring": "selects all item types .", "partition": "test"}
{"idx": "1488", "code": "public void assignThreadForSubscriber(@NonNull Object subscriber){\n  Looper looper=Looper.myLooper();\n  if (looper != null) {\n    mSubscribersDefaultThreads.put(new IdentityWeakReferenceKey<>(subscriber),looper != Looper.getMainLooper() ? new Handler(looper) : mUiThreadHandler);\n  }\n else {\n    mSubscribersDefaultThreads.remove(new IdentityWeakReferenceKey<>(subscriber));\n  }\n}\n", "docstring": "assign current thread to the subscriber object . to make it work , the thread have to have a looper ( looper . mylooper ( ) ! = null ) . if current thread have no looper , all event handlers marked with deliver_in_default_thread , it will be executed as deliver_in_background_thread . < p / > this method can be used to re - assign the default thread for already registered object .", "partition": "test"}
{"idx": "2250", "code": "public ServiceConfig createOrganizationConfig(String orgName,Map attrs) throws SMSException, SSOException {\n  validateSSM();\n  ServiceSchemaImpl ss=ssm.getSchema(SchemaType.ORGANIZATION);\n  if (ss == null) {\n    String[] args={serviceName};\n    throw (new SMSException(IUMSConstants.UMS_BUNDLE_NAME,\"sms-service-does-not-have-org-schema\",args));\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  CreateServiceConfig.checkBaseNodesForOrg(token,orgdn,serviceName,version);\n  String orgDN=scm.constructServiceConfigDN(SMSUtils.DEFAULT,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  try {\n    CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,orgDN);\n    if (cEntry.isDirty()) {\n      cEntry.refresh();\n    }\n    if (cEntry.isNewEntry()) {\n      CreateServiceConfig.createSubConfigEntry(token,orgDN,ss,null,null,attrs,orgName);\n      if (ServiceManager.isCoexistenceMode()) {\n        String smsDN=DNMapper.orgNameToDN(orgName);\n        OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(smsDN),smsDN);\n        amsdk.assignService(serviceName);\n      }\n    }\n else     if (attrs != null && !attrs.isEmpty()) {\n      ServiceConfig sc=getOrganizationConfig(orgName,null);\n      sc.setAttributes(attrs);\n    }\n  }\n catch (  ServiceAlreadyExistsException slee) {\n  }\n  return (getOrganizationConfig(orgName,null));\n}\n", "docstring": "creates organization configuration for the default instance of the service given configuration attributes .", "partition": "test"}
{"idx": "875", "code": "public boolean isObsessional(){\n  return typeString.contains(SUFFIX_OBSESSIONAL);\n}\n", "docstring": "determine if the expression is a obsessional one .", "partition": "test"}
{"idx": "3375", "code": "protected String searchFor(final String target,String start){\n  return searchFor(target,null,start);\n}\n", "docstring": "searches for the given target directory starting in the \" plugins \" subdirectory of the given location . if one is found then this location is returned ; otherwise an exception is thrown .", "partition": "test"}
{"idx": "3653", "code": "void deriveConfidenceValue(double baseCount){\n  if (Utils.isMissingValue(m_confidence) && !Utils.isMissingValue(baseCount) && baseCount > 0) {\n    m_confidence=m_recordCount / baseCount;\n  }\n}\n", "docstring": "backfit confidence value ( does nothing if the confidence value is already set ) .", "partition": "test"}
{"idx": "3816", "code": "private long convertToBytes(int megaBytes){\n  long bytes=megaBytes;\n  bytes=bytes * 1024 * 1024;\n  return bytes;\n}\n", "docstring": "takes an int which is supposed to be in megabytes and converts it to a long . this conversion takes into account that multiplication can lead to integer . max_value being exceeded", "partition": "test"}
{"idx": "2126", "code": "public void test_getPutByteArray(){\n  final int size=200;\n  final IDataRecord buf=new FixedByteArrayBuffer(size);\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(size - 1));\n  final int pos=1;\n  for (int i=0; i < LIMIT; i++) {\n    final byte[] expected=new byte[r.nextInt(size - 2)];\n    r.nextBytes(expected);\n    buf.put(pos,expected);\n    assertEquals(0,BytesUtil.compareBytesWithLenAndOffset(0,expected.length,expected,pos,expected.length,buf.array()));\n    final byte[] actual=new byte[expected.length];\n    buf.get(pos,actual);\n    assertTrue(BytesUtil.bytesEqual(expected,actual));\n  }\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(pos + size - 2));\n}\n", "docstring": "test of the simple forms of the bulk get / put methods .", "partition": "test"}
{"idx": "3000", "code": "private void updateTrafficProjections(){\n  List<AirMapTraffic> updated=new ArrayList<>();\n  for (  AirMapTraffic traffic : allTraffic) {\n    if (traffic.getGroundSpeedKt() > -1 && traffic.getTrueHeading() > -1) {\n      allTraffic.remove(traffic);\n      Coordinate projected=projectedCoordinate(traffic);\n      traffic.setCoordinate(projected);\n      traffic.setShowAlert(false);\n      allTraffic.add(traffic);\n      updated.add(traffic);\n    }\n  }\n  notifyUpdated(updated);\n}\n", "docstring": "update all the traffic projections based on their heading and ground speed", "partition": "test"}
{"idx": "2707", "code": "public void init(String flagzDirectory) throws FlagException, EtcdFlagFieldUpdaterException {\n  this.directoryPrefix=MoreObjects.firstNonNull(flagzDirectory,directoryFlag.get());\n  client=new EtcdClient(uris.toArray(new URI[uris.size()]));\n  client.setRetryHandler(retryPolicy);\n  initialSetAllFlagz();\n}\n", "docstring": "init performs the initial read of values from etcd .", "partition": "test"}
{"idx": "2153", "code": "public void close() throws IOException {\n  try {\n    Debug.message(\"binaryfile\",\"StreamInputReader.close()\");\n    if (Debug.debugging(\"connection_problems\")) {\n      Thread.sleep(1000);\n    }\n    if (inputStream != null)     inputStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  inputStream=null;\n}\n", "docstring": "closes the underlying file", "partition": "test"}
{"idx": "1272", "code": "public static String morpha(String text,boolean tags){\n  if (text.isEmpty()) {\n    return \"\";\n  }\n  String[] textParts=whitespace.split(text);\n  StringBuilder result=new StringBuilder();\n  try {\n    for (    String textPart : textParts) {\n      Morpha morpha=new Morpha(new StringReader(textPart),tags);\n      if (result.length() != 0) {\n        result.append(\" \");\n      }\n      result.append(morpha.next());\n    }\n  }\n catch (  Error e) {\n    return text;\n  }\ncatch (  java.io.IOException e) {\n    return text;\n  }\n  return result.toString();\n}\n", "docstring": "run the morpha algorithm on the specified string .", "partition": "test"}
{"idx": "1978", "code": "private void extractWeightValues(List<Synapse> synapses){\n  int exWeights=0;\n  int inWeights=0;\n  for (  Synapse s : synapses) {\n    double w=s.getStrength();\n    if (w > 0) {\n      exWeights++;\n    }\n else {\n      inWeights++;\n    }\n  }\n  weights[0]=new double[exWeights];\n  weights[1]=new double[inWeights];\n  exWeights=0;\n  inWeights=0;\n  if (weights[0].length != 0) {\n    for (    Synapse s : synapses) {\n      double w=s.getStrength();\n      if (w > 0) {\n        weights[0][exWeights++]=w;\n      }\n else {\n        weights[1][inWeights++]=w;\n      }\n    }\n  }\n}\n", "docstring": "extracts weight values and organizes them by synapse type ( inhibitory or excitatory ) . inhibitory values are represented by their absolute value .", "partition": "test"}
{"idx": "3301", "code": "public static float parseFloat(String s){\n  if (POSITIVE_INFINITY.equals(s)) {\n    return Float.POSITIVE_INFINITY;\n  }\n else   if (NEGATIVE_INFINITY.equals(s)) {\n    return Float.NEGATIVE_INFINITY;\n  }\n else   if (NaN.equals(s)) {\n    return Float.NaN;\n  }\n else {\n    s=trimPlusSign(s);\n    return Float.parseFloat(s);\n  }\n}\n", "docstring": "parses the supplied xsd : float string and returns its value .", "partition": "test"}
{"idx": "3669", "code": "public static boolean isFile(String path){\n  File f=new File(path);\n  return f.isFile();\n}\n", "docstring": "checks if the given path is a file", "partition": "test"}
{"idx": "495", "code": "@Override public Iterator<Profile> iterator(){\n  return profiles.iterator();\n}\n", "docstring": "get an iterator of profiles .", "partition": "test"}
{"idx": "2487", "code": "String parse(String cellStr,int layoutConstant){\n  return cellStr.split(LayoutConstants.CELL_PTRN)[layoutConstant];\n}\n", "docstring": "utility method to parse a cell definition for a particular value .", "partition": "test"}
{"idx": "1623", "code": "protected void doFunction(float[] inputs,int inputOffset,float[] outputs,int outputOffset){\n  float input=inputs[inputOffset];\n  for (int i=0; i < getNumOutputs(); i++) {\n    outputs[i + outputOffset]=getC0(i) + (float)(Math.pow(input,getN()) * (getC1(i) - getC0(i)));\n  }\n}\n", "docstring": "calculate the function value for the input . for each output ( j ) , the function value is : c0 ( j ) + x ^ n * ( c1 ( j ) - c0 ( j ) )", "partition": "test"}
{"idx": "4257", "code": "public void remove(String btxn){\nsynchronized (filterMap) {\n    FilterProcessor oldfp=filterMap.get(btxn);\n    if (oldfp != null) {\n      globalExclusionFilters.remove(oldfp);\n      btxnFilters.remove(oldfp);\n    }\n  }\n}\n", "docstring": "this method removes the business transaction .", "partition": "test"}
{"idx": "1563", "code": "protected int __offset(int vtable_offset){\n  int vtable=bb_pos - bb.getInt(bb_pos);\n  return vtable_offset < bb.getShort(vtable) ? bb.getShort(vtable + vtable_offset) : 0;\n}\n", "docstring": "look up a field in the vtable .", "partition": "test"}
{"idx": "2142", "code": "public void test_nonEmptyJournal() throws IOException, InterruptedException, ExecutionException {\n  final File out=File.createTempFile(getName(),Options.JNL);\n  try {\n    final Journal src=getStore(getProperties());\n    try {\n      if (!(src.getBufferStrategy() instanceof IHABufferStrategy)) {\n        return;\n      }\n      src.write(getRandomData(128));\n      src.commit();\n      try {\n        final ISnapshotFactory snapshotFactory=new MySnapshotFactory(getName(),false);\n        final Future<ISnapshotResult> f=src.snapshot(snapshotFactory);\n        final ISnapshotResult snapshotResult=f.get();\n        final File snapshotFile=snapshotResult.getFile();\n        try {\n          final Journal tmp=openSnapshot(snapshotResult);\n          assertEquals(src.getRootBlockView(),tmp.getRootBlockView());\n          tmp.destroy();\n        }\n  finally {\n          if (snapshotFile.exists()) {\n            snapshotFile.delete();\n          }\n        }\n      }\n catch (      IllegalArgumentException ex) {\n        log.info(\"Ignoring expected exception: \" + ex);\n      }\n    }\n  finally {\n      src.destroy();\n    }\n  }\n  finally {\n    out.delete();\n  }\n}\n", "docstring": "verifies exception if there are no commits on the journal ( the lastcommittime will be zero which does not identify a valid commit point ) .", "partition": "test"}
{"idx": "2274", "code": "public IElementType captureString(){\n  CharSequence buffer=getBuffer();\n  int currentPosition=getTokenEnd();\n  setTokenStart(currentPosition);\n  int bufferEnd=getBufferEnd();\n  char openQuote=buffer.charAt(currentPosition);\n  char closeQuote=RegexBlock.getQuoteCloseChar(openQuote);\n  boolean quotesDiffer=openQuote != closeQuote;\n  boolean isEscaped=false;\n  int quotesDepth=0;\n  currentPosition++;\n  while (currentPosition < bufferEnd) {\n    char currentChar=buffer.charAt(currentPosition);\n    if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote) {\n      break;\n    }\n    if (!isEscaped && quotesDiffer) {\n      if (currentChar == openQuote) {\n        quotesDepth++;\n      }\n else       if (currentChar == closeQuote) {\n        quotesDepth--;\n      }\n    }\n    isEscaped=!isEscaped && currentChar == '\\\\\\\\';\n    currentPosition++;\n  }\n  if (currentPosition < bufferEnd) {\n    currentPosition++;\n  }\n  setTokenEnd(currentPosition);\n  PerlStringLexer stringLexer=getStringLexer();\n  popState();\n  preparsedTokensList.addAll(lexCurrentToken(stringLexer));\n  return getPreParsedToken();\n}\n", "docstring": "captures string token from current position according to the current lexical state", "partition": "test"}
{"idx": "2853", "code": "private List<NameValuePair> buildIPTParameters(Ipt ipt,String organisationKey){\n  List<NameValuePair> data=new ArrayList<NameValuePair>();\n  if (ipt != null && organisationKey != null) {\n    data.add(new BasicNameValuePair(\"organisationKey\",StringUtils.trimToEmpty(organisationKey)));\n    data.add(new BasicNameValuePair(\"name\",StringUtils.trimToEmpty(ipt.getName())));\n    data.add(new BasicNameValuePair(\"description\",StringUtils.trimToEmpty(ipt.getDescription())));\n    data.add(new BasicNameValuePair(\"primaryContactType\",StringUtils.trimToEmpty(ipt.getPrimaryContactType())));\n    data.add(new BasicNameValuePair(\"primaryContactName\",StringUtils.trimToEmpty(ipt.getPrimaryContactName())));\n    data.add(new BasicNameValuePair(\"primaryContactEmail\",StringUtils.trimToEmpty(ipt.getPrimaryContactEmail())));\n    data.add(new BasicNameValuePair(\"serviceTypes\",SERVICE_TYPE_RSS));\n    data.add(new BasicNameValuePair(\"serviceURLs\",getRssFeedURL()));\n  }\n else {\n    log.debug(\"One or both of IPT and Organisation key were null. Params needed for ws will be empty\");\n  }\n  return data;\n}\n", "docstring": "populate a list of name value pairs used in the common ws requests for ipt registrations and updates .", "partition": "test"}
{"idx": "1872", "code": "public boolean fireMapMouseClicked(MouseEvent evt){\n  if (DEBUG) {\n    logger.fine(\"MapMouseSupport: fireMapMouseClicked\");\n  }\n  clickHappened=true;\n  boolean consumed=false;\n  evt=new MapMouseEvent(getParentMode(),evt);\n  if (priorityListener != null && evt.getClickCount() > 1) {\n    priorityListener.mouseClicked(evt);\n    consumed=true;\n  }\n  priorityListener=null;\n  if (proxy == null || evt.isShiftDown() || (proxyDistributionMask & PROXY_DISTRIB_MOUSE_CLICKED) > 0) {\n    Iterator<MapMouseListener> it=iterator();\n    while (it.hasNext() && !consumed) {\n      MapMouseListener target=it.next();\n      consumed=target.mouseClicked(evt) && consumeEvents;\n      if (consumed) {\n        priorityListener=target;\n      }\n    }\n  }\n  boolean ignoreConsumed=!consumed || (consumed && ((proxyDistributionMask & PROXY_ACK_CONSUMED_MOUSE_CLICKED) == 0));\n  if (proxy != null && ignoreConsumed && !evt.isShiftDown()) {\n    proxy.mouseClicked(evt);\n    consumed=true;\n  }\n  return consumed;\n}\n", "docstring": "handle a mouseclicked mouselistener event . if the prioritylistener is set , it automatically gets the clicked event . if it is not set , the other listeners get a shot at the event according to the consumeevent mode .", "partition": "test"}
{"idx": "851", "code": "public static void copyRealmPrivilegesFromParent(SSOToken token,OrganizationConfigManager parent,OrganizationConfigManager child) throws SSOException, DelegationException {\n  if (debug.messageEnabled()) {\n    debug.message(\"DelegationUtils.copyRealmPrivilegesFromParent\" + \" Parent org: \" + parent.getOrganizationName() + \" Child org: \"+ child.getOrganizationName());\n  }\n  DelegationManager pdm=new DelegationManager(token,parent.getOrganizationName());\n  DelegationManager cdm=new DelegationManager(token,child.getOrganizationName());\n  String childOrgName=DNMapper.orgNameToDN(child.getOrganizationName());\n  Set pdps=pdm.getPrivileges();\n  if (pdps == null || pdps.isEmpty()) {\n    if (debug.messageEnabled()) {\n      debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: No privilege subjects in parent\");\n    }\n    return;\n  }\n  for (Iterator items=pdps.iterator(); items.hasNext(); ) {\n    DelegationPrivilege dp=(DelegationPrivilege)items.next();\n    Set subjects=dp.getSubjects();\n    if (subjects == null || subjects.isEmpty()) {\n      if (debug.messageEnabled()) {\n        debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: No subjects in privilege: \" + dp);\n      }\n      continue;\n    }\n    Set newSubjects=new HashSet();\n    for (Iterator subs=subjects.iterator(); subs.hasNext(); ) {\n      String sName=(String)subs.next();\n      try {\n        AMIdentity id=IdUtils.getIdentity(token,sName);\n        AMIdentity newId=new AMIdentity(token,id.getName(),id.getType(),childOrgName,id.getDN());\n        newSubjects.add(IdUtils.getUniversalId(newId));\n      }\n catch (      IdRepoException ide) {\n        if (debug.messageEnabled()) {\n          debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: IdRepoException for: \" + dp,ide);\n        }\n        continue;\n      }\n    }\n    dp.setSubjects(newSubjects);\n    Set permissions=dp.getPermissions();\n    if ((permissions != null) && (!permissions.isEmpty())) {\n      Iterator it=permissions.iterator();\n      while (it.hasNext()) {\n        DelegationPermission perm=(DelegationPermission)it.next();\n        perm.setOrganizationName(\"*\" + childOrgName);\n      }\n    }\n    cdm.addPrivilege(dp);\n    if (debug.messageEnabled()) {\n      debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: Privilege copied from parent: \" + dp);\n    }\n  }\n}\n", "docstring": "creates default privileges for a newly created realm this method should be called in realm mode only .", "partition": "test"}
{"idx": "2231", "code": "private static String createJsMethodInvocationExpression(String methodName,boolean isStatic,String... paramNames){\n  StringBuilder sb=new StringBuilder();\n  sb.append(isStatic ? WND : THIS);\n  sb.append(\".\");\n  sb.append(methodName);\n  sb.append(\"(\");\n  for (int i=0; i < paramNames.length; i++) {\n    if (i != 0) {\n      sb.append(\", \");\n    }\n    sb.append(paramNames[i]);\n  }\n  sb.append(\");\");\n  return sb.toString();\n}\n", "docstring": "creates a jsni method invocation expression .", "partition": "test"}
{"idx": "2936", "code": "public InMemoryMessageExchangeStore(final NetworkConfig config,TokenProvider tokenProvider){\n  if (config == null) {\n    throw new NullPointerException(\"Configuration must not be null\");\n  }\n  if (tokenProvider == null) {\n    throw new NullPointerException(\"TokenProvider must not be null\");\n  }\n  this.tokenProvider=tokenProvider;\n  this.config=config;\n}\n", "docstring": "creates a new store for configuration values .", "partition": "test"}
{"idx": "4266", "code": "public static Workflow.Method restoreFromCloneMethod(URI storage,List<URI> clone,Boolean updateOpStatus,boolean isCG){\n  return new Workflow.Method(\"restoreFromCloneStep\",storage,clone,updateOpStatus,isCG);\n}\n", "docstring": "return a workflow . method for restorevolume", "partition": "test"}
{"idx": "2728", "code": "private synchronized boolean _restart() throws ServletException {\n  if (singelton != null)   singelton.reset();\n  initEngine();\n  System.gc();\n  return true;\n}\n", "docstring": "restart the cfml engine", "partition": "test"}
{"idx": "400", "code": "public static void runFinalization(){\n  RUNTIME.runFinalization();\n}\n", "docstring": "provides a hint to the virtual machine that it would be useful to attempt to perform any outstanding object finalizations .", "partition": "test"}
{"idx": "3916", "code": "public void modify(SSOToken token,String objName,ModificationItem[] mods) throws SMSException, SSOException {\n  if ((objName == null) || (objName.length() == 0) || (mods == null)|| (mods.length == 0)) {\n    throw new IllegalArgumentException(\"SMSFlatFileObject.modify: \" + \"One or more arguments is null or empty\");\n  }\n  String objKey=objName.toLowerCase();\n  String filepath=null;\n  mRWLock.readRequest();\n  try {\n    filepath=mNameMap.getProperty(objKey);\n    if (filepath == null) {\n      String errmsg=\"SMSFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n  }\n  finally {\n    mRWLock.readDone();\n  }\n  mRWLock.writeRequest();\n  try {\n    filepath=mNameMap.getProperty(objKey);\n    if (filepath == null) {\n      String errmsg=\"SMSFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    File filehandle=new File(filepath);\n    if (!filehandle.isFile()) {\n      String errmsg=\"SMSFlatFileObject.modify: Attributes file for object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    Properties props=loadProperties(filehandle,objName);\n    boolean hasSunXmlKeyValue=(props.getProperty(SMSEntry.ATTR_XML_KEYVAL) == null) ? false : true;\n    for (int i=0; i < mods.length; i++) {\n      modifyValues(objName,mods[i],props);\n    }\n    saveProperties(props,filehandle,objName);\n    if (!hasSunXmlKeyValue) {\n      hasSunXmlKeyValue=(props.getProperty(SMSEntry.ATTR_XML_KEYVAL) == null) ? false : true;\n    }\n    if (hasSunXmlKeyValue) {\n      deleteSunXmlKeyValFiles(filehandle.getParentFile());\n      Set xmlKeyVals=toValSet(SMSEntry.ATTR_XML_KEYVAL,props.getProperty(SMSEntry.ATTR_XML_KEYVAL));\n      createSunXmlKeyValFiles(filehandle.getParentFile(),xmlKeyVals);\n    }\n  }\n  finally {\n    mRWLock.writeDone();\n  }\n}\n", "docstring": "modify the attributes for the given configuration object .", "partition": "test"}
{"idx": "880", "code": "public static NativePage createNativePageForURL(String url,NativePage candidatePage,Tab tab,TabModelSelector tabModelSelector,Activity activity){\n  return createNativePageForURL(url,candidatePage,tab,tabModelSelector,activity,tab.isIncognito());\n}\n", "docstring": "returns a nativepage for displaying the given url if the url is a valid chrome - native url , or null otherwise . if candidatepage is non - null and corresponds to the url , it will be returned . otherwise , a new nativepage will be constructed .", "partition": "test"}
{"idx": "3908", "code": "public void fill_ellipse_arr(PlaEllipse[] p_ellipse_arr,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  if (p_ellipse_arr.length <= 0)   return;\n  GeneralPath draw_path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n  for (  PlaEllipse curr_ellipse : p_ellipse_arr) {\n    Point2D center=coordinate_transform.board_to_screen(curr_ellipse.center);\n    double bigger_radius=coordinate_transform.board_to_screen(curr_ellipse.bigger_radius);\n    if (!point_near_rectangle(center.getX(),center.getY(),(Rectangle)p_g.getClip(),bigger_radius)) {\n      continue;\n    }\n    double smaller_radius=coordinate_transform.board_to_screen(curr_ellipse.smaller_radius);\n    Ellipse2D draw_ellipse=new Ellipse2D.Double(center.getX() - bigger_radius,center.getY() - smaller_radius,2 * bigger_radius,2 * smaller_radius);\n    double rotation=coordinate_transform.board_to_screen_angle(curr_ellipse.rotation);\n    AffineTransform affine_transform=new AffineTransform();\n    affine_transform.rotate(rotation,center.getX(),center.getY());\n    Shape rotated_ellipse=affine_transform.createTransformedShape(draw_ellipse);\n    draw_path.append(rotated_ellipse,false);\n  }\n  Graphics2D g2=(Graphics2D)p_g;\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_path);\n}\n", "docstring": "draws the interiour of an array of ellipses . ellipses contained in an other ellipse are treated as holes .", "partition": "test"}
{"idx": "3641", "code": "public final <T>void removeInternal(List<T> list,int position){\n  if (hasHeaderView() && position == 0)   return;\n  if (enableLoadMore() && position == getItemCount() - 1)   return;\n  if (list.size() > 0) {\nsynchronized (mLock) {\n      list.remove(hasHeaderView() ? position - 1 : position);\n    }\n    removeNotifyExternal(position);\n    notifyItemRemoved(position);\n  }\n}\n", "docstring": "remove a item of the list of the adapter", "partition": "test"}
{"idx": "1740", "code": "public void addListener(CircularProgressViewListener listener){\n  if (listener != null)   listeners.add(listener);\n}\n", "docstring": "register a circularprogressviewlistener with this view", "partition": "test"}
{"idx": "4140", "code": "private void fillXMLAttribute(Attributes att,int index){\n  fillQName(fAttributeQName,att.getURI(index),att.getLocalName(index),att.getQName(index));\n  String type=att.getType(index);\n  fAttributes.addAttributeNS(fAttributeQName,(type != null) ? type : XMLSymbols.fCDATASymbol,att.getValue(index));\n}\n", "docstring": "adds an attribute to the xmlattributes object .", "partition": "test"}
{"idx": "519", "code": "public boolean indicateDirtyRead(ITemplateHolder template){\n  return ((template.isReadOperation() && _useDirtyRead) || template.isDirtyReadRequested());\n}\n", "docstring": "given an entry and a template , return true if dirty - read should be performed", "partition": "test"}
{"idx": "439", "code": "public boolean checkModifiers(MouseEvent e){\n  return e.getModifiers() == modifiers;\n}\n", "docstring": "check the mouse event modifiers against the instance member modifiers . default implementation checks equality . can be overridden to test with a mask", "partition": "test"}
{"idx": "2134", "code": "protected final void dragDropFinished(final boolean success,final int operations,final int x,final int y){\n  DragSourceEvent event=new DragSourceDropEvent(getDragSourceContext(),operations & sourceActions,success,x,y);\n  EventDispatcher dispatcher=new EventDispatcher(DISPATCH_FINISH,event);\n  SunToolkit.invokeLaterOnAppContext(SunToolkit.targetToAppContext(getComponent()),dispatcher);\n  startSecondaryEventLoop();\n  setNativeContext(0);\n  dragImage=null;\n  dragImageOffset=null;\n}\n", "docstring": "upcall from native code via implemented class ( do )", "partition": "test"}
{"idx": "2535", "code": "public double elasticity(final double spot){\n  final double val=value();\n  final double del=delta(spot);\n  if (val > Constants.QL_EPSILON)   return del / val * spot;\n else   if (Math.abs(del) < Constants.QL_EPSILON)   return 0.0;\n else   if (del > 0.0)   return Double.MAX_VALUE;\n else   return Double.MIN_VALUE;\n}\n", "docstring": "sensitivity in percent to a percent change in the underlying spot price .", "partition": "test"}
{"idx": "4079", "code": "private void updateZoningMap(UnManagedExportMask mask,List<Initiator> initiators,List<StoragePort> storagePorts){\n  ZoneInfoMap zoningMap=networkDeviceController.getInitiatorsZoneInfoMap(initiators,storagePorts);\n  for (  ZoneInfo zoneInfo : zoningMap.values()) {\n    log.info(\"Found zone: {} for initiator {} and port {}\",new Object[]{zoneInfo.getZoneName(),zoneInfo.getInitiatorWwn(),zoneInfo.getPortWwn()});\n  }\n  mask.setZoningMap(zoningMap);\n}\n", "docstring": "set mask zoning map", "partition": "test"}
{"idx": "2387", "code": "public DNetscapeCaPolicyUrl(JDialog parent){\n  super(parent);\n  setTitle(res.getString(\"DNetscapeCaPolicyUrl.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dnetscapecapolicyurl dialog .", "partition": "test"}
{"idx": "652", "code": "private void nukeSymbols(){\n  _count=0;\n  _longestCollisionList=0;\n  Arrays.fill(_mainHash,0);\n  Arrays.fill(_mainNames,null);\n  Arrays.fill(_collList,null);\n  _collCount=0;\n  _collEnd=0;\n}\n", "docstring": "helper method called to empty all shared symbols , but to leave arrays allocated", "partition": "test"}
{"idx": "747", "code": "public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumIterations\");\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration of the additional measure names", "partition": "test"}
{"idx": "3712", "code": "public static String readFileAsString(File file,String encoding) throws IOException {\n  ByteBuffer buffer=readFile(file);\n  if (null == encoding) {\n    encoding=\"UTF-8\";\n  }\n  String converted=new String(buffer.array(),encoding);\n  return converted;\n}\n", "docstring": "new nio based method to read a file as a string with the given encoding .", "partition": "test"}
{"idx": "1195", "code": "public AnnotationDrawer(final AnnotationsModel model,final ProcessRendererModel rendererModel){\n  this.model=model;\n  this.rendererModel=rendererModel;\n  this.displayCache=new HashMap<>();\n  this.cachedID=new HashMap<>();\n  pane=new JEditorPane(\"text/html\",\"\");\n  pane.setBorder(null);\n  pane.setOpaque(false);\n}\n", "docstring": "creates a new drawer for the specified model and decorator .", "partition": "test"}
{"idx": "111", "code": "public double percentage(ConstantRange range){\n  SortedSet<Constant> sorted=values();\n  SortedSet<Constant> contained=new TreeSet<Constant>();\n  Constant prev=null;\n  for (  Constant pct : sorted) {\n    if (range.contains(pct))     contained.add(pct);\n else     if (contained.isEmpty())     prev=pct;\n  }\n  if (contained.size() == 0)   return 0.0;\n  double prevPercent=prev == null ? 0.0 : pcts.get(prev);\n  return pcts.get(contained.last()) - prevPercent;\n}\n", "docstring": "gets the percent of values within the specified value range .", "partition": "test"}
{"idx": "1212", "code": "public String toString(){\n  return \"Value: \" + String.format(\"%5.2f%%\",ValueSimilarity * 100.0) + \" Containment: \"+ String.format(\"%5.2f%%\",ContainmentSimilarity * 100.0)+ \" Size: \"+ String.format(\"%5.2f%%\",SizeSimilarity * 100.0);\n}\n", "docstring": "return a string representation of this object , describing all aspects of similarity .", "partition": "test"}
{"idx": "1920", "code": "public void despawn(VisibleObject object){\n  despawn(object,true);\n}\n", "docstring": "despawn visibleobject , object will become invisible and object position will become invalid . all others objects will be noticed that this object is no longer visible .", "partition": "test"}
{"idx": "4060", "code": "private static CharHandler parseUnprintableExtCodes(String[] codeStrings){\n  if (codeStrings.length != 1) {\n    throw new IllegalStateException(\"Unexpected code strings \" + Arrays.asList(codeStrings));\n  }\n  byte[] bytes=codesToBytes(codeStrings[0],true);\n  if (bytes.length != 1) {\n    throw new IllegalStateException(\"Unexpected code strings \" + Arrays.asList(codeStrings));\n  }\n  return new UnprintableExtCharHandler(bytes[0]);\n}\n", "docstring": "returns a unprintableextcharhandler parsed from the given index code strings .", "partition": "test"}
{"idx": "2471", "code": "static public void addAll(List<String> list,String[] array){\n  for (  String item : array)   list.add(item);\n}\n", "docstring": "adds all items in the specific array to the specific list .", "partition": "test"}
{"idx": "3532", "code": "@Override protected void beforeModelLinked(EObject model,IDiagnosticConsumer diagnosticsConsumer){\n  ImportedNamesAdapter adapter=ImportedNamesAdapter.find(model.eResource());\n  if (adapter != null)   adapter.clear();\n  UnionMemberScope.clearCachedComposedMembers(model);\n}\n", "docstring": "removes the imported names before linking and cleans other caches attached to the ast .", "partition": "test"}
{"idx": "512", "code": "private void initializeMessages(List<String> messages){\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getGeneralMessages()));\n  if (OSUtils.isWindows()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getWindowsMessages()));\n  }\n else   if (OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getMacOSXMessages()));\n  }\n else   if (OSUtils.isLinux()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getLinuxMessages()));\n  }\n else {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getOtherMessages()));\n  }\n  if (!OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getNonMacOSXMessages()));\n  }\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getFrostWireMessages()));\n  Collections.shuffle(messages);\n  _currentTip=-1;\n}\n", "docstring": "iterates through all the tips \"'\" keys and stores the ones that are valid for this os .", "partition": "test"}
{"idx": "1021", "code": "public void splitNode(KDTreeNode node,int numNodesCreated,double[][] nodeRanges,double[][] universe) throws Exception {\n  correctlyInitialized();\n  if (node.m_NodesRectBounds == null) {\n    node.m_NodesRectBounds=new double[2][node.m_NodeRanges.length];\n    for (int i=0; i < node.m_NodeRanges.length; i++) {\n      node.m_NodesRectBounds[MIN][i]=node.m_NodeRanges[i][MIN];\n      node.m_NodesRectBounds[MAX][i]=node.m_NodeRanges[i][MAX];\n    }\n  }\n  double maxRectWidth=Double.NEGATIVE_INFINITY, maxPtWidth=Double.NEGATIVE_INFINITY, tempval;\n  int splitDim=-1, classIdx=m_Instances.classIndex();\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval > maxRectWidth && node.m_NodeRanges[i][WIDTH] > 0.0)     maxRectWidth=tempval;\n  }\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval >= maxRectWidth * (1 - ERR) && node.m_NodeRanges[i][WIDTH] > 0.0) {\n      if (node.m_NodeRanges[i][WIDTH] > maxPtWidth) {\n        maxPtWidth=node.m_NodeRanges[i][WIDTH];\n        if (m_NormalizeNodeWidth)         maxPtWidth=maxPtWidth / universe[i][WIDTH];\n        splitDim=i;\n      }\n    }\n  }\n  double splitVal=node.m_NodesRectBounds[MIN][splitDim] + (node.m_NodesRectBounds[MAX][splitDim] - node.m_NodesRectBounds[MIN][splitDim]) * 0.5;\n  if (splitVal < node.m_NodeRanges[splitDim][MIN])   splitVal=node.m_NodeRanges[splitDim][MIN];\n else   if (splitVal >= node.m_NodeRanges[splitDim][MAX])   splitVal=node.m_NodeRanges[splitDim][MAX] - node.m_NodeRanges[splitDim][WIDTH] * 0.001;\n  int rightStart=rearrangePoints(m_InstList,node.m_Start,node.m_End,splitDim,splitVal);\n  if (rightStart == node.m_Start || rightStart > node.m_End) {\n    if (rightStart == node.m_Start)     throw new Exception(\"Left child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n else     throw new Exception(\"Right child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n  }\n  node.m_SplitDim=splitDim;\n  node.m_SplitValue=splitVal;\n  double[][] widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MAX][splitDim]=splitVal;\n  node.m_Left=new KDTreeNode(numNodesCreated + 1,node.m_Start,rightStart - 1,m_EuclideanDistance.initializeRanges(m_InstList,node.m_Start,rightStart - 1),widths);\n  widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MIN][splitDim]=splitVal;\n  node.m_Right=new KDTreeNode(numNodesCreated + 2,rightStart,node.m_End,m_EuclideanDistance.initializeRanges(m_InstList,rightStart,node.m_End),widths);\n}\n", "docstring": "splits a node into two based on the midpoint value of the dimension in which the node \"'\" s rectangle is widest . if after splitting one side is empty then it is slided towards the non - empty side until there is at least one point on the empty side . the two nodes created after the whole splitting are correctly initialised . and , node . left and node . right are set appropriately .", "partition": "test"}
{"idx": "2109", "code": "protected final void firePropertyChange(String propertyName,long oldValue,long newValue){\n  firePropertyChange(propertyName,Long.valueOf(oldValue),Long.valueOf(newValue));\n}\n", "docstring": "support for reporting bound property changes for integer properties . this method can be called when a bound property has changed and it will send the appropriate propertychangeevent to any registered propertychangelisteners .", "partition": "test"}
{"idx": "791", "code": "public void add(String name,long cnt){\n  if (_values == null) {\n    _values=new ArrayList<>(30);\n  }\n  _values.add(new Count(this,name,cnt));\n}\n", "docstring": "insert at the end of the list", "partition": "test"}
{"idx": "1907", "code": "private Map<UUID,int[]> reducers(Collection<ClusterNode> top,Map<UUID,Collection<HadoopInputSplit>> mappers,int reducerCnt){\n  int totalWeight=0;\n  List<WeightedNode> nodes=new ArrayList<>(top.size());\n  for (  ClusterNode node : top) {\n    Collection<HadoopInputSplit> split=mappers.get(node.id());\n    int weight=reducerNodeWeight(node,split != null ? split.size() : 0);\n    nodes.add(new WeightedNode(node.id(),weight,weight));\n    totalWeight+=weight;\n  }\n  int totalAdjustedWeight=0;\n  for (  WeightedNode node : nodes) {\n    node.floatWeight=((float)node.weight * reducerCnt) / totalWeight;\n    node.weight=Math.round(node.floatWeight);\n    totalAdjustedWeight+=node.weight;\n  }\n  Collections.sort(nodes);\n  if (totalAdjustedWeight > reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(nodes.size() - 1);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasPrevious())       iter=nodes.listIterator(nodes.size() - 1);\n      WeightedNode node=iter.previous();\n      if (node.weight > 0) {\n        node.weight-=1;\n        totalAdjustedWeight--;\n      }\n    }\n  }\n else   if (totalAdjustedWeight < reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(0);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasNext())       iter=nodes.listIterator(0);\n      WeightedNode node=iter.next();\n      if (node.floatWeight > 0.0f) {\n        node.weight+=1;\n        totalAdjustedWeight++;\n      }\n    }\n  }\n  int idx=0;\n  Map<UUID,int[]> reducers=new HashMap<>(nodes.size(),1.0f);\n  for (  WeightedNode node : nodes) {\n    if (node.weight > 0) {\n      int[] arr=new int[node.weight];\n      for (int i=0; i < arr.length; i++)       arr[i]=idx++;\n      reducers.put(node.nodeId,arr);\n    }\n  }\n  return reducers;\n}\n", "docstring": "create plan for reducers .", "partition": "test"}
{"idx": "3612", "code": "@SuppressWarnings(\"unchecked\") private void expungeStaleEntries(){\nsynchronized (sync) {\n    ListWeakReference r;\n    while ((r=(ListWeakReference)queue.poll()) != null) {\n      ListEntry le=r.getListEntry();\n      int i=list.indexOf(le);\n      if (i != -1) {\n        list.remove(i);\n      }\n    }\n  }\n}\n", "docstring": "expunge stale entries from the list .", "partition": "test"}
{"idx": "3322", "code": "private void SaveGCMData(){\n  try {\n    SharedPreferences preferences=getSharedPreferences();\n    SharedPreferences.Editor editor=preferences.edit();\n    editor.putString(PREFS_PUSHER_APP_ID_KEY,mPusherAppId);\n    editor.putString(PREFS_PUSHER_URL_KEY,mPusherUrl);\n    editor.putString(PREFS_PUSHER_FILE_TAG_KEY,mPusherBaseFileTag);\n    editor.commit();\n  }\n catch (  Exception e) {\n    Log.e(LOG_TAG,\"SaveGCMData failed \" + e.getLocalizedMessage());\n  }\n}\n", "docstring": "save the gcm info to the preferences", "partition": "test"}
{"idx": "3485", "code": "public static String formatLong(long number){\n  return intFormat.format(number);\n}\n", "docstring": "formats a long value . for example : input = 1234567 / output = 1 , 234 , 567 .", "partition": "test"}
{"idx": "830", "code": "public void deleteSubGroupContainers(Set groupContainers) throws AMException, SSOException {\n  Iterator iter=groupContainers.iterator();\n  while (iter.hasNext()) {\n    String groupContainerDN=(String)iter.next();\n    AMGroupContainer groupContainer=new AMGroupContainerImpl(token,groupContainerDN);\n    groupContainer.delete();\n  }\n}\n", "docstring": "deletes sub group containers in this group container .", "partition": "test"}
{"idx": "21", "code": "public boolean removeShutdownHook(Thread hook){\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(RuntimePermissionCollection.SHUTDOWN_HOOKS_PERMISSION);\n  }\n  if (hook == null)   throw new NullPointerException(\"null is not allowed here\");\n  if (VMState > 0) {\n    throw new IllegalStateException();\n  }\nsynchronized (hooksList) {\n    return hooksList.remove(hook);\n  }\n}\n", "docstring": "de - registers a previously - registered virtual - machine shutdown hook .", "partition": "test"}
{"idx": "1875", "code": "protected void paintContentBorderTopEdge(Graphics g,int x,int y,int w,int h,boolean drawBroken,Rectangle selRect,boolean isContentBorderPainted){\n  if (isContentBorderPainted) {\n    g.setColor(selectHighlight);\n    g.fillRect(x,y,w - 1,1);\n  }\n}\n", "docstring": "draws the top edge of the border around the content area . draw unbroken line for tabs are not on top override where appropriate .", "partition": "test"}
{"idx": "676", "code": "public static IgniteLogger logger(GridKernalContext ctx,AtomicReference<IgniteLogger> logRef,Object obj){\n  IgniteLogger log=logRef.get();\n  if (log == null) {\n    logRef.compareAndSet(null,ctx.log(obj.getClass()));\n    log=logRef.get();\n  }\n  return log;\n}\n", "docstring": "initializes logger into / from log reference passed in .", "partition": "test"}
{"idx": "2025", "code": "SegmentManager commitIndex(long commitIndex){\n  this.commitIndex=Math.max(this.commitIndex,commitIndex);\n  return this;\n}\n", "docstring": "sets the log commit index .", "partition": "test"}
{"idx": "170", "code": "private void refreshDoneButton(boolean done){\n  butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n}\n", "docstring": "refreshes the done button . the label will say the opposite of the player \"'\" s \" done \" status , indicating that clicking it will reverse the condition .", "partition": "test"}
{"idx": "760", "code": "public synchronized void trackHexImages(IHex hex,MediaTracker tracker){\n  Image base=hexToImageCache.get(hex);\n  List<Image> superImgs=hexToImageListCache.get(hex);\n  List<Image> orthoImgs=orthoListCache.get(hex);\n  tracker.addImage(base,1);\n  if (superImgs != null) {\n    for (Iterator<Image> i=superImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n  if (orthoImgs != null) {\n    for (Iterator<Image> i=orthoImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n}\n", "docstring": "adds all images associated with the hex to the specified tracker", "partition": "test"}
{"idx": "2257", "code": "private static String formatSampleRate(int rate){\n  return MHZ_FORMATTER.format((double)rate / 1E6d);\n}\n", "docstring": "formats the rate in hertz for display as megahertz", "partition": "test"}
{"idx": "2265", "code": "public void generateClassFile(OutputStream os){\n  ClassWriter cw=new SootASMClassWriter(ClassWriter.COMPUTE_FRAMES);\n  cv=cw;\n  generateByteCode();\n  try {\n    os.write(cw.toByteArray());\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Could not write class file in the ASM-backend!\",e);\n  }\n}\n", "docstring": "outputs the bytecode generated as a class file", "partition": "test"}
{"idx": "543", "code": "public static int removeArgsAndReturnInsertionIndex(List<String> args,int argIndex,boolean tryRemovingArgValue){\n  if (argIndex < 0 || argIndex >= args.size()) {\n    return 0;\n  }\n  if (tryRemovingArgValue) {\n    String argValue=getArgValue(args,argIndex + 1);\n    if (argValue != null) {\n      args.remove(argIndex + 1);\n    }\n  }\n  args.remove(argIndex);\n  return argIndex;\n}\n", "docstring": "removes the argument at the given index .", "partition": "test"}
{"idx": "2877", "code": "public static boolean enoughSpaceOnPhone(long updateSize){\n  return getRealSizeOnPhone() > updateSize;\n}\n", "docstring": "checks if there is enough space on phone self", "partition": "test"}
{"idx": "56", "code": "public void writeNoScale(Image c,Component i){\n  if (page == null) {\n    newpage();\n  }\n  int x=x0 + width - (c.getWidth(null) + charwidth);\n  int y=y0 + (linenum * lineheight) + lineascent;\n  if (page != null && pagenum >= prFirst) {\n    page.drawImage(c,x,y,c.getWidth(null),c.getHeight(null),null);\n  }\n}\n", "docstring": "write a graphic to the printout . < p > this was not in the original class , but was added afterwards by kevin dickerson . it is a copy of the write , but without the scaling . < p > the image is positioned on the right side of the paper , at the current height .", "partition": "test"}
{"idx": "3664", "code": "public boolean isLessThen(Percent Percent){\n  assertDefined();\n  BigDecimal thisValue=notNull(this);\n  BigDecimal parameter=notNull(Percent);\n  return (thisValue.compareTo(parameter) < 0);\n}\n", "docstring": "compares two percent objects .", "partition": "test"}
{"idx": "4252", "code": "public void close() throws IOException {\n  rrdFile.close();\n}\n", "docstring": "closes this database stream and releases any associated system resources .", "partition": "test"}
{"idx": "4179", "code": "public void testInvokeAll2() throws InterruptedException {\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    List<Future<String>> r=e.invokeAll(new ArrayList<Callable<String>>());\n    assertTrue(r.isEmpty());\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "invokeall ( empty collection ) returns empty collection", "partition": "test"}
{"idx": "2269", "code": "private void checkShutdown(){\nsynchronized (mux) {\n    if (isBeingShutdown)     throw new RejectedExecutionException(\"Failed to execute command during executor shutdown.\");\n  }\n}\n", "docstring": "checks if service is being shutdown .", "partition": "test"}
{"idx": "3391", "code": "public void addAttributeFor(final Field field){\n  fieldToUseAsAttribute.add(field);\n}\n", "docstring": "tells this mapper to use an attribute for this field .", "partition": "test"}
{"idx": "4043", "code": "public void run(){\n  start();\n  try {\n    while (true) {\n      Thread.sleep(interval);\n      processConfigMessages();\n    }\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n    log.warn(\"Got interrupt in config manager thread, so shutting down\");\n  }\n finally {\n    log.info(\"Stopping the config manager\");\n    stop();\n  }\n}\n", "docstring": "this method is an infinite loop that periodically checks if there are any new messages in the job coordinator stream , and reads them if they exist . then it reacts accordingly based on the configuration that is being set . the method the calls the start ( ) method to initialized the system , runs in a infinite loop , and calls the stop ( ) method at the end to stop the consumer and the system", "partition": "test"}
{"idx": "2669", "code": "private void changeAnnotationDocumentState(SourceDocument aSourceDocument,User aUser,AnnotationDocumentStateTransition aAnnotationDocumentStateTransition){\n  AnnotationDocument annotationDocument=repository.getAnnotationDocument(aSourceDocument,aUser);\n  annotationDocument.setState(AnnotationDocumentStateTransition.transition(aAnnotationDocumentStateTransition));\n  try {\n    repository.createAnnotationDocument(annotationDocument);\n  }\n catch (  IOException e) {\n    LOG.info(\"Unable to get the LOG file\");\n  }\n}\n", "docstring": "change the state of an annotation document . used to re - open closed documents", "partition": "test"}
{"idx": "3756", "code": "public void externalEntityDecl(String name,XMLResourceIdentifier identifier,Augmentations augs) throws XNIException {\n  try {\n    if (fDeclHandler != null) {\n      String publicId=identifier.getPublicId();\n      String systemId=fResolveDTDURIs ? identifier.getExpandedSystemId() : identifier.getLiteralSystemId();\n      fDeclHandler.externalEntityDecl(name,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}\n", "docstring": "an external entity declaration .", "partition": "test"}
{"idx": "4269", "code": "public void clearNameInUnoccupiedBlocks(){\n  for (int i=0; i < mBlockEntries.size(); i++) {\n    Block b=mBlockEntries.get(i);\n    if (b.getState() == Block.UNOCCUPIED) {\n      b.setValue(\"  \");\n    }\n  }\n}\n", "docstring": "this function clears the block values for blocks in this section .", "partition": "test"}
{"idx": "4173", "code": "@Override public DataSource createDataSource(Properties properties) throws SQLException {\n  Properties propertiesCopy=new Properties();\n  if (properties != null) {\n    propertiesCopy.putAll(properties);\n  }\n  rejectUnsupportedOptions(propertiesCopy);\n  rejectPoolingOptions(propertiesCopy);\n  JdbcDataSource dataSource=new JdbcDataSource();\n  setupH2DataSource(dataSource,propertiesCopy);\n  return dataSource;\n}\n", "docstring": "creates a basic data source .", "partition": "test"}
{"idx": "297", "code": "private void resolveFiles(List<String> classpaths,Map<String,String> files,String[] paths,String prefix){\n  for (  String path : paths) {\n    String relativePath=fileHandler.getName(path);\n    if (prefix != null) {\n      relativePath=fileHandler.append(prefix,relativePath);\n    }\n    if (classpaths != null) {\n      classpaths.add(relativePath);\n    }\n    if (fileHandler.isDirectory(path)) {\n      String[] children=fileHandler.getChildren(path);\n      if (children != null && children.length != 0) {\n        resolveFiles(null,files,children,relativePath);\n      }\n    }\n else {\n      files.put(relativePath,path);\n    }\n  }\n}\n", "docstring": "resolves all files it finds into a map , with relative paths as the key and absolute path as the value .", "partition": "test"}
{"idx": "1403", "code": "public XwavesLabelfileReader(Reader reader) throws IOException {\n  this.reader=new BufferedReader(reader);\n  parseLabels();\n  reader.close();\n}\n", "docstring": "read data from a label file .", "partition": "test"}
{"idx": "430", "code": "protected void processBytes(byte[] buf,int off,int len){\n  nBytesIn+=len;\n  if (len < 1 || state.isDone())   return;\n  if (state == State.ROW_READY)   throw new PngjInputException(\"this should only be called if waitingForMoreInput\");\n  if (inf.needsDictionary() || !inf.needsInput())   throw new RuntimeException(\"should not happen\");\n  inf.setInput(buf,off,len);\n  if (isCallbackMode()) {\n    while (inflateData()) {\n      int nextRowLen=processRowCallback();\n      prepareForNextRow(nextRowLen);\n      if (isDone())       processDoneCallback();\n    }\n  }\n else   inflateData();\n}\n", "docstring": "feeds the inflater with the compressed bytes in poll mode , the caller should not call repeatedly this , without consuming first , checking isdatareadyforconsumer ( )", "partition": "test"}
{"idx": "1487", "code": "public void hasNetworkConnection(NetworkRequestCheckListener listener){\n  if (hasNetworkConnection()) {\n    testNetworkRequest(listener);\n  }\n else {\n    listener.onNoResponse();\n  }\n}\n", "docstring": "utility method which checks current network connection state , but will also try to perform test network request , in order to determine if user can actually perform any network operation .", "partition": "test"}
{"idx": "2114", "code": "public int findStartOfColumn(int column){\n  if (column == mColumns)   return getSpaceUsed();\n  int currentColumn=0;\n  int currentCharIndex=0;\n  while (true) {\n    int newCharIndex=currentCharIndex;\n    char c=mText[newCharIndex++];\n    boolean isHigh=Character.isHighSurrogate(c);\n    int codePoint=isHigh ? Character.toCodePoint(c,mText[newCharIndex++]) : c;\n    int wcwidth=WcWidth.width(codePoint);\n    if (wcwidth > 0) {\n      currentColumn+=wcwidth;\n      if (currentColumn == column) {\n        while (newCharIndex < mSpaceUsed) {\n          if (Character.isHighSurrogate(mText[newCharIndex])) {\n            if (WcWidth.width(Character.toCodePoint(mText[newCharIndex],mText[newCharIndex + 1])) <= 0) {\n              newCharIndex+=2;\n            }\n else {\n              break;\n            }\n          }\n else           if (WcWidth.width(mText[newCharIndex]) <= 0) {\n            newCharIndex++;\n          }\n else {\n            break;\n          }\n        }\n        return newCharIndex;\n      }\n else       if (currentColumn > column) {\n        return currentCharIndex;\n      }\n    }\n    currentCharIndex=newCharIndex;\n  }\n}\n", "docstring": "note that the column may end of second half of wide character .", "partition": "test"}
{"idx": "1671", "code": "public static File searchPaths(Iterable<? extends File> paths,String relFile){\n  for (  File path : paths) {\n    File f=new File(path,relFile);\n    if (f.exists()) {\n      return path;\n    }\n  }\n  return null;\n}\n", "docstring": "given a relative file path and a list of \" search paths \" returns the search path where the file was located", "partition": "test"}
{"idx": "3213", "code": "@Override public long freeMemory(long windowId) throws IOException {\n  long size=keyStream.dataSizeUpToWindow(windowId) + valueStream.dataSizeUpToWindow(windowId);\n  windowsForFreeMemory.add(windowId);\n  return size;\n}\n", "docstring": "free memory up to the given windowid this method will be called by another thread . adding concurrency control to stream would impact the performance . this method only calculates the size of the memory that could be released and then sends free memory request to the operator thread", "partition": "test"}
{"idx": "2562", "code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n    sb.append((char)bb.get(0));\n    return i + 2;\n  }\n else {\n    CharBuffer cb=UTF_8_CHARSET.decode(bb);\n    sb.append(cb.toString());\n    return i + bb.limit() * 3 - 1;\n  }\n}\n", "docstring": "decodes octets to characters using the utf - 8 decoding and appends the characters to a stringbuffer .", "partition": "test"}
{"idx": "3516", "code": "public void labelDistances(Hypergraph<V,E> graph,V root){\n  labelDistances(graph,Collections.singleton(root));\n}\n", "docstring": "computes the distances of all the node from the specified root node . also keeps track of the predecessors of each node traversed as well as the order of nodes traversed .", "partition": "test"}
{"idx": "2997", "code": "public void beginUpdateMemoryUsed(long bytesUsed,boolean willSendEvent);\n", "docstring": "called at the beginning of updatememoryused .", "partition": "test"}
{"idx": "4141", "code": "public JComponent createPropertyGUI(PropertyConsumer pc){\n  this.propertyConsumer=pc;\n  Properties props=new Properties();\n  props=pc.getProperties(props);\n  Properties info=new Properties();\n  info=pc.getPropertyInfo(info);\n  String prefix=pc.getPropertyPrefix();\n  return createPropertyGUI(prefix,props,info);\n}\n", "docstring": "creates a jcomponent with the properties to be changed . this component is suitable for inclusion into a gui .", "partition": "test"}
{"idx": "4056", "code": "public void calculateMin(double min){\n  if (this.min == -1) {\n    this.min=min;\n  }\n else {\n    this.min=Math.min(this.min,min);\n  }\n}\n", "docstring": "sets the minimum and deals with the - 1 initialization ! .", "partition": "test"}
{"idx": "417", "code": "public ObjectMapper nextLevel(ObjectMapper level){\n  ObjectMapper previous=levelStack.peek();\n  levelStack.push(level);\n  return previous;\n}\n", "docstring": "sets the new current nested level and pushes old current nested level down the stack returns that level .", "partition": "test"}
{"idx": "1188", "code": "private List<double[]> initializeWeightsND(){\n  int N=50;\n  List<double[]> candidates=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfPoints * N; i++) {\n    double[] weight=new double[numberOfObjectives];\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]=PRNG.nextDouble();\n    }\n    double sum=StatUtils.sum(weight);\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]/=sum;\n    }\n    candidates.add(weight);\n  }\n  List<double[]> weights=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfObjectives; i++) {\n    double[] weight=new double[numberOfObjectives];\n    weight[i]=1.0;\n    weights.add(weight);\n  }\n  while (weights.size() < numberOfPoints) {\n    double[] weight=null;\n    double distance=Double.NEGATIVE_INFINITY;\n    for (int i=0; i < candidates.size(); i++) {\n      double d=Double.POSITIVE_INFINITY;\n      for (int j=0; j < weights.size(); j++) {\n        d=Math.min(d,MathArrays.distance(candidates.get(i),weights.get(j)));\n      }\n      if (d > distance) {\n        weight=candidates.get(i);\n        distance=d;\n      }\n    }\n    weights.add(weight);\n    candidates.remove(weight);\n  }\n  return weights;\n}\n", "docstring": "returns the weights for problems of arbitrary dimension .", "partition": "test"}
{"idx": "3827", "code": "public static Object deserialization(String filePath){\n  ObjectInputStream in=null;\n  try {\n    in=new ObjectInputStream(new FileInputStream(filePath));\n    Object o=in.readObject();\n    in.close();\n    return o;\n  }\n catch (  FileNotFoundException e) {\n    throw new RuntimeException(\"FileNotFoundException occurred. \",e);\n  }\ncatch (  ClassNotFoundException e) {\n    throw new RuntimeException(\"ClassNotFoundException occurred. \",e);\n  }\ncatch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtils.close(in);\n  }\n}\n", "docstring": "deserialization object from file .", "partition": "test"}
{"idx": "2015", "code": "public boolean endsWith(Name n){\n  if (n instanceof CompoundName) {\n    return (impl.endsWith(n.size(),n.getAll()));\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "determines whether a compound name is a suffix of this compound name . a compound name \"'\" n \"'\" is a suffix if it it is equal to getsuffix ( size ( ) - n . size ( ) ) - - in other words , this compound name ends with \"'\" n \"'\" . if n is null or not a compound name , false is returned . < p > implementation note : currently the syntax properties of n are not used when doing the comparison . they might be in the future .", "partition": "test"}
{"idx": "966", "code": "public void testOtherToStringDefault(){\n  NumberConverter converter=makeConverter();\n  assertEquals(\"Default Convert \",\"ABC\",converter.convert(String.class,new StringBuffer(\"ABC\")));\n}\n", "docstring": "convert other - - > string ( default conversion )", "partition": "test"}
{"idx": "3134", "code": "public static String pad(String string,int n,String padding,boolean right){\n  if (n < 0) {\n    n=0;\n  }\n  if (n < string.length()) {\n    return string.substring(0,n);\n  }\n else   if (n == string.length()) {\n    return string;\n  }\n  char paddingChar;\n  if (padding == null || padding.length() == 0) {\n    paddingChar=' ';\n  }\n else {\n    paddingChar=padding.charAt(0);\n  }\n  StringBuilder buff=new StringBuilder(n);\n  n-=string.length();\n  if (right) {\n    buff.append(string);\n  }\n  for (int i=0; i < n; i++) {\n    buff.append(paddingChar);\n  }\n  if (!right) {\n    buff.append(string);\n  }\n  return buff.toString();\n}\n", "docstring": "pad a string . this method is used for the sql function rpad and lpad .", "partition": "test"}
{"idx": "3154", "code": "public ModuleHandle addModule(String moduleName,String sessionKey){\n  String sanitizedModuleName=generateUniqueNameIfNullOrEmpty(moduleName,\"Module\");\n  ModuleHandle moduleHandle=new ModuleHandle(sanitizedModuleName,sessionKey);\nsynchronized (privateInstanceLock) {\n    modules.add(moduleHandle);\n  }\n  setTerminated(false);\n  return moduleHandle;\n}\n", "docstring": "add a module that was loaded in this browser tab . if the module name is null or the empty string , a name will be generated . it is legal to add a module with the same name and session key more than once . if this browser tab was marked as terminated , then it will be reset to the unterminated state . an event will be fired to all listeners on the model . note : this method fires events . if you \"'\" re invoking this method from other model classes , make sure that no locks are being held .", "partition": "test"}
{"idx": "1739", "code": "private InputStream findTemplate(String path,String template){\n  try {\n    File file=new File(path,template);\n    if (file.canRead()) {\n      return new BufferedInputStream(new FileInputStream(file.getAbsolutePath()));\n    }\n else {\n      return null;\n    }\n  }\n catch (  FileNotFoundException fnfe) {\n    return null;\n  }\n}\n", "docstring": "try to find a template given a normalized path .", "partition": "test"}
{"idx": "612", "code": "public void send(Set recipients,boolean multicast) throws InterruptedException, ReplyException {\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (Thread.interrupted())   throw new InterruptedException();\n  recipients=new HashSet(recipients);\n  DistributedMember me=originDm.getDistributionManagerId();\n  if (recipients.contains(me)) {\n    recipients.remove(me);\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"Recipients for SerialAckedMessage are {}\",recipients);\n  }\n  rp=new ReplyProcessor21(originDm,recipients);\n  processorId=rp.getProcessorId();\n  setRecipients(recipients);\n  setMulticast(multicast);\n  Set failures=originDm.putOutgoing(this);\n  if (failures != null && failures.size() > 0) {\n    for (Iterator i=failures.iterator(); i.hasNext(); ) {\n      InternalDistributedMember mbr=(InternalDistributedMember)i.next();\n      if (isDebugEnabled) {\n        logger.debug(\"Unable to send serial acked message to {}\",mbr);\n      }\n    }\n  }\n  rp.waitForReplies();\n}\n", "docstring": "send the message and wait for replies", "partition": "test"}
{"idx": "3977", "code": "private void cmd_import(){\n  JFileChooser jc=new JFileChooser();\n  jc.setDialogTitle(Msg.getMsg(Env.getCtx(),\"Import\"));\n  jc.setDialogType(JFileChooser.OPEN_DIALOG);\n  jc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n  if (jc.showOpenDialog(this) != JFileChooser.APPROVE_OPTION)   return;\n  StringBuffer sb=new StringBuffer();\n  try {\n    InputStreamReader in=new InputStreamReader(new FileInputStream(jc.getSelectedFile()));\n    char[] cbuf=new char[1024];\n    int count;\n    while ((count=in.read(cbuf)) > 0)     sb.append(cbuf,0,count);\n    in.close();\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,\"HTMLEditor.import\" + e.getMessage());\n    return;\n  }\n  setHtmlText(sb.toString());\n}\n", "docstring": "import text from file", "partition": "test"}
{"idx": "91", "code": "@RequestMapping(value=\"/SAML2/IDPSSO/{tenant:.*}\") public void ssoBindingError(Locale locale,@PathVariable(value=\"tenant\") String tenant,HttpServletResponse response) throws IOException {\n  logger.info(\"IDP SSO binding error! The client locale is \" + locale.toString() + \", tenant is \"+ tenant);\n  ssoDefaultTenantError(locale,response);\n}\n", "docstring": "handle request sent with a wrong binding", "partition": "test"}
{"idx": "2683", "code": "private void writePkgInfo() throws BuildException {\n  File pkgInfo=new File(mContentsDir,\"PkgInfo\");\n  PrintWriter writer=null;\n  try {\n    writer=new PrintWriter(new BufferedWriter(new FileWriter(pkgInfo)));\n    writer.print(bundleProperties.getCFBundlePackageType());\n    writer.println(bundleProperties.getCFBundleSignature());\n    writer.flush();\n  }\n catch (  IOException ex) {\n    throw new BuildException(\"Cannot create PkgInfo file: \" + ex);\n  }\n finally {\n    mFileUtils.close(writer);\n  }\n}\n", "docstring": "write the pkginfo file into the application bundle", "partition": "test"}
{"idx": "784", "code": "public static double[] lsf2lpc(double[] lsf){\n  MathUtils.quickSort(lsf);\n  int P=lsf.length;\n  int half_order=P / 2;\n  int i, j;\n  double xf, xx;\n  double[] a=new double[P / 2 + 1];\n  double[] a1=new double[P / 2 + 1];\n  double[] a2=new double[P / 2 + 1];\n  double[] b=new double[P / 2 + 1];\n  double[] b1=new double[P / 2 + 1];\n  double[] b2=new double[P / 2 + 1];\n  double[] p=new double[P / 2];\n  double[] q=new double[P / 2];\n  double[] oneMinusA=new double[P + 1];\n  oneMinusA[0]=1.;\n  if ((lsf[0] <= 0.0) || (lsf[0] >= 0.5)) {\n    throw new IllegalArgumentException(\"LSFs out of bounds; lsf[0] = \" + lsf[0]);\n  }\n  for (i=1; i < P; i++) {\n    if (lsf[i] <= lsf[i - 1])     throw new IllegalArgumentException(\"nonmonotonic LSFs\");\n    if ((lsf[i] <= 0.0) || (lsf[i] >= 0.5))     throw new IllegalArgumentException(\"LSFs out of bounds; lsf[\" + i + \"] = \"+ lsf[i]);\n  }\n  for (i=0; i < half_order; i++) {\n    p[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i]);\n    q[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i + 1]);\n  }\n  xf=0.0;\n  for (i=0; i <= P; i++) {\n    if (i == 0)     xx=1.0;\n else     xx=0.0;\n    a[0]=xx + xf;\n    b[0]=xx - xf;\n    xf=xx;\n    for (j=0; j < half_order; j++) {\n      a[j + 1]=a[j] + p[j] * a1[j] + a2[j];\n      b[j + 1]=b[j] + q[j] * b1[j] + b2[j];\n      a2[j]=a1[j];\n      a1[j]=a[j];\n      b2[j]=b1[j];\n      b1[j]=b[j];\n    }\n    if (i > 0)     oneMinusA[i]=0.5 * (a[half_order] + b[half_order]);\n  }\n  return oneMinusA;\n}\n", "docstring": "convert lsf frequencies into lpc coefficients . the analysis filter may be reconstructed : a ( z ) = 1 / 2 [ p ( z ) + q ( z ) ", "partition": "test"}
{"idx": "2608", "code": "public void add(final CertificateValidity certificateValidity){\n  certificateValidityList.add(certificateValidity);\n}\n", "docstring": "this method allows to add a candidate for the signing certificate .", "partition": "test"}
{"idx": "3596", "code": "protected void parseCommand(final String... args){\n  for (  String arg : args) {\n    final Command command=Command.valueOfName(arg);\n    if (command != null) {\n      setCommand(command);\n      break;\n    }\n  }\n}\n", "docstring": "iterates the list of arguments in search of the target locator launcher command .", "partition": "test"}
{"idx": "2479", "code": "private void validateReplicaAvailability(Slice slice,String shard,String collectionName,int count){\n  if (slice != null) {\n    Collection<Replica> allReplicasForShard=slice.getReplicas();\n    if (allReplicasForShard == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"No replicas found  in shard/collection: \" + shard + \"/\"+ collectionName);\n    }\n    if (allReplicasForShard.size() == 1) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"There is only one replica available in shard/collection: \" + shard + \"/\"+ collectionName+ \". Cannot delete that.\");\n    }\n    if (allReplicasForShard.size() <= count) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"There are lesser num replicas requested to be deleted than are available in shard/collection : \" + shard + \"/\"+ collectionName+ \" Requested: \"+ count+ \" Available: \"+ allReplicasForShard.size()+ \".\");\n    }\n  }\n}\n", "docstring": "validate if there is less replicas than requested to remove . also error out if there is only one replica available", "partition": "test"}
{"idx": "86", "code": "public void test_getPutByteArray(){\n  final int capacity=200;\n  final ByteArrayBuffer buf=new ByteArrayBuffer(capacity);\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(capacity - 1));\n  final int pos=1;\n  for (int i=0; i < LIMIT; i++) {\n    final byte[] expected=new byte[r.nextInt(capacity - 2)];\n    r.nextBytes(expected);\n    buf.put(pos,expected);\n    assertEquals(0,BytesUtil.compareBytesWithLenAndOffset(0,expected.length,expected,pos,expected.length,buf.array()));\n    final byte[] actual=new byte[expected.length];\n    buf.get(pos,actual);\n    assertTrue(BytesUtil.bytesEqual(expected,actual));\n  }\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(pos + capacity - 2));\n}\n", "docstring": "test bulk get / put byte [ ", "partition": "test"}
{"idx": "1639", "code": "public void updatePoint(float x,float y){\n  if (Math.sqrt(x * x + y * y) > 1.5)   if (listener != null) {\n    listener.onAngleChangedListener(getAngle(x,-y));\n  }\n}\n", "docstring": "update the gravity point only if a the gravity vector is longer than the threshold", "partition": "test"}
{"idx": "996", "code": "public static String right(String s,int width,char fillChar){\n  if (s.length() >= width) {\n    return s;\n  }\n  StringBuffer sb=new StringBuffer(width);\n  for (int i=width - s.length(); --i >= 0; ) {\n    sb.append(fillChar);\n  }\n  sb.append(s);\n  return sb.toString();\n}\n", "docstring": "right justify a string .", "partition": "test"}
{"idx": "1946", "code": "@Override public void makeImmutable(){\n  if (mutable) {\n    if (attrs != null) {\n      Iterator iter=attrs.iterator();\n      while (iter.hasNext()) {\n        Attribute attr=(Attribute)iter.next();\n        attr.makeImmutable();\n      }\n      attrs=Collections.unmodifiableList(attrs);\n    }\n    if (encAttrs != null) {\n      encAttrs=Collections.unmodifiableList(encAttrs);\n    }\n    mutable=false;\n  }\n}\n", "docstring": "makes the object immutable .", "partition": "test"}
{"idx": "2334", "code": "public SimpleCommand(String commandName,String... args){\n  this(commandName,(Argument)null);\n  ArrayList<Argument> argList=new ArrayList<Argument>();\n  for (  String arg : args)   argList.add(new Argument(arg));\n  _arguments=argList.toArray(new Argument[0]);\n}\n", "docstring": "constructs a simplecommand from the given command name and the list of arguments .", "partition": "test"}
{"idx": "3582", "code": "public RhythmGroup addOverlays(Collection<RhythmOverlay> overlays){\n  mOverlays.addAll(overlays);\n  if (mCurrentOverlayIndex == NO_OVERLAY) {\n    selectOverlay(0);\n  }\n  return this;\n}\n", "docstring": "add multiple rhythm overlays to this group", "partition": "test"}
{"idx": "3493", "code": "private synchronized boolean pollStatsBroker(Destination queue){\n  statsMessageListener.setDestination(queue);\n  Timestamp timestamp=new Timestamp(System.currentTimeMillis());\n  LOGGER.debug(\"Setting the destination to \" + getQueueName(queue) + \" at \"+ timestamp);\n  jmsTemplate.execute(STATS_BROKER_DESTINATION + getQueueName(queue),new ProducerCallbackImpl(statsQueue));\n  try {\n    Thread.sleep(3 * 1000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return statsMessageListener.getStats() != null;\n}\n", "docstring": "poll the statistics broker plugin", "partition": "test"}
{"idx": "2602", "code": "private static Object add(final Object array,final int index,final Object element,final Class<?> clss){\n  if (array == null) {\n    if (index != 0) {\n      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n    }\n    Object joinedArray=Array.newInstance(clss,1);\n    Array.set(joinedArray,0,element);\n    return joinedArray;\n  }\n  int length=Array.getLength(array);\n  if (index > length || index < 0) {\n    throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \"+ length);\n  }\n  Object result=Array.newInstance(clss,length + 1);\n  System.arraycopy(array,0,result,0,index);\n  Array.set(result,index,element);\n  if (index < length) {\n    System.arraycopy(array,index,result,index + 1,length - index);\n  }\n  return result;\n}\n", "docstring": "underlying implementation of add ( array , index , element ) methods . the last parameter is the class , which may not equal element . getclass for primitives .", "partition": "test"}
{"idx": "4018", "code": "private String extractSpan(String spans,int start,int end) throws IndexOutOfBoundsException {\n  int offset=getFirstSpanOffset(spans);\n  assert (start >= offset);\n  assert (end >= offset);\n  spans+=HTML_OPEN_SPAN;\n  int substart=getSpanPos(spans,start - offset);\n  int subend=getSpanPos(spans,end - offset + 1);\n  return spans.substring(substart,subend);\n}\n", "docstring": "helper function for uploadnewnertask2 : extract certain token spans from the html token spans that the crowdflower job task1 uses to display a text fragment . it is used to cut out a named entity from html token spans .", "partition": "test"}
{"idx": "2684", "code": "public EventBean[] toArray(){\n  if (firstEvent == null) {\n    return new EventBean[0];\n  }\n  if (additionalEvents == null) {\n    return new EventBean[]{firstEvent};\n  }\n  EventBean[] events=new EventBean[1 + additionalEvents.size()];\n  events[0]=firstEvent;\n  int count=1;\n  for (  EventBean theEvent : additionalEvents) {\n    events[count]=theEvent;\n    count++;\n  }\n  return events;\n}\n", "docstring": "returns an array holding the collected events .", "partition": "test"}
{"idx": "3126", "code": "private boolean checkForCarry(final char[] ca1,final int icarry){\n  boolean carry=false;\n  if (icarry < ca1.length) {\n    if (ca1[icarry] == '6' || ca1[icarry] == '7' || ca1[icarry] == '8' || ca1[icarry] == '9') {\n      carry=true;\n    }\n else     if (ca1[icarry] == '5') {\n      int ii=icarry + 1;\n      for (; ii < ca1.length; ii++) {\n        if (ca1[ii] != '0') {\n          break;\n        }\n      }\n      carry=ii < ca1.length;\n      if (!carry && icarry > 0) {\n        carry=(ca1[icarry - 1] == '1' || ca1[icarry - 1] == '3' || ca1[icarry - 1] == '5' || ca1[icarry - 1] == '7' || ca1[icarry - 1] == '9');\n      }\n    }\n  }\n  return carry;\n}\n", "docstring": "check to see if the digits that are going to be truncated because of the precision should force a round in the preceding digits .", "partition": "test"}
{"idx": "467", "code": "public void renameEditorPanel(Editor panel){\n  if (panelsList.size() == 0) {\n    return;\n  }\n  for (int i=0; i < panelsList.size(); i++) {\n    Object o=panelsList.get(i);\n    if (o == panel) {\n      JCheckBoxMenuItem r=(JCheckBoxMenuItem)panelsSubMenu.getItem(i);\n      r.setText(panel.getTitle());\n      return;\n    }\n  }\n}\n", "docstring": "rename an editor type panel in show panels sub menu", "partition": "test"}
{"idx": "3701", "code": "public static float generateRandomFloatBetween(float lowerLimit,float upperLimit){\n  return lowerLimit + ((upperLimit - lowerLimit) * _r.nextFloat());\n}\n", "docstring": "generates a random float between two limits . both limits are inclusive .", "partition": "test"}
{"idx": "448", "code": "public void testAddServletRunAsRole() throws Exception {\n  String xml=WEBAPP_TEST_HEADER + \"  <servlet>\" + \"    <servlet-name>s1</servlet-name>\"+ \"    <servlet-class>sclass1</servlet-class>\"+ \"  </servlet>\"+ \"</web-app>\";\n  WebXml webXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(xml.getBytes(\"UTF-8\")),getEntityResolver());\n  WebXmlUtils.addServletRunAsRoleName(webXml,\"s1\",\"r1\");\n  String roleName=WebXmlUtils.getServletRunAsRoleName(webXml,\"s1\");\n  assertEquals(\"r1\",roleName);\n}\n", "docstring": "tests that a run - as role - name can be added to a servlet .", "partition": "test"}
{"idx": "3092", "code": "@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  super.readExternal(in);\n  isLeaf=in.readBoolean();\n  numEntries=in.readInt();\n}\n", "docstring": "reads the id of this node , the numentries and the entries array from the specified stream .", "partition": "test"}
{"idx": "1202", "code": "public FromClause add(OuterJoinQualifier outerJoinQualifier){\n  outerJoinQualifiers.add(outerJoinQualifier);\n  return this;\n}\n", "docstring": "adds an outer join descriptor that defines how the streams are related via outer joins . < p > for joining n streams , add n - 1 outer join qualifiers .", "partition": "test"}
{"idx": "1982", "code": "public boolean isValidNumber(PhoneNumber number){\n  String regionCode=getRegionCodeForNumber(number);\n  return isValidNumberForRegion(number,regionCode);\n}\n", "docstring": "tests whether a phone number matches a valid pattern . note this doesn \"'\" t verify the number is actually in use , which is impossible to tell by just looking at a number itself .", "partition": "test"}
{"idx": "2486", "code": "private float checkSaturationValid(final float val){\n  float tempval=val;\n  if (val > 1) {\n    tempval=1;\n  }\n  if (val < 0) {\n    tempval=0;\n  }\n  return tempval;\n}\n", "docstring": "check whether the specified saturation is valid or not .", "partition": "test"}
{"idx": "1951", "code": "static boolean isRefreshNotificationRegistered(NotificationListener client,RefreshNotificationType type){\n  boolean isRegistered=false;\n  Map<RefreshNotificationType,Integer> notifications=null;\nsynchronized (refreshClients) {\n    notifications=(Map<RefreshNotificationType,Integer>)refreshClients.get(client);\n  }\n  if (notifications != null) {\n    Integer timerNotificationId=notifications.get(type);\n    if (timerNotificationId != null) {\n      isRegistered=true;\n    }\n  }\n  return isRegistered;\n}\n", "docstring": "verifies a refresh notification for the specified client mbean . if notification is not registered , then returns a false", "partition": "test"}
{"idx": "134", "code": "protected int parseAndAddNode(XmlResourceParser parser,HashMap<String,TagParser> tagParserMap,ArrayList<Long> screenIds) throws XmlPullParserException, IOException {\n  if (TAG_INCLUDE.equals(parser.getName())) {\n    final int resId=getAttributeResourceValue(parser,ATTR_WORKSPACE,0);\n    if (resId != 0) {\n      return parseLayout(resId,screenIds);\n    }\n else {\n      return 0;\n    }\n  }\n  mValues.clear();\n  parseContainerAndScreen(parser,mTemp);\n  final long container=mTemp[0];\n  final long screenId=mTemp[1];\n  mValues.put(Favorites.CONTAINER,container);\n  mValues.put(Favorites.SCREEN,screenId);\n  mValues.put(Favorites.CELLX,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_X),mColumnCount));\n  mValues.put(Favorites.CELLY,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_Y),mRowCount));\n  TagParser tagParser=tagParserMap.get(parser.getName());\n  if (tagParser == null) {\n    if (LOGD)     Log.d(TAG,\"Ignoring unknown element tag: \" + parser.getName());\n    return 0;\n  }\n  long newElementId=tagParser.parseAndAdd(parser);\n  if (newElementId >= 0) {\n    if (!screenIds.contains(screenId) && container == Favorites.CONTAINER_DESKTOP) {\n      screenIds.add(screenId);\n    }\n    return 1;\n  }\n  return 0;\n}\n", "docstring": "parses the current node and returns the number of elements added .", "partition": "test"}
{"idx": "2492", "code": "@Override protected void addChooserFilters(JFileChooser chooser){\n  javax.swing.filechooser.FileNameExtensionFilter filter=new javax.swing.filechooser.FileNameExtensionFilter(Bundle.getMessage(\"FileFilterLabel\",\"*.dfm, *.hex\"),\"dmf\",\"hex\");\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Digitrax Mangled Firmware (*.dmf)\",\"dmf\"));\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Intel Hex Format Firmware (*.hex)\",\"hex\"));\n  chooser.addChoosableFileFilter(filter);\n  chooser.setFileFilter(filter);\n}\n", "docstring": "add filter ( s ) for possible types to the input file chooser .", "partition": "test"}
{"idx": "3247", "code": "public Matrix4 multiplyByScale(double xScale,double yScale,double zScale){\n  double[] m=this.m;\n  m[0]*=xScale;\n  m[4]*=xScale;\n  m[8]*=xScale;\n  m[12]*=xScale;\n  m[1]*=yScale;\n  m[5]*=yScale;\n  m[9]*=yScale;\n  m[13]*=yScale;\n  m[2]*=zScale;\n  m[6]*=zScale;\n  m[10]*=zScale;\n  m[14]*=zScale;\n  return this;\n}\n", "docstring": "multiplies this matrix by a scale matrix with specified values .", "partition": "test"}
{"idx": "4083", "code": "public void omitLessFreq(){\n  if (name == null)   return;\n  int threshold=n_words[0] / LESS_FREQ_RATIO;\n  if (threshold < MINIMUM_FREQ)   threshold=MINIMUM_FREQ;\n  Set<String> keys=freq.keySet();\n  int roman=0;\n  for (Iterator<String> i=keys.iterator(); i.hasNext(); ) {\n    String key=i.next();\n    int count=freq.get(key);\n    if (count <= threshold) {\n      n_words[key.length() - 1]-=count;\n      i.remove();\n    }\n else {\n      if (key.matches(\"^[A-Za-z]$\")) {\n        roman+=count;\n      }\n    }\n  }\n  if (roman < n_words[0] / 3) {\n    Set<String> keys2=freq.keySet();\n    for (Iterator<String> i=keys2.iterator(); i.hasNext(); ) {\n      String key=i.next();\n      if (key.matches(\".*[A-Za-z].*\")) {\n        n_words[key.length() - 1]-=freq.get(key);\n        i.remove();\n      }\n    }\n  }\n}\n", "docstring": "eliminate below less frequency n - grams and noise latin alphabets", "partition": "test"}
{"idx": "23", "code": "public boolean boundScroll(){\n  float curScroll=getStackScroll();\n  float newScroll=getBoundedStackScroll(curScroll);\n  if (Float.compare(newScroll,curScroll) != 0) {\n    setStackScroll(newScroll);\n    return true;\n  }\n  return false;\n}\n", "docstring": "bounds the current scroll if necessary", "partition": "test"}
{"idx": "2048", "code": "private void loadDataFromService(){\n  List<ExceptionSensorData> exData=null;\n  if ((null != fromDate) && (null != toDate)) {\n    exData=dataAccessService.getUngroupedExceptionOverview(template,limit,fromDate,toDate,resultComparator);\n  }\n else {\n    exData=dataAccessService.getUngroupedExceptionOverview(template,limit,resultComparator);\n  }\n  exceptionSensorData.clear();\n  if (null != exData) {\n    exceptionSensorData.addAll(exData);\n  }\n}\n", "docstring": "reloads the data from the service .", "partition": "test"}
{"idx": "2781", "code": "protected Instance specifier(int i){\n  return m_Specifiers.get(i);\n}\n", "docstring": "get the template at the given position .", "partition": "test"}
{"idx": "2108", "code": "public boolean containsWindow(Class<?> windowClass){\n  return (getWindow(windowClass) != null);\n}\n", "docstring": "checks , whether an instance of the given window class is already in the window list .", "partition": "test"}
{"idx": "3189", "code": "public void updateAmount(){\n  setAmt(getTotalAmount());\n}\n", "docstring": "updates the amount on the document", "partition": "test"}
{"idx": "1166", "code": "@SuppressWarnings(\"unchecked\") @Test public void innerEnum(){\n  Class<?> pc=PlayingCard.class;\n  List<Enum<?>> include=new ArrayList<>();\n  List<Enum<?>> exclude=new ArrayList<>();\n  for (  Class<?> c : pc.getDeclaredClasses()) {\n    int mods=c.getModifiers();\n    if (c.isEnum()) {\n      if (Modifier.isPublic(mods)) {\n        include.addAll(asList(c.getEnumConstants()));\n      }\n else {\n        exclude.addAll(asList(c.getEnumConstants()));\n      }\n    }\n  }\n  Set<TypedOperation> actual=getConcreteOperations(pc);\n  assertEquals(\"number of statements\",include.size() + 5,actual.size());\n  for (  Enum<?> e : include) {\n    assertTrue(\"enum constant \" + e.name() + \" should occur\",actual.contains(createEnumOperation(e)));\n  }\n  for (  Enum<?> e : exclude) {\n    assertFalse(\"enum constant \" + e.name() + \" should not occur\",actual.contains(createEnumOperation(e)));\n  }\n}\n", "docstring": "innerenum tests that reflection . getstatements is collecting simple enum constants from a class . uses randoop . test . playingcard , which has two public enums , one private enum , and one enum with package access .", "partition": "test"}
{"idx": "3626", "code": "private static void removeLoopSafepoint(StructuredGraph graph){\n  LoopBeginNode loopBegin=findFirstLoop(graph);\n  loopBegin.disableSafepoint();\n}\n", "docstring": "remove the safepoint from the first loop in the test method , so only the safepoints on monitorenter and monitorexit remain in the loop . that way , we can make sure it deopts inside the monitorenter by invalidating the code while holding the lock .", "partition": "test"}
{"idx": "276", "code": "@Nullable public String fileName(){\n  return JavaLogger.fileName(delegate);\n}\n", "docstring": "returns current log file .", "partition": "test"}
{"idx": "3032", "code": "@RequestMapping(value={\"/\",\"\"},method=RequestMethod.PUT) @ResponseBody public RestWrapper insert(@ModelAttribute(\"userroles\") @Valid UserRoles userRoles,BindingResult bindingResult,Principal principal){\n  RestWrapper restWrapper=null;\n  if (bindingResult.hasErrors()) {\n    BindingResultError bindingResultError=new BindingResultError();\n    return bindingResultError.errorMessage(bindingResult);\n  }\n  try {\n    com.wipro.ats.bdre.md.dao.jpa.UserRoles jpaUserRoles=new com.wipro.ats.bdre.md.dao.jpa.UserRoles();\n    jpaUserRoles.setUserRoleId(userRoles.getUserRoleId());\n    jpaUserRoles.setRole(userRoles.getRole());\n    Users users=new Users();\n    users.setUsername(userRoles.getUsername());\n    jpaUserRoles.setUsers(users);\n    Integer userRolesId=userRolesDAO.insert(jpaUserRoles);\n    userRoles.setUserRoleId(userRolesId);\n    restWrapper=new RestWrapper(userRoles,RestWrapper.OK);\n    LOGGER.info(\"Record with ID:\" + userRoles.getUserRoleId() + \" inserted in UserRoles by User:\"+ principal.getName()+ userRoles);\n  }\n catch (  Exception e) {\n    LOGGER.error(e);\n    restWrapper=new RestWrapper(e.getMessage(),RestWrapper.ERROR);\n  }\n  return restWrapper;\n}\n", "docstring": "this method calls proc insertuserroles and adds a record in userroles table . it also validates the values passed .", "partition": "test"}
{"idx": "1508", "code": "public void runScript(Reader reader) throws IOException, SQLException {\n  try {\n    boolean originalAutoCommit=connection.getAutoCommit();\n    try {\n      if (originalAutoCommit != this.autoCommit) {\n        connection.setAutoCommit(this.autoCommit);\n      }\n      runScript(connection,reader);\n    }\n  finally {\n      connection.setAutoCommit(originalAutoCommit);\n    }\n  }\n catch (  IOException|SQLException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error running script.  Cause: \" + e,e);\n  }\n}\n", "docstring": "runs an sql script ( read in using the reader parameter )", "partition": "test"}
{"idx": "3635", "code": "public static byte[] combine(final List<byte[]> dataChunks){\n  int totalSize=0;\n  for (  final byte[] dataPart : dataChunks) {\n    totalSize+=dataPart.length;\n  }\n  final byte[] data=new byte[totalSize];\n  int index=0;\n  for (  final byte[] dataPart : dataChunks) {\n    System.arraycopy(dataPart,0,data,index,dataPart.length);\n    index+=dataPart.length;\n  }\n  return data;\n}\n", "docstring": "combines a list of byte arrays into one big byte array .", "partition": "test"}
{"idx": "46", "code": "protected void recoverPrimary(Set excludedServers){\n  if (pool.getPoolOrCacheCancelInProgress() != null) {\n    return;\n  }\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (queueConnections.getPrimary() != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"Primary recovery not needed\");\n    }\n    return;\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover\");\n  }\n  if (printRecoveringPrimary) {\n    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));\n    printRecoveringPrimary=false;\n  }\n  QueueConnectionImpl newPrimary=null;\n  while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {\n    List backups=queueConnections.getBackups();\n    newPrimary=promoteBackupToPrimary(backups);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\nsynchronized (lock) {\n        queueConnections=queueConnections.removeConnection(newPrimary);\n      }\n      newPrimary=null;\n    }\n  }\n  if (newPrimary != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"SubscriptionManager redundancy satisfier - Switched backup server to primary: {}\",newPrimary.getEndpoint());\n    }\n    if (PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    cqsConnected();\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  while (newPrimary == null) {\n    newPrimary=createNewPrimary(excludedServers);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\n      excludedServers.add(newPrimary.getServer());\n      newPrimary=null;\n    }\n    if (newPrimary != null) {\n      if (isDebugEnabled) {\n        logger.debug(\"SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}\",newPrimary.getEndpoint());\n      }\n      if (!recoverInterest(newPrimary,true)) {\n        excludedServers.add(newPrimary.getServer());\n        newPrimary=null;\n      }\n      cqsConnected();\n    }\n    if (newPrimary != null && PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  cqsDisconnected();\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - Could not recover a new primary\");\n  }\nsynchronized (lock) {\n    queueConnections=queueConnections.setPrimaryDiscoveryFailed(null);\n    lock.notifyAll();\n  }\n}\n", "docstring": "find a new primary , adding any failed servers we encounter to the excluded servers list first we try to make a backup server the primary , but if run out of backup servers we will try to find a new server .", "partition": "test"}
{"idx": "2484", "code": "public void addColumn(String name,String expr){\n  Expression ex=ExpressionParser.parse(expr);\n  Throwable t=ExpressionParser.getError();\n  if (t != null) {\n    throw new RuntimeException(t);\n  }\n else {\n    addColumn(name,ex);\n  }\n}\n", "docstring": "add a derived column to this table , using an expression instance to dynamically calculate the column data values .", "partition": "test"}
{"idx": "119", "code": "public String parse(File file,JSON m){\n  try {\n    Template template=getTemplate(file);\n    if (template != null) {\n      StringWriter w=new StringWriter();\n      BufferedWriter writer=new BufferedWriter(w);\n      template.merge(new VelocityContext(m),writer);\n      writer.flush();\n      writer.close();\n      return w.toString();\n    }\n  }\n catch (  Exception e) {\n    log.error(e.getMessage(),e);\n  }\n  return null;\n}\n", "docstring": "parse the file to string with the json", "partition": "test"}
{"idx": "2643", "code": "public static void discard(){\n  current.remove();\n}\n", "docstring": "discards any active baggage currently in this thread", "partition": "test"}
{"idx": "350", "code": "public GT_MetaGenerated_Item(String aUnlocalized,short aOffset,short aItemAmount){\n  super(aUnlocalized);\n  setCreativeTab(GregTech_API.TAB_GREGTECH_MATERIALS);\n  setHasSubtypes(true);\n  setMaxDamage(0);\n  mEnabledItems=new BitSet(aItemAmount);\n  mVisibleItems=new BitSet(aItemAmount);\n  mOffset=(short)Math.min(32766,aOffset);\n  mItemAmount=(short)Math.min(aItemAmount,32766 - mOffset);\n  mIconList=new IIcon[aItemAmount][1];\n  sInstances.put(getUnlocalizedName(),this);\n}\n", "docstring": "creates the item using these parameters .", "partition": "test"}
{"idx": "1549", "code": "public AbstractWorkerManager(String id){\n  _id=id;\n  _status=new WorkerManagerStatus();\n  setExecutionMode(EXECUTION_MODE.NON_SERIAL);\n  setupExecutor();\n}\n", "docstring": "set the identifier of the process", "partition": "test"}
{"idx": "968", "code": "public static int numPixelsBetween(int x1,int y1,int x2,int y2){\n  return (int)Math.sqrt(Math.pow((double)(x1 - x2),2.0) + Math.pow((double)(y1 - y2),2.0));\n}\n", "docstring": "little math utility that both tools use , that just implements the pythagorean theorem to do the number of pixels between two screen points .", "partition": "test"}
{"idx": "3047", "code": "protected void addToGUI(JPanel gui,JTextField b,String cmd){\n  b.setActionCommand(cmd);\n  b.addActionListener(this);\n  gui.add(b);\n}\n", "docstring": "adds a feature to the gui attribute of the e00layer object", "partition": "test"}
{"idx": "3066", "code": "VPlexDistributedDeviceInfo findDistributedDevice(String deviceName) throws VPlexApiException {\n  return findDistributedDevice(deviceName,false);\n}\n", "docstring": "finds the distributed device with the passed name .", "partition": "test"}
{"idx": "4228", "code": "public RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {\n  decode(encoded);\n  RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(),e);\n}\n", "docstring": "construct a key from its encoding . used by rsakeyfactory .", "partition": "test"}
{"idx": "4051", "code": "public void makeClass(String str,boolean caseless){\n  for (int i=0; i < str.length(); i++)   makeClass(str.charAt(i),caseless);\n}\n", "docstring": "creates a new character class for each character of the specified string .", "partition": "test"}
{"idx": "4233", "code": "public static Function<Value,Value> ofValue(){\n  return VALUE;\n}\n", "docstring": "the identity function for value conversion - returns the value untouched .", "partition": "test"}
{"idx": "470", "code": "public static String encodeUrl(final String str){\n  return encode(str,\"%20\");\n}\n", "docstring": "encode a string for html requests", "partition": "test"}
{"idx": "1465", "code": "public static String toString(Reader reader,long timeout) throws IOException {\n  StringWriter sw=new StringWriter(512);\n  copy(toBufferedReader(reader),sw,timeout);\n  sw.close();\n  return sw.toString();\n}\n", "docstring": "reads string data from a reader", "partition": "test"}
{"idx": "983", "code": "public void load(){\n  try {\n    if (fileChannel == null) {\n      fileChannel=FileChannel.open(path,StandardOpenOption.READ);\n    }\n    fileChannel.position(0L);\n    buffer.clear();\n    tmp.clear();\n    while (fileChannel.read(tmp) > 0) {\n      tmp.flip();\n      if (tmp.remaining() > buffer.capacity() - buffer.position()) {\n        final ByteBuffer next=ByteBuffer.allocateDirect(Math.max(buffer.capacity() * 2,tmp.remaining()));\n        buffer.flip();\n        next.put(buffer);\n        buffer=next;\n      }\n      buffer.put(tmp);\n      tmp.clear();\n    }\n    buffer.flip();\n  }\n catch (  final IOException e) {\n    throw new UncheckedIOException(e);\n  }\n}\n", "docstring": "opens a channel to the specified path if it does not already exist . allocates a larger bytebuffer if file size & gt ; current buffer size . reads file data into bytebuffer .", "partition": "test"}
{"idx": "3408", "code": "@Override public String dumpWindowHierarchy(boolean compressed){\n  device.setCompressedLayoutHeirarchy(compressed);\n  try {\n    ByteArrayOutputStream os=new ByteArrayOutputStream();\n    device.dumpWindowHierarchy(os);\n    os.close();\n    return os.toString(\"UTF-8\");\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n  }\n finally {\n    device.setCompressedLayoutHeirarchy(false);\n  }\n  return null;\n}\n", "docstring": "helper method used for debugging to dump the current window \"'\" s layout hierarchy .", "partition": "test"}
{"idx": "2772", "code": "private static void d_ucumm(double[] a,double[] agg,double[] c,int m,int n,int rl,int ru){\n  double[] cprods=(agg != null) ? agg : new double[n];\n  if (agg == null)   Arrays.fill(cprods,1);\n  for (int i=rl, aix=rl * n; i < ru; i++, aix+=n) {\n    productAgg(a,cprods,aix,0,n);\n    System.arraycopy(cprods,0,c,aix,n);\n  }\n}\n", "docstring": "cumprod , opcode : ucum * , dense input .", "partition": "test"}
{"idx": "3333", "code": "public static String replace(String a,String b,String c){\n  StringBuilder result=new StringBuilder(c.length());\n  int i=0;\n  int j=c.indexOf(a);\n  while (j >= i) {\n    result.append(c.substring(i,j));\n    result.append(b);\n    i=j + a.length();\n    j=c.indexOf(a,i);\n  }\n  result.append(c.substring(i,c.length()));\n  return result.toString();\n}\n", "docstring": "replaces a with b in c .", "partition": "test"}
{"idx": "3258", "code": "@Override public void actionPerformed(ActionEvent event){\n  String command=event.getActionCommand();\n  if (command.equals(\"BackgroundPaint\")) {\n    attemptModifyBackgroundPaint();\n  }\n}\n", "docstring": "handles user interactions with the panel .", "partition": "test"}
{"idx": "988", "code": "private void sendResource(final UUID uuid,final Object resource,final long length,final InputStream is) throws IOException {\n  assert uuid != null;\n  assert resource != null;\n  assert length >= 0;\n  assert is != null;\n  assert !sentStatus;\n  long bytesWritten=0L;\n  final long begin=System.nanoTime();\n  final OutputStream os=s.getOutputStream();\n  try {\n{\n      final DataOutputStream dos=new DataOutputStream(os);\n      dos.write(new byte[]{StatusEnum.OK.get()});\n      dos.writeLong(length);\n      dos.flush();\n      bytesWritten+=1 + Bytes.SIZEOF_LONG;\n      sentStatus=true;\n    }\n    final long checksum;\n{\n      final int BUFSIZE=Bytes.kilobyte32 * 2;\n      final CheckedInputStream cis=new CheckedInputStream(new BufferedInputStream(is),new Adler32());\n      final byte[] buff=new byte[BUFSIZE];\n      while (true) {\n        final int read=cis.read(buff,0,BUFSIZE);\n        if (read <= 0)         break;\n        os.write(buff,0,read);\n        bytesWritten+=read;\n      }\n      checksum=cis.getChecksum().getValue();\n    }\n{\n      final DataOutputStream dos=new DataOutputStream(os);\n      dos.writeLong(checksum);\n      bytesWritten+=Bytes.SIZEOF_LONG;\n      dos.flush();\n    }\n    os.flush();\n    if (log.isInfoEnabled())     log.info(\"Sent: uuid=\" + uuid + \", resource=\"+ resource+ \", length=\"+ length+ \", checksum=\"+ checksum+ \", elapsed=\"+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin)+ \"ms\");\n  }\n  finally {\n    try {\n      os.close();\n    }\n catch (    Throwable t) {\n    }\n    counters.bytesWritten.add(bytesWritten);\n    counters.elapsedWriteNanos.add(System.nanoTime() - begin);\nsynchronized (counters.maxWriteSizeLock) {\n      counters.maxWriteSize=Math.max(counters.maxWriteSize,bytesWritten);\n    }\n  }\n}\n", "docstring": "sends given resource to the socket .", "partition": "test"}
{"idx": "3570", "code": "private static IAbstractNode convertOr(final CommonTree ast) throws RecognitionException {\n  final List<IAbstractNode> children=new ArrayList<IAbstractNode>();\n  for (  final Object childObject : ast.getChildren()) {\n    children.add(convert((CommonTree)childObject));\n  }\n  return new CAbstractOrExpression(children);\n}\n", "docstring": "converts an antrl or ast into a filter or ast .", "partition": "test"}
{"idx": "723", "code": "public List<String> makeURLList(String shard){\n  List<String> urls=StrUtils.splitSmart(shard,\"|\",true);\n  for (int i=0; i < urls.size(); i++) {\n    urls.set(i,buildUrl(urls.get(i)));\n  }\n  if (urls.size() > 1)   Collections.shuffle(urls,r);\n  return urls;\n}\n", "docstring": "creates a randomized list of urls for the given shard .", "partition": "test"}
{"idx": "422", "code": "public void and(LongBitSet other){\n  int pos=Math.min(numWords,other.numWords);\n  while (--pos >= 0) {\n    bits[pos]&=other.bits[pos];\n  }\n  if (numWords > other.numWords) {\n    Arrays.fill(bits,other.numWords,numWords,0L);\n  }\n}\n", "docstring": "this = this and other", "partition": "test"}
{"idx": "1377", "code": "public Iterator<Target> targetIterator(){\n  return targetList.iterator();\n}\n", "docstring": "iterate over target objects representing control flow targets and their edge types .", "partition": "test"}
{"idx": "586", "code": "public static ByteBuffer convertToSigned16BitSamples(Buffer buffer){\n  return convertToSigned16BitSamples(buffer.getSamples());\n}\n", "docstring": "converts the float samples in a complex buffer to a little endian 16 - bit buffer", "partition": "test"}
{"idx": "986", "code": "public void initToolTip(){\n  if (ttmanager == null) {\n    ttmanager=ToolTipManager.sharedInstance();\n    ttmanager.registerComponent(map);\n    ttmanager.setEnabled(true);\n    return;\n  }\n  if (map != null) {\n    map.setToolTipText(null);\n  }\n}\n", "docstring": "this method should be called to initialize the tooltip status so that an old tooltip doesn \"'\" t remain when a layer starts listening to mouse events .", "partition": "test"}
{"idx": "2036", "code": "public boolean offer(E event,int taskId) throws InterruptedException {\n  assertNotDone();\n  if (predicate.match(event)) {\n    this.matched[taskId]=true;\n    for (    boolean match : matched) {\n      if (!match)       return true;\n    }\n    responseQueue.put(new EventHolder(event));\n    done=true;\n    return true;\n  }\n else   return false;\n}\n", "docstring": "offer an event to this watch instance . if it accepts the event we note the task id and return true .", "partition": "test"}
{"idx": "2421", "code": "void changeState(int newState){\n  int oldState;\nsynchronized (stateLock) {\n    if (state == newState)     return;\n    oldState=state;\n    state=newState;\n    stateLock.notifyAll();\n  }\n  sendStateChangeNotification(oldState,newState);\n}\n", "docstring": "for internal use only .", "partition": "test"}
{"idx": "3430", "code": "private void sortBrokerItems(BrokerItem[] brokerItems,int sortType){\n  Arrays.sort(brokerItems,BrokerItem.getComparatoryByType(sortType));\n}\n", "docstring": "perform sorting according to sort type", "partition": "test"}
{"idx": "377", "code": "public boolean is_overlap(){\n  Set<BrdItem> start_contacts=get_start_contacts();\n  Set<BrdItem> end_contacts=get_end_contacts();\n  for (  BrdItem end_contact : end_contacts) {\n    if (start_contacts.contains(end_contact))     return true;\n  }\n  return false;\n}\n", "docstring": "looks , if this trace is connected to the same object at its start and its end point", "partition": "test"}
{"idx": "2273", "code": "protected void removeMarkers(){\n  for (int i=markerImage.size(); i > 0; i--) {\n    LocoIcon il=markerImage.get(i - 1);\n    if ((il != null) && (il.isActive())) {\n      markerImage.remove(i - 1);\n      il.remove();\n      il.dispose();\n      setDirty(true);\n    }\n  }\n  super.removeMarkers();\n  repaint();\n}\n", "docstring": "remove marker icons from panel", "partition": "test"}
{"idx": "15", "code": "private int determineMaxLevelRec(int level,Node v){\n  int newLevel=level;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    newLevel=Math.max(newLevel,determineMaxLevelRec(level,e.getTarget()) + 1);\n  }\n  return newLevel;\n}\n", "docstring": "recursively does the work", "partition": "test"}
{"idx": "575", "code": "public Decimal subtract(Decimal decimal){\n  assertDefined();\n  if (null == m_value) {\n    return (decimal);\n  }\n  BigDecimal value=m_value.subtract(decimal.getBigDecimalValue());\n  return new Decimal(value,SCALE);\n}\n", "docstring": "subtracts two decimal objects", "partition": "test"}
{"idx": "815", "code": "public JavaFormatter(String lineDelimiter,int initialIndentLevel,boolean useCodeFormatter,IJavaProject project){\n  fLineDelimiter=lineDelimiter;\n  fUseCodeFormatter=useCodeFormatter;\n  fInitialIndentLevel=initialIndentLevel;\n  fProject=project;\n}\n", "docstring": "creates a javaformatter with the target line delimiter .", "partition": "test"}
{"idx": "1866", "code": "public void removeEventListener(SIPTransactionEventListener oldListener){\n  eventListeners.remove(oldListener);\n}\n", "docstring": "removed an event listener from this transaction .", "partition": "test"}
{"idx": "4235", "code": "public DBasicConstraints(JDialog parent,byte[] value) throws IOException {\n  super(parent);\n  setTitle(res.getString(\"DBasicConstraints.Title\"));\n  initComponents();\n  prepopulateWithValue(value);\n}\n", "docstring": "creates a new dbasicconstraints dialog .", "partition": "test"}
{"idx": "3474", "code": "public boolean check(final Direction dir,final boolean facing){\n  if (this.dir != dir) {\n    return false;\n  }\n  if (this.facing != facing) {\n    return false;\n  }\n  final long now=System.currentTimeMillis();\n  if (now >= expiration) {\n    return false;\n  }\n  expiration=now + DELAY;\n  return true;\n}\n", "docstring": "check if a new direction matches the existing one , and if so , reset the expiration point .", "partition": "test"}
{"idx": "910", "code": "private static long signFromBit_antiCyclic(final double value){\n  return Double.doubleToRawLongBits(value) >> 62 | 1;\n}\n", "docstring": "redefined here , to avoid cyclic dependency with ( strict ) fastmath .", "partition": "test"}
{"idx": "3212", "code": "public boolean hasParameter(String name){\n  return _parameters.hasParameter(name);\n}\n", "docstring": "checks if the extension contains a parameter .", "partition": "test"}
{"idx": "2829", "code": "public void removeComponentListener(final ComponentUpdateListener listener){\n  componentListeners.remove(listener);\n}\n", "docstring": "removes a component listener from this instance .", "partition": "test"}
{"idx": "2337", "code": "public ViewRefRender(ViewRender<T> view,Class<T> type,int priority){\n  Objects.requireNonNull(view);\n  _view=view;\n  _type=type;\n  _priority=priority;\n}\n", "docstring": "creates the view and analyzes the type", "partition": "test"}
{"idx": "883", "code": "public MemoidOne(Function<? super Input,? extends Output> fn,BiPredicate<Input,Input> equality){\n  fn_=Objects.requireNonNull(fn);\n  equality_=Objects.requireNonNull(equality);\n}\n", "docstring": "create a new memoidone , using the supplied transformation function .", "partition": "test"}
{"idx": "1648", "code": "private void scheduledEnqueueSend(){\n  schedulerQueueSize.decrementAndGet();\n  scheduled.set(false);\n  enqueueSendWithErrorLogging();\n}\n", "docstring": "decrements the scheduled queue counter and enqueues the request .", "partition": "test"}
{"idx": "1964", "code": "public Future<?> execute(CameraCommand command){\n  if (mClosed) {\n    return Futures.immediateFuture(null);\n  }\nsynchronized (mLock) {\n    if (mExecutor == null) {\n      mExecutor=mExecutorProvider.get();\n    }\n    checkNotNull(mExecutor);\n    return mExecutor.submit(new CommandRunnable(command));\n  }\n}\n", "docstring": "executes the given command , returning a future to indicate its status and allow ( interruptible ) cancellation .", "partition": "test"}
{"idx": "1291", "code": "public boolean shouldExecuteAction(){\n  if (delay <= 0) {\n    return true;\n  }\n  long timePassed=System.currentTimeMillis() - lastActionExecuted;\n  if (timePassed > delay * 100) {\n    lastActionExecuted=System.currentTimeMillis();\n    return true;\n  }\n  return false;\n}\n", "docstring": "checks whether an action should currently be executed , based on the required delay . also assumes that an action was executed if this returns true and sets the time of the last action to the current time .", "partition": "test"}
{"idx": "3206", "code": "public static void interrupt(final Thread thread){\n  if (thread != null) {\n    thread.interrupt();\n  }\n}\n", "docstring": "interrupts the specified thread , guarding against null . < p / >", "partition": "test"}
{"idx": "2395", "code": "public void tallyVariant(VcfHeader header,VcfRecord rec){\n  tallyVariant(rec,header.getSampleNames());\n}\n", "docstring": "add the given vcf record to the statistics", "partition": "test"}
{"idx": "1025", "code": "private boolean isValidEngine(){\n  if (hasFlag(~(CLAN_ENGINE | TANK_ENGINE | LARGE_ENGINE| SUPERHEAVY_ENGINE| SUPPORT_VEE_ENGINE))) {\n    problem.append(\"Flags:\" + engineFlags);\n    return false;\n  }\n  if (hasFlag(SUPPORT_VEE_ENGINE) && (engineType != STEAM) && (engineType != COMBUSTION_ENGINE)&& (engineType != BATTERY)&& (engineType != FUEL_CELL)&& (engineType != SOLAR)&& (engineType != FISSION)&& (engineType != NORMAL_ENGINE)&& (engineType != NONE)) {\n    problem.append(\"Invalid Engine type for support vehicle engines!\");\n    return false;\n  }\n  if ((((int)Math.ceil(engineRating / 5) > ENGINE_RATINGS.length) || (engineRating < 0)) && !hasFlag(SUPPORT_VEE_ENGINE)) {\n    problem.append(\"Rating:\" + engineRating);\n    return false;\n  }\n  if ((engineRating > 400) && !hasFlag(SUPPORT_VEE_ENGINE)) {\n    engineFlags|=LARGE_ENGINE;\n  }\nswitch (engineType) {\ncase COMBUSTION_ENGINE:\ncase NORMAL_ENGINE:\ncase XL_ENGINE:\ncase XXL_ENGINE:\ncase FUEL_CELL:\ncase NONE:\ncase MAGLEV:\ncase BATTERY:\ncase SOLAR:\n    break;\ncase COMPACT_ENGINE:\n  if (hasFlag(LARGE_ENGINE)) {\n    problem.append(Messages.getString(\"Engine.invalidCompactLarge\"));\n    return false;\n  }\nbreak;\ncase LIGHT_ENGINE:\ncase FISSION:\nif (hasFlag(CLAN_ENGINE)) {\nproblem.append(Messages.getString(\"Engine.invalidSphereOnly\"));\nreturn false;\n}\nbreak;\ndefault :\nproblem.append(\"Type:\" + engineType);\nreturn false;\n}\nreturn true;\n}\n", "docstring": "sanity checks the engine , no negative ratings , and similar checks .", "partition": "test"}
{"idx": "1736", "code": "public <T>T time(Callable<T> event) throws Exception {\n  final long startTime=clock.tick();\n  try {\n    return event.call();\n  }\n  finally {\n    update(clock.tick() - startTime);\n  }\n}\n", "docstring": "times and records the duration of event .", "partition": "test"}
{"idx": "3590", "code": "public ArrayList<String> GetElementList(String xPathExpression){\n  try {\n    ArrayList<String> values=new ArrayList<String>();\n    List<?> nodeList=XPath.selectNodes(this.xmlDocument,xPathExpression);\n    Iterator<?> iter=nodeList.iterator();\n    while (iter.hasNext()) {\n      org.jdom.Element element=(org.jdom.Element)iter.next();\n      values.add(element.getText());\n    }\n    return values;\n  }\n catch (  Exception ex) {\n    LOG.error(\"Error in handler: \" + ex.getMessage(),ex);\n    return null;\n  }\n}\n", "docstring": "retrieves the text elements for a given xpath expression", "partition": "test"}
{"idx": "1788", "code": "private List extractColumnKeys(String line){\n  List keys=new java.util.ArrayList();\n  int fieldIndex=0;\n  int start=0;\n  for (int i=0; i < line.length(); i++) {\n    if (line.charAt(i) == this.fieldDelimiter) {\n      if (fieldIndex > 0) {\n        String key=line.substring(start,i);\n        keys.add(removeStringDelimiters(key));\n      }\n      start=i + 1;\n      fieldIndex++;\n    }\n  }\n  String key=line.substring(start,line.length());\n  keys.add(removeStringDelimiters(key));\n  return keys;\n}\n", "docstring": "extracts the column keys from a string .", "partition": "test"}
{"idx": "2380", "code": "void remove(TcpServerThread t){\n  running.remove(t);\n}\n", "docstring": "remove a thread from the list .", "partition": "test"}
{"idx": "2638", "code": "public static double pdf(double x,double shape,double scale,double factor){\n  if (x <= 0)   return 0.0;\n  final double a=Math.exp(shape * Math.log(scale) - (shape + 1) * Math.log(x) - (scale / x) - GammaFunction.lnGamma(shape));\n  return factor * a;\n}\n", "docstring": "probability density function of the gamma distribution", "partition": "test"}
{"idx": "3086", "code": "public static void sortSeqs(List<String> seqs){\n  Collections.sort(seqs,null);\n}\n", "docstring": "sort n string sequence list .", "partition": "test"}
{"idx": "3128", "code": "public static boolean deleteDirectoryFiles(Set<String> inputFilePathsAndNames){\n  if ((inputFilePathsAndNames == null)) {\n    return false;\n  }\n  boolean didSuccessfullyDeleteAllFiles=true;\n  try {\n    for (    String filePathAndName : inputFilePathsAndNames) {\n      File file=new File(filePathAndName);\n      if (!file.isDirectory()) {\n        boolean deleteSuccess=deleteFile(filePathAndName);\n        if (!deleteSuccess) {\n          logger.debug(\"Warning - \" + filePathAndName + \" failed to delete\");\n          didSuccessfullyDeleteAllFiles=false;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.debug(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n    return false;\n  }\n  return didSuccessfullyDeleteAllFiles;\n}\n", "docstring": "this is a quiet method . only deletes files . doesn \"'\" t delete directories .", "partition": "test"}
{"idx": "1256", "code": "final public void print(double v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    String s=String.valueOf(v);\n    out.write(s,0,s.length());\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a double followed by a newline .", "partition": "test"}
{"idx": "2115", "code": "private TripSchedule rerouteTripSchedule(TripSchedule originalSchedule){\n  TripSchedule schedule=originalSchedule.clone();\n  schedule.arrivals=new int[newPatternLength];\n  schedule.departures=new int[newPatternLength];\n  int prevOutputDeparture=0;\n  for (int ss=0, ts=0; ts < newPatternLength; ss++, ts++) {\n    if ((ss == insertBeginIndex - 1) || (ss == 0 && insertBeginIndex == 0)) {\n      int hopTime=originalSchedule.arrivals[ss];\n      if (ss > 0)       hopTime-=originalSchedule.departures[ss - 1];\n      schedule.arrivals[ts]=prevOutputDeparture + hopTime;\n      schedule.departures[ts]=schedule.arrivals[ts] + dwellTimes[0];\n      prevOutputDeparture=schedule.departures[ts];\n      ts++;\n      for (int hop=0, dwell=1; dwell < dwellTimes.length; hop++, dwell++) {\n        schedule.arrivals[ts]=prevOutputDeparture + hopTimes[hop];\n        schedule.departures[ts]=schedule.arrivals[ts] + dwellTimes[dwell];\n        prevOutputDeparture=schedule.departures[ts];\n        ts++;\n      }\n      ss=insertEndIndex + 1;\n      if (ts == newPatternLength)       break;\n    }\n    int hopTime=originalSchedule.arrivals[ss];\n    if (ss > 0)     hopTime-=originalSchedule.departures[ss - 1];\n    schedule.arrivals[ts]=prevOutputDeparture + hopTime;\n    int dwellTime=originalSchedule.departures[ss] - originalSchedule.arrivals[ss];\n    schedule.departures[ts]=schedule.arrivals[ts] + dwellTime;\n    prevOutputDeparture=schedule.departures[ts];\n  }\n  int timeShift=originalSchedule.arrivals[originalFixedPointStopIndex] - schedule.arrivals[newFixedPointStopIndex];\n  for (int i=0; i < newPatternLength; i++) {\n    schedule.arrivals[i]+=timeShift;\n    schedule.departures[i]+=timeShift;\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Original arrivals:   {}\",originalSchedule.arrivals);\n    LOG.debug(\"Original departures: {}\",originalSchedule.departures);\n    LOG.debug(\"Modified arrivals:   {}\",schedule.arrivals);\n    LOG.debug(\"Modified departures: {}\",schedule.departures);\n  }\n  return schedule;\n}\n", "docstring": "todo calculate all arrivals and departures zero - based , and then shift them at the end to maintain fixed - point stop . the fixed - point stop should be different depending on whether we are splicing onto the beginning or end of the route .", "partition": "test"}
{"idx": "4106", "code": "public PWResetException(String bundleName,String errCode,Object[] args){\n  super(bundleName,errCode,args);\n  errList=new ArrayList(1);\n  errList.add(getMessage());\n}\n", "docstring": "creates a password reset exception object with localizable error message .", "partition": "test"}
{"idx": "1511", "code": "default Filterable<T> removeAll(final T... values){\n  return removeAll(Stream.of(values));\n}\n", "docstring": "remove all supplied elements from this filterable", "partition": "test"}
{"idx": "2067", "code": "private ArtLocateResult calculate_next_trace(boolean p_layer_changed,boolean p_at_fanout_end){\n  Collection<PlaPointFloat> corner_list=new LinkedList<PlaPointFloat>();\n  corner_list.add(current_from_point);\n  if (!p_at_fanout_end) {\n    PlaPointFloat adjusted_start_corner=adjust_start_corner();\n    if (adjusted_start_corner != current_from_point) {\n      PlaPointFloat add_corner=calculate_additional_corner(current_from_point,adjusted_start_corner,true,angle_restriction);\n      corner_list.add(add_corner);\n      corner_list.add(adjusted_start_corner);\n      previous_from_point=current_from_point;\n      current_from_point=adjusted_start_corner;\n    }\n  }\n  PlaPointFloat prev_corner=current_from_point;\n  for (int c_limit=0; c_limit < 1000; c_limit++) {\n    Collection<PlaPointFloat> next_corners=calculate_next_trace_corners();\n    if (next_corners.isEmpty())     break;\n    for (    PlaPointFloat curr_next_corner : next_corners) {\n      if (curr_next_corner == prev_corner)       continue;\n      corner_list.add(curr_next_corner);\n      previous_from_point=current_from_point;\n      current_from_point=curr_next_corner;\n      prev_corner=curr_next_corner;\n    }\n  }\n  int next_layer=current_trace_layer;\n  if (p_layer_changed) {\n    current_from_door_index=current_target_door_index + 1;\n    ExpandRoomComplete next_room=backtrack_array[current_from_door_index].next_room;\n    if (next_room != null) {\n      next_layer=next_room.get_layer();\n    }\n  }\n  PlaPointIntAlist rounded_corner_list=new PlaPointIntAlist(corner_list.size());\n  PlaPointInt prev_point=null;\n  for (  PlaPointFloat a_float : corner_list) {\n    PlaPointInt curr_point=a_float.round();\n    if (curr_point.equals(prev_point))     continue;\n    rounded_corner_list.add(curr_point);\n    prev_point=curr_point;\n  }\n  ArtLocateResult result=new ArtLocateResult(rounded_corner_list,current_trace_layer);\n  current_trace_layer=next_layer;\n  return result;\n}\n", "docstring": "calculates the next trace trace of the connection under construction .", "partition": "test"}
{"idx": "2325", "code": "public static int findURISplitIndex(String uri){\n  int uriLength=uri.length();\n  int idx=uriLength - 1;\n  for (; idx >= 0; idx--) {\n    if (!TurtleUtil.isNameChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  idx++;\n  for (; idx < uriLength; idx++) {\n    if (TurtleUtil.isNameStartChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  if (!TurtleUtil.isNameEndChar(uri.charAt(uriLength - 1))) {\n    return -1;\n  }\n  if (idx > 0 && idx < uriLength) {\n    return idx;\n  }\n  return -1;\n}\n", "docstring": "tries to find an index where the supplied uri can be split into a namespace and a local name that comply with the serialization constraints of the turtle format .", "partition": "test"}
{"idx": "2252", "code": "protected void addSourceCodeRemark(TestSolution testSolution,Element element,String messageCode,EvidenceElement evidenceElement){\n  if (evidenceElement != null) {\n    Collection<EvidenceElement> evidenceElementList=new ArrayList<>();\n    evidenceElementList.add(evidenceElement);\n    processRemarkService.addSourceCodeRemarkOnElement(testSolution,element,messageCode,evidenceElementList);\n  }\n else {\n    processRemarkService.addSourceCodeRemarkOnElement(testSolution,element,messageCode);\n  }\n}\n", "docstring": "add a sourcecoderemark on the given element with a preset evidence element collection", "partition": "test"}
{"idx": "1151", "code": "public static double computeMAD(double[] x,double median){\n  for (int i=0; i < x.length; i++) {\n    x[i]=Math.abs(x[i] - median);\n  }\n  double mad=QuickSelect.median(x);\n  if (!(mad > 0.)) {\n    double min=Double.POSITIVE_INFINITY;\n    for (    double xi : x) {\n      if (xi > 0. && xi < min) {\n        min=xi;\n      }\n    }\n    if (min < Double.POSITIVE_INFINITY) {\n      mad=min;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  return mad;\n}\n", "docstring": "compute the median absolute deviation from median .", "partition": "test"}
{"idx": "4262", "code": "public static List<ExecutionEntity> orderFromRootToLeaf(Collection<ExecutionEntity> executions){\n  List<ExecutionEntity> orderedList=new ArrayList<ExecutionEntity>(executions.size());\n  HashSet<String> previousIds=new HashSet<String>();\n  for (  ExecutionEntity execution : executions) {\n    if (execution.getParentId() == null) {\n      orderedList.add(execution);\n      previousIds.add(execution.getId());\n    }\n  }\n  while (orderedList.size() < executions.size()) {\n    for (    ExecutionEntity execution : executions) {\n      if (!previousIds.contains(execution.getId()) && previousIds.contains(execution.getParentId())) {\n        orderedList.add(execution);\n        previousIds.add(execution.getId());\n      }\n    }\n  }\n  return orderedList;\n}\n", "docstring": "takes in a collection of executions belonging to the same process instance . orders the executions in a list , first elements are the leaf , last element is the root elements .", "partition": "test"}
{"idx": "2239", "code": "public boolean matchesWord(){\n  return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n}\n", "docstring": "test if the queue matches a word character ( letter or digit ) .", "partition": "test"}
{"idx": "3928", "code": "public static boolean deleteDirectorySubdirectories(String rootDirectory){\n  if ((rootDirectory == null)) {\n    return false;\n  }\n  boolean didSuccessfullyDeleteAllDirectories=true;\n  try {\n    List<File> files=getListOfFilesInADirectory(rootDirectory);\n    for (    File file : files) {\n      if (file.isDirectory()) {\n        boolean deleteSuccess=deleteDirectoryAndContents(file);\n        if (!deleteSuccess) {\n          logger.debug(\"Warning - failed to delete \" + file.getAbsolutePath());\n          didSuccessfullyDeleteAllDirectories=false;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.debug(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n    return false;\n  }\n  return didSuccessfullyDeleteAllDirectories;\n}\n", "docstring": "this is a quiet method . only deletes directories . will fail if the directories have files in them .", "partition": "test"}
{"idx": "2283", "code": "public static boolean isExtension(String filename,Collection<String> extensions){\n  if (filename == null)   return false;\n  if (extensions == null || extensions.isEmpty())   return indexOfExtension(filename) == -1;\n  String fileExt=getExtension(filename);\n  for (  String extension : extensions) {\n    if (fileExt.equals(extension))     return true;\n  }\n  return false;\n}\n", "docstring": "checks whether the extension of the filename is one of those specified . < p > this method obtains the extension as the textual part of the filename after the last dot . there must be no directory separator after the dot . the extension check is case - sensitive on all platforms .", "partition": "test"}
{"idx": "3432", "code": "private void updatePathConstraints(TestChromosome test){\n  List<BranchCondition> pathCondition=ConcolicExecution.getSymbolicPath(test);\n  pathConditions.put(test,pathCondition);\n}\n", "docstring": "calculate and store path constraints for an individual", "partition": "test"}
{"idx": "1153", "code": "public static void sessionStop(){\n  if (mProcess == null)   return;\n  mProcess.destroy();\n  mProcess=null;\n}\n", "docstring": "stops the superuser session", "partition": "test"}
{"idx": "3632", "code": "public void paint(Graphics g){\n  try {\n    super.paint(g);\n  }\n catch (  Exception e) {\n  }\n  int focusedRow=getFocusedRow(true);\n  if (focusedRow != -1 && focusedRow < getRowCount()) {\n    Border rowBorder=UIManager.getBorder(\"Table.focusRowHighlightBorder\");\n    if (rowBorder != null) {\n      Rectangle rect=getCellRect(focusedRow,0,true);\n      rect.width=getWidth();\n      rowBorder.paintBorder(this,g,rect.x,rect.y,rect.width,rect.height);\n    }\n  }\n}\n", "docstring": "paints the table & a focused row border .", "partition": "test"}
{"idx": "2346", "code": "private void addExprToTLA(TLAExpr expr){\n  Vector sv=expr.toStringVector();\n  Vector exprMapping=expr.toMappingVector();\n  int indent=tlacodeNextLine.length();\n  int nextLine=0;\n  if (indent != 0) {\n    MappingObject.shiftMappingVector(exprMapping,indent);\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n    nextLine=1;\n    if (sv.size() > 1) {\n      endCurrentLineOfTLA();\n    }\n  }\n  if (sv.size() > 1) {\n    String spaces=NSpaces(indent);\n    while (nextLine < sv.size() - 1) {\n      tlacode.addElement(spaces + ((String)sv.elementAt(nextLine)));\n      mappingVector.addElement((Vector)exprMapping.elementAt(nextLine));\n      nextLine++;\n    }\n    tlacodeNextLine=spaces + ((String)sv.elementAt(nextLine));\n    mappingVectorNextLine=(Vector)exprMapping.elementAt(nextLine);\n  }\n else   if (indent == 0) {\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n  }\n}\n", "docstring": "adds the expression to tlacode / tlacodenextline and its mapping to mappingvector / mappingvectornextline . it adds no space before the expression and leaves the last line of the expression ( which could be its first line ) at the end of tlacodenextline .", "partition": "test"}
{"idx": "2780", "code": "void initDemandAndCollectionMap(final List<String> prepareFieldNames,final Map<String,BigDecimal> demand,final Map<String,BigDecimal> collection,final Map<String,BigDecimal> rebates){\n  if (prepareFieldNames != null && !prepareFieldNames.isEmpty())   for (  final String fieldName : prepareFieldNames) {\n    demand.put(fieldName,BigDecimal.ZERO);\n    collection.put(fieldName,BigDecimal.ZERO);\n    rebates.put(fieldName,BigDecimal.ZERO);\n  }\n}\n", "docstring": "method called internally to prepare the map with fieldnames dynamically ( i . e field names can be verified depending upon the client )", "partition": "test"}
{"idx": "207", "code": "private static boolean isInNeedOfForm(UIComponent component){\n  return (component instanceof ActionSource || component instanceof ActionSource2 || component instanceof EditableValueHolder);\n}\n", "docstring": "is the component in need of a form .", "partition": "test"}
{"idx": "657", "code": "public void remove(RequestFilter filter){\n  filters.remove(filter);\n}\n", "docstring": "unregister filter ( it won \"'\" t get anymore events )", "partition": "test"}
{"idx": "3633", "code": "private void add(final JLabel label,final JTextField field){\n  panel.add(label);\n  panel.add(field);\n  if (previous == null) {\n    layout.putConstraint(SpringLayout.NORTH,panel,-SPACING,SpringLayout.NORTH,label);\n  }\n else {\n    layout.putConstraint(SpringLayout.NORTH,label,SPACING,SpringLayout.SOUTH,previous);\n  }\n  layout.putConstraint(SpringLayout.WEST,panel,-SPACING,SpringLayout.WEST,label);\n  layout.putConstraint(SpringLayout.SOUTH,panel,SPACING,SpringLayout.SOUTH,label);\n  layout.putConstraint(SpringLayout.EAST,field,-SPACING,SpringLayout.EAST,panel);\n  layout.putConstraint(SpringLayout.WEST,field,-(TEXT_FIELD_WIDTH + SPACING),SpringLayout.EAST,panel);\n  layout.putConstraint(SpringLayout.SOUTH,field,SPACING,SpringLayout.SOUTH,label);\n  previous=label;\n}\n", "docstring": "adds a label and a field combination .", "partition": "test"}
{"idx": "3860", "code": "public void doWindowOpen(){\n  doConnect();\n}\n", "docstring": "this method is fired after the tab has been created and placed in the tab controller .", "partition": "test"}
{"idx": "230", "code": "public Metadata.Property.Builder clear(){\n  Metadata_Property_Builder _defaults=new Metadata.Property.Builder();\n  type=_defaults.type;\n  boxedType=_defaults.boxedType;\n  name=_defaults.name;\n  capitalizedName=_defaults.capitalizedName;\n  allCapsName=_defaults.allCapsName;\n  getterName=_defaults.getterName;\n  codeGenerator=_defaults.codeGenerator;\n  fullyCheckedCast=_defaults.fullyCheckedCast;\n  accessorAnnotations.clear();\n  _unsetProperties.clear();\n  _unsetProperties.addAll(_defaults._unsetProperties);\n  return (Metadata.Property.Builder)this;\n}\n", "docstring": "resets the state of this builder .", "partition": "test"}
{"idx": "896", "code": "private void addPingTimeData(long sample){\n  lastPingTimesLock.lock();\n  try {\n    if (lastPingTimes == null) {\n      lastPingTimes=new long[PING_MOVING_AVERAGE_WINDOW];\n      Arrays.fill(lastPingTimes,sample);\n    }\n else {\n      System.arraycopy(lastPingTimes,1,lastPingTimes,0,lastPingTimes.length - 1);\n      lastPingTimes[lastPingTimes.length - 1]=sample;\n    }\n  }\n  finally {\n    lastPingTimesLock.unlock();\n  }\n}\n", "docstring": "adds a ping time sample to the averaging window .", "partition": "test"}
{"idx": "2704", "code": "private Sprite(float xPos,float yPos,float xVel,float yVel,Image... sprites){\n  if (sprites != null)   spriteFrame=new ImageView(sprites[0]);\n  playerStates.addAll(Arrays.asList(sprites));\n  spriteFrame.setTranslateX(xPos);\n  spriteFrame.setTranslateY(yPos);\n  this.xPos=xPos;\n  this.yPos=yPos;\n  this.xVel=xVel;\n  this.yVel=yVel;\n}\n", "docstring": "used internally to create common functions between motion and stationary sprite .", "partition": "test"}
{"idx": "1707", "code": "public static void addFile(String s) throws IOException {\n  File f=new File(s);\n  addFile(f);\n}\n", "docstring": "adds a file to the classpath .", "partition": "test"}
{"idx": "892", "code": "private void show(boolean show){\n  if (show) {\n    if (mXFade != null) {\n      mXFade.cancel();\n    }\n    mState=STATE_PIE;\n    mCurrentItem=null;\n    PieItem root=getRoot();\n    for (    PieItem openItem : mOpen) {\n      if (openItem.hasItems()) {\n        for (        PieItem item : openItem.getItems()) {\n          item.setSelected(false);\n        }\n      }\n    }\n    mLabel.setText(\"\");\n    mOpen.clear();\n    mOpen.add(root);\n    layoutPie();\n    fadeIn();\n  }\n else {\n    mState=STATE_IDLE;\n    mTapMode=false;\n    if (mXFade != null) {\n      mXFade.cancel();\n    }\n    if (mLabel != null) {\n      mLabel.setText(\"\");\n    }\n  }\n  setVisible(show);\n  mHandler.sendEmptyMessage(show ? MSG_OPEN : MSG_CLOSE);\n}\n", "docstring": "guaranteed has center set", "partition": "test"}
{"idx": "1271", "code": "public PacketOutputStream writeTimestampLength(final Calendar calendar,Timestamp ts,boolean fractionalSeconds){\n  assureBufferCapacity(fractionalSeconds ? 12 : 8);\n  buffer.put((byte)(fractionalSeconds ? 11 : 7));\n  buffer.putShort((short)calendar.get(Calendar.YEAR));\n  buffer.put((byte)((calendar.get(Calendar.MONTH) + 1) & 0xff));\n  buffer.put((byte)(calendar.get(Calendar.DAY_OF_MONTH) & 0xff));\n  buffer.put((byte)calendar.get(Calendar.HOUR_OF_DAY));\n  buffer.put((byte)calendar.get(Calendar.MINUTE));\n  buffer.put((byte)calendar.get(Calendar.SECOND));\n  if (fractionalSeconds) {\n    buffer.putInt(ts.getNanos() / 1000);\n  }\n  return this;\n}\n", "docstring": "write timestamp in binary format .", "partition": "test"}
{"idx": "3484", "code": "public Object extractHardRef(Object o){\n  SoftReference w=(SoftReference)o;\n  if (w != null) {\n    return w.get();\n  }\n  return null;\n}\n", "docstring": "extracts the hard reference from the soft / weak reference given", "partition": "test"}
{"idx": "3143", "code": "protected void drawLowFarOut(double aRadius,Graphics2D g2,double xx,double m){\n  double side=aRadius * 2;\n  g2.draw(new Line2D.Double(xx - side,m - side,xx + side,m - side));\n  g2.draw(new Line2D.Double(xx - side,m - side,xx,m));\n  g2.draw(new Line2D.Double(xx + side,m - side,xx,m));\n}\n", "docstring": "draws a triangle to indicate the presence of far out values .", "partition": "test"}
{"idx": "3012", "code": "protected int chooseRandomIndexBasedOnProportions(double[] proportionArray,Random random){\n  double probSum;\n  double val;\n  int index;\n  double sum;\n  probSum=Utils.sum(proportionArray);\n  val=random.nextDouble() * probSum;\n  index=0;\n  sum=0.0;\n  while ((sum <= val) && (index < proportionArray.length)) {\n    sum+=proportionArray[index++];\n  }\n  return index - 1;\n}\n", "docstring": "returns a random index based on the given proportions", "partition": "test"}
{"idx": "365", "code": "public static String generateStringOfCharacters(int count){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < count; i++) {\n    sb.append(CHARACTERS.charAt((int)(Math.random() * CHARACTERS.length())));\n  }\n  return sb.toString();\n}\n", "docstring": "creates a random string which only consists of letters", "partition": "test"}
{"idx": "2299", "code": "public void test_canonicalizingCache(){\n  final Properties properties=getProperties();\n  properties.setProperty(AbstractTransactionService.Options.MIN_RELEASE_AGE,\"5000\");\n  final Journal journal=new Journal(properties);\n  try {\n    final long commitTime0=journal.commit();\n    assertTrue(commitTime0 != 0L);\n    final ICommitRecord commitRecord0=journal.getCommitRecord(commitTime0);\n    assertEquals(commitRecord0,journal.getCommitRecord());\n    journal.write(ByteBuffer.wrap(new byte[]{1,2,3}));\n    final long commitTime1=journal.commit();\n    assertTrue(commitTime1 != 0L);\n    final ICommitRecord commitRecord1=journal.getCommitRecord(commitTime1);\n    assertEquals(commitRecord1,journal.getCommitRecord());\n    assertTrue(commitRecord0 == journal.getCommitRecord(commitTime1 - 1));\n    assertTrue(commitRecord1 == journal.getCommitRecord(commitTime1 + 0));\n    assertTrue(commitRecord1 == journal.getCommitRecord(commitTime1 + 1));\n  }\n  finally {\n    journal.destroy();\n  }\n}\n", "docstring": "test verifies that exact match and find always return the same reference for the same commit record ( at least as long as the test holds a hard reference to the commit record of interest ) .", "partition": "test"}
{"idx": "3209", "code": "public static Object[] putAll(){\n  Region region=cache.getRegion(Region.SEPARATOR + REGION_NAME);\n  assertNotNull(region);\n  try {\n    Map map=new LinkedHashMap();\n    map.put(PUTALL_KEY1,PUTALL_VALUE1);\n    map.put(PUTALL_KEY2,PUTALL_VALUE2);\n    map.put(PUTALL_KEY3,PUTALL_VALUE3);\n    map.put(PUTALL_KEY4,PUTALL_VALUE4);\n    map.put(PUTALL_KEY5,PUTALL_VALUE5);\n    region.putAll(map,\"putAllCallbackArg\");\n    EventID[] evids=new EventID[5];\n    evids[0]=putAlleventId1;\n    evids[1]=putAlleventId2;\n    evids[2]=putAlleventId3;\n    evids[3]=putAlleventId4;\n    evids[4]=putAlleventId5;\n    assertNotNull(evids[0]);\n    assertNotNull(evids[1]);\n    assertNotNull(evids[2]);\n    assertNotNull(evids[3]);\n    assertNotNull(evids[4]);\n    return evids;\n  }\n catch (  Exception e) {\n    fail(\"put failed due to \" + e);\n  }\n  return null;\n}\n", "docstring": "does an update and return the eventid generated . eventid is caught in the listener and stored in a static variable", "partition": "test"}
{"idx": "1393", "code": "public void read(ByteCodeParser in) throws IOException {\n  int length=in.readInt();\n  _maxStack=in.readShort();\n  _maxLocals=in.readShort();\n  int codeLength=in.readInt();\n  _code=new byte[codeLength];\n  in.read(_code,0,codeLength);\n  int exnCount=in.readShort();\n  for (int i=0; i < exnCount; i++) {\n    ExceptionItem exn=new ExceptionItem();\n    exn.setStart(in.readShort() & 0xffff);\n    exn.setEnd(in.readShort() & 0xffff);\n    exn.setHandler(in.readShort() & 0xffff);\n    exn.setType(in.readShort() & 0xffff);\n    _exceptions.add(exn);\n  }\n  int attrCount=in.readShort();\n  for (int i=0; i < attrCount; i++) {\n    Attribute attr=in.parseAttribute();\n    _attributes.add(attr);\n  }\n}\n", "docstring": "writes the field to the output .", "partition": "test"}
{"idx": "1654", "code": "protected void appendText(final String text){\n  if (text != null) {\n    textBody.append(text);\n  }\n}\n", "docstring": "append text to the outgoing email body .", "partition": "test"}
{"idx": "4204", "code": "protected void configDialogPropertyChange(PropertyChangeEvent event){\n  log.debug(\"internal config dialog handler\");\n  firePropertyChange(PropertyChangeID.CONFIG_CHANGE,event.getOldValue(),event.getNewValue());\n}\n", "docstring": "callback for the config dialog", "partition": "test"}
{"idx": "1155", "code": "private MulticastSocket createSocket() throws IOException {\n  MulticastSocket sock=new MulticastSocket(mcastPort);\n  sock.setLoopbackMode(false);\n  if (sockItf != null)   sock.setInterface(sockItf);\n  if (sock.getLoopbackMode())   U.warn(log,\"Loopback mode is disabled which prevents nodes on the same machine from discovering \" + \"each other.\");\n  sock.joinGroup(mcastGrp);\n  if (ttl != -1)   sock.setTimeToLive(ttl);\n  return sock;\n}\n", "docstring": "creates multicast socket and joins multicast group .", "partition": "test"}
{"idx": "1603", "code": "@Override public void close(){\n  try {\n    if (connection != null) {\n      connection.close();\n    }\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "close the jdbc connection", "partition": "test"}
{"idx": "2732", "code": "public OptionalInt maxByInt(IntUnaryOperator keyExtractor){\n  int[] result=collect(null,null,null);\n  return result[2] == 1 ? OptionalInt.of(result[0]) : OptionalInt.empty();\n}\n", "docstring": "returns the maximum element of this stream according to the provided key extractor function . < p > this is a terminal operation .", "partition": "test"}
{"idx": "1295", "code": "@Override public void paintIcon(Component c,Graphics g,int x,int y){\n  Painter painter=(Painter)UIManager.get(prefix + \"[Enabled].\" + key);\n  if (painter != null) {\n    JComponent jc=(c instanceof JComponent) ? (JComponent)c : null;\n    Graphics2D gfx=(Graphics2D)g;\n    gfx.translate(x,y);\n    painter.paint(gfx,jc,width,height);\n    gfx.translate(-x,-y);\n  }\n}\n", "docstring": "implements the standard icon interface \"'\" s painticon method as the standard synth stub passes null for the context and this will cause us to not paint any thing , so we override here so that we can paint the enabled state if no synth context is available", "partition": "test"}
{"idx": "1171", "code": "public Phone createPhone(String value){\n  PhoneField phoneImpl=new PhoneField();\n  try {\n    phoneImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return phoneImpl;\n}\n", "docstring": "returns phone object with the specified value .", "partition": "test"}
{"idx": "2645", "code": "@Override public PacketBuffer write(PacketBuffer buf){\n  values.forEach(null);\n  return buf;\n}\n", "docstring": "writes this packet to the given buffer", "partition": "test"}
{"idx": "3480", "code": "public static String randomRegexpishString(Random r){\n  return randomRegexpishString(r,20);\n}\n", "docstring": "returns a string thats \" regexpish \" ( contains lots of operators typically found in regular expressions ) if you call this enough times , you might get a valid regex !", "partition": "test"}
{"idx": "70", "code": "public void addParameters(final NameValuePair[] parameters){\n  LOG.trace(\"enter PostMethod.addParameters(NameValuePair[])\");\n  if (parameters == null) {\n    LOG.warn(\"Attempt to addParameters(null) ignored\");\n  }\n else {\n    super.clearRequestBody();\n    for (int i=0; i < parameters.length; i++) {\n      params.add(parameters[i]);\n    }\n  }\n}\n", "docstring": "adds an array of parameters to be used in the post request body . logs a warning if the parameters argument is null .", "partition": "test"}
{"idx": "3112", "code": "private Response requestHttpGetFromRegistry(String url) throws RegistryException {\n  try {\n    Response resp=http.get(url);\n    if (resp != null && resp.content != null) {\n      return resp;\n    }\n else {\n      throw new RegistryException(TYPE.BAD_RESPONSE,\"Response content is null\");\n    }\n  }\n catch (  ClassCastException e) {\n    throw new RegistryException(TYPE.BAD_RESPONSE,e);\n  }\ncatch (  ConnectException e) {\n    throw new RegistryException(TYPE.PROXY,e);\n  }\ncatch (  UnknownHostException e) {\n    try {\n      http.get(\"http://www.google.com\");\n    }\n catch (    Exception e1) {\n      throw new RegistryException(TYPE.NO_INTERNET,e1);\n    }\n    throw new RegistryException(TYPE.SITE_DOWN,e);\n  }\ncatch (  IOException e) {\n    throw new RegistryException(TYPE.IO_ERROR,e);\n  }\ncatch (  URISyntaxException e) {\n    throw new RegistryException(TYPE.BAD_REQUEST,\"Please check the request URL: \" + ((url != null) ? url : \"empty URL used!\"));\n  }\n}\n", "docstring": "executes an http get request against the gbif registry . if the content is not null , the response is returned . otherwise , if the content was null , or an exception occurred , it throws the appropriate type of registryexception .", "partition": "test"}
{"idx": "164", "code": "public boolean containsWordBreakingChar(final @NonNull CharSequence input){\n  if (!TextUtils.isEmpty(input)) {\n    for (int i=0; i < input.length(); i++) {\n      char c=input.charAt(i);\n      if (isWordBreakingChar(c)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the input string contains a word - breaking character .", "partition": "test"}
{"idx": "2863", "code": "public void jGoogleAnalyticsTracker(final String eventType,final String version,final String trackerId){\n  final JGoogleAnalyticsTracker tracker=new JGoogleAnalyticsTracker(\"vdi_calculator\",version,trackerId);\n  final FocusPoint focusPoint=new FocusPoint(eventType.toLowerCase());\n  tracker.trackAsynchronously(focusPoint);\n}\n", "docstring": "google analytics usage tracking", "partition": "test"}
{"idx": "1574", "code": "public final void addHelperTextColor(@ColorInt final int color){\n  if (!helperTextColors.contains(color)) {\n    helperTextColors.add(color);\n    verifyPasswordStrength();\n  }\n}\n", "docstring": "adds a new helper text color , which should be used to highlight the helper text , which indicates the password strength .", "partition": "test"}
{"idx": "1478", "code": "private <S,T>Set<T> extract(final Collection<S> collection,final Extractor<S,T> extractor){\n  final Set<T> values=new HashSet<T>(collection.size());\n  for (  final S instance : collection) {\n    values.add(extractor.getValue(instance));\n  }\n  return values;\n}\n", "docstring": "extract a set of a defined type from the passed collection using the given extractor .", "partition": "test"}
{"idx": "1789", "code": "protected void drawRhombus(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  int halfWidth=w / 2;\n  int halfHeight=h / 2;\n  Polygon rhombus=new Polygon();\n  rhombus.addPoint(x + halfWidth,y);\n  rhombus.addPoint(x + w,y + halfHeight);\n  rhombus.addPoint(x + halfWidth,y + h);\n  rhombus.addPoint(x,y + halfHeight);\n  drawPolygon(rhombus,fillColor,fillPaint,penColor,shadow);\n}\n", "docstring": "draws a rhombus ( aka . diamond ) for the given parameters .", "partition": "test"}
{"idx": "3262", "code": "public static TypeBinding[] substitute(Substitution substitution,TypeBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  TypeBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    TypeBinding originalType=originalTypes[i];\n    TypeBinding substitutedParameter=substitute(substitution,originalType);\n    if (substitutedParameter != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new TypeBinding[length],0,i);\n      }\n      substitutedTypes[i]=substitutedParameter;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}\n", "docstring": "returns an array of types , where original types got substituted given a substitution . only allocate an array if anything is different .", "partition": "test"}
{"idx": "2475", "code": "@Override public void step(MessageLogger logger){\n  try {\n    addAgent();\n    env.step();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "executes one simulation step .", "partition": "test"}
{"idx": "235", "code": "public int size(){\n  return al.size();\n}\n", "docstring": "returns the number of elements in this set .", "partition": "test"}
{"idx": "1544", "code": "public void addNode(TopologicalNode node){\n  nodeList.add(node);\n}\n", "docstring": "adds an topological node to this graph .", "partition": "test"}
{"idx": "1825", "code": "public void addErrorListener(final ErrorListener errorListener){\n  if (errorListeners == null) {\n    errorListeners=new ArrayList<ErrorListener>();\n  }\n  errorListeners.add(errorListener);\n}\n", "docstring": "add an error listener .", "partition": "test"}
{"idx": "3232", "code": "public CloseableAnimatedBitmap(List<Bitmap> bitmaps,List<Integer> durations,ResourceReleaser<Bitmap> resourceReleaser){\n  Preconditions.checkNotNull(bitmaps);\n  Preconditions.checkState(bitmaps.size() >= 1,\"Need at least 1 frame!\");\n  mBitmaps=new ArrayList<>();\n  mBitmapReferences=new ArrayList<>();\n  for (  Bitmap bitmap : bitmaps) {\n    mBitmapReferences.add(CloseableReference.of(bitmap,resourceReleaser));\n    mBitmaps.add(bitmap);\n  }\n  mDurations=Preconditions.checkNotNull(durations);\n  Preconditions.checkState(mDurations.size() == mBitmaps.size(),\"Arrays length mismatch!\");\n}\n", "docstring": "creates a new instance of a closeablestaticbitmap .", "partition": "test"}
{"idx": "3861", "code": "public boolean schedule(Runnable task,ClassLoader loader){\n  boolean isPriority=false;\n  boolean isQueue=true;\n  boolean isWake=true;\n  return scheduleImpl(task,loader,MAX_EXPIRE,isPriority,isQueue,isWake);\n}\n", "docstring": "schedules a new task .", "partition": "test"}
{"idx": "1175", "code": "public final void decRef() throws IOException {\n  ensureOpen();\n  final int rc=refCount.decrementAndGet();\n  if (rc == 0) {\n    boolean success=false;\n    try {\n      doClose();\n      closed=true;\n      success=true;\n    }\n  finally {\n      if (!success) {\n        refCount.incrementAndGet();\n      }\n    }\n  }\n else   if (rc < 0) {\n    throw new IllegalStateException(\"too many decRef calls: refCount is \" + rc + \" after decrement\");\n  }\n}\n", "docstring": "expert : decreases the refcount of this taxonomyreader instance . if the refcount drops to 0 this taxonomy reader is closed .", "partition": "test"}
{"idx": "2311", "code": "public static File findConfigInWorkingDirectory(){\n  for (  final String suffix : SUFFIXES) {\n    final File configFile=new File(System.getProperty(\"user.dir\"),PREFIX + suffix);\n    if (configFile.isFile()) {\n      return configFile;\n    }\n  }\n  return null;\n}\n", "docstring": "finds a log4j configuration file in the current working directory . the names of the files to look for are the same as those that log4j would look for on the classpath .", "partition": "test"}
{"idx": "1901", "code": "public void reset(){\n  displayCache.clear();\n  cachedID.clear();\n}\n", "docstring": "resets the drawer and its caches .", "partition": "test"}
{"idx": "2603", "code": "public double doubleValue(){\n  return d.doubleValue();\n}\n", "docstring": "get the double value corresponding to the instance .", "partition": "test"}
{"idx": "3255", "code": "public void addRequestProperty(String key,String value){\n  if (connected)   throw new IllegalStateException(\"Already connected\");\n  if (key == null)   throw new NullPointerException(\"key is null\");\n  if (requests == null)   requests=new MessageHeader();\n  requests.add(key,value);\n}\n", "docstring": "adds a general request property specified by a key - value pair . this method will not overwrite existing values associated with the same key .", "partition": "test"}
{"idx": "2689", "code": "public Iterable<Notification> skip(@Nonnull final Iterable<Notification> notifications,final long startId,final boolean inclusive,final int limitSize){\n  Objects.requireNonNull(notifications);\n  final int position=indexOf(notifications,startId);\n  if (position == -1) {\n    return Iterables.limit(notifications,limitSize);\n  }\n  if (inclusive) {\n    return Iterables.limit(Iterables.skip(notifications,position),limitSize);\n  }\n  return Iterables.limit(Iterables.skip(notifications,position + 1),limitSize);\n}\n", "docstring": "returns an iterable that skips forward to a given notification id then only returns count more notifications . if the given notification id is not found", "partition": "test"}
{"idx": "3046", "code": "public final void printClusters(PrintWriter out,List<ClusterData> clusterData,int[] matIndexToMsgInternalId) throws AdeException {\n  if (m_finalClusters == null) {\n    updateClusters(clusterData,matIndexToMsgInternalId);\n  }\n  for (  Map.Entry<String,Collection<Integer>> entry : m_finalClusters.entrySet()) {\n    final String n=entry.getKey();\n    final Collection<Integer> c=entry.getValue();\n    out.printf(\"%s\\\\t\",n);\n    for (    int m : c) {\n      out.printf(\"%d\\\\t\",matIndexToMsgInternalId[m]);\n    }\n    out.println();\n  }\n}\n", "docstring": "prints out the cluster information .", "partition": "test"}
{"idx": "355", "code": "public static String gensalt(int log_rounds,SecureRandom random){\n  StringBuffer rs=new StringBuffer();\n  byte rnd[]=new byte[BCRYPT_SALT_LEN];\n  random.nextBytes(rnd);\n  rs.append(\"$2a$\");\n  if (log_rounds < 10) {\n    rs.append(\"0\");\n  }\n  if (log_rounds > 30) {\n    throw new IllegalArgumentException(\"log_rounds exceeds maximum (30)\");\n  }\n  rs.append(Integer.toString(log_rounds));\n  rs.append(\"$\");\n  rs.append(encode_base64(rnd,rnd.length));\n  return rs.toString();\n}\n", "docstring": "generate a salt for use with the bcrypt . hashpw ( ) method .", "partition": "test"}
{"idx": "2935", "code": "public static String replaceChars(String str,String oldchars,char newchar){\n  int pos=indexOfChars(str,oldchars);\n  if (pos == -1) {\n    return str;\n  }\n  StringBuilder buf=new StringBuilder(str);\n  do {\n    buf.setCharAt(pos,newchar);\n    pos=indexOfChars(str,oldchars,pos + 1);\n  }\n while (pos != -1);\n  return buf.toString();\n}\n", "docstring": "like string . replace ( ) except that it accepts any number of old chars . replaces any occurrances of \"'\" oldchars \"'\" in \"'\" str \"'\" with \"'\" newchar \"'\" . example : replacechars ( \" hello , world ! \" , \" h , ! \" , \"'\" \"'\" ) returns \" ello world \"", "partition": "test"}
{"idx": "2773", "code": "public static List<ModuleSpec> expandSpecWildcards(File dir,List<ModuleSpec> modules,Backend forBackend){\n  List<File> dirs=new ArrayList<File>();\n  dirs.add(dir);\n  return expandSpecWildcards(dirs,modules,forBackend);\n}\n", "docstring": "given a source directory and a list of modulespecs that possibly contain wildcards it returns a expanded list of modulespecs of modules that were actually found in the given source directory . modulespecs that didn \"'\" t contain wildcards are left alone ( it \"'\" s not checked if they exist or not ) . if a backend is passed expanded modules will be checked if they support it ( they either don \"'\" t have a native annotation or it is for the correct backend ) .", "partition": "test"}
{"idx": "3784", "code": "public void serialize(KXmlSerializer serializer) throws IOException {\n  serializer.startTag(ns,TAG);\n  serializeAttribute(serializer,NAME_ATTR,mName);\n  serializeAttribute(serializer,APP_PACKAGE_NAME_ATTR,mAppPackageName);\n  serializeAttribute(serializer,DIGEST_ATTR,getDigest());\n  if (SIGNATURE_TEST_PKG.equals(mName)) {\n    serializer.attribute(ns,\"signatureCheck\",\"true\");\n  }\n  mSuiteRoot.serialize(serializer);\n  serializer.endTag(ns,TAG);\n}\n", "docstring": "serialize this object and all its contents to xml .", "partition": "test"}
{"idx": "436", "code": "public AwsIotConnection(AbstractAwsIotClient client){\n  this.client=client;\n}\n", "docstring": "instantiates a new connection object .", "partition": "test"}
{"idx": "1396", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return TRUE_AS_OF_SECS;\ncase 2:\n  return SOURCE;\ncase 3:\nreturn SYSTEM;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "2836", "code": "protected void waitForShutdownSignal() throws InterruptedException {\n  if (mutexWaiting == null)   mutexWaiting=new Object();\n  try {\nsynchronized (mutexWaiting) {\n      mutexWaiting.wait();\n    }\n  }\n catch (  InterruptedException e) {\n    if (!shutdown)     throw e;\n  }\n}\n", "docstring": "causes the current thread to block until signalshutdown is called . this is used by workerthreads which are not actively polling the shutdown field .", "partition": "test"}
{"idx": "3995", "code": "public ElsaSerializerPojo make(){\n  return new ElsaSerializerPojo(objectStack,singletons,registeredSers,registeredSerHeaders,registeredDeser,unknownClassNotification,new ElsaClassInfoResolver.ArrayBased(classes.toArray(new Class[0])));\n}\n", "docstring": "creates new serializer with configuration from this builder", "partition": "test"}
{"idx": "3602", "code": "private CoderResult decodeByteBufferToCharacterBuffer(boolean endOfInput) throws DecodingException {\n  buffer.flip();\n  return decodeMoreBytesToCharacterBuffer(endOfInput);\n}\n", "docstring": "decodes contents of the byte buffer to the character buffer . the character buffer will be replaced by a larger one if required .", "partition": "test"}
{"idx": "473", "code": "@Override public void actOn(File f){\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new FileReader(f));\n    announceSeedsFromReader(reader);\n  }\n catch (  FileNotFoundException fnf) {\n    logger.log(Level.SEVERE,\"seed file source not found\",fnf);\n  }\n finally {\n    IOUtils.closeQuietly(reader);\n  }\n}\n", "docstring": "treat the given file as a source of additional seeds , announcing to seedlisteners .", "partition": "test"}
{"idx": "903", "code": "public static int parseStringAsInt(String in) throws IndexParseFieldException {\n  try {\n    return Integer.parseInt(in);\n  }\n catch (  NumberFormatException e) {\n    throw new IndexParseFieldException(in,e);\n  }\n}\n", "docstring": "parses a string as a int .", "partition": "test"}
{"idx": "2373", "code": "protected void sendIntensity(double intensity){\n  if (log.isDebugEnabled()) {\n    log.debug(\"sendIntensity(\" + intensity + \")\"+ \" lastOutputStep: \"+ lastOutputStep+ \" maxDimStep: \"+ maxDimStep);\n  }\n  int newStep=(int)Math.round(intensity * maxDimStep);\n  if ((newStep < 0) || (newStep > maxDimStep)) {\n    log.error(\"newStep wrong: \" + newStep + \" intensity: \"+ intensity);\n  }\n  if (newStep == 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"intensity \" + intensity + \" within current step, return\");\n    }\n    return;\n  }\n  X10Sequence out=new X10Sequence();\n  out.addExtData(housecode,devicecode,X10Sequence.EXTCMD_DIM,newStep);\n  tc.sendX10Sequence(out,null);\n  lastOutputStep=newStep;\n  if (log.isDebugEnabled()) {\n    log.debug(\"sendIntensity(\" + intensity + \") house \"+ X10Sequence.houseValueToText(housecode)+ \" device \"+ devicecode+ \" newStep: \"+ newStep);\n  }\n}\n", "docstring": "send a dim / bright commands to the x10 hardware to reach a specific intensity . acts immediately , and changes no general state . < p > this sends \" dim \" commands .", "partition": "test"}
{"idx": "589", "code": "protected void describeVocabularies(final IVCount[] predicatePartitionCounts){\n  final Set<String> namespaces=new LinkedHashSet<String>();\n{\n    for (    IVCount tmp : predicatePartitionCounts) {\n      final URI p=(URI)tmp.getValue();\n      String namespace=p.getNamespace();\n      if (namespace.endsWith(\"#\")) {\n        namespace=namespace.substring(0,namespace.length() - 1);\n      }\n      namespaces.add(namespace);\n    }\n  }\n  final String[] a=namespaces.toArray(new String[namespaces.size()]);\n  Arrays.sort(a);\n  for (  String namespace : a) {\n    g.add(aDataset,VoidVocabularyDecl.vocabulary,f.createURI(namespace));\n  }\n}\n", "docstring": "describe the vocabularies which are in use in the kb based on the predicate partition statistics .", "partition": "test"}
{"idx": "1519", "code": "default Document putAll(Iterable<Field> fields,Predicate<CharSequence> acceptableFieldNames){\n  for (  Field field : fields) {\n    if (acceptableFieldNames.test(field.getName())) {\n      setValue(field.getName(),field.getValue());\n    }\n  }\n  return this;\n}\n", "docstring": "attempts to copy all of the acceptable fields from the source and set on this document , overwriting any existing values .", "partition": "test"}
{"idx": "4230", "code": "private JPanel createImageFilePanel(){\n  JPanel panel=new JPanel();\n  panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));\n  panel.add(imageFileName);\n  panel.add(Box.createHorizontalStrut(6));\n  panel.add(new JButton(openImageFile));\n  return panel;\n}\n", "docstring": "create and return the image file panel .", "partition": "test"}
{"idx": "1831", "code": "public DExamineSsl(JFrame parent,KseFrame kseFrame){\n  super(parent,res.getString(\"DExamineSsl.Title\"),Dialog.ModalityType.DOCUMENT_MODAL);\n  this.kseFrame=kseFrame;\n  initComponents();\n}\n", "docstring": "creates new dexaminessl dialog .", "partition": "test"}
{"idx": "1009", "code": "public boolean isSearchLightBit(int bit){\n  if (nodeType != SMINI) {\n    log.error(\"Invalid query of Searchlights bits - not SMINI node\");\n    return (false);\n  }\n  if ((bit < 0) || (bit > 47)) {\n    log.error(\"Invalid bit number in query of SMINI Searchlights bits: \" + Integer.toString(bit));\n    return (false);\n  }\n  if (locSearchLightBits[bit] == 1) {\n    return (true);\n  }\n  return (false);\n}\n", "docstring": "query searchlightbits by bit number ( smini only ) bit - bitnumber of the either bit of an oscillating search light bit pair note : returns \"'\" true \"'\" if bit is an oscillating searchlightbit , otherwise \"'\" false \"'\" is returned", "partition": "test"}
{"idx": "3820", "code": "public static boolean isUriKey(String key){\n  return key.endsWith(\".url\") || key.endsWith(\".uri\");\n}\n", "docstring": "this method determines if the supplied key relates to a uri .", "partition": "test"}
{"idx": "2650", "code": "private Collection<ExtractedItemsCollection> filterItemsByLevel(Player player,List<ExtractedItemsCollection> itemsCollections){\n  int playerLevel=player.getLevel();\n  Collection<ExtractedItemsCollection> result=new ArrayList<ExtractedItemsCollection>();\n  for (  ExtractedItemsCollection collection : itemsCollections) {\n    if (collection.getMinLevel() > playerLevel) {\n      continue;\n    }\n    if (collection.getMaxLevel() > 0 && collection.getMaxLevel() < playerLevel) {\n      continue;\n    }\n    result.add(collection);\n  }\n  return result;\n}\n", "docstring": "add to result collection only items witch suits player \"'\" s level", "partition": "test"}
{"idx": "3104", "code": "public AuthRequest authenticate(List discoveries,String returnToUrl) throws ConsumerException, MessageException {\n  return authenticate(discoveries,returnToUrl,returnToUrl);\n}\n", "docstring": "builds a authentication request message for the user specified in the discovery information provided as a parameter . < p > if the discoveries parameter contains more than one entry , it will iterate over them trying to establish an association . if an association cannot be established , the first entry is used with stateless mode .", "partition": "test"}
{"idx": "2279", "code": "protected void sqrtLayout(VisualTable labels){\n  Rectangle2D b=getLayoutBounds();\n  double breadth=getBreadth(b);\n  double span=m_hi - m_lo;\n  double splo=MathLib.safeSqrt(m_prevlo);\n  double spspan=MathLib.safeSqrt(m_prevhi) - splo;\n  double vlo=Math.pow(10,Math.floor(MathLib.safeLog10(m_lo)));\n  double slo=MathLib.safeSqrt(m_lo);\n  double sspan=MathLib.safeSqrt(m_hi) - slo;\n  Iterator iter=labels.tuples();\n  while (iter.hasNext()) {\n    VisualItem item=(VisualItem)iter.next();\n    reset(item);\n    double v=item.getDouble(VALUE);\n    double x=span == 0 ? 0 : ((MathLib.safeSqrt(v) - slo) / sspan) * breadth;\n    set(item,x,b);\n  }\n  Index index=labels.index(VALUE);\n  double step=getLinearStep(span,breadth / span);\n  if (step == 0)   step=1;\n  int r;\n  for (double x, v=vlo; v <= m_hi; v+=step) {\n    x=((MathLib.safeSqrt(v) - slo) / sspan) * breadth;\n    if (x < -0.5) {\n      continue;\n    }\n else     if ((r=index.get(v)) >= 0) {\n      VisualItem item=labels.getItem(r);\n      item.setVisible(true);\n      item.setEndVisible(true);\n    }\n else {\n      VisualItem item=labels.addItem();\n      item.set(LABEL,m_nf.format(v));\n      item.setDouble(VALUE,v);\n      double f=spspan == 0 ? 0 : ((MathLib.safeSqrt(v) - splo) / spspan);\n      if (f <= 0 || f >= 1.0) {\n        item.setStartVisible(true);\n      }\n      set(item,f * breadth,b);\n      set(item,x,b);\n    }\n  }\n}\n", "docstring": "calculates a quantitative , square root scaled layout .", "partition": "test"}
{"idx": "2933", "code": "public GeoDistanceBuilder addUnboundedFrom(String key,double from){\n  ranges.add(new Range(key,from,null));\n  return this;\n}\n", "docstring": "add a new range with no upper bound .", "partition": "test"}
{"idx": "2715", "code": "public boolean checkForRp(){\n  return NullColumnValueGetter.isNotNullValue(getRpCopyName());\n}\n", "docstring": "uses a field in the volume to determine if the volume is an rp volume . best to use a field that is set during placement / scheduling of the volume , during vipr ( cassandra ) volume creation .", "partition": "test"}
{"idx": "2209", "code": "public void close() throws IOException {\n  flushBits();\n  out.close();\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2212", "code": "public void cut(){\n  copy();\n  deleteSelectedObjects();\n}\n", "docstring": "cut to the clipboard .", "partition": "test"}
{"idx": "44", "code": "private ServiceRegistrar[] buildServiceRegistrar(){\n  int k=0;\n  ServiceRegistrar[] proxys=new ServiceRegistrar[proxyRegSet.size()];\n  Iterator iter=proxyRegSet.iterator();\n  while (iter.hasNext()) {\n    ProxyReg reg=(ProxyReg)iter.next();\n    proxys[k++]=reg.proxy;\n  }\n  return proxys;\n}\n", "docstring": "returns array of serviceregistrar created from the proxyregset", "partition": "test"}
{"idx": "97", "code": "private static void solve_l2r_l1l2_svr(Problem prob,double[] w,Parameter param){\n  int l=prob.l;\n  double C=param.C;\n  double p=param.p;\n  int w_size=prob.n;\n  double eps=param.eps;\n  int i, s, iter=0;\n  int max_iter=param.getMaxIters();\n  int active_size=l;\n  int[] index=new int[l];\n  double d, G, H;\n  double Gmax_old=Double.POSITIVE_INFINITY;\n  double Gmax_new, Gnorm1_new;\n  double Gnorm1_init=-1.0;\n  double[] beta=new double[l];\n  double[] QD=new double[l];\n  double[] y=prob.y;\n  double[] lambda=new double[]{0.5 / C};\n  double[] upper_bound=new double[]{Double.POSITIVE_INFINITY};\n  if (param.solverType == SolverType.L2R_L1LOSS_SVR_DUAL) {\n    lambda[0]=0;\n    upper_bound[0]=C;\n  }\n  for (i=0; i < l; i++)   beta[i]=0;\n  for (i=0; i < w_size; i++)   w[i]=0;\n  for (i=0; i < l; i++) {\n    QD[i]=0;\n    for (    Feature xi : prob.x[i]) {\n      double val=xi.getValue();\n      QD[i]+=val * val;\n      w[xi.getIndex() - 1]+=beta[i] * val;\n    }\n    index[i]=i;\n  }\n  while (iter < max_iter) {\n    Gmax_new=0;\n    Gnorm1_new=0;\n    for (i=0; i < active_size; i++) {\n      int j=i + random.nextInt(active_size - i);\n      swap(index,i,j);\n    }\n    for (s=0; s < active_size; s++) {\n      i=index[s];\n      G=-y[i] + lambda[GETI_SVR(i)] * beta[i];\n      H=QD[i] + lambda[GETI_SVR(i)];\n      for (      Feature xi : prob.x[i]) {\n        int ind=xi.getIndex() - 1;\n        double val=xi.getValue();\n        G+=val * w[ind];\n      }\n      double Gp=G + p;\n      double Gn=G - p;\n      double violation=0;\n      if (beta[i] == 0) {\n        if (Gp < 0)         violation=-Gp;\n else         if (Gn > 0)         violation=Gn;\n else         if (Gp > Gmax_old && Gn < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] >= upper_bound[GETI_SVR(i)]) {\n        if (Gp > 0)         violation=Gp;\n else         if (Gp < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] <= -upper_bound[GETI_SVR(i)]) {\n        if (Gn < 0)         violation=-Gn;\n else         if (Gn > Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] > 0)       violation=Math.abs(Gp);\n else       violation=Math.abs(Gn);\n      Gmax_new=Math.max(Gmax_new,violation);\n      Gnorm1_new+=violation;\n      if (Gp < H * beta[i])       d=-Gp / H;\n else       if (Gn > H * beta[i])       d=-Gn / H;\n else       d=-beta[i];\n      if (Math.abs(d) < 1.0e-12)       continue;\n      double beta_old=beta[i];\n      beta[i]=Math.min(Math.max(beta[i] + d,-upper_bound[GETI_SVR(i)]),upper_bound[GETI_SVR(i)]);\n      d=beta[i] - beta_old;\n      if (d != 0) {\n        for (        Feature xi : prob.x[i]) {\n          w[xi.getIndex() - 1]+=d * xi.getValue();\n        }\n      }\n    }\n    if (iter == 0)     Gnorm1_init=Gnorm1_new;\n    iter++;\n    if (iter % 10 == 0)     info(\".\");\n    if (Gnorm1_new <= eps * Gnorm1_init) {\n      if (active_size == l)       break;\n else {\n        active_size=l;\n        info(\"*\");\n        Gmax_old=Double.POSITIVE_INFINITY;\n        continue;\n      }\n    }\n    Gmax_old=Gmax_new;\n  }\n  info(\"%noptimization finished, #iter = %d%n\",iter);\n  if (iter >= max_iter)   info(\"%nWARNING: reaching max number of iterations%nUsing -s 11 may be faster%n%n\");\n  double v=0;\n  int nSV=0;\n  for (i=0; i < w_size; i++)   v+=w[i] * w[i];\n  v=0.5 * v;\n  for (i=0; i < l; i++) {\n    v+=p * Math.abs(beta[i]) - y[i] * beta[i] + 0.5 * lambda[GETI_SVR(i)] * beta[i]* beta[i];\n    if (beta[i] != 0)     nSV++;\n  }\n  info(\"Objective value = %g%n\",v);\n  info(\"nSV = %d%n\",nSV);\n}\n", "docstring": "a coordinate descent algorithm for l1 - loss and l2 - loss epsilon - svr dual problem min_ \\\\ beta 0 . 5 \\\\ beta ^ t ( q + diag ( lambda ) ) \\\\ beta - p \\\\ sum_ { i = 1 } ^ l | \\\\ beta_i | + \\\\ sum_ { i = 1 } ^ l yi \\\\ beta_i , s . t . - upper_bound_i < = \\\\ beta_i < = upper_bound_i , where qij = xi ^ t xj and d is a diagonal matrix in l1 - svm case : upper_bound_i = c lambda_i = 0 in l2 - svm case : upper_bound_i = inf lambda_i = 1 / ( 2 * c ) given : x , y , p , c eps is the stopping tolerance solution will be put in w see algorithm 4 of ho and lin , 2012", "partition": "test"}
{"idx": "2102", "code": "public SimpleSetupPanel(Experiment exp){\n  this();\n  setExperiment(exp);\n}\n", "docstring": "creates the setup panel with the supplied initial experiment .", "partition": "test"}
{"idx": "1986", "code": "public void stop(){\n  server.stop(0);\n}\n", "docstring": "stop the web server .", "partition": "test"}
{"idx": "1436", "code": "public static final double sigma(double a){\n  return 1.0 / (1.0 + Math.exp(-a));\n}\n", "docstring": "sigmoid / logistic function", "partition": "test"}
{"idx": "3470", "code": "public KeyImpl(KerberosPrincipal principal,char[] password,String algorithm){\n  try {\n    PrincipalName princ=new PrincipalName(principal.getName());\n    EncryptionKey key=new EncryptionKey(password,princ.getSalt(),algorithm);\n    this.keyBytes=key.getBytes();\n    this.keyType=key.getEType();\n  }\n catch (  KrbException e) {\n    throw new IllegalArgumentException(e.getMessage());\n  }\n}\n", "docstring": "constructs a keyimpl from a password .", "partition": "test"}
{"idx": "3655", "code": "public ByteArrayDataSource(InputStream is,String type){\n  try {\n    ByteArrayOutputStream os=new ByteArrayOutputStream();\n    int ch;\n    while ((ch=is.read()) != -1) {\n      os.write(ch);\n    }\n    m_data=os.toByteArray();\n  }\n catch (  IOException ioex) {\n    log.log(Level.WARNING,\"\",ioex);\n  }\n  if (type != null && type.length() > 0)   m_type=type;\n}\n", "docstring": "create a datasource from an input stream", "partition": "test"}
{"idx": "3319", "code": "public static void load(String url){\n  String driver=getDriver(url);\n  if (driver != null) {\n    loadUserClass(driver);\n  }\n}\n", "docstring": "load the driver class for the given url , if the database url is known .", "partition": "test"}
{"idx": "881", "code": "protected void throwParseException(ParseException e) throws ParseException {\n  if (locator != null) {\n    String elementLocation=\"\";\n    if (curHandler != null) {\n      elementLocation+=\", element \" + curHandler.qName;\n    }\n    String location=\"[Line \" + String.valueOf(locator.getLineNumber()) + \", Column \"+ String.valueOf(locator.getColumnNumber())+ elementLocation+ \"] \";\n    LogUtils.logException(logger,Level.FINE,location,e);\n    throw new ParseException(location + e.getMessage(),e);\n  }\n else {\n    LogUtils.logException(logger,Level.FINE,null,e);\n    throw e;\n  }\n}\n", "docstring": "throws a parse exception with line / column information .", "partition": "test"}
{"idx": "2675", "code": "public void testBug10630() throws Exception {\n  Connection conn2=null;\n  Statement stmt2=null;\n  try {\n    conn2=getConnectionWithProps((Properties)null);\n    stmt2=conn2.createStatement();\n    conn2.close();\n    stmt2.getWarnings();\n    fail(\"Should\\'ve caught an exception here\");\n  }\n catch (  SQLException sqlEx) {\n    assertEquals(SQLError.SQL_STATE_ILLEGAL_ARGUMENT,sqlEx.getSQLState());\n  }\n finally {\n    if (stmt2 != null) {\n      stmt2.close();\n    }\n    if (conn2 != null) {\n      conn2.close();\n    }\n  }\n}\n", "docstring": "tests fix for bug # 10630 , statement . getwarnings ( ) fails with npe if statement has been closed .", "partition": "test"}
{"idx": "3159", "code": "private void stashRequestUser(RequestAndResponse requestAndResponse){\n  if (requestAndResponse.wasUserAlreadyStashed) {\n    return;\n  }\n  requestAndResponse.wasUserAlreadyStashed=true;\n  final User user=dbLogic.getUserById(getEffectiveUserId(requestAndResponse));\n  if (user != null) {\n    requestAndResponse.userIsAdmin=user.getIsAdmin();\n    requestAndResponse.userIsAccountClosed=user.getIsAccountClosed();\n    requestAndResponse.userOptions=user.getOptions();\n  }\n else {\n    requestAndResponse.userOptions=\"{}\";\n  }\n}\n", "docstring": "stashes user information in the requestandresponse to reduce the number of queries and transactions .", "partition": "test"}
{"idx": "3127", "code": "protected void addBottomComponent(Component bottomComponent){\n  c.weighty=2;\n  layout.setConstraints(bottomComponent,c);\n  contentPanel.add(bottomComponent);\n}\n", "docstring": "subclasses might add an additional component here which is seen during all steps , e . g . a data view table .", "partition": "test"}
{"idx": "3314", "code": "protected double kernelHelper(int n,char[] s,int endIndexS,char[] t,int endIndexT){\n  if (n <= 0) {\n    return getReturnValue(n);\n  }\n  if (Math.min(endIndexS + 1,endIndexT + 1) < n) {\n    return getReturnValue(n);\n  }\n  int adr=0;\n  if (m_useRecursionCache) {\n    adr=m_multX * n + m_multY * endIndexS + m_multZ * endIndexT;\n    if (cachekhK[adr % maxCache] == adr + 1) {\n      return cachekh[adr % maxCache];\n    }\n  }\n  double result=0;\n  result=m_lambda * kernelHelper(n,s,endIndexS - 1,t,endIndexT) + kernelHelper2(n,s,endIndexS,t,endIndexT);\n  if (m_useRecursionCache) {\n    cachekhK[adr % maxCache]=adr + 1;\n    cachekh[adr % maxCache]=result;\n  }\n  return result;\n}\n", "docstring": "the kernel helper function , called k \"'\" in [ 1 ", "partition": "test"}
{"idx": "248", "code": "private static String unwrap(String expression){\n  if (expression.startsWith(\"((\")) {\n    expression=expression.substring(expression.indexOf(\")\") + 1,expression.length() - 1);\n    if (expression.endsWith(\"]\")) {\n      expression=expression.substring(0,expression.lastIndexOf(\"[\"));\n    }\n else {\n      expression=expression.substring(0,expression.lastIndexOf(\".\"));\n    }\n  }\n  return expression;\n}\n", "docstring": "removes the outermost property from a nested getter expression", "partition": "test"}
{"idx": "2332", "code": "public boolean hasChangeEvent(String name){\n  if (var != null) {\n    List<MetaData> mdList=var.getMetaData(StandardDefs.MD_CHANGEEVENT);\n    if (mdList != null) {\n      for (int i=0, size=mdList.size(); i < size; i++) {\n        MetaData md=mdList.get(i);\n        if (name.equals(md.getValue(0))) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "[ changeevent ", "partition": "test"}
{"idx": "2536", "code": "private byte[] entityToBytes(HttpEntity entity,Request request) throws IOException, ServerError {\n  PoolingByteArrayOutputStream bytes=new PoolingByteArrayOutputStream(mPool,(int)entity.getContentLength());\n  byte[] buffer=null;\n  try {\n    InputStream in=entity.getContent();\n    if (in == null) {\n      throw new ServerError();\n    }\n    buffer=mPool.getBuf(1024);\n    int progress=0;\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      bytes.write(buffer,0,count);\n      progress+=count;\n      request.progressUpdate(progress);\n    }\n    return bytes.toByteArray();\n  }\n  finally {\n    try {\n      entity.consumeContent();\n    }\n catch (    IOException e) {\n      VinciLog.d(\"Error occured when calling consumingContent\");\n    }\n    mPool.returnBuf(buffer);\n    bytes.close();\n  }\n}\n", "docstring": "reads the contents of httpentity into a byte [ ", "partition": "test"}
{"idx": "1351", "code": "public CodeAttribute createCode(){\n  CodeAttribute code=new CodeAttribute();\n  for (int i=0; i < _attributes.size(); i++) {\n    Attribute attr=_attributes.get(i);\n    if (attr instanceof CodeAttribute)     return (CodeAttribute)attr;\n  }\n  return null;\n}\n", "docstring": "create the code attribute .", "partition": "test"}
{"idx": "2756", "code": "public Vector<Option> enumToVector(Enumeration<Option> enu){\n  Vector<Option> options=new Vector<Option>();\n  options.addAll(Collections.list(enu));\n  return options;\n}\n", "docstring": "convenience method . turns the given enumeration of options into a vector .", "partition": "test"}
{"idx": "721", "code": "private boolean isNotInArray(String str,String[] array){\n  for (int i=0; i < array.length; i++) {\n    if (str.equals(array[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "returns true iff str is not an element of array .", "partition": "test"}
{"idx": "2024", "code": "void addAttributeValues(String attrName,Set values) throws SMSException {\n  if (attrName != null && values != null && !values.isEmpty()) {\n    Map attrs=getAttributes();\n    Set origValues=(Set)attrs.get(attrName);\n    Set newValues=new HashSet(values);\n    if (origValues != null && !origValues.isEmpty()) {\n      newValues.addAll(origValues);\n    }\n    Map newAttrs=new HashMap();\n    newAttrs.put(attrName,newValues);\n    setAttributes(newAttrs);\n  }\n}\n", "docstring": "adds attributes to amsdk organization . the organziation attribute names are defined in the idrepo service .", "partition": "test"}
{"idx": "827", "code": "public KafkaCluster usingDirectory(File dataDir){\n  if (running)   throw new IllegalStateException(\"Unable to add a broker when the cluster is already running\");\n  if (dataDir != null && dataDir.exists() && !dataDir.isDirectory() && !dataDir.canWrite() && !dataDir.canRead()) {\n    throw new IllegalArgumentException(\"The directory must be readable and writable\");\n  }\n  this.dataDir=dataDir;\n  return this;\n}\n", "docstring": "set the parent directory where the brokers logs and server \"'\" s logs and snapshots will be kept .", "partition": "test"}
{"idx": "1224", "code": "public static Object invokeStatic(Class clazz,String methodName) throws NoSuchMethodException {\n  try {\n    Method method=clazz.getMethod(methodName,new Class[0]);\n    Object result=method.invoke(null,new Object[0]);\n    return result;\n  }\n catch (  IllegalAccessException e) {\n    throw new NoSuchMethodException(methodName + \" is not accessible\");\n  }\ncatch (  InvocationTargetException e) {\n    throw new InternalError(e.getMessage());\n  }\n}\n", "docstring": "invokes the specified accessible parameterless method if it exists .", "partition": "test"}
{"idx": "3750", "code": "private void attachImageFromCamera(){\n  try {\n    if (null != mShootedPicturePath) {\n      Uri uri=Uri.fromFile(new File(mShootedPicturePath));\n      try {\n        Bitmap previewBitmap=VectorApp.getSavedPickerImagePreview();\n        String thumbnailPath=getThumbnailPath(mShootedPicturePath);\n        int rotationAngle=ImageUtils.getRotationAngleForBitmap(VectorMediasPickerActivity.this,uri);\n        if (0 != rotationAngle) {\n          android.graphics.Matrix bitmapMatrix=new android.graphics.Matrix();\n          bitmapMatrix.postRotate(360 - rotationAngle);\n          previewBitmap=Bitmap.createBitmap(previewBitmap,0,0,previewBitmap.getWidth(),previewBitmap.getHeight(),bitmapMatrix,false);\n        }\n        File file=new File(thumbnailPath);\n        FileOutputStream outStream=new FileOutputStream(file);\n        previewBitmap.compress(Bitmap.CompressFormat.JPEG,50,outStream);\n        outStream.flush();\n        outStream.close();\n      }\n catch (      Exception e) {\n        Log.e(LOG_TAG,\"attachImageFromCamera fails to create thumbnail file\");\n      }\n      Bundle conData=new Bundle();\n      Intent intent=new Intent();\n      intent.setData(uri);\n      intent.putExtras(conData);\n      setResult(RESULT_OK,intent);\n    }\n  }\n catch (  Exception e) {\n    setResult(RESULT_CANCELED,null);\n  }\n finally {\n    VectorApp.setSavedCameraImagePreview(null);\n    finish();\n  }\n}\n", "docstring": "return the taken image from the camera to the calling activity . this method returns to the calling activity .", "partition": "test"}
{"idx": "3559", "code": "public void addLongSelectionListener(SelectionListener listener){\n  if (listener == null)   throw new IllegalArgumentException();\n  if (hexEditControl == null) {\n    if (listOfLongListeners == null)     listOfLongListeners=new ArrayList<>();\n    listOfLongListeners.add(listener);\n  }\n else {\n    hexEditControl.addLongSelectionListener(listener);\n  }\n}\n", "docstring": "adds a long selection listener . events sent to the listener have long start and end points .", "partition": "test"}
{"idx": "967", "code": "private void showFilterDialog(Filter filter){\n  int sortOrder=mAdapter.getCount() - 1;\n  if (filter == null) {\n    EditFilterActivity.createNewFilter(getActivity(),sortOrder);\n  }\n else {\n    EditFilterActivity.editFilter(getActivity(),filter,sortOrder);\n  }\n}\n", "docstring": "shows the filter dialog", "partition": "test"}
{"idx": "2340", "code": "static void createPolicyTree(String configName,String configId,ServiceConfigManager scm,String org) throws NoPermissionException, PolicyException, SSOException {\n  try {\n    ServiceConfig pConfig=scm.getOrganizationConfig(org,null);\n    if (pConfig == null) {\n      scm.createOrganizationConfig(org,null);\n      pConfig=scm.getOrganizationConfig(org,null);\n    }\n    pConfig.addSubConfig(configName,configId,0,null);\n  }\n catch (  ServiceAlreadyExistsException se) {\n    if (debug.messageEnabled()) {\n      debug.message(\"PolicyManager->createPolicyTree: Name: \" + configName + \" ID: \"+ configId+ \" Policy service already exists under org->\"+ org);\n    }\n  }\ncatch (  SMSException e) {\n    String[] objs={org};\n    if (e.getExceptionCode() == SMSException.STATUS_NO_PERMISSION) {\n      throw (new NoPermissionException(ResBundleUtils.rbName,\"insufficient_access_rights\",null));\n    }\n else {\n      throw (new PolicyException(ResBundleUtils.rbName,\"unable_to_create_policy_for_org\",objs,e));\n    }\n  }\n}\n", "docstring": "creates the policy tree , ou = policy , ou = services , . . .", "partition": "test"}
{"idx": "4193", "code": "public void create(String[] rpfFilePaths,String outputFile) throws MakeTocException {\n  create(rpfFilePaths,outputFile,false);\n}\n", "docstring": "create a a . toc file specificed by the frame file list , at the location specified .", "partition": "test"}
{"idx": "4059", "code": "public static void scaleRectAboutCenter(Rect r,float scale){\n  if (scale != 1.0f) {\n    int cx=r.centerX();\n    int cy=r.centerY();\n    r.offset(-cx,-cy);\n    r.left=(int)(r.left * scale + 0.5f);\n    r.top=(int)(r.top * scale + 0.5f);\n    r.right=(int)(r.right * scale + 0.5f);\n    r.bottom=(int)(r.bottom * scale + 0.5f);\n    r.offset(cx,cy);\n  }\n}\n", "docstring": "scales a rect about its centroid", "partition": "test"}
{"idx": "2103", "code": "private static void processArgs(String[] args){\n  for (int i=0; i < args.length; i++) {\n    String arg=args[i];\n    if (arg.equals(\"-o\")) {\n      outputDir=args[++i];\n    }\n else     if (arg.equals(\"-spec\")) {\n      unicodeData=args[++i];\n    }\n else     if (arg.equals(\"-language\")) {\n      language=args[++i];\n    }\n else     if (arg.equals(\"-country\")) {\n      country=args[++i];\n    }\n else     if (arg.equals(\"-valiant\")) {\n      valiant=args[++i];\n    }\n else {\n      usage();\n    }\n  }\n  localeName=getLocaleName();\n}\n", "docstring": "parses the specified arguments and sets up the variables .", "partition": "test"}
{"idx": "1341", "code": "public String documentationHomePageUrl(){\n  return properties.getProperty(\"doc.homepage.url\");\n}\n", "docstring": "returns the url of the product home page .", "partition": "test"}
{"idx": "3267", "code": "public ExtendedTextLabel createExtended(Font font,CoreMetrics lm,Decoration decorator,int start,int limit){\n  if (start >= limit || start < lineStart || limit > lineLimit) {\n    throw new IllegalArgumentException(\"bad start: \" + start + \" or limit: \"+ limit);\n  }\n  int level=lineBidi == null ? 0 : lineBidi.getLevelAt(start - lineStart);\n  int linedir=(lineBidi == null || lineBidi.baseIsLeftToRight()) ? 0 : 1;\n  int layoutFlags=flags & ~0x9;\n  if ((level & 0x1) != 0)   layoutFlags|=1;\n  if ((linedir & 0x1) != 0)   layoutFlags|=8;\n  TextSource source=new StandardTextSource(text,start,limit - start,lineStart,lineLimit - lineStart,level,layoutFlags,font,frc,lm);\n  return new ExtendedTextSourceLabel(source,decorator);\n}\n", "docstring": "create an extended glyph array for the text between start and limit .", "partition": "test"}
{"idx": "1899", "code": "public void continueButtonActionPerformed(java.awt.event.ActionEvent e){\n  if (testRunning && testSuspended) {\n    testSuspended=false;\n    if (wrapTest) {\n      statusText1.setText(\"Running Wraparound Test\");\n      statusText1.setVisible(true);\n    }\n  }\n}\n", "docstring": "method to handle continue button in diagnostic frame", "partition": "test"}
{"idx": "1842", "code": "public static byte[] unsynchronize(byte[] abySource){\n  ByteArrayInputStream input=new ByteArrayInputStream(abySource);\n  ByteArrayOutputStream output=new ByteArrayOutputStream(abySource.length);\n  int count=0;\n  while (input.available() > 0) {\n    int firstByte=input.read();\n    count++;\n    output.write(firstByte);\n    if ((firstByte & MPEGFrameHeader.SYNC_BYTE1) == MPEGFrameHeader.SYNC_BYTE1) {\n      if (input.available() > 0) {\n        input.mark(1);\n        int secondByte=input.read();\n        if ((secondByte & MPEGFrameHeader.SYNC_BYTE2) == MPEGFrameHeader.SYNC_BYTE2) {\n          if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Writing unsynchronisation bit at:\" + count);\n          }\n          output.write(0);\n        }\n else         if (secondByte == 0) {\n          if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Inserting zero unsynchronisation bit at:\" + count);\n          }\n          output.write(0);\n        }\n        input.reset();\n      }\n    }\n  }\n  if ((abySource[abySource.length - 1] & MPEGFrameHeader.SYNC_BYTE1) == MPEGFrameHeader.SYNC_BYTE1) {\n    logger.finest(\"Adding unsynchronisation bit at end of stream\");\n    output.write(0);\n  }\n  return output.toByteArray();\n}\n", "docstring": "unsynchronize an array of bytes , this should only be called if the decision has already been made to unsynchronize the byte array in order to prevent a media player from incorrectly interpreting the contents of a tag , all $ ff bytes followed by a byte with value > = 224 must be followed by a $ 00 byte ( thus , $ ff $ f0 sequences become $ ff $ 00 $ f0 ) . additionally because unsynchronisation is being applied any existing $ ff $ 00 have to be converted to $ ff $ 00 $ 00", "partition": "test"}
{"idx": "1374", "code": "private void executeClaimedTask(ClaimedTask claimedTask){\n  if (!claimedTask.setStartTime(new Date())) {\n    _log.info(\"Claimed task is overdue; range not scanned: {}\",claimedTask.getTask());\n    return;\n  }\n  ScanRangeTask task=claimedTask.getTask();\n  boolean releaseTask=false;\n  try {\n    _scanWorkflow.renewScanRangeTasks(ImmutableList.of(task),QUEUE_RENEW_TTL);\n    releaseTask=asyncRangeScan(task);\n  }\n  finally {\n    unclaimTask(claimedTask,releaseTask);\n    _backgroundService.submit(_startScansIfAvailableRunnable);\n  }\n}\n", "docstring": "executes a previously claimed scan range task .", "partition": "test"}
{"idx": "1253", "code": "private void loadMap(String extension,String mimeType){\n  if (!mimeTypeToExtensionMap.containsKey(mimeType)) {\n    mimeTypeToExtensionMap.put(mimeType,extension);\n  }\n  extensionToMimeTypeMap.put(extension,mimeType);\n  if (isImageType(mimeType)) {\n    imageMimeTypeSet.add(mimeType);\n  }\n}\n", "docstring": "load an entry into the map .", "partition": "test"}
{"idx": "2368", "code": "void copyInto(Converter[] converters){\n  System.arraycopy(iConverters,0,converters,0,iConverters.length);\n}\n", "docstring": "copies all the converters in the set to the given array .", "partition": "test"}
{"idx": "3547", "code": "private static Position nextTokenPos(Position pos,Token[][] spec){\n  if (pos == null) {\n    return null;\n  }\n  int nextItem=pos.item + 1;\n  if ((nextItem < spec[pos.line].length) && ((pos.line < pcalEnd.line) || (nextItem < pcalEnd.item))) {\n    return new Position(pos.line,nextItem);\n  }\n  int nextLine=pos.line + 1;\n  while ((nextLine < spec.length) && (spec[nextLine].length == 0)) {\n    nextLine++;\n  }\n  if ((nextLine < spec.length) && ((nextLine < pcalEnd.line) || ((nextLine == pcalEnd.line) && (0 < pcalEnd.item)))) {\n    return new Position(nextLine,0);\n  }\n  return null;\n}\n", "docstring": "returns the position of the next token after position pos in specification spec if that token exists and is in the pluscal algorithm ; otherwise , it returns null . for convenience it returns null if called with a null pos argument .", "partition": "test"}
{"idx": "4000", "code": "private String processLogoutRequest(LogoutState t,LogoutRequest logoutRequest,SessionManager sessionManager) throws SamlServiceException {\n  String sessionId=null;\n  List<SessionIndex> sessionList=logoutRequest.getSessionIndexes();\n  Validate.notNull(sessionList,\"sessionList\");\n  Validate.isTrue(sessionList.size() > 0);\n  for (  SessionIndex sessionIndex : sessionList) {\n    Validate.notNull(sessionIndex);\n    String participantSession=sessionIndex.getSessionIndex();\n    Validate.notNull(participantSession,\"participantSession\");\n    Session session=sessionManager.getByParticipant(participantSession);\n    if (session == null) {\n      throw new SamlServiceException(\"Server session not found\");\n    }\n    if (!session.containsSessionParticipantUrl(t.getIssuerValue())) {\n      throw new SamlServiceException(\"Issuer URL does not match session participant URL\");\n    }\n    if (sessionId == null) {\n      sessionId=session.getId();\n    }\n else {\n      if (!sessionId.equals(session.getId())) {\n        throw new SamlServiceException(\"Participant requested multiple server sessions to be terminated\");\n      }\n    }\n  }\n  return sessionId;\n}\n", "docstring": "process logoutrequest return the session found or throw samlserviceexception", "partition": "test"}
{"idx": "1927", "code": "private static a createImageLink(String AD_Language,String name,String js_command,boolean enabled,boolean pressed){\n  a img=new a(\"#\",createImage(AD_Language,name));\n  if (!pressed || !enabled)   img.setID(\"imgButtonLink\");\n else   img.setID(\"imgButtonPressedLink\");\n  if (js_command == null)   js_command=\"\\'Submit\\'\";\n  if (js_command.length() > 0 && enabled) {\n    if (js_command.startsWith(\"startPopup\"))     img.setOnClick(js_command);\n else     img.setOnClick(\"SubmitForm(\\'\" + name + \"\\', \"+ js_command+ \",\\'toolbar\\');return false;\");\n  }\n  img.setClass(\"ToolbarButton\");\n  img.setOnMouseOver(\"window.status=\\'\" + name + \"\\';return true;\");\n  img.setOnMouseOut(\"window.status=\\'\\';return true;\");\n  img.setOnBlur(\"this.hideFocus=false\");\n  return img;\n}\n", "docstring": "create image with name , id of button_name and set p_command onclick", "partition": "test"}
{"idx": "1766", "code": "public synchronized void commit(){\nsynchronized (mutex) {\n    Map<Column,Set<Interval>> temp=workingIntervals;\n    workingIntervals=Collections.synchronizedMap(new LinkedHashMap<>());\n    availableIntervalsRef.set(Collections.unmodifiableMap(new LinkedHashMap<>(temp)));\n    super.columns=new LinkedHashSet<>(temp.keySet());\n  }\n}\n", "docstring": "swaps the actual cache with the built - up temporary cache and creates a fresh , empty temporary cache .", "partition": "test"}
{"idx": "482", "code": "public AbstractResource(String mimetype){\n  this(mimetype,System.currentTimeMillis());\n}\n", "docstring": "initializes this abstractresource with the given mimetype . the modification time of the resource is set to the current system time .", "partition": "test"}
{"idx": "3118", "code": "@Override public Void call() throws Exception {\n  MulticastSocket datagramSocket=null;\n  ExecutorService service=null;\n  try {\n    datagramSocket=new MulticastSocket(port);\n    datagramSocket.joinGroup(group);\n    service=Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory(\"GangliaListener\"));\n    final byte[] buffer=new byte[BUFFER_SIZE];\n    final DatagramPacket packet=new DatagramPacket(buffer,0,buffer.length);\n    listening=true;\n    while (true) {\n      try {\n        datagramSocket.receive(packet);\n        if (Thread.interrupted()) {\n          break;\n        }\n        final IGangliaMessage msg=decodeRecord(packet.getData(),packet.getOffset(),packet.getLength());\n        if (msg != null) {\n          service.submit(new DispatchTask(handler,msg));\n        }\n      }\n catch (      Throwable t) {\n        log.warn(t,t);\n      }\n    }\n    return (Void)null;\n  }\n  finally {\n    if (service != null) {\n      service.shutdown();\n    }\n    if (datagramSocket != null) {\n      datagramSocket.close();\n    }\n    listening=false;\n  }\n}\n", "docstring": "listens for ganglia messages . each message is decoded as as it is received . bad packets are dropped . valid messages are dispatched using a second thread to avoid latency in the thread which is listening to the ganglia protocol . < p > note : this method blocks and does not notice an interrupt . this is because jdk 6 does not support multicast nio . todo java 6 does not support non - blocking multicast receive . write a jdk 7 specific version of class class which uses multicast with non - blocking io and hence can be interrupted .", "partition": "test"}
{"idx": "1721", "code": "public static MoveParticipant[] loadMoveParticipants(RefactoringStatus status,RefactoringProcessor processor,Object element,MoveArguments arguments,IParticipantDescriptorFilter filter,String[] affectedNatures,SharableParticipants shared){\n  RefactoringParticipant[] participants=fgMoveExtensions.getParticipants(status,processor,element,arguments,filter,affectedNatures,shared);\n  MoveParticipant[] result=new MoveParticipant[participants.length];\n  System.arraycopy(participants,0,result,0,participants.length);\n  return result;\n}\n", "docstring": "loads the move participants for the given element .", "partition": "test"}
{"idx": "1959", "code": "public void removeAllIms(){\n  ims.clear();\n}\n", "docstring": "removes all im \"'\" s from this user", "partition": "test"}
{"idx": "2234", "code": "private Segment createDiskSegment(SegmentDescriptor descriptor){\n  File segmentFile=SegmentFile.createSegmentFile(name,storage.directory(),descriptor.id(),descriptor.version());\n  Buffer buffer=FileBuffer.allocate(segmentFile,Math.min(DEFAULT_BUFFER_SIZE,descriptor.maxSegmentSize()),Integer.MAX_VALUE);\n  descriptor.copyTo(buffer);\n  Segment segment=new Segment(new SegmentFile(segmentFile),buffer.slice(),descriptor,createIndex(descriptor),new OffsetPredicate(),serializer.clone(),this);\n  LOGGER.debug(\"Created segment: {}\",segment);\n  return segment;\n}\n", "docstring": "creates a new segment .", "partition": "test"}
{"idx": "2750", "code": "public void output(List list,Writer out) throws IOException {\n  printContentRange(out,list,0,list.size(),0,createNamespaceStack());\n  out.flush();\n}\n", "docstring": "this will handle printing out a list of nodes . this can be useful for printing the content of an element that contains html , like \" & lt ; description & gt ; jdom is & lt ; b & gt ; fun & gt ; ! & lt ; / description & gt ; \" .", "partition": "test"}
{"idx": "2559", "code": "private static void assertChangeEvents(Collection<PortChangeEvent> earlyEvents,Collection<PortChangeEvent> lateEvents,Collection<PortChangeEvent> anytimeEvents,Collection<PortChangeEvent> actualEvents){\n  String inputDesc=String.format(\"earlyEvents=%s, lateEvents=%s, \" + \"anytimeEvents=%s, actualEvents=%s\",earlyEvents,lateEvents,anytimeEvents,actualEvents);\n  Collection<PortChangeEvent> early=new ArrayList<PortChangeEvent>(earlyEvents);\n  Collection<PortChangeEvent> late=new ArrayList<PortChangeEvent>(lateEvents);\n  Collection<PortChangeEvent> any=new ArrayList<PortChangeEvent>(anytimeEvents);\n  for (  PortChangeEvent ev : early) {\n    assertFalse(\"Test setup error. Early and late overlap\",late.contains(ev));\n    assertFalse(\"Test setup error. Early and anytime overlap\",any.contains(ev));\n  }\n  for (  PortChangeEvent ev : late) {\n    assertFalse(\"Test setup error. Late and early overlap\",early.contains(ev));\n    assertFalse(\"Test setup error. Late and any overlap\",any.contains(ev));\n  }\n  for (  PortChangeEvent ev : any) {\n    assertFalse(\"Test setup error. Anytime and early overlap\",early.contains(ev));\n    assertFalse(\"Test setup error. Anytime and late overlap\",late.contains(ev));\n  }\n  for (  PortChangeEvent a : actualEvents) {\n    if (early.remove(a)) {\n      continue;\n    }\n    if (any.remove(a)) {\n      continue;\n    }\n    if (late.remove(a)) {\n      if (!early.isEmpty()) {\n        fail(a + \" is in late list, but haven\\'t seen all required \" + \"early events. \"+ inputDesc);\n      }\n else {\n        continue;\n      }\n    }\n    fail(a + \" was not expected. \" + inputDesc);\n  }\n  if (!early.isEmpty())   fail(\"Elements left in early: \" + early + \". \"+ inputDesc);\n  if (!late.isEmpty())   fail(\"Elements left in late: \" + late + \". \"+ inputDesc);\n  if (!any.isEmpty())   fail(\"Elements left in any: \" + any + \". \"+ inputDesc);\n}\n", "docstring": "assert that the expected portchangeevents have been recevied , asserting the expected ordering . all events in earlyevents have to appear in actualevents before any event in lateevent appears . events in anytimeevents can appear at any given time . earlyevents , lateevents , and anytimeevents must be mutually exclusive ( their intersection must be none ) and their union must contain all elements from actualevents", "partition": "test"}
{"idx": "3059", "code": "@Override protected synchronized void write(long offset,byte[] b) throws IOException {\n  if (byteBuffer != null) {\n    byteBuffer.position((int)offset);\n    byteBuffer.put(b);\n  }\n else {\n    throw new IOException(\"Write failed, file \" + getPath() + \" not mapped for I/O\");\n  }\n}\n", "docstring": "writes bytes to the underlying rrd file on the disk", "partition": "test"}
{"idx": "4072", "code": "public String text(){\n  StringBuilder sb=new StringBuilder();\n  for (  Node node : nodes) {\n    sb.append(node.getTextContent());\n  }\n  return sb.toString();\n}\n", "docstring": "gets the combined text contents of each element in the set of matched elements , including their descendants . text is html decoded for text nodes .", "partition": "test"}
{"idx": "2213", "code": "public void stop(){\n  setLedOn(false);\n  if (null != blinkFuture) {\n    blinkFuture.cancel(true);\n  }\n  if (null != blinkService) {\n    blinkService.shutdownNow();\n  }\n}\n", "docstring": "calling this method will stop all threads . this is needed when using javafx on mobile devices when the device goes to sleep mode .", "partition": "test"}
{"idx": "640", "code": "boolean writeData() throws IOException {\n  int tosend;\n  int sent;\n  byte[] block=new byte[kBlockSize];\n  do {\n    tosend=Math.min(sendStreamSize - totalSent,block.length);\n    System.arraycopy(sendData,totalSent,block,0,tosend);\n    if (tosend > 0) {\n      sent=localSend(block,tosend);\n      updateLocalClock();\n      if (sent != -1) {\n        totalSent+=sent;\n      }\n else {\n        logger.log(Level.FINE,\"Flow Controlled\");\n      }\n    }\n else {\n      sent=tosend=0;\n    }\n  }\n while (sent > 0);\n  if (logger.isLoggable(Level.FINER)) {\n    logger.log(Level.FINER,\"Sent: \" + totalSent + \" remaining: \"+ (sendStreamSize - totalSent));\n  }\n  return tosend == 0;\n}\n", "docstring": "writes the data until there \"'\" s space available", "partition": "test"}
{"idx": "3277", "code": "@Override public final void writeBoolean(boolean v) throws IOException {\n  dis.writeBoolean(v);\n}\n", "docstring": "write a booleans as one byte .", "partition": "test"}
{"idx": "1605", "code": "public int loadSigned16(int addr){\n  return loadSigned16(addr,AccessSource.CODE);\n}\n", "docstring": "perform a 16bit load where the sign extended result fills the return value", "partition": "test"}
{"idx": "1039", "code": "public List<ColourChange> sampleConditionalMigrationEvents2(int parentColour,double parentHeight,int childColour,double childHeight,double[] m){\n  List<ColourChange> colourChanges=new ArrayList<ColourChange>();\n  if (parentHeight < childHeight) {\n    throw new IllegalArgumentException(\"sampleConditionalMigrationEvents: parentHeight=\" + parentHeight + \" childHeight=\"+ childHeight+ \", not good.\");\n  }\n  try {\n    int currentColour=parentColour;\n    double currentHeight=parentHeight;\n    while (true) {\n      ColourChange nextEvent=randomConditionalMigrationEvent(currentColour,currentHeight,childColour,childHeight,m);\n      currentHeight=nextEvent.getTime();\n      currentColour=nextEvent.getColourAbove();\n      colourChanges.add(nextEvent);\n    }\n  }\n catch (  NoEventException nee) {\n  }\n  reverseColourChangeList(colourChanges,parentColour);\n  return colourChanges;\n}\n", "docstring": "samples migration events on a two - coloured branch , conditional on colours at both ends migration process is forwards in ( natural ) time , so we are going down the tree . returns a list of events , ordered forward in time ( i . e . colour refers to branch * below * the event ) *", "partition": "test"}
{"idx": "3678", "code": "private ImageElement(int AD_PrintFormatItem_ID){\n  loadAttachment(AD_PrintFormatItem_ID);\n}\n", "docstring": "create image from attachment", "partition": "test"}
{"idx": "1378", "code": "private void fitSizeOfScrolledContent(){\n  Point p=scrollComposite.getSize();\n  main.setSize(main.computeSize(p.x,SWT.DEFAULT));\n}\n", "docstring": "fits the width of the main composite to the same width scrolled composite was given .", "partition": "test"}
{"idx": "4112", "code": "public TimeSeriesMetricDeltaSet(Stream<Entry<Tags,MetricValue>> td){\n  values_=Any2.right(td.collect(Collectors.toMap(null,null,null,null)));\n}\n", "docstring": "create a metricdelta set for tagged metrics and initialize it with the given collection .", "partition": "test"}
{"idx": "1917", "code": "public void proposeTree() throws OperatorFailedException {\n  NodeRef i;\n  double oldMinAge, newMinAge, newRange, oldRange, newAge, q;\n  final int nodeCount=tree.getNodeCount();\n  do {\n    i=tree.getNode(MathUtils.nextInt(nodeCount));\n  }\n while (tree.getRoot() == i);\n  final NodeRef iP=tree.getParent(i);\n  NodeRef j=tree.getNode(MathUtils.nextInt(nodeCount));\n  NodeRef k=tree.getParent(j);\n  while ((k != null && tree.getNodeHeight(k) <= tree.getNodeHeight(i)) || (i == j)) {\n    j=tree.getNode(MathUtils.nextInt(nodeCount));\n    k=tree.getParent(j);\n  }\n  if (j == tree.getRoot() || iP == tree.getRoot()) {\n    throw new OperatorFailedException(\"Root changes not allowed!\");\n  }\n  if (k == iP || j == iP || k == i)   throw new OperatorFailedException(\"move failed\");\n  final NodeRef CiP=getOtherChild(tree,iP,i);\n  NodeRef PiP=tree.getParent(iP);\n  newMinAge=Math.max(tree.getNodeHeight(i),tree.getNodeHeight(j));\n  newRange=tree.getNodeHeight(k) - newMinAge;\n  newAge=newMinAge + (MathUtils.nextDouble() * newRange);\n  oldMinAge=Math.max(tree.getNodeHeight(i),tree.getNodeHeight(CiP));\n  oldRange=tree.getNodeHeight(PiP) - oldMinAge;\n  q=newRange / Math.abs(oldRange);\n  tree.beginTreeEdit();\n  if (j == tree.getRoot()) {\n    tree.removeChild(iP,CiP);\n    tree.removeChild(PiP,iP);\n    tree.addChild(iP,j);\n    tree.addChild(PiP,CiP);\n    tree.setRoot(iP);\n  }\n else   if (iP == tree.getRoot()) {\n    tree.removeChild(k,j);\n    tree.removeChild(iP,CiP);\n    tree.addChild(iP,j);\n    tree.addChild(k,iP);\n    tree.setRoot(CiP);\n  }\n else {\n    tree.removeChild(k,j);\n    tree.removeChild(iP,CiP);\n    tree.removeChild(PiP,iP);\n    tree.addChild(iP,j);\n    tree.addChild(k,iP);\n    tree.addChild(PiP,CiP);\n  }\n  tree.setNodeHeight(iP,newAge);\n  tree.endTreeEdit();\n  logq=Math.log(q);\n}\n", "docstring": "warning : assumes strictly bifurcating tree .", "partition": "test"}
{"idx": "17", "code": "public static void f(String msg,Object... args){\n  if (!allowWtf)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n", "docstring": "send a fatal error log message", "partition": "test"}
{"idx": "1637", "code": "private void changeValue(AbstractStorageLabel<Object> label,Object newValue){\n  if (!Objects.equals(label.getValue(),newValue)) {\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.preLabelValueChange(label);\n      }\n    }\n    label.setValue(newValue);\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.postLabelValueChange(label);\n      }\n    }\n  }\n}\n", "docstring": "reforms the value change and informs the listeners .", "partition": "test"}
{"idx": "535", "code": "private boolean zzRefill() throws java.io.IOException {\n  if (zzStartRead > 0) {\n    System.arraycopy(zzBuffer,zzStartRead,zzBuffer,0,zzEndRead - zzStartRead);\n    zzEndRead-=zzStartRead;\n    zzCurrentPos-=zzStartRead;\n    zzMarkedPos-=zzStartRead;\n    zzPushbackPos-=zzStartRead;\n    zzStartRead=0;\n  }\n  if (zzCurrentPos >= zzBuffer.length) {\n    final char newBuffer[]=new char[zzCurrentPos * 2];\n    System.arraycopy(zzBuffer,0,newBuffer,0,zzBuffer.length);\n    zzBuffer=newBuffer;\n  }\n  final int numRead=zzReader.read(zzBuffer,zzEndRead,zzBuffer.length - zzEndRead);\n  if (numRead < 0) {\n    return true;\n  }\n else {\n    zzEndRead+=numRead;\n    return false;\n  }\n}\n", "docstring": "refills the input buffer .", "partition": "test"}
{"idx": "604", "code": "public boolean revisionContainsTemplateName(int revId,String templateName) throws WikiApiException {\n  return revisionContainsTemplateNames(revId,Arrays.asList(new String[]{templateName}));\n}\n", "docstring": "determines whether a given revision contains a given template name", "partition": "test"}
{"idx": "1481", "code": "private FastConcurrentSkipListMap.Node<K,V> loNode(){\n  if (lo == null)   return m.findFirst();\n else   if (loInclusive)   return m.findNear(lo,m.GT | m.EQ);\n else   return m.findNear(lo,m.GT);\n}\n", "docstring": "returns lowest node . this node might not be in range , so most usages need to check bounds", "partition": "test"}
{"idx": "597", "code": "static WindowsFileAttributes fromFindData(long address){\n  int fileAttrs=unsafe.getInt(address + OFFSETOF_FIND_DATA_ATTRIBUTES);\n  long creationTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_CREATETIME);\n  long lastAccessTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTACCESSTIME);\n  long lastWriteTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTWRITETIME);\n  long size=((long)(unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZEHIGH)) << 32) + (unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZELOW) & 0xFFFFFFFFL);\n  int reparseTag=isReparsePoint(fileAttrs) ? unsafe.getInt(address + OFFSETOF_FIND_DATA_RESERVED0) : 0;\n  return new WindowsFileAttributes(fileAttrs,creationTime,lastAccessTime,lastWriteTime,size,reparseTag,0,0,0);\n}\n", "docstring": "create a windowsfileattributes from a win32_find_data structure", "partition": "test"}
{"idx": "2790", "code": "public void load(Element element,Object o){\n  log.error(\"load(Element, Object) called unexpectedly\");\n}\n", "docstring": "update static data from xml file", "partition": "test"}
{"idx": "533", "code": "protected boolean canDeleteConsistencyGroup(final BlockConsistencyGroup consistencyGroup){\n  return (!consistencyGroup.getInactive() && !consistencyGroup.created());\n}\n", "docstring": "check to see if the consistency group is active and not created . in this case we can delete the consistency group . otherwise we should not delete the consistency group .", "partition": "test"}
{"idx": "2998", "code": "@Override public Point translateJava2DToScreen(Point2D java2DPoint){\n  Insets insets=getInsets();\n  int x=(int)(java2DPoint.getX() * this.scaleX + insets.left);\n  int y=(int)(java2DPoint.getY() * this.scaleY + insets.top);\n  return new Point(x,y);\n}\n", "docstring": "translates a java2d point on the chart to a screen location .", "partition": "test"}
{"idx": "135", "code": "private float calculateScrambleImageHeightMultiplier(float multiplier){\nswitch (currentPuzzle) {\ncase PuzzleUtils.TYPE_777:\ncase PuzzleUtils.TYPE_666:\ncase PuzzleUtils.TYPE_555:\ncase PuzzleUtils.TYPE_222:\ncase PuzzleUtils.TYPE_444:\ncase PuzzleUtils.TYPE_333:\n    return (multiplier / 4) * 3;\ncase PuzzleUtils.TYPE_CLOCK:\n  return multiplier / 2;\ncase PuzzleUtils.TYPE_MEGA:\nreturn (multiplier / 2);\ncase PuzzleUtils.TYPE_PYRA:\nreturn (float)(multiplier / Math.sqrt(1.25));\ncase PuzzleUtils.TYPE_SKEWB:\nreturn (multiplier / 4) * 3;\ncase PuzzleUtils.TYPE_SQUARE1:\nreturn multiplier;\n}\nreturn multiplier;\n}\n", "docstring": "calculates scramble image height multiplier to respect aspect ratio", "partition": "test"}
{"idx": "3457", "code": "public static DataSet readContinuous(File file,char delimiter) throws IOException {\n  return readInContinuousData(file,delimiter,Collections.singleton(\"MULT\"));\n}\n", "docstring": "read in continuous dataset .", "partition": "test"}
{"idx": "1024", "code": "public ControlFlowGraph run(CompilationUnitTree root,ProcessingEnvironment env,MethodTree tree,ClassTree classTree){\n  UnderlyingAST underlyingAST=new CFGMethod(tree,classTree);\n  return run(root,env,underlyingAST);\n}\n", "docstring": "build the control flow graph of a method .", "partition": "test"}
{"idx": "1568", "code": "public void testFloatValueNeg(){\n  String a=\"-1238096483923847.6356789029578E+21\";\n  BigDecimal aNumber=new BigDecimal(a);\n  float result=-1.2380965E36F;\n  assertTrue(\"incorrect value\",aNumber.floatValue() == result);\n}\n", "docstring": "float value of a negative bigdecimal", "partition": "test"}
{"idx": "158", "code": "public void addGetters(int assignedPropertyNumber,String propertyName){\n  for (  EventType type : knownTypes) {\n    EventPropertyGetter getter=type.getGetter(propertyName);\n    VariantPropertyGetterRow row=allGetters.get(type);\n    if (row == null) {\nsynchronized (this) {\n        row=new VariantPropertyGetterRow(type,new EventPropertyGetter[assignedPropertyNumber + 1]);\n        allGetters.put(type,row);\n      }\n    }\n    row.addGetter(assignedPropertyNumber,getter);\n  }\n  properties.add(propertyName);\n}\n", "docstring": "adds the getters for a property that is identified by a property number which indexes into array of getters per type .", "partition": "test"}
{"idx": "2227", "code": "private void adjustBackingFileLength(byte[] buffer,long index) throws IOException {\n  if (buffer == null || buffer.length == 0) {\n    throw new IOException(\"Buffer null or empty!\");\n  }\n  long newsize=fHeader.headerSize() + (index * CHUNK_ENC_SIZE) + CHUNK_IV_SIZE+ buffer.length+ CHUNK_TLEN;\n  if (newsize > realLength()) {\n    backingRandomAccessFile.setLength(newsize);\n  }\n}\n", "docstring": "helper methods which adjusts the actual length of the backing file for caching . as with caching , data is only actually written to disk , if a chunk has been filled completely and a new chunk is being accessed , the file size has to be extended in advance in order for methods like seek / skipbytes / . . . to still be able to work .", "partition": "test"}
{"idx": "3495", "code": "public String jsTypeName(TypeRef typeRef){\nswitch (typeRef.getKind()) {\ncase TYPE_MESSAGE:\n    return \"Object\";\ncase TYPE_ENUM:\n  return \"number\";\ndefault :\n{\n  String name=PRIMITIVE_TYPE_NAMES.get(typeRef.getKind());\n  if (!Strings.isNullOrEmpty(name)) {\n    return name;\n  }\n  throw new IllegalArgumentException(\"unknown type kind: \" + typeRef.getKind());\n}\n}\n}\n", "docstring": "returns the name of js type for the given typeref .", "partition": "test"}
{"idx": "977", "code": "public void clear(){\n  infoQueue.clear();\n  while (!dataQueue.isEmpty()) {\n    allocator.release(dataQueue.remove());\n  }\n  totalBytesDropped=0;\n  totalBytesWritten=0;\n  lastAllocation=null;\n  lastAllocationOffset=allocationLength;\n}\n", "docstring": "clears the buffer , returning all allocations to the allocator .", "partition": "test"}
{"idx": "336", "code": "private static double hackyAdjuster(double f){\n  double tmp=Math.sqrt(1.0 - f);\n  return (f <= 0.5) ? tmp : tmp + (0.01 * (f - 0.5));\n}\n", "docstring": "this hackyadjuster is tightly coupled with the width of the confidence interval normally specified with number of standard deviations . to simplify this interface the number of standard deviations has been fixed to 2 . 0 , which corresponds to a confidence interval of 95 % .", "partition": "test"}
{"idx": "1898", "code": "private void drawHook(Canvas canvas){\n  Path hookPath=new Path();\n  double sweepAngle=Math.PI / 180 * 180;\n  float y=(float)Math.sin(sweepAngle) * (getBigCircleRadius()) + rectF.height() / 2;\n  float x=(float)Math.cos(sweepAngle) * (getBigCircleRadius()) + rectF.width() / 2;\n  float i=getBigCircleRadius() / 2;\n  hookPath.addRoundRect(new RectF(i + i / 2,i + i / 2,i + i / 2 + 6,i + i + i / 2),3f,3f,Path.Direction.CCW);\n  hookPath.addRoundRect(new RectF(i + i / 2,(i + i + i / 2) - 3f,i + i / 2 + i + i,i + i + i / 2 + 3f),3f,3f,Path.Direction.CCW);\n  Matrix matrix=new Matrix();\n  matrix.reset();\n  int restoreCount=canvas.getSaveCount();\n  hookPath.close();\n  canvas.rotate(-45,rectF.centerX(),rectF.centerY());\n  canvas.drawPath(hookPath,mHookPaint);\n  canvas.restoreToCount(restoreCount);\n}\n", "docstring": "there is some bug and it \"'\" s not perfect . so we should improve this path for our projection", "partition": "test"}
{"idx": "2572", "code": "@NotNull protected VirtualFile[] collectAffectedFiles(@NotNull Project project,@NotNull VirtualFile[] files){\n  List<VirtualFile> affectedFiles=new ArrayList<VirtualFile>(files.length);\n  ProjectLevelVcsManager projectLevelVcsManager=ProjectLevelVcsManager.getInstance(project);\n  for (  VirtualFile file : files) {\n    if (!file.isDirectory() && projectLevelVcsManager.getVcsFor(file) instanceof GitVcs) {\n      affectedFiles.add(file);\n    }\n else     if (file.isDirectory() && isRecursive()) {\n      addChildren(project,affectedFiles,file);\n    }\n  }\n  return VfsUtilCore.toVirtualFileArray(affectedFiles);\n}\n", "docstring": "given a list of action - target files , returns all the files that should be subject to the action does not keep directories , but recursively adds directory contents", "partition": "test"}
{"idx": "146", "code": "public List<String> classify(List<List<Feature>> features) throws CleartkProcessingException {\n  String[][] featureStringArray=toStrings(features);\n  Pipe pipe=transducer.getInputPipe();\n  Instance instance=new Instance(featureStringArray,null,null,null);\n  instance=pipe.instanceFrom(instance);\n  Sequence<?> data=(Sequence<?>)instance.getData();\n  Sequence<?> untypedSequence=transducer.transduce(data);\n  Sequence<String> sequence=ReflectionUtil.uncheckedCast(untypedSequence);\n  List<String> returnValues=new ArrayList<String>();\n  for (int i=0; i < sequence.size(); i++) {\n    String encodedOutcome=sequence.get(i);\n    returnValues.add(outcomeEncoder.decode(encodedOutcome));\n  }\n  return returnValues;\n}\n", "docstring": "this method classifies several instances at once", "partition": "test"}
{"idx": "3072", "code": "public void clear(){\n  Set<Sensor> oldSelection=new HashSet<Sensor>(selection);\n  selection.clear();\n  if (!oldSelection.isEmpty()) {\n    fireSelectionChanged(oldSelection,selection);\n  }\n}\n", "docstring": "clear this sensor selection model .", "partition": "test"}
{"idx": "1588", "code": "public int add(T dl,int row){\n  _list.add(row,dl);\n  fireTableRowsInserted(row,row);\n  return row;\n}\n", "docstring": "adds a dataline to the list at a row . all forms of add ( . . ) eventually end up here . extending classes should override this if they want to maintain a hashmap of any type for speedier access .", "partition": "test"}
{"idx": "2119", "code": "public static long calculateElapsedGC(){\n  long timeMillis=0;\n  for (  GarbageCollectorMXBean gcbean : gcbeans) {\n    timeMillis+=gcbean.getCollectionTime();\n  }\n  return timeMillis;\n}\n", "docstring": "ask each gc bean for its elapsed collection time", "partition": "test"}
{"idx": "3048", "code": "static TokenStream wrap(String fieldName,Analyzer indexAnalyzer,String content,char splitChar) throws IOException {\n  if (indexAnalyzer.getOffsetGap(fieldName) != 1) {\n    throw new IllegalArgumentException(\"offset gap of the provided analyzer should be 1 (field \" + fieldName + \")\");\n  }\n  int splitCharIdx=content.indexOf(splitChar);\n  if (splitCharIdx == -1) {\n    return indexAnalyzer.tokenStream(fieldName,content);\n  }\n  TokenStream subTokenStream=indexAnalyzer.tokenStream(fieldName,content.substring(0,splitCharIdx));\n  return new MultiValueTokenStream(subTokenStream,fieldName,indexAnalyzer,content,splitChar,splitCharIdx);\n}\n", "docstring": "note : the caller must remember to close the tokenstream eventually .", "partition": "test"}
{"idx": "335", "code": "public void testNegNegFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=-1;\n  byte rBytes[]={-1,127,-10,-57,-101,1,2,2,2,-96,-16,8,-40,-59,68,-88,-88,16,73};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.and(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,result.signum());\n}\n", "docstring": "and for two negative numbers ; the first is shorter", "partition": "test"}
{"idx": "2828", "code": "@Override public String findLibrary(String name){\n  String systemName=System.mapLibraryName(name);\n  ArrayList<Loader> loaders=getLoaders();\n  for (int i=0; i < loaders.size(); i++) {\n    Loader loader=loaders.get(i);\n    Path path=loader.getPath(systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n    path=loader.getPath(\"native/\" + systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n  }\n  for (int i=0; i < _nativePath.size(); i++) {\n    Path path=_nativePath.get(i);\n    if (path.canRead())     return path.getNativePath();\n  }\n  return super.findLibrary(name);\n}\n", "docstring": "returns the full library path for the name .", "partition": "test"}
{"idx": "1885", "code": "public boolean longLabel(){\n  return fState.longLabel;\n}\n", "docstring": "returns true if long labels are uses in the indicator display .", "partition": "test"}
{"idx": "3027", "code": "public boolean nextTile() throws ModelControlException {\n  boolean movedToRow=super.nextTile();\n  if (movedToRow) {\n    curTile=getTileIndex();\n    setDisplayFieldValue(TXT_PARENT_INDEX,parentIdx);\n    setDisplayFieldValue(TXT_CHOICE,choices[curTile]);\n    setDisplayFieldValue(TXT_INDEX,Integer.toString(curTile));\n  }\n  return movedToRow;\n}\n", "docstring": "moves the current tile position to the next available tile .", "partition": "test"}
{"idx": "720", "code": "private Integer zGetWeekNumberForASevenDayRange(LocalDate firstDateInRange,WeekFields weekFieldRules,boolean requireUnanimousWeekNumber){\n  ArrayList<Integer> weekNumbersList=new ArrayList<Integer>();\n  for (int daysIntoTheFuture=0; daysIntoTheFuture <= 6; ++daysIntoTheFuture) {\n    LocalDate currentDateInRange;\n    try {\n      currentDateInRange=firstDateInRange.plusDays(daysIntoTheFuture);\n      int currentWeekNumber=currentDateInRange.get(weekFieldRules.weekOfWeekBasedYear());\n      weekNumbersList.add(currentWeekNumber);\n    }\n catch (    Exception ex) {\n      return 1;\n    }\n  }\n  boolean isUnanimous=(InternalUtilities.areObjectsEqual(weekNumbersList.get(0),weekNumbersList.get(6)));\n  if (isUnanimous) {\n    return weekNumbersList.get(0);\n  }\n  if (requireUnanimousWeekNumber) {\n    return null;\n  }\n  int mostCommonWeekNumber=InternalUtilities.getMostCommonElementInList(weekNumbersList);\n  return mostCommonWeekNumber;\n}\n", "docstring": "zgetweeknumberforasevendayrange , this returns a week number for the specified seven day range , according to the supplied weekfieldrules . if all seven days fall on the same week number , then that week number will be returned . if \" requireunanimousweeknumber \" is true and the supplied range falls across two week numbers , then null is returned . if \" requireunanimousweeknumber \" is false and the supplied range falls across two week numbers , then the \" majority rules \" system is used for determining the returned week number . the majority rules system means that the most common week number in the seven day range will be returned . for example : if days 1 and 2 are in week 30 , and days 3 through 7 are in week 31 , then the week number 31 will be returned . there is no possibility of a \" tie \" week number , because the number of days in the range is seven ( an odd number ) . additionally , the returned week number will always be the correct week number for a minimum of four days out of the seven day range . to make sure that all seven days in the range - can - fall on the same week number , the caller of the function would need to supply a seven day range that starts on the same \" first day of the week \" that is used by the supplied weekfieldrules . i don \"'\" t know if there are any special cases where these matching parameters are supplied , but the result is still not a unanimous week number . the week fields object can be created from a specific locale , ( including locale . iso if desired ) , or the week fields can be configured to match any desired week field rules . examples of creating week field instances : weekfields weekfields = weekfields . of ( locale locale ) ; weekfields weekfields = weekfields . of ( dayofweek firstdayofweek , int minimaldaysinfirstweek ) ;", "partition": "test"}
{"idx": "3357", "code": "@VisibleForTesting protected void startExecutor(final int container){\n  LOG.info(\"Starting a new executor for container: \" + container);\n  final Process containerExecutor=startExecutorProcess(container);\n  processToContainer.put(containerExecutor,container);\n  LOG.info(\"Started the executor for container: \" + container);\n  startExecutorMonitor(container,containerExecutor);\n}\n", "docstring": "start the executor for the given container", "partition": "test"}
{"idx": "521", "code": "public RemoteServiceDescriptor(String baseUrl,HttpJsonRequestFactory requestFactory) throws IllegalArgumentException {\n  this.baseUrl=baseUrl;\n  this.requestFactory=requestFactory;\n  try {\n    final URL baseUrlURL=new URL(baseUrl);\n    final String protocol=baseUrlURL.getProtocol();\n    if (!(protocol.equals(\"http\") || protocol.equals(\"https\"))) {\n      throw new IllegalArgumentException(String.format(\"Invalid URL: %s\",baseUrl));\n    }\n  }\n catch (  MalformedURLException e) {\n    throw new IllegalArgumentException(String.format(\"Invalid URL: %s\",baseUrl));\n  }\n}\n", "docstring": "creates new descriptor of remote restful service .", "partition": "test"}
{"idx": "1250", "code": "@Override public void doctypeDecl(String rootElement,String publicId,String systemId,Augmentations augs) throws XNIException {\n  fInDTD=true;\n  try {\n    if (fLexicalHandler != null) {\n      fLexicalHandler.startDTD(rootElement,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n  if (fDeclHandler != null) {\n    fDeclaredAttrs=new SymbolHash();\n  }\n}\n", "docstring": "notifies of the presence of the doctype line in the document .", "partition": "test"}
{"idx": "3019", "code": "protected void sleep(int sleepMillis,int sleepNanos) throws InterruptedException {\n  Thread.sleep(sleepMillis,sleepNanos);\n}\n", "docstring": "sub classes ( tests basically ) can use this to override how the sleep is being done", "partition": "test"}
{"idx": "314", "code": "public int retrieveRowCount(String tableName) throws SQLException {\n  ResultSet rs=null;\n  int rowCount=-1;\n  try {\n    rs=statement.executeQuery(\"SELECT COUNT(*) FROM \" + tableName);\n    rs.next();\n    rowCount=rs.getInt(1);\n  }\n  finally {\n    if (rs != null) {\n      rs.close();\n    }\n  }\n  return rowCount;\n}\n", "docstring": "does a count on a given table .", "partition": "test"}
{"idx": "2018", "code": "public static void flush(){\n  clearBuffer();\n  try {\n    out.flush();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "flush standard output , padding 0s if number of bits written so far is not a multiple of 8 .", "partition": "test"}
{"idx": "1154", "code": "public static Request newUploadVideoRequest(Session session,File file,Callback callback) throws FileNotFoundException {\n  ParcelFileDescriptor descriptor=ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);\n  Bundle parameters=new Bundle(1);\n  parameters.putParcelable(file.getName(),descriptor);\n  return new Request(session,MY_VIDEOS,parameters,HttpMethod.POST,callback);\n}\n", "docstring": "creates a new request configured to upload a photo to the user \"'\" s default photo album . the photo will be read from the specified file descriptor .", "partition": "test"}
{"idx": "3865", "code": "public static <T>Stream<T> concat(Stream<? extends T> a,Stream<? extends T> b){\n  Objects.requireNonNull(a);\n  Objects.requireNonNull(b);\n  @SuppressWarnings(\"unchecked\") Spliterator<T> split=new Streams.ConcatSpliterator.OfRef<>((Spliterator<T>)a.spliterator(),(Spliterator<T>)b.spliterator());\n  Stream<T> stream=StreamSupport.stream(split,a.isParallel() || b.isParallel());\n  return stream.onClose(Streams.composedClose(a,b));\n}\n", "docstring": "creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream . the resulting stream is ordered if both of the input streams are ordered , and parallel if either of the input streams is parallel . when the resulting stream is closed , the close handlers for both input streams are invoked .", "partition": "test"}
{"idx": "3610", "code": "public static Uri addMessageToUri(ContentResolver resolver,Uri uri,String address,String body,String subject,Long date,boolean read,boolean deliveryReport,long threadId){\n  ContentValues values=new ContentValues(7);\n  values.put(Sms.ADDRESS,address);\n  if (date != null) {\n    values.put(Sms.DATE,date);\n  }\n  values.put(Sms.READ,read ? Integer.valueOf(1) : Integer.valueOf(0));\n  values.put(Sms.SUBJECT,subject);\n  values.put(Sms.BODY,body);\n  if (deliveryReport) {\n    values.put(Sms.STATUS,Sms.STATUS_PENDING);\n  }\n  if (threadId != -1L) {\n    values.put(Sms.THREAD_ID,threadId);\n  }\n  return resolver.insert(uri,values);\n}\n", "docstring": "add an sms to the given uri with the specified thread id .", "partition": "test"}
{"idx": "2860", "code": "public VNXeCommandJob modifyLunAsync(LunModifyParam param,String resourceId){\n  StringBuilder urlBld=new StringBuilder(URL_RESOURCE);\n  urlBld.append(resourceId);\n  urlBld.append(URL_LUN_MODIFY_ACTION);\n  _url=urlBld.toString();\n  return postRequestAsync(param);\n}\n", "docstring": "modify lun ( export / unexport / expand etc ) in async mode", "partition": "test"}
{"idx": "398", "code": "public static GenericObjectEditorDialog createDialog(Container parent){\n  return createDialog(parent,null);\n}\n", "docstring": "creates a modal dialog for the parent .", "partition": "test"}
{"idx": "2030", "code": "public long next(){\n  long result=-1l;\n  if (cache < 0L && bufferElements > 0) {\n    result=getNextFromBuffer();\n    bufferElements--;\n  }\n else {\n    result=cache;\n    cache=-1L;\n  }\n  if (!cs.isEmpty()) {\n    long first=cs.first();\n    if (result > first || result == -1L) {\n      cs.remove(first);\n      cache=result;\n      result=first;\n    }\n  }\n  if (result == -1L) {\n    throw new NoSuchElementException();\n  }\n  Assert.check(previous < result,EC.GENERAL);\n  previous=result;\n  readElements++;\n  return result;\n}\n", "docstring": "returns the next element in the iteration .", "partition": "test"}
{"idx": "1014", "code": "public String convertSWFToHTML(InputStream in) throws Exception {\n  StringWriter out1=new StringWriter();\n  output=new PrintWriter(out1);\n  TagParser parser=new TagParser(this);\n  SWFReader reader=new SWFReader(parser,in);\n  reader.readFile();\n  in.close();\n  sizeCount=reader.size;\n  final String ret=\"<html>\" + (headerstr.isEmpty() ? \"<body>\" : \"<header>\" + headerstr + \"</header><body>\") + out1.toString()+ \"</body></html>\";\n  return ret;\n}\n", "docstring": "parses swf input and extracts text and wrap it as html", "partition": "test"}
{"idx": "741", "code": "private void printAnnotationFromEditor(final WorkflowAnnotation anno,final Graphics2D g2){\n  Graphics2D gPr=(Graphics2D)g2.create();\n  Rectangle2D loc=anno.getLocation();\n  gPr.translate(loc.getX(),loc.getY());\n  gPr.setClip(0,0,(int)loc.getWidth(),(int)loc.getHeight());\n  Dimension size=new Dimension((int)loc.getWidth(),(int)loc.getHeight());\n  pane.setSize(size);\n  pane.setText(AnnotationDrawUtils.createStyledCommentString(anno));\n  pane.setCaretPosition(0);\n  pane.paint(gPr);\n  gPr.dispose();\n}\n", "docstring": "bypass the cache and the speedy image drawing and directly paint the jeditorpane to the context . required for printing in svg format which would turn out pixelated if it were drawn as an image .", "partition": "test"}
{"idx": "3671", "code": "public ZookeeperEmbedded(int port){\n  this.port=port;\n  this.logDir=new File(System.getProperty(\"java.io.tmpdir\"),\"zk/logs/zookeeper-test-\" + port);\n}\n", "docstring": "create zookeeper testing server .", "partition": "test"}
{"idx": "2092", "code": "public Matcher next() throws IOException {\n  readahead();\n  if (matches == null) {\n    throw new NoSuchElementException();\n  }\n  Matcher matcher=matches.next();\n  if (discard) {\n    Pattern pattern=matcher.pattern();\n    for (int n=0; n < patterns.length; n++) {\n      if (patterns[n] == pattern) {\n        patterns[n]=null;\n        break;\n      }\n    }\n  }\n  return matcher;\n}\n", "docstring": "returns the next match from the character stream . matches are returned in the order they are encountered in the character stream , then by the order they are expressed in the supplied patterns collection .", "partition": "test"}
{"idx": "4034", "code": "public static byte[] readBytesFromByteBuffer(ByteBuffer byteBuffer){\n  byte[] buffer=new byte[byteBuffer.remaining()];\n  byteBuffer.get(buffer);\n  return buffer;\n}\n", "docstring": "reads the remaining bytes in a bytebuffer into a byte [ ", "partition": "test"}
{"idx": "2749", "code": "public Set keySet(){\n  return totalKeySet();\n}\n", "docstring": "returns the total key set of all scopes . this method violates the map contract by returning an unmodifiable set .", "partition": "test"}
{"idx": "337", "code": "private boolean copyDocument(SearchDocument newDocument,SearchDocument document,Map<String,Set<String>> removedProperties){\n  boolean mutated=false;\n  for (  String oldFieldName : document.getPropertyNames()) {\n    newDocument.addProperty(oldFieldName);\n    List<String> oldValues=document.getProperty(oldFieldName);\n    if (oldValues != null) {\n      Set<String> objectsRemoved=(removedProperties != null) ? removedProperties.get(oldFieldName) : null;\n      for (      String oldValue : oldValues) {\n        if ((objectsRemoved != null) && (objectsRemoved.contains(oldValue))) {\n          mutated=true;\n        }\n else {\n          addProperty(oldFieldName,oldValue,newDocument);\n        }\n      }\n    }\n  }\n  return mutated;\n}\n", "docstring": "creates a copy of the old document ; updating the retrieved document instance works ok for stored properties but indexed data gets lost when doing an indexwriter . updatedocument with it .", "partition": "test"}
{"idx": "2163", "code": "public void exportSymbols(String[] exportNames,Symbol[] symbols){\n  if (exportedSymbols == null) {\n    exportedSymbols=new ArrayList();\n  }\n  for (int i=0; i < exportNames.length && i < symbols.length; i++) {\n    exportedSymbols.add(new ExportedSymbol(symbols[i],exportNames[i]));\n  }\n}\n", "docstring": "export a number of symbols with the given names so that other movies can import and use them . flash version 5 only .", "partition": "test"}
{"idx": "3601", "code": "static int firstIllegalCharacter(String source){\n  for (int i=0; i < source.length(); i++) {\n    if (isLegal(source.charAt(i)) == false) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "docstring": "utility method to find the first invalid character as per rfc 2396 section 2 . this helps us prevent creating excessive objects in the encode ( ) methods since most strings will not be encoded .", "partition": "test"}
{"idx": "1147", "code": "public GitlabGroupMember addGroupMember(GitlabGroup group,GitlabUser user,GitlabAccessLevel accessLevel) throws IOException {\n  return addGroupMember(group.getId(),user.getId(),accessLevel);\n}\n", "docstring": "add a group member .", "partition": "test"}
{"idx": "1342", "code": "public static boolean hasTaxonomyInfo(SequencesReader reader){\n  final File taxonFile=new File(reader.path(),TAXONOMY_FILE);\n  final File mappingFile=new File(reader.path(),TAXONOMY_TO_SEQUENCE_FILE);\n  if (taxonFile.exists() && mappingFile.exists()) {\n    return true;\n  }\n else   if (taxonFile.exists() || mappingFile.exists()) {\n    throw new NoTalkbackSlimException(\"Reference SDF does not contain both taxonomy and sequences lookup\");\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "returns true if the supplied reader contains taxonomy information", "partition": "test"}
{"idx": "2818", "code": "public static boolean hasBinding(Injector injector,Key<?> key){\n  Binding<?> binding=getBinding(injector,key);\n  return binding != null;\n}\n", "docstring": "returns true if a binding exists for the given key", "partition": "test"}
{"idx": "4215", "code": "protected abstract boolean validateNumber(ConversationContext context,Number input);\n", "docstring": "validates a number , for use cases where you may need the number to be within a range", "partition": "test"}
{"idx": "1642", "code": "private int convertToPanelX(double xval){\n  double temp=(xval - m_minX) / m_rangeX;\n  temp=temp * m_panelWidth;\n  return (int)temp;\n}\n", "docstring": "convert an x coordinate from the instance space to the panel space .", "partition": "test"}
{"idx": "2312", "code": "@Override public void drawRangeMarker(Graphics2D g2,XYPlot plot,ValueAxis rangeAxis,Marker marker,Rectangle2D dataArea){\n  if (marker instanceof ValueMarker) {\n    ValueMarker vm=(ValueMarker)marker;\n    double value=vm.getValue();\n    Range range=rangeAxis.getRange();\n    if (!range.contains(value)) {\n      return;\n    }\n    double v=rangeAxis.valueToJava2D(value,dataArea,plot.getRangeAxisEdge());\n    PlotOrientation orientation=plot.getOrientation();\n    Line2D line=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      line=new Line2D.Double(v,dataArea.getMinY(),v,dataArea.getMaxY());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      line=new Line2D.Double(dataArea.getMinX(),v,dataArea.getMaxX(),v);\n    }\n else {\n      throw new IllegalStateException(\"Unrecognised orientation.\");\n    }\n    final Composite originalComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    g2.setPaint(marker.getPaint());\n    g2.setStroke(marker.getStroke());\n    g2.draw(line);\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,line.getBounds2D(),marker.getLabelOffset(),LengthAdjustmentType.EXPAND,anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(originalComposite);\n  }\n else   if (marker instanceof IntervalMarker) {\n    IntervalMarker im=(IntervalMarker)marker;\n    double start=im.getStartValue();\n    double end=im.getEndValue();\n    Range range=rangeAxis.getRange();\n    if (!(range.intersects(start,end))) {\n      return;\n    }\n    double start2d=rangeAxis.valueToJava2D(start,dataArea,plot.getRangeAxisEdge());\n    double end2d=rangeAxis.valueToJava2D(end,dataArea,plot.getRangeAxisEdge());\n    double low=Math.min(start2d,end2d);\n    double high=Math.max(start2d,end2d);\n    PlotOrientation orientation=plot.getOrientation();\n    Rectangle2D rect=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      low=Math.max(low,dataArea.getMinX());\n      high=Math.min(high,dataArea.getMaxX());\n      rect=new Rectangle2D.Double(low,dataArea.getMinY(),high - low,dataArea.getHeight());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      low=Math.max(low,dataArea.getMinY());\n      high=Math.min(high,dataArea.getMaxY());\n      rect=new Rectangle2D.Double(dataArea.getMinX(),low,dataArea.getWidth(),high - low);\n    }\n    final Composite originalComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    Paint p=marker.getPaint();\n    if (p instanceof GradientPaint) {\n      GradientPaint gp=(GradientPaint)p;\n      GradientPaintTransformer t=im.getGradientPaintTransformer();\n      if (t != null) {\n        gp=t.transform(gp,rect);\n      }\n      g2.setPaint(gp);\n    }\n else {\n      g2.setPaint(p);\n    }\n    g2.fill(rect);\n    if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n      if (orientation == PlotOrientation.VERTICAL) {\n        Line2D line=new Line2D.Double();\n        double x0=dataArea.getMinX();\n        double x1=dataArea.getMaxX();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(x0,start2d,x1,start2d);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(x0,end2d,x1,end2d);\n          g2.draw(line);\n        }\n      }\n else {\n        Line2D line=new Line2D.Double();\n        double y0=dataArea.getMinY();\n        double y1=dataArea.getMaxY();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(start2d,y0,start2d,y1);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(end2d,y0,end2d,y1);\n          g2.draw(line);\n        }\n      }\n    }\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,rect,marker.getLabelOffset(),marker.getLabelOffsetType(),anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(originalComposite);\n  }\n}\n", "docstring": "draws a line on the chart perpendicular to the y - axis to mark a value or range of values .", "partition": "test"}
{"idx": "3061", "code": "void fixCompatibility(View root){\n  Queue<View> queue=new LinkedList<View>();\n  queue.add(root);\n  View view=null;\n  while ((view=queue.poll()) != null) {\n    if (view instanceof ViewGroup) {\n      ViewGroup group=(ViewGroup)view;\n      for (int i=0; i < group.getChildCount(); i++) {\n        queue.add(group.getChildAt(i));\n      }\n    }\n  }\n}\n", "docstring": "iterate through each view in the view hiearchy and implement standout specific compatibility workarounds . < p > currently , this method does the following : < p > nothing yet .", "partition": "test"}
{"idx": "1700", "code": "private void doNormalCommandLineList(List<String> commandLineList,List<String> jointOptions,Path classpath){\n  commandLineList.add(\"--classpath\");\n  commandLineList.add(classpath.toString());\n  if (jointCompilation) {\n    commandLineList.add(\"-j\");\n    commandLineList.addAll(jointOptions);\n  }\n  if (destDir != null) {\n    commandLineList.add(\"-d\");\n    commandLineList.add(destDir.getPath());\n  }\n  if (encoding != null) {\n    commandLineList.add(\"--encoding\");\n    commandLineList.add(encoding);\n  }\n  if (stacktrace) {\n    commandLineList.add(\"-e\");\n  }\n  if (parameters) {\n    commandLineList.add(\"--parameters\");\n  }\n  if (useIndy) {\n    commandLineList.add(\"--indy\");\n  }\n  if (scriptBaseClass != null) {\n    commandLineList.add(\"-b\");\n    commandLineList.add(scriptBaseClass);\n  }\n  if (configscript != null) {\n    commandLineList.add(\"--configscript\");\n    commandLineList.add(configscript);\n  }\n}\n", "docstring": "add \" groovyc \" parameters to the commandlinelist , based on the ant configuration .", "partition": "test"}
{"idx": "1839", "code": "@SuppressWarnings(\"unchecked\") public static <K,V>void transformStringMap(Map<String,String> original,Map<K,V> map,Class<K> keyClass,Class<V> valueClass) throws PreferenceException {\n  Method parseKeyMethod=findParseMethod(keyClass);\n  Method parseValueMethod=findParseMethod(valueClass);\n  if ((null != parseKeyMethod) && (null != parseValueMethod)) {\n    for (    Map.Entry<String,String> toTransformEntry : original.entrySet()) {\n      try {\n        Object transformedKey=parseKeyMethod.invoke(null,toTransformEntry.getKey());\n        Object transformedValue=parseValueMethod.invoke(null,toTransformEntry.getValue());\n        if (keyClass.isAssignableFrom(transformedKey.getClass()) && valueClass.isAssignableFrom(transformedValue.getClass())) {\n          map.put((K)transformedKey,(V)transformedValue);\n        }\n      }\n catch (      Exception e) {\n        throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\",e);\n      }\n    }\n  }\n else   if (null == parseKeyMethod) {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ keyClass.getName()+ \".\");\n  }\n else {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ valueClass.getName()+ \".\");\n  }\n}\n", "docstring": "transforms all the strings key / value pairs in the original map to the given class key / value pairs and adds them to the given resulting map .", "partition": "test"}
{"idx": "4164", "code": "@Override public int hashCode(){\n  return type << 16 | value.hashCode() << 8 | otherValue.hashCode();\n}\n", "docstring": "returns a hash code for this node .", "partition": "test"}
{"idx": "397", "code": "public static Set<String> listServers(SSOToken ssoToken,String siteName) throws SMSException, SSOException, ConfigurationException {\n  Set<String> members=new HashSet<>();\n  String siteId=getSiteId(ssoToken,siteName);\n  if (siteId != null) {\n    Set<String> allServers=ServerConfiguration.getServers(ssoToken);\n    for (    String svr : allServers) {\n      if (ServerConfiguration.belongToSite(ssoToken,svr,siteName)) {\n        members.add(svr);\n      }\n    }\n  }\n  return members;\n}\n", "docstring": "returns the server instance names that belong to a site .", "partition": "test"}
{"idx": "4089", "code": "void onMoved(){\n  double diff=System.currentTimeMillis() - timeStamp;\n  timeStamp=0;\n  if (diff > DISCARD_THRESHOLD) {\n    return;\n  }\n  double recentJitter=0;\n  double sum=0.0;\n  for (int i=0; i < VECTOR_LENGTH; i++) {\n    double old=times[i];\n    double avg=(diff + old) / 2;\n    recentJitter+=Math.abs(old - diff);\n    times[i]=avg;\n    diff=old;\n    sum+=avg;\n  }\n  recentJitter/=8;\n  jitter=(jitter + 2.0 * Math.max(jitter,recentJitter) + recentJitter) / 4.0;\n  prediction=TURN_LENGTH / (sum / VECTOR_LENGTH + jitter);\n  WtWindowManager wm=WtWindowManager.getInstance();\n  wm.setProperty(SPEED_PROPERTY,Double.toString(prediction));\n  wm.setProperty(JITTER_PROPERTY,Double.toString(jitter));\n}\n", "docstring": "called when the user moves . marks the end of a timing instance .", "partition": "test"}
{"idx": "1033", "code": "public StandardXYItemLabelGenerator(){\n  this(DEFAULT_ITEM_LABEL_FORMAT,NumberFormat.getNumberInstance(),NumberFormat.getNumberInstance());\n}\n", "docstring": "creates an item label generator using default number formatters .", "partition": "test"}
{"idx": "3318", "code": "public void addFooterView(View v,Object data,boolean isSelectable){\n  FixedViewInfo info=new FixedViewInfo();\n  info.view=v;\n  info.data=data;\n  info.isSelectable=isSelectable;\n  mFooterViewInfos.add(info);\n  if (mAdapter != null && mObserver != null) {\n    mObserver.onChanged();\n  }\n}\n", "docstring": "add a fixed view to appear at the bottom of the list . if addfooterview is called more than once , the views will appear in the order they were added . views added using this call can take focus if they want . < p / > note : call this before calling setadapter . this is so listview can wrap the supplied cursor with one that will also account for header and footer views .", "partition": "test"}
{"idx": "2327", "code": "public void reload(String why){\n  mFullPhotoPaths=mRootDir.list(MediaScanner.JPG_FILENAME_FILTER);\n  if ((mFullPhotoPaths != null) && (mFullPhotoPaths.length == 0)) {\n    mFullPhotoPaths=null;\n    Log.i(Global.LOG_CONTEXT,mDebugPrefix + why + \"AdapterArrayHelper.refreshLocal(\"+ mRootDir+ \") \"+ 0);\n  }\n else   if (mFullPhotoPaths != null) {\n    if (Global.debugEnabled) {\n      Log.i(Global.LOG_CONTEXT,mDebugPrefix + why + \"AdapterArrayHelper.refreshLocal(\"+ mRootDir+ \") \"+ mFullPhotoPaths.length);\n    }\n    String parentDirString=mRootDir.getAbsolutePath();\n    for (int i=0; i < mFullPhotoPaths.length; i++) {\n      mFullPhotoPaths[i]=parentDirString + \"/\" + mFullPhotoPaths[i];\n    }\n  }\n}\n", "docstring": "refreshlocal files from inital path", "partition": "test"}
{"idx": "1571", "code": "private static boolean isMerge(InstructionHandle handle){\n  if (handle.hasTargeters()) {\n    InstructionTargeter[] targeterList=handle.getTargeters();\n    for (    InstructionTargeter targeter : targeterList) {\n      if (targeter instanceof BranchInstruction) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "determine whether or not the given instruction is a control flow merge .", "partition": "test"}
{"idx": "956", "code": "public QDate(){\n  this(_gmtTimeZone);\n}\n", "docstring": "creates the date for gmt .", "partition": "test"}
{"idx": "388", "code": "public void addListener(final IFilterPanelListener<T> listener){\n  m_listeners.addListener(listener);\n}\n", "docstring": "adds a listener that is notified about changes in the filter .", "partition": "test"}
{"idx": "3312", "code": "public static String padLeft(String str,int totalChars){\n  if (str == null)   str=\"null\";\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < totalChars - str.length(); i++) {\n    sb.append(\" \");\n  }\n  sb.append(str);\n  return sb.toString();\n}\n", "docstring": "pads the given string to the left with spaces to ensure that it \"'\" s at least totalchars long .", "partition": "test"}
{"idx": "2264", "code": "public static boolean stringToBooleanValue(String str) throws ExpressionException {\n  str=StringUtil.toLowerCase(str.trim());\n  if (str.equals(\"yes\") || str.equals(\"true\"))   return true;\n else   if (str.equals(\"no\") || str.equals(\"false\"))   return false;\n  throw new CasterException(\"Can\\'t cast String [\" + str + \"] to boolean\");\n}\n", "docstring": "cast a string to a boolean value ( primitive value type )", "partition": "test"}
{"idx": "1715", "code": "public static Object newInstance(Class<?> cl,int[] dims){\n  if (dims.length == 0) {\n    dims=new int[]{1};\n  }\n  return Array.newInstance(cl,dims);\n}\n", "docstring": "allocate an array dynamically . the array . newinstance method does not throw an error and silently returns a null . throws an outofmemoryerror if insufficient space is available .", "partition": "test"}
{"idx": "2351", "code": "public static int nextInt(int n){\n  Random random=getRandom();\n  int value=random.nextInt(n);\n  if (!_isTest)   _freeRandomList.free(random);\n  return value;\n}\n", "docstring": "returns the next random int .", "partition": "test"}
{"idx": "284", "code": "private boolean isAtMaximum(Adjustable bar){\n  return (bar.getValue() + bar.getVisibleAmount() >= bar.getMaximum());\n}\n", "docstring": "check if a scroll bar is at its maximum value .", "partition": "test"}
{"idx": "241", "code": "public static <E extends Identifiable>List<E> findByPrimaryKeys(EntityManager em,List<BigInteger> ids,Class<E> type){\n  requireArgument(em != null,\"The entity manager cannot be null.\");\n  requireArgument(ids != null && !ids.isEmpty(),\"IDs cannot be null or empty.\");\n  requireArgument(type != null,\"The entity type cannot be null.\");\n  TypedQuery<E> query=em.createNamedQuery(\"JPAEntity.findByPrimaryKeys\",type);\n  query.setHint(\"javax.persistence.cache.storeMode\",\"REFRESH\");\n  try {\n    query.setParameter(\"ids\",ids);\n    query.setParameter(\"deleted\",false);\n    return query.getResultList();\n  }\n catch (  NoResultException ex) {\n    return new ArrayList<>(0);\n  }\n}\n", "docstring": "finds jpa entities by their primary keys .", "partition": "test"}
{"idx": "100", "code": "@Override public void ignorableWhitespace(XMLString text,Augmentations augs) throws XNIException {\n  if (!fIncludeIgnorableWhitespace || fFilterReject) {\n    return;\n  }\n  if (!fDeferNodeExpansion) {\n    Node child=fCurrentNode.getLastChild();\n    if (child != null && child.getNodeType() == Node.TEXT_NODE) {\n      Text textNode=(Text)child;\n      textNode.appendData(text.toString());\n    }\n else {\n      Text textNode=fDocument.createTextNode(text.toString());\n      if (fDocumentImpl != null) {\n        TextImpl textNodeImpl=(TextImpl)textNode;\n        textNodeImpl.setIgnorableWhitespace(true);\n      }\n      fCurrentNode.appendChild(textNode);\n    }\n  }\n else {\n    int txt=fDeferredDocumentImpl.createDeferredTextNode(text.toString(),true);\n    fDeferredDocumentImpl.appendChild(fCurrentNodeIndex,txt);\n  }\n}\n", "docstring": "ignorable whitespace . for this method to be called , the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable . for example , the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model .", "partition": "test"}
{"idx": "1852", "code": "public NativeRunner(File eclipsec){\n  this.eclipsec=Objects.requireNonNull(eclipsec);\n}\n", "docstring": "pass it the location of the launcher file .", "partition": "test"}
{"idx": "2167", "code": "private static void read(InputStream in,byte[] buf,int pos,int n) throws IOException {\n  int read=0;\n  int res=0;\n  while (read < n) {\n    res=in.read(buf,read + pos,n - read);\n    if (res > 0) {\n      read+=res;\n    }\n else {\n      throw new IOException(\"Read failed, got \" + read + \" of \"+ n);\n    }\n  }\n}\n", "docstring": "read at least the specified amount of bytes , and place them in the input buffer .", "partition": "test"}
{"idx": "810", "code": "private void pushContext(BaseContext c){\n  contextStack.push(c);\n}\n", "docstring": "add a new parsing context onto the parse context stack .", "partition": "test"}
{"idx": "3060", "code": "public boolean hasChanged(){\n  return System.identityHashCode(config) != initialHash;\n}\n", "docstring": "checks if the config has changed since it was loaded .", "partition": "test"}
{"idx": "2662", "code": "private void storePassword(String password){\n  if (isStore && sharedState != null) {\n    sharedState.put(getPwdKey(),password);\n  }\n}\n", "docstring": "stores password into shared state map . this method may be called after successful authentication by each individual module .", "partition": "test"}
{"idx": "1207", "code": "public static void writeUint8(OutputStream theOs,int theValue) throws IOException {\n  theOs.write(theValue);\n}\n", "docstring": "writes a \" uint8 \" in wsp format to the given output stream .", "partition": "test"}
{"idx": "3853", "code": "private static boolean dateByOrdinal(DateTimeFormatterBuilder bld,Collection<DateTimeFieldType> fields,boolean extended,boolean strictISO){\n  boolean reducedPrec=false;\n  if (fields.remove(DateTimeFieldType.year())) {\n    bld.append(yearElement());\n    if (fields.remove(DateTimeFieldType.dayOfYear())) {\n      appendSeparator(bld,extended);\n      bld.appendDayOfYear(3);\n    }\n else {\n      reducedPrec=true;\n    }\n  }\n else   if (fields.remove(DateTimeFieldType.dayOfYear())) {\n    bld.appendLiteral('-');\n    bld.appendDayOfYear(3);\n  }\n  return reducedPrec;\n}\n", "docstring": "creates a date using the ordinal date format . specification reference : 5 . 2 . 2 .", "partition": "test"}
{"idx": "3714", "code": "public boolean needPreloadKey(int idx){\n  return preloadKeys != null && preloadKeys.get(idx);\n}\n", "docstring": "checks whether entry info should be sent to primary node from backup .", "partition": "test"}
{"idx": "694", "code": "public boolean remove(String classname){\n  String pkgname;\n  HashSet<String> names;\n  classname=cleanUp(classname);\n  pkgname=extractPackage(classname);\n  names=m_Cache.get(pkgname);\n  if (names != null) {\n    return names.remove(classname);\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "removes the classname from the cache .", "partition": "test"}
{"idx": "1782", "code": "public boolean checkRootBySuperUserApk(){\n  File suApk=new File(SU_APK);\n  if (suApk != null && suApk.exists()) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "returns true if the device contains superuser . apk which is stored into the device in the rooting process .", "partition": "test"}
{"idx": "1547", "code": "private void divide(int[] idx,double[] data,ArrayList<int[]> ret,int start,int end,int depth){\n  if (depth == 0) {\n    int[] a=Arrays.copyOfRange(idx,start,end);\n    Arrays.sort(a);\n    ret.add(a);\n    return;\n  }\n  final int count=end - start;\n  if (count == 0) {\n    for (int j=1 << depth; j > 0; --j) {\n      ret.add(new int[0]);\n    }\n    return;\n  }\n  double m=0.;\n  for (int i=start; i < end; i++) {\n    m+=data[i];\n  }\n  m/=count;\n  int pos=Arrays.binarySearch(data,start,end,m);\n  if (pos >= 0) {\n    final int opt=(start + end) >> 1;\n    while (data[pos] == m) {\n      if (pos < opt) {\n        pos++;\n      }\n else       if (pos > opt) {\n        pos--;\n      }\n else {\n        break;\n      }\n    }\n  }\n else {\n    pos=(-pos - 1);\n  }\n  divide(idx,data,ret,start,pos,depth - 1);\n  divide(idx,data,ret,pos,end,depth - 1);\n}\n", "docstring": "recursive call to further subdivide the array .", "partition": "test"}
{"idx": "1443", "code": "protected void handleAutoDraw(){\n  if (isToolItemSelected(ToolBarItemKey.AUTO_DRAW)) {\n    onAutoDraw();\n  }\n}\n", "docstring": "if auto draw is enabled , a draw request is sent . this method should be invoked when receiving a move and right after sending one . in the future this will become smarter and only draw when the game shows a draw by three times in the same position or 50 move draw rule .", "partition": "test"}
{"idx": "2923", "code": "public void evict() throws Exception {\n  assertOpen();\n  boolean isEmpty;\nsynchronized (this) {\n    isEmpty=pool.isEmpty();\n  }\n  if (!isEmpty) {\n    if (softMinEvictableIdleTimeMillis > 0) {\n      int numToEvict=getNumIdle() - getMinIdle();\n      evict(System.currentTimeMillis() - softMinEvictableIdleTimeMillis,numToEvict);\n    }\n    if (minEvictableIdleTimeMillis > 0) {\n      int numToEvict=getNumIdle();\n      evict(System.currentTimeMillis() - minEvictableIdleTimeMillis,numToEvict);\n    }\n  }\n}\n", "docstring": "make one pass of the idle object evictor .", "partition": "test"}
{"idx": "3731", "code": "private void displayEasterEgg(CommandSender sender){\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a7c\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a7c\\\\u2592\u00a7c\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a7c\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a78\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a78\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a78\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a74\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a78\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a76\\\\u2592\u00a76\\\\u2592\u00a74\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a7f\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a7f\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a74\\\\u2592\u00a74\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a7f\\\\u2592\u00a7f\\\\u2592\u00a77\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a74\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a78\\\\u2592\u00a78\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a70\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a77\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a75\\\\u2592\u00a77\\\\u2592\u00a7r\"));\n}\n", "docstring": "easter egg ; run it and you \"'\" ll see what all this mess is about !", "partition": "test"}
{"idx": "1758", "code": "public Configuration loadConfigFromResource(Resource resource){\n  PropertiesConfiguration result=new PropertiesConfiguration();\n  try {\n    result.load(resource.getInputStream());\n    return result;\n  }\n catch (  ConfigurationException|IOException e) {\n    LOG.error(CONFIGURATION_LOAD_ERROR.format(resource.getFilename()),e);\n    throw new SystemConfigException(CONFIGURATION_LOAD_ERROR.format(resource.getFilename()),e);\n  }\n}\n", "docstring": "build a configuration object from a resource , processing it as a properties file .", "partition": "test"}
{"idx": "3716", "code": "@Override public void perform(IR ir){\n  for (Enumeration<BasicBlock> e=ir.getBasicBlocks(); e.hasMoreElements(); ) {\n    BasicBlock bb=e.nextElement();\n    if (bb.isEmpty())     continue;\n    container.counter2++;\n    if (bb.getInfrequent()) {\n      container.counter1++;\n      if (ir.options.FREQ_FOCUS_EFFORT)       continue;\n    }\n    for (Enumeration<Instruction> ie=bb.forwardInstrEnumerator(); ie.hasMoreElements(); ) {\n      Instruction s=ie.nextElement();\n      if (TypeCheck.conforms(s) && (invertNullAndTypeChecks(s) || pushTypeCheckBelowIf(s,ir))) {\n        ie=bb.forwardInstrEnumerator();\n      }\n    }\n  }\n}\n", "docstring": "main routine : perform the transformation .", "partition": "test"}
{"idx": "4005", "code": "public boolean isLandingPage(URL url){\n  if (url.getQuery() != null) {\n    return false;\n  }\n else {\n    return landingPageSuffix(url) != \"\";\n  }\n}\n", "docstring": "calculates whether the url is a landing page or not", "partition": "test"}
{"idx": "3663", "code": "protected List<String> createNewExportMaskWorkflowForInitiators(List<URI> initiatorURIs,ExportGroup exportGroup,Workflow workflow,Map<URI,Integer> volumeMap,StorageSystem storage,String token,String previousStep) throws Exception {\n  List<String> newSteps=new ArrayList<>();\n  if (!initiatorURIs.isEmpty()) {\n    Map<String,List<URI>> computeResourceToInitiators=mapInitiatorsToComputeResource(exportGroup,initiatorURIs);\n    for (    Map.Entry<String,List<URI>> resourceEntry : computeResourceToInitiators.entrySet()) {\n      String computeKey=resourceEntry.getKey();\n      List<URI> computeInitiatorURIs=resourceEntry.getValue();\n      _log.info(String.format(\"New export masks for %s\",computeKey));\n      GenExportMaskCreateWorkflowResult result=generateDeviceSpecificExportMaskCreateWorkFlow(workflow,previousStep,storage,exportGroup,computeInitiatorURIs,volumeMap,token);\n      previousStep=result.getStepId();\n      newSteps.add(previousStep);\n    }\n  }\n  if (newSteps.isEmpty() && previousStep != null) {\n    newSteps.add(previousStep);\n  }\n  return newSteps;\n}\n", "docstring": "creates a new exportmask for host for the given initiators .", "partition": "test"}
{"idx": "103", "code": "public static int convertLatmToY(int latm){\n  long v=Math.round((Mercator.MAX_Y - Mercator.lat2y(latm / LATLON_TO_LATLONM)) * MAX_AP_UNITS / (Mercator.MAX_Y * 2));\n  if (v > MAX_AP_UNITS)   return MAX_AP_UNITS;\n  if (v < 0)   return -1;\n  return (int)v;\n}\n", "docstring": "returns the y position based on latitude . note that this is based of mercator which will have infinite number of points approaching + / - 90 degrees . so if we are out of range , ( beyond the configured min / max latitude ) , we return - 1 and max_ap_units based on which direction we are out", "partition": "test"}
{"idx": "1597", "code": "@Override public boolean isInitial(){\n  return init;\n}\n", "docstring": "returns a boolean flag indicating if the state is initial ( just starting )", "partition": "test"}
{"idx": "3834", "code": "protected void createFromHValues(int[] hValues,int partitions){\n  Arrays.sort(hValues);\n  this.splits=new int[partitions];\n  int maxH=0x7fffffff;\n  for (int i=0; i < splits.length; i++) {\n    int quantile=(int)((long)(i + 1) * hValues.length / partitions);\n    this.splits[i]=quantile == hValues.length ? maxH : hValues[quantile];\n  }\n}\n", "docstring": "create a hilbertcurvepartitioner from a list of points", "partition": "test"}
{"idx": "1977", "code": "public static String encode(final Coordinate[] coords){\n  long lastLat=0;\n  long lastLng=0;\n  final StringBuffer result=new StringBuffer();\n  for (  final Coordinate point : coords) {\n    long lat=Math.round(point.y * 1e5);\n    long lng=Math.round(point.x * 1e5);\n    long dLat=lat - lastLat;\n    long dLng=lng - lastLng;\n    encode(dLat,result);\n    encode(dLng,result);\n    lastLat=lat;\n    lastLng=lng;\n  }\n  return result.toString();\n}\n", "docstring": "encodes a sequence of latlngs into an encoded path string .", "partition": "test"}
{"idx": "3734", "code": "@Override public synchronized void addRequestProperty(String key,String value){\n  if (connected || connecting)   throw new IllegalStateException(\"Already connected\");\n  if (key == null)   throw new NullPointerException(\"key is null\");\n  if (isExternalMessageHeaderAllowed(key,value)) {\n    requests.add(key,value);\n    if (!key.equalsIgnoreCase(\"Content-Type\")) {\n      userHeaders.add(key,value);\n    }\n  }\n}\n", "docstring": "adds a general request property specified by a key - value pair . this method will not overwrite existing values associated with the same key .", "partition": "test"}
{"idx": "1441", "code": "private static void writeSpaces(Writer out,int amt) throws IOException {\n  while (amt > 0) {\n    out.write(' ');\n    amt--;\n  }\n}\n", "docstring": "writes the given number of spaces to the given writer .", "partition": "test"}
{"idx": "3686", "code": "private boolean isPageBreak(int row){\n  for (int i=0; i < m_pageBreak.size(); i++) {\n    Integer rr=(Integer)m_pageBreak.get(i);\n    if (rr.intValue() + 1 == row)     return true;\n else     if (rr.intValue() > row)     return false;\n  }\n  return false;\n}\n", "docstring": "check for for pagebreak", "partition": "test"}
{"idx": "454", "code": "public static DateFormat createUTCDateFormatter(String dateFormat){\n  DateFormat formatter=new SimpleDateFormat(dateFormat);\n  formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n  return formatter;\n}\n", "docstring": "creates a dateformat that assumes the incoming date is in utc time .", "partition": "test"}
{"idx": "3622", "code": "public void displayInfoLine(String infoLine,int labelDesignator){\n  if (infoLineHolder != null) {\n    setLabel((infoLine != null && infoLine.length() > 0) ? infoLine : fudgeString,labelDesignator);\n  }\n}\n", "docstring": "display a line of text in a designated info line .", "partition": "test"}
{"idx": "659", "code": "public void addElement(Object anObject){\n  p_data.add(anObject);\n  fireIntervalAdded(this,p_data.size() - 1,p_data.size() - 1);\n  if (p_data.size() == 1 && m_selectedObject == null && anObject != null)   setSelectedItem(anObject);\n}\n", "docstring": "add element at the end", "partition": "test"}
{"idx": "3502", "code": "public CharBuffer(String string){\n  int length=string.length();\n  int capacity=length + MIN_CAPACITY;\n  init(new char[capacity],0,length);\n  string.getChars(0,length,buffer(),0);\n}\n", "docstring": "constructs a char buffer with the given initial string", "partition": "test"}
{"idx": "2428", "code": "public static String convertBooleanArrToString(Boolean[] noDictionaryDimsMapping){\n  StringBuilder builder=new StringBuilder();\n  int index=0;\n  for (; index < noDictionaryDimsMapping.length; index++) {\n    builder.append(noDictionaryDimsMapping[index]);\n    builder.append(CarbonCommonConstants.COMA_SPC_CHARACTER);\n  }\n  int lastIndex=builder.lastIndexOf(CarbonCommonConstants.COMA_SPC_CHARACTER);\n  String str=-1 != lastIndex ? builder.substring(0,lastIndex) : builder.toString();\n  return str;\n}\n", "docstring": "this method will convert boolean [ ", "partition": "test"}
{"idx": "4124", "code": "public static String array2hex(final byte[] array){\n  return byteArray2String(array,\"0x\",\", \",true,16);\n}\n", "docstring": "a byte array into its hex string representation", "partition": "test"}
{"idx": "194", "code": "public static Vector tokenizeString(String source,String separator){\n  if (separator.length() == 1) {\n    return tokenizeString(source,separator.charAt(0));\n  }\n  Vector tokenized=new Vector();\n  int len=source.length();\n  StringBuilder buf=new StringBuilder();\n  for (int iter=0; iter < len; iter++) {\n    char current=source.charAt(iter);\n    if (separator.indexOf(current) > -1) {\n      if (buf.length() > 0) {\n        tokenized.addElement(buf.toString());\n        buf=new StringBuilder();\n      }\n    }\n else {\n      buf.append(current);\n    }\n  }\n  if (buf.length() > 0) {\n    tokenized.addElement(buf.toString());\n  }\n  return tokenized;\n}\n", "docstring": "breaks a string to multiple strings ( similar to string tokenizer )", "partition": "test"}
{"idx": "658", "code": "protected void removeClassifiers(int[] indices){\n  int i;\n  if (indices == null) {\n    m_ModelClassifiers.removeAllElements();\n  }\n else {\n    for (i=indices.length - 1; i >= 0; i--)     m_ModelClassifiers.remove(indices[i]);\n  }\n  setModified(true);\n}\n", "docstring": "removes the specified classifiers .", "partition": "test"}
{"idx": "2913", "code": "protected String wrapLinuxCommand(String command) throws IOException, InterruptedException {\n  String setGroup=\"export GROUP_NAME=`(getent group \" + getGid() + \" || (groupadd -g \"+ getGid()+ \" user && echo user:x:\"+ getGid()+ \")) | cut -d: -f1`\";\n  String setUser=\"export USER_NAME=`(getent passwd \" + getUid() + \" || (useradd -u \"+ getUid()+ \" -g ${GROUP_NAME} user && echo user:x:\"+ getGid()+ \")) | cut -d: -f1`\";\n  String chownCommand=\"chown --silent -R ${USER_NAME}.${GROUP_NAME} /usr/src/app || true\";\n  return setGroup + \" && \" + setUser+ \" && \"+ chownCommand+ \" && \"+ command+ \" && \"+ chownCommand;\n}\n", "docstring": "wrap the given command into a command with chown . also add group / user that match host environment if not exists", "partition": "test"}
{"idx": "3401", "code": "public void testMergeOneServletIntoDocumentWithAnotherServlet() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <servlet>\" + \"    <servlet-name>s1</servlet-name>\"+ \"    <servlet-class>sclass1</servlet-class>\"+ \"  </servlet>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  String mergeXml=\"<web-app>\" + \"  <servlet>\" + \"    <servlet-name>s2</servlet-name>\"+ \"    <servlet-class>sclass2</servlet-class>\"+ \"  </servlet>\"+ \"</web-app>\";\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(mergeXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.merge(mergeWebXml);\n  assertTrue(WebXmlUtils.hasServlet(srcWebXml,\"s1\"));\n  assertTrue(WebXmlUtils.hasServlet(srcWebXml,\"s2\"));\n}\n", "docstring": "tests whether a single servlet is correctly merged into a descriptor that already contains the definition of an other servlet .", "partition": "test"}
{"idx": "1635", "code": "public void componentResized(ComponentEvent e){\n  if (logger.isLoggable(Level.FINE)) {\n    logger.fine(\"Size changed: \" + getWidth() + \" x \"+ getHeight());\n  }\n  projection.setWidth(getWidth());\n  projection.setHeight(getHeight());\n  fireProjectionChanged();\n}\n", "docstring": "componentlistener interface method . should not be called directly . invoked when component has been resized , and kicks off a projection change .", "partition": "test"}
{"idx": "4108", "code": "boolean isStateChange(XDecoratedPeer window,XPropertyEvent e){\n  if (!window.isShowing()) {\n    stateLog.finer(\"Window is not showing\");\n    return false;\n  }\n  int wm_state=window.getWMState();\n  if (wm_state == XUtilConstants.WithdrawnState) {\n    stateLog.finer(\"WithdrawnState\");\n    return false;\n  }\n else {\n    if (stateLog.isLoggable(PlatformLogger.Level.FINER)) {\n      stateLog.finer(\"Window WM_STATE is \" + wm_state);\n    }\n  }\n  boolean is_state_change=false;\n  if (e.get_atom() == XA_WM_STATE.getAtom()) {\n    is_state_change=true;\n  }\n  for (  XStateProtocol proto : getProtocols(XStateProtocol.class)) {\n    is_state_change|=proto.isStateChange(e);\n    if (stateLog.isLoggable(PlatformLogger.Level.FINEST)) {\n      stateLog.finest(proto + \": is state changed = \" + is_state_change);\n    }\n  }\n  return is_state_change;\n}\n", "docstring": "\\\\ notice window state change when wm changes a property on the window . . . \\\\", "partition": "test"}
{"idx": "623", "code": "public Prototype undump(InputStream stream,String chunkname) throws IOException {\n  if (stream.read() != LUA_SIGNATURE[0] || stream.read() != LUA_SIGNATURE[1] || stream.read() != LUA_SIGNATURE[2] || stream.read() != LUA_SIGNATURE[3])   return null;\n  String sname=getSourceName(chunkname);\n  LoadState s=new LoadState(stream,sname);\n  s.loadHeader();\nswitch (s.luacNumberFormat) {\ncase NUMBER_FORMAT_FLOATS_OR_DOUBLES:\ncase NUMBER_FORMAT_INTS_ONLY:\ncase NUMBER_FORMAT_NUM_PATCH_INT32:\n    break;\ndefault :\n  throw new LuaError(\"unsupported int size\");\n}\nreturn s.loadFunction(LuaString.valueOf(sname));\n}\n", "docstring": "load input stream as a lua binary chunk if the first 4 bytes are the lua binary signature .", "partition": "test"}
{"idx": "41", "code": "StoppableReadLock(ReadWriteLock lock,CancelCriterion stopper){\n  this.lock=lock.readLock();\n  this.stopper=stopper;\n}\n", "docstring": "create a new read lock from the given lock", "partition": "test"}
{"idx": "1822", "code": "public static void initializeProperties(Properties properties,boolean reset,boolean withDefaults){\n  Properties defaultProp=null;\n  if (withDefaults) {\n    SSOToken appToken=AccessController.doPrivileged(AdminTokenAction.getInstance());\n    defaultProp=ServerConfiguration.getDefaults(appToken);\n  }\n  PropertiesHolder oldProps;\n  PropertiesHolder newProps;\n  do {\n    oldProps=propertiesHolderRef.get();\n    final Properties combined=new Properties();\n    if (defaultProp != null) {\n      combined.putAll(defaultProp);\n    }\n    if (!reset) {\n      combined.putAll(oldProps.properties);\n    }\n    combined.putAll(properties);\n    newProps=new PropertiesHolder(Maps.fromProperties(combined));\n  }\n while (!propertiesHolderRef.compareAndSet(oldProps,newProps));\n}\n", "docstring": "initializes the properties to be used by openam . ideally this must be called first before any other method is called within openam . this method provides a programmatic way to set the properties , and will override similar properties if loaded for a properties file .", "partition": "test"}
{"idx": "2653", "code": "public boolean add(symbol sym) throws internal_error {\n  Object previous;\n  not_null(sym);\n  previous=_all.put(sym.name(),sym);\n  return previous == null;\n}\n", "docstring": "add a single symbol to the set .", "partition": "test"}
{"idx": "2797", "code": "public void compileProjects(List<File> projects,IssueAcceptor issueAcceptor) throws N4JSCompileException {\n  compileProjects(Arrays.asList(new File(\".\")),projects,Collections.emptyList(),issueAcceptor);\n}\n", "docstring": "compile a list of projects .", "partition": "test"}
{"idx": "1660", "code": "public Process(final File file,final ProgressListener progressListener) throws IOException, XMLException {\n  this.processLocation=new FileProcessLocation(file);\n  initContext();\n  Reader in=null;\n  try {\n    in=new InputStreamReader(new FileInputStream(file),\"UTF-8\");\n    readProcess(in,progressListener);\n  }\n catch (  IOException e) {\n    throw e;\n  }\n finally {\n    if (in != null) {\n      in.close();\n    }\n  }\n}\n", "docstring": "creates a new process from the given process file . this might have been created with the gui beforehand .", "partition": "test"}
{"idx": "1127", "code": "public static String[] stringArrayFromProperties(Properties p,String propName,String tok){\n  String[] ret=null;\n  String raw=p.getProperty(propName);\n  if (raw != null && raw.length() > 0) {\n    try {\n      StringTokenizer token=new StringTokenizer(raw,tok);\n      int numPaths=token.countTokens();\n      ret=new String[numPaths];\n      for (int i=0; i < numPaths; i++) {\n        ret[i]=token.nextToken();\n      }\n      return ret;\n    }\n catch (    java.util.NoSuchElementException e) {\n      e.printStackTrace();\n    }\n  }\n  return ret;\n}\n", "docstring": "takes a string of representing token separated properties and returns an array of parsed strings . note : this method currently doesn \"'\" t support appropriate quoting of the token , although it probably should . . .", "partition": "test"}
{"idx": "2071", "code": "public void goToCurrentDay(){\n  int monthDifference=FlexibleCalendarHelper.getMonthDifference(displayYear,displayMonth);\n  Calendar cal=Calendar.getInstance();\n  selectedDateItem.setDay(cal.get(Calendar.DAY_OF_MONTH));\n  selectedDateItem.setMonth(cal.get(Calendar.MONTH));\n  selectedDateItem.setYear(cal.get(Calendar.YEAR));\n  if (disableAutoDateSelection) {\n    this.userSelectedItem=selectedDateItem.clone();\n  }\n  if (monthDifference != 0) {\n    resetAdapters=true;\n    if (monthDifference < 0) {\n      monthInfPagerAdapter.setFakeCount(lastPosition);\n      monthInfPagerAdapter.notifyDataSetChanged();\n    }\n    shouldOverrideComputedDate=true;\n    moveToPosition(monthDifference);\n  }\n else {\n    FlexibleCalendarGridAdapter currentlyVisibleAdapter=monthViewPagerAdapter.getMonthAdapterAtPosition(lastPosition % MonthViewPagerAdapter.VIEWS_IN_PAGER);\n    currentlyVisibleAdapter.notifyDataSetChanged();\n  }\n}\n", "docstring": "move the position to today \"'\" s date", "partition": "test"}
{"idx": "2496", "code": "public Model validateModel(Dataset dataset,URI shapesGraphURI,Resource minSeverity,boolean validateShapes,Function<RDFNode,String> labelFunction,ProgressMonitor monitor) throws InterruptedException {\n  if (dataset.getDefaultModel() == null) {\n    throw new IllegalArgumentException(\"Dataset requires a default model\");\n  }\n  Model shapesModel=dataset.getNamedModel(shapesGraphURI.toString());\n  if (monitor != null) {\n    monitor.subTask(\"Preparing execution plan\");\n  }\n  List<Property> constraintProperties=SHACLUtil.getAllConstraintProperties(validateShapes);\n  Map<Resource,List<SHConstraint>> map=buildShape2ConstraintsMap(shapesModel,dataset.getDefaultModel(),constraintProperties,validateShapes);\n  if (monitor != null) {\n    monitor.subTask(\"\");\n  }\n  if (monitor != null) {\n    monitor.beginTask(\"Validating constraints for \" + map.size() + \" shapes...\",map.size());\n  }\n  Model results=JenaUtil.createMemoryModel();\n  results.setNsPrefixes(dataset.getDefaultModel());\n  for (  Resource shape : map.keySet()) {\n    for (    SHConstraint constraint : map.get(shape)) {\n      validateConstraintForShape(dataset,shapesGraphURI,minSeverity,constraint,shape,results,labelFunction,monitor);\n      if (monitor != null) {\n        monitor.worked(1);\n        if (monitor.isCanceled()) {\n          throw new InterruptedException();\n        }\n      }\n    }\n  }\n  return results;\n}\n", "docstring": "validates all resources in a given model , which is expected to be the default graph of a given dataset .", "partition": "test"}
{"idx": "3730", "code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    byte[] values=(byte[])newVal;\n    ByteBuffer buffer=ByteBuffer.wrap(values);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      valueSet.add(buffer.getInt());\n    }\n    return;\n  }\n else {\n    double value=new Double(newVal.toString());\n    agg(value);\n  }\n}\n", "docstring": "distinct count aggregate function which update the distinct count", "partition": "test"}
{"idx": "477", "code": "public boolean addSubAction(final ConfAction actionConf) throws GeneralException, ConfigurationException {\n  if (actionConf.getType() != null) {\n    final SubAction sub=SubAction.factory(actionConf.getType(),actionConf);\n    if (sub == null) {\n      if (Cfg.DEBUG) {\n        Check.log(TAG + \" Error (addSubAction): unknown type: \" + actionConf.getType());\n      }\n      return false;\n    }\n    list.add(sub);\n    if (sub instanceof SubActionSlow) {\n      setQueue(MAIN_QUEUE);\n    }\n    return true;\n  }\n else {\n    if (Cfg.DEBUG) {\n      Check.log(TAG + \" Error (addSubAction): null type \");\n    }\n    return false;\n  }\n}\n", "docstring": "adds the sub action .", "partition": "test"}
{"idx": "3044", "code": "public void engineDeleteEntry(String alias) throws KeyStoreException {\nsynchronized (entries) {\n    entries.remove(alias.toLowerCase(Locale.ENGLISH));\n  }\n}\n", "docstring": "deletes the entry identified by the given alias from this keystore .", "partition": "test"}
{"idx": "1989", "code": "@SuppressWarnings(\"unchecked\") private HashMap<String,DBObject> loadDBObjects(Class objectClass){\n  HashMap<String,DBObject> objectMap=new HashMap<String,DBObject>();\n  DBObject dbObject=new DBObject(this,objectClass);\n  String objectToLoad=s_logger.localizeMessage(\"object\");\n  String objectsToLoad=s_logger.localizeMessage(\"objects\");\n  String sqlLoadHeaders=null;\n  String sqlLoadContents=null;\n  if (dbObject != null) {\n    objectToLoad=dbObject.getObjectType();\n    objectsToLoad=dbObject.getObjectTypes();\n    sqlLoadHeaders=dbObject.getLoadHeaderSQL();\n    sqlLoadContents=dbObject.getLoadContentSQL();\n  }\n  s_logger.log(Level.FINE,\"loadDBObjects\",new Object[]{objectsToLoad,getDirection()});\n  PreparedStatementWrapper stmtLoadHeaders=setPreparedStatement(sqlLoadHeaders);\n  PreparedStatementWrapper stmtLoadContents=setPreparedStatement(sqlLoadContents);\n  int counter=0;\n  if (dbObject != null) {\n    String sql=dbObject.getLoadObjectSQL();\n    Statement stmt=setStatement();\n    ResultSet rs=executeQuery(stmt,sql);\n    while (getResultSetNext(rs)) {\n      String s=getResultSetString(rs,\"OBJECT_NAME\");\n      if (!objectMap.containsKey(s)) {\n        DBObject obj=new DBObject(this,objectClass,s);\n        obj.populate(stmtLoadHeaders,stmtLoadContents);\n        if (obj.isPopulated()) {\n          objectMap.put(s.toUpperCase(),obj);\n          counter++;\n        }\n      }\n    }\n    releaseResultSet(rs);\n    releaseStatement(stmt);\n  }\n  releasePreparedStatement(stmtLoadHeaders);\n  releasePreparedStatement(stmtLoadContents);\n  if (counter == 1)   s_logger.log(Level.FINE,\"dbObjectsLoaded\",new Object[]{Integer.toString(counter),objectToLoad});\n else   s_logger.log(Level.FINE,\"dbObjectsLoaded\",new Object[]{Integer.toString(counter),objectsToLoad});\n  s_logger.flush();\n  return objectMap;\n}\n", "docstring": "load objects defined in the database", "partition": "test"}
{"idx": "3023", "code": "protected <T extends TaskServiceDocument<E>,E extends Enum<E>>T waitForTaskCompletion(String documentSelfLink,Class<T> type) throws Throwable {\n  return waitForPropertyValue(documentSelfLink,type,TaskServiceDocument.FIELD_NAME_TASK_STAGE,Arrays.asList(TaskStage.FINISHED,TaskStage.FAILED,TaskStage.CANCELLED),true,waitForStageChangeCountLonger());\n}\n", "docstring": "waits until the given task completes and returns its final state .", "partition": "test"}
{"idx": "4061", "code": "public void updatePendingList(){\n  while (mPendingList.size() > 0 && activeListHasRoom()) {\n    DownloadInfoRunnable pending=mPendingList.get(0);\n    pending.changeStatusState(new ActiveState(pending));\n  }\n}\n", "docstring": "check if there are pending downloads and if so move the top one up to the active list .", "partition": "test"}
{"idx": "2037", "code": "private static AlgorithmParameterSpec algorithmParameterSpec(){\n  final SecureRandom random=new SecureRandom();\n  final byte[] bytes=new byte[CcAes.BLOCK];\n  random.nextBytes(bytes);\n  return new IvParameterSpec(bytes);\n}\n", "docstring": "create algorithmparameterspec with the block size .", "partition": "test"}
{"idx": "607", "code": "public StringList plus(String... args){\n  StringList newList=new StringList();\n  newList.addAll(this);\n  newList.addAll(Arrays.asList(args));\n  return newList;\n}\n", "docstring": "add a list of strings .", "partition": "test"}
{"idx": "1419", "code": "public void updateMaxTextWidths(float requiredWidth,float matchContentsWidth){\n  mMaxRequiredWidth=Math.max(mMaxRequiredWidth,requiredWidth);\n  mMaxMatchContentsWidth=Math.max(mMaxMatchContentsWidth,matchContentsWidth);\n}\n", "docstring": "updates the max text width values for the suggestions .", "partition": "test"}
{"idx": "2078", "code": "public static <T>UnaryOperator<List<T>> from(Collection<String> commandLineUdids,Function<T,ICloud.MBSBackup> mbsBackup,Function<ICloud.MBSBackup,String> formatter,Printer out,InputStream in){\n  return commandLineUdids.isEmpty() ? new User(mbsBackup,out,in,formatter) : new Udid(mbsBackup,out,in,new ArrayList<>(commandLineUdids));\n}\n", "docstring": "returns a new instance . < p > the from udids will be fully or partially matched against the supplied udids , case - insensitive . if the supplied udids list is empty , the user will be prompted for a selection .", "partition": "test"}
{"idx": "3936", "code": "private void init(){\n  acceptableMethods=new ArrayList<>();\n  acceptableMethods.add(new NoAuthenticationRequiredMethod());\n  acceptableMethods.add(new GssApiMethod());\n  acceptableMethods.add(new UsernamePasswordMethod());\n}\n", "docstring": "constructs a socks5 instance without any parameter .", "partition": "test"}
{"idx": "3782", "code": "boolean removeViewIfHidden(View view){\n  final int index=mCallback.indexOfChild(view);\n  if (index == -1) {\n    if (mHiddenViews.remove(view) && DEBUG) {\n      throw new IllegalStateException(\"view is in hidden list but not in view group\");\n    }\n    return true;\n  }\n  if (mBucket.get(index)) {\n    mBucket.remove(index);\n    mCallback.removeViewAt(index);\n    if (!mHiddenViews.remove(view) && DEBUG) {\n      throw new IllegalStateException(\"removed a hidden view but it is not in hidden views list\");\n    }\n    return true;\n  }\n  return false;\n}\n", "docstring": "removes a view from the viewgroup if it is hidden .", "partition": "test"}
{"idx": "1743", "code": "public List<String> reset(List<String> replace){\n  ArrayList<String> copy=new ArrayList<String>(retainedVars.size());\n  copy.addAll(retainedVars);\n  retainedVars.clear();\n  if (replace != null) {\n    retainedVars.addAll(replace);\n  }\n  return copy;\n}\n", "docstring": "replaces the list of retained vars with the specified list , returning the old list . if no list is specified then a new empty one is used .", "partition": "test"}
{"idx": "2889", "code": "private List<UserNamespaceAuthorization> createUserNamespaceAuthorizationsFromEntities(List<UserNamespaceAuthorizationEntity> userNamespaceAuthorizationEntities){\n  List<UserNamespaceAuthorization> userNamespaceAuthorizations=new ArrayList<>();\n  for (  UserNamespaceAuthorizationEntity userNamespaceAuthorizationEntity : userNamespaceAuthorizationEntities) {\n    userNamespaceAuthorizations.add(createUserNamespaceAuthorizationFromEntity(userNamespaceAuthorizationEntity));\n  }\n  return userNamespaceAuthorizations;\n}\n", "docstring": "creates a list of user namespace authorizations from the list of persisted entities .", "partition": "test"}
{"idx": "2099", "code": "public static void mergeNodeChildren(TreeNode node){\n  DefaultMutableTreeNode masterNode=(DefaultMutableTreeNode)node;\n  for (int i=0; i < masterNode.getChildCount(); i++) {\n    DefaultMutableTreeNode child=(DefaultMutableTreeNode)masterNode.getChildAt(i);\n    if (!child.isLeaf()) {\n      MergeHelpUtilities.mergeNodeChildren(DEFAULT_MERGE_TYPE,child);\n    }\n  }\n}\n", "docstring": "merge node children . merge the children of a node according to the merging rules of the parent . each subclass must implement this method", "partition": "test"}
{"idx": "476", "code": "public ResourcesPoet addTypedArray(String name,@NotNull List<String> values){\n  Element element=document.createElement(\"array\");\n  element.setAttribute(\"name\",name);\n  for (  String value : values) {\n    Element valueElement=document.createElement(\"item\");\n    valueElement.appendChild(document.createTextNode(value));\n    element.appendChild(valueElement);\n  }\n  resourceElement.appendChild(element);\n  return this;\n}\n", "docstring": "add a typed array to the config", "partition": "test"}
{"idx": "1362", "code": "public SimpleMetricGroup(GroupName name,Stream<? extends Metric> i){\n  this(name,i.collect(Collectors.<Metric>toList()));\n}\n", "docstring": "create a metric group with the given metrics .", "partition": "test"}
{"idx": "744", "code": "public void add(OffsettedItem item){\n  throwIfPrepared();\n  try {\n    if (item.getAlignment() > getAlignment()) {\n      throw new IllegalArgumentException(\"incompatible item alignment\");\n    }\n  }\n catch (  NullPointerException ex) {\n    throw new NullPointerException(\"item == null\");\n  }\n  items.add(item);\n}\n", "docstring": "adds an item to this instance . this will in turn tell the given item that it has been added to this instance . it is invalid to add the same item to more than one instance , nor to add the same items multiple times to a single instance .", "partition": "test"}
{"idx": "1494", "code": "private static void drawShape(GL2 gl,Shape s){\n  PathIterator it=s.getPathIterator(new AffineTransform(),shapeFlatness);\n  float[] lastMoveTo=new float[6];\n  float[] f=new float[6];\n  while (!it.isDone()) {\n    int res=it.currentSegment(f);\nswitch (res) {\ncase PathIterator.SEG_CLOSE:\n      GLPanel.V(gl,lastMoveTo[0],lastMoveTo[1]);\n    break;\ncase PathIterator.SEG_MOVETO:\n  GLPanel.V(gl,f[0],f[1]);\nSystem.arraycopy(f,0,lastMoveTo,0,6);\nbreak;\ncase PathIterator.SEG_LINETO:\nGLPanel.V(gl,f[0],f[1]);\nbreak;\ncase PathIterator.SEG_CUBICTO:\nCubicCurve2D c=new CubicCurve2D.Float(lastMoveTo[0],lastMoveTo[1],f[0],f[1],f[2],f[3],f[4],f[5]);\ndrawShape(gl,c);\nbreak;\ndefault :\nthrow new Error(\"Error while drawing AWT shape. \" + \"Path iterator setment not handled:\" + res);\n}\nit.next();\n}\n}\n", "docstring": "draw the given shape on the given opengl object .", "partition": "test"}
{"idx": "3026", "code": "private static boolean calculateGap(Rectangle a,Rectangle b,Rectangle gap){\n  if (a.intersects(b)) {\n    gap.width=0;\n    return false;\n  }\n  int ax1=a.x;\n  int ax2=a.x + a.width;\n  int ay1=a.y;\n  int ay2=a.y + a.height;\n  int bx1=b.x;\n  int bx2=b.x + b.width;\n  int by1=b.y;\n  int by2=b.y + b.height;\n  int xOverlap=Math.min(ax2,bx2) - Math.max(ax1,bx1);\n  int yOverlap=Math.min(ay2,by2) - Math.max(ay1,by1);\n  if (xOverlap <= 0 && yOverlap <= 0) {\n    gap.width=0;\n    return false;\n  }\n  if (xOverlap > 0) {\n    gap.x=Math.max(ax1,bx1);\n    gap.y=(ay1 > by1) ? by2 : ay2;\n    gap.width=xOverlap;\n    gap.height=-yOverlap;\n  }\n  if (yOverlap > 0) {\n    gap.x=(ax1 > bx1) ? bx2 : ax2;\n    gap.y=Math.max(ay1,by1);\n    gap.width=-xOverlap;\n    gap.height=yOverlap;\n  }\n  return true;\n}\n", "docstring": "calculate the gap rectangle between two rectangles", "partition": "test"}
{"idx": "952", "code": "public void delete(SSOToken token,String dn) throws SMSException, SSOException {\n  for (  String entry : subEntries(token,dn,\"*\",0,false,false)) {\n    debug.message(\"SMSLdapObject: deleting sub-entry: {}\",entry);\n    delete(token,getNamingAttribute() + \"=\" + entry+ \",\"+ dn);\n  }\n  for (  String subOrg : searchSubOrgNames(token,dn,\"*\",0,false,false,false)) {\n    debug.message(\"SMSLdapObject: deleting suborganization: {}\",subOrg);\n    delete(token,subOrg);\n  }\n  delete(token.getPrincipal(),dn);\n  objectChanged(dn,DELETE);\n}\n", "docstring": "delete the entry in the directory . this will delete sub - entries also !", "partition": "test"}
{"idx": "1659", "code": "public void close() throws IOException {\n  if (writer != null)   writer.flushBuffer();\n}\n", "docstring": "done with this responsewriter . . . make sure any buffers are flushed to writer", "partition": "test"}
{"idx": "429", "code": "public void rebuildPanel(){\n  if (activeWorker != null && !activeWorker.isDone()) {\n    activeWorker.cancel(true);\n  }\n  panelImages.removeAll();\n  panelImages.revalidate();\n  scrollPane.repaint();\n  activeWorker=new ImageLoader(mediaFiles);\n  activeWorker.execute();\n}\n", "docstring": "trigger to rebuild the panel", "partition": "test"}
{"idx": "1427", "code": "private void commitLocalTransaction() throws CommitFailedException {\n  if (_tx == null) {\n    return;\n  }\n  if (_logger.isLoggable(Level.FINEST)) {\n    _logger.log(Level.FINEST,\"Committing local transaction: \" + _tx);\n  }\n  try {\n    _tx.commit();\n  }\n catch (  Exception e) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,\"Failed to commit local transaction: \" + _tx,e);\n    }\n    throw new CommitFailedException(e);\n  }\n}\n", "docstring": "commits the local transaction .", "partition": "test"}
{"idx": "4208", "code": "private boolean isRecoverPointInitiator(String portWWN){\n  return portWWN.contains(RECOVERPOINT_INITIATOR_PREFIX);\n}\n", "docstring": "determines if the given port wwn is a recoverpoint initiator .", "partition": "test"}
{"idx": "871", "code": "protected SourceRecords consumeRecordsByTopic(int numRecords) throws InterruptedException {\n  SourceRecords records=new SourceRecords();\n  consumeRecords(numRecords,null);\n  return records;\n}\n", "docstring": "try to consume and capture exactly the specified number of records from the connector .", "partition": "test"}
{"idx": "2525", "code": "Task<Void> synchronizeAllAuthDataAsync(){\n  Map<String,Map<String,String>> authData;\nsynchronized (mutex) {\n    if (!isCurrentUser()) {\n      return Task.forResult(null);\n    }\n    authData=getAuthData();\n  }\n  List<Task<Void>> tasks=new ArrayList<>(authData.size());\n  for (  String authType : authData.keySet()) {\n    tasks.add(synchronizeAuthDataAsync(authType));\n  }\n  return Task.whenAll(tasks);\n}\n", "docstring": "ensures that all auth sources have auth data ( e . g . access tokens , etc . ) that matches this user .", "partition": "test"}
{"idx": "1299", "code": "public JarInfo loadJar() throws IOException {\n  ZipInputStream zis=null;\n  Manifest mf=null;\n  boolean empty=true;\n  try {\n    zis=new ZipInputStream(jarStream);\n    ZipEntry ent=null;\n    while ((ent=zis.getNextEntry()) != null) {\n      empty=false;\n      String name=ent.getName();\n      if (Manifest.isManifestName(name)) {\n        ByteArrayOutputStream baos=new ByteArrayOutputStream();\n        byte buffer[]=new byte[1024];\n        for (; ; ) {\n          int len=zis.read(buffer);\n          if (len < 0) {\n            break;\n          }\n          baos.write(buffer,0,len);\n        }\n        byte[] buf=baos.toByteArray();\n        mf=new Manifest(buf);\n      }\n    }\n  }\n catch (  IOException ex) {\n    throw ex;\n  }\ncatch (  Throwable th) {\n    th.printStackTrace();\n    throw new IOException(\"loadJar caught: \" + th);\n  }\n finally {\n    if (zis != null) {\n      try {\n        zis.close();\n      }\n catch (      Exception ex) {\n      }\n    }\n  }\n  if (empty) {\n    throw new IOException(\"JAR file is corrupt or empty\");\n  }\n  JarInfo ji=createJarInfo(mf);\n  return ji;\n}\n", "docstring": "load the classes , resources , etc .", "partition": "test"}
{"idx": "3161", "code": "@Override public boolean isInsideSoftWrap(@NotNull VisualPosition visual){\n  return isInsideSoftWrap(visual,false);\n}\n", "docstring": "allows to answer if given visual position points to soft wrap - introduced virtual space .", "partition": "test"}
{"idx": "2849", "code": "@Override protected String dateToString(DateTimeData date){\n  StringBuffer message=new StringBuffer(5);\n  message.append('-');\n  message.append('-');\n  append(message,date.month,2);\n  append(message,(char)date.utc,0);\n  return message.toString();\n}\n", "docstring": "converts month object representation to string", "partition": "test"}
{"idx": "3252", "code": "public boolean clear(){\n  try {\n    list.clear();\n    fireTableDataChanged();\n  }\n catch (  Exception e) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "remove all entries from the table list .", "partition": "test"}
{"idx": "1011", "code": "public void put(String sample,HiddenAttribute attribute,Object value){\n  put(sample,attribute.toString(),value);\n}\n", "docstring": "put a value in the table", "partition": "test"}
{"idx": "1365", "code": "public static List<InetAddress> hostAddresses(){\n  List<InetAddress> addrList=new ArrayList<>();\n  Enumeration<NetworkInterface> IFCs=null;\n  try {\n    IFCs=NetworkInterface.getNetworkInterfaces();\n  }\n catch (  SocketException ex) {\n    log.error(\"Unable to get network interfaces.\",ex);\n  }\n  if (IFCs != null) {\n    while (IFCs.hasMoreElements()) {\n      NetworkInterface IFC=IFCs.nextElement();\n      try {\n        if (IFC.isUp()) {\n          Enumeration<InetAddress> addresses=IFC.getInetAddresses();\n          while (addresses.hasMoreElements()) {\n            InetAddress address=addresses.nextElement();\n            if (!address.isLoopbackAddress() && !address.isLinkLocalAddress()) {\n              addrList.add(address);\n            }\n          }\n        }\n      }\n catch (      SocketException ex) {\n        log.error(\"Unable to read network interface {}.\",IFC.toString(),ex);\n      }\n    }\n  }\n  return addrList;\n}\n", "docstring": "a list of the non - loopback , non - link - local ip addresses of the host , or null if none found .", "partition": "test"}
{"idx": "261", "code": "protected void configureFromProperties(InputStream is,String rootDirectory) throws IOException {\n  Properties props=new Properties();\n  props.load(is);\n  props.put(ROOT_DIR_PATH_PROPERTY,rootDirectory);\n  String oldPrefix=getPropertyPrefix();\n  setProperties(null,props);\n  setPropertyPrefix(oldPrefix);\n}\n", "docstring": "called with an input stream for a properties file , used for reading tiles . omp files .", "partition": "test"}
{"idx": "1712", "code": "public static byte[] createDataToSign(byte[] digest){\n  byte[] prefix=getDigestInfoPrefix(digest);\n  byte[] digestInfo=new byte[prefix.length + digest.length];\n  System.arraycopy(prefix,0,digestInfo,0,prefix.length);\n  System.arraycopy(digest,0,digestInfo,prefix.length,digest.length);\n  return digestInfo;\n}\n", "docstring": "creates data to be signed from the digest .", "partition": "test"}
{"idx": "2258", "code": "void start(){\n  this.running=true;\n  Thread thread=new Thread(this,\"IceConnector@\" + hashCode());\n  thread.setDaemon(true);\n  thread.start();\n}\n", "docstring": "start the network listening thread .", "partition": "test"}
{"idx": "776", "code": "private Object findParcel(@NonNull byte[] objectArray,@NonNull String className){\n  try {\n    Class classTmp=getClassForName(className);\n    Constructor declaredConstructor=classTmp.getDeclaredConstructor(Parcel.class);\n    declaredConstructor.setAccessible(true);\n    return declaredConstructor.newInstance(WearBusTools.byteToParcel(objectArray));\n  }\n catch (  Exception e) {\n    Log.d(WearBusTools.BUSWEAR_TAG,\"syncEvent error: \" + e.getMessage());\n  }\n  return null;\n}\n", "docstring": "attempts to locate the class specified by classname to instantiate with the given objectarray", "partition": "test"}
{"idx": "3906", "code": "@Override public void addAttribute(String name,float value){\n  String str=Float.toString(value);\n  if (str.endsWith(\".0\"))   str=str.substring(0,str.length() - 2);\n  current.setAttribute(name,str);\n}\n", "docstring": "adds an attribute to current element of the dom document .", "partition": "test"}
{"idx": "1666", "code": "public void adjustIndentation(int delta){\n  if (delta < 0) {\n    indentationLevel=Math.max(0,indentationLevel + delta);\n  }\n else {\n    indentationLevel+=delta;\n  }\n}\n", "docstring": "adjusts the current indentation level of this log stream .", "partition": "test"}
{"idx": "2824", "code": "public static byte[] hashTwice(byte[] input,int offset,int length){\n  MessageDigest digest=newDigest();\n  digest.update(input,offset,length);\n  return digest.digest(digest.digest());\n}\n", "docstring": "calculates the sha - 256 hash of the given byte range , and then hashes the resulting hash again .", "partition": "test"}
{"idx": "2924", "code": "protected void generateRandomPopulation(int population_size){\n  logger.debug(\"Creating random population\");\n  for (int i=0; i < population_size; i++) {\n    T individual=chromosomeFactory.getChromosome();\n    for (    FitnessFunction<?> fitnessFunction : this.fitnessFunctions) {\n      individual.addFitness(fitnessFunction);\n    }\n    population.add(individual);\n    if (isFinished())     break;\n  }\n  logger.debug(\"Created \" + population.size() + \" individuals\");\n}\n", "docstring": "generate random population of given size", "partition": "test"}
{"idx": "1792", "code": "public static int computeStringWidth(FontMetrics fm,String str){\n  return SwingUtilities2.stringWidth(null,fm,str);\n}\n", "docstring": "compute the width of the string using a font with the specified \" metrics \" ( sizes ) .", "partition": "test"}
{"idx": "2984", "code": "protected void scanCompilationUnits(final List<ICompilationUnit> us) throws IllegalArgumentException, CoreException {\n  progressMonitor.beginTask(\"Iterating over laconizeable compilation units...\",us.size());\n  for (  final ICompilationUnit \u00a2 : us)   scanCompilationUnit(\u00a2,newSubMonitor(progressMonitor));\n  progressMonitor.done();\n}\n", "docstring": "creates a change from each compilation unit and stores it in the changes list", "partition": "test"}
{"idx": "3826", "code": "private double[] CalcVariableCoef(Variogram variogram,KrigingPoint p,List<KrigingPoint> NNPoints){\n  int n=NNPoints.size();\n  double[] mat=new double[n + 1];\n  double dist=0.0;\n  for (int i=0; i < n; i++) {\n    dist=Math.sqrt(Math.abs(Math.pow(NNPoints.get(i).x - p.x,2)) + Math.abs(Math.pow(NNPoints.get(i).y - p.y,2)));\n    mat[i]=getTheoreticalSVValue(dist,variogram);\n  }\n  mat[n]=1;\n  return mat;\n}\n", "docstring": "calculates the d matrix for kriging system", "partition": "test"}
{"idx": "4088", "code": "public boolean addProperty(OwlProperty property){\n  property.addRestriction(this);\n  return properties.add(property);\n}\n", "docstring": "add \" onproperty p \" information , and tell p to point back here .", "partition": "test"}
{"idx": "3374", "code": "public static byte[] readAllLimited(InputStream inStr,int limit) throws IOException {\n  ByteArrayOutputStream buf=new ByteArrayOutputStream();\n  pipeAllLimited(inStr,limit,buf);\n  return buf.toByteArray();\n}\n", "docstring": "read from instr up to a maximum number of bytes , throwing an exception if more the maximum amount of requested data is available .", "partition": "test"}
{"idx": "3941", "code": "@SuppressWarnings(\"unchecked\") public JdbcData(Connection connection,String table,boolean buffered){\n  this.connection=connection;\n  this.table=table;\n  setBuffered(buffered);\n  try {\n    setColumnTypes(getJdbcColumnTypes());\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "initializes a new instance to query the data from a specified table using a specified jdbc connection . it is assumed the table columns are constant during the connection .", "partition": "test"}
{"idx": "1240", "code": "public void write(int c) throws IOException {\n  if (_output == null)   throw new IOException(\"Writer closed\");\n  _output.append((char)c);\n}\n", "docstring": "writes the 16 low - order bits of the given integer value ; the 16 high - order bits are ignored .", "partition": "test"}
{"idx": "2166", "code": "public boolean toFail(){\n  LifecycleState state;\nsynchronized (this) {\n    state=_state;\n    if (state.isAfterDestroying()) {\n      return false;\n    }\n    _state=FAILED;\n    _lastChangeTime=CurrentTime.currentTime();\n  }\n  if (_log != null && _log.isLoggable(_level))   _log.log(_level,\"fail \" + _name);\n  notifyListeners(state,FAILED);\n  _failCount++;\n  return true;\n}\n", "docstring": "changes to the failed state .", "partition": "test"}
{"idx": "3927", "code": "public DiskStoreFactory createDiskStoreFactory(){\n  return new DiskStoreFactoryImpl(this);\n}\n", "docstring": "create diskstore factory with default attributes", "partition": "test"}
{"idx": "1423", "code": "public IdsQueryBuilder addIds(String... ids){\n  values.addAll(Arrays.asList(ids));\n  return this;\n}\n", "docstring": "adds ids to the filter .", "partition": "test"}
{"idx": "3551", "code": "public void addPortToAlreadyAllocatedContext(StoragePort port,StorageHADomain haDomain,StorageSystem.Type arrayType,String switchName){\n  String engine=getEngine(port,haDomain,arrayType);\n  if (engine != null) {\n    _alreadyAllocatedEngines.add(engine);\n  }\n  String directorType=getDirectorType(arrayType,haDomain);\n  if (directorType != null) {\n    _alreadyAllocatedDirectorTypes.add(directorType);\n  }\n  String director=getDirector(port,haDomain);\n  if (director != null) {\n    _alreadyAllocatedDirectors.add(director);\n  }\n  String cpu=getCpu(port,haDomain,arrayType);\n  if (cpu != null) {\n    _alreadyAllocatedCpus.add(cpu);\n  }\n  if (switchName != null) {\n    _alreadyAllocatedSwitches.add(switchName);\n  }\n}\n", "docstring": "allocates existing ports to the already allocated context ( only ) . these ports may be from different networks and are not necessarily part of the pool of ports we can allocate from .", "partition": "test"}
{"idx": "2660", "code": "private void unwrapData() throws IgniteCheckedException, SSLException {\n  if (log.isDebugEnabled())   log.debug(\"Unwrapping received data.\");\n  inNetBuf.flip();\n  SSLEngineResult res=unwrap0();\n  inNetBuf.compact();\n  checkStatus(res);\n  renegotiateIfNeeded(res);\n}\n", "docstring": "unwraps user data to the application buffer .", "partition": "test"}
{"idx": "3879", "code": "public QuickActionView addAction(Action action){\n  checkShown();\n  mActions.add(action);\n  return this;\n}\n", "docstring": "adds an action to the quickactionview", "partition": "test"}
{"idx": "391", "code": "public static void calcTextSize(Paint paint,String demoText,FSize outputFSize){\n  Rect r=mCalcTextSizeRect;\n  r.set(0,0,0,0);\n  paint.getTextBounds(demoText,0,demoText.length(),r);\n  outputFSize.width=r.width();\n  outputFSize.height=r.height();\n}\n", "docstring": "calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )", "partition": "test"}
{"idx": "122", "code": "private void updateVolumeLabels(Volume trustedSrc,Volume invalidTgt){\n  VirtualArray invalidTgtVA=dbClient.queryObject(VirtualArray.class,invalidTgt.getVirtualArray());\n  StringBuilder newLabel=new StringBuilder();\n  newLabel.append(trustedSrc.getLabel());\n  newLabel.append(\"-target-\");\n  newLabel.append(invalidTgtVA.getLabel());\n  log.info(\"Revised name for target: \" + newLabel.toString());\n  invalidTgt.setLabel(newLabel.toString());\n  NamedURI projectURI=invalidTgt.getProject();\n  projectURI.setName(newLabel.toString());\n  invalidTgt.setProject(projectURI);\n  NamedURI tenantURI=invalidTgt.getTenant();\n  tenantURI.setName(newLabel.toString());\n  invalidTgt.setTenant(tenantURI);\n  Volume tgtVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,invalidTgt);\n  if (tgtVplexVolume != null) {\n    Volume srcVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,trustedSrc);\n    if (srcVplexVolume != null) {\n      newLabel.setLength(0);\n      newLabel.append(srcVplexVolume.getLabel());\n      newLabel.append(\"-target-\");\n      newLabel.append(invalidTgtVA.getLabel());\n      log.info(\"Revised name for VPlex target: \" + newLabel.toString());\n      tgtVplexVolume.setLabel(newLabel.toString());\n      projectURI=tgtVplexVolume.getProject();\n      projectURI.setName(newLabel.toString());\n      tgtVplexVolume.setProject(projectURI);\n      tenantURI=tgtVplexVolume.getTenant();\n      tenantURI.setName(newLabel.toString());\n      tgtVplexVolume.setTenant(tenantURI);\n      dbClient.updateAndReindexObject(tgtVplexVolume);\n    }\n  }\n}\n", "docstring": "updates the label field of the invalidtgt , and if the volume is fronted by a vplex volume , also updates the target vplex volume label .", "partition": "test"}
{"idx": "2793", "code": "public void propertyChange(PropertyChangeEvent evt){\n  String name=evt.getPropertyName();\n  if (name == \"width\" || name == \"preferredWidth\") {\n    invalidateWidthCache();\n    fireColumnMarginChanged();\n  }\n}\n", "docstring": "property change listener change method . used to track changes to the column width or preferred column width .", "partition": "test"}
{"idx": "3519", "code": "public final static HeaderElement parseHeaderElement(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=SaveHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  SaveParserCursor cursor=new SaveParserCursor(0,value.length());\n  return parser.parseHeaderElement(buffer,cursor);\n}\n", "docstring": "parses an element with the given parser .", "partition": "test"}
{"idx": "1846", "code": "public static void insertIntoCombo(JComboBox combo,Object item){\n  MutableComboBoxModel model=(MutableComboBoxModel)combo.getModel();\n  if (model.getSize() == 0) {\n    model.insertElementAt(item,0);\n    return;\n  }\n  Object o=model.getElementAt(0);\n  if (o.equals(item)) {\n    return;\n  }\n  model.removeElement(item);\n  model.insertElementAt(item,0);\n  combo.setSelectedIndex(0);\n}\n", "docstring": "insert the given item into the combo box , and set it as first selected item . if the item already exists , it is removed , so there are no duplicates .", "partition": "test"}
{"idx": "823", "code": "private void blackmanHarris4sMin(int size){\n  int start=(windowFunction.length - size) / 2;\n  int stop=(windowFunction.length + size) / 2;\n  double scale=1.0 / (double)size / 0.36;\n  for (int i=0; start < stop; start++, i++)   windowFunction[i]=scale * (0.35875 - 0.48829 * Math.cos(twoPI * i / size) + 0.14128 * Math.cos(2 * twoPI * i / size) - 0.01168 * Math.cos(3 * twoPI * i / size));\n}\n", "docstring": "fill an array with the values of a minimum 4 - sample blackman - harris window function", "partition": "test"}
{"idx": "451", "code": "public void testInvalidXml() throws Exception {\n  testInvalidGpx(INVALID_XML_GPX);\n}\n", "docstring": "test an invalid xml input .", "partition": "test"}
{"idx": "3952", "code": "private void injectContent(Inject injectContent) throws IOException, MojoExecutionException {\n  Map<Pattern,File> contents=getContentsMap(injectContent.getContents());\n  File tmpFile=ioFactory.createTemporaryFile(injectContent.getDestinationFile());\n  BufferedReader reader=null;\n  BufferedWriter writer=null;\n  try {\n    reader=ioFactory.newReader(injectContent.getDestinationFile());\n    writer=ioFactory.newWriter(tmpFile);\n    String line;\n    while ((line=reader.readLine()) != null) {\n      File content=doesLineMatchId(contents,line);\n      if (content != null) {\n        ioFactory.writeContent(writer,content,getContentConverter(injectContent));\n      }\n else {\n        ioFactory.writeLine(writer,line);\n      }\n    }\n  }\n  finally {\n    if (reader != null) {\n      reader.close();\n    }\n    if (writer != null) {\n      writer.flush();\n      writer.close();\n    }\n  }\n  ioFactory.moveTo(tmpFile,injectContent.getDestinationFile());\n}\n", "docstring": "injects the configured content files into the destination file .", "partition": "test"}
{"idx": "2963", "code": "public List<User> loadAllDeepFromCursor(Cursor cursor){\n  int count=cursor.getCount();\n  List<User> list=new ArrayList<User>(count);\n  if (cursor.moveToFirst()) {\n    if (identityScope != null) {\n      identityScope.lock();\n      identityScope.reserveRoom(count);\n    }\n    try {\n      do {\n        list.add(loadCurrentDeep(cursor,false));\n      }\n while (cursor.moveToNext());\n    }\n  finally {\n      if (identityScope != null) {\n        identityScope.unlock();\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "reads all available rows from the given cursor and returns a list of new imageto objects .", "partition": "test"}
{"idx": "1486", "code": "private ArrayList<IconMarker> createIconMarkers(){\n  final ArrayList<IconMarker> iconMarkers=new ArrayList<>(LOCATIONS.length);\n  iconMarkers.add(new IconMarker(LOCATIONS[0],R.drawable.bread,R.drawable.bread_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[1],R.drawable.butcher,R.drawable.butcher_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[2],R.drawable.fruits,R.drawable.fruits_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[3],R.drawable.grocery,R.drawable.grocery_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[4],R.drawable.patisserie,R.drawable.patisserie_c));\n  return iconMarkers;\n}\n", "docstring": "icons courtesy of https : / / mapicons . mapsmarker . com /", "partition": "test"}
{"idx": "1280", "code": "public UUID(long mostSigBits,long leastSigBits){\n  this.mostSigBits=mostSigBits;\n  this.leastSigBits=leastSigBits;\n  init();\n}\n", "docstring": "< p > constructs an instance with the specified bits .", "partition": "test"}
{"idx": "2555", "code": "@Override public boolean domainMatch(final String host,final String domain){\n  return host.endsWith(domain);\n}\n", "docstring": "performs domain - match as described in the netscape draft .", "partition": "test"}
{"idx": "2145", "code": "private String classToEntryPath(Class<?> clazz){\n  String name=\"\";\n  Class<?> parent;\n  while ((parent=clazz.getEnclosingClass()) != null) {\n    name=\"$\" + clazz.getSimpleName() + name;\n    clazz=parent;\n  }\n  return classNameToEntryPath(clazz.getCanonicalName() + name);\n}\n", "docstring": "utility method to get the jar entry path from a class name . e . g . it returns someting like \" com / foo / outerclass $ innerclass1 $ innerclass2 . class \"", "partition": "test"}
{"idx": "1619", "code": "public static <T>T decodeFromBase64(Coder<T> coder,String encodedValue) throws CoderException {\n  return decodeFromSafeStream(coder,new ByteArrayInputStream(Base64.decodeBase64(encodedValue)),Coder.Context.OUTER);\n}\n", "docstring": "parses a value from a base64 - encoded string using the given coder .", "partition": "test"}
{"idx": "2911", "code": "public synchronized void insert(double _priority,Object _data){\n  numElements++;\n  if (numElements == queue.length) {\n    PriorityQueueNode[] tmp=new PriorityQueueNode[(int)(queue.length * 1.5)];\n    System.arraycopy(queue,0,tmp,0,queue.length);\n    for (int i=queue.length; i < tmp.length; i++) {\n      tmp[i]=new PriorityQueueNode();\n    }\n    queue=tmp;\n  }\n  queue[numElements].data=_data;\n  queue[numElements].priority=_priority;\n  reheapify(numElements);\n}\n", "docstring": "insert the object passed with the priority value passed", "partition": "test"}
{"idx": "2560", "code": "@Override public void write(Kryo kryo,Output output){\n  int size=index.size();\n  output.writeInt(size + 1,true);\n  for (int i=0; i < size; ++i) {\n    String s=index.get(i);\n    if (s == null) {\n      throw new RuntimeException(\"Cannot serialize null string at index \" + Integer.toString(i));\n    }\n    output.writeString(s);\n  }\n}\n", "docstring": "custom serializer . follows kryo \"'\" s stringarrayserializer example .", "partition": "test"}
{"idx": "874", "code": "public static boolean isValidVector(Vector2f vector){\n  if (vector == null) {\n    return false;\n  }\n  if (Float.isNaN(vector.x) || Float.isNaN(vector.y)) {\n    return false;\n  }\n  if (Float.isInfinite(vector.x) || Float.isInfinite(vector.y)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .", "partition": "test"}
{"idx": "3166", "code": "private int flush(int offset){\n  try {\n    _os.write(_buffer,0,offset);\n    _offset=0;\n    return 0;\n  }\n catch (  IOException e) {\n    throw new H3ExceptionOut(e);\n  }\n}\n", "docstring": "flush the buffer and set the offset to zero .", "partition": "test"}
{"idx": "3964", "code": "public static String truncate(String string,int length){\n  if (string.length() > length) {\n    string=string.substring(0,length);\n  }\n  return string;\n}\n", "docstring": "sets the maximum length of the string . longer strings will be simply truncated .", "partition": "test"}
{"idx": "2047", "code": "private Object[] unmarshalParametersChecked(DeserializationChecker checker,Method method,MarshalInputStream in) throws IOException, ClassNotFoundException {\n  int callID=methodCallIDCount.getAndIncrement();\n  MyChecker myChecker=new MyChecker(checker,method,callID);\n  in.setStreamChecker(myChecker);\n  try {\n    Class<?>[] types=method.getParameterTypes();\n    Object[] values=new Object[types.length];\n    for (int i=0; i < types.length; i++) {\n      myChecker.setIndex(i);\n      values[i]=unmarshalValue(types[i],in);\n    }\n    myChecker.end(callID);\n    return values;\n  }\n  finally {\n    in.setStreamChecker(null);\n  }\n}\n", "docstring": "unmarshal parameters for the given method of the given instance over the given marshalinputstream . do perform all additional checks .", "partition": "test"}
{"idx": "3278", "code": "public void train(Set<String> sFileNames){\n  Iterator<String> iFile=sFileNames.iterator();\n  while (iFile.hasNext()) {\n    String sText=utils.loadFileToString(iFile.next());\n    train(sText);\n  }\n}\n", "docstring": "train the statistics of the chunker from a given file set .", "partition": "test"}
{"idx": "1555", "code": "public PlaPointInt round_to_the_left(PlaDirection p_dir){\n  PlaPointFloat dir=p_dir.to_float();\n  double rounded_x;\n  if (dir.v_y > 0) {\n    rounded_x=Math.floor(v_x);\n  }\n else   if (dir.v_y < 0) {\n    rounded_x=Math.ceil(v_x);\n  }\n else {\n    rounded_x=Math.round(v_x);\n  }\n  double rounded_y;\n  if (dir.v_x > 0) {\n    rounded_y=Math.ceil(v_y);\n  }\n else   if (dir.v_x < 0) {\n    rounded_y=Math.floor(v_y);\n  }\n else {\n    rounded_y=Math.round(v_y);\n  }\n  return new PlaPointInt(rounded_x,rounded_y);\n}\n", "docstring": "rounds this point , so that if this point is on the left side of any directed line with direction p_dir , the result point will also be on the left side .", "partition": "test"}
{"idx": "3446", "code": "private int convertLocationToColumn(int x,int y){\n  if (cellWidth > 0) {\n    if (layoutOrientation == JList.VERTICAL) {\n      return 0;\n    }\n    Insets insets=list.getInsets();\n    int col;\n    if (isLeftToRight) {\n      col=(x - insets.left) / cellWidth;\n    }\n else {\n      col=(list.getWidth() - x - insets.right- 1) / cellWidth;\n    }\n    if (col < 0) {\n      return 0;\n    }\n else     if (col >= columnCount) {\n      return columnCount - 1;\n    }\n    return col;\n  }\n  return 0;\n}\n", "docstring": "returns the closest column to the passed in location .", "partition": "test"}
{"idx": "1706", "code": "private String excludeDestinationStatement(String text){\n  int idx=-1;\n  if ((idx=text.indexOf(\"Destination will be\")) != -1) {\n    text=text.substring(0,idx);\n  }\n  return text;\n}\n", "docstring": "parses the specified string to return the portion not containing the destination statement . this is needed so that the main text which when parsed , indicates the direction icon that will be used ; will be the only determiner of the associated directions icon . the destination text has other directions which will confuse the parsing which determines the icon . ( i . e . the destination will be on the right ) .", "partition": "test"}
{"idx": "3687", "code": "public ExecutorService shutdown(){\n  pool.shutdown();\n  return pool;\n}\n", "docstring": "shuts down the internal thread pool . if you need to do more a advanced shutdown , the pool is returned .", "partition": "test"}
{"idx": "4261", "code": "@SuppressLint(\"NewApi\") @TargetApi(Build.VERSION_CODES.KITKAT) private static Platform findPlatform(){\n  try {\n    try {\n      Class.forName(\"com.android.org.conscrypt.OpenSSLSocketImpl\");\n    }\n catch (    ClassNotFoundException e) {\n      Class.forName(\"org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl\");\n    }\n    OptionalMethod<Socket> setUseSessionTickets=new OptionalMethod<>(null,\"setUseSessionTickets\",boolean.class);\n    OptionalMethod<Socket> setHostname=new OptionalMethod<>(null,\"setHostname\",String.class);\n    Method trafficStatsTagSocket=null;\n    Method trafficStatsUntagSocket=null;\n    OptionalMethod<Socket> getAlpnSelectedProtocol=null;\n    OptionalMethod<Socket> setAlpnProtocols=null;\n    try {\n      Class<?> trafficStats=Class.forName(\"android.net.TrafficStats\");\n      trafficStatsTagSocket=trafficStats.getMethod(\"tagSocket\",Socket.class);\n      trafficStatsUntagSocket=trafficStats.getMethod(\"untagSocket\",Socket.class);\n      try {\n        Class.forName(\"android.net.Network\");\n        getAlpnSelectedProtocol=new OptionalMethod<>(byte[].class,\"getAlpnSelectedProtocol\");\n        setAlpnProtocols=new OptionalMethod<>(null,\"setAlpnProtocols\",byte[].class);\n      }\n catch (      ClassNotFoundException ignored) {\n      }\n    }\n catch (    ClassNotFoundException|NoSuchMethodException ignored) {\n    }\n    return new Android(setUseSessionTickets,setHostname,trafficStatsTagSocket,trafficStatsUntagSocket,getAlpnSelectedProtocol,setAlpnProtocols);\n  }\n catch (  ClassNotFoundException ignored) {\n  }\n  try {\n    String negoClassName=\"org.eclipse.jetty.alpn.ALPN\";\n    Class<?> negoClass=Class.forName(negoClassName);\n    Class<?> providerClass=Class.forName(negoClassName + \"$Provider\");\n    Class<?> clientProviderClass=Class.forName(negoClassName + \"$ClientProvider\");\n    Class<?> serverProviderClass=Class.forName(negoClassName + \"$ServerProvider\");\n    Method putMethod=negoClass.getMethod(\"put\",SSLSocket.class,providerClass);\n    Method getMethod=negoClass.getMethod(\"get\",SSLSocket.class);\n    Method removeMethod=negoClass.getMethod(\"remove\",SSLSocket.class);\n    return new JdkWithJettyBootPlatform(putMethod,getMethod,removeMethod,clientProviderClass,serverProviderClass);\n  }\n catch (  ClassNotFoundException|NoSuchMethodException ignored) {\n  }\n  return new Platform();\n}\n", "docstring": "attempt to match the host runtime to a capable platform implementation .", "partition": "test"}
{"idx": "3500", "code": "@Override public void modifyNonstaticJPedalParameters(final Map values) throws PdfException {\n  options.set(values);\n  if (values.containsKey(JPedalSettings.DISPLAY_BACKGROUND)) {\n  }\n}\n", "docstring": "allow user to alter certain values in software such as colour , please note all color and text highlighting values are static and common across the jvm", "partition": "test"}
{"idx": "3219", "code": "private static boolean isStartElement(String line){\n  int first=line.lastIndexOf(\"<\");\n  int last=line.lastIndexOf(\">\");\n  if (last < first) {\n    return true;\n  }\n else {\n    int firstEnd=line.lastIndexOf(\"</\");\n    int lastEnd=line.lastIndexOf(\"/>\");\n    if ((firstEnd != first) && ((lastEnd + 1) != last)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "tries to find out if the line finishes with an element start", "partition": "test"}
{"idx": "1841", "code": "public ComponentManager(Collection<Sequence> generalSeeds){\n  Set<Sequence> seedSet=new LinkedHashSet<>(generalSeeds.size());\n  seedSet.addAll(generalSeeds);\n  this.gralSeeds=Collections.unmodifiableSet(seedSet);\n  gralComponents=new SequenceCollection(seedSet);\n}\n", "docstring": "create a component manager , initially populated with the given sequences , which are considered seed sequences .", "partition": "test"}
{"idx": "2931", "code": "public void gotoFrame(int frameNumber) throws IOException {\n  print(\"gotoFrame\",new String[]{Integer.toString(frameNumber)});\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2959", "code": "static boolean causedByRDE(DiskAccessException dae){\n  boolean result=false;\n  if (dae != null) {\n    Throwable cause=dae.getCause();\n    while (cause != null) {\n      if (cause instanceof RegionDestroyedException) {\n        result=true;\n        break;\n      }\n      cause=cause.getCause();\n    }\n  }\n  return result;\n}\n", "docstring": "return true if dae was caused by a regiondestroyedexception . this was added for bug 39603 .", "partition": "test"}
{"idx": "2139", "code": "public boolean isRunning(){\n  return this.running;\n}\n", "docstring": "return whether the stop watch is currently running .", "partition": "test"}
{"idx": "2416", "code": "public synchronized int add(IAudioProcessor processor){\n  processors.add(processor);\n  buildFinalProcessor();\n  return processors.indexOf(processor);\n}\n", "docstring": "adds a processor to the internal processor queue .", "partition": "test"}
{"idx": "662", "code": "private boolean dropInTrash(){\n  if (mHighlightedBlockView != null) {\n    mHighlightedBlockView.setHighlightedConnection(null);\n    mHighlightedBlockView=null;\n  }\n  mDraggedConnections.clear();\n  return mController.trashRootBlock(mPendingDrag.getRootDraggedBlock());\n}\n", "docstring": "ends a drag in the trash can , clearing state and deleting blocks as needed .", "partition": "test"}
{"idx": "1203", "code": "private static final File[] encode(String src){\n  if (src == null || src.length() == 0) {\n    return (new File[0]);\n  }\n  StringTokenizer tokenizer=new StringTokenizer(src,\";\");\n  File[] dirs=new File[tokenizer.countTokens()];\n  for (int i=0; i < dirs.length; i++) {\n    dirs[i]=new File(tokenizer.nextToken());\n  }\n  return dirs;\n}\n", "docstring": "splits the string into an array", "partition": "test"}
{"idx": "2574", "code": "private static boolean isWithinBounds(VisualPosition targetPosition,VisualPosition startPosition,VisualPosition endPosition){\n  return targetPosition.line >= startPosition.line && targetPosition.line <= endPosition.line && targetPosition.column >= startPosition.column && targetPosition.column <= endPosition.column;\n}\n", "docstring": "allows to answer if particular visual position belongs to visual rectangle identified by the given visual position of its top - left and bottom - right corners .", "partition": "test"}
{"idx": "209", "code": "public static long runMultiThreaded(Iterable<Callable<?>> calls,GridTestSafeThreadFactory threadFactory) throws Exception {\n  if (!busyLock.enterBusy())   throw new IllegalStateException(\"Failed to start new threads (test is being stopped).\");\n  Collection<Thread> threads=new ArrayList<>();\n  long time;\n  try {\n    for (    Callable<?> call : calls)     threads.add(threadFactory.newThread(call));\n    time=System.currentTimeMillis();\n    for (    Thread t : threads)     t.start();\n  }\n  finally {\n    busyLock.leaveBusy();\n  }\n  for (  Thread t : threads)   t.join();\n  time=System.currentTimeMillis() - time;\n  threadFactory.checkError();\n  return time;\n}\n", "docstring": "runs callable tasks each in separate threads .", "partition": "test"}
{"idx": "357", "code": "private void runInitScriptIfRequired(String url,Connection connection) throws SQLException {\n  Matcher matcher=INITSCRIPT_MATCHING_PATTERN.matcher(url);\n  if (matcher.matches()) {\n    String initScriptPath=matcher.group(2);\n    try {\n      URL resource=Resources.getResource(initScriptPath);\n      String sql=Resources.toString(resource,Charsets.UTF_8);\n      ScriptUtils.executeSqlScript(connection,initScriptPath,sql);\n    }\n catch (    IOException|IllegalArgumentException e) {\n      LOGGER.warn(\"Could not load classpath init script: {}\",initScriptPath);\n      throw new SQLException(\"Could not load classpath init script: \" + initScriptPath,e);\n    }\ncatch (    ScriptException e) {\n      LOGGER.error(\"Error while executing init script: {}\",initScriptPath,e);\n      throw new SQLException(\"Error while executing init script: \" + initScriptPath,e);\n    }\n  }\n}\n", "docstring": "run an init script from the classpath .", "partition": "test"}
{"idx": "4160", "code": "public IvrZoneset showActiveIvrZoneset() throws NetworkDeviceControllerException {\n  List<IvrZoneset> zonesets=showIvrZonesets(true);\n  return zonesets.isEmpty() ? null : zonesets.get(0);\n}\n", "docstring": "collect the active ivr zoneset , and its zones , members", "partition": "test"}
{"idx": "114", "code": "private static byte[] stringToByteArray(String str){\n  if (str == null) {\n    return null;\n  }\n  byte[] srcByte=str.getBytes();\n  int srcLength=srcByte.length;\n  byte[] result=new byte[srcLength + 1];\n  System.arraycopy(srcByte,0,result,0,srcLength);\n  result[srcLength]=0;\n  return result;\n}\n", "docstring": "returns this java string as a null - terminated byte array", "partition": "test"}
{"idx": "1558", "code": "public SELECT(@NonNull String... columns){\n  if (columns == null) {\n    throw new NullPointerException(\"SELECT: Columns are null\");\n  }\n  if (columns.length == 0)   throw new IllegalArgumentException(\"At least on column is required\");\n  StringBuilder builder=new StringBuilder(\"SELECT \");\n  for (int i=0; i < columns.length; i++) {\n    builder.append(columns[i]);\n    if (i != (columns.length - 1))     builder.append(\", \");\n  }\n  sql=builder.toString();\n}\n", "docstring": "create a < code > select column1 , column2 , . . . from tablename", "partition": "test"}
{"idx": "1960", "code": "public void copyReader(String encoding,Reader r) throws IOException {\n  super.setContentEncoding(encoding);\n  String s=readString(r);\n  content=s.getBytes(encoding);\n}\n", "docstring": "set the content by copying characters from the given reader and converting them into bytes using the specified encoding .", "partition": "test"}
{"idx": "3568", "code": "private Derivation<TK,FV> constructDerivation(Derivation<TK,FV> markedNode,int sourceInputId,FeatureExtractor<TK,FV> featurizer,Scorer<FV> scorer,SearchHeuristic<TK,FV> heuristic,OutputSpace<TK,FV> outputSpace){\n  final List<Derivation<TK,FV>> nodes=new LinkedList<>();\n  Derivation<TK,FV> p=markedNode;\n  while (p != null) {\n    nodes.add(0,p);\n    p=p.parent;\n  }\n  p=markedNode.bestChild;\n  while (p != null) {\n    nodes.add(p);\n    p=p.bestChild;\n  }\n  Derivation<TK,FV> goalHyp=null;\n  for (  Derivation<TK,FV> node : nodes) {\n    goalHyp=goalHyp == null ? node : new Derivation<>(sourceInputId,node.rule,goalHyp.length,goalHyp,featurizer,scorer,heuristic,outputSpace);\n  }\n  return goalHyp;\n}\n", "docstring": "construct a new derivation from a node of interest .", "partition": "test"}
{"idx": "1595", "code": "private String resourceId(){\n  return subSchemaPath.isEmpty() ? null : lastSchemaNodeName();\n}\n", "docstring": "gets the resource id . for root schema config , this will be null . otherwise , it will be the name of the schema type this provider addresses .", "partition": "test"}
{"idx": "188", "code": "protected String buildCreateSchemaStatement() throws ReplicatorException {\n  return null;\n}\n", "docstring": "return a statement that will create the schema , null if no create schema can be given", "partition": "test"}
{"idx": "1010", "code": "public void calcMajorTick(){\n  majorTick=10;\n  majorTickCount=(int)Math.round(log10(maxTick / minTick)) + 1;\n}\n", "docstring": "calculate the optimum major tick distance .", "partition": "test"}
{"idx": "1338", "code": "private List reverse(List seq){\n  LinkedList newSeq=new LinkedList();\n  for (Iterator i=seq.iterator(); i.hasNext(); ) {\n    DirectedEdge de=(DirectedEdge)i.next();\n    newSeq.addFirst(de.getSym());\n  }\n  return newSeq;\n}\n", "docstring": "reverse the sequence . this requires reversing the order of the diredges , and flipping each diredge as well", "partition": "test"}
{"idx": "1142", "code": "private void updateContactHeaderPort(int localPort,SIPMessage message){\n  if (message != null && message.getContactHeader() != null) {\n    ContactHeader contactHeader=message.getContactHeader();\n    Address contactAddress=contactHeader.getAddress();\n    contactAddress.setPort(localPort);\n  }\n}\n", "docstring": "update port of contact header to reflect local port", "partition": "test"}
{"idx": "3618", "code": "@Override public Trie optimize(Trie orig){\n  List<CharSequence> cmds=orig.cmds;\n  List<Row> rows=new ArrayList<>();\n  List<Row> orows=orig.rows;\n  int remap[]=new int[orows.size()];\n  for (int j=orows.size() - 1; j >= 0; j--) {\n    liftUp(orows.get(j),orows);\n  }\n  Arrays.fill(remap,-1);\n  rows=removeGaps(orig.root,orows,new ArrayList<Row>(),remap);\n  return new Trie(orig.forward,remap[orig.root],cmds,rows);\n}\n", "docstring": "optimize ( eliminate rows with no content ) the given trie and return the reduced trie .", "partition": "test"}
{"idx": "530", "code": "private void validateUserNamespaceAuthorizationCreateRequest(UserNamespaceAuthorizationCreateRequest request){\n  Assert.notNull(request,\"A user namespace authorization create request must be specified.\");\n  validateUserNamespaceAuthorizationKey(request.getUserNamespaceAuthorizationKey());\n  validateNamespacePermissions(request.getNamespacePermissions());\n}\n", "docstring": "validates the user namespace authorization create request . this method also trims the request parameters .", "partition": "test"}
{"idx": "1621", "code": "public String add(Object... values){\n  double result=0;\n  for (int i=0; i < values.length; i++) {\n    result+=FunctionHandler.getDouble(values[i]);\n  }\n  return Double.toString(result);\n}\n", "docstring": "adds all values together", "partition": "test"}
{"idx": "2469", "code": "public PropertyXMLBuilder(ServiceSchema serviceSchema,AMModel model,Set attributeSchemas) throws SMSException, SSOException {\n  this.model=model;\n  this.serviceName=serviceSchema.getServiceName();\n  getServiceResourceBundle(serviceSchema);\n  if (serviceBundle != null) {\n    mapTypeToAttributeSchema=new HashMap(attributeSchemas.size() * 2);\n    mapTypeToAttributeSchema.put(NULL_TYPE,attributeSchemas);\n  }\n}\n", "docstring": "returns a xml for displaying attribute in property sheet .", "partition": "test"}
{"idx": "2567", "code": "public void onSinksReceived(String sourceUrn,List<MediaSink> sinks){\n  mSinks.put(sourceUrn,sinks);\n  nativeOnSinksReceived(mNativeMediaRouterAndroid,sourceUrn,sinks.size());\n}\n", "docstring": "called when the sinks found by the media route provider for the particular | sourceurn | have changed .", "partition": "test"}
{"idx": "2075", "code": "private void destroy(){\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(this + \" destroying connection\");\n  }\n  try {\n    _socket.forceShutdown();\n  }\n catch (  Throwable e) {\n  }\n  try {\n    closeConnection();\n  }\n catch (  Throwable e) {\n    log.log(Level.FINER,e.toString(),e);\n  }\n  _port.removeConnection(this);\n}\n", "docstring": "destroy kills the connection and drops it from the connection pool . destroy should only occur if the connection state machine has failed or", "partition": "test"}
{"idx": "1750", "code": "public static final FileTime unixTimeToFileTime(long utime){\n  return FileTime.from(utime,TimeUnit.SECONDS);\n}\n", "docstring": "converts \" standard unix time \" ( in seconds , utc / gmt ) to filetime", "partition": "test"}
{"idx": "1421", "code": "public void mouseEntered(MouseEvent e){\n  if (Debug.debugging(\"mousemodedetail\")) {\n    Debug.output(getID() + \"|NavMouseMode.mouseEntered()\");\n  }\n  super.mouseEntered(e);\n  autoZoom=true;\n}\n", "docstring": "handle a mouseentered mouselistener event . the boolean autozoom is set to true , which will make the delegate ask the map to zoom in to a box that is drawn .", "partition": "test"}
{"idx": "113", "code": "@Override public void releaseLuceePageContext(PageContext pc,boolean register){\n  if (pc.getId() < 0)   return;\n  pc.release();\n  ThreadLocalPageContext.release();\n  runningPcs.remove(Integer.valueOf(pc.getId()));\n  if (pcs.size() < 100 && pc.getRequestTimeoutException() == null)   pcs.push(pc);\n}\n", "docstring": "similar to the releasepagecontext method , but take lucee pagecontext as entry", "partition": "test"}
{"idx": "3328", "code": "private final String _decodeShortUnicodeName(int len) throws IOException, JsonParseException {\n  int outPtr=0;\n  char[] outBuf=_textBuffer.emptyAndGetCurrentSegment();\n  int inPtr=_inputPtr;\n  _inputPtr+=len;\n  final int[] codes=SmileConstants.sUtf8UnitLengths;\n  final byte[] inBuf=_inputBuffer;\n  for (int end=inPtr + len; inPtr < end; ) {\n    int i=inBuf[inPtr++] & 0xFF;\n    int code=codes[i];\n    if (code != 0) {\nswitch (code) {\ncase 1:\n        i=((i & 0x1F) << 6) | (inBuf[inPtr++] & 0x3F);\n      break;\ncase 2:\n    i=((i & 0x0F) << 12) | ((inBuf[inPtr++] & 0x3F) << 6) | (inBuf[inPtr++] & 0x3F);\n  break;\ncase 3:\ni=((i & 0x07) << 18) | ((inBuf[inPtr++] & 0x3F) << 12) | ((inBuf[inPtr++] & 0x3F) << 6)| (inBuf[inPtr++] & 0x3F);\ni-=0x10000;\noutBuf[outPtr++]=(char)(0xD800 | (i >> 10));\ni=0xDC00 | (i & 0x3FF);\nbreak;\ndefault :\n_reportError(\"Invalid byte \" + Integer.toHexString(i) + \" in short Unicode text block\");\n}\n}\noutBuf[outPtr++]=(char)i;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn _textBuffer.contentsAsString();\n}\n", "docstring": "helper method used to decode short unicode string , length for which actual length ( in bytes ) is known", "partition": "test"}
{"idx": "2816", "code": "public void finish() throws IOException {\n  if (!def.finished()) {\n    def.finish();\n    while (!def.finished()) {\n      int len=def.deflate(buf,0,buf.length);\n      if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n        writeTrailer(buf,len);\n        len=len + TRAILER_SIZE;\n        out.write(buf,0,len);\n        return;\n      }\n      if (len > 0)       out.write(buf,0,len);\n    }\n    byte[] trailer=new byte[TRAILER_SIZE];\n    writeTrailer(trailer,0);\n    out.write(trailer);\n  }\n}\n", "docstring": "finishes writing compressed data to the output stream without closing the underlying stream . use this method when applying multiple filters in succession to the same output stream .", "partition": "test"}
{"idx": "452", "code": "public String toString(boolean expand){\n  StringBuilder acc=new StringBuilder();\n  toString(acc,0,expand);\n  return acc.toString();\n}\n", "docstring": "convert a re to a string .", "partition": "test"}
{"idx": "3725", "code": "public MaterialPackage(MaterialPackageBO materialPackageBO,List<GenericTrack> genericTracks){\n  super(materialPackageBO);\n  this.materialPackageBO=materialPackageBO;\n  this.genericTracks=Collections.unmodifiableList(genericTracks);\n}\n", "docstring": "instantiates a new materialpackage object", "partition": "test"}
{"idx": "3035", "code": "public List<Interval> merge(List<Interval> intervals){\n  List<Interval> res=new ArrayList<>();\n  if (intervals == null || intervals.size() == 0) {\n    return res;\n  }\n  Collections.sort(intervals,null);\n  Interval prev=null;\n  for (  Interval i : intervals) {\n    if (prev == null || prev.end < i.start) {\n      res.add(i);\n      prev=i;\n    }\n else     if (i.end > prev.end) {\n      prev.end=i.end;\n    }\n  }\n  return res;\n}\n", "docstring": "sort and merge , o ( nlogn ) time . sort the intervals according to the start value in asc order . for each of the intervals , 1 ) add to result directly if the result list is empty . 2 ) add to result directly if there is no overlap between current interval and previous interval . 3 ) if there is overlap , we already know current interval \"'\" s start is larger than previous interval . we need to update the end of previous interval if current interval \"'\" s end is larger .", "partition": "test"}
{"idx": "1703", "code": "private void writeJavaFieldSpec(JavaFieldSpec spec,Document document,Element parentElement){\n  Element parameter=document.createElement(\"parameter\");\n  parameter.appendChild(parentElement);\n  parameter.setAttribute(\"package\",spec.getPackageName());\n  parameter.setAttribute(\"class\",spec.getClassName());\n  parameter.setAttribute(\"field\",spec.getFieldName());\n}\n", "docstring": "writes out a source / sink specification object for java static fields", "partition": "test"}
{"idx": "1388", "code": "private String createComponentChanges(){\n  StringBuilder builder=new StringBuilder();\n  for (  ServiceCatalogDiff serviceCatalogDiff : diffList) {\n    builder.append(createApiChanges(serviceCatalogDiff));\n  }\n  return builder.toString();\n}\n", "docstring": "construct details of api changes by service and component name", "partition": "test"}
{"idx": "2945", "code": "private Cache createCache() throws CacheException {\n  final Properties props=new Properties();\n  props.setProperty(LOCATORS,\"\");\n  props.setProperty(MCAST_PORT,\"0\");\n  return CacheFactory.create(DistributedSystem.connect(props));\n}\n", "docstring": "creates the cache instance for the test", "partition": "test"}
{"idx": "2855", "code": "public static boolean isMatch(String actualString,LinkedList patterns,char wildCard){\n  boolean matched=false;\n  for (ListIterator iter=patterns.listIterator(0); iter.hasNext(); ) {\n    if (isMatch(actualString,(String)iter.next(),wildCard)) {\n      matched=true;\n      break;\n    }\n  }\n  return matched;\n}\n", "docstring": "check whether the string matches the pattern .", "partition": "test"}
{"idx": "1340", "code": "private void addToScene(final Node items){\n  collection.add(items);\n}\n", "docstring": "adds items to scene , ensuring we are on the fx thread", "partition": "test"}
{"idx": "2961", "code": "public MagicVariablesArgumentsBundle(@NonNull Map<String,String> arguments,@NonNull Map<String,String> variables,String layerName,@NonNull DisplayMetrics metrics){\n  super(arguments,metrics);\n  mVariables=variables;\n  mLayerNamePrefix='@' + layerName.replace('-','_') + '_';\n}\n", "docstring": "create a new simple arguments bundle implementation from provided key - & gt ; value map .", "partition": "test"}
{"idx": "3264", "code": "public void testMergeOneFilterIntoDocumentWithSameFilter() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.mergeFilters(mergeWebXml);\n  assertTrue(WebXmlUtils.hasFilter(srcWebXml,\"f1\"));\n}\n", "docstring": "tests whether a single filter in the merge descriptor is ignored because a filter with the same name already exists in the source descriptor .", "partition": "test"}
{"idx": "1330", "code": "public static void free(DMessage msg){\n  int index=size2Index(msg.getSize());\n  msg.clear();\n  if (index < 0)   ;\n else   if (m_cache[index] != null)   ;\n else   m_cache[index]=msg;\n}\n", "docstring": "put a dmessage into the cache for reuse", "partition": "test"}
{"idx": "2228", "code": "private static Collection<Collection<DsnNetPin>> create_ordered_subnets(Collection<DsnNetPin> p_pin_list){\n  Collection<Collection<DsnNetPin>> result=new LinkedList<Collection<DsnNetPin>>();\n  if (p_pin_list.isEmpty()) {\n    return result;\n  }\n  Iterator<DsnNetPin> it=p_pin_list.iterator();\n  DsnNetPin prev_pin=it.next();\n  while (it.hasNext()) {\n    DsnNetPin next_pin=it.next();\n    Set<DsnNetPin> curr_subnet_pin_list=new java.util.TreeSet<DsnNetPin>();\n    curr_subnet_pin_list.add(prev_pin);\n    curr_subnet_pin_list.add(next_pin);\n    result.add(curr_subnet_pin_list);\n    prev_pin=next_pin;\n  }\n  return result;\n}\n", "docstring": "creates a sequence of subnets with 2 pins from p_pin_list", "partition": "test"}
{"idx": "1936", "code": "public static <O>KNNQuery<O> precomputedKNNQuery(Database database,Relation<O> relation,DistanceQuery<O> dq,int k){\n  KNNQuery<O> knnq=database.getKNNQuery(dq,k,DatabaseQuery.HINT_HEAVY_USE,DatabaseQuery.HINT_OPTIMIZED_ONLY,DatabaseQuery.HINT_NO_CACHE);\n  if (knnq instanceof PreprocessorKNNQuery) {\n    return knnq;\n  }\n  MaterializeKNNPreprocessor<O> preproc=new MaterializeKNNPreprocessor<>(relation,dq.getDistanceFunction(),k);\n  preproc.initialize();\n  return preproc.getKNNQuery(dq,k);\n}\n", "docstring": "get ( or create ) a precomputed knn query for the database .", "partition": "test"}
{"idx": "3897", "code": "private static Pair<String,String> offsetASR(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2,final String immediateNodeValue){\n  final String address=environment.getNextVariableString();\n  final String index=environment.getNextVariableString();\n  final String tmpVar=environment.getNextVariableString();\n  long baseOffset=offset;\n  if (immediateNodeValue.equals(\"0\")) {\n    final String isZeroCondition=environment.getNextVariableString();\n    final String tmpVar1=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dw,registerNodeValue2,wd,String.valueOf(-31),dw,tmpVar1));\n    instructions.add(ReilHelpers.createBisz(baseOffset++,dw,tmpVar1,bt,isZeroCondition));\n    instructions.add(ReilHelpers.createSub(baseOffset++,dw,String.valueOf(0x0L),bt,isZeroCondition,dw,index));\n  }\n else {\n    final String tmpVar1=environment.getNextVariableString();\n    final String tmpVar2=environment.getNextVariableString();\n    final String tmpVar3=environment.getNextVariableString();\n    final String tmpVar4=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue2,dw,String.valueOf(0x80000000L),dw,tmpVar1));\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dw,tmpVar1,dw,\"-\" + immediateNodeValue,dw,tmpVar2));\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dw,String.valueOf(0x80000000L),dw,\"-\" + immediateNodeValue,dw,tmpVar3));\n    instructions.add(ReilHelpers.createSub(baseOffset++,dw,tmpVar2,dw,tmpVar3,qw,tmpVar4));\n    instructions.add(ReilHelpers.createAnd(baseOffset++,qw,tmpVar4,dw,dWordBitMask,dw,index));\n  }\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue1,dw,index,dw,tmpVar));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dw,tmpVar,dw,dWordBitMask,dw,address));\n  return new Pair<String,String>(address,registerNodeValue1);\n}\n", "docstring": "operation : [ < rn > , + / - < rm > , asr # < shift_imm > ", "partition": "test"}
{"idx": "798", "code": "public static void resetIndexBufferTime(){\n  SAFE_QUERY_TIME.set(0);\n}\n", "docstring": "only for test purposes this should not be called from any product code . calls from product code will possibly cause continous reevaluation ( performance issue ) or incorrect query results ( functional issue )", "partition": "test"}
{"idx": "1604", "code": "public Version addQualifier(String qualifier){\n  List<String> newQualifiers=new ArrayList<>(this.qualifiers);\n  newQualifiers.add(qualifier);\n  return new Version(major,minor,patch,newQualifiers.toArray(new String[newQualifiers.size()]));\n}\n", "docstring": "creates a new version object from the current one , but append a new qualifier to it .", "partition": "test"}
{"idx": "3571", "code": "public JDialog displayPanelInWindow(final JPanel panel,String title){\n  JDialog frame=new GenericJDialog();\n  frame.setContentPane(panel);\n  frame.pack();\n  frame.setTitle(title);\n  frame.setVisible(true);\n  return frame;\n}\n", "docstring": "a copy of displaypanel except returning a subclass of window . here to temporarily resolve ongoing conflict between classes using generic frame and classes using window .", "partition": "test"}
{"idx": "1455", "code": "public static boolean isCacheSafe(Class<?> clazz,ClassLoader classLoader){\n  Assert.notNull(clazz,\"Class must not be null\");\n  ClassLoader target=clazz.getClassLoader();\n  if (target == null) {\n    return false;\n  }\n  ClassLoader cur=classLoader;\n  if (cur == target) {\n    return true;\n  }\n  while (cur != null) {\n    cur=cur.getParent();\n    if (cur == target) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "check whether the given class is cache - safe in the given context , i . e . whether it is loaded by the given classloader or a parent of it .", "partition": "test"}
{"idx": "3779", "code": "public void put(ByteBuffer byteBuffer,int contentLength){\n  if (contentLength > (bytes.length - this.contentLength)) {\n    throw new IllegalArgumentException(\"contentLength is too large\");\n  }\n  byteBuffer.get(bytes,this.contentLength,contentLength);\n  this.contentLength+=contentLength;\n}\n", "docstring": "appends content from the specified bytebuffer to this bytearray", "partition": "test"}
{"idx": "3550", "code": "private void checkIfDirectoriesExist(File[] disk_dirs){\n  DiskStoreFactoryImpl.checkIfDirectoriesExist(disk_dirs);\n}\n", "docstring": "checks if directories exist", "partition": "test"}
{"idx": "1048", "code": "public static RowLimitSpec buildRowLimitSpec(EsperEPL2GrammarParser.RowLimitContext ctx){\n  Object numRows;\n  Object offset;\n  if (ctx.o != null) {\n    numRows=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    offset=parseNumOrVariableIdent(ctx.n2,ctx.i2);\n  }\n else   if (ctx.c != null) {\n    offset=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    numRows=parseNumOrVariableIdent(ctx.n2,ctx.i2);\n  }\n else {\n    numRows=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    offset=null;\n  }\n  Integer numRowsInt=null;\n  String numRowsVariable=null;\n  if (numRows instanceof String) {\n    numRowsVariable=(String)numRows;\n  }\n else {\n    numRowsInt=(Integer)numRows;\n  }\n  Integer offsetInt=null;\n  String offsetVariable=null;\n  if (offset instanceof String) {\n    offsetVariable=(String)offset;\n  }\n else {\n    offsetInt=(Integer)offset;\n  }\n  return new RowLimitSpec(numRowsInt,offsetInt,numRowsVariable,offsetVariable);\n}\n", "docstring": "builds a row limit specification .", "partition": "test"}
{"idx": "3575", "code": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  Calendar dateTime=new GregorianCalendar(GMT);\n  long localTime=value;\n  if (tzShift != null) {\n    localTime+=tzShift.longValue() * 60000;\n  }\n  dateTime.setTimeInMillis(localTime);\n  try {\n    appendInt(sb,dateTime.get(Calendar.YEAR),4);\n    sb.append('-');\n    appendInt(sb,dateTime.get(Calendar.MONTH) + 1,2);\n    sb.append('-');\n    appendInt(sb,dateTime.get(Calendar.DAY_OF_MONTH),2);\n    if (!dateOnly) {\n      sb.append('T');\n      appendInt(sb,dateTime.get(Calendar.HOUR_OF_DAY),2);\n      sb.append(':');\n      appendInt(sb,dateTime.get(Calendar.MINUTE),2);\n      sb.append(':');\n      appendInt(sb,dateTime.get(Calendar.SECOND),2);\n      if (dateTime.isSet(Calendar.MILLISECOND)) {\n        sb.append('.');\n        appendInt(sb,dateTime.get(Calendar.MILLISECOND),3);\n      }\n    }\n    if (tzShift != null) {\n      if (tzShift.intValue() == 0) {\n        sb.append('Z');\n      }\n else {\n        int absTzShift=tzShift.intValue();\n        if (tzShift > 0) {\n          sb.append('+');\n        }\n else {\n          sb.append('-');\n          absTzShift=-absTzShift;\n        }\n        int tzHours=absTzShift / 60;\n        int tzMinutes=absTzShift % 60;\n        appendInt(sb,tzHours,2);\n        sb.append(':');\n        appendInt(sb,tzMinutes,2);\n      }\n    }\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    throw new RuntimeException(e);\n  }\n  return sb.toString();\n}\n", "docstring": "formats the value as an xs : date or xs : datetime string .", "partition": "test"}
{"idx": "3434", "code": "public static boolean p2pLoader(ClassLoader ldr){\n  return ldr instanceof GridDeploymentInfo;\n}\n", "docstring": "checks if class loader is an internal p2p class loader .", "partition": "test"}
{"idx": "2869", "code": "public static void addPermissionRecursive(Path path,PosixFilePermission permission) throws IOException {\n  changePermissionsRecursive(path,PermissionChange.ADD,Collections.singleton(permission));\n}\n", "docstring": "recursively adds a permission to a directory .", "partition": "test"}
{"idx": "1019", "code": "protected void acceptDrop(int dropOperation){\n  DropTargetContextPeer peer=getDropTargetContextPeer();\n  if (peer != null) {\n    peer.acceptDrop(dropOperation);\n  }\n}\n", "docstring": "called to signal that the drop is acceptable using the specified operation . must be called during droptargetlistener . drop method invocation . < p >", "partition": "test"}
{"idx": "2382", "code": "private int readSourceToLog(Settings settings){\n  String sourceToLog=settings.get(INDEX_INDEXING_SLOWLOG_MAX_SOURCE_CHARS_TO_LOG,\"1000\");\n  try {\n    return Integer.parseInt(sourceToLog,10);\n  }\n catch (  NumberFormatException e) {\n    return Booleans.parseBoolean(sourceToLog,true) ? Integer.MAX_VALUE : 0;\n  }\n}\n", "docstring": "reads how much of the source to log . the user can specify any value they like and numbers are interpreted the maximum number of characters to log and everything else is interpreted as elasticsearch interprets booleans which is then converted to 0 for false and integer . max_value for true .", "partition": "test"}
{"idx": "2965", "code": "public static Document createDOM(InputStream is) throws ParserConfigurationException, SAXException, IOException {\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  dbf.setValidating(false);\n  dbf.setIgnoringComments(false);\n  dbf.setIgnoringElementContentWhitespace(true);\n  dbf.setNamespaceAware(true);\n  dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,true);\n  dbf.setFeature(DISALLOW_DOCTYPE_DECL,true);\n  dbf.setFeature(EXTERNAL_GENERAL_ENTITIES,false);\n  dbf.setFeature(EXTERNAL_PARAMETER_ENTITIES,false);\n  dbf.setFeature(LOAD_EXTERNAL_DTD,false);\n  DocumentBuilder db=null;\n  db=dbf.newDocumentBuilder();\n  db.setEntityResolver(new NullResolver());\n  db.setErrorHandler(new SamlParserErrorHandler());\n  return db.parse(is);\n}\n", "docstring": "create dom from iostream .", "partition": "test"}
{"idx": "438", "code": "protected void initForecastErrors(ArrayList<Float> model,TimeSeries.DataSequence data){\n  double sumErr=0.0;\n  double sumAbsErr=0.0;\n  double sumAbsPercentErr=0.0;\n  double sumErrSquared=0.0;\n  int processedPoints=0;\n  int n=data.size();\n  for (int i=0; i < n; i++) {\n    double error=model.get(i) - data.get(i).value;\n    sumErr+=error;\n    sumAbsErr+=Math.abs(error);\n    sumAbsPercentErr+=Math.abs(error / data.get(i).value);\n    sumErrSquared+=error * error;\n    processedPoints++;\n  }\n  this.bias=sumErr / processedPoints;\n  this.mad=sumAbsErr / processedPoints;\n  this.mape=sumAbsPercentErr / processedPoints;\n  this.mse=sumErrSquared / processedPoints;\n  this.sae=sumAbsErr;\n  errorsInit=true;\n}\n", "docstring": "initializes all errors given the model .", "partition": "test"}
{"idx": "1015", "code": "public Shape greatCircleLineShape(){\n  GeneralPath path=null;\n  if (llpts != null && llpts.length >= 4 && llpts.length % 2 == 0) {\n    double y1=llpts[0];\n    double x1=llpts[1];\n    path=new GeneralPath(GeneralPath.WIND_EVEN_ODD,llpts.length / 2);\n    boolean firstCoords=true;\n    for (int i=2; i < llpts.length; i+=2) {\n      double y2=llpts[i];\n      double x2=llpts[i + 1];\n      double radDist=GreatCircle.sphericalDistance(y1,x1,y2,x2);\n      int nsegs=(int)(ProjMath.radToDeg(radDist) * segsPerDeg);\n      if (nsegs == 0) {\n        nsegs=1;\n      }\n      double[] coords=GreatCircle.greatCircle(y1,x1,y2,x2,nsegs,false);\n      if (returnDegrees) {\n        ProjMath.arrayRadToDeg(coords);\n      }\n      for (int j=0; j <= coords.length - 1; j+=2) {\n        if (firstCoords) {\n          path.moveTo(coords[j + 1],coords[j]);\n          firstCoords=false;\n        }\n else {\n          path.lineTo(coords[j + 1],coords[j]);\n        }\n      }\n      x1=x2;\n      y1=y2;\n    }\n    if (returnDegrees) {\n      path.lineTo(ProjMath.radToDeg(x1),ProjMath.radToDeg(y1));\n    }\n else {\n      path.lineTo(x1,y1);\n    }\n  }\n  return path;\n}\n", "docstring": "create a java . awt . shape object of coordinates connected by great circle lines .", "partition": "test"}
{"idx": "3350", "code": "public void addRam(AttackAction ea){\n  pendingRams.addElement(ea);\n  processGameEvent(new GameNewActionEvent(this,ea));\n}\n", "docstring": "adds a pending ramming attack to the list for this phase .", "partition": "test"}
{"idx": "217", "code": "public boolean canRead(){\n  return _is != null;\n}\n", "docstring": "returns true if there \"'\" s an associated file .", "partition": "test"}
{"idx": "3280", "code": "public PrintfFormat(String fmtArg) throws IllegalArgumentException {\n  this(Locale.getDefault(),fmtArg);\n}\n", "docstring": "constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings . control strings begin with unpaired percent signs . a pair of successive percent signs designates a single percent sign in the format .", "partition": "test"}
{"idx": "1745", "code": "public synchronized void deleteAllTables(){\n  List<String> tableNames=new ArrayList<String>(tableLookup.keySet());\n  for (  String s : tableNames) {\n    deleteTable(s);\n  }\n}\n", "docstring": "delete all tables from this database .", "partition": "test"}
{"idx": "2565", "code": "protected final void fireVetoableChange(String propertyName,double oldValue,double newValue) throws PropertyVetoException {\n  fireVetoableChange(propertyName,Double.valueOf(oldValue),Double.valueOf(newValue));\n}\n", "docstring": "support for reporting changes for constrained integer properties . this method can be called before a constrained property will be changed and it will send the appropriate propertychangeevent to any registered vetoablechangelisteners .", "partition": "test"}
{"idx": "3998", "code": "public SpecificationRunnerBuilder sections(String[] paramSections){\n  Collections.addAll(this.sections,paramSections);\n  return this;\n}\n", "docstring": "you can add sections to filter the input specification , so livingdoc will only execute the specified sections .", "partition": "test"}
{"idx": "2211", "code": "private String appendNationalNumber(String nationalNumber){\n  int prefixBeforeNationalNumberLength=prefixBeforeNationalNumber.length();\n  if (shouldAddSpaceAfterNationalPrefix && prefixBeforeNationalNumberLength > 0 && prefixBeforeNationalNumber.charAt(prefixBeforeNationalNumberLength - 1) != SEPARATOR_BEFORE_NATIONAL_NUMBER) {\n    return new String(prefixBeforeNationalNumber) + SEPARATOR_BEFORE_NATIONAL_NUMBER + nationalNumber;\n  }\n else {\n    return prefixBeforeNationalNumber + nationalNumber;\n  }\n}\n", "docstring": "combines the national number with any prefix ( idd / + and country code or national prefix ) that was collected . a space will be inserted between them if the current formatting template indicates this to be suitable .", "partition": "test"}
{"idx": "3311", "code": "public void removeListeners(){\n  if (globalListener != null) {\n    try {\n      InvokerHelper.invokeMethod(currentObject,\"removePropertyChangeListener\",globalListener);\n    }\n catch (    Exception e) {\n    }\n    globalListener=null;\n  }\n  if (localListener != null) {\n    try {\n      InvokerHelper.invokeMethod(currentObject,\"removePropertyChangeListener\",new Object[]{propertyName,localListener});\n    }\n catch (    Exception e) {\n    }\n    localListener=null;\n  }\n  if (syntheticFullBinding != null) {\n    syntheticFullBinding.unbind();\n  }\n}\n", "docstring": "remove listeners , believing that our bould flags are accurate and it removes only as declared .", "partition": "test"}
{"idx": "1382", "code": "public void add(final T object){\nsynchronized (mLock) {\n    mList.add(object);\n  }\n  notifyDataSetChanged();\n}\n", "docstring": "adds the specified object at the end of the array .", "partition": "test"}
{"idx": "80", "code": "private boolean isFieldPackagePrivate(Element attribute){\n  Set<Modifier> modifiers=attribute.getModifiers();\n  return !modifiers.contains(PUBLIC) && !modifiers.contains(PROTECTED) && !modifiers.contains(PRIVATE);\n}\n", "docstring": "checks if the given field has package - private visibility", "partition": "test"}
{"idx": "3658", "code": "private void fetchMetadata(TableMapLogEvent tableEvent) throws SQLException, ReplicatorException {\n  if (metadataCache == null)   metadataCache=new TableMetadataCache(5000);\n  Table table=metadataCache.retrieve(tableEvent.getDatabaseName(),tableEvent.getTableName());\n  if (table == null || table.getTableId() != tableEvent.getTableId()) {\n    prepareMetadataConnection();\n    table=metadataConnection.findTable(tableEvent.getDatabaseName(),tableEvent.getTableName(),false);\n    if (table != null) {\n      table.setTableId(tableEvent.getTableId());\n      metadataCache.store(table);\n    }\n  }\n else   if (logger.isDebugEnabled())   logger.debug(\"Table \" + tableEvent.getDatabaseName() + \".\"+ tableEvent.getTableName()+ \" found in cache.\");\n  if (table == null) {\n    logger.warn(\"No metadata found for table \" + tableEvent.getDatabaseName() + \".\"+ tableEvent.getTableName());\n  }\n else {\n    tableEvent.setTable(table);\n  }\n}\n", "docstring": "fetches metadata for the table from the cache or from the database if needed", "partition": "test"}
{"idx": "1784", "code": "public static <E>E syncRest(final Iterator<? extends Object> iterator,final Callable<E> task) throws Exception {\n  if (iterator.hasNext()) {\nsynchronized (iterator.next()) {\n      return syncRest(iterator,task);\n    }\n  }\n else {\n    return task.call();\n  }\n}\n", "docstring": "recursively synchronizes on the components in the provided iterator and executes the provided task if there are no more components .", "partition": "test"}
{"idx": "3935", "code": "@Override public void drawRangeMarker(Graphics2D g2,CategoryPlot plot,ValueAxis axis,Marker marker,Rectangle2D dataArea){\n  if (marker instanceof ValueMarker) {\n    ValueMarker vm=(ValueMarker)marker;\n    double value=vm.getValue();\n    Range range=axis.getRange();\n    if (!range.contains(value)) {\n      return;\n    }\n    final Composite savedComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    PlotOrientation orientation=plot.getOrientation();\n    double v=axis.valueToJava2D(value,dataArea,plot.getRangeAxisEdge());\n    Line2D line=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      line=new Line2D.Double(v,dataArea.getMinY(),v,dataArea.getMaxY());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      line=new Line2D.Double(dataArea.getMinX(),v,dataArea.getMaxX(),v);\n    }\n else {\n      throw new IllegalStateException();\n    }\n    g2.setPaint(marker.getPaint());\n    g2.setStroke(marker.getStroke());\n    g2.draw(line);\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coordinates=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,line.getBounds2D(),marker.getLabelOffset(),LengthAdjustmentType.EXPAND,anchor);\n      Rectangle2D rect=TextUtils.calcAlignedStringBounds(label,g2,(float)coordinates.getX(),(float)coordinates.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(rect);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtils.drawAlignedString(label,g2,(float)coordinates.getX(),(float)coordinates.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(savedComposite);\n  }\n else   if (marker instanceof IntervalMarker) {\n    IntervalMarker im=(IntervalMarker)marker;\n    double start=im.getStartValue();\n    double end=im.getEndValue();\n    Range range=axis.getRange();\n    if (!(range.intersects(start,end))) {\n      return;\n    }\n    final Composite savedComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    double start2d=axis.valueToJava2D(start,dataArea,plot.getRangeAxisEdge());\n    double end2d=axis.valueToJava2D(end,dataArea,plot.getRangeAxisEdge());\n    double low=Math.min(start2d,end2d);\n    double high=Math.max(start2d,end2d);\n    PlotOrientation orientation=plot.getOrientation();\n    Rectangle2D rect=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      low=Math.max(low,dataArea.getMinX());\n      high=Math.min(high,dataArea.getMaxX());\n      rect=new Rectangle2D.Double(low,dataArea.getMinY(),high - low,dataArea.getHeight());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      low=Math.max(low,dataArea.getMinY());\n      high=Math.min(high,dataArea.getMaxY());\n      rect=new Rectangle2D.Double(dataArea.getMinX(),low,dataArea.getWidth(),high - low);\n    }\n    Paint p=marker.getPaint();\n    if (p instanceof GradientPaint) {\n      GradientPaint gp=(GradientPaint)p;\n      GradientPaintTransformer t=im.getGradientPaintTransformer();\n      if (t != null) {\n        gp=t.transform(gp,rect);\n      }\n      g2.setPaint(gp);\n    }\n else {\n      g2.setPaint(p);\n    }\n    g2.fill(rect);\n    if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n      if (orientation == PlotOrientation.VERTICAL) {\n        Line2D line=new Line2D.Double();\n        double x0=dataArea.getMinX();\n        double x1=dataArea.getMaxX();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(x0,start2d,x1,start2d);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(x0,end2d,x1,end2d);\n          g2.draw(line);\n        }\n      }\n else {\n        Line2D line=new Line2D.Double();\n        double y0=dataArea.getMinY();\n        double y1=dataArea.getMaxY();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(start2d,y0,start2d,y1);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(end2d,y0,end2d,y1);\n          g2.draw(line);\n        }\n      }\n    }\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,rect,marker.getLabelOffset(),marker.getLabelOffsetType(),anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(savedComposite);\n  }\n}\n", "docstring": "draws a marker for the range axis .", "partition": "test"}
{"idx": "3202", "code": "private String readUntil(char[] delimiter,boolean returnText) throws IOException, XmlPullParserException {\n  int start=position;\n  StringBuilder result=null;\n  if (returnText && text != null) {\n    result=new StringBuilder();\n    result.append(text);\n  }\n  search:   while (true) {\n    if (position + delimiter.length > limit) {\n      if (start < position && returnText) {\n        if (result == null) {\n          result=new StringBuilder();\n        }\n        result.append(buffer,start,position - start);\n      }\n      if (!fillBuffer(delimiter.length)) {\n        checkRelaxed(UNEXPECTED_EOF);\n        type=COMMENT;\n        return null;\n      }\n      start=position;\n    }\n    for (int i=0; i < delimiter.length; i++) {\n      if (buffer[position + i] != delimiter[i]) {\n        position++;\n        continue search;\n      }\n    }\n    break;\n  }\n  int end=position;\n  position+=delimiter.length;\n  if (!returnText) {\n    return null;\n  }\n else   if (result == null) {\n    return stringPool.get(buffer,start,end - start);\n  }\n else {\n    result.append(buffer,start,end - start);\n    return result.toString();\n  }\n}\n", "docstring": "reads text until the specified delimiter is encountered . consumes the text and the delimiter .", "partition": "test"}
{"idx": "1068", "code": "public static void assertLabel(int[] path,String text){\n  if (verbose) {\n    log(\"assertLabel(\" + toString(path) + \", \"+ text+ \")\");\n  }\n  Label l=(Label)getComponentByPath(path);\n  assertBool(l != null,\"Null label\" + text);\n  assertBool(text == l.getText() || text.equals(l.getText()),(\"\" + l.getText()) + \" != \" + text);\n}\n", "docstring": "asserts that we have a label with the given text baring the given name", "partition": "test"}
{"idx": "176", "code": "public List<String> splitStringWithDefaultDelimiterEscaped(String inputString){\n  String delimiter=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER);\n  String escapeChar=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER_ESCAPE_CHAR);\n  List<String> splitString=new ArrayList<>();\n  if (StringUtils.isNotBlank(inputString)) {\n    String regex=\"(?<!\" + Pattern.quote(escapeChar) + \")\"+ Pattern.quote(delimiter);\n    for (    String s : inputString.split(regex)) {\n      splitString.add(s.replace(escapeChar + delimiter,delimiter));\n    }\n  }\n  return splitString;\n}\n", "docstring": "splits the input string based on the default delimiter , and also escapes delimiter .", "partition": "test"}
{"idx": "523", "code": "@Override public boolean isComplete(){\n  return true;\n}\n", "docstring": "test if the profile is complete .", "partition": "test"}
{"idx": "2222", "code": "public static void writeResultToFile(Result result,String fname) throws Exception {\n  PrintWriter outer=new PrintWriter(new BufferedWriter(new FileWriter(fname)));\n  outer.write(result.toString());\n  outer.close();\n}\n", "docstring": "writeresulttofile - - write a result \"'\" result \"'\" out in plain text format to file \"'\" fname \"'\" .", "partition": "test"}
{"idx": "384", "code": "public static GridField[] createFields(Properties ctx,int WindowNo,int TabNo,int AD_Tab_ID){\n  ArrayList<GridFieldVO> listVO=new ArrayList<GridFieldVO>();\n  int AD_Window_ID=0;\n  boolean readOnly=false;\n  String sql=GridFieldVO.getSQL(ctx);\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,AD_Tab_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      GridFieldVO vo=GridFieldVO.create(ctx,WindowNo,TabNo,AD_Window_ID,AD_Tab_ID,readOnly,rs);\n      listVO.add(vo);\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n  GridField[] retValue=new GridField[listVO.size()];\n  for (int i=0; i < listVO.size(); i++)   retValue[i]=new GridField((GridFieldVO)listVO.get(i));\n  return retValue;\n}\n", "docstring": "create fields . used by apanel . cmd_find and viewer . cmd_find", "partition": "test"}
{"idx": "1459", "code": "public Subscription register(Object mBean,MBeanDescription description){\n  return register(mBean,description.getMBeanName(getNextId()));\n}\n", "docstring": "register the given mbean based on the given description", "partition": "test"}
{"idx": "3425", "code": "public boolean writeCharacteristic(String address,String serviceUUID,String characteristicUUID,byte[] value){\n  BluetoothGatt bluetoothGatt=mBluetoothGattMap.get(address);\n  if (bluetoothGatt != null) {\n    BluetoothGattService service=bluetoothGatt.getService(UUID.fromString(serviceUUID));\n    BluetoothGattCharacteristic characteristic=service.getCharacteristic(UUID.fromString(characteristicUUID));\n    characteristic.setValue(value);\n    return bluetoothGatt.writeCharacteristic(characteristic);\n  }\n  return false;\n}\n", "docstring": "write data to characteristic , and send to remote bluetooth le device .", "partition": "test"}
{"idx": "4231", "code": "void writeLine(BufferedWriter writer,String line) throws IOException {\n  writer.write(line);\n  writer.newLine();\n}\n", "docstring": "writes the given line with the given writer , followed by a new line .", "partition": "test"}
{"idx": "1912", "code": "public static Colour attemptToGetAsColour(String part){\n  Colour col=null;\n  try {\n    col=Colour.valueOf(part.toUpperCase());\n  }\n catch (  Exception e) {\n  }\n  return col;\n}\n", "docstring": "attempt to parse string as a colour", "partition": "test"}
{"idx": "1593", "code": "protected char skipAllWhitespace(Reader r) throws IOException {\n  char c;\n  do {\n    c=(char)r.read();\n  }\n while (Character.isWhitespace(c) && c != (char)-1);\n  return c;\n}\n", "docstring": "skips all consecutive whitespace characters from reader", "partition": "test"}
{"idx": "730", "code": "public ListenableFuture<String> push(final String name,final Expression func){\n  String let=String.format(\"let %s = %s\",name,func.toHaskell());\n  return pullRaw(let);\n}\n", "docstring": "uploads a new let binding to ghci", "partition": "test"}
{"idx": "4212", "code": "private int calculatePreferredWrapPosition(@NotNull Editor editor,@NotNull CharSequence text,int tabSize,int spaceSize,int startLineOffset,int endLineOffset,int targetRangeEndOffset){\n  boolean hasTabs=false;\n  boolean canOptimize=true;\n  boolean hasNonSpaceSymbols=false;\n  loop:   for (int i=startLineOffset; i < Math.min(endLineOffset,targetRangeEndOffset); i++) {\n    char c=text.charAt(i);\nswitch (c) {\ncase '\\\\t':\n{\n        hasTabs=true;\n        if (hasNonSpaceSymbols) {\n          canOptimize=false;\n          break loop;\n        }\n      }\ncase ' ':\n    break;\ndefault :\n  hasNonSpaceSymbols=true;\n}\n}\nif (!hasTabs) {\nreturn wrapPositionForTextWithoutTabs(startLineOffset,endLineOffset,targetRangeEndOffset);\n}\n else if (canOptimize) {\nreturn wrapPositionForTabbedTextWithOptimization(text,tabSize,startLineOffset,endLineOffset,targetRangeEndOffset);\n}\n else {\nreturn wrapPositionForTabbedTextWithoutOptimization(editor,text,spaceSize,startLineOffset,endLineOffset,targetRangeEndOffset);\n}\n}\n", "docstring": "checks if it \"'\" s worth to try to wrap target line ( it \"'\" s long enough ) and tries to calculate preferred wrap position .", "partition": "test"}
{"idx": "1038", "code": "public DViewAsymmetricKeyFields(JDialog parent,String title,RSAPublicKey rsaPublicKey){\n  super(parent,title,Dialog.ModalityType.DOCUMENT_MODAL);\n  key=rsaPublicKey;\n  initFields();\n}\n", "docstring": "creates new dviewasymmetrickeyfields dialog .", "partition": "test"}
{"idx": "2003", "code": "@Override public Result doComparisonTest(final Properties properties) throws Exception {\n  final long timeout=Long.parseLong(properties.getProperty(TestOptions.TIMEOUT));\n  final int nresources=Integer.parseInt(properties.getProperty(TestOptions.NRESOURCES));\n  final int minLocks=Integer.parseInt(properties.getProperty(TestOptions.MIN_LOCKS));\n  final int maxLocks=Integer.parseInt(properties.getProperty(TestOptions.MAX_LOCKS));\n  final int ntrials=Integer.parseInt(properties.getProperty(TestOptions.NTRIALS));\n  final int keyLen=Integer.parseInt(properties.getProperty(TestOptions.KEYLEN));\n  final int nops=Integer.parseInt(properties.getProperty(TestOptions.NOPS));\n  final double failureRate=Double.parseDouble(properties.getProperty(TestOptions.FAILURE_RATE));\n  Result result=doConcurrentClientTest(journal,timeout,nresources,minLocks,maxLocks,ntrials,keyLen,nops,failureRate);\n  return result;\n}\n", "docstring": "setup and run a test .", "partition": "test"}
{"idx": "1952", "code": "private Collection<String> readProcessOutput(Process proc) throws IOException {\n  BufferedReader rdr=new BufferedReader(new InputStreamReader(proc.getInputStream()));\n  Collection<String> res=new ArrayList<>();\n  String s;\n  while ((s=rdr.readLine()) != null)   res.add(s);\n  return res;\n}\n", "docstring": "reads process output line - by - line .", "partition": "test"}
{"idx": "4131", "code": "private void scoreTrackResults(Collection<Track> tracks,SearchQuery query,Collection<ScoredResult> output){\n  for (  Track track : tracks) {\n    double score=scoreTrackResult(query,track);\n    output.add(new ScoredResult(track,score));\n  }\n}\n", "docstring": "scores a collection of track results .", "partition": "test"}
{"idx": "2110", "code": "public AbstractSurfaceObject(AbstractSurfaceObject source){\n  super(source);\n  this.visible=source.visible;\n  this.uniqueId=nextUniqueId();\n  this.lastModifiedTime=System.currentTimeMillis();\n  this.enableBatchPicking=source.enableBatchPicking;\n}\n", "docstring": "creates a shallow copy of the specified source shape .", "partition": "test"}
{"idx": "2170", "code": "List<Entry> killAll(boolean rootIncluded){\n  List<Entry> killed=new ArrayList<>(rootIncluded ? entries.size() : entries.size() - 1);\n  Entry entry;\n  for (int i=entries.size() - 1; i > (rootIncluded ? -1 : 0); i--) {\n    entry=entries.get(i);\n    if (entry.dead)     continue;\n    entry.dead=true;\n    if (i != 0) {\n      killed.add(entry);\n    }\n  }\n  return killed;\n}\n", "docstring": "kill all , including root or not the returned entries don \"'\" t include the root entry though", "partition": "test"}
{"idx": "2049", "code": "void drawIcon(Graphics g,int ax,int ay,int aw,int ah,float align,Component c){\n  int gap=isLeftToRight ? -(img.getIconWidth() + bulletgap) : (aw + bulletgap);\n  int x=ax + gap;\n  int y=Math.max(ay,ay + (int)(align * ah) - img.getIconHeight());\n  img.paintIcon(c,g,x,y);\n}\n", "docstring": "draws the bullet icon specified by the list - style - image argument .", "partition": "test"}
{"idx": "1823", "code": "public void addNetworkListener(final NetworkListener listener){\n  networkListeners.add(listener);\n}\n", "docstring": "register a network listener .", "partition": "test"}
{"idx": "877", "code": "public boolean remove(Object targetChild){\n  return remove(targetChild,true);\n}\n", "docstring": "removes a child from this beancontext . if the child object is not for adding then this method throws an illegalstateexception .", "partition": "test"}
{"idx": "943", "code": "public void writeToFile(String filename){\n  GridUtils.writeSpatialGridTable(this,filename);\n}\n", "docstring": "just for debugging convenience", "partition": "test"}
{"idx": "3804", "code": "public void unassignServices(String universalId,Set serviceNames) throws AMConsoleException {\n  if ((serviceNames != null) && !serviceNames.isEmpty()) {\n    String[] params=new String[2];\n    params[0]=universalId;\n    String currentSvc=\"\";\n    try {\n      AMIdentity amid=IdUtils.getIdentity(getUserSSOToken(),universalId);\n      for (Iterator iter=serviceNames.iterator(); iter.hasNext(); ) {\n        currentSvc=(String)iter.next();\n        params[1]=currentSvc;\n        logEvent(\"ATTEMPT_IDENTITY_UNASSIGN_SERVICE\",params);\n        amid.unassignService(currentSvc);\n        logEvent(\"SUCCEED_IDENTITY_UNASSIGN_SERVICE\",params);\n      }\n    }\n catch (    SSOException e) {\n      String[] paramsEx={universalId,currentSvc,getErrorString(e)};\n      logEvent(\"SSO_EXCEPTION_IDENTITY_UNASSIGN_SERVICE\",paramsEx);\n      debug.warning(\"EntitiesModelImpl.unassignServices\",e);\n      throw new AMConsoleException(getErrorString(e));\n    }\ncatch (    IdRepoException e) {\n      String[] paramsEx={universalId,currentSvc,getErrorString(e)};\n      logEvent(\"IDM_EXCEPTION_IDENTITY_UNASSIGN_SERVICE\",paramsEx);\n      debug.warning(\"EntitiesModelImpl.unassignServices\",e);\n      throw new AMConsoleException(getErrorString(e));\n    }\n  }\n}\n", "docstring": "unassigns services from an entity .", "partition": "test"}
{"idx": "2111", "code": "public SootMethodAndClass parseSootMethodString(String parseString){\n  if (!parseString.startsWith(\"<\") || !parseString.endsWith(\">\")) {\n    throw new IllegalArgumentException(\"Illegal format of \" + parseString + \" (should use soot method representation)\");\n  }\n  String name=\"\";\n  String className=\"\";\n  String returnType=\"\";\n  Pattern pattern=Pattern.compile(\"<(.*?):\");\n  Matcher matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    className=matcher.group(1);\n  }\n  pattern=Pattern.compile(\": (.*?) \");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    returnType=matcher.group(1);\n    parseString=parseString.substring(matcher.end(1));\n  }\n  pattern=Pattern.compile(\" (.*?)\\\\\\\\(\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    name=matcher.group(1);\n  }\n  List<String> paramList=new ArrayList<String>();\n  pattern=Pattern.compile(\"\\\\\\\\((.*?)\\\\\\\\)\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    String params=matcher.group(1);\n    for (    String param : params.split(\",\"))     paramList.add(param.trim());\n  }\n  return new SootMethodAndClass(name,className,returnType,paramList);\n}\n", "docstring": "parses a string in soot representation , for example : < soot . jimple . infoflow . test . testnomain : java . lang . string function1 ( ) > < soot . jimple . infoflow . test . testnomain : void functioncallonobject ( ) > < soot . jimple . infoflow . test . testnomain : java . lang . string function2 ( java . lang . string , java . lang . string ) >", "partition": "test"}
{"idx": "1262", "code": "@Override public void onFailure(IMqttToken asyncActionToken,Throwable exception){\n  exception.printStackTrace();\n  Log.e(\"TrafficService\",\"Error connecting: \" + exception.getMessage());\n  onDisconnect(false);\n}\n", "docstring": "called when there was an error connecting", "partition": "test"}
{"idx": "327", "code": "private static String computeRegexString(String originalString,String oldName,String newName){\n  StringBuilder builder=new StringBuilder(originalString.length());\n  String oldNameOrNewNameRegEx=String.format(\"(%s)|(%s)\",Pattern.quote(oldName),Pattern.quote(newName));\n  int i=originalString.indexOf(oldName);\n  if (i >= 0) {\n    int prevI=0;\n    while (i >= 0) {\n      builder.append(Pattern.quote(originalString.substring(prevI,i)));\n      builder.append(oldNameOrNewNameRegEx);\n      prevI=i;\n      i=originalString.indexOf(oldName,i + oldName.length());\n    }\n    builder.append(Pattern.quote(originalString.substring(prevI + oldName.length(),originalString.length())));\n  }\n  return builder.toString();\n}\n", "docstring": "computes a regular expression string where each instance of the old name can be fulfilled by either the old name or new name .", "partition": "test"}
{"idx": "2979", "code": "@Override public Collection<SerialMessage> initialize(boolean refresh){\n  ArrayList<SerialMessage> result=new ArrayList<SerialMessage>();\n  if (isSupportRequestSupported == true && (refresh == true || initialiseDone == false) && getVersion() > 1) {\n    result.add(getSupportedMessage());\n  }\n  return result;\n}\n", "docstring": "initializes the meter command class . requests the supported meter types .", "partition": "test"}
{"idx": "2343", "code": "public void detach(AppCompatActivity activity){\n  attrViewMaps.remove(activity.hashCode());\n}\n", "docstring": "this method should be called in activity ondestroy method", "partition": "test"}
{"idx": "369", "code": "public static boolean isUniqueContraintError(Exception e){\n  if (DB.isPostgreSQL())   return isSQLState(e,\"23505\");\n  return isErrorCode(e,1);\n}\n", "docstring": "check if unique constraint exception ( aka ora - 00001 )", "partition": "test"}
{"idx": "1255", "code": "public static String encode(byte[] bytes){\n  int len=bytes.length;\n  final StringBuffer encoded=new StringBuffer((len + 2) / 3 * 4);\n  int i=0;\n  int j=len;\n  while (j >= 3) {\n    encoded.append(to64((((bytes[i] & 0xff) << 16) | (int)((bytes[i + 1] & 0xff) << 8) | (int)(bytes[i + 2] & 0xff)),4));\n    i+=3;\n    j-=3;\n  }\n  if (j == 2) {\n    encoded.append(to64(((bytes[i] & 0xff) << 8) | ((bytes[i + 1] & 0xff)),3));\n  }\n  if (j == 1) {\n    encoded.append(to64(((bytes[i] & 0xff)),2));\n  }\n  return encoded.toString();\n}\n", "docstring": "encodes an array of byte into a string of printable ascii characters using a base - 64 encoding .", "partition": "test"}
{"idx": "3831", "code": "static public Automaton concatenate(Automaton a1,Automaton a2){\n  return concatenate(Arrays.asList(a1,a2));\n}\n", "docstring": "returns an automaton that accepts the concatenation of the languages of the given automata . < p > complexity : linear in total number of states .", "partition": "test"}
{"idx": "2832", "code": "protected byte[] assertEncodeDecode(final IGangliaMetadataMessage decl,final IGangliaMessage expected){\n  if (expected == null)   throw new IllegalArgumentException();\n  final XDROutputBuffer xdr=new XDROutputBuffer(IGangliaDefaults.BUFFER_SIZE);\n  final GangliaMessageEncoder31 messageEncoder=new GangliaMessageEncoder31();\n  final GangliaMessageDecoder31 messageDecoder=new GangliaMessageDecoder31();\n  if (expected.isMetricRequest()) {\n    messageEncoder.writeRequest(xdr,(IGangliaRequestMessage)expected);\n  }\n else   if (expected.isMetricMetadata()) {\n    messageEncoder.writeMetadata(xdr,(IGangliaMetadataMessage)expected);\n  }\n else   if (expected.isMetricValue()) {\n    if (decl == null)     throw new IllegalArgumentException(\"Declaration required for metric value record\");\n    messageEncoder.writeMetric(xdr,decl,(IGangliaMetricMessage)expected);\n  }\n else {\n    throw new AssertionError();\n  }\n  final IGangliaMessage actual=messageDecoder.decode(xdr.getBuffer(),0,xdr.getLength());\n  assertEquals(\"messages not equal()\",expected,actual);\n  final byte[] actualData=new byte[xdr.getLength()];\n  System.arraycopy(xdr.getBuffer(),0,actualData,0,actualData.length);\n  return actualData;\n}\n", "docstring": "verify that we can encode and decode a record .", "partition": "test"}
{"idx": "3902", "code": "public Endpoint(URI endpointUrl,SecurityMode... modes){\n  if (modes == null || endpointUrl == null)   throw new IllegalArgumentException(\"null arg\");\n  for (  SecurityMode m : modes) {\n    if (m == null)     throw new IllegalArgumentException(\"null arg\");\n    hash=13 * hash + m.hashCode();\n  }\n  this.endpointUrl=endpointUrl.toString();\n  this.modes=modes;\n  this.endpointConfiguration=EndpointConfiguration.defaults();\n  hash=13 * hash + endpointUrl.hashCode();\n}\n", "docstring": "create a new endpoint .", "partition": "test"}
{"idx": "1761", "code": "private static final PublicKey constructPublicKey(byte[] encodedKey,String encodedKeyAlgorithm) throws InvalidKeyException, NoSuchAlgorithmException {\n  PublicKey key=null;\n  try {\n    KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm,SunJCE.getInstance());\n    X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n    key=keyFactory.generatePublic(keySpec);\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    try {\n      KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm);\n      X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n      key=keyFactory.generatePublic(keySpec);\n    }\n catch (    NoSuchAlgorithmException nsae2) {\n      throw new NoSuchAlgorithmException(\"No installed providers \" + \"can create keys for the \" + encodedKeyAlgorithm + \"algorithm\");\n    }\ncatch (    InvalidKeySpecException ikse2) {\n      InvalidKeyException ike=new InvalidKeyException(\"Cannot construct public key\");\n      ike.initCause(ikse2);\n      throw ike;\n    }\n  }\ncatch (  InvalidKeySpecException ikse) {\n    InvalidKeyException ike=new InvalidKeyException(\"Cannot construct public key\");\n    ike.initCause(ikse);\n    throw ike;\n  }\n  return key;\n}\n", "docstring": "construct a public key from its encoding .", "partition": "test"}
{"idx": "415", "code": "@Override public void clearRouteSensors(){\n  _controlSensorList=new ArrayList<>();\n}\n", "docstring": "method to delete all control sensors from this route", "partition": "test"}
{"idx": "2986", "code": "public ActivityResolveInfo(ResolveInfo resolveInfo){\n  this.resolveInfo=resolveInfo;\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "3895", "code": "public void testDoubles() throws Exception {\n  double[] values=new double[]{Double.NEGATIVE_INFINITY,-2.3E25,-1.0E15,-1.0,-1.0E-1,-1.0E-2,-0.0,+0.0,1.0E-2,1.0E-1,1.0,1.0E15,2.3E25,Double.POSITIVE_INFINITY,Double.NaN};\n  long[] encoded=new long[values.length];\n  for (int i=0; i < values.length; i++) {\n    encoded[i]=NumericUtils.doubleToSortableLong(values[i]);\n    assertTrue(\"forward and back conversion should generate same double\",Double.compare(values[i],NumericUtils.sortableLongToDouble(encoded[i])) == 0);\n  }\n  for (int i=1; i < encoded.length; i++) {\n    assertTrue(\"check sort order\",encoded[i - 1] < encoded[i]);\n  }\n}\n", "docstring": "check various sorted values of doubles ( including extreme values ) check for correct ordering of the encoded bytes and that values round - trip .", "partition": "test"}
{"idx": "739", "code": "private void fillPicks() throws Exception {\n  MLookup orgL=MLookupFactory.get(Env.getCtx(),m_WindowNo,0,2223,DisplayType.TableDir);\n  fWarehouse=new VLookup(\"M_Warehouse_ID\",true,false,true,orgL);\n  lWarehouse.setText(Msg.translate(Env.getCtx(),\"M_Warehouse_ID\"));\n  fWarehouse.addVetoableChangeListener(this);\n  m_M_Warehouse_ID=fWarehouse.getValue();\n  MLookup bpL=MLookupFactory.get(Env.getCtx(),m_WindowNo,0,2762,DisplayType.Search);\n  fBPartner=new VLookup(\"C_BPartner_ID\",false,false,true,bpL);\n  lBPartner.setText(Msg.translate(Env.getCtx(),\"C_BPartner_ID\"));\n  fBPartner.addVetoableChangeListener(this);\n  lDocType.setText(Msg.translate(Env.getCtx(),\"C_DocType_ID\"));\n  cmbDocType.addItem(new KeyNamePair(MOrder.Table_ID,Msg.translate(Env.getCtx(),\"Order\")));\n  cmbDocType.addItem(new KeyNamePair(MRMA.Table_ID,Msg.translate(Env.getCtx(),\"VendorRMA\")));\n  cmbDocType.addActionListener(this);\n}\n", "docstring": "fill picks . column_id from c_order", "partition": "test"}
{"idx": "3289", "code": "public static String urlDecode(String str){\n  try {\n    return (URLDecoder.decode(str,\"utf-8\"));\n  }\n catch (  Exception e) {\n    return (\"Decoding error\");\n  }\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2789", "code": "public static Test suite() throws Exception {\n  return suite(true);\n}\n", "docstring": "skip the dataset tests for now until we can figure out what is wrong with them . fixme fix the dataset tests . there is some problem in how the data to be loaded into the fixture is being resolved in these tests .", "partition": "test"}
{"idx": "2138", "code": "private boolean activeListHasRoom(){\n  int maxDownloads=1;\n  return mActiveList.size() < maxDownloads;\n}\n", "docstring": "check if there is room in the active list .", "partition": "test"}
{"idx": "567", "code": "private void createGui(){\n  final JPanel outerNamePanel=new JPanel(new BorderLayout());\n  outerNamePanel.setBorder(new TitledBorder(\"Tag\"));\n  final JPanel namePanel=new JPanel(new BorderLayout());\n  namePanel.setBorder(new EmptyBorder(0,0,5,0));\n  final JLabel nameLabel=new CHelpLabel(\"Name\" + \":\",new CNameHelp());\n  nameLabel.setPreferredSize(new Dimension(110,25));\n  namePanel.add(nameLabel,BorderLayout.WEST);\n  namePanel.add(m_nameTextField,BorderLayout.CENTER);\n  outerNamePanel.add(namePanel,BorderLayout.CENTER);\n  final JPanel outerDescriptionPanel=new JPanel(new BorderLayout());\n  outerDescriptionPanel.setBorder(new EmptyBorder(5,0,0,0));\n  final JPanel descriptionPanel=new JPanel(new BorderLayout());\n  descriptionPanel.setBorder(new TitledBorder(\"Description\"));\n  descriptionPanel.setMinimumSize(new Dimension(0,120));\n  descriptionPanel.add(new JScrollPane(m_descriptionField));\n  outerDescriptionPanel.add(descriptionPanel,BorderLayout.CENTER);\n  final JPanel buttonPanel=new JPanel(new GridLayout(1,2));\n  buttonPanel.add(new JPanel());\n  buttonPanel.setBorder(new EmptyBorder(5,0,5,2));\n  buttonPanel.add(m_saveButton);\n  final JPanel topPanel=new JPanel(new BorderLayout());\n  topPanel.add(outerNamePanel,BorderLayout.NORTH);\n  topPanel.add(outerDescriptionPanel,BorderLayout.CENTER);\n  topPanel.add(buttonPanel,BorderLayout.SOUTH);\n  final JPanel bottomPanel=new JPanel(new BorderLayout());\n  bottomPanel.setBorder(m_tableBorder);\n  final JScrollPane scrollPane=new JScrollPane(m_childrenTagTable);\n  bottomPanel.add(scrollPane,BorderLayout.CENTER);\n  final JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topPanel,bottomPanel);\n  splitPane.setOneTouchExpandable(true);\n  splitPane.setDividerLocation(splitPane.getMinimumDividerLocation());\n  splitPane.setResizeWeight(0.5);\n  add(splitPane);\n}\n", "docstring": "creates the gui of the component .", "partition": "test"}
{"idx": "3158", "code": "public static double variance(double[] x,double mean){\n  double var=0;\n  int count=x.length;\n  for (  double aX : x) {\n    if (Double.isNaN(aX)) {\n      count--;\n    }\n else {\n      double diff=aX - mean;\n      var+=diff * diff;\n    }\n  }\n  if (count < 2) {\n    count=1;\n  }\n else {\n    count=count - 1;\n  }\n  return var / (double)count;\n}\n", "docstring": "compute variance ( ml estimator )", "partition": "test"}
{"idx": "3178", "code": "public MapObjects(PokemonGo api){\n  this.api=api;\n}\n", "docstring": "instantiates a new map objects .", "partition": "test"}
{"idx": "4221", "code": "@Override public void write(char c[],int off,int len){\n  if ((off < 0) || (off > c.length) || (len < 0)|| ((off + len) > c.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return;\n  }\n  int newcount=count + len;\n  if (newcount > buf.length) {\n    buf=Arrays.copyOf(buf,Math.max(buf.length << 1,newcount));\n  }\n  System.arraycopy(c,off,buf,count,len);\n  count=newcount;\n}\n", "docstring": "writes characters to the buffer .", "partition": "test"}
{"idx": "3542", "code": "private void sequenceQuery(QueryEntry entry,ServerSessionContext session,CompletableFuture<QueryResponse> future){\n  if (entry.getSequence() > session.getCommandSequence()) {\n    session.registerSequenceQuery(entry.getSequence(),null);\n  }\n else {\n    indexQuery(entry,future);\n  }\n}\n", "docstring": "sequences the given query .", "partition": "test"}
{"idx": "4096", "code": "public PutRepositoryRequest source(byte[] repositoryDefinition){\n  return source(repositoryDefinition,0,repositoryDefinition.length);\n}\n", "docstring": "parses repository definition . json , smile and yaml formats are supported", "partition": "test"}
{"idx": "2019", "code": "private String attachFooterToText(String content) throws MessagingException, IOException {\n  StringBuilder builder=new StringBuilder(content);\n  ensureTrailingCarriageReturn(content,builder);\n  builder.append(getFooterText());\n  return builder.toString();\n}\n", "docstring": "prepends the content of the mimepart as text to the existing footer", "partition": "test"}
{"idx": "319", "code": "public static void readFully(InputStream in,byte buf[],int off,int len) throws IOException {\n  int toRead=len;\n  while (toRead > 0) {\n    int ret=in.read(buf,off,toRead);\n    if (ret < 0) {\n      throw new IOException(\"Premature EOF from inputStream\");\n    }\n    toRead-=ret;\n    off+=ret;\n  }\n}\n", "docstring": "does the readfully based on the input read .", "partition": "test"}
{"idx": "940", "code": "public static void launchEmailIntent(final Activity activity,String addr,String text){\n  Log.i(LOG_TAG,\"Launch email intent from \" + activity.getLocalClassName());\n  Intent emailIntent=new Intent(Intent.ACTION_SEND);\n  emailIntent.putExtra(Intent.EXTRA_EMAIL,new String[]{addr});\n  emailIntent.setType(\"text/plain\");\n  PackageManager emailpackageManager=activity.getPackageManager();\n  List<ResolveInfo> emailresolveInfos=emailpackageManager.queryIntentActivities(emailIntent,0);\n  if (emailresolveInfos.size() > 0) {\n    activity.startActivity(emailIntent);\n  }\n}\n", "docstring": "launch an email intent if the device is capable .", "partition": "test"}
{"idx": "1667", "code": "public int capacity(){\n  return capacity.get();\n}\n", "docstring": "retrieves the maximum capacity of the map .", "partition": "test"}
{"idx": "3967", "code": "protected void parseDOMAttributes(Element element) throws SAML2Exception {\n  requestId=element.getAttribute(SAML2Constants.ID);\n  validateID(requestId);\n  version=element.getAttribute(SAML2Constants.VERSION);\n  validateVersion(version);\n  String issueInstantStr=element.getAttribute(SAML2Constants.ISSUE_INSTANT);\n  validateIssueInstant(issueInstantStr);\n  destinationURI=element.getAttribute(SAML2Constants.DESTINATION);\n  consent=element.getAttribute(SAML2Constants.CONSENT);\n}\n", "docstring": "parses attributes of the docuemnt element for this object .", "partition": "test"}
{"idx": "1774", "code": "public void reset(){\n  ns.removeAllElements();\n  ks.setLength(0);\n  cur=tt.root;\n  run();\n}\n", "docstring": "resets the iterator to its initial state .", "partition": "test"}
{"idx": "1855", "code": "public static String surround(String string,String prefix,String suffix){\n  if (string.startsWith(prefix) == false) {\n    string=prefix + string;\n  }\n  if (string.endsWith(suffix) == false) {\n    string+=suffix;\n  }\n  return string;\n}\n", "docstring": "surrounds the string with provided prefix and suffix if such missing from string .", "partition": "test"}
{"idx": "4236", "code": "public FloatColumn(int nrows,int capacity,float defaultValue){\n  super(float.class,new Float(defaultValue));\n  if (capacity < nrows) {\n    throw new IllegalArgumentException(\"Capacity value can not be less than the row count.\");\n  }\n  m_values=new float[capacity];\n  Arrays.fill(m_values,defaultValue);\n  m_size=nrows;\n}\n", "docstring": "create a new floatcolumn .", "partition": "test"}
{"idx": "3970", "code": "private void copyACLs(List<UnManagedCifsShareACL> origACLList,List<CifsShareACL> shareACLList,FileShare fileshare){\n  CifsShareACL shareACL=null;\n  for (  UnManagedCifsShareACL origACL : origACLList) {\n    shareACL=new CifsShareACL();\n    shareACL.setId(URIUtil.createId(CifsShareACL.class));\n    shareACL.setUser(origACL.getUser());\n    shareACL.setPermission(origACL.getPermission());\n    shareACL.setShareName(origACL.getShareName());\n    shareACL.setFileSystemId(fileshare.getId());\n    shareACLList.add(shareACL);\n    _logger.info(\"share ACLs details {}\",shareACL.toString());\n  }\n}\n", "docstring": "copy unmanaged cifs share into new cifs share acls", "partition": "test"}
{"idx": "696", "code": "@Override public void paintComponent(Graphics g){\n  super.paintComponent(g);\n  Graphics2D graphics=(Graphics2D)g;\n  graphics.setBackground(mColorSpectrumBackground);\n  RenderingHints renderHints=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  renderHints.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n  graphics.setRenderingHints(renderHints);\n  drawFrequencies(graphics);\n  drawCursor(graphics);\n}\n", "docstring": "renders the channel configs , lines , labels , and cursor", "partition": "test"}
{"idx": "2641", "code": "public void testABandCBbrokerNetwork() throws Exception {\n  bridgeBrokers(\"BrokerA\",\"BrokerB\");\n  bridgeBrokers(\"BrokerC\",\"BrokerB\");\n  startAllBrokers();\n  Destination dest=createDestination(\"TEST.FOO\",true);\n  MessageConsumer clientA=createConsumer(\"BrokerA\",dest);\n  MessageConsumer clientB=createConsumer(\"BrokerB\",dest);\n  MessageConsumer clientC=createConsumer(\"BrokerC\",dest);\n  Thread.sleep(2000);\n  sendMessages(\"BrokerA\",dest,MESSAGE_COUNT);\n  sendMessages(\"BrokerB\",dest,MESSAGE_COUNT);\n  sendMessages(\"BrokerC\",dest,MESSAGE_COUNT);\n  MessageIdList msgsA=getConsumerMessages(\"BrokerA\",clientA);\n  MessageIdList msgsB=getConsumerMessages(\"BrokerB\",clientB);\n  MessageIdList msgsC=getConsumerMessages(\"BrokerC\",clientC);\n  msgsA.waitForMessagesToArrive(MESSAGE_COUNT);\n  msgsB.waitForMessagesToArrive(MESSAGE_COUNT * 3);\n  msgsC.waitForMessagesToArrive(MESSAGE_COUNT);\n  assertEquals(MESSAGE_COUNT,msgsA.getMessageCount());\n  assertEquals(MESSAGE_COUNT * 3,msgsB.getMessageCount());\n  assertEquals(MESSAGE_COUNT,msgsC.getMessageCount());\n}\n", "docstring": "brokera - > brokerb < - brokerc", "partition": "test"}
{"idx": "2408", "code": "public void reclaimViews(List<View> views){\n  int childCount=getChildCount();\n  RecyclerListener listener=mRecycler.mRecyclerListener;\n  for (int i=0; i < childCount; i++) {\n    View child=getChildAt(i);\n    TwoWayAbsListView.LayoutParams lp=(TwoWayAbsListView.LayoutParams)child.getLayoutParams();\n    if (lp != null && mRecycler.shouldRecycleViewType(lp.viewType)) {\n      views.add(child);\n      if (listener != null) {\n        listener.onMovedToScrapHeap(child);\n      }\n    }\n  }\n  mRecycler.reclaimScrapViews(views);\n  removeAllViewsInLayout();\n}\n", "docstring": "move all views ( excluding headers and footers ) held by this twowayabslistview into the supplied list . this includes views displayed on the screen as well as views stored in twowayabslistview \"'\" s internal view recycler .", "partition": "test"}
{"idx": "3562", "code": "protected String alterCase(String value){\nswitch (getCase()) {\ncase UPPERCASE:\n    return value.toUpperCase();\ncase LOWERCASE:\n  return value.toLowerCase();\ndefault :\nreturn value;\n}\n}\n", "docstring": "alter the case of this element so that it is rendered according to whatever the value of case_type is . default is mixedcase", "partition": "test"}
{"idx": "4042", "code": "public void removeListener(final L listener){\n  Validate.notNull(listener,\"Listener object cannot be null.\");\n  listeners.remove(listener);\n}\n", "docstring": "unregisters an event listener .", "partition": "test"}
{"idx": "1649", "code": "public static String join(char[] self,String separator){\n  StringBuilder buffer=new StringBuilder();\n  boolean first=true;\n  if (separator == null)   separator=\"\";\n  for (  char next : self) {\n    if (first) {\n      first=false;\n    }\n else {\n      buffer.append(separator);\n    }\n    buffer.append(next);\n  }\n  return buffer.toString();\n}\n", "docstring": "concatenates the string representation of each items in this array , with the given string as a separator between each item .", "partition": "test"}
{"idx": "1170", "code": "public synchronized boolean removeAll(Collection c){\n  Object[] elements=getArray();\n  int len=elements.length;\n  if (len != 0) {\n    int newlen=0;\n    Object[] temp=new Object[len];\n    for (int i=0; i < len; ++i) {\n      Object element=elements[i];\n      if (!c.contains(element))       temp[newlen++]=element;\n    }\n    if (newlen != len) {\n      setArray(copyOfRange(temp,0,newlen,Object[].class));\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "removes from this list all of its elements that are contained in the specified collection . this is a particularly expensive operation in this class because of the need for an internal temporary array .", "partition": "test"}
{"idx": "748", "code": "@Override public Instances defineDataFormat() throws Exception {\n  ArrayList<Attribute> atts;\n  ArrayList<String> attValues;\n  int i;\n  m_Random=new Random(getSeed());\n  m_nextClassShouldBeZero=true;\n  m_lastLabel=Double.NaN;\n  setNumExamplesAct(getNumExamples());\n  atts=new ArrayList<Attribute>();\n  atts.add(new Attribute(\"salary\"));\n  atts.add(new Attribute(\"commission\"));\n  atts.add(new Attribute(\"age\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 5; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"elevel\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=1; i <= 20; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"car\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 9; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"zipcode\",attValues));\n  atts.add(new Attribute(\"hvalue\"));\n  atts.add(new Attribute(\"hyears\"));\n  atts.add(new Attribute(\"loan\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 2; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"group\",attValues));\n  m_DatasetFormat=new Instances(getRelationNameToUse(),atts,0);\n  return m_DatasetFormat;\n}\n", "docstring": "initializes the format for the dataset produced . must be called before the generateexample or generateexamples methods are used . re - initializes the random number generator with the given seed .", "partition": "test"}
{"idx": "793", "code": "public void addParam(AstNode param){\n  assertNotNull(param);\n  if (params == null) {\n    params=new ArrayList<AstNode>();\n  }\n  params.add(param);\n  param.setParent(this);\n}\n", "docstring": "adds a parameter to the function parameter list . sets the parent of the param node to this node .", "partition": "test"}
{"idx": "1704", "code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getMask(actions));\n}\n", "docstring": "readobject is called to restore the state of the filepermission from a stream .", "partition": "test"}
{"idx": "1431", "code": "public SimpleString concat(final char c){\n  byte[] bytes=new byte[data.length + 2];\n  System.arraycopy(data,0,bytes,0,data.length);\n  bytes[data.length]=(byte)(c & 0xFF);\n  bytes[data.length + 1]=(byte)(c >> 8 & 0xFF);\n  return new SimpleString(bytes);\n}\n", "docstring": "concatenates a simplestring and a char", "partition": "test"}
{"idx": "1167", "code": "public static boolean inTargetDir(File file){\n  return inTargetDir(file.toPath());\n}\n", "docstring": "verify that the supplied file or directory is within the target directory .", "partition": "test"}
{"idx": "736", "code": "public <T>List<String> validateBean(T bean,String errIfBeanNull){\n  List<String> errors=new ArrayList<String>();\n  if (bean == null) {\n    errors.add(errIfBeanNull);\n    return errors;\n  }\n  Set<ConstraintViolation<T>> violations=validator.validate(bean);\n  for (  ConstraintViolation<T> violation : violations) {\n    errors.add(violation.getMessage());\n  }\n  return errors;\n}\n", "docstring": "validate the bean is not null ; then validate its fields", "partition": "test"}
{"idx": "1278", "code": "private void addEntry(){\n  model.addNewEntry();\n  removeButton.setEnabled(false);\n}\n", "docstring": "adds a new colour map entry .", "partition": "test"}
{"idx": "3469", "code": "private String applyReplacement(final BidiMap replacement,String contents){\n  for (  Object key : replacement.keySet()) {\n    String attributeName=(String)key;\n    String attributeInitials=(String)replacement.get(key);\n    contents=contents.replaceAll(JSONSerialisation.jsonAttributeName(attributeName),JSONSerialisation.jsonAttributeName(attributeInitials));\n  }\n  return contents;\n}\n", "docstring": "perform the keyword substitution .", "partition": "test"}
{"idx": "2405", "code": "private void addFlags(int newflags){\n  flags=getLayoutFlags() | newflags;\n}\n", "docstring": "or newflags with existing flags . first computes existing flags if needed .", "partition": "test"}
{"idx": "860", "code": "public StrBuilder insert(final int index,final Object obj){\n  if (obj == null) {\n    return insert(index,nullText);\n  }\n  return insert(index,obj.toString());\n}\n", "docstring": "inserts the string representation of an object into this builder . inserting null will use the stored null text value .", "partition": "test"}
{"idx": "938", "code": "private LocusInfo createNextUncoveredLocusInfo(final Locus stopBeforeLocus){\n  while (lastReferenceSequence <= stopBeforeLocus.getSequenceIndex() && lastReferenceSequence <= referenceSequenceMask.getMaxSequenceIndex()) {\n    if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex() && lastPosition + 1 >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n    final int nextbit=referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition);\n    if (nextbit == -1) {\n      if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex()) {\n        lastPosition=stopBeforeLocus.getPosition();\n        return null;\n      }\n      lastReferenceSequence++;\n      lastPosition=0;\n    }\n else     if (lastReferenceSequence < stopBeforeLocus.getSequenceIndex() || nextbit < stopBeforeLocus.getPosition()) {\n      lastPosition=nextbit;\n      return new LocusInfo(getReferenceSequence(lastReferenceSequence),lastPosition);\n    }\n else     if (nextbit >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n  }\n  return null;\n}\n", "docstring": "create the next relevant zero - coverage locusinfo", "partition": "test"}
{"idx": "2518", "code": "private void connect() throws IOException {\n  JMXServiceURL jmxUrl=new JMXServiceURL(String.format(fmtUrl,host,port));\n  Map<String,Object> env=new HashMap<String,Object>();\n  if (username != null) {\n    String[] creds={username,password};\n    env.put(JMXConnector.CREDENTIALS,creds);\n  }\n  env.put(\"com.sun.jndi.rmi.factory.socket\",getRMIClientSocketFactory());\n  jmxc=JMXConnectorFactory.connect(jmxUrl,env);\n  mbeanServerConn=jmxc.getMBeanServerConnection();\n  try {\n    ObjectName name=new ObjectName(ssObjName);\n    ssProxy=JMX.newMBeanProxy(mbeanServerConn,name,StorageServiceMBean.class);\n    name=new ObjectName(MessagingService.MBEAN_NAME);\n    msProxy=JMX.newMBeanProxy(mbeanServerConn,name,MessagingServiceMBean.class);\n    name=new ObjectName(StreamManagerMBean.OBJECT_NAME);\n    streamProxy=JMX.newMBeanProxy(mbeanServerConn,name,StreamManagerMBean.class);\n    name=new ObjectName(CompactionManager.MBEAN_OBJECT_NAME);\n    compactionProxy=JMX.newMBeanProxy(mbeanServerConn,name,CompactionManagerMBean.class);\n    name=new ObjectName(FailureDetector.MBEAN_NAME);\n    fdProxy=JMX.newMBeanProxy(mbeanServerConn,name,FailureDetectorMBean.class);\n    name=new ObjectName(CacheService.MBEAN_NAME);\n    cacheService=JMX.newMBeanProxy(mbeanServerConn,name,CacheServiceMBean.class);\n    name=new ObjectName(StorageProxy.MBEAN_NAME);\n    spProxy=JMX.newMBeanProxy(mbeanServerConn,name,StorageProxyMBean.class);\n    name=new ObjectName(HintedHandOffManager.MBEAN_NAME);\n    hhProxy=JMX.newMBeanProxy(mbeanServerConn,name,HintedHandOffManagerMBean.class);\n    name=new ObjectName(GCInspector.MBEAN_NAME);\n    gcProxy=JMX.newMBeanProxy(mbeanServerConn,name,GCInspectorMXBean.class);\n    name=new ObjectName(Gossiper.MBEAN_NAME);\n    gossProxy=JMX.newMBeanProxy(mbeanServerConn,name,GossiperMBean.class);\n  }\n catch (  MalformedObjectNameException e) {\n    throw new RuntimeException(\"Invalid ObjectName? Please report this as a bug.\",e);\n  }\n  memProxy=ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,ManagementFactory.MEMORY_MXBEAN_NAME,MemoryMXBean.class);\n  runtimeProxy=ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,ManagementFactory.RUNTIME_MXBEAN_NAME,RuntimeMXBean.class);\n}\n", "docstring": "create a connection to the jmx agent and setup the m [ x ", "partition": "test"}
{"idx": "3982", "code": "public synchronized boolean verifyChunkAuthTag(int chunkIdx,byte[] chunkAuthTag) throws FileEncryptionException {\n  if ((chunkIdx < 0) || (chunkAuthTag == null) || (chunkAuthTag.length != backEncRandomAccessFile.CHUNK_TLEN)) {\n    throw new FileEncryptionException(\"Invalid auth tag parameter given!\");\n  }\n else {\n    byte[] storedAuthTag=atagList.get(chunkIdx);\n    if (storedAuthTag == null || !Arrays.equals(chunkAuthTag,storedAuthTag)) {\n      return false;\n    }\n else {\n      return true;\n    }\n  }\n}\n", "docstring": "verifies if the given chunk authentication tag equals the one in the authentication tag list , but does not verify if the complete list of all authentication tags is valid w . r . t . the central file authentication tag", "partition": "test"}
{"idx": "4024", "code": "private Instance votedReclassifyExample(Instance example) throws Exception {\n  int classVotes[]=new int[getNumClasses()];\n  for (int i=0; i < classVotes.length; i++) {\n    classVotes[i]=0;\n  }\n  for (Enumeration<RuleList> e=new WekaEnumeration<RuleList>(m_DecisionList); e.hasMoreElements(); ) {\n    RuleList rl=e.nextElement();\n    int classValue=(int)rl.classifyInstance(example);\n    if (classValue >= 0) {\n      classVotes[classValue]++;\n    }\n  }\n  int maxVote=0;\n  int vote=-1;\n  for (int i=0; i < classVotes.length; i++) {\n    if (classVotes[i] > maxVote) {\n      maxVote=classVotes[i];\n      vote=i;\n    }\n  }\n  if (vote >= 0) {\n    example.setClassValue(vote);\n  }\n else {\n    throw new Exception(\"Error in instance classification.\");\n  }\n  return example;\n}\n", "docstring": "classify example with maximum vote the following way . with every rule in the decisionlist , it is evaluated if the given instance could be the class of the rule . finally the class value that receives the highest number of votes is assigned to the example .", "partition": "test"}
{"idx": "3263", "code": "private boolean checkIfScrolling(float[] lastPoints,MotionEvent ev){\n  float[] point=new float[2];\n  point[0]=ev.getRawX();\n  point[1]=ev.getRawY();\n  float delta=getDistance(lastPoints,point);\n  return Math.abs(delta) > mSlop;\n}\n", "docstring": "checks to see if the user is currently scrolling the menu .", "partition": "test"}
{"idx": "641", "code": "public static int copyAndCloseOutput(Reader input,Writer output) throws IOException {\n  try {\n    return copy(input,output);\n  }\n  finally {\n    output.close();\n  }\n}\n", "docstring": "copy input to output and close the output stream before returning", "partition": "test"}
{"idx": "2309", "code": "protected void handleMesosFailure(String taskId){\n  int attempt=TaskUtils.getAttemptForTaskId(taskId);\n  BaseContainer container=containersInfo.get(TaskUtils.getContainerIndexForTaskId(taskId));\n  boolean hasAttemptsLeft=attempt < container.retries;\n  if (hasAttemptsLeft) {\n    LOG.warning(String.format(\"Retrying task: %s, attempt: %d\",container.name,attempt + 1));\n    String newTaskId=TaskUtils.getTaskId(container.name,attempt + 1);\n    scheduleNewTask(newTaskId);\n  }\n else {\n    LOG.severe(\"Would not restart the job since it is beyond retries: \" + attempt);\n  }\n}\n", "docstring": "restart a failed task unless exceeding the retires limitation", "partition": "test"}
{"idx": "1778", "code": "public static String makeRelatedSessionID(String encryptedID,SessionID prototype) throws SessionException {\n  prototype.parseSessionString();\n  return makeSessionID(encryptedID,prototype.getExtension(),prototype.tail);\n}\n", "docstring": "generates encoded session id string which uses the same extensions and tail part as prototype session id , but a different encrypted id . this method is used to generate session handle and restricted token id for a given master session id . related session ids must share extensions and tail information in order for session failover to work properly", "partition": "test"}
{"idx": "1843", "code": "private byte[] calculateGeneralEncryptionKey(byte[] userPassword,byte[] firstDocIdValue,int keyBitLength,int revision,byte[] oValue,int pValue,boolean encryptMetadata) throws GeneralSecurityException {\n  final byte[] paddedPassword=padPassword(userPassword);\n  MessageDigest md5=createMD5Digest();\n  md5.reset();\n  md5.update(paddedPassword);\n  md5.update(oValue);\n  md5.update((byte)(pValue & 0xFF));\n  md5.update((byte)((pValue >> 8) & 0xFF));\n  md5.update((byte)((pValue >> 16) & 0xFF));\n  md5.update((byte)(pValue >> 24));\n  if (firstDocIdValue != null) {\n    md5.update(firstDocIdValue);\n  }\n  if (revision >= 4 && !encryptMetadata) {\n    for (int i=0; i < 4; ++i) {\n      md5.update((byte)0xFF);\n    }\n  }\n  byte[] hash=md5.digest();\n  final int keyLen=revision == 2 ? 5 : (keyBitLength / 8);\n  final byte[] key=new byte[keyLen];\n  if (revision >= 3) {\n    for (int i=0; i < 50; ++i) {\n      md5.update(hash,0,key.length);\n      digestTo(md5,hash);\n    }\n  }\n  System.arraycopy(hash,0,key,0,key.length);\n  return key;\n}\n", "docstring": "determine what the general encryption key is , given a configuration . this corresponds to algorithm 3 . 2 of pdf reference version 1 . 7 .", "partition": "test"}
{"idx": "3384", "code": "public static Map<String,String> createBasicAuthHeader(String username,String password,Map<String,String> headerMap){\n  if (headerMap == null)   headerMap=new HashMap<>();\n  String credentials=username + \":\" + password;\n  String base64EncodedCredentials=Base64.encodeToString(credentials.getBytes(),Base64.NO_WRAP);\n  headerMap.put(\"Authorization\",\"Basic \" + base64EncodedCredentials);\n  return headerMap;\n}\n", "docstring": "method to create a basic http base64 encrypted authentication header", "partition": "test"}
{"idx": "1529", "code": "private static int labelEnd(String s){\n  int colonIndex=s.indexOf(\":\");\n  int semicolonIndex=s.indexOf(\";\");\n  if ((semicolonIndex == -1) || (colonIndex < semicolonIndex)) {\n    return colonIndex;\n  }\n else {\n    return -1;\n  }\n}\n", "docstring": "determines the position in the string where a label that might be contained ends", "partition": "test"}
{"idx": "688", "code": "public void beforeInsert(int index,char element){\n  if (index > size || index < 0)   throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"+ size);\n  ensureCapacity(size + 1);\n  System.arraycopy(elements,index,elements,index + 1,size - index);\n  elements[index]=element;\n  size++;\n}\n", "docstring": "inserts the specified element before the specified position into the receiver . shifts the element currently at that position ( if any ) and any subsequent elements to the right .", "partition": "test"}
{"idx": "2205", "code": "public void removeChild(Group theGroup){\n  mChildren.remove(theGroup);\n}\n", "docstring": "remove a child from this group", "partition": "test"}
{"idx": "2013", "code": "public static boolean isDigitalUnix(){\n  return osName.indexOf(\"Digital Unix\") > -1;\n}\n", "docstring": "is operating system digital unix ?", "partition": "test"}
{"idx": "1962", "code": "public static String toTypeString(Object[] arguments,int maxSize){\n  if (arguments == null) {\n    return \"null\";\n  }\n  StringBuilder argBuf=new StringBuilder();\n  for (int i=0; i < arguments.length; i++) {\n    if (maxSize != -1 && argBuf.length() > maxSize) {\n      argBuf.append(\"...\");\n      break;\n    }\n else {\n      if (i > 0) {\n        argBuf.append(\", \");\n      }\n      argBuf.append(arguments[i] != null ? typeName(arguments[i]) : \"null\");\n    }\n  }\n  return argBuf.toString();\n}\n", "docstring": "a helper method to format the arguments types as a comma - separated list .", "partition": "test"}
{"idx": "293", "code": "@Get public Representation userCodeForm() throws OAuth2RestletException, InvalidGrantException, NotFoundException, ServerException {\n  final OAuth2Request request=requestFactory.create(getRequest());\n  if (request.getParameter(OAuth2Constants.DeviceCode.USER_CODE) != null) {\n    return verify(null);\n  }\n else {\n    return getTemplateRepresentation(FORM,request,null);\n  }\n}\n", "docstring": "handles get requests to the oauth2 device / user endpoint , returning a form to allow the user to submit their user code", "partition": "test"}
{"idx": "3629", "code": "public final int remainingCapacity(){\n  return Math.max(0,capacity - cache.size());\n}\n", "docstring": "gets the number of entries that can be added to this cache without the need for removing stale entries .", "partition": "test"}
{"idx": "195", "code": "private void backupFavorites(BackupDataOutput data) throws IOException {\n  ContentResolver cr=mContext.getContentResolver();\n  Cursor cursor=cr.query(Favorites.CONTENT_URI,FAVORITE_PROJECTION,getUserSelectionArg(),null,null);\n  try {\n    cursor.moveToPosition(-1);\n    while (cursor.moveToNext()) {\n      final long id=cursor.getLong(ID_INDEX);\n      final long updateTime=cursor.getLong(ID_MODIFIED);\n      Key key=getKey(Key.FAVORITE,id);\n      mKeys.add(key);\n      final String backupKey=keyToBackupKey(key);\n      if (!mExistingKeys.contains(backupKey) || updateTime >= mLastBackupRestoreTime) {\n        writeRowToBackup(key,packFavorite(cursor),data);\n      }\n else {\n        if (DEBUG)         Log.d(TAG,\"favorite already backup up: \" + id);\n      }\n    }\n  }\n  finally {\n    cursor.close();\n  }\n}\n", "docstring": "write all modified favorites to the data stream .", "partition": "test"}
{"idx": "296", "code": "public void close(){\n  while (!mReceivers.isEmpty()) {\n    mContext.unregisterReceiver(mReceivers.remove(0));\n  }\n  if (mOutputWriter != null) {\n    try {\n      mOutputWriter.close();\n    }\n catch (    IOException e) {\n      Log.w(mTag,\"Test output file could not be closed\",e);\n    }\n  }\n}\n", "docstring": "closes the utility instance and unregisters any broadcastreceivers .", "partition": "test"}
{"idx": "3429", "code": "public TSink<byte[]> sendBytes(TStream<byte[]> stream){\n  Objects.requireNonNull(stream,\"stream\");\n  return sendBinary(stream,null);\n}\n", "docstring": "send a stream \"'\" s byte [ ", "partition": "test"}
{"idx": "1161", "code": "public void addToBeLoaded(final String url){\n  if (toBeLoaded == null) {\n    toBeLoaded=new ArrayList<String>();\n  }\n  if (StringUtils.isNotBlank(url)) {\n    toBeLoaded.add(url);\n  }\n}\n", "docstring": "this methods allows to indicate if the resource must be obtained . if this method has been invoked then only the provided url will be processed .", "partition": "test"}
{"idx": "2248", "code": "public boolean isEmpty(){\n  return rdns.isEmpty();\n}\n", "docstring": "determines whether this ldap name is empty . an empty name is one with zero components .", "partition": "test"}
{"idx": "1537", "code": "static SizeRequirements calculateTiledRequirements(LayoutIterator iter,SizeRequirements r){\n  long minimum=0;\n  long maximum=0;\n  long preferred=0;\n  int lastMargin=0;\n  int totalSpacing=0;\n  int n=iter.getCount();\n  for (int i=0; i < n; i++) {\n    iter.setIndex(i);\n    int margin0=lastMargin;\n    int margin1=(int)iter.getLeadingCollapseSpan();\n    totalSpacing+=Math.max(margin0,margin1);\n    preferred+=(int)iter.getPreferredSpan(0);\n    minimum+=iter.getMinimumSpan(0);\n    maximum+=iter.getMaximumSpan(0);\n    lastMargin=(int)iter.getTrailingCollapseSpan();\n  }\n  totalSpacing+=lastMargin;\n  totalSpacing+=2 * iter.getBorderWidth();\n  minimum+=totalSpacing;\n  preferred+=totalSpacing;\n  maximum+=totalSpacing;\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  r.minimum=(minimum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)minimum;\n  r.preferred=(preferred > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)preferred;\n  r.maximum=(maximum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)maximum;\n  return r;\n}\n", "docstring": "calculate the requirements needed to tile the requirements given by the iterator that would be tiled . the calculation takes into consideration margin and border spacing .", "partition": "test"}
{"idx": "224", "code": "public void handleText(String text){\n  if (skippingCharacters > 0) {\n    if (skippingCharacters >= text.length()) {\n      skippingCharacters-=text.length();\n      return;\n    }\n else {\n      text=text.substring(skippingCharacters);\n      skippingCharacters=0;\n    }\n  }\n  if (rtfDestination != null) {\n    rtfDestination.handleText(text);\n    return;\n  }\n  warning(\"Text with no destination. oops.\");\n}\n", "docstring": "handles any pure text ( containing no control characters ) in the input stream . called by the superclass .", "partition": "test"}
{"idx": "579", "code": "public static ByteBuffer base64StringToByteBuffer(String base64EncodedKey){\n  return ByteBuffer.wrap(base64DecodeString(base64EncodedKey));\n}\n", "docstring": "converts a base64 encoded key into a bytebuffer", "partition": "test"}
{"idx": "2992", "code": "@Override public <T>Future<T> submit(Callable<T> task){\nsynchronized (this) {\n    active.incrementAndGet();\n    long timeout=0;\n    while (queue.remainingCapacity() == 0) {\n      try {\n        if (timeout <= giveupTime) {\n          Thread.sleep(DEFAULT_SLEEP);\n          timeout+=DEFAULT_SLEEP;\n        }\n else {\n          throw new RuntimeException(\"Timed out because TPE is too busy...\");\n        }\n      }\n catch (      InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return super.submit(task);\n  }\n}\n", "docstring": "this is a thread safe way to avoid rejection exception . . . this is implemented because we might want to hold the incoming requests till there is a free thread .", "partition": "test"}
{"idx": "1536", "code": "public void removeBiomeType(BiomeDictionary.Type type){\n  ArrayList<BiomeGenBase> entryList=new ArrayList<BiomeGenBase>();\n  entryList.addAll(Arrays.asList(BiomeDictionary.getBiomesForType(type)));\n  for (  BiomeGenBase biome : entryList) {\n    Iterator<BiomeEntry> iterator=allowedBiomes.iterator();\n    while (iterator.hasNext()) {\n      if (BiomeDictionary.areBiomesEquivalent(iterator.next().biome,biome))       iterator.remove();\n    }\n  }\n}\n", "docstring": "removes all biomes of this type from the list of biomes allowed to generate", "partition": "test"}
{"idx": "770", "code": "public void uncompress(){\n  data.position(0);\n  InflaterInputStream inflater=new InflaterInputStream(data.asInputStream());\n  byte[] buffer=new byte[8192];\n  IoBuffer tmp=IoBuffer.allocate(0);\n  tmp.setAutoExpand(true);\n  try {\n    while (inflater.available() > 0) {\n      int decompressed=inflater.read(buffer);\n      if (decompressed <= 0) {\n        break;\n      }\n      tmp.put(buffer,0,decompressed);\n    }\n  }\n catch (  IOException e) {\n    tmp.free();\n    throw new RuntimeException(\"could not uncompress data\",e);\n  }\n finally {\n    if (inflater != null) {\n      try {\n        inflater.close();\n      }\n catch (      IOException e1) {\n      }\n    }\n  }\n  data.free();\n  data=tmp;\n  data.flip();\n  prepareIO();\n}\n", "docstring": "decompress contents using zlib .", "partition": "test"}
{"idx": "4022", "code": "public int serverDelivery(Object message,Object consumer,int deliveryCount) throws Exception {\n  ProtonServerSenderContext protonSender=serverSenders.get(consumer);\n  if (protonSender != null) {\n    return protonSender.deliverMessage(message,deliveryCount);\n  }\n  return 0;\n}\n", "docstring": "the consumer object from the broker or the key used to store the sender", "partition": "test"}
{"idx": "1275", "code": "public TCPChannelClient(ExecutorService executor,TCPChannelEvents eventListener,String ip,int port){\n  this.executor=executor;\n  executorThreadCheck=new ThreadUtils.ThreadChecker();\n  executorThreadCheck.detachThread();\n  this.eventListener=eventListener;\n  InetAddress address;\n  try {\n    address=InetAddress.getByName(ip);\n  }\n catch (  UnknownHostException e) {\n    reportError(\"Invalid IP address.\");\n    return;\n  }\n  if (address.isAnyLocalAddress()) {\n    socket=new TCPSocketServer(address,port);\n  }\n else {\n    socket=new TCPSocketClient(address,port);\n  }\n  socket.start();\n}\n", "docstring": "initializes the tcpchannelclient . if ip is a local ip address , starts a listening server on that ip . if not , instead connects to the ip .", "partition": "test"}
{"idx": "2827", "code": "@Override public void makeImmutable(){\n  if (isMutable) {\n    if (authnStatements != null) {\n      int length=authnStatements.size();\n      for (int i=0; i < length; i++) {\n        AuthnStatement authn=(AuthnStatement)authnStatements.get(i);\n        authn.makeImmutable();\n      }\n      authnStatements=Collections.unmodifiableList(authnStatements);\n    }\n    if (authzDecisionStatements != null) {\n      int length=authzDecisionStatements.size();\n      for (int i=0; i < length; i++) {\n        AuthzDecisionStatement authz=(AuthzDecisionStatement)authzDecisionStatements.get(i);\n        authz.makeImmutable();\n      }\n      authzDecisionStatements=Collections.unmodifiableList(authzDecisionStatements);\n    }\n    if (attributeStatements != null) {\n      int length=attributeStatements.size();\n      for (int i=0; i < length; i++) {\n        AttributeStatement attr=(AttributeStatement)attributeStatements.get(i);\n        attr.makeImmutable();\n      }\n      attributeStatements=Collections.unmodifiableList(attributeStatements);\n    }\n    if (statements != null) {\n      statements=Collections.unmodifiableList(statements);\n    }\n    if (conditions != null) {\n      conditions.makeImmutable();\n    }\n    if (issuer != null) {\n      issuer.makeImmutable();\n    }\n    if (subject != null) {\n      subject.makeImmutable();\n    }\n    if (advice != null) {\n      advice.makeImmutable();\n    }\n    isMutable=false;\n  }\n}\n", "docstring": "makes the object immutable", "partition": "test"}
{"idx": "637", "code": "public void saveIndexes(){\n  ArrayList toSave=new ArrayList();\nsynchronized (this) {\n    Object[] valueTable=this.indexes.valueTable;\n    for (int i=0, l=valueTable.length; i < l; i++) {\n      Index index=(Index)valueTable[i];\n      if (index != null)       toSave.add(index);\n    }\n  }\n  boolean allSaved=true;\n  for (int i=0, length=toSave.size(); i < length; i++) {\n    Index index=(Index)toSave.get(i);\n    ReadWriteMonitor monitor=index.monitor;\n    if (monitor == null)     continue;\n    try {\n      monitor.enterRead();\n      if (index.hasChanged()) {\n        if (monitor.exitReadEnterWrite()) {\n          try {\n            saveIndex(index);\n          }\n catch (          IOException e) {\n            if (VERBOSE) {\n              Util.verbose(\"-> got the following exception while saving:\",System.err);\n              e.printStackTrace();\n            }\n            allSaved=false;\n          }\n finally {\n            monitor.exitWriteEnterRead();\n          }\n        }\n else {\n          allSaved=false;\n        }\n      }\n    }\n  finally {\n      monitor.exitRead();\n    }\n  }\n  if (this.participantsContainers != null && this.participantUpdated) {\n    writeParticipantsIndexNamesFile();\n    this.participantUpdated=false;\n  }\n  this.needToSave=!allSaved;\n}\n", "docstring": "commit all index memory changes to disk", "partition": "test"}
{"idx": "3420", "code": "protected void publish() throws MqttException, IOException {\n  sampleClientPub=new SampleAsyncCallback(url,clientIdPub,cleanSession,quietMode,userName,password);\n  if (sampleClientPub != null) {\n    String topic=\"Sample/Java/v3\";\n    int qos=2;\n    String message=\"Message from async calback MQTTv3 Java client sample\";\n    try {\n      sampleClientPub.publish(topic,qos,message.getBytes());\n    }\n catch (    Throwable e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "publish / send a message to an mqtt server", "partition": "test"}
{"idx": "3397", "code": "public static byte[] select(String appId,String suffix){\n  String cardletAid=FIDESMO_AID_PREFIX + appId + suffix;\n  return select(cardletAid);\n}\n", "docstring": "builds the select command apdu from a cardlet \"'\" s app id : - builds the cardlet \"'\" s aid appending the fidesmo prefix and a suffix - builds the command concatenating the header , aid lenght and aid", "partition": "test"}
{"idx": "1112", "code": "public void resetReferences(){\n  if (_refs != null)   _refs.clear();\n}\n", "docstring": "resets the references for streaming .", "partition": "test"}
{"idx": "2896", "code": "private void fieldGoalAtt(Team offense,Team defense){\n  double fgDistRatio=Math.pow((110 - gameYardLine) / 50,2);\n  double fgAccRatio=Math.pow((110 - gameYardLine) / 50,1.25);\n  double fgDistChance=(getHFadv() + offense.getK(0).ratKickPow - fgDistRatio * 80);\n  double fgAccChance=(getHFadv() + offense.getK(0).ratKickAcc - fgAccRatio * 80);\n  if (fgDistChance > 20 && fgAccChance * Math.random() > 15) {\n    if (gamePoss) {\n      homeScore+=3;\n      HomeKStats[3]++;\n      HomeKStats[2]++;\n    }\n else {\n      awayScore+=3;\n      AwayKStats[3]++;\n      AwayKStats[2]++;\n    }\n    gameEventLog+=getEventPrefix() + offense.abbr + \" K \"+ offense.getK(0).name+ \" made the \"+ (110 - gameYardLine)+ \" yard FG.\";\n    addPointsQuarter(3);\n    offense.getK(0).statsFGMade++;\n    offense.getK(0).statsFGAtt++;\n    if (!playingOT)     kickOff(offense);\n else     resetForOT();\n  }\n else {\n    gameEventLog+=getEventPrefix() + offense.abbr + \" K \"+ offense.getK(0).name+ \" missed the \"+ (110 - gameYardLine)+ \" yard FG.\";\n    offense.getK(0).statsFGAtt++;\n    if (!playingOT) {\n      gameYardLine=Math.max(100 - gameYardLine,20);\n      gameDown=1;\n      gameYardsNeed=10;\n      if (gamePoss) {\n        HomeKStats[3]++;\n      }\n else {\n        AwayKStats[3]++;\n      }\n      gamePoss=!gamePoss;\n    }\n else     resetForOT();\n  }\n  gameTime-=20;\n}\n", "docstring": "attempt a field goal using the offense \"'\" s kicker . if successful , add 3 points and kick off . if not , turn the ball over .", "partition": "test"}
{"idx": "670", "code": "@After public void clean(){\n  mute(null);\n  mute(null);\n  mute(null);\n}\n", "docstring": "cleanups after each tests .", "partition": "test"}
{"idx": "3451", "code": "public List<Instruction> reduceInstructions(final List<Instruction> instructions){\n  lock.lock();\n  try {\n    this.instructions=instructions;\n    stackSizeSimulator.buildStackSizes(instructions);\n    return reduceInstructionsInternal(instructions);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "returns all instructions which are somewhat \" relevant \" for the returned object of the method . the instructions are visited backwards - starting from the return statement . load and store operations are handled as well .", "partition": "test"}
{"idx": "958", "code": "protected Tuple<BlobStoreIndexShardSnapshots,Integer> buildBlobStoreIndexShardSnapshots(Map<String,BlobMetaData> blobs){\n  int latest=-1;\n  for (  String name : blobs.keySet()) {\n    if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {\n      try {\n        int gen=Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()));\n        if (gen > latest) {\n          latest=gen;\n        }\n      }\n catch (      NumberFormatException ex) {\n        logger.warn(\"failed to parse index file name [{}]\",name);\n      }\n    }\n  }\n  if (latest >= 0) {\n    try {\n      return new Tuple<>(indexShardSnapshotsFormat.read(blobContainer,Integer.toString(latest)),latest);\n    }\n catch (    IOException e) {\n      logger.warn(\"failed to read index file  [{}]\",e,SNAPSHOT_INDEX_PREFIX + latest);\n    }\n  }\n  List<SnapshotFiles> snapshots=new ArrayList<>();\n  for (  String name : blobs.keySet()) {\n    try {\n      BlobStoreIndexShardSnapshot snapshot=null;\n      if (name.startsWith(SNAPSHOT_PREFIX)) {\n        snapshot=indexShardSnapshotFormat.readBlob(blobContainer,name);\n      }\n else       if (name.startsWith(LEGACY_SNAPSHOT_PREFIX)) {\n        snapshot=indexShardSnapshotLegacyFormat.readBlob(blobContainer,name);\n      }\n      if (snapshot != null) {\n        snapshots.add(new SnapshotFiles(snapshot.snapshot(),snapshot.indexFiles()));\n      }\n    }\n catch (    IOException e) {\n      logger.warn(\"failed to read commit point [{}]\",e,name);\n    }\n  }\n  return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots),-1);\n}\n", "docstring": "loads all available snapshots in the repository", "partition": "test"}
{"idx": "2609", "code": "public void addPolicyListener(PolicyListener policyListener){\n  policyCache.addPolicyListener(policyListener);\n}\n", "docstring": "adds a policy listener that would be notified whenever a policy is added , removed or changed", "partition": "test"}
{"idx": "3839", "code": "public boolean isEmoteIgnored(Emoticon emote){\n  return ignoredEmotes.contains(emote.code);\n}\n", "docstring": "check if the given emote is on the list of ignored emotes . compares the emote code to the codes on the list .", "partition": "test"}
{"idx": "1285", "code": "public Future<SyncReply> sendRequest(int xid,SyncMessage request) throws RemoteStoreException {\n  ensureConnected();\n  RemoteSyncFuture future=new RemoteSyncFuture(xid,connectionGeneration);\n  futureMap.put(Integer.valueOf(xid),future);\n  if (futureMap.size() > MAX_PENDING_REQUESTS) {\nsynchronized (futureNotify) {\n      while (futureMap.size() > MAX_PENDING_REQUESTS) {\n        try {\n          futureNotify.wait();\n        }\n catch (        InterruptedException e) {\n          throw new RemoteStoreException(\"Could not send request\",e);\n        }\n      }\n    }\n  }\n  channel.writeAndFlush(request);\n  return future;\n}\n", "docstring": "send a request to the server and generate a future for the eventual reply . note that this call can block if there is no active connection while a new connection is re - established or if the maximum number of requests is already pending", "partition": "test"}
{"idx": "2612", "code": "public static Object extractTypeChecked(List<Object> args,int i,Class clazz,Function<List<Object>,Object> extractFunc){\n  if (args.size() < i + 1) {\n    return null;\n  }\n else   if (clazz.isInstance(args.get(i))) {\n    return extractFunc.apply(args);\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "extract type - checked value from an argument list using the specified type check and extraction function", "partition": "test"}
{"idx": "52", "code": "@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}\n", "docstring": "returns first enum constant found in at space - separated list of style names .", "partition": "test"}
{"idx": "4177", "code": "public boolean remove(String word){\n  return m_Words.remove(word);\n}\n", "docstring": "removes the word from the stopword list", "partition": "test"}
{"idx": "4103", "code": "public void sort(Comparator<Individual> comparator){\n  Collections.sort(individuals,comparator);\n}\n", "docstring": "sorts the individuals in ascending order according to their performance , thus the best one will be in last position .", "partition": "test"}
{"idx": "3649", "code": "public TermsAckParser parse() throws ParserConfigurationException, SAXException, ParseFailureException {\n  try {\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(mInputSource,this);\n    return this;\n  }\n catch (  IOException e) {\n    throw new ParseFailureException(\"Failed to parse input source!\",e);\n  }\n}\n", "docstring": "parse the terms ack information", "partition": "test"}
{"idx": "3821", "code": "public synchronized void addOFChannelHandlerAndSendRole(OFChannelHandler h){\n  connectedChannelHandlers.add(h);\n  h.sendRoleRequest(this.role);\n}\n", "docstring": "add a newly connected ofchannelhandler . the channel handler is added we send the current role to the channel handler . all subsequent role changes will be send to all connected", "partition": "test"}
{"idx": "265", "code": "public void sleepMillis(final long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  final InterruptedException e) {\n    logger.error(e,e);\n  }\n}\n", "docstring": "waits the specified number of milliseconds .", "partition": "test"}
{"idx": "2246", "code": "public static String removeFormatting(String line){\n  int length=line.length();\n  StringBuilder buffer=new StringBuilder();\n  for (int i=0; i < length; i++) {\n    char ch=line.charAt(i);\n    if (ch != '\\\\u000f' && ch != '\\\\u0002' && ch != '\\\\u001f' && ch != '\\\\u0016')     buffer.append(ch);\n  }\n  return buffer.toString();\n}\n", "docstring": "remove formatting from a line of irc text .", "partition": "test"}
{"idx": "396", "code": "private void updateStatus(String relayState,int currentStatus){\n  Integer tmp=(Integer)currentStatusMap.get(relayState);\n  if (tmp != null) {\n    int previousStatus=tmp.intValue();\nswitch (previousStatus) {\ncase LOGOUT_SUCCEEDED_STATUS:\n      if (currentStatus > previousStatus) {\n        currentStatusMap.put(relayState,new Integer(currentStatus));\n      }\n    break;\ncase LOGOUT_FAILED_STATUS:\n  if (currentStatus < LOGOUT_FAILED_STATUS) {\n    currentStatusMap.put(relayState,new Integer(LOGOUT_PARTIAL_STATUS));\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n else {\ncurrentStatusMap.put(relayState,new Integer(currentStatus));\n}\n}\n", "docstring": "updates logout status based on current status and what stored in the internal map .", "partition": "test"}
{"idx": "908", "code": "private void registerProviders(){\n  final DevMachine devMachine=appContext.getDevMachine();\n  if (devMachine == null) {\n    return;\n  }\n  final Set<Macro> providers=getMacros(devMachine);\n  checkNotNull(providers);\n  if (providers.isEmpty()) {\n    return;\n  }\n  providerRegistry.register(providers);\n}\n", "docstring": "register macro providers which returns the implementation .", "partition": "test"}
{"idx": "699", "code": "static boolean isAssignableTo(ClassNode type,ClassNode toBeAssignedTo){\n  if (UNKNOWN_PARAMETER_TYPE == type)   return true;\n  if (type == toBeAssignedTo)   return true;\n  if (toBeAssignedTo.redirect() == STRING_TYPE && type.redirect() == GSTRING_TYPE) {\n    return true;\n  }\n  if (isPrimitiveType(toBeAssignedTo))   toBeAssignedTo=getWrapper(toBeAssignedTo);\n  if (isPrimitiveType(type))   type=getWrapper(type);\n  if (Double_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE);\n  }\n  if (Float_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect();\n  }\n  if (Long_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect();\n  }\n  if (Integer_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect() && Long_TYPE != type.redirect();\n  }\n  if (Short_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect() && Long_TYPE != type.redirect() && Integer_TYPE != type.redirect();\n  }\n  if (Byte_TYPE == toBeAssignedTo) {\n    return type.redirect() == Byte_TYPE;\n  }\n  if (type.isArray() && toBeAssignedTo.isArray()) {\n    return isAssignableTo(type.getComponentType(),toBeAssignedTo.getComponentType());\n  }\n  if (type.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(toBeAssignedTo)) {\n    return true;\n  }\n  if (toBeAssignedTo.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(type)) {\n    return true;\n  }\n  if (implementsInterfaceOrIsSubclassOf(type,toBeAssignedTo)) {\n    if (OBJECT_TYPE.equals(toBeAssignedTo))     return true;\n    if (toBeAssignedTo.isUsingGenerics()) {\n      GenericsType gt=GenericsUtils.buildWildcardType(toBeAssignedTo);\n      return gt.isCompatibleWith(type);\n    }\n    return true;\n  }\n  if (type.isDerivedFrom(CLOSURE_TYPE) && isSAMType(toBeAssignedTo)) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "checks if a class node is assignable to another . this is used for example in assignment checks where you want to verify that the assignment is valid .", "partition": "test"}
{"idx": "1245", "code": "public void discard(ServiceRegistrar reg){\nsynchronized (registrars) {\n    if (terminated) {\n      throw new IllegalStateException(\"discovery terminated\");\n    }\n    if (reg == null)     return;\n    sendDiscarded(reg,null);\n  }\n}\n", "docstring": "discard a registrar from the set of registrars already discovered . this does not prevent that registrar from being rediscovered ; it is intended to be used to clear unreachable entries from the set . < p > if the registrar has been discovered using this lookupdiscovery object , each listener registered with this object will have its discarded method called with the given registrar as parameter .", "partition": "test"}
{"idx": "2906", "code": "public InputStream put(final URLConnection connection,final boolean flushCacheOnClose){\n  final String key=getKey(connection);\n  if (key == null)   return null;\n  if (!isCacheable((HttpURLConnection)connection))   try {\n    cache.remove(key);\n    return null;\n  }\n catch (  IOException e) {\n    return null;\n  }\n  String etag=connection.getHeaderField(HEADER_ETAG);\n  if (etag == null || etag.length() == 0)   return null;\n  Editor editor;\n  try {\n    editor=cache.edit(key);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  if (editor == null)   return null;\n  try {\n    editor.set(ETAG,etag);\n  }\n catch (  IOException e) {\n    try {\n      editor.abort();\n    }\n catch (    IOException ignored) {\n    }\n    return null;\n  }\n  InputStream input;\n  try {\n    input=connection.getInputStream();\n    if (!(input instanceof InflaterInputStream) && ENCODING_GZIP.equals(connection.getHeaderField(HEADER_CONTENT_ENCODING)))     input=new GZIPInputStream(input);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  OutputStream output;\n  try {\n    output=editor.newOutputStream(BODY);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  if (output != null)   return new CacheStream(input,output,editor,this,flushCacheOnClose);\n else   return null;\n}\n", "docstring": "create stream that will be cached after it is read", "partition": "test"}
{"idx": "3221", "code": "@Override public Instance remove(int index){\n  return m_Instances.remove(index);\n}\n", "docstring": "removes the instance at the given position .", "partition": "test"}
{"idx": "1144", "code": "@Override public void visitVertex(StreetRouter.State state){\n  Integer edgeIdx=state.backEdge;\n  if (!(edgeIdx == null || edgeIdx == -1)) {\n    EdgeStore.Edge edge=edgeStore.getCursor(edgeIdx);\n    GeoJsonFeature feature=new GeoJsonFeature(edge.getGeometry());\n    feature.addProperty(\"weight\",state.weight);\n    feature.addProperty(\"mode\",state.streetMode);\n    feature.addProperty(\"backEdge\",state.backEdge);\n    features.add(feature);\n  }\n}\n", "docstring": "saves current state geometry mode and weight as geojson feature properties in list of features . it is used in full state graph when debugging", "partition": "test"}
{"idx": "2313", "code": "protected boolean attemptToAddWord(Word word){\n  double additionalLength=word.getWordWidth();\n  additionalLength+=!words.isEmpty() ? spaceSize : 0;\n  if (currentLineLength + additionalLength <= maxLength || maxLength == -1) {\n    words.add(word);\n    currentLineLength+=additionalLength;\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "attempt to add a word to the line . if the line can fit the word in without reaching the maximum line length then the word is added and the line length increased .", "partition": "test"}
{"idx": "718", "code": "public PrivateKey loadPrivateKey() throws Exception {\n  if (defaultKeys) {\n    return getPrivateKeyFromString(RSAKeyLoader.DEFAULT_PKEY);\n  }\n  if (priKey == null) {\n    FileReader f=new FileReader(path + \"privatekey\" + this.id);\n    BufferedReader r=new BufferedReader(f);\n    String tmp=\"\";\n    String key=\"\";\n    while ((tmp=r.readLine()) != null) {\n      key=key + tmp;\n    }\n    f.close();\n    r.close();\n    priKey=getPrivateKeyFromString(key);\n  }\n  return priKey;\n}\n", "docstring": "loads the private key of this process", "partition": "test"}
{"idx": "2388", "code": "public boolean textboxKeyTyped(char p_146201_1_,int p_146201_2_){\n  if (!isFocused)   return false;\n else   if (GuiScreen.func_175278_g(p_146201_2_)) {\n    setCursorPositionEnd();\n    setSelectionPos(0);\n    return true;\n  }\n else   if (GuiScreen.func_175280_f(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    return true;\n  }\n else   if (GuiScreen.func_175279_e(p_146201_2_)) {\n    if (isEnabled)     writeText(GuiScreen.getClipboardString());\n    return true;\n  }\n else   if (GuiScreen.func_175277_d(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    if (isEnabled)     writeText(\"\");\n    return true;\n  }\n else switch (p_146201_2_) {\ncase 14:\n    if (GuiScreen.isCtrlKeyDown()) {\n      if (isEnabled)       deleteWords(-1);\n    }\n else     if (isEnabled)     deleteFromCursor(-1);\n  return true;\ncase 199:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(0);\n else setCursorPositionZero();\nreturn true;\ncase 203:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(-1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() - 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(-1));\n else moveCursorBy(-1);\nreturn true;\ncase 205:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() + 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(1));\n else moveCursorBy(1);\nreturn true;\ncase 207:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(text.length());\n else setCursorPositionEnd();\nreturn true;\ncase 211:\nif (GuiScreen.isCtrlKeyDown()) {\nif (isEnabled) deleteWords(1);\n}\n else if (isEnabled) deleteFromCursor(1);\nreturn true;\ndefault :\nif (EmailAllowedCharacters.isAllowedCharacter(p_146201_1_)) {\nif (isEnabled) writeText(Character.toString(p_146201_1_));\nreturn true;\n}\n else return false;\n}\n}\n", "docstring": "call this method from your guiscreen to process the keys into the textbox", "partition": "test"}
{"idx": "3062", "code": "public void substituteHeader(int state,String header) throws AuthLoginException {\n  if (debug.messageEnabled()) {\n    debug.message(\"substituteHeader : state=\" + state + \", header=\"+ header);\n  }\n  if (state > stateLength) {\n    throw new AuthLoginException(bundleName,\"invalidState\",new Object[]{new Integer(state)});\n  }\n  Callback[] ext=getCallback(state);\n  if (ext.length <= 0) {\n    throw new AuthLoginException(bundleName,\"invalidCallbackIndex\",null);\n  }\n  if ((header != null) && (header.length() != 0)) {\n    PagePropertiesCallback pc=(PagePropertiesCallback)((Callback[])internal.get(state - 1))[0];\n    pc.setHeader(header);\n  }\n}\n", "docstring": "use this method to replace the header text from the xml file with new text . this method can be used multiple times on the same state replacing text with new text each time . useful for modules that control their own error handling .", "partition": "test"}
{"idx": "2062", "code": "public void addFieldBuffered(VEditor editor,GridField mField){\n  wrap=mField != null ? !mField.isSameLine() : false;\n  if (prevEditor != null && prevField != null)   addField(prevEditor,prevField);\n  prevEditor=editor;\n  prevField=mField;\n}\n", "docstring": "add field and label to buffer and push buffered field to panel", "partition": "test"}
{"idx": "1352", "code": "public BinaryOut(String filename){\n  try {\n    OutputStream os=new FileOutputStream(filename);\n    out=new BufferedOutputStream(os);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "initializes a binary output stream from a file .", "partition": "test"}
{"idx": "3837", "code": "public byte readByte() throws IOException {\n  return dis.readByte();\n}\n", "docstring": "read a byte from the input stream .", "partition": "test"}
{"idx": "1408", "code": "protected void clearAllTrails(SSOTokenID tokenID){\n  boolean removed=false;\n  String key=tokenID.toString();\nsynchronized (mapTokenIDs) {\n    removed=(mapTokenIDs.remove(key) != null);\n  }\n}\n", "docstring": "clears all registered page trails of a given single sign on token id", "partition": "test"}
{"idx": "2331", "code": "public Collection<GridPortRecord> records(){\nsynchronized (recs) {\n    return Collections.unmodifiableCollection(new ArrayList<>(recs));\n  }\n}\n", "docstring": "returns unmodifiable collections of records .", "partition": "test"}
{"idx": "4263", "code": "public void initTKF91(){\n  int iNumNodes=iParent.length;\n  double iBeta[]=new double[iNumNodes];\n  iB=new double[iNumNodes];\n  iE=new double[iNumNodes];\n  iH=new double[iNumNodes];\n  iN=new double[iNumNodes];\n  iInitial=1.0;\n  for (int i=0; i < iNumNodes; i++) {\n    if (i == iNumNodes - 1) {\n      iBeta[i]=1.0 / iMu;\n      iH[i]=0.0;\n    }\n else {\n      iBeta[i]=Math.exp((iLambda - iMu) * iTau[i]);\n      iBeta[i]=(1.0 - iBeta[i]) / (iMu - iLambda * iBeta[i]);\n      iH[i]=Math.exp(-iMu * iTau[i]) * (1.0 - iLambda * iBeta[i]);\n    }\n    iB[i]=iLambda * iBeta[i];\n    iE[i]=iMu * iBeta[i];\n    iN[i]=(1.0 - iMu * iBeta[i]) * (1.0 - iB[i]) - iH[i];\n    iInitial*=(1.0 - iB[i]);\n  }\n}\n", "docstring": "populates the ib , ie , ih and in arrays , and iinitial value", "partition": "test"}
{"idx": "3245", "code": "private boolean renderOutput(Node node,InternalContextAdapter context,Writer writer) throws IOException, MethodInvocationException, ResourceNotFoundException {\n  String arg=\"\";\n  if (node == null) {\n    rsvc.error(\"#include() error :  null argument\");\n    return false;\n  }\n  Object value=node.value(context);\n  if (value == null) {\n    rsvc.error(\"#include() error :  null argument\");\n    return false;\n  }\n  arg=value.toString();\n  Resource resource=null;\n  try {\n    resource=rsvc.getContent(arg,getInputEncoding(context));\n  }\n catch (  ResourceNotFoundException rnfe) {\n    rsvc.error(\"#include(): cannot find resource \\'\" + arg + \"\\', called from template \"+ context.getCurrentTemplateName()+ \" at (\"+ getLine()+ \", \"+ getColumn()+ \")\");\n    throw rnfe;\n  }\ncatch (  Exception e) {\n    rsvc.error(\"#include(): arg = \\'\" + arg + \"\\', called from template \"+ context.getCurrentTemplateName()+ \" at (\"+ getLine()+ \", \"+ getColumn()+ \") : \"+ e);\n  }\n  if (resource == null)   return false;\n  writer.write((String)resource.getData());\n  return true;\n}\n", "docstring": "does the actual rendering of the included file", "partition": "test"}
{"idx": "2722", "code": "public java.util.Collection<ObjectReference> dumpThreadRoots(int width){\n  return Collections.emptyList();\n}\n", "docstring": "print the thread roots and return them for processing .", "partition": "test"}
{"idx": "3006", "code": "void triggerWildcardExpander(final Collection<File> allFiles,final WildcardContext wildcardContext) throws IOException {\n  LOG.debug(\"wildcard resources: {}\",allFiles);\n  if (allFiles.isEmpty()) {\n    final String message=String.format(\"No resource found for wildcard: %s\",wildcardContext.getWildcard());\n    LOG.warn(message);\n    throw new IOException(message);\n  }\n  if (wildcardExpanderHandler != null) {\n    try {\n      wildcardExpanderHandler.apply(allFiles);\n    }\n catch (    final IOException e) {\n      throw e;\n    }\ncatch (    final Exception e) {\n      LOG.debug(\"wildcard expanding error. Reporting original exception\",e);\n      throw new IOException(\"Exception during expanding wildcard: \" + e.getMessage());\n    }\n  }\n}\n", "docstring": "uses the wildcardexpanderhandler to process all found files and directories .", "partition": "test"}
{"idx": "1775", "code": "@LayoutlibDelegate static float sin(float angle){\n  return (float)Math.sin(angle);\n}\n", "docstring": "returns the closest float approximation of the sine of the argument .", "partition": "test"}
{"idx": "951", "code": "public void testFindSpringOpenLdap(){\n  LdapProxy proxy=getLdapOpenLdap();\n  List result=null;\n  try {\n    result=proxy.find(getLdapSearchVO(\"\",LdapConstants.NO_SEARCH_LIMIT,null,null,null,LdapScopeConstants.SCOPE_SUBTREE));\n  }\n catch (  Exception e) {\n  }\n  assertNotNull(result);\n  assertEquals(4,result.size());\n}\n", "docstring": "test de busqueda open ldap", "partition": "test"}
{"idx": "2237", "code": "public void crabDownDirBlockForModification(BlockId blk){\n  lockTbl.xLock(blk,txNum);\n  writenIndexBlks.add(blk);\n}\n", "docstring": "sets exclusive lock on the directory block when crabbing down for modification .", "partition": "test"}
{"idx": "39", "code": "public static String decodeCharset(String s,String charset){\n  if (s == null) {\n    return null;\n  }\n  try {\n    byte buf[]=s.getBytes(ASCII_CHARSET);\n    return (new String(buf,0,buf.length,charset));\n  }\n catch (  UnsupportedEncodingException uee) {\n    return s;\n  }\n}\n", "docstring": "decodes the string into specified charset", "partition": "test"}
{"idx": "484", "code": "public List<TLV> initRespondSmp(String question,String secret,boolean initiating) throws OtrException {\n  if (question != null && !initiating)   throw new IllegalArgumentException(\"Only supply a question if initiating\");\n  byte[] our_fp=Hex.decode(keyManager.getLocalFingerprint(sessionID));\n  String remoteFingerprint=keyManager.getRemoteFingerprint(sessionID);\n  if (remoteFingerprint == null)   throw new OtrException(\"no fingerprint for remote user\");\n  byte[] their_fp=Hex.decode(remoteFingerprint);\n  byte[] sessionId;\n  try {\n    sessionId=computeSessionId(session.getS());\n  }\n catch (  SMException ex) {\n    throw new OtrException(ex);\n  }\n  byte[] bytes=secret.getBytes(SerializationUtils.UTF8);\n  int combined_buf_len=41 + sessionId.length + bytes.length;\n  byte[] combined_buf=new byte[combined_buf_len];\n  combined_buf[0]=1;\n  if (initiating) {\n    System.arraycopy(our_fp,0,combined_buf,1,20);\n    System.arraycopy(their_fp,0,combined_buf,21,20);\n  }\n else {\n    System.arraycopy(their_fp,0,combined_buf,1,20);\n    System.arraycopy(our_fp,0,combined_buf,21,20);\n  }\n  System.arraycopy(sessionId,0,combined_buf,41,sessionId.length);\n  System.arraycopy(bytes,0,combined_buf,41 + sessionId.length,bytes.length);\n  MessageDigest sha256;\n  try {\n    sha256=MessageDigest.getInstance(\"SHA-256\");\n  }\n catch (  NoSuchAlgorithmException ex) {\n    throw new OtrException(ex);\n  }\n  byte[] combined_secret=sha256.digest(combined_buf);\n  byte[] smpmsg;\n  try {\n    if (initiating) {\n      smpmsg=SM.step1(smstate,combined_secret);\n    }\n else {\n      smpmsg=SM.step2b(smstate,combined_secret);\n    }\n  }\n catch (  SMException ex) {\n    throw new OtrException(ex);\n  }\n  if (question != null) {\n    bytes=question.getBytes(SerializationUtils.UTF8);\n    byte[] qsmpmsg=new byte[bytes.length + 1 + smpmsg.length];\n    System.arraycopy(bytes,0,qsmpmsg,0,bytes.length);\n    System.arraycopy(smpmsg,0,qsmpmsg,bytes.length + 1,smpmsg.length);\n    smpmsg=qsmpmsg;\n  }\n  TLV sendtlv=new TLV(initiating ? (question != null ? TLV.SMP1Q : TLV.SMP1) : TLV.SMP2,smpmsg);\n  smstate.nextExpected=initiating ? SM.EXPECT2 : SM.EXPECT3;\n  return makeTlvList(sendtlv);\n}\n", "docstring": "respond to or initiate an smp negotiation", "partition": "test"}
{"idx": "4144", "code": "public List<JCAnnotation> transformAnnotations(OutputElement target,Tree.Declaration annotated){\n  EnumSet<OutputElement> outputs;\n  if (annotated instanceof Tree.AnyClass) {\n    outputs=AnnotationUtil.outputs((Tree.AnyClass)annotated);\n  }\n else   if (annotated instanceof Tree.AnyInterface) {\n    outputs=AnnotationUtil.outputs((Tree.AnyInterface)annotated);\n  }\n else   if (annotated instanceof Tree.TypeAliasDeclaration) {\n    outputs=AnnotationUtil.outputs((Tree.TypeAliasDeclaration)annotated);\n  }\n else   if (annotated instanceof Tree.Constructor) {\n    outputs=AnnotationUtil.outputs((Tree.Constructor)annotated);\n  }\n else   if (annotated instanceof Tree.Enumerated) {\n    outputs=AnnotationUtil.outputs((Tree.Enumerated)annotated);\n  }\n else   if (annotated instanceof Tree.AnyMethod) {\n    outputs=AnnotationUtil.outputs((Tree.AnyMethod)annotated);\n  }\n else   if (annotated instanceof Tree.AttributeDeclaration) {\n    outputs=AnnotationUtil.outputs((Tree.AttributeDeclaration)annotated);\n  }\n else   if (annotated instanceof Tree.AttributeGetterDefinition) {\n    outputs=AnnotationUtil.outputs((Tree.AttributeGetterDefinition)annotated);\n  }\n else   if (annotated instanceof Tree.AttributeSetterDefinition) {\n    outputs=AnnotationUtil.outputs((Tree.AttributeSetterDefinition)annotated);\n  }\n else   if (annotated instanceof Tree.ObjectDefinition) {\n    outputs=AnnotationUtil.outputs((Tree.ObjectDefinition)annotated);\n  }\n else {\n    throw BugException.unhandledNodeCase(annotated);\n  }\n  return transform(annotated.getDeclarationModel(),target,annotated.getAnnotationList(),outputs);\n}\n", "docstring": "transform the annotations on the given annotated declaration for inclusion on the given target element type", "partition": "test"}
{"idx": "446", "code": "public boolean validate(String cert,String signedData,String signature) throws NoSuchAlgorithmException, IOException, Exception {\n  byte[] certBytes=Base64.decode(cert);\n  byte[] signedDataBytes=Base64.decode(signedData);\n  byte[] signatureBytes=Base64.decode(signature);\n  return validate(certBytes,signedDataBytes,signatureBytes);\n}\n", "docstring": "example implementation . it only knows to verify sha256withec algorithm .", "partition": "test"}
{"idx": "1994", "code": "public boolean hasNatureAndWeapon(Nature nature,String weapon){\n  return this.nature == nature && ((weapon == null && this.weapon == null) || (weapon != null && weapon.equals(this.weapon)));\n}\n", "docstring": "check if this painter has the given nature an weapon .", "partition": "test"}
{"idx": "4013", "code": "public IntervalImpl(int serialNum,long startIntervalDateTime,double coverageFactor,FramingFlowType intervalDataType,ISource source,IIntervalClassification intervalClassification,Version adeVersion) throws AdeInternalException {\n  a_adeVersion=adeVersion;\n  if (startIntervalDateTime < 0) {\n    throw new IllegalArgumentException(String.format(\"Interval start time must be \" + \"greater than 0! Failed creating new interval with parameters: serialNum=%d, \" + \"startIntervalDateTime=%d, coverageFactor=%s, intervalDataType=%s, source=%s, \"+ \"intervalClassification=%s, adeVersion=%s\",serialNum,startIntervalDateTime,coverageFactor,intervalDataType,source,intervalClassification,adeVersion));\n  }\n  m_startIntervalTime=startIntervalDateTime;\n  m_framingFlowType=intervalDataType;\n  m_serialNum=serialNum;\n  m_intervalClassification=intervalClassification;\n  if (m_intervalClassification == null) {\n    m_intervalClassification=IntervalClassificationEnum.REGULAR;\n  }\n  m_messageSummaryMap=new TreeMap<Integer,IMessageSummary>();\n  m_endIntervalTime=m_startIntervalTime + m_framingFlowType.getDuration();\n  m_source=source;\n  if (coverageFactor <= 0 || coverageFactor > 1) {\n    throw new AdeInternalException(\"Interval coverage factor must be between 0 (exclusive) and 1 (inclusive), but currently is: \" + coverageFactor);\n  }\n  m_coverageFactor=coverageFactor;\n}\n", "docstring": "this is used to build partial intervals .", "partition": "test"}
{"idx": "616", "code": "public static double P_AveragePrecision(int y[],int r[]){\n  double avg_prec=0;\n  int L=y.length;\n  List<Integer> ones=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      ones.add(j);\n    }\n  }\n  if (ones.size() <= 0)   return 1.0;\n  for (  int j : ones) {\n    double s=0.0;\n    for (    int k : ones) {\n      if (r[k] <= r[j]) {\n        s++;\n      }\n    }\n    avg_prec+=(s / (1. + r[j]));\n  }\n  avg_prec/=ones.size();\n  return avg_prec;\n}\n", "docstring": "average precision - computes for each relevant label the percentage of relevant labels among all labels that are ranked before it .", "partition": "test"}
{"idx": "2001", "code": "@RequestMapping(value={\"/\",\"\"},method=RequestMethod.POST) @ResponseBody public RestWrapper update(@ModelAttribute(\"userroles\") @Valid UserRoles userRoles,BindingResult bindingResult,Principal principal){\n  RestWrapper restWrapper=null;\n  if (bindingResult.hasErrors()) {\n    BindingResultError bindingResultError=new BindingResultError();\n    return bindingResultError.errorMessage(bindingResult);\n  }\n  try {\n    com.wipro.ats.bdre.md.dao.jpa.UserRoles jpaUserRoles=new com.wipro.ats.bdre.md.dao.jpa.UserRoles();\n    jpaUserRoles.setUserRoleId(userRoles.getUserRoleId());\n    jpaUserRoles.setRole(userRoles.getRole());\n    Users users=new Users();\n    users.setUsername(userRoles.getUsername());\n    jpaUserRoles.setUsers(users);\n    userRolesDAO.update(jpaUserRoles);\n    restWrapper=new RestWrapper(userRoles,RestWrapper.OK);\n    LOGGER.info(\"Record with ID:\" + userRoles.getUserRoleId() + \" updated in UserRoles by User:\"+ principal.getName()+ userRoles);\n  }\n catch (  Exception e) {\n    LOGGER.error(e);\n    restWrapper=new RestWrapper(e.getMessage(),RestWrapper.ERROR);\n  }\n  return restWrapper;\n}\n", "docstring": "this method calls proc updateuserroles and updates the values . it also validates the values passed .", "partition": "test"}
{"idx": "2994", "code": "protected XSQLDA allocateXSqlDa(RowDescriptor rowDescriptor){\n  if (rowDescriptor == null || rowDescriptor.getCount() == 0) {\n    final XSQLDA xSqlDa=new XSQLDA(1);\n    xSqlDa.sqld=xSqlDa.sqln=0;\n    return xSqlDa;\n  }\n  final XSQLDA xSqlDa=new XSQLDA(rowDescriptor.getCount());\n  for (int idx=0; idx < rowDescriptor.getCount(); idx++) {\n    final FieldDescriptor fieldDescriptor=rowDescriptor.getFieldDescriptor(idx);\n    final XSQLVAR xSqlVar=xSqlDa.sqlvar[idx];\n    xSqlVar.sqltype=(short)(fieldDescriptor.getType() | 1);\n    xSqlVar.sqlsubtype=(short)fieldDescriptor.getSubType();\n    xSqlVar.sqlscale=(short)fieldDescriptor.getScale();\n    xSqlVar.sqllen=(short)fieldDescriptor.getLength();\n    xSqlVar.sqlind=new ShortByReference();\n    final int requiredDataSize=fieldDescriptor.isVarying() ? fieldDescriptor.getLength() + 3 : fieldDescriptor.getLength() + 1;\n    xSqlVar.sqldata=new Memory(requiredDataSize);\n  }\n  return xSqlDa;\n}\n", "docstring": "creates an xsqlda , populates type information and allocates memory for the sqldata fields .", "partition": "test"}
{"idx": "745", "code": "public static void addAnnotationToXML(Element annotationsElement,String name,String value){\n  if (value == null) {\n    deleteAnnotationFromXML(annotationsElement,name);\n  }\n else {\n    final Document doc=annotationsElement.getOwnerDocument();\n    Element elem=doc.createElement(\"annotation\");\n    annotationsElement.appendChild(elem);\n    elem.setAttribute(\"key\",name);\n    elem.setTextContent(value);\n  }\n}\n", "docstring": "updates the xml representation to contain this annotation .", "partition": "test"}
{"idx": "1858", "code": "void scheduleToTimerPool(){\n  if (sessionPollerPool.isPollingEnabled()) {\n    long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxIdleTime() * 60)) * 1000;\n    if (sessionPollerPool.getCacheBasedPolling()) {\n      timeoutTime=Math.min((session.getLatestRefreshTime() + (session.getMaxCachingTime() * 60)) * 1000,timeoutTime);\n    }\n    rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n  }\n else {\n    if ((sessionPollerPool.isSessionCleanupEnabled()) && willExpire(session.getMaxSessionTime())) {\n      long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxSessionTime() * 60)) * 1000;\n      rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n    }\n  }\n}\n", "docstring": "schedule this culler to be run , based on the state of the session .", "partition": "test"}
{"idx": "2341", "code": "private void rollbackMethodForCreateSnapshot(boolean isSnapshotCreated,boolean isDummyLunPathAdded,HDSApiClient hdsApiClient,StorageSystem storage,URI snapshot) throws Exception {\n  if (isDummyLunPathAdded) {\n    log.info(\"Remove dummy path while doing roll back\");\n    hdsProtectionOperations.removeDummyLunPath(storage,snapshot);\n  }\n  if (isSnapshotCreated) {\n    log.info(\"Remove snapshot volume for roll back\");\n    BlockSnapshot snapshotObj=dbClient.queryObject(BlockSnapshot.class,snapshot);\n    String systemObjectID=HDSUtils.getSystemObjectID(storage);\n    String logicalUnitObjId=HDSUtils.getLogicalUnitObjectId(snapshotObj.getNativeId(),storage);\n    hdsApiClient.deleteSnapshotVolume(systemObjectID,logicalUnitObjId,storage.getModel());\n  }\n}\n", "docstring": "roll back method to clean up stale snapshot volume on storage system", "partition": "test"}
{"idx": "1567", "code": "private void initProgram(){\n  glUseProgram(this.program);\n  vec3ArrayUniform=glGetUniformLocation(this.program,\"cols\");\n  chosenUniform=glGetUniformLocation(this.program,\"chosen\");\n  glUseProgram(0);\n}\n", "docstring": "initialize the shader program .", "partition": "test"}
{"idx": "3340", "code": "public void rotateZ(double theta){\n  Matrix3D tmp=new Matrix3D();\n  double c=Math.cos(theta);\n  double s=Math.sin(theta);\n  tmp.set(0,0,c);\n  tmp.set(0,1,-s);\n  tmp.set(1,0,s);\n  tmp.set(1,1,c);\n  preMultiply(tmp);\n}\n", "docstring": "rotate transformation about the z axis", "partition": "test"}
{"idx": "150", "code": "public void replaceSplitElement(int aIndex,Fragment aSplitElement){\n  splits.set(aIndex,aSplitElement);\n}\n", "docstring": "replaces a split element with another one", "partition": "test"}
{"idx": "3849", "code": "static boolean chunkSet(InternalDistributedMember recipient,Set set,int CHUNK_SIZE_IN_BYTES,boolean includeValues,ObjectIntProcedure proc) throws IOException {\n  Iterator it=set.iterator();\n  boolean keepGoing=true;\n  boolean sentLastChunk=false;\n  final HeapDataOutputStream mos=new HeapDataOutputStream(InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048,recipient.getVersionObject());\n  do {\n    mos.reset();\n    int avgItemSize=0;\n    int itemCount=0;\n    while ((mos.size() + avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES && it.hasNext()) {\n      Object key=it.next();\n      DataSerializer.writeObject(key,mos);\n      itemCount++;\n      avgItemSize=mos.size() / itemCount;\n    }\n    DataSerializer.writeObject((Object)null,mos);\n    int lastMsg=it.hasNext() ? 0 : 1;\n    keepGoing=proc.executeWith(mos,lastMsg);\n    sentLastChunk=lastMsg == 1 && keepGoing;\n  }\n while (keepGoing && it.hasNext());\n  return sentLastChunk;\n}\n", "docstring": "serialize the given set \"'\" s elments into byte [ ", "partition": "test"}
{"idx": "757", "code": "public static String formatPercent(int downloadSize,int fileSize){\n  float num=(float)downloadSize / fileSize;\n  float percent=((float)(int)(num * 1000)) / 10;\n  return String.valueOf(percent + \"%\");\n}\n", "docstring": "format the download percent", "partition": "test"}
{"idx": "486", "code": "public RoundedIconGenerator(int iconWidthPx,int iconHeightPx,int cornerRadiusPx,int backgroundColor,float textSizePx){\n  mIconWidthPx=iconWidthPx;\n  mIconHeightPx=iconHeightPx;\n  mCornerRadiusPx=cornerRadiusPx;\n  mBackgroundRect=new RectF(0,0,mIconWidthPx,mIconHeightPx);\n  mBackgroundPaint=new Paint(Paint.ANTI_ALIAS_FLAG);\n  mBackgroundPaint.setColor(backgroundColor);\n  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);\n  mTextPaint.setColor(Color.WHITE);\n  mTextPaint.setFakeBoldText(true);\n  mTextPaint.setTextSize(textSizePx);\n  FontMetrics textFontMetrics=mTextPaint.getFontMetrics();\n  mTextHeight=(float)Math.ceil(textFontMetrics.bottom - textFontMetrics.top);\n  mTextYOffset=-textFontMetrics.top;\n}\n", "docstring": "constructs the generator and initializes the common members ignoring display density .", "partition": "test"}
{"idx": "3017", "code": "public void addClaimedSignerRole(final String claimedSignerRole){\n  if ((claimedSignerRole == null) || (claimedSignerRole.length() == 0)) {\n    throw new NullPointerException(\"claimedSignerRole\");\n  }\n  if (claimedSignerRoles == null) {\n    claimedSignerRoles=new ArrayList<String>();\n  }\n  claimedSignerRoles.add(claimedSignerRole);\n}\n", "docstring": "adds a claimed signer role", "partition": "test"}
{"idx": "3487", "code": "public void writeRawBytes(final byte[] value,int offset,int length) throws IOException {\n  if (limit - position >= length) {\n    System.arraycopy(value,offset,buffer,position,length);\n    position+=length;\n  }\n else {\n    throw new OutOfSpaceException(position,limit);\n  }\n}\n", "docstring": "write part of an array of bytes .", "partition": "test"}
{"idx": "3144", "code": "private Set<ObjectName> objectNamesFromFilteredNamedObjects(Set<NamedObject> list,QueryExp query){\n  Set<ObjectName> result=new HashSet<ObjectName>();\n  if (query == null) {\n    for (    NamedObject no : list) {\n      result.add(no.getName());\n    }\n  }\n else {\n    final MBeanServer oldServer=QueryEval.getMBeanServer();\n    query.setMBeanServer(server);\n    try {\n      for (      NamedObject no : list) {\n        boolean res;\n        try {\n          res=query.apply(no.getName());\n        }\n catch (        Exception e) {\n          res=false;\n        }\n        if (res) {\n          result.add(no.getName());\n        }\n      }\n    }\n  finally {\n      query.setMBeanServer(oldServer);\n    }\n  }\n  return result;\n}\n", "docstring": "applies the specified queries to the set of namedobjects .", "partition": "test"}
{"idx": "654", "code": "private LocalDateTime parseDate(String dateStr,boolean tryAgain){\n  LocalDateTime date=LocalDateTime.now(ZoneId.of(\"GMT\"));\n  if (mDateTimeFormatter == null) {\n    initFormatter(dateStr);\n  }\n  if (mDateTimeFormatter != null) {\n    try {\n      date=LocalDateTime.parse(dateStr,mDateTimeFormatter);\n    }\n catch (    DateTimeParseException e) {\n      Timber.d(String.format(\"ParseException parsing date: %s\",dateStr));\n      if (tryAgain) {\n        Timber.d(\"ParseException encountered, re-initializing the date parser\");\n        mDateTimeFormatter=null;\n        parseDate(dateStr,false);\n      }\n    }\n  }\n  return date;\n}\n", "docstring": "parses a string date into a java date object", "partition": "test"}
{"idx": "1376", "code": "public void updateButtonActionPerformed(){\n  if (!readReceiveDelay()) {\n    return;\n  }\n  if (!readPulseWidth()) {\n    return;\n  }\n  if (!checkConsistency()) {\n    return;\n  }\n  if (curNode.getNodeType() != nodeType) {\n    curNode.setNodeType(nodeType);\n  }\n  setNodeParameters();\n  changedNode=true;\n  editMode=false;\n  curNode=null;\n  addButton.setVisible(true);\n  editButton.setVisible(true);\n  deleteButton.setVisible(true);\n  doneButton.setVisible(true);\n  updateButton.setVisible(false);\n  cancelButton.setVisible(false);\n  nodeAddrField.setVisible(true);\n  nodeAddrStatic.setVisible(false);\n  statusText2.setText(stdStatus2);\n  statusText3.setText(stdStatus3);\n  statusText1.setText(rb.getString(\"FeedBackUpdate\") + \" \" + Integer.toString(nodeAddress));\n  errorInStatus1=true;\n}\n", "docstring": "method to handle update button", "partition": "test"}
{"idx": "2112", "code": "private void createNewReviewTask(TaskRepository repository,TaskData taskData) throws CoreException {\n  Repository repo=AppraisePluginUtils.getGitRepoForRepository(repository);\n  AppraisePluginReviewClient client;\n  try {\n    client=new AppraisePluginReviewClient(repository);\n  }\n catch (  GitClientException e1) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Failed to initialize git client\"));\n  }\n  String currentBranch;\n  try {\n    currentBranch=repo.getFullBranch();\n  }\n catch (  IOException e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Error retrieving current branch\",e));\n  }\n  if (MASTER_REF.equals(currentBranch)) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Cannot create review on master branch\"));\n  }\n  setAttributeValue(taskData,schema.REQUESTER,repository.getUserName());\n  setAttributeValue(taskData,schema.TARGET_REF,MASTER_REF);\n  setAttributeValue(taskData,schema.REVIEW_REF,currentBranch);\n  RevCommit reviewCommit;\n  try {\n    reviewCommit=client.getReviewCommit(currentBranch,MASTER_REF);\n  }\n catch (  GitClientException e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Cannot find a merge base\",e));\n  }\n  if (reviewCommit == null) {\n    throw new CoreException(new Status(IStatus.INFO,AppraiseConnectorPlugin.PLUGIN_ID,\"No commits to review on \" + currentBranch));\n  }\n  setAttributeValue(taskData,schema.DESCRIPTION,reviewCommit.getFullMessage());\n  setAttributeValue(taskData,schema.REVIEW_COMMIT,reviewCommit.getName());\n  try {\n    List<DiffEntry> diffs=client.getReviewDiffs(currentBranch,MASTER_REF);\n    populateDiffs(repository,diffs,taskData);\n  }\n catch (  Exception e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Failed to load review diffs\",e));\n  }\n}\n", "docstring": "sets up a new review on the current branch , as a task .", "partition": "test"}
{"idx": "282", "code": "public static InetAddress hexToInet6Address(String addrHexString) throws IllegalArgumentException {\n  try {\n    return numericToInetAddress(String.format(\"%s:%s:%s:%s:%s:%s:%s:%s\",addrHexString.substring(0,4),addrHexString.substring(4,8),addrHexString.substring(8,12),addrHexString.substring(12,16),addrHexString.substring(16,20),addrHexString.substring(20,24),addrHexString.substring(24,28),addrHexString.substring(28,32)));\n  }\n catch (  Exception e) {\n    Log.e(\"NetworkUtils\",\"error in hexToInet6Address(\" + addrHexString + \"): \"+ e);\n    throw new IllegalArgumentException(e);\n  }\n}\n", "docstring": "convert a 32 char hex string into a inet6address . throws a runtime exception if the string isn \"'\" t 32 chars , isn \"'\" t hex or can \"'\" t be made into an inet6address", "partition": "test"}
{"idx": "2361", "code": "public static boolean compareDoubles(double a,double b){\n  if (Double.isNaN(a) && Double.isNaN(b))   return true;\n  if (!Double.isInfinite(a) && !Double.isInfinite(b))   return Math.abs(a - b) <= EPSILON;\n  return a == b;\n}\n", "docstring": "compares two doubles for equality .", "partition": "test"}
{"idx": "4242", "code": "@Override public Query newFuzzyQuery(String text,int fuzziness){\n  if (settings.lowercaseExpandedTerms()) {\n    text=text.toLowerCase(settings.locale());\n  }\n  BooleanQuery.Builder bq=new BooleanQuery.Builder();\n  bq.setDisableCoord(true);\n  for (  Map.Entry<String,Float> entry : weights.entrySet()) {\n    try {\n      Query q=new FuzzyQuery(new Term(entry.getKey(),text),fuzziness);\n      q.setBoost(entry.getValue());\n      bq.add(q,BooleanClause.Occur.SHOULD);\n    }\n catch (    RuntimeException e) {\n      rethrowUnlessLenient(e);\n    }\n  }\n  return super.simplify(bq.build());\n}\n", "docstring": "dispatches to lucene \"'\" s simplequeryparser \"'\" s newfuzzyquery , optionally lowercasing the term first", "partition": "test"}
{"idx": "4145", "code": "public boolean areAllPermissionsGranted(){\n  return deniedPermissionResponses.isEmpty();\n}\n", "docstring": "returns whether the user has granted all the requested permission", "partition": "test"}
{"idx": "1165", "code": "protected SOAPRequest createSOAPRequest(final String methodName,final SOAPMethodRequestWriter requestWriter){\n  final PostMethod method=new PostMethod(endpoint.toString());\n  method.setContentChunked(false);\n  setRequestHeaders(method,methodName);\n  final SOAPRequestEntity requestEntity=buildRequestEntity(methodName,requestWriter);\n  requestEntity.setSOAPHeaderProvider(soapHeaderProvider);\n  final BufferedSOAPRequestEntity bufferedEntity=new BufferedSOAPRequestEntity(requestEntity);\n  method.setRequestEntity(bufferedEntity);\n  return new SOAPRequest(method,requestEntity);\n}\n", "docstring": "create a soap request for the given method name . the writing of the request body is delegated to the given request writer .", "partition": "test"}
{"idx": "3224", "code": "public static void copyExcept(Object src,Object dst,int oldSize,int removeIndex){\n  if (removeIndex > 0 && oldSize > 0) {\n    System.arraycopy(src,0,dst,0,removeIndex);\n  }\n  if (removeIndex < oldSize) {\n    System.arraycopy(src,removeIndex + 1,dst,removeIndex,oldSize - removeIndex - 1);\n  }\n}\n", "docstring": "copy the elements of an array , and remove one element .", "partition": "test"}
{"idx": "1680", "code": "public INDArray asMatrix(BufferedImage image){\n  if (channels == 3) {\n    return toBgr(image);\n  }\n else {\n    image=scalingIfNeed(image,true);\n    int w=image.getWidth();\n    int h=image.getHeight();\n    INDArray ret=Nd4j.create(h,w);\n    for (int i=0; i < h; i++) {\n      for (int j=0; j < w; j++) {\n        ret.putScalar(new int[]{i,j},image.getRGB(i,j));\n      }\n    }\n    return ret;\n  }\n}\n", "docstring": "convert an bufferedimage to a matrix", "partition": "test"}
{"idx": "578", "code": "@Override public void listVolumes(CommandInput input,CompletionHandler completionHandler){\n  createOrUpdateTargetSsl(input);\n  URI uri=UriUtils.extendUri(input.getDockerUri(),\"/volumes\");\n  sendGet(uri,null,completionHandler);\n}\n", "docstring": "https : / / docs . docker . com / engine / reference / api / docker_remote_api_v1 . 24 / section 3 . 4 volumes - list volumes", "partition": "test"}
{"idx": "2991", "code": "public void testNegPosFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=1;\n  byte rBytes[]={-74,91,47,-5,-13,-7,-5,-33,-49,-65,-1,-9,-3};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.or(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,result.signum());\n}\n", "docstring": "or for two negative numbers ; the first is shorter", "partition": "test"}
{"idx": "1655", "code": "public void onRestoreInstanceState(Bundle savedInstanceState){\n  mSelectedPositions.addAll(savedInstanceState.getIntegerArrayList(TAG));\n  Log.d(TAG,\"Restore selection \" + mSelectedPositions);\n}\n", "docstring": "restores the previous state of the selection on the items .", "partition": "test"}
{"idx": "3078", "code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  IdentitySubjectModel subjectModel=getSubjectModel();\n  PolicyModel model=(PolicyModel)getModel();\n  super.beginDisplay(event);\n  if (!canModify) {\n    Map mapValues=getDefaultValues();\n    if ((mapValues != null) && !mapValues.isEmpty()) {\n      Set values=(Set)mapValues.get(AMIdentityMembershipCondition.AM_IDENTITY_NAME);\n      Set identityNames=helper.getAMIdentityNames(model.getUserSSOToken(),values);\n      propertySheetModel.setValue(VALUES_MULTIPLE_CHOICE_VALUE,AMAdminUtils.getString(identityNames,\",\",false));\n    }\n  }\n else {\n    CCDropDownMenu menu=(CCDropDownMenu)getChild(FILTER_TYPE);\n    Map supportedEntityTypes=model.getSupportedEntityTypes(realmName);\n    OptionList entityTypes=createOptionList(supportedEntityTypes);\n    entityTypes.add(0,\"policy.subject.select.identity.type\",\"\");\n    menu.setOptions(entityTypes);\n    menu.setValue(\"\");\n    CCAddRemove child=(CCAddRemove)getChild(VALUES_MULTIPLE_CHOICE_VALUE);\n    child.restoreStateData();\n    if (!submitCycle) {\n      helper.setSelectedIdentities(child,model.getUserSSOToken(),model.getUserLocale(),this,getDefaultValues());\n    }\n else {\n      OptionList possible=helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,getPossibleValues(subjectModel,realmName));\n      OptionList selected=addRemoveModel.getSelectedOptionList();\n      List selectedIds=AMAdminUtils.toList(selected);\n      child.resetStateData();\n      addRemoveModel.setAvailableOptionList(possible);\n      addRemoveModel.setSelectedOptionList(helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,selectedIds));\n    }\n  }\n}\n", "docstring": "sets the values to ui model .", "partition": "test"}
{"idx": "2404", "code": "public Skype(String username,String password){\n  this.username=username;\n  this.password=password;\n}\n", "docstring": "builds a new skype connection without connecting to anything .", "partition": "test"}
{"idx": "1235", "code": "public static Color blend(Color color1,Color color2,double weight){\n  double w2=MathUtils.limit(weight,0.0,1.0);\n  double w1=1.0 - w2;\n  int r=(int)Math.round(w1 * color1.getRed() + w2 * color2.getRed());\n  int g=(int)Math.round(w1 * color1.getGreen() + w2 * color2.getGreen());\n  int b=(int)Math.round(w1 * color1.getBlue() + w2 * color2.getBlue());\n  int a=(int)Math.round(w1 * color1.getAlpha() + w2 * color2.getAlpha());\n  return new Color(r,g,b,a);\n}\n", "docstring": "linearly blends two colors with a defined weight .", "partition": "test"}
{"idx": "4098", "code": "public boolean isAdditiveNumber(String num){\n  int n=num.length();\n  for (int i=1; i <= n / 2; i++) {\n    if (num.charAt(0) == '0' && i > 1) {\n      return false;\n    }\n    BigInteger num1=new BigInteger(num.substring(0,i));\n    for (int j=1; Math.max(i,j) <= n - i - j; j++) {\n      if (num.charAt(i) == '0' && j > 1) {\n        break;\n      }\n      BigInteger num2=new BigInteger(num.substring(i,i + j));\n      if (isAdditiveNumber(num1,num2,i + j,num)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "recursive . generate the first and second of the sequence , check if the rest of the string match the sum recursively . i is the length of first number , j is the length of thgste second .", "partition": "test"}
{"idx": "4214", "code": "public static void pipeAll(InputStream inStr,OutputStream outStr) throws IOException {\n  byte[] bs=new byte[BUFFER_SIZE];\n  int numRead;\n  while ((numRead=inStr.read(bs,0,bs.length)) >= 0) {\n    outStr.write(bs,0,numRead);\n  }\n}\n", "docstring": "write the full contents of instr to the destination stream outstr .", "partition": "test"}
{"idx": "1474", "code": "private void buildDescriptionPanel(final Composite parent){\n  descriptionLabel=new StyledText(parent,SWT.READ_ONLY);\n  descriptionLabel.setText(\"\");\n  descriptionLabel.setLayoutData(new GridData(GridData.FILL,GridData.FILL,true,true,1,1));\n}\n", "docstring": "build the description panel", "partition": "test"}
{"idx": "1752", "code": "private boolean verifyMigrateFromProductHome(String migrateFromProductHome) throws InstallException {\n  if (migrateFromProductHome == null || migrateFromProductHome.length() == 0) {\n    Debug.log(\"MultipleMigrateDriver.verifyMigrateFromProductHome() :\" + \"empty product home by the user\");\n    Console.println(LocalizedMessage.get(LOC_HR_MSG_MIGRATE_NONE_FOUND));\n    return false;\n  }\n  if (!migrateFromProductHome.equals(ConfigUtil.getHomePath())) {\n    Debug.log(\"MultipleMigrateDriver.verifyMigrateFromProductHome() : \" + \"Migrate from product home: \" + migrateFromProductHome + \", New product home: \"+ ConfigUtil.getHomePath());\n    String translateFile=migrateFromProductHome + MigrateFromInstFinderStore.getRelativeTranslateFile();\n    if (!FileUtils.isFileValid(translateFile)) {\n      Console.println(LocalizedMessage.get(LOC_HR_MSG_MIGRATE_NONE_FOUND));\n      return false;\n    }\n  }\n else {\n    Debug.log(\"MultipleMigrateDriver - Error:\" + \"This product has been already migrated!\");\n    throw new InstallException(LocalizedMessage.get(LOC_DR_ERR_PRODUCT_ALREADY_MIGRATED));\n  }\n  return true;\n}\n", "docstring": "check if the product home input by the user has the locator file of the product to be migrated from .", "partition": "test"}
{"idx": "3929", "code": "public void put(byte[] buffer,int offset,int count){\n  if (count > (bytes.length - this.contentLength)) {\n    throw new IllegalArgumentException(\"buffer is too large\");\n  }\n  System.arraycopy(buffer,offset,bytes,this.contentLength,count);\n  this.contentLength+=count;\n}\n", "docstring": "puts content from the specified byte array to this bytearray", "partition": "test"}
{"idx": "2483", "code": "public static synchronized double partialCorrelation(TetradMatrix submatrix){\n  try {\n    TetradMatrix inverse=submatrix.inverse();\n    double a=-1.0 * inverse.get(0,1);\n    double v0=inverse.get(0,0);\n    double v1=inverse.get(1,1);\n    double b=Math.sqrt(v0 * v1);\n    return a / b;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return Double.NaN;\n  }\n}\n", "docstring": "assumes that the given covariance matrix was extracted in such a way that the order of the variables ( in either direction ) is x , y , z1 , . . . , zn , where the partial correlation one wants is correlation ( x , y | z1 , . . . , zn ) . this may be extracted using datautils . submatrix ( ) .", "partition": "test"}
{"idx": "596", "code": "@Override protected void onDestroy(){\n  super.onDestroy();\n  doReallyStop(false);\n  mFragments.dispatchDestroy();\n  if (mLoaderManager != null) {\n    mLoaderManager.doDestroy();\n  }\n}\n", "docstring": "destroy all fragments and loaders .", "partition": "test"}
{"idx": "322", "code": "public void addFrequentSet(FrequentItemSet itemSet){\n  frequentSets.add(itemSet);\n  maximumSetSize=Math.max(itemSet.getNumberOfItems(),maximumSetSize);\n}\n", "docstring": "adds a frequent item set to this container . conditionalitems and frequentitems are merged .", "partition": "test"}
{"idx": "2915", "code": "private int indexOfElementInLevel(int element,int level[]) throws Exception {\n  for (int i=0; i < level.length; i++) {\n    if (level[i] == element) {\n      return i;\n    }\n  }\n  throw new Exception(\"Error. Didn\\'t find element \" + m_nodes.get(element).ID + \" in level. Inspect code for \"+ \"weka.gui.graphvisualizer.HierarchicalBCEngine\");\n}\n", "docstring": "returns the index of an element in a level . must never be called with the wrong element and the wrong level , will throw an exception otherwise . it takes as agrument the index of the element ( in the m_nodes vector ) and the level it is supposed to be in ( as each level contains the indices of the nodes present in that level ) .", "partition": "test"}
{"idx": "891", "code": "private String readNfcErrorMsg(ByteBuffer reply) throws IOException {\n  int errorType=reply.getInt();\n  int errorCode=reply.getInt();\n  int msgLen=reply.getInt();\n  if (msgLen == 0) {\n    return \"\";\n  }\n  ByteBuffer msgBuffer=ByteBuffer.allocate(msgLen);\n  readFully(msgBuffer);\n  String errorMsg=new String(msgBuffer.array(),0,msgLen - 1,Charsets.US_ASCII);\n  return String.format(\"NFC Error %d/%d: %s\",errorType,errorCode,errorMsg);\n}\n", "docstring": "read nfc error from reply message .", "partition": "test"}
{"idx": "1881", "code": "public void append(char c[]){\n  int maxlength=buffer.length - pos;\n  if (c.length < maxlength) {\n    System.arraycopy(c,0,buffer,pos,c.length);\n    pos+=c.length;\n  }\n else {\n    System.arraycopy(c,0,buffer,pos,maxlength);\n    curr.next=new Entity(buffer);\n    curr=curr.next;\n    length+=buffer.length;\n    buffer=new char[(buffer.length > c.length - maxlength) ? buffer.length : c.length - maxlength];\n    if (c.length > maxlength) {\n      System.arraycopy(c,maxlength,buffer,0,c.length - maxlength);\n      pos=c.length - maxlength;\n    }\n else {\n      pos=0;\n    }\n  }\n}\n", "docstring": "method to appennd a charr array to the buffer", "partition": "test"}
{"idx": "2880", "code": "public TrieDictionary<T> build(int baseId){\n  byte[] trieBytes=buildTrieBytes(baseId);\n  TrieDictionary<T> r=new TrieDictionary<T>(trieBytes);\n  return r;\n}\n", "docstring": "flatten the trie into a byte array for a minimized memory footprint . lookup remains fast . cost is inflexibility to modify ( becomes immutable ) . flattened node structure is head + nodes , for each node : - o byte , offset to child node , o = stats . mbpn_sizechildoffset - 1 bit , islastchild flag , the 1st msb of o - 1 bit , isendofvalue flag , the 2nd msb of o - c byte , number of values beneath , c = stats . mbpn_sizenovaluebeneath - 1 byte , number of value bytes - n byte , value bytes", "partition": "test"}
{"idx": "1286", "code": "public static boolean isEmpty(String str){\n  return (null == str || 0 == str.length());\n}\n", "docstring": "is null or its length is 0", "partition": "test"}
{"idx": "507", "code": "public ModbusTransaction createTransaction(){\n  ModbusSerialTransaction transaction=new ModbusSerialTransaction();\n  transaction.setTransport(this);\n  return transaction;\n}\n", "docstring": "creates a new transaction suitable for the serial port", "partition": "test"}
{"idx": "2286", "code": "public TypedEventListener(EventListener<E> wrappedListener,Class<E> eventClass){\n  this.eventClass=eventClass;\n  this.wrappedListener=wrappedListener;\n}\n", "docstring": "constructs a new single typed event listener .", "partition": "test"}
{"idx": "60", "code": "public static ClassProperties loadProperties(Class[] cls,Properties properties,boolean inherit){\n  ClassProperties cp=new ClassProperties(properties);\n  for (  Class c : cls) {\n    cp.load(c,inherit);\n  }\n  return cp;\n}\n", "docstring": "for all the classes , loads all properties from each class annotations for the given platform .", "partition": "test"}
{"idx": "639", "code": "public UndoableEdit insertString(int where,String str) throws BadLocationException {\n  if (where >= count || where < 0) {\n    throw new BadLocationException(\"Invalid location\",count);\n  }\n  char[] chars=str.toCharArray();\n  replace(where,0,chars,0,chars.length);\n  if (marks != null) {\n    updateMarksForInsert(where,str.length());\n  }\n  return new InsertUndo(where,str.length());\n}\n", "docstring": "inserts a string into the content .", "partition": "test"}
{"idx": "932", "code": "public static String toUTF8String(String s){\n  return new String(s.getBytes(),Charset.forName(PanboxConstants.STANDARD_CHARSET));\n}\n", "docstring": "string conversion into standard charset", "partition": "test"}
{"idx": "2735", "code": "public static Pair<String,String> split(String varName){\n  int splitIndex=varName.indexOf('.');\n  if (splitIndex < 0) {\n    return null;\n  }\n  String left=varName.substring(0,splitIndex);\n  String right=varName.substring(splitIndex + 1);\n  if (left == null || left.length() == 0 || right == null || right.length() == 0) {\n    return null;\n  }\n  return Pair.of(left,right);\n}\n", "docstring": "splits a qualified varname into two parts , a left and a right left will be the text before the first instance of \"'\" . \"'\" right will be everything else returns null if the varname could not be split for any reason", "partition": "test"}
{"idx": "1444", "code": "protected final void _loadToHaveAtLeast(int minAvailable) throws IOException {\n  if (_inputStream == null) {\n    throw _constructError(\"Needed to read \" + minAvailable + \" bytes, reached end-of-input\");\n  }\n  int amount=_inputEnd - _inputPtr;\n  _currInputProcessed+=_inputPtr;\n  if (amount > 0 && _inputPtr > 0) {\n    System.arraycopy(_inputBuffer,_inputPtr,_inputBuffer,0,amount);\n    _inputEnd=amount;\n  }\n else {\n    _inputEnd=0;\n  }\n  _inputPtr=0;\n  while (_inputEnd < minAvailable) {\n    int count=_inputStream.read(_inputBuffer,_inputEnd,_inputBuffer.length - _inputEnd);\n    if (count < 1) {\n      _closeInput();\n      if (count == 0) {\n        throw new IOException(\"InputStream.read() returned 0 characters when trying to read \" + amount + \" bytes\");\n      }\n      throw _constructError(\"Needed to read \" + minAvailable + \" bytes, missed \"+ minAvailable+ \" before end-of-input\");\n    }\n    _inputEnd+=count;\n  }\n}\n", "docstring": "helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary", "partition": "test"}
{"idx": "257", "code": "public static File createTempPath(String path) throws IOException {\n  String sep=File.separator;\n  File tempDir=new File(System.getProperty(\"java.io.tmpdir\") + sep + path);\n  if (!tempDir.exists())   if (!tempDir.mkdirs()) {\n    boolean status=tempDir.delete();\n    throw new IOException(\"creation failed for dir \" + tempDir + \"status = \"+ status);\n  }\n  tempDir.deleteOnExit();\n  return tempDir;\n}\n", "docstring": "create a hierarchy of directories ( a path ) in the designated temp dir . if the jvm terminates normally , these will be cleaned up .", "partition": "test"}
{"idx": "2681", "code": "boolean closeOutbound() throws SSLException {\n  if (sslEngine == null || sslEngine.isOutboundDone()) {\n    return false;\n  }\n  sslEngine.closeOutbound();\n  createOutNetBuffer(0);\n  SSLEngineResult result;\n  for (; ; ) {\n    result=sslEngine.wrap(emptyBuffer.buf(),outNetBuffer.buf());\n    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n      outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n      outNetBuffer.limit(outNetBuffer.capacity());\n    }\n else {\n      break;\n    }\n  }\n  if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n    throw new SSLException(\"Improper close state: \" + result);\n  }\n  outNetBuffer.flip();\n  return true;\n}\n", "docstring": "start ssl shutdown process .", "partition": "test"}
{"idx": "2815", "code": "public void load(Entity unit) throws IllegalArgumentException {\n  if (!canLoad(unit)) {\n    throw new IllegalArgumentException(\"Can not load \" + unit.getShortName() + \" into this bay.\");\n  }\n  currentSpace-=1;\n  troops.addElement(unit.getId());\n}\n", "docstring": "load the given unit .", "partition": "test"}
{"idx": "3055", "code": "public void handleTblDSAttributeMapListHrefActionRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    WSPPServiceDSAttributeMapListEditViewBean vb=(WSPPServiceDSAttributeMapListEditViewBean)getViewBean(WSPPServiceDSAttributeMapListEditViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    vb.populateValues((String)getDisplayFieldValue(\"tblDSAttributeMapListHrefAction\"));\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n    forwardTo();\n  }\n}\n", "docstring": "handles edit ldap attribute mapping request .", "partition": "test"}
{"idx": "3926", "code": "public void rebuildEventList(boolean resetSelected){\n  if (logger.isLoggable(Level.FINE)) {\n    logger.fine(\"rebuilding list\");\n  }\n  allEvents=null;\n  activeEvents=null;\n  hideDetails();\n  initInterface(getActiveEvents(),resetSelected);\n  highlightCurrentEvent(currentTime);\n  firePropertyChange(ActiveEventsProperty,null,getActiveEvents());\n}\n", "docstring": "this is the method that rebuilds the list of visible events .", "partition": "test"}
{"idx": "2526", "code": "public static Element createElementInEncryptionSpace(Document doc,String elementName){\n  if (doc == null) {\n    throw new RuntimeException(\"Document is null\");\n  }\n  if ((xencPrefix == null) || (xencPrefix.length() == 0)) {\n    return doc.createElementNS(EncryptionConstants.EncryptionSpecNS,elementName);\n  }\n  return doc.createElementNS(EncryptionConstants.EncryptionSpecNS,xencPrefix + \":\" + elementName);\n}\n", "docstring": "creates an element in the xml encryption specification namespace .", "partition": "test"}
{"idx": "1644", "code": "private Set<String> primaryKeys(PreparedStatement stmt,String owner,String tbl) throws SQLException {\n  Set<String> pkCols=new HashSet<>();\n  stmt.setString(1,owner);\n  stmt.setString(2,tbl);\n  try (ResultSet pkRs=stmt.executeQuery()){\n    while (pkRs.next())     pkCols.add(pkRs.getString(1));\n  }\n   return pkCols;\n}\n", "docstring": "retrieve primary key columns .", "partition": "test"}
{"idx": "3478", "code": "private void export_dependencies(JCas jcas){\n  dependencies=new LinkedHashMap<Token,List<Dependency>>();\n  List<Token> nonGoverned=new ArrayList<Token>(nodes.keySet());\n  for (  Dependency dependency : select(jcas,Dependency.class)) {\n    Token governor=dependency.getGovernor();\n    Token dependent=dependency.getDependent();\n    List<Dependency> l=dependencies.get(governor);\n    if (l == null) {\n      dependencies.put(governor,new ArrayList<Dependency>());\n      l=dependencies.get(governor);\n    }\n    l.add(dependency);\n    nonGoverned.remove(dependent);\n  }\n  for (  Token t : nonGoverned) {\n    traverseDependents(t,\"\",-1);\n    writeToFile(\"component\",componentId,\"p\",\"dep\",\"dep\");\n    componentId++;\n  }\n}\n", "docstring": "traverse the dependency structure beginning from all \" roots \" , i . e . non - governed tokens .", "partition": "test"}
{"idx": "2734", "code": "public static String traceExcetion(Throwable ex){\n  final Writer result=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(result);\n  ex.printStackTrace(printWriter);\n  String stacktrace=result.toString();\n  Log.e(TAG,\"ERROR ---> \" + stacktrace);\n  return stacktrace;\n}\n", "docstring": "write exception throw in log", "partition": "test"}
{"idx": "2636", "code": "public static double crossTrackDistanceRad(double lat1,double lon1,double lat2,double lon2,double latQ,double lonQ){\n  final double dlon12=lon2 - lon1;\n  final double dlon1Q=lonQ - lon1;\n  final double dlat1Q=latQ - lat1;\n  final double clat1=Math.cos(lat1), slat1=MathUtil.cosToSin(lat1,clat1);\n  final double clatQ=Math.cos(latQ), slatQ=MathUtil.cosToSin(latQ,clatQ);\n  final double clat2=Math.cos(lat2), slat2=MathUtil.cosToSin(lat2,clat2);\n  final double slat=Math.sin(dlat1Q * .5);\n  final double slon=Math.sin(dlon1Q * .5);\n  final double a=slat * slat + slon * slon * clat1* clatQ;\n  final double angDist1Q=2 * Math.atan2(Math.sqrt(a),Math.sqrt(1 - a));\n  final double sdlon12=Math.sin(dlon12), cdlon12=MathUtil.sinToCos(dlon12,sdlon12);\n  final double sdlon1Q=Math.sin(dlon1Q), cdlon1Q=MathUtil.sinToCos(dlon1Q,sdlon1Q);\n  final double yE=sdlon12 * clat2;\n  final double yQ=sdlon1Q * clatQ;\n  final double xE=clat1 * slat2 - slat1 * clat2 * cdlon12;\n  final double xQ=clat1 * slatQ - slat1 * clatQ * cdlon1Q;\n  final double crs12=Math.atan2(yE,xE);\n  final double crs1Q=Math.atan2(yQ,xQ);\n  return Math.asin(Math.sin(angDist1Q) * Math.sin(crs1Q - crs12));\n}\n", "docstring": "compute the cross - track distance . xtd = asin ( sin ( dist_sq ) * sin ( crs_sq - crs_se ) )", "partition": "test"}
{"idx": "302", "code": "public void putBytes(byte[] bytes){\n  ensureCapacity(bytes.length);\n  System.arraycopy(bytes,0,this.byteBuffer,this.position,bytes.length);\n  this.position+=bytes.length;\n}\n", "docstring": "put an array of bytes in the buffer .", "partition": "test"}
{"idx": "3428", "code": "public boolean remove(JsonElement element){\n  return elements.remove(element);\n}\n", "docstring": "removes the first occurrence of the specified element from this array , if it is present . if the array does not contain the element , it is unchanged .", "partition": "test"}
{"idx": "33", "code": "protected <T extends AbstractOptionValue<?,?>>AbstractOptions(Function<T,T> valueFilter,AbstractOptions baseOptions,Iterable<T> values){\n  requireNonNull(baseOptions,\"baseOptions\");\n  requireNonNull(valueFilter,\"valueFilter\");\n  requireNonNull(values,\"values\");\n  valueMap=new IdentityHashMap<>(baseOptions.valueMap);\n  putAll(valueFilter,StreamSupport.stream(values.spliterator(),false));\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "1827", "code": "public static void importBaseTypes(final CConnection connection,final int rawModuleId,final int moduleId) throws SQLException {\n  final String query=\"INSERT INTO \" + CTableNames.BASE_TYPES_TABLE + \" SELECT \"+ moduleId+ \", id, name, size, pointer, signed \"+ \"FROM \"+ String.format(CTableNames.RAW_BASE_TYPES,rawModuleId);\n  connection.executeUpdate(query,true);\n  final String updateSequence=String.format(\"SELECT setval(\\'bn_base_types_id_seq\\', \" + \"COALESCE((SELECT MAX(id) + 1 FROM %s), 1), false) from %s\",CTableNames.BASE_TYPES_TABLE,CTableNames.BASE_TYPES_TABLE);\n  connection.executeQuery(updateSequence,true);\n}\n", "docstring": "imports the base types .", "partition": "test"}
{"idx": "821", "code": "@SuppressWarnings(\"unchecked\") public void restore(String fileName) throws IOException, ClassNotFoundException {\n  ObjectInputStream ois=new ObjectInputStream(new FileInputStream(fileName));\n  locations=(Map<V,Point>)ois.readObject();\n  ois.close();\n  initializeLocations();\n  locked=true;\n  fireStateChanged();\n}\n", "docstring": "restore the graph vertex locations from a file", "partition": "test"}
{"idx": "3284", "code": "public static boolean isObjectAvailableNow(final boolean enabled,final Date availableFrom,final Date availableTo,final Date now){\n  if (!enabled) {\n    return false;\n  }\n  if (availableFrom != null && now.before(availableFrom)) {\n    return false;\n  }\n  if (availableTo != null && now.after(availableTo)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "check availability of an object .", "partition": "test"}
{"idx": "740", "code": "@Override protected FieldConfigBase createCopy(FieldConfigBase fieldConfigBase){\n  FieldConfigFontPreview copy=null;\n  if (fieldConfigBase != null) {\n    copy=new FieldConfigFontPreview(fieldConfigBase.getCommonData());\n  }\n  return copy;\n}\n", "docstring": "creates a copy of the field .", "partition": "test"}
{"idx": "1670", "code": "public void test_reopen01(){\n  final IRawStore store=new SimpleMemoryRawStore();\n  final BTree btree;\n{\n    IndexMetadata md=new IndexMetadata(UUID.randomUUID());\n    md.setBranchingFactor(3);\n    btree=BTree.create(store,md);\n  }\n  assertTrue(btree.isOpen());\n  btree.close();\n  assertFalse(btree.isOpen());\n  try {\n    btree.close();\n    fail(\"Expecting: \" + IllegalStateException.class);\n  }\n catch (  IllegalStateException ex) {\n    if (log.isInfoEnabled())     log.info(\"Ignoring expected exception: \" + ex);\n  }\n  assertNotNull(btree.getRoot());\n  assertTrue(btree.isOpen());\n}\n", "docstring": "test close on a new tree - should force the root to the store since a new root is dirty ( if empty ) . reopen should then reload the empty root and on life goes .", "partition": "test"}
{"idx": "2323", "code": "private void initCheckbox(CheckBoxPreference checkbox,boolean checked,boolean enabled){\n  checkbox.setChecked(checked);\n  checkbox.setEnabled(enabled);\n}\n", "docstring": "initialize the service activation checkbox", "partition": "test"}
{"idx": "992", "code": "public void stopSampling(){\n  if (mSamplingCounter.decrementAndGet() == 0) {\n    mHandler.stopSamplingThread();\n    addFinalSample();\n  }\n}\n", "docstring": "finish sampling and prevent further changes to the connectionclass until another timer is started .", "partition": "test"}
{"idx": "2383", "code": "private void deleteCurrentLicenseFileOnDisk(){\n  File licenseFile=new File(LicenseConstants.LICENSE_FILE_PATH);\n  if (licenseFile.exists()) {\n    licenseFile.delete();\n  }\n}\n", "docstring": "deletes current version of license file in / tmp / . license", "partition": "test"}
{"idx": "1611", "code": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) public static <T extends Annotation>T unproxy(T annotation){\n  Function unproxyFunction=getUnproxyFunction(annotation.annotationType());\n  return (T)unproxyFunction.apply(annotation);\n}\n", "docstring": "convert java proxy annotation to specialized implementation , used to speedup equals / hashcode / tostring methods .", "partition": "test"}
{"idx": "3109", "code": "public SelectClause addWithAsProvidedName(String propertyName,String asName){\n  selectList.add(new SelectClauseExpression(new PropertyValueExpression(propertyName),asName));\n  return this;\n}\n", "docstring": "adds a single property name and an \" as \" - asname for the column .", "partition": "test"}
{"idx": "2473", "code": "public void test_vmstat_header_and_data_parse(){\n  final Pattern pattern=VMStatCollector.pattern;\n  final String header=\"  r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\";\n  final String data=\"  1  0     96 178580 206520 1170604   56   12     0     7    1    0  1  0 99  3  0\";\n{\n    final String[] fields=pattern.split(header.trim(),0);\n    for (int i=0; i < fields.length; i++) {\n      if (log.isInfoEnabled())       log.info(\"fields[\" + i + \"]=[\"+ fields[i]+ \"]\");\n    }\n    assertField(header,fields,2,\"swpd\");\n    assertField(header,fields,3,\"free\");\n    assertField(header,fields,6,\"si\");\n    assertField(header,fields,7,\"so\");\n    assertField(header,fields,12,\"us\");\n    assertField(header,fields,13,\"sy\");\n    assertField(header,fields,14,\"id\");\n    assertField(header,fields,15,\"wa\");\n  }\n{\n    final String[] fields=pattern.split(data.trim(),0);\n    assertField(data,fields,2,\"96\");\n    assertField(data,fields,3,\"178580\");\n    assertField(data,fields,6,\"56\");\n    assertField(data,fields,7,\"12\");\n    assertField(data,fields,12,\"1\");\n    assertField(data,fields,13,\"0\");\n    assertField(data,fields,14,\"99\");\n    assertField(data,fields,15,\"3\");\n  }\n}\n", "docstring": "test based on some sample data .", "partition": "test"}
{"idx": "2195", "code": "public boolean matchesNamingConvension(){\n  return packageName.matches(JAVA_PACKAGE_CONVENSION);\n}\n", "docstring": "check whether the package name match standard java package name conventions .", "partition": "test"}
{"idx": "1461", "code": "@Override public <R>CompletableFuture<R> collect(final Supplier<R> supplier,final BiConsumer<R,? super T> accumulator,final BiConsumer<R,R> combiner){\n  return CompletableFuture.supplyAsync(null,exec);\n}\n", "docstring": "asynchronously perform a stream collection", "partition": "test"}
{"idx": "30", "code": "public boolean isPrefixed(){\n  return name.indexOf(':') >= 0;\n}\n", "docstring": "it returns true if the attribute is prefixed ( used the \" : \" character ) .", "partition": "test"}
{"idx": "2942", "code": "boolean addToBuffer(char c) throws IOException {\n  int len=sb.length();\n  if (len == 0 && c != CHAR_LT)   return false;\n  sb.append(c);\n  if (++len >= minTagLen) {\n    boolean isClosingTag=(len >= 2 && sb.charAt(1) == CHAR_SL);\n    String substr;\n    if (isClosingTag)     substr=sb.substring(2);\n else     substr=sb.substring(1);\n    for (int i=0; i < EXCLUDE_TAGS.length; i++) {\n      if (substr.equalsIgnoreCase(EXCLUDE_TAGS[i])) {\n        if (isClosingTag) {\n          depthDec(i);\n          printBuffer();\n          lastChar=0;\n        }\n else {\n          depthInc(i);\n        }\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "checks if a character is part of an open html tag or close html tag , and if so adds it to the buffer , otherwise returns false .", "partition": "test"}
{"idx": "2174", "code": "private static boolean isTrusted(Object obj,TrustVerifier.Context ctx) throws RemoteException {\n  Object saved=state.get();\n  try {\n    state.set(obj);\n    return ctx.isTrustedObject(obj);\n  }\n  finally {\n    state.set(saved);\n  }\n}\n", "docstring": "returns result of calling ctx . istrustedobject ( obj ) with thread - local state set to obj .", "partition": "test"}
{"idx": "374", "code": "public int elevationAt(float lat,float lon){\n  if (frame_is_valid == true) {\n    if (lat >= dsi.sw_lat && lat <= dsi.ne_lat && lon >= dsi.sw_lon && lon <= dsi.ne_lon) {\n      int lat_index=Math.round((lat - dsi.sw_lat) * 36000 / uhl.lat_post_interval);\n      int lon_index=Math.round((lon - dsi.sw_lon) * 36000 / uhl.lon_post_interval);\n      if (elevations[lon_index] == null)       readDataRecord(lon_index);\n      return (int)elevations[lon_index][lat_index];\n    }\n  }\n  return -32767;\n}\n", "docstring": "the elevation at the closest sw post to the given lat / lon . this is just a go - to - the - closest - post solution .", "partition": "test"}
{"idx": "1585", "code": "public static Object objectFromByteBuffer(byte[] buffer) throws Exception {\n  if (buffer == null)   return null;\n  ByteArrayInputStream inStream=new ByteArrayInputStream(buffer);\n  ObjectInputStream in=new ObjectInputStreamExt(inStream);\n  Object retval=in.readObject();\n  in.close();\n  return retval;\n}\n", "docstring": "creates an object from a byte buffer .", "partition": "test"}
{"idx": "3724", "code": "long timestamp(long timestamp){\n  this.timestamp=Math.max(this.timestamp,timestamp);\n  return this.timestamp;\n}\n", "docstring": "returns an updated executor timestamp .", "partition": "test"}
{"idx": "1113", "code": "public void schemaChanged(String serviceName,String version){\nsynchronized (mapRealmToFormat) {\n    mapRealmToFormat.remove(ROOT);\n  }\n}\n", "docstring": "this method will be invoked when a service \"'\" s schema has been changed .", "partition": "test"}
{"idx": "738", "code": "private String attemptToChooseFormattingPattern(){\n  if (nationalNumber.length() >= MIN_LEADING_DIGITS_LENGTH) {\n    getAvailableFormats(nationalNumber.toString());\n    String formattedNumber=attemptToFormatAccruedDigits();\n    if (formattedNumber.length() > 0) {\n      return formattedNumber;\n    }\n    return maybeCreateNewTemplate() ? inputAccruedNationalNumber() : accruedInput.toString();\n  }\n else {\n    return appendNationalNumber(nationalNumber.toString());\n  }\n}\n", "docstring": "attempts to set the formatting template and returns a string which contains the formatted version of the digits entered so far .", "partition": "test"}
{"idx": "3361", "code": "public int read() throws IOException {\n  int val;\n  if ((val=is.read()) < 0) {\n    return -1;\n  }\n  if (bo == 'b') {\n    val=(char)((val << 8) | (is.read() & 0xff));\n  }\n else {\n    val=(char)((is.read() << 8) | (val & 0xff));\n  }\n  return val;\n}\n", "docstring": "reads a single character .", "partition": "test"}
{"idx": "3215", "code": "@Override public long handleCommit(final long commitTime){\n  if (error != null)   throw new IndexInconsistentError(error);\n  final IRootBlockView view=journal.getRootBlockView();\n  final ByteBuffer rbv=view.asReadOnlyBuffer();\n  final ByteBuffer bb=ByteBuffer.allocate(rbv.capacity());\n  for (int i=0; i < rbv.capacity(); i++) {\n    bb.put(rbv.get());\n  }\n  bb.flip();\n  return journal.write(bb);\n}\n", "docstring": "write the current root block to the journal and return its address to be stored in the commitrecord .", "partition": "test"}
{"idx": "1735", "code": "public void handleMaintenance(Operation maintOp){\n  performPendingRequestMaintenance();\n  checkAndScheduleSynchronization(this.cachedGroupState.membershipUpdateTimeMicros);\n  maintOp.complete();\n}\n", "docstring": "invoked by parent during its maintenance interval", "partition": "test"}
{"idx": "381", "code": "protected synchronized void onSendTaskCompleted(RecordBuffer<R> buffer){\n  logger.trace(\"{}:{} Send Completed\",name(),buffer);\n  activeSendTasks.decrementAndGet();\n}\n", "docstring": "this method should not raise any exceptions .", "partition": "test"}
{"idx": "2700", "code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)((float)Math.ceil(result));\n}\n", "docstring": "determines the height of this view", "partition": "test"}
{"idx": "3133", "code": "public Position createPosition(int offset) throws BadLocationException {\n  while (queue.poll() != null) {\n    unusedMarks++;\n  }\n  if (unusedMarks > Math.max(5,(marks.size() / 10))) {\n    removeUnusedMarks();\n  }\n  int g0=getGapStart();\n  int g1=getGapEnd();\n  int index=(offset < g0) ? offset : offset + (g1 - g0);\n  search.index=index;\n  int sortIndex=findSortIndex(search);\n  MarkData m;\n  StickyPosition position;\n  if (sortIndex < marks.size() && (m=marks.elementAt(sortIndex)).index == index && (position=m.getPosition()) != null) {\n  }\n else {\n    position=new StickyPosition();\n    m=new MarkData(index,position,queue);\n    position.setMark(m);\n    marks.insertElementAt(m,sortIndex);\n  }\n  return position;\n}\n", "docstring": "creates a position within the content that will track change as the content is mutated .", "partition": "test"}
{"idx": "2702", "code": "public void add(int i,int data){\n  if (_length + 1 > _capacity)   ensureCapacity(_length + 1);\n  System.arraycopy(_buffer,i,_buffer,i + 1,_length - i);\n  _buffer[i]=(byte)data;\n  _length+=1;\n}\n", "docstring": "inserts a byte array", "partition": "test"}
{"idx": "3980", "code": "public final double sampleMax(){\n  long max=_max.getAndSet(0);\n  return _scale * max;\n}\n", "docstring": "return the probe \"'\" s next sample .", "partition": "test"}
{"idx": "4050", "code": "@Override public void update(List<EnvVar> dataList){\n  envVarList.clear();\n  if (dataList == null) {\n    for (    EnvVar envVar : builtInEnvVarMap.values()) {\n      envVarList.add(envVar);\n    }\n  }\n else {\n    for (    EnvVar envVar : dataList) {\n      if (builtInEnvVarMap.containsKey(envVar.getName())) {\n        envVarList.add(new EnvVar(envVar,true));\n      }\n else {\n        envVarList.add(new EnvVar(envVar,false));\n      }\n    }\n  }\n  setEnvironmentVariableValues();\n}\n", "docstring": "update the environment variables .", "partition": "test"}
{"idx": "1355", "code": "protected int executePrepareStatement(List<Column> columns,PreparedStatement statement) throws SQLException {\n  int bindNo=1;\n  for (  Column c : columns) {\n    setColumnValue(statement,bindNo,c);\n    bindNo++;\n  }\n  return statement.executeUpdate();\n}\n", "docstring": "executes a prepared statement using values supplied as arguments .", "partition": "test"}
{"idx": "3002", "code": "public static float computeContrastBetweenColors(int bg,int fg){\n  float bgR=Color.red(bg) / 255f;\n  float bgG=Color.green(bg) / 255f;\n  float bgB=Color.blue(bg) / 255f;\n  bgR=(bgR < 0.03928f) ? bgR / 12.92f : (float)Math.pow((bgR + 0.055f) / 1.055f,2.4f);\n  bgG=(bgG < 0.03928f) ? bgG / 12.92f : (float)Math.pow((bgG + 0.055f) / 1.055f,2.4f);\n  bgB=(bgB < 0.03928f) ? bgB / 12.92f : (float)Math.pow((bgB + 0.055f) / 1.055f,2.4f);\n  float bgL=0.2126f * bgR + 0.7152f * bgG + 0.0722f * bgB;\n  float fgR=Color.red(fg) / 255f;\n  float fgG=Color.green(fg) / 255f;\n  float fgB=Color.blue(fg) / 255f;\n  fgR=(fgR < 0.03928f) ? fgR / 12.92f : (float)Math.pow((fgR + 0.055f) / 1.055f,2.4f);\n  fgG=(fgG < 0.03928f) ? fgG / 12.92f : (float)Math.pow((fgG + 0.055f) / 1.055f,2.4f);\n  fgB=(fgB < 0.03928f) ? fgB / 12.92f : (float)Math.pow((fgB + 0.055f) / 1.055f,2.4f);\n  float fgL=0.2126f * fgR + 0.7152f * fgG + 0.0722f * fgB;\n  return Math.abs((fgL + 0.05f) / (bgL + 0.05f));\n}\n", "docstring": "calculates the constrast between two colors , using the algorithm provided by the wcag v2 .", "partition": "test"}
{"idx": "2302", "code": "private static void generateGraphFile(TransMeta transMeta,String graphFile) throws GraphGeneratorException {\n  DataOutputStream dos=null;\n  try {\n    String xml=transMeta.getXML();\n    dos=new DataOutputStream(new FileOutputStream(new File(graphFile)));\n    dos.write(xml.getBytes(CarbonCommonConstants.DEFAULT_CHARSET));\n  }\n catch (  KettleException kettelException) {\n    throw new GraphGeneratorException(\"Error while getting the graph XML\",kettelException);\n  }\ncatch (  FileNotFoundException e) {\n    throw new GraphGeneratorException(\"Unable to find the graph fileL\",e);\n  }\ncatch (  UnsupportedEncodingException ue) {\n    throw new GraphGeneratorException(\"Error while Converting the graph xml string to bytes\",ue);\n  }\ncatch (  IOException ioe) {\n    throw new GraphGeneratorException(\"Error while writing the graph file\",ioe);\n  }\n finally {\n    if (dos != null) {\n      try {\n        dos.close();\n      }\n catch (      IOException e) {\n        e.getMessage();\n      }\n    }\n  }\n}\n", "docstring": "generate the graph file . . .", "partition": "test"}
{"idx": "1405", "code": "public boolean putProfile(Profile profile){\n  return putProfile(profile,false);\n}\n", "docstring": "create or update a profile for a remote counterpart .", "partition": "test"}
{"idx": "775", "code": "private static PolicyNotification extractPolicyNotification(String xml) throws PolicyEvaluationException {\n  PolicyNotification policyNotification=null;\n  try {\n    String notificationDataBlock=getNotificationDataBlock(xml);\n    if (notificationDataBlock != null) {\n      Document doc=XMLUtils.getXMLDocument(new ByteArrayInputStream(notificationDataBlock.getBytes()));\n      Node rootNode=XMLUtils.getRootNode(doc,NODE_POLICY_SERVICE);\n      if (rootNode != null) {\n        Node notificationNode=XMLUtils.getChildNode(rootNode,NODE_POLICY_NOTIFICATION);\n        if (notificationNode != null) {\n          policyNotification=PolicyNotification.parseXML(notificationNode);\n        }\n else {\n          debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\" + \"cannot find notification node\");\n          throw new PolicyEvaluationException(ResBundleUtils.rbName,\"invalid_root_element\",null,null);\n        }\n      }\n else {\n        debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\");\n      }\n    }\n else {\n      debug.error(\"ResultsCacheUtil:\" + \"extractPolicyNotification():\" + \"notification data block is null\");\n    }\n  }\n catch (  Exception xe) {\n    debug.error(\"ResultsCacheUtil.extractPolicyNotification():\",xe);\n    throw new PolicyEvaluationException(ResBundleUtils.rbName,\"xml_parsing_error\",null,xe);\n  }\n  return policyNotification;\n}\n", "docstring": "returns the notification xml node", "partition": "test"}
{"idx": "2798", "code": "protected final void print_contact_info(ObjectInfoPanel p_window,java.util.Locale p_locale){\n  Collection<BrdItem> contacts=get_normal_contacts();\n  if (contacts.isEmpty())   return;\n  GuiResources resources=r_board.newGuiResources(\"board.resources.ObjectInfoPanel\");\n  p_window.append(\", \" + resources.getString(\"contacts\") + \" \");\n  Integer contact_count=contacts.size();\n  p_window.append_items(contact_count.toString(),resources.getString(\"contact_info\"),contacts);\n}\n", "docstring": "internal function used in the implementation of print_info", "partition": "test"}
{"idx": "1308", "code": "ExternalProblem(Process process){\n  this(process.getInputStream(),process.getOutputStream());\n  RedirectStream.redirect(process.getErrorStream(),System.err);\n}\n", "docstring": "constructs an external problem using the specified process .", "partition": "test"}
{"idx": "735", "code": "public DataProviderEvent(final LocalizableMessage reason,final Set<Type> types){\n  Reject.ifNull(reason,types);\n  Reject.ifTrue(types.isEmpty());\n  this.reason=reason;\n  final EnumSet<Type> tmp=EnumSet.noneOf(Type.class);\n  tmp.addAll(types);\n  this.types=Collections.unmodifiableSet(tmp);\n}\n", "docstring": "creates a new data provider event .", "partition": "test"}
{"idx": "2308", "code": "public static java.util.Date toDate(String monthStr,String dayStr,String yearStr,String hourStr,String minuteStr,String secondStr){\n  int month, day, year, hour, minute, second;\n  try {\n    month=Integer.parseInt(monthStr);\n    day=Integer.parseInt(dayStr);\n    year=Integer.parseInt(yearStr);\n    hour=Integer.parseInt(hourStr);\n    minute=Integer.parseInt(minuteStr);\n    second=Integer.parseInt(secondStr);\n  }\n catch (  Exception e) {\n    return null;\n  }\n  return toDate(month,day,year,hour,minute,second);\n}\n", "docstring": "makes a date from separate strings for month , day , year , hour , minute , and second .", "partition": "test"}
{"idx": "2060", "code": "public void submit(String queueName,DispatcherTask dispatcherTask){\nsynchronized (syncRoot) {\n    DispatcherTaskRunner currentTaskRunner=currentTasksMap.get(queueName);\n    if (currentTaskRunner == null) {\n      currentTaskRunner=new DispatcherTaskRunner(queueName,dispatcherTask);\n      currentTasksMap.put(queueName,currentTaskRunner);\n      executorService.execute(currentTaskRunner);\n    }\n else {\n      enqueueNextTask(queueName,dispatcherTask);\n    }\n  }\n}\n", "docstring": "submits task to the specific queue", "partition": "test"}
{"idx": "193", "code": "protected void appendShortType(StringBuilder sb,FieldType fieldType,int fieldWidth){\n  sb.append(\"SMALLINT\");\n}\n", "docstring": "output the sql type for a java short .", "partition": "test"}
{"idx": "3904", "code": "public TimeSeriesCollection(){\n  this(null,TimeZone.getDefault());\n}\n", "docstring": "constructs an empty dataset , tied to the default timezone .", "partition": "test"}
{"idx": "2009", "code": "public static Request request(){\n  return threadLocal.get();\n}\n", "docstring": "get the current request , which is specific to the current thread .", "partition": "test"}
{"idx": "981", "code": "public PathImpl createTempFile(String prefix,String suffix) throws IOException {\n  if (prefix == null || prefix.length() == 0)   prefix=\"t\";\n  if (suffix == null)   suffix=\".tmp\";\nsynchronized (LOCK) {\n    for (int i=0; i < 32768; i++) {\n      int r=Math.abs((int)RandomUtil.getRandomLong());\n      PathImpl file=lookup(prefix + r + suffix);\n      if (file.createNewFile())       return file;\n    }\n  }\n  throw new IOException(\"cannot create temp file\");\n}\n", "docstring": "creates a unique temporary file as a child of this directory .", "partition": "test"}
{"idx": "2355", "code": "public static int[] extractArcs(ASN1ObjectIdentifier oid) throws InvalidObjectIdException {\n  String oidStr=oid.getId();\n  StringTokenizer strTokCnt=new StringTokenizer(oidStr,\".\",false);\n  int arcCount=strTokCnt.countTokens();\n  StringTokenizer strTok=new StringTokenizer(oidStr,\".\",true);\n  boolean expectDelimiter=false;\n  int[] arcs=new int[arcCount];\n  int i=0;\n  while (strTok.hasMoreTokens()) {\n    String token=strTok.nextToken();\n    if (expectDelimiter && (!token.equals(\".\") || !strTok.hasMoreTokens())) {\n      throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n    }\n else     if (!expectDelimiter) {\n      try {\n        arcs[i]=Integer.parseInt(token);\n        if (arcs[i] < 0) {\n          throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n        }\n        i++;\n      }\n catch (      NumberFormatException ex) {\n        throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n      }\n    }\n    expectDelimiter=!expectDelimiter;\n  }\n  return arcs;\n}\n", "docstring": "extract the arcs from an object identifier .", "partition": "test"}
{"idx": "42", "code": "private long computeInterfaceHash(){\n  long hash=0;\n  ByteArrayOutputStream sink=new ByteArrayOutputStream(512);\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    DataOutputStream out=new DataOutputStream(new DigestOutputStream(sink,md));\n    out.writeInt(INTERFACE_HASH_STUB_VERSION);\n    for (    Method method : remoteMethods) {\n      MethodDoc methodDoc=method.methodDoc();\n      out.writeUTF(methodDoc.name());\n      out.writeUTF(Util.methodDescriptorOf(methodDoc));\n      ClassDoc exceptions[]=methodDoc.thrownExceptions();\n      Arrays.sort(exceptions,new ClassDocComparator());\n      for (      ClassDoc ex : exceptions) {\n        out.writeUTF(Util.binaryNameOf(ex));\n      }\n    }\n    out.flush();\n    byte hashArray[]=md.digest();\n    for (int i=0; i < Math.min(8,hashArray.length); i++) {\n      hash+=((long)(hashArray[i] & 0xFF)) << (i * 8);\n    }\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new AssertionError(e);\n  }\n  return hash;\n}\n", "docstring": "computes the \" interface hash \" of the stub / skeleton pair for this remote implementation class . this is the 64 - bit value used to enforce compatibility between a stub class and a skeleton class in the jdk 1 . 1 version of the jrmp stub / skeleton protocol . it is calculated using the first 64 bits of an sha digest . the digest is of a stream consisting of the following data : ( int ) stub version number , always 1 for each remote method , in order of operation number : ( utf - 8 ) method name ( utf - 8 ) method descriptor for each declared exception , in alphabetical name order : ( utf - 8 ) name of exception class ( where \" utf - 8 \" includes a 16 - bit length prefix as written by java . io . dataoutput . writeutf ) .", "partition": "test"}
{"idx": "788", "code": "private void consumeNestedScroll(int dxUnconsumed,int dyUnconsumed,int dxFinalUnconsumed,int dyFinalUnconsumed){\n  if (mOverScrollEffect == OverScrollEffect.BOUNCE && dyFinalUnconsumed != 0) {\n    mUnconsumedOverScrollOffset+=-dyFinalUnconsumed;\n    int maxOffset=mOverScrollOffsetLimit;\n    if (mUnconsumedOverScrollOffset > 0) {\n      mUnconsumedOverScrollOffset=Math.min(maxOffset,mUnconsumedOverScrollOffset);\n    }\n else     if (mUnconsumedOverScrollOffset < 0) {\n      mUnconsumedOverScrollOffset=Math.max(-maxOffset,mUnconsumedOverScrollOffset);\n    }\n    setScrollingOffset(getUnconsumedScrollingOffset());\n  }\n  pullEdgeEffects(dxUnconsumed,dyUnconsumed);\n}\n", "docstring": "consume the final unconsumed nested scroll after all behaviors done .", "partition": "test"}
{"idx": "1449", "code": "private String buildToolTip(final CTaggedGraphNodesContainerNode node){\n  final StringBuilder tooltip=new StringBuilder(\"<html>\");\n  boolean first=true;\n  for (  final NaviNode graphnode : node.getGraphNodes()) {\n    if (!first) {\n      tooltip.append(\"<br>\");\n    }\n    tooltip.append(CNodesDisplayString.getDisplayString(graphnode));\n    first=false;\n  }\n  return tooltip + \"</html>\";\n}\n", "docstring": "generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes .", "partition": "test"}
{"idx": "1031", "code": "private int moveComponents(Container target,int x,int y,int width,int height,int rowStart,int rowEnd,boolean ltr,boolean useBaseline,int[] ascent,int[] descent){\nswitch (newAlign) {\ncase LEFT:\n    x+=ltr ? 0 : width;\n  break;\ncase CENTER:\nx+=width / 2;\nbreak;\ncase RIGHT:\nx+=ltr ? width : 0;\nbreak;\ncase LEADING:\nbreak;\ncase TRAILING:\nx+=width;\nbreak;\n}\nint maxAscent=0;\nint nonbaselineHeight=0;\nint baselineOffset=0;\nif (useBaseline) {\nint maxDescent=0;\nfor (int i=rowStart; i < rowEnd; i++) {\nComponent m=target.getComponent(i);\nif (m.visible) {\nif (ascent[i] >= 0) {\nmaxAscent=Math.max(maxAscent,ascent[i]);\nmaxDescent=Math.max(maxDescent,descent[i]);\n}\n else {\nnonbaselineHeight=Math.max(m.getHeight(),nonbaselineHeight);\n}\n}\n}\nheight=Math.max(maxAscent + maxDescent,nonbaselineHeight);\nbaselineOffset=(height - maxAscent - maxDescent) / 2;\n}\nfor (int i=rowStart; i < rowEnd; i++) {\nComponent m=target.getComponent(i);\nif (m.isVisible()) {\nint cy;\nif (useBaseline && ascent[i] >= 0) {\ncy=y + baselineOffset + maxAscent - ascent[i];\n}\n else {\ncy=y + (height - m.height) / 2;\n}\nif (ltr) {\nm.setLocation(x,cy);\n}\n else {\nm.setLocation(target.width - x - m.width,cy);\n}\nx+=m.width + hgap;\n}\n}\nreturn height;\n}\n", "docstring": "centers the elements in the specified row , if there is any slack .", "partition": "test"}
{"idx": "3025", "code": "void insertFunction2(ByteBuffer bb){\n  int baseSec=(int)(windowId >> 32);\n  bb.putInt(baseSec);\n  Integer operId=operatorId;\n  for (int i=0; i < 3; i++) {\n    byte num=(byte)(operId >> 8 * (2 - i));\n    bb.put(num);\n  }\n  bb.putShort((short)(windowId & 0xffff));\n  for (int i=0; i < 3; i++) {\n    byte num=(byte)(tupleId >> 8 * (2 - i));\n    bb.put(num);\n  }\n}\n", "docstring": "4b basesec | 3b operatorid | 2b windowid | 3b tupleid", "partition": "test"}
{"idx": "611", "code": "public void removeTitlePrefix(String prfx){\n  titlePrefix.remove(prfx);\n  firePropertyChange(TITLE_PREFIX,null,titlePrefix);\n}\n", "docstring": "removes the title prefix .", "partition": "test"}
{"idx": "234", "code": "public static void assertProps(UniformPair<EventBean> received,String[] propertyNames,Object[] expectedInsert,Object[] expectedRemoved){\n  assertProps(received.getFirst(),propertyNames,expectedInsert);\n  assertProps(received.getSecond(),propertyNames,expectedRemoved);\n}\n", "docstring": "assert that the property values of a new event and a removed event match the expected insert and removed values .", "partition": "test"}
{"idx": "3488", "code": "private void assertBackupStatus(final BackupStatus backupStatus){\n  Map<DistributedMember,Set<PersistentID>> backupMap=backupStatus.getBackedUpDiskStores();\n  assertFalse(backupMap.isEmpty());\n  for (  DistributedMember member : backupMap.keySet()) {\n    for (    PersistentID id : backupMap.get(member)) {\n      assertNotNull(id.getHost());\n      assertNotNull(id.getUUID());\n      assertNotNull(id.getDirectory());\n    }\n  }\n}\n", "docstring": "used to confirm valid backupstatus data . confirms fix for defect # 45657", "partition": "test"}
{"idx": "1069", "code": "private void interpolateResultList(ArrayList<PathParser.PathDataNode> list){\n  if (list == null || list.size() <= 2)   return;\n  float[][] listPenPos=PathNodeUtils.calculatePenPosition(list);\n  ArrayList<PathParser.PathDataNode> subList=new ArrayList<>();\n  int size=list.size();\n  PathParser.PathDataNode currentNode=null;\n  int i=0;\n  while (i < size - 1) {\n    currentNode=list.get(i);\n    if (!isInterpolatableCommand(currentNode.mType)) {\n      i++;\n      continue;\n    }\n    boolean validSequence=true;\n    int k=i;\n    for (int j=i; j < size && validSequence; j++) {\n      if (currentNode.mType == list.get(j).mType) {\n        k=j;\n        if (!Arrays.equals(currentNode.mParams,list.get(j).mParams))         break;\n      }\n else       validSequence=false;\n    }\n    if (k - i > 2) {\n      interpolateSubList(list.subList(i,k + 1));\n    }\n    i++;\n  }\n}\n", "docstring": "apply interpolation on the result list ( where possible )", "partition": "test"}
{"idx": "3713", "code": "public EmBayesEstimatorEditor(EmBayesEstimatorWrapper emBayesEstWrapper){\n  this(emBayesEstWrapper.getEstimateBayesIm(),emBayesEstWrapper.getDataSet());\n}\n", "docstring": "constructs a new bayes im editor from a bayes estimator wrapper .", "partition": "test"}
{"idx": "807", "code": "public GradleDistribution deserializeFromString(String distributionString){\n  Preconditions.checkNotNull(distributionString);\n  String localInstallationPrefix=\"GRADLE_DISTRIBUTION(LOCAL_INSTALLATION(\";\n  if (distributionString.startsWith(localInstallationPrefix) && distributionString.endsWith(\"))\")) {\n    String localInstallationDir=distributionString.substring(localInstallationPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forLocalInstallation(new File(localInstallationDir));\n  }\n  String remoteDistributionPrefix=\"GRADLE_DISTRIBUTION(REMOTE_DISTRIBUTION(\";\n  if (distributionString.startsWith(remoteDistributionPrefix) && distributionString.endsWith(\"))\")) {\n    String remoteDistributionUri=distributionString.substring(remoteDistributionPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forRemoteDistribution(createURI(remoteDistributionUri));\n  }\n  String versionPrefix=\"GRADLE_DISTRIBUTION(VERSION(\";\n  if (distributionString.startsWith(versionPrefix) && distributionString.endsWith(\"))\")) {\n    String version=distributionString.substring(versionPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forVersion(version);\n  }\n  String wrapperString=\"GRADLE_DISTRIBUTION(WRAPPER)\";\n  if (distributionString.equals(wrapperString)) {\n    return GradleDistribution.fromBuild();\n  }\n  String message=String.format(\"Cannot deserialize Gradle distribution string \\'%s.\\'\",distributionString);\n  throw new RuntimeException(message);\n}\n", "docstring": "deserializes the gradle distribution from the the given string representation .", "partition": "test"}
{"idx": "31", "code": "public void releaseAnyConnection(Connection connection) throws SQLException {\n  try {\n    connection.close();\n  }\n catch (  Exception ex) {\n    throw new RuntimeException(ex);\n  }\n}\n", "docstring": "release a non - shard - specific connection .", "partition": "test"}
{"idx": "221", "code": "public void fireAnnotationSelected(WorkflowAnnotation anno){\n  List<WorkflowAnnotation> list=new LinkedList<>();\n  list.add(anno);\n  fireAnnotationsChanged(AnnotationEvent.SELECTED_ANNOTATION_CHANGED,list);\n}\n", "docstring": "fire when an annotation has been selected .", "partition": "test"}
{"idx": "3496", "code": "public StateMachine createStateMachine(StateMachineDefinition stateMachineDefinition){\n  final Map<EventDefinition,EventData> eventDataMap=stateMachineDefinition.getEventDataMap();\n  Set<Event> allEvents=createAllEvents(eventDataMap);\n  Set<StateDefinition> stateDefinitions=stateMachineDefinition.getStates();\n  Set<State> states=new HashSet<>();\n  for (  StateDefinition stateDefinition : stateDefinitions) {\n    State state=convertStateDefinitionToState(stateDefinition);\n    states.add(state);\n  }\n  StateMachine stateMachine=new StateMachine(stateMachineDefinition.getVersion(),stateMachineDefinition.getName(),stateMachineDefinition.getDescription(),states,stateMachineDefinition.getCorrelationId());\n  stateMachinesDAO.create(stateMachine);\n  for (  Event event : allEvents) {\n    event.setStateMachineInstanceId(stateMachine.getId());\n    eventPersistenceService.persistEvent(event);\n  }\n  for (  State state : stateMachine.getStates()) {\n    auditDAO.create(new AuditRecord(stateMachine.getId(),state.getId(),0L,Status.initialized,null,null));\n  }\n  return stateMachine;\n}\n", "docstring": "converts state machine definition to state machine domain object and saves in db .", "partition": "test"}
{"idx": "672", "code": "private void updateUiFromCommand(Command command){\n  if (command == null) {\n    return;\n  }\n  actionsComboBox.setText(command.getAction());\n  dataTextField.setText(command.getData());\n  categoryTextField.setText(command.getCategory());\n  mimeTextField.setText(command.getMimeType());\n  componentTextField.setText(command.getComponent());\n  userTextField.setText(command.getUser());\n  flagsList_.removeSelectionInterval(0,flagsList_.getItemsCount());\n  List<IntentFlags> flags=command.getFlags();\n  if (flags != null && flags.size() > 0) {\n    for (    IntentFlags flag : command.getFlags()) {\n      flagsList_.setSelectedValue(flag,false);\n    }\n  }\n else {\n    flagsList_.setSelectedIndex(0);\n  }\n  updateFlagsTextField();\n  tableModel_.removeAllRows();\n  List<ExtraField> extras=command.getExtras();\n  if (extras != null && extras.size() > 0) {\n    for (    ExtraField extra : extras) {\n      tableModel_.addRow(extra);\n    }\n  }\n  updateTableVisibility();\n}\n", "docstring": "fills up vies from given command", "partition": "test"}
{"idx": "2878", "code": "private Object stringToValue(Object oldValue,String newValue) throws ReplicatorException {\n  if (oldValue instanceof String) {\n    return newValue;\n  }\n else   if (oldValue instanceof Integer) {\n    return Integer.valueOf(newValue);\n  }\n else   if (oldValue instanceof SerialBlob) {\n    try {\n      return DatabaseHelper.getSafeBlob(newValue.getBytes());\n    }\n catch (    SQLException e) {\n      throw new ReplicatorException(\"Unable to convert back from String to SerialBlob: \" + e,e);\n    }\n  }\n else {\n    return newValue;\n  }\n}\n", "docstring": "converts string back to correct ( previous ) data type .", "partition": "test"}
{"idx": "3230", "code": "public static double P_Harmonic(int Y[][],int Ypred[][]){\n  int allMissings=0;\n  int N=Y.length;\n  double loss=0.0;\n  for (int i=0; i < N; i++) {\n    if (allMissing(Y[i])) {\n      allMissings++;\n      continue;\n    }\n    double curLoss=P_Harmonic(Y[i],Ypred[i]);\n    if (Double.isNaN(curLoss)) {\n      allMissings++;\n      continue;\n    }\n    loss+=curLoss;\n  }\n  return loss / (double)(N - allMissings);\n}\n", "docstring": "harmonic accuracy - - average over all labels . multi - label only .", "partition": "test"}
{"idx": "2861", "code": "public String replace(CharSequence target,CharSequence replacement){\n  if (target == null) {\n    throw new NullPointerException(\"target should not be null\");\n  }\n  if (replacement == null) {\n    throw new NullPointerException(\"replacement should not be null\");\n  }\n  String ts=target.toString();\n  int index=indexOf(ts,0);\n  if (index == -1)   return this;\n  String rs=replacement.toString();\n  StringBuilder buffer=new StringBuilder(count);\n  int tl=target.length();\n  int tail=0;\n  do {\n    buffer.append(value,offset + tail,index - tail);\n    buffer.append(rs);\n    tail=index + tl;\n  }\n while ((index=indexOf(ts,tail)) != -1);\n  buffer.append(value,offset + tail,count - tail);\n  return buffer.toString();\n}\n", "docstring": "copies this string replacing occurrences of the specified target sequence with another sequence . the string is processed from the beginning to the end .", "partition": "test"}
{"idx": "1945", "code": "public void addPauseListener(AnimatorPauseListener listener){\n  if (mPauseListeners == null) {\n    mPauseListeners=new ArrayList<AnimatorPauseListener>();\n  }\n  mPauseListeners.add(listener);\n}\n", "docstring": "adds a pause listener to this animator .", "partition": "test"}
{"idx": "3780", "code": "private void handleResponse(AvsResponse response){\n  boolean checkAfter=(avsQueue.size() == 0);\n  if (response != null) {\n    for (int i=response.size() - 1; i >= 0; i--) {\n      if (response.get(i) instanceof AvsReplaceAllItem || response.get(i) instanceof AvsReplaceEnqueuedItem) {\n        avsQueue.clear();\n        response.remove(i);\n      }\n    }\n    Log.i(TAG,\"Adding \" + response.size() + \" items to our queue\");\n    avsQueue.addAll(response);\n  }\n  if (checkAfter) {\n    checkQueue();\n  }\n}\n", "docstring": "handle the response sent back from alexa \"'\" s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen )", "partition": "test"}
{"idx": "1954", "code": "public void addOperand(ISpacePredicate operand){\n  if (_operandsList == null)   _operandsList=new ArrayList<ISpacePredicate>();\n  _operandsList.add(operand);\n}\n", "docstring": "adds an operand at the end of the current operands list .", "partition": "test"}
{"idx": "1569", "code": "public void bindKeyStore(final KeyStoreService keyStoreService){\n  this.keyStore=keyStoreService;\n}\n", "docstring": "binds the keystore to the truststore service . this method is needed to prevent compilation errors .", "partition": "test"}
{"idx": "858", "code": "private static String checksumMD5(String data){\n  MessageDigest md5=null;\n  try {\n    md5=MessageDigest.getInstance(\"MD5\");\n  }\n catch (  NoSuchAlgorithmException ex) {\n    throw new RuntimeException(\"Unable to create MD5 instance\",ex);\n  }\n  return hexEncode(md5.digest(data.getBytes()));\n}\n", "docstring": "md5 version of the \" h ( ) \" function from rfc2617 .", "partition": "test"}
{"idx": "1864", "code": "@Override public boolean equalsValue(final Object other){\n  return Objects.equals(this.value,other);\n}\n", "docstring": "indicates whether some other object is \" equal to \" the value . the other value is equal if object . equals ( value , other ) returns true .", "partition": "test"}
{"idx": "393", "code": "public static void write(int x1,int y1,Image image,int image_width,int image_height,LinkProperties properties,DataOutputStream dos) throws IOException, InterruptedException {\n  int[] pixels=new int[image_width * image_height];\n  PixelGrabber pixelgrabber=new PixelGrabber(image,0,0,image_width,image_height,pixels,0,image_width);\n  pixelgrabber.grabPixels();\n  LinkRaster.write(x1,y1,image_width,image_height,pixels,properties,dos);\n}\n", "docstring": "write an image , x / y placement with an imageicon .", "partition": "test"}
{"idx": "1141", "code": "private void fireEvent(final IRunningQuery q){\n  if (q == null)   throw new IllegalArgumentException();\n  if (listeners.isEmpty()) {\n    return;\n  }\n  final IRunningQueryListener[] a=listeners.toArray(new IRunningQueryListener[0]);\n  for (  IRunningQueryListener l : a) {\n    final IRunningQueryListener listener=l;\n    try {\n      listener.notify(q);\n    }\n catch (    Throwable t) {\n      if (InnerCause.isInnerCause(t,InterruptedException.class)) {\n        throw new RuntimeException(t);\n      }\n      log.error(t,t);\n    }\n  }\n}\n", "docstring": "send an event to all registered listeners .", "partition": "test"}
{"idx": "1261", "code": "public String importTrl(String directory,int AD_Client_ID,String AD_Language,String Trl_Table){\n  String fileName=directory + File.separator + Trl_Table+ \"_\"+ AD_Language+ \".xml\";\n  log.info(fileName);\n  File in=new File(fileName);\n  if (!in.exists()) {\n    String msg=\"File does not exist: \" + fileName;\n    log.log(Level.SEVERE,msg);\n    return msg;\n  }\n  try {\n    TranslationHandler handler=new TranslationHandler(AD_Client_ID);\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(in,handler);\n    log.info(\"Updated=\" + handler.getUpdateCount());\n    return Msg.getMsg(m_ctx,\"Updated\") + \"=\" + handler.getUpdateCount();\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,\"importTrl\",e);\n    return e.toString();\n  }\n}\n", "docstring": "import translation . uses translationhandler to update translation", "partition": "test"}
{"idx": "3754", "code": "private void validateCollectionAttribute(CollectionAttribute collection,Set<String> allCollections){\n  if (collection == null || allCollections == null) {\n    return;\n  }\n  for (  RestMethod restMethod : collection.getMethods()) {\n    if (allCollections.contains(restMethod.getRestFullMethodName())) {\n      aspect.warning(SimpleLocation.TOPLEVEL,\"The rpc methods and the associated http paths are not following the guidelines. As a \" + \"result the derived rest collection \\'%s\\' contains a sub collection and a \" + \"method with the same name as \\'%s\\'. This can cause a failure to generate client \"+ \"library, since these names are used for generating artifacts in generated code.\",collection.getFullName(),restMethod.getRestMethodName());\n    }\n  }\n}\n", "docstring": "validates if the collection does not contain same named elements ( methods and resources ) .", "partition": "test"}
{"idx": "4237", "code": "void readPRJ() throws IOException {\n  while (true) {\n    String S=isr.readLine();\n    if (S == null)     return;\n    if (S.startsWith(\"EOP\"))     return;\n  }\n}\n", "docstring": "read prj records ( in fact does nothing )", "partition": "test"}
{"idx": "3790", "code": "public java.lang.StringBuffer insert(int offset,char c){\n  internal.insert(offset,c);\n  return this;\n}\n", "docstring": "inserts the string representation of the char argument into this string buffer . the second argument is inserted into the contents of this string buffer at the position indicated by offset . the length of this string buffer increases by one . the overall effect is exactly as if the argument were converted to a string by the method string . valueof ( char ) and the character in that string were then inserted into this stringbuffer object at the position indicated by offset . the offset argument must be greater than or equal to 0 , and less than or equal to the length of this string buffer .", "partition": "test"}
{"idx": "3569", "code": "public void testPlusMathContextPositive(){\n  String a=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=41;\n  int precision=37;\n  RoundingMode rm=RoundingMode.FLOOR;\n  MathContext mc=new MathContext(precision,rm);\n  String c=\"929487820944884782312124789.8748298842\";\n  int cScale=10;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal res=aNumber.plus(mc);\n  assertEquals(\"incorrect value\",c,res.toString());\n  assertEquals(\"incorrect scale\",cScale,res.scale());\n}\n", "docstring": "plus ( mathcontext ) for a positive bigdecimal", "partition": "test"}
{"idx": "3880", "code": "protected boolean display(File helpFile) throws HelpException {\n  if (helpFile.exists()) {\n    loadAndWrite(helpFile);\n    return true;\n  }\n else {\n    File notFound=new File(helpDir,NOT_FOUND);\n    if (notFound.exists())     loadAndWrite(notFound);\n else     throw new HelpException(\"Topic not found, try \\'help\\' for more information\");\n    return false;\n  }\n}\n", "docstring": "displays the requested help file if it is found . if not , we first try to display the default not found message . if that is not available , we display a default message .", "partition": "test"}
{"idx": "3051", "code": "public static double[] expandArrayD(int bufferSize,double[] currentArray){\n  if (currentArray == null) {\n    return new double[bufferSize * 3];\n  }\n  int length=currentArray.length;\n  double[] ret=new double[length + bufferSize * 3];\n  System.arraycopy(currentArray,0,ret,0,length);\n  return ret;\n}\n", "docstring": "create an array to hold double data for 3d polygons and lines .", "partition": "test"}
{"idx": "3148", "code": "public void test_multipleResourceLocking_resources10_locktries10() throws Exception {\n  final Properties properties=new Properties();\n  properties.setProperty(TestOptions.NTHREADS,\"20\");\n  properties.setProperty(TestOptions.NTASKS,\"1000\");\n  properties.setProperty(TestOptions.NRESOURCES,\"100\");\n  properties.setProperty(TestOptions.MIN_LOCKS,\"10\");\n  properties.setProperty(TestOptions.MAX_LOCKS,\"10\");\n  properties.setProperty(TestOptions.MAX_LOCK_TRIES,\"10\");\n  properties.setProperty(TestOptions.PREDECLARE_LOCKS,\"false\");\n  properties.setProperty(TestOptions.SORT_LOCK_REQUESTS,\"false\");\n  properties.setProperty(TestOptions.TIMEOUT,Long.toString(3 * 60));\n  doComparisonTest(properties);\n}\n", "docstring": "test where each operation locks one or more resources . < p > note : this condition provides the basis for deadlocks . in fact , since we have 10 resource locks for each operation and only 100 operations the chances of a deadlock on any given operation are extremely high . however , since we are predeclaring our locks and the lock requests are being sorted no deadlocks should result .", "partition": "test"}
{"idx": "3356", "code": "public void addMessage(String message){\n  messages.addLast(message);\n  if (messages.size() > MAX_HISTORY) {\n    messages.removeFirst();\n  }\n  pointer=messages.size();\n}\n", "docstring": "add a message to the history", "partition": "test"}
{"idx": "2005", "code": "public void addDelete(IResource delete){\n  if (fDelete == null)   fDelete=new ArrayList<IResource>(2);\n  fDelete.add(delete);\n  if (fIgnoreCount == 0) {\n    internalAdd(new DeleteDescription(delete));\n  }\n}\n", "docstring": "adds the given resource to the list of resources to be deleted .", "partition": "test"}
{"idx": "2654", "code": "public final int size(){\n  if (GWT.isScript()) {\n    return jsArray.size();\n  }\n else {\n    return javaArray.size();\n  }\n}\n", "docstring": "return the list size", "partition": "test"}
{"idx": "339", "code": "public void unlockForClear(InternalDistributedMember locker){\nsynchronized (this.clearLockSync) {\n    InternalDistributedSystem instance=InternalDistributedSystem.getAnyInstance();\n    if (instance != null && logger.isDebugEnabled()) {\n      logger.debug(\"Unlocking for clear, from member {} RVV {}\",locker,System.identityHashCode(this));\n    }\n    if (this.lockOwner != null && !locker.equals(this.lockOwner)) {\n      if (instance != null && logger.isDebugEnabled()) {\n        logger.debug(\"current clear lock owner was {} not unlocking\",lockOwner);\n      }\n      return;\n    }\n    unlockVersionGeneration(locker);\n  }\n}\n", "docstring": "unlocks version generation for clear ( ) operations", "partition": "test"}
{"idx": "3829", "code": "public boolean shouldInclude(final Path path){\n  return includeMatchers.size() == 0 || matches(path,includeMatchers);\n}\n", "docstring": "check whether a path should be included .", "partition": "test"}
{"idx": "268", "code": "@Override public void mousePressed(MouseEvent e){\n  m_frameLimiter.setRepeats(true);\n  if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && !e.isAltDown() && m_mouseState == 0 && m_scaling == 0) {\n    if (((e.getModifiers() & InputEvent.CTRL_MASK) != 0) && ((e.getModifiers() & InputEvent.SHIFT_MASK) == 0)) {\n      m_mouseState=2;\n    }\n else     if (((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) && ((e.getModifiers() & InputEvent.CTRL_MASK) == 0)) {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=3;\n      Graphics g=getGraphics();\n      if (m_ZoomBoxColor == null) {\n        g.setColor(Color.black);\n      }\n else {\n        g.setColor(m_ZoomBoxColor);\n      }\n      if (m_ZoomBoxXORColor == null) {\n        g.setXORMode(Color.white);\n      }\n else {\n        g.setXORMode(m_ZoomBoxXORColor);\n      }\n      g.drawRect(m_oldMousePos.width,m_oldMousePos.height,m_newMousePos.width - m_oldMousePos.width,m_newMousePos.height - m_oldMousePos.height);\n      g.dispose();\n    }\n else {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=1;\n      m_frameLimiter.start();\n    }\n  }\n else   if ((e.getButton() == MouseEvent.BUTTON1) && e.isAltDown() && e.isShiftDown()&& !e.isControlDown()) {\n    saveComponent();\n  }\n else   if (m_mouseState == 0 && m_scaling == 0) {\n  }\n}\n", "docstring": "determines what action the user wants to perform .", "partition": "test"}
{"idx": "3481", "code": "public List<ExpectedPartitionValueEntity> createExpectedPartitionValueEntities(String partitionKeyGroupName,List<String> expectedPartitionValues){\n  PartitionKeyGroupEntity partitionKeyGroupEntity=partitionKeyGroupDao.getPartitionKeyGroupByName(partitionKeyGroupName);\n  if (partitionKeyGroupEntity == null) {\n    partitionKeyGroupEntity=partitionKeyGroupDaoTestHelper.createPartitionKeyGroupEntity(partitionKeyGroupName);\n  }\n  List<ExpectedPartitionValueEntity> expectedPartitionValueEntities=new ArrayList<>();\n  for (  String expectedPartitionValue : expectedPartitionValues) {\n    ExpectedPartitionValueEntity expectedPartitionValueEntity=new ExpectedPartitionValueEntity();\n    expectedPartitionValueEntity.setPartitionKeyGroup(partitionKeyGroupEntity);\n    expectedPartitionValueEntity.setPartitionValue(expectedPartitionValue);\n    expectedPartitionValueEntities.add(expectedPartitionValueDao.saveAndRefresh(expectedPartitionValueEntity));\n  }\n  return expectedPartitionValueEntities;\n}\n", "docstring": "creates and persists specified partition value entities . this method also creates and persists a partition key group entity , if it does not exist .", "partition": "test"}
{"idx": "1759", "code": "public final void log(String filename,int lineNumber,String method,String tag,int level,String message){\n  final LogMessage lm=new LogMessage(LogMessage.LOGMSG_TYPE_LOG,nextSequenceNumber.getAndIncrement());\n  lm.addInt16(level,LogMessage.PART_KEY_LEVEL);\n  if (filename != null) {\n    lm.addString(filename,LogMessage.PART_KEY_FILENAME);\n    if (lineNumber != 0)     lm.addInt32(lineNumber,LogMessage.PART_KEY_LINENUMBER);\n  }\n  if (method != null)   lm.addString(method,LogMessage.PART_KEY_FUNCTIONNAME);\n  if (tag != null && !tag.isEmpty())   lm.addString(tag,LogMessage.PART_KEY_TAG);\n  lm.addString(message,LogMessage.PART_KEY_MESSAGE);\n  log(lm);\n}\n", "docstring": "log a message with full information ( if provided )", "partition": "test"}
{"idx": "2247", "code": "public void print(){\n  Object[] iterChargingTimes=chargingTimes.toArray();\n  Arrays.sort(iterChargingTimes);\n  for (int i=0; i < iterChargingTimes.length; i++) {\n    ChargeLog curItem=(ChargeLog)iterChargingTimes[i];\n    curItem.print();\n  }\n}\n", "docstring": "just prints out sorted after the time ( starting with 0 : 00 ) note : this is not the order in which the charging happened .", "partition": "test"}
{"idx": "975", "code": "public LogFormatter(Logger log){\n  if (log == null)   log=Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n  Level lvl=null;\n  while (log != null) {\n    lvl=log.getLevel();\n    if (lvl != null)     break;\n    log=log.getParent();\n  }\n  ;\n  if (lvl == null)   lvl=Level.WARNING;\n  this.level=lvl;\n}\n", "docstring": "create a log formatter around a given logger . if null , uses the global logger .", "partition": "test"}
{"idx": "3411", "code": "public void serialize(String name,byte[] message,OutputStream out) throws IOException {\n  byte[] header=new byte[4 + COMMAND_LEN + 4+ 4];\n  uint32ToByteArrayBE(params.getPacketMagic(),header,0);\n  for (int i=0; i < name.length() && i < COMMAND_LEN; i++) {\n    header[4 + i]=(byte)(name.codePointAt(i) & 0xFF);\n  }\n  Utils.uint32ToByteArrayLE(message.length,header,4 + COMMAND_LEN);\n  byte[] hash=doubleDigest(message);\n  System.arraycopy(hash,0,header,4 + COMMAND_LEN + 4,4);\n  out.write(header);\n  out.write(message);\n  if (log.isDebugEnabled())   log.debug(\"Sending {} message: {}\",name,bytesToHexString(header) + bytesToHexString(message));\n}\n", "docstring": "writes message to to the output stream .", "partition": "test"}
{"idx": "1125", "code": "public static Properties createProperties(final Map<String,String> map){\n  Properties properties=new Properties();\n  if (!(map == null || map.isEmpty())) {\n    for (    Entry<String,String> entry : map.entrySet()) {\n      properties.setProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  return properties;\n}\n", "docstring": "creates an properties object initialized with the value from the given map . < p >", "partition": "test"}
{"idx": "2917", "code": "public void deepSort(int[] setFeatureSequence){\n  featureSequence=setFeatureSequence;\n  numberOfLeaves=0;\n  tree=new MaryNode(0,featureVectors.length);\n  sortNode(0,tree);\n}\n", "docstring": "launches a deep sort on the array of feature vectors . this is public because it can be used to re - index the previously read feature file .", "partition": "test"}
{"idx": "2191", "code": "void addRule(String[] selector,AttributeSet declaration,boolean isLinked){\n  int n=selector.length;\n  StringBuilder sb=new StringBuilder();\n  sb.append(selector[0]);\n  for (int counter=1; counter < n; counter++) {\n    sb.append(' ');\n    sb.append(selector[counter]);\n  }\n  String selectorName=sb.toString();\n  Style rule=getStyle(selectorName);\n  if (rule == null) {\n    Style altRule=addStyle(selectorName,null);\nsynchronized (this) {\n      SelectorMapping mapping=getRootSelectorMapping();\n      for (int i=n - 1; i >= 0; i--) {\n        mapping=mapping.getChildSelectorMapping(selector[i],true);\n      }\n      rule=mapping.getStyle();\n      if (rule == null) {\n        rule=altRule;\n        mapping.setStyle(rule);\n        refreshResolvedRules(selectorName,selector,rule,mapping.getSpecificity());\n      }\n    }\n  }\n  if (isLinked) {\n    rule=getLinkedStyle(rule);\n  }\n  rule.addAttributes(declaration);\n}\n", "docstring": "adds a rule into the stylesheet .", "partition": "test"}
{"idx": "4127", "code": "public void installBuiltinSound(String soundIdentifier,InputStream data) throws IOException {\n  builtinSounds.put(soundIdentifier,convertBuiltinSound(data));\n}\n", "docstring": "installs a replacement sound as the builtin sound responsible for the given sound identifier ( this will override the system sound if such a sound exists ) .", "partition": "test"}
{"idx": "3514", "code": "public static Object toArray(Collection<?> collection,Class<?> componentType){\n  if (componentType.isPrimitive()) {\n    Object array=Array.newInstance(componentType,collection.size());\n    int index=0;\n    for (    Object value : collection) {\n      Array.set(array,index++,value);\n    }\n    return array;\n  }\n  return collection.toArray((Object[])Array.newInstance(componentType,collection.size()));\n}\n", "docstring": "returns a new array of the given component type ( possibly a java primitive ) that is a copy of the content of the given collection .", "partition": "test"}
{"idx": "120", "code": "public Repository(String domain,boolean fairLock){\n  lock=new ReentrantReadWriteLock(fairLock);\n  domainTb=new HashMap<String,Map<String,NamedObject>>(5);\n  if (domain != null && domain.length() != 0)   this.domain=domain.intern();\n else   this.domain=ServiceName.DOMAIN;\n  domainTb.put(this.domain,new HashMap<String,NamedObject>());\n}\n", "docstring": "construct a new repository with the given default domain .", "partition": "test"}
{"idx": "2410", "code": "public void paint(Graphics g){\n  g.translate(0,translateY);\n  super.paint(g);\n}\n", "docstring": "displays our component in the location ( 0 , translatey ) . note that this changes only the rendering location of the button , not the physical location of it . note , also , that rendering into g will be clipped to the physical location of the button , so the button will disappear as it moves away from that location .", "partition": "test"}
{"idx": "2390", "code": "public static boolean isWindows8(){\n  return osName.indexOf(\"Windows\") > -1 && (osVersion.equals(\"6.2\") || osVersion.equals(\"6.3\"));\n}\n", "docstring": "is operating system windows 8 or 8 . 1 ?", "partition": "test"}
{"idx": "2197", "code": "private Map.Entry<K,V> doRemoveFirstEntry(){\n  for (Node<K,V> b, n; ; ) {\n    if ((n=(b=head.node).next) == null)     return null;\n    Node<K,V> f=n.next;\n    if (n != b.next)     continue;\n    Object v=n.value;\n    if (v == null) {\n      n.helpDelete(b,f);\n      continue;\n    }\n    if (!n.casValue(v,null))     continue;\n    if (!n.appendMarker(f) || !b.casNext(n,f))     findFirst();\n    clearIndexToFirst();\n    @SuppressWarnings(\"unchecked\") V vv=(V)v;\n    return new AbstractMap.SimpleImmutableEntry<K,V>(n.key,vv);\n  }\n}\n", "docstring": "removes first entry ; returns its snapshot .", "partition": "test"}
{"idx": "2921", "code": "private double addRecursively(ArrayList<double[]> hull,Hierarchy<Cluster<Model>> hier,Cluster<Model> clus){\n  final DBIDs ids=clus.getIDs();\n  double weight=ids.size();\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    double[] projP=proj.fastProjectDataToRenderSpace(rel.get(iter));\n    if (projP[0] != projP[0] || projP[1] != projP[1]) {\n      continue;\n    }\n    hull.add(projP);\n  }\n  for (Iter<Cluster<Model>> iter=hier.iterChildren(clus); iter.valid(); iter.advance()) {\n    weight+=.5 * addRecursively(hull,hier,iter.get());\n  }\n  return weight;\n}\n", "docstring": "recursively add a cluster and its children .", "partition": "test"}
{"idx": "405", "code": "public void updateFromResource(){\n  for (  String resource : resources) {\n    InputStream is=ClassLoader.getSystemResourceAsStream(resource);\n    LinkedHashMap<EntryType,LinkedHashMap<String,ConfigEntry>> parseResult=parse(is);\n    for (    EntryType type : myMap.keySet()) {\n      LinkedHashMap<String,ConfigEntry> dataMappings=myMap.get(type);\n      LinkedHashMap<String,ConfigEntry> resourceMappings=parseResult.get(type);\n      LinkedHashMap<String,ConfigEntry> tempMappings=new LinkedHashMap<String,ConfigEntry>();\n      LinkedHashSet<String> keys=new LinkedHashSet<String>();\n      keys.addAll(dataMappings.keySet());\n      keys.addAll(resourceMappings.keySet());\n      for (      String key : keys) {\n        if (resourceMappings.containsKey(key)) {\n          tempMappings.put(key,resourceMappings.get(key));\n        }\n else {\n          tempMappings.put(key,dataMappings.get(key));\n        }\n      }\n      myMap.put(type,tempMappings);\n    }\n  }\n}\n", "docstring": "maintains order of all keys , but overwrites all data keys with values from resources .", "partition": "test"}
{"idx": "3382", "code": "private static Type[] unrollBounds(final Map<TypeVariable<?>,Type> typeArguments,final Type[] bounds){\n  Type[] result=bounds;\n  int i=0;\n  for (; i < result.length; i++) {\n    final Type unrolled=unrollVariables(typeArguments,result[i]);\n    if (unrolled == null) {\n      result=ArrayUtils.remove(result,i--);\n    }\n else {\n      result[i]=unrolled;\n    }\n  }\n  return result;\n}\n", "docstring": "local helper method to unroll variables in a type bounds array .", "partition": "test"}
{"idx": "889", "code": "public void collapseBuilding(Building bldg){\n  buildings.removeElement(bldg);\n  Enumeration<Coords> bldgCoords=bldg.getCoords();\n  while (bldgCoords.hasMoreElements()) {\n    final Coords coords=bldgCoords.nextElement();\n    collapseBuilding(coords);\n  }\n}\n", "docstring": "the given building has collapsed . remove it from the board and replace it with rubble .", "partition": "test"}
{"idx": "1028", "code": "private static Properties loadProperties(String propertiesFile){\n  Properties properties=new Properties();\n  try (InputStream is=new FileInputStream(propertiesFile)){\n    properties.load(is);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"failed to load properties\",e);\n  }\n  return properties;\n}\n", "docstring": "loads properties from a properties file on the local filesystem .", "partition": "test"}
{"idx": "92", "code": "public CheckpointManager(NetworkParameters params,@Nullable InputStream inputStream) throws IOException {\n  this.params=checkNotNull(params);\n  if (inputStream == null)   inputStream=openStream(params);\n  checkNotNull(inputStream);\n  inputStream=new BufferedInputStream(inputStream);\n  inputStream.mark(1);\n  int first=inputStream.read();\n  inputStream.reset();\n  if (first == BINARY_MAGIC.charAt(0))   dataHash=readBinary(inputStream);\n else   if (first == TEXTUAL_MAGIC.charAt(0))   dataHash=readTextual(inputStream);\n else   throw new IOException(\"Unsupported format.\");\n}\n", "docstring": "loads the checkpoints from the given stream", "partition": "test"}
{"idx": "450", "code": "public static void printLine(Object message){\n  if (!isDisabled()) {\n    printLine(String.valueOf(message));\n  }\n}\n", "docstring": "prints the message passed as a non - string object and a new line .", "partition": "test"}
{"idx": "1647", "code": "protected void add(CSVRecord record){\n  records.add(Objects.requireNonNull(record));\n}\n", "docstring": "adds the given record to this data .", "partition": "test"}
{"idx": "421", "code": "@VisibleForTesting static boolean isPrecachingEnabled(Context context){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n  return prefs.getBoolean(PREF_IS_PRECACHING_ENABLED,false);\n}\n", "docstring": "returns true if precaching is able to run . set by precachelauncher # updateprecachingenabled .", "partition": "test"}
{"idx": "522", "code": "public Server start() throws SQLException {\n  try {\n    started=true;\n    service.start();\n    String name=service.getName() + \" (\" + service.getURL()+ \")\";\n    Thread t=new Thread(this,name);\n    t.setDaemon(service.isDaemon());\n    t.start();\n    for (int i=1; i < 64; i+=i) {\n      wait(i);\n      if (isRunning(false)) {\n        return this;\n      }\n    }\n    if (isRunning(true)) {\n      return this;\n    }\n    throw DbException.get(ErrorCode.EXCEPTION_OPENING_PORT_2,name,\"timeout; \" + \"please check your network configuration, specially the file /etc/hosts\");\n  }\n catch (  DbException e) {\n    throw DbException.toSQLException(e);\n  }\n}\n", "docstring": "tries to start the server .", "partition": "test"}
{"idx": "2708", "code": "public static void closeEL(InputStream is){\n  try {\n    if (is != null)     is.close();\n  }\n catch (  Throwable t) {\n  }\n}\n", "docstring": "close inputstream without a exception", "partition": "test"}
{"idx": "89", "code": "public static void slideInFromTopAnimator(@NonNull List<Animator> animators,@NonNull View view,RecyclerView recyclerView){\n  alphaAnimator(animators,view,0f);\n  animators.add(ObjectAnimator.ofFloat(view,\"translationY\",-recyclerView.getMeasuredHeight() >> 1,0));\n  if (FlexibleAdapter.DEBUG)   Log.v(TAG,\"Added TOP Animator\");\n}\n", "docstring": "item will slide from top of the screen to its natural position .", "partition": "test"}
{"idx": "2400", "code": "public static GeoTimeSerie detect(GeoTimeSerie gts,int alphabetSize,int wordLen,int windowLen,Collection<String> patterns,boolean standardizePAA) throws WarpScriptException {\n  GeoTimeSerie gtsPatterns=GTSHelper.bSAX(gts,alphabetSize,wordLen,windowLen,standardizePAA);\n  GTSHelper.sort(gtsPatterns);\n  GeoTimeSerie detected=new GeoTimeSerie(gts.lastbucket,gts.bucketcount,gts.bucketspan,16);\n  detected.setMetadata(gts.getMetadata());\n  int lastidx=-1;\n  for (int i=0; i < gtsPatterns.values; i++) {\n    if (!patterns.contains(gtsPatterns.stringValues[i])) {\n      continue;\n    }\n    for (int j=0; j < windowLen; j++) {\n      if (i + j > lastidx) {\n        lastidx=i + j;\n        GTSHelper.setValue(detected,GTSHelper.tickAtIndex(gts,lastidx),GTSHelper.locationAtIndex(gts,lastidx),GTSHelper.elevationAtIndex(gts,lastidx),GTSHelper.valueAtIndex(gts,lastidx),false);\n      }\n    }\n  }\n  return detected;\n}\n", "docstring": "detect patterns in a geo time serie instance . return a modified version of the original gts instance where only the values which are part of one of the provided patterns are kept .", "partition": "test"}
{"idx": "1303", "code": "private boolean goTo(long day,boolean animate,boolean setSelected,boolean forceScroll){\n  if (setSelected) {\n    mSelectedDay.setTimeInMillis(day);\n  }\n  mTempDay.setTimeInMillis(day);\n  final int position=getPositionFromDay(day);\n  View child;\n  int i=0;\n  int top=0;\n  do {\n    child=getChildAt(i++);\n    if (child == null) {\n      break;\n    }\n    top=child.getTop();\n  }\n while (top < 0);\n  int selectedPosition;\n  if (child != null) {\n    selectedPosition=getPositionForView(child);\n  }\n else {\n    selectedPosition=0;\n  }\n  if (setSelected) {\n    mAdapter.setSelectedDay(mSelectedDay);\n  }\n  if (position != selectedPosition || forceScroll) {\n    setMonthDisplayed(mTempDay);\n    mPreviousScrollState=OnScrollListener.SCROLL_STATE_FLING;\n    if (animate) {\n      smoothScrollToPositionFromTop(position,LIST_TOP_OFFSET,GOTO_SCROLL_DURATION);\n      return true;\n    }\n else {\n      postSetSelection(position);\n    }\n  }\n else   if (setSelected) {\n    setMonthDisplayed(mSelectedDay);\n  }\n  return false;\n}\n", "docstring": "this moves to the specified time in the view . if the time is not already in range it will move the list so that the first of the month containing the time is at the top of the view . if the new time is already in view the list will not be scrolled unless forcescroll is true . this time may optionally be highlighted as selected as well .", "partition": "test"}
{"idx": "2508", "code": "public Interceptor[] buildRouteInterceptors(Interceptor[] defaultInters,Interceptor[] resourceInters,Class<? extends Resource> resourceClass,Interceptor[] methodInters,Method method){\n  List<Interceptor> allInters=new ArrayList<Interceptor>();\n  for (  Interceptor defaultInter : defaultInters) {\n    allInters.add(defaultInter);\n  }\n  for (  Interceptor resourceInter : resourceInters) {\n    allInters.add(resourceInter);\n  }\n  for (  Interceptor methodInter : methodInters) {\n    allInters.add(methodInter);\n  }\n  Class<? extends Interceptor>[] resourceClears=getResourceClears(resourceClass);\n  Class<? extends Interceptor>[] methodClears=getMethodClears(method);\n  if ((resourceClears != null && resourceClears.length > 0) || (methodClears != null && methodClears.length > 0)) {\n    for (int i=0; i < allInters.size(); i++) {\n      i=clearInterceptor(allInters,resourceClears,i);\n      i=clearInterceptor(allInters,methodClears,i);\n    }\n  }\n  return allInters.toArray(new Interceptor[allInters.size()]);\n}\n", "docstring": "build interceptors of action", "partition": "test"}
{"idx": "3031", "code": "private boolean isSelfSigned(X509Certificate cert){\n  return signedBy(cert,cert);\n}\n", "docstring": "returns true if the certificate is self - signed , false otherwise .", "partition": "test"}
{"idx": "214", "code": "public void revert(final VirtualFile root,final List<FilePath> files) throws VcsException {\n  for (  List<String> paths : VcsFileUtil.chunkPaths(root,files)) {\n    GitSimpleHandler handler=new GitSimpleHandler(myProject,root,GitCommand.CHECKOUT);\n    handler.addParameters(\"HEAD\");\n    handler.endOptions();\n    handler.addParameters(paths);\n    handler.run();\n  }\n}\n", "docstring": "reverts the list of files we are passed .", "partition": "test"}
{"idx": "2701", "code": "public void layout(Container container){\n  Map<Location,Drawable> comps=getComponentsByLocation(container);\n  Drawable north=comps.get(Location.NORTH);\n  Drawable northEast=comps.get(Location.NORTH_EAST);\n  Drawable east=comps.get(Location.EAST);\n  Drawable southEast=comps.get(Location.SOUTH_EAST);\n  Drawable south=comps.get(Location.SOUTH);\n  Drawable southWest=comps.get(Location.SOUTH_WEST);\n  Drawable west=comps.get(Location.WEST);\n  Drawable northWest=comps.get(Location.NORTH_WEST);\n  Drawable center=comps.get(Location.CENTER);\n  double widthWest=getMaxWidth(northWest,west,southWest);\n  double widthEast=getMaxWidth(northEast,east,southEast);\n  double heightNorth=getMaxHeight(northWest,north,northEast);\n  double heightSouth=getMaxHeight(southWest,south,southEast);\n  double gapEast=(widthEast > 0.0) ? getGapX() : 0.0;\n  double gapWest=(widthWest > 0.0) ? getGapX() : 0.0;\n  double gapNorth=(heightNorth > 0.0) ? getGapY() : 0.0;\n  double gapSouth=(heightSouth > 0.0) ? getGapY() : 0.0;\n  Rectangle2D bounds=container.getBounds();\n  Insets2D insets=container.getInsets();\n  if (insets == null) {\n    insets=new Insets2D.Double();\n  }\n  double xWest=bounds.getMinX() + insets.getLeft() - gapWest - widthWest;\n  double xCenter=bounds.getMinX() + insets.getLeft();\n  double xEast=bounds.getMaxX() - insets.getRight() + gapEast;\n  double yNorth=bounds.getMinY() + insets.getTop() - gapNorth - heightNorth;\n  double yCenter=bounds.getMinY() + insets.getTop();\n  double ySouth=bounds.getMaxY() - insets.getBottom() + gapSouth;\n  layoutComponent(northWest,xWest,yNorth,widthWest,heightNorth);\n  layoutComponent(north,xCenter,yNorth,bounds.getWidth() - insets.getHorizontal(),heightNorth);\n  layoutComponent(northEast,xEast,yNorth,widthEast,heightNorth);\n  layoutComponent(east,xEast,yCenter,widthEast,bounds.getHeight() - insets.getVertical());\n  layoutComponent(southEast,xEast,ySouth,widthEast,heightSouth);\n  layoutComponent(south,xCenter,ySouth,bounds.getWidth() - insets.getHorizontal(),heightSouth);\n  layoutComponent(southWest,xWest,ySouth,widthWest,heightSouth);\n  layoutComponent(west,xWest,yCenter,widthWest,bounds.getHeight() - insets.getVertical());\n  layoutComponent(center,xCenter + getGapX(),yCenter + getGapY(),bounds.getWidth() - insets.getHorizontal() - 2 * getGapX(),bounds.getHeight() - insets.getVertical() - 2 * getGapY());\n}\n", "docstring": "arranges the components of the specified container according to this layout .", "partition": "test"}
{"idx": "3738", "code": "@SuppressWarnings(\"unused\") public boolean onTouchEvent(MotionEvent event){\n  try {\n    int pointerCount=multiTouchSupported ? (Integer)m_getPointerCount.invoke(event) : 1;\n    if (DEBUG)     Log.i(\"MultiTouch\",\"Got here 1 - \" + multiTouchSupported + \" \"+ mMode+ \" \"+ handleSingleTouchEvents+ \" \"+ pointerCount);\n    if (mMode == MODE_NOTHING && !handleSingleTouchEvents && pointerCount == 1)     return false;\n    if (DEBUG)     Log.i(\"MultiTouch\",\"Got here 2\");\n    int action=event.getAction();\n    int histLen=event.getHistorySize() / pointerCount;\n    for (int histIdx=0; histIdx <= histLen; histIdx++) {\n      boolean processingHist=histIdx < histLen;\n      if (!multiTouchSupported || pointerCount == 1) {\n        if (DEBUG)         Log.i(\"MultiTouch\",\"Got here 3\");\n        xVals[0]=processingHist ? event.getHistoricalX(histIdx) : event.getX();\n        yVals[0]=processingHist ? event.getHistoricalY(histIdx) : event.getY();\n        pressureVals[0]=processingHist ? event.getHistoricalPressure(histIdx) : event.getPressure();\n      }\n else {\n        if (DEBUG)         Log.i(\"MultiTouch\",\"Got here 4\");\n        int numPointers=Math.min(pointerCount,MAX_TOUCH_POINTS);\n        if (DEBUG && pointerCount > MAX_TOUCH_POINTS)         Log.i(\"MultiTouch\",\"Got more pointers than MAX_TOUCH_POINTS\");\n        for (int ptrIdx=0; ptrIdx < numPointers; ptrIdx++) {\n          int ptrId=(Integer)m_getPointerId.invoke(event,ptrIdx);\n          pointerIds[ptrIdx]=ptrId;\n          xVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalX.invoke(event,ptrIdx,histIdx) : m_getX.invoke(event,ptrIdx));\n          yVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalY.invoke(event,ptrIdx,histIdx) : m_getY.invoke(event,ptrIdx));\n          pressureVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalPressure.invoke(event,ptrIdx,histIdx) : m_getPressure.invoke(event,ptrIdx));\n        }\n      }\n      decodeTouchEvent(pointerCount,xVals,yVals,pressureVals,pointerIds,processingHist ? MotionEvent.ACTION_MOVE : action,processingHist ? true : action != MotionEvent.ACTION_UP && (action & ((1 << ACTION_POINTER_INDEX_SHIFT) - 1)) != ACTION_POINTER_UP && action != MotionEvent.ACTION_CANCEL,processingHist ? event.getHistoricalEventTime(histIdx) : event.getEventTime());\n    }\n    return true;\n  }\n catch (  Exception e) {\n    Log.e(\"MultiTouchController\",\"onTouchEvent() failed\",e);\n    return false;\n  }\n}\n", "docstring": "process incoming touch events", "partition": "test"}
{"idx": "392", "code": "protected void performDefaults(){\n  super.performDefaults();\n  initializeValues();\n  verifyValidation();\n}\n", "docstring": "defaults was clicked . restore the svn preferences to their default values", "partition": "test"}
{"idx": "1948", "code": "public void addComponent(T component){\n  components.add(component);\n}\n", "docstring": "adds a component to the composite .", "partition": "test"}
{"idx": "492", "code": "public boolean canInvoke(MDepreciationWorkfile assetwk,MAssetAcct assetAcct,int A_Current_Period,BigDecimal Accum_Dep){\n  if (assetwk == null) {\n    log.warning(\"@NotFound@ @A_Depreciation_Workfile_ID@\");\n    return false;\n  }\n  int offset=0;\n  int lifePeriods=assetwk.getUseLifeMonths(assetwk.isFiscal());\n  boolean ok=(offset <= A_Current_Period);\n  if (CLogMgt.isLevelFinest())   log.finest(\"A_Current_Period=\" + A_Current_Period + \", lifePeriods=\"+ lifePeriods+ \" (offset=\"+ offset+ \") ==> OK=\"+ ok);\n  return ok;\n}\n", "docstring": "check if the method can be invoked to give parameters", "partition": "test"}
{"idx": "3748", "code": "public static int hash(Object o){\n  int h=o == null ? 0 : o instanceof byte[] ? Arrays.hashCode((byte[])o) : o.hashCode();\n  h+=(h << 15) ^ 0xffffcd7d;\n  h^=(h >>> 10);\n  h+=(h << 3);\n  h^=(h >>> 6);\n  h+=(h << 2) + (h << 14);\n  return h ^ (h >>> 16);\n}\n", "docstring": "gets hash code for a given object .", "partition": "test"}
{"idx": "3905", "code": "public static <E>List<E> of(E e1,E e2,E e3){\n  List<E> list=new ArrayList<>();\n  list.add(e1);\n  list.add(e2);\n  list.add(e3);\n  return list;\n}\n", "docstring": "returns a list of the given elements , in order .", "partition": "test"}
{"idx": "2667", "code": "@Override protected void failed(){\n  relation.setCanceled(true);\n  super.failed();\n}\n", "docstring": "marks the relation as canceled and invokes the the handler \"'\" s failed ( ) method .", "partition": "test"}
{"idx": "681", "code": "public boolean isInvalidNode(){\n  ASTNode first=fNodes.get(0);\n  ASTNode candidate=first.getParent();\n  if (candidate == null)   return false;\n  if (candidate.getNodeType() == ASTNode.METHOD_DECLARATION)   return true;\n  return false;\n}\n", "docstring": "tests whether the node to be replaced is invalid .", "partition": "test"}
{"idx": "2665", "code": "public void refreshInheritedMethods(Set modifiedSuperExpandos){\n  for (Iterator i=modifiedSuperExpandos.iterator(); i.hasNext(); ) {\n    ExpandoMetaClass superExpando=(ExpandoMetaClass)i.next();\n    if (superExpando != this) {\n      refreshInheritedMethods(superExpando);\n    }\n  }\n}\n", "docstring": "called from expandometaclasscreationhandle in the registry if it exists to set up inheritance handling", "partition": "test"}
{"idx": "1454", "code": "private static String[] collationMatchingRuleNames(final List<String> localeNames,final int numSuffix,final String symbolicSuffix){\n  final List<String> names=new ArrayList<>();\n  for (  String localeName : localeNames) {\n    if (symbolicSuffix.isEmpty()) {\n      names.add(localeName);\n    }\n else {\n      names.add(localeName + \".\" + numSuffix);\n      names.add(localeName + \".\" + symbolicSuffix);\n    }\n  }\n  return names.toArray(new String[names.size()]);\n}\n", "docstring": "build the complete list of names for a collation matching rule .", "partition": "test"}
{"idx": "2294", "code": "public void addTransaction(SIPServerTransaction serverTransaction) throws IOException {\n  if (isLoggingEnabled())   stackLogger.logDebug(\"added transaction \" + serverTransaction);\n  serverTransaction.map();\n  addTransactionHash(serverTransaction);\n}\n", "docstring": "add a new server transaction to the set of existing transactions . add it to the top of the list so an incoming ack has less work to do in order to find the transaction .", "partition": "test"}
{"idx": "2162", "code": "private static String generateJWT(String secret,String jwtID,String iss,Integer ttl,Map<String,String> claims) throws HmacException {\n  try {\n    return signJWT(secret,jwtID,ttl,iss,claims);\n  }\n catch (  JOSEException e) {\n    e.printStackTrace();\n    throw new HmacException(\"Cannot generate JWT\",e);\n  }\n}\n", "docstring": "generate a new signed jwt", "partition": "test"}
{"idx": "1612", "code": "public static List<Node> parseExpression(Context context,HashSet<String> configNamespaces,String text){\n  return parseExpression(context,configNamespaces,text,0,false);\n}\n", "docstring": "this method should be used to parse an expression , like \" a = b \" . it differs from the parse ( ) methods in it \"'\" s handling of expressions like \" [ a , b ", "partition": "test"}
{"idx": "1220", "code": "public static void changeFont(JComponent comp,int style){\n  Font font=comp.getFont();\n  comp.setFont(font.deriveFont(style));\n}\n", "docstring": "change the font style of a component", "partition": "test"}
{"idx": "2066", "code": "public void createAccrualBasedJournalEntriesAndReversalsForLoanCharges(final Office office,final String currencyCode,final Integer accountTypeToBeDebited,final Integer accountTypeToBeCredited,final Long loanProductId,final Long loanId,final String transactionId,final Date transactionDate,final BigDecimal totalAmount,final Boolean isReversal,final List<ChargePaymentDTO> chargePaymentDTOs){\n  GLAccount receivableAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeDebited,null);\n  final Map<GLAccount,BigDecimal> creditDetailsMap=new LinkedHashMap<>();\n  for (  final ChargePaymentDTO chargePaymentDTO : chargePaymentDTOs) {\n    final Long chargeId=chargePaymentDTO.getChargeId();\n    final GLAccount chargeSpecificAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeCredited,chargeId);\n    BigDecimal chargeSpecificAmount=chargePaymentDTO.getAmount();\n    if (creditDetailsMap.containsKey(chargeSpecificAccount)) {\n      final BigDecimal existingAmount=creditDetailsMap.get(chargeSpecificAccount);\n      chargeSpecificAmount=chargeSpecificAmount.add(existingAmount);\n    }\n    creditDetailsMap.put(chargeSpecificAccount,chargeSpecificAmount);\n  }\n  BigDecimal totalCreditedAmount=BigDecimal.ZERO;\n  for (  final Map.Entry<GLAccount,BigDecimal> entry : creditDetailsMap.entrySet()) {\n    final GLAccount account=entry.getKey();\n    final BigDecimal amount=entry.getValue();\n    totalCreditedAmount=totalCreditedAmount.add(amount);\n    if (isReversal) {\n      createDebitJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n    }\n else {\n      createDebitJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n    }\n  }\n  if (totalAmount.compareTo(totalCreditedAmount) != 0) {\n    throw new PlatformDataIntegrityException(\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",totalCreditedAmount,totalAmount);\n  }\n}\n", "docstring": "convenience method that creates a pair of related debits and credits for accrual based accounting . the target accounts for debits and credits are switched in case of a reversal", "partition": "test"}
{"idx": "239", "code": "private static String forceNumberStringToTwoDigits(String text){\n  while (text.length() < 2) {\n    text=\"0\" + text;\n  }\n  if (text.length() > 2) {\n    text=text.substring(text.length() - 2,text.length());\n  }\n  return text;\n}\n", "docstring": "forcenumberstringtotwodigits , this takes a string of digits , and forces it to be two digits long . first any extra leftmost digits are truncated , leaving only the right one digit or right two digits . if there is only one digit , it is zero padded to enforce a two digit string result . this function is used by the datepickerutilities . doesparseddatematchtext ( ) function .", "partition": "test"}
{"idx": "674", "code": "public IVector(int c){\n  vector=new int[Math.max(defaultCapacity,c)];\n}\n", "docstring": "constructs a new vector with the specified capacity .", "partition": "test"}
{"idx": "1923", "code": "@CallerSensitive public Class<?> forClass(){\n  if (cl == null) {\n    return null;\n  }\n  requireInitialized();\n  if (System.getSecurityManager() != null) {\n    Class<?> caller=Reflection.getCallerClass();\n    if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),cl.getClassLoader())) {\n      ReflectUtil.checkPackageAccess(cl);\n    }\n  }\n  return cl;\n}\n", "docstring": "return the class in the local vm that this version is mapped to . null is returned if there is no corresponding local class .", "partition": "test"}
{"idx": "704", "code": "private void checkStart(){\n  if (mCanProcessAudio && !mOutput.isRunning() && mOutput.available() <= mBufferStartThreshold) {\n    mOutput.start();\n  }\n}\n", "docstring": "starts audio playback once audio buffer is almost full and remaining capacity falls below the start threshold .", "partition": "test"}
{"idx": "3251", "code": "private boolean isAccessibleUserToKibana(Set<String> filters){\n  if (filters.contains(\"/.kibana\")) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "check if an user has auth to kibana", "partition": "test"}
{"idx": "1017", "code": "protected static Vector convertToVector(final Object[] anArray){\n  if (anArray == null) {\n    return null;\n  }\n  final Vector v=new Vector(anArray.length);\n  for (  final Object element : anArray) {\n    v.addElement(element);\n  }\n  return v;\n}\n", "docstring": "returns a vector that contains the same objects as the array .", "partition": "test"}
{"idx": "825", "code": "public boolean incrementReceived(){\n  Long diff=System.currentTimeMillis() - startTime;\n  if (diff >= 1000) {\n    packetsPerSecond=intervalPackets;\n    startTime=System.currentTimeMillis();\n    intervalPackets=1;\n    return true;\n  }\n else {\n    intervalPackets++;\n  }\n  this.receivedPackets++;\n  return false;\n}\n", "docstring": "used for incrementing the number of packets received from the client", "partition": "test"}
{"idx": "2033", "code": "private static String toString(double coeff){\n  final String c=Double.toString(coeff);\n  if (c.endsWith(\".0\")) {\n    return c.substring(0,c.length() - 2);\n  }\n else {\n    return c;\n  }\n}\n", "docstring": "creates a string representing a coefficient , removing \" . 0 \" endings .", "partition": "test"}
{"idx": "2664", "code": "public ExternalProcessResult awaitTerminationAndResult(int timeoutMs,boolean destroyOnError) throws InterruptedException, TimeoutException, OperationCancellation, IOException {\n  awaitTermination(timeoutMs,destroyOnError);\n  return new ExternalProcessResult(process.exitValue(),getStdOutBytes(),getStdErrBytes());\n}\n", "docstring": "awaits for successful process termination , as well as successful termination of reader threads , throws an exception otherwise ( and destroys the process ) .", "partition": "test"}
{"idx": "1469", "code": "public static List<SpaceTime> divideConquerBrownianBridge(MultivariateNormalDistribution normal,SpaceTime start,SpaceTime end,int depth,int maxTries,SpaceTimeRejector rejector){\n  List<SpaceTime> points=new LinkedList<SpaceTime>();\n  points.add(start);\n  points.add(end);\n  stop=false;\n  if (divideConquerBrownianBridge(normal,0,points,depth,maxTries,rejector) == (2 << (depth - 1))) {\n    return points;\n  }\n  stop=false;\n  return null;\n}\n", "docstring": "divide and conquer brownian bridge ; not thread - safe ! ! ! ! !", "partition": "test"}
{"idx": "131", "code": "Rules(Workspace workspace){\n  this.root=workspace.getRoot();\n  this.teamHook=workspace.getTeamHook();\n}\n", "docstring": "creates a new scheduling rule factory for the given workspace", "partition": "test"}
{"idx": "2524", "code": "public static long[] interpose(long[] vector,int vectorLen,int offset,int len){\n  long[] updated=create(vectorLen + len);\n  int idx=offset >> 6;\n  System.arraycopy(vector,0,updated,0,idx);\n  if (idx < vector.length) {\n    int delta=offset & 63;\n    updated[idx]|=vector[idx] & maskBelow(delta);\n  }\n  copy(vector,offset,updated,offset + len,vectorLen - offset);\n  return updated;\n}\n", "docstring": "returns a copy of the vector , with an empty bit range inserted at the specified location .", "partition": "test"}
{"idx": "3015", "code": "private int countNonNewline(String str,int off,int len){\n  for (int cnt=0; cnt < len; cnt++) {\n    final int pos=off + cnt;\n    if (str.charAt(pos) == UNIX_NEWLINE) {\n      return cnt;\n    }\n    if (str.charAt(pos) == CARRIAGE_RETURN) {\n      return cnt;\n    }\n  }\n  return len;\n}\n", "docstring": "count the number of non - newline characters before first newline in the string .", "partition": "test"}
{"idx": "2891", "code": "protected void drawText(String text1,String text2,int x,int y,Canvas c){\n  if (textPaint == null) {\n    Paint p=new Paint();\n    p.setTypeface(RobotoLightTypeface.getInstance(context));\n    p.setColor(textColor);\n    p.setTextSize(14 * pixelDensity);\n    this.textPaint=p;\n  }\n  float w=textPaint.measureText(text1,0,text1.length());\n  int offset=(int)w / 2;\n  c.drawText(text1,x - offset,y + (18f * pixelDensity),textPaint);\n  w=textPaint.measureText(text2,0,text2.length());\n  offset=(int)w / 2;\n  c.drawText(text2,x - offset,y + (36f * pixelDensity),textPaint);\n}\n", "docstring": "draw the text under the graphics", "partition": "test"}
{"idx": "2188", "code": "public static List<String> unescape(String source,char escapeChar,char[] specialCharacters,char splitCharacter,int splitLimit){\n  List<String> result=new LinkedList<>();\n  StringBuilder b=new StringBuilder();\n  boolean readEscape=false;\n  int indexCount=-1;\n  for (  char c : source.toCharArray()) {\n    indexCount++;\n    if (readEscape) {\n      boolean found=false;\n      if (c == splitCharacter) {\n        found=true;\n        b.append(c);\n      }\n else       if (c == escapeChar) {\n        found=true;\n        b.append(c);\n      }\n else {\n        for (        char s : specialCharacters) {\n          if (s == c) {\n            found=true;\n            b.append(c);\n            break;\n          }\n        }\n      }\n      if (!found) {\n        throw new IllegalArgumentException(\"String \\'\" + source + \"\\' contains illegal escaped character \\'\"+ c+ \"\\'.\");\n      }\n      readEscape=false;\n    }\n else     if (c == escapeChar) {\n      readEscape=true;\n    }\n else     if (c == splitCharacter) {\n      readEscape=false;\n      result.add(b.toString());\n      if (splitLimit != -1) {\n        if (result.size() == splitLimit - 1) {\n          result.add(source.substring(indexCount + 1));\n          return result;\n        }\n      }\n      b=new StringBuilder();\n    }\n else {\n      readEscape=false;\n      b.append(c);\n    }\n  }\n  result.add(b.toString());\n  return result;\n}\n", "docstring": "splits the string at every split character unless escaped . if the split limit is not - 1 , at most so many tokens will be returned . no more escaping is performed in the last token !", "partition": "test"}
{"idx": "3184", "code": "private Optional<CuratorFramework> createClient(String zookeeperUrl){\n  if (StringUtils.isNotBlank(zookeeperUrl)) {\n    CuratorFramework client=ConfigurationsUtils.getClient(zookeeperUrl);\n    client.start();\n    return Optional.of(client);\n  }\n else {\n    return Optional.empty();\n  }\n}\n", "docstring": "creates a zookeeper client .", "partition": "test"}
{"idx": "1833", "code": "static void normalize(StringBuilder number){\n  String normalizedNumber=normalize(number.toString());\n  number.replace(0,number.length(),normalizedNumber);\n}\n", "docstring": "normalizes a string of characters representing a phone number . this is a wrapper for normalize ( string number ) but does in - place normalization of the stringbuilder provided .", "partition": "test"}
{"idx": "3956", "code": "String generateKey() throws OracleException {\n  byte[] data=null;\n  try {\n    data=HashFuncs.getRandom();\n  }\n catch (  Exception e) {\n    if (OracleLog.isLoggingEnabled())     log.warning(e.toString());\n  }\n  if (data == null) {\n    data=fetchGuid();\n  }\n  if (data == null) {\n    throw SODAUtils.makeException(SODAMessage.EX_UNABLE_TO_CREATE_UUID);\n  }\n  return (ByteArray.rawToHex(data));\n}\n", "docstring": "generate a uuid key string", "partition": "test"}
{"idx": "3111", "code": "public static String cutFromIndexOf(String string,String substring){\n  int i=string.indexOf(substring);\n  if (i != -1) {\n    string=string.substring(i);\n  }\n  return string;\n}\n", "docstring": "cuts the string from the first index of provided substring to the end .", "partition": "test"}
{"idx": "1749", "code": "public Exchange(final Request request,final Origin origin){\n  this.currentRequest=request;\n  this.origin=origin;\n  this.timestamp=System.currentTimeMillis();\n}\n", "docstring": "creates a new exchange with the specified request and origin .", "partition": "test"}
{"idx": "4111", "code": "public static String grabClass(String signature){\n  Matcher matcher=sigRE.matcher(signature);\n  boolean b=matcher.matches();\n  if (!b && matcher.groupCount() != 4)   logger.error(\"Bad method signature: {}\",signature);\n  return matcher.group(1);\n}\n", "docstring": "grab the class from the signature", "partition": "test"}
{"idx": "3909", "code": "@Override public void zoomDomainAxes(double factor,PlotRenderingInfo state,Point2D source){\n}\n", "docstring": "multiplies the range on the domain axis / axes by the specified factor .", "partition": "test"}
{"idx": "695", "code": "public void testFailedStage(){\n  CFException ex=new CFException();\n  CompletionStage<Integer> f=CompletableFuture.failedStage(ex);\n  AtomicInteger x=new AtomicInteger(0);\n  AtomicReference<Throwable> r=new AtomicReference<Throwable>();\n  f.whenComplete(null);\n  assertEquals(x.get(),0);\n  assertEquals(r.get(),ex);\n}\n", "docstring": "failedstage returns a completionstage completed exceptionally with the given exception", "partition": "test"}
{"idx": "1777", "code": "public byte[] extractData(byte[] stegoData,String stegoFileName,byte[] origSigData) throws OpenStegoException {\n  return null;\n}\n", "docstring": "method to extract the message from the stego data", "partition": "test"}
{"idx": "3056", "code": "private V doGet(Object key){\n  if (key == null)   throw new NullPointerException();\n  Comparator<? super K> cmp=comparator;\n  outer:   for (; ; ) {\n    for (Node<K,V> b=findPredecessor(key,cmp), n=b.next; ; ) {\n      Object v;\n      int c;\n      if (n == null)       break outer;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      if ((v=n.value) == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (b.value == null || v == n)       break;\n      if ((c=cpr(cmp,key,n.key)) == 0) {\n        @SuppressWarnings(\"unchecked\") V vv=(V)v;\n        return vv;\n      }\n      if (c < 0)       break outer;\n      b=n;\n      n=f;\n    }\n  }\n  return null;\n}\n", "docstring": "gets value for key . almost the same as findnode , but returns the found value ( to avoid retries during re - reads )", "partition": "test"}
{"idx": "4232", "code": "public Layer childAt(int index){\n  return children.get(index);\n}\n", "docstring": "returns the layer at the specified index . layers are ordered in terms of their depth and will be returned in this order , with 0 being the layer on bottom .", "partition": "test"}
{"idx": "1981", "code": "private void ensureCapacity(int additionalData){\n  if ((this.position + additionalData) > this.byteBuffer.length) {\n    int newLength=(int)(this.byteBuffer.length * 1.25);\n    if (newLength < (this.byteBuffer.length + additionalData)) {\n      newLength=this.byteBuffer.length + (int)(additionalData * 1.25);\n    }\n    if (newLength < this.byteBuffer.length) {\n      newLength=this.byteBuffer.length + additionalData;\n    }\n    byte[] newBytes=new byte[newLength];\n    System.arraycopy(this.byteBuffer,0,newBytes,0,this.byteBuffer.length);\n    this.byteBuffer=newBytes;\n  }\n}\n", "docstring": "ensure that there are additionaldata bytes available in the buffer . if not realocate the buffer .", "partition": "test"}
{"idx": "2130", "code": "public int countIn(CharSequence sequence){\n  int count=0;\n  for (int i=0; i < sequence.length(); i++) {\n    if (matches(sequence.charAt(i))) {\n      count++;\n    }\n  }\n  return count;\n}\n", "docstring": "returns the number of matching characters found in a character sequence .", "partition": "test"}
{"idx": "3190", "code": "public void testCreationUnique(){\n  Instances data;\n  ArrayList<Attribute> atts;\n  String relName;\n  relName=\"testCreationUnique\";\n  atts=new ArrayList<Attribute>();\n  atts.add(new Attribute(\"att-numeric_1\"));\n  atts.add(new Attribute(\"att-numeric_2\"));\n  atts.add(new Attribute(\"att-data_1\",\"yyyy-MM-dd HH:mm\"));\n  atts.add(new Attribute(\"att-nominal_1\",new ArrayList<String>(Arrays.asList(new String[]{\"1\",\"2\",\"3\"}))));\n  atts.add(new Attribute(\"att-nominal_2\",new ArrayList<String>(Arrays.asList(new String[]{\"yes\",\"no\"}))));\n  atts.add(new Attribute(\"att-string_1\",(ArrayList<String>)null));\n  data=new Instances(relName,atts,0);\n  assertEquals(\"relation name differs\",relName,data.relationName());\n  assertEquals(\"# of attributes differ\",atts.size(),data.numAttributes());\n}\n", "docstring": "tests the creation of a dataset ( unique attribute names ) .", "partition": "test"}
{"idx": "1543", "code": "public static String dropWhile(GString self,@ClosureParams(value=FromString.class,conflictResolutionStrategy=PickFirstResolver.class,options={\"String\",\"Character\"}) Closure condition){\n  return dropWhile(self.toString(),condition);\n}\n", "docstring": "a gstring variant of the equivalent charsequence method .", "partition": "test"}
{"idx": "2547", "code": "public static String toString(long l){\n  if (l < NUMBERS_MIN || l > NUMBERS_MAX) {\n    return Long.toString(l,10);\n  }\n  return NUMBERS[(int)l];\n}\n", "docstring": "cast a long value to a string", "partition": "test"}
{"idx": "1814", "code": "public static CLPlatform[] listGPUPoweredPlatforms(){\n  CLPlatform[] platforms=listPlatforms();\n  List<CLPlatform> out=new ArrayList<CLPlatform>(platforms.length);\n  for (  CLPlatform platform : platforms) {\n    if (platform.listGPUDevices(true).length > 0)     out.add(platform);\n  }\n  return out.toArray(new CLPlatform[out.size()]);\n}\n", "docstring": "list the opencl implementations that contain at least one gpu device .", "partition": "test"}
{"idx": "2007", "code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeObject(approximation);\n}\n", "docstring": "calls the super method and writes the polynomial approximation of the knn distances of this entry to the specified stream .", "partition": "test"}
{"idx": "2466", "code": "private static void configureHeadLessSimulation(){\n  System.setProperty(\"java.awt.headless\",\"true\");\n  GAMA.setHeadLessMode();\n}\n", "docstring": "load in headless mode a specified model and create an experiment", "partition": "test"}
{"idx": "2647", "code": "public int parseInt(String localeFormattedInteger){\n  return Integer.parseInt(localeFormattedInteger);\n}\n", "docstring": "parses an integer based on locale conventions", "partition": "test"}
{"idx": "1428", "code": "public static Entry addObjectClass(Entry entry){\n  Attribute attribute=entry.getAttribute(CoreTokenConstants.OBJECT_CLASS);\n  if (attribute == null) {\n    entry.addAttribute(CoreTokenConstants.OBJECT_CLASS,CoreTokenConstants.FR_CORE_TOKEN);\n  }\n  return entry;\n}\n", "docstring": "only adds the objectclass if it hasn \"'\" t already been added .", "partition": "test"}
{"idx": "3546", "code": "public void addDocumentType(DocumentType documentType){\n  mDocumentTypes.add(documentType);\n}\n", "docstring": "add a document type to the document type list .", "partition": "test"}
{"idx": "549", "code": "public void addProcessInteractionListener(final ProcessInteractionListener l){\n  if (l == null) {\n    throw new IllegalArgumentException(\"l must not be null!\");\n  }\n  processInteractionListeners.add(l);\n}\n", "docstring": "adds a listener that will be informed when the user right - clicks an operator or a port .", "partition": "test"}
{"idx": "4161", "code": "@SuppressWarnings(\"unchecked\") public static <K>ImmutableArray<K> empty(){\n  return (ImmutableArray<K>)EMPTY;\n}\n", "docstring": "get an empty immutable array .", "partition": "test"}
{"idx": "2588", "code": "HttpStreamWrapper(HttpStream stream) throws IOException {\n  _stream=stream;\n}\n", "docstring": "create a new http stream .", "partition": "test"}
{"idx": "3052", "code": "@SuppressWarnings(\"unchecked\") public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory){\n  if (configurableListableBeanFactory.containsBean(sessionFactoryBeanName)) {\n    BeanDefinition sessionFactoryBeanDefinition=configurableListableBeanFactory.getBeanDefinition(sessionFactoryBeanName);\n    MutablePropertyValues propertyValues=sessionFactoryBeanDefinition.getPropertyValues();\n    if (mappingResources != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"mappingResources\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"mappingResources\",new ArrayList());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      List existingMappingResources=(List)propertyValue.getValue();\n      existingMappingResources.addAll(mappingResources);\n    }\n    if (annotatedClasses != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"annotatedClasses\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"annotatedClasses\",new ArrayList());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      List existingMappingResources=(List)propertyValue.getValue();\n      existingMappingResources.addAll(annotatedClasses);\n    }\n    if (configLocations != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"configLocations\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"configLocations\",new ArrayList());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      List existingConfigLocations=(List)propertyValue.getValue();\n      existingConfigLocations.addAll(configLocations);\n    }\n    if (hibernateProperties != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"hibernateProperties\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"hibernateProperties\",new Properties());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      Properties existingHibernateProperties=(Properties)propertyValue.getValue();\n      existingHibernateProperties.putAll(hibernateProperties);\n    }\n  }\n else {\n    throw new NoSuchBeanDefinitionException(\"No bean named [\" + sessionFactoryBeanName + \"] exists within the bean factory. \"+ \"Cannot post process session factory to add Hibernate resource definitions.\");\n  }\n}\n", "docstring": "adds the annotated classes and the mapping resources to the existing session factory configuration .", "partition": "test"}
{"idx": "3008", "code": "protected List<IEditProposal> collectEditProposals(){\n  List<IEditProposal> proposals=new ArrayList<IEditProposal>();\n  View selectedView=getSelectedView();\n  if (selectedView != null) {\n    if (proposalProviders != null) {\n      for (      IEditProposalProvider provider : proposalProviders) {\n        for (        IEditProposal editProposal : provider.getProposals(selectedView)) {\n          if (editProposal.isApplicable())           proposals.add(editProposal);\n        }\n      }\n    }\n  }\n  return proposals;\n}\n", "docstring": "collects all edit proposals from contained poroposal providers .", "partition": "test"}
{"idx": "2192", "code": "public Builder appendReadData(byte[] data){\n  Assertions.checkState(data != null && data.length > 0);\n  segments.add(new Segment(data,null));\n  return this;\n}\n", "docstring": "appends to the underlying data .", "partition": "test"}
{"idx": "762", "code": "public boolean isProcessed(Trace trace,Node node,Direction direction){\n  boolean ret=false;\n  if (processor.getNodeType() == node.getType() && processor.getDirection() == direction) {\n    if (uriFilter == null || uriFilter.test(node.getUri())) {\n      ret=true;\n    }\n  }\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(\"ProcessManager/Processor: isProcessed trace=\" + trace + \" node=\"+ node+ \" direction=\"+ direction+ \"? \"+ ret);\n  }\n  return ret;\n}\n", "docstring": "this method checks that this processor matches the supplied business txn name and node details .", "partition": "test"}
{"idx": "1871", "code": "public void testOrderedByDatatype() throws Exception {\n  int lastType=Integer.MIN_VALUE;\n  while (typeInfoRs.next()) {\n    String name=typeInfoRs.getString(\"TYPE_NAME\");\n    int type=typeInfoRs.getInt(\"DATA_TYPE\");\n    assertTrue(\"type \" + type + \" (\"+ name+ \") less than last type \"+ lastType,type >= lastType);\n    lastType=type;\n  }\n}\n", "docstring": "check types ordered by data type .", "partition": "test"}
{"idx": "1008", "code": "public boolean isStored(){\n  return Integer.signum(id) != -1;\n}\n", "docstring": "determines whether the view was previously stored to the database .", "partition": "test"}
{"idx": "2711", "code": "@Action(value=\"/receipts/challan-newform\") @ValidationErrorPage(value=ERROR) @SkipValidation public String newform(){\n  setLoginDept();\n  SimpleDateFormat sdf=new SimpleDateFormat(\"dd/MM/yyyy\");\n  try {\n    cutOffDate=sdf.parse(collectionsUtil.getAppConfigValue(CollectionConstants.MODULE_NAME_COLLECTIONS_CONFIG,CollectionConstants.APPCONFIG_VALUE_COLLECTIONDATAENTRYCUTOFFDATE));\n  }\n catch (  ParseException e) {\n    LOGGER.error(getText(\"Error parsing Cut Off Date\") + e.getMessage());\n  }\n  return NEW;\n}\n", "docstring": "this method is invoked when the user clicks on create challan from menu tree", "partition": "test"}
{"idx": "4148", "code": "void processAddOnChanges(Window caller,AddOnDependencyChecker.AddOnChangesResult changes){\n  if (addonsDialog != null) {\n    addonsDialog.setDownloadingUpdates();\n  }\n  if (getView() != null) {\n    Set<AddOn> addOns=new HashSet<>(changes.getUninstalls());\n    addOns.addAll(changes.getOldVersions());\n    Set<Extension> extensions=new HashSet<>();\n    extensions.addAll(changes.getUnloadExtensions());\n    extensions.addAll(changes.getSoftUnloadExtensions());\n    if (!warnUnsavedResourcesOrActiveActions(caller,addOns,extensions,true)) {\n      return;\n    }\n  }\n  uninstallAddOns(caller,changes.getUninstalls(),false);\n  Set<AddOn> allAddons=new HashSet<>(changes.getNewVersions());\n  allAddons.addAll(changes.getInstalls());\n  for (  AddOn addOn : allAddons) {\n    if (addonsDialog != null) {\n      addonsDialog.notifyAddOnDownloading(addOn);\n    }\n    downloadAddOn(addOn);\n  }\n}\n", "docstring": "processes the given add - on changes .", "partition": "test"}
{"idx": "3946", "code": "private PendingIntent createRequestPendingIntent(@NonNull String pendingIntentClassName){\n  PendingIntent pendingIntent=null;\n  try {\n    Class classOfPendingIntent=Class.forName(pendingIntentClassName);\n    if (classOfPendingIntent != null) {\n      Intent intent=new Intent(mContext,classOfPendingIntent);\n      pendingIntent=PendingIntent.getService(mContext,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);\n    }\n  }\n catch (  ClassNotFoundException e) {\n    e.printStackTrace();\n  }\n  return pendingIntent;\n}\n", "docstring": "create a pending intent from the storable fence", "partition": "test"}
{"idx": "2117", "code": "public static LinkedList<MaryModule> modulesRequiredForProcessing(MaryDataType sourceType,MaryDataType targetType,Locale locale,Voice voice){\n  if (!registrationComplete)   throw new IllegalStateException(\"Cannot inquire about modules while registration is ongoing\");\n  if (sourceType == null)   throw new NullPointerException(\"Received null source type\");\n  if (targetType == null)   throw new NullPointerException(\"Received null target type\");\n  LinkedList<MaryDataType> seenTypes=new LinkedList<MaryDataType>();\n  seenTypes.add(sourceType);\n  return modulesRequiredForProcessing(sourceType,targetType,locale,voice,seenTypes);\n}\n", "docstring": "a method for determining the list of modules required to transform the given source data type into the requested target data type . if the voice given is not null , any preferred modules it may have are taken into account .", "partition": "test"}
{"idx": "431", "code": "@Override protected String toString(File obj){\n  return obj.getAbsolutePath();\n}\n", "docstring": "turns an object into a string for storing in the props .", "partition": "test"}
{"idx": "2714", "code": "public static boolean waitForAllActiveAndLiveReplicas(ZkStateReader zkStateReader,int timeoutInMs){\n  return waitForAllActiveAndLiveReplicas(zkStateReader,null,timeoutInMs);\n}\n", "docstring": "wait to see * all * cores live and active .", "partition": "test"}
{"idx": "1242", "code": "public void initializeKeyStore(){\n  try {\n    Logger logger=(com.sun.identity.log.Logger)Logger.getLogger(logName);\n    resetCurrentFileList(logName);\n    addToCurrentFileList(logName,logName,logName);\n    String logPath=lmanager.getProperty(LogConstants.LOG_LOCATION);\n    if (!logPath.endsWith(\"/\"))     logPath+=\"/\";\n    String fileName=logName;\n    String loggerFileName=logPath + PREFIX + \"log.\"+ fileName;\n    String verifierFileName=logPath + PREFIX + \"ver.\"+ fileName;\n    Debug.message(logName + \":Logger Keystore name = \" + loggerFileName);\n    Debug.message(logName + \":Verifier Keystore name= \" + verifierFileName);\n    helper.initializeSecureLogHelper(loggerFileName,logPassword,verifierFileName,logPassword);\n    Debug.message(logName + \":Initialized SecureLogHelper\");\n    helper.initializeVerifier(verifierFileName,logPassword,verPassword);\n    Debug.message(logName + \":Done init of SecureLogHelper and Verifier\");\n  }\n catch (  Exception e) {\n    Debug.error(logName + \":Logger: exception thrown while initializing secure logger\",e);\n  }\n}\n", "docstring": "initialize logger key store", "partition": "test"}
{"idx": "1410", "code": "public DirectoryOrFileNotFoundException(String entity,String name){\n  super(String.format(_errorMessage,entity,name));\n}\n", "docstring": "constructs a new exception with detailed error message .", "partition": "test"}
{"idx": "4045", "code": "public int predBlockIndexForSourcesIndex(int sourcesIndex){\n  return operands.get(sourcesIndex).blockIndex;\n}\n", "docstring": "gets the index of the pred block associated with the registerspec at the particular getsources ( ) index .", "partition": "test"}
{"idx": "3593", "code": "static void queuePlayerCapeReplacement(AbstractClientPlayer player){\n  final String displayName=player.getDisplayNameString();\n  Logger.info(\"Queueing cape replacement for %s\",displayName);\n  THREAD_POOL.submit(null);\n}\n", "docstring": "queue the replacement of a player \"'\" s cape with the testmod3 cape . < p > in at least 100 milliseconds , the player \"'\" s cape will be replaced on the next iteration of the client \"'\" s main loop .", "partition": "test"}
{"idx": "1551", "code": "public final boolean insert_via(BrdViaInfo p_via_info,PlaPointInt p_location,NetNosList p_net_no_arr,int p_trace_clearance_class_no,int[] p_trace_pen_halfwidth_arr,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_pull_tight_accuracy,int p_pull_tight_time_limit){\n  shove_fail_clear();\n  changed_area_clear();\n  boolean r_ok=shove_via_algo.shove_via_insert(p_via_info,p_location,p_net_no_arr,p_trace_clearance_class_no,p_trace_pen_halfwidth_arr,p_max_recursion_depth,p_max_via_recursion_depth);\n  if (!r_ok)   return false;\n  NetNosList opt_net_no_arr=p_max_recursion_depth <= 0 ? p_net_no_arr : NetNosList.EMPTY;\n  TimeLimitStoppable t_limit=new TimeLimitStoppable(s_PREVENT_ENDLESS_LOOP);\n  changed_area_optimize(opt_net_no_arr,p_pull_tight_accuracy,null,t_limit,null);\n  return true;\n}\n", "docstring": "shoves aside traces , so that a via with the input parameters can be inserted without clearance violations . if the shove failed , the database may be damaged , so that an undo becomes necessesary .", "partition": "test"}
{"idx": "115", "code": "public static Properties loadProperties(ClassLoader classLoader,String classpathResource){\n  return loadProperties(null,classpathResource);\n}\n", "docstring": "atomically load the properties file at the given location within the designated class loader .", "partition": "test"}
{"idx": "2895", "code": "public Method suspendSRDFGroupMethod(final URI systemURI,final RemoteDirectorGroup group,final List<URI> sourceVolumes,final List<URI> targetVolumes){\n  return new Workflow.Method(SUSPEND_SRDF_GROUP_METHOD,systemURI,group,sourceVolumes,targetVolumes);\n}\n", "docstring": "returns a workflow . method for suspending srdf group", "partition": "test"}
{"idx": "3541", "code": "public String versionCompact(){\n  return properties.getProperty(\"version.compact\");\n}\n", "docstring": "returns the compact version string for this product , suitable for use in path names and similar cases .", "partition": "test"}
{"idx": "2051", "code": "public static void fullReset(){\n  resetRuntime();\nsynchronized (readProperties) {\n    readProperties.clear();\n  }\n}\n", "docstring": "fully reset the state , not only the one related to latest test case execution", "partition": "test"}
{"idx": "746", "code": "public boolean readBoolean() throws IOException {\n  return primitiveTypes.readBoolean();\n}\n", "docstring": "reads a boolean from the source stream .", "partition": "test"}
{"idx": "3918", "code": "private void makeItems(int fingerPosition,List<View> viewList){\n  if (fingerPosition >= viewList.size()) {\n    return;\n  }\n  for (int i=0; i < viewList.size(); i++) {\n    int translationY=Math.min(Math.max(Math.abs(fingerPosition - i) * intervalHeight,10),maxTranslationHeight);\n    updateItemHeightAnimator(viewList.get(i),translationY);\n  }\n}\n", "docstring": "calculates every icon \"'\" s height needed and start animation", "partition": "test"}
{"idx": "2157", "code": "@Override public boolean hasQueuedReaderThreads(){\n  return readerLock.hasQueuedThreads();\n}\n", "docstring": "returns whether there are threads waiting for read access to the guacamole instruction stream .", "partition": "test"}
{"idx": "962", "code": "SparseArray(Class<L> linearArrayType,int[] rowIndices,int[] colIndices,L realValues,L imagValues,int numRows,int numCols){\n  validateUserSuppliedParameters(linearArrayType,rowIndices,colIndices,realValues,imagValues);\n  _baseComponentType=linearArrayType.getComponentType();\n  _outputArrayType=(Class<L[]>)ArrayUtils.getArrayClass(_baseComponentType,2);\n  Map<SparseKey,SparseValue> sparseMap=createSparseMap(linearArrayType,rowIndices,colIndices,realValues,imagValues,numRows,numCols);\n  _numRows=numRows;\n  _numCols=numCols;\n  ArrayList<SparseKey> keys=new ArrayList<SparseKey>(sparseMap.keySet());\n  Collections.sort(keys);\n  _rowIndices=new int[keys.size()];\n  _colIndices=new int[keys.size()];\n  _linearIndices=new int[keys.size()];\n  _realValues=linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  _imagValues=imagValues == null ? null : linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  for (int i=0; i < keys.size(); i++) {\n    SparseKey key=keys.get(i);\n    _rowIndices[i]=key.row;\n    _colIndices[i]=key.col;\n    _linearIndices[i]=key.linearIndex;\n    SparseValue value=sparseMap.get(key);\n    setSparseValue(value,_realValues,_imagValues,i);\n  }\n}\n", "docstring": "data provided by a user ; this data needs to be validated and processed .", "partition": "test"}
{"idx": "2149", "code": "public final void updateCursor(){\n  updatePending.set(false);\n  updateCursorImpl();\n}\n", "docstring": "sets the cursor to correspond the component currently under mouse . this method should not be executed on the toolkit thread as it calls to user code ( e . g . container . findcomponentat ) .", "partition": "test"}
{"idx": "1845", "code": "public static final byte[] unzip(byte[] in) throws IOException {\n  ByteArrayOutputStream outStream=new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);\n  GZIPInputStream inStream=new GZIPInputStream(new ByteArrayInputStream(in));\n  byte[] buf=new byte[BUF_SIZE];\n  while (true) {\n    int size=inStream.read(buf);\n    if (size <= 0)     break;\n    outStream.write(buf,0,size);\n  }\n  outStream.close();\n  return outStream.toByteArray();\n}\n", "docstring": "returns an gunzipped copy of the input array .", "partition": "test"}
{"idx": "885", "code": "private static Class<?> convertFieldType(String fieldType){\n  if (fieldTypeMap.containsKey(fieldType)) {\n    return fieldTypeMap.get(fieldType);\n  }\n  return null;\n}\n", "docstring": "convert field type from string to a class type .", "partition": "test"}
{"idx": "3254", "code": "public void testBug66947() throws Exception {\n  Connection con=null;\n  try {\n    Properties props=new Properties();\n    props.setProperty(\"useServerPrepStmts\",\"true\");\n    props.setProperty(\"cachePrepStmts\",\"true\");\n    props.setProperty(\"prepStmtCacheSize\",\"2\");\n    con=getConnectionWithProps(props);\n    PreparedStatement ps1_1;\n    PreparedStatement ps1_2;\n    String query=\"Select \\'a\\' from dual\";\n    ps1_1=con.prepareStatement(query);\n    ps1_1.execute();\n    ps1_1.close();\n    ps1_2=con.prepareStatement(query);\n    assertSame(\"SSPS should be taken from cache but is not the same.\",ps1_1,ps1_2);\n    ps1_2.execute();\n    ps1_2.close();\n    ps1_2.close();\n    ps1_1=con.prepareStatement(query);\n    assertNotSame(\"SSPS should not be taken from cache but is the same.\",ps1_2,ps1_1);\n    ps1_1.execute();\n    ps1_1.close();\n    ps1_1.close();\n    PreparedStatement ps2_1;\n    PreparedStatement ps2_2;\n    PreparedStatement ps3_1;\n    PreparedStatement ps3_2;\n    ps1_1=con.prepareStatement(\"Select \\'b\\' from dual\");\n    ps1_1.execute();\n    ps1_1.close();\n    ps2_1=con.prepareStatement(\"Select \\'c\\' from dual\");\n    ps2_1.execute();\n    ps2_1.close();\n    ps3_1=con.prepareStatement(\"Select \\'d\\' from dual\");\n    ps3_1.execute();\n    ps3_1.close();\n    ps1_2=con.prepareStatement(\"Select \\'b\\' from dual\");\n    assertNotSame(\"SSPS should not be taken from cache but is the same.\",ps1_1,ps1_2);\n    ps2_2=con.prepareStatement(\"Select \\'c\\' from dual\");\n    assertSame(\"SSPS should be taken from cache but is not the same.\",ps2_1,ps2_2);\n    ps3_2=con.prepareStatement(\"Select \\'d\\' from dual\");\n    assertSame(\"SSPS should be taken from cache but is not the same.\",ps3_1,ps3_2);\n  }\n  finally {\n    if (con != null) {\n      con.close();\n    }\n  }\n}\n", "docstring": "tests fix for bug # 66947 ( 16004987 ) - calling serverpreparedstatement . close ( ) twiche corrupts cached statements", "partition": "test"}
{"idx": "1677", "code": "public static void modifyFile(File file,Function<String,String> modifier) throws IOException {\n  String content=new String(Files.toByteArray(file),StandardCharsets.UTF_8);\n  String result=modifier.apply(content);\n  Files.write(result.getBytes(StandardCharsets.UTF_8),file);\n}\n", "docstring": "modifies the given file in place .", "partition": "test"}
{"idx": "844", "code": "public double localScore(int i,int... parents){\n  for (  int p : parents)   if (forbidden.contains(p))   return Double.NaN;\n  double residualVariance=covariances.get(i,i);\n  int n=getSampleSize();\n  int p=parents.length;\n  Matrix covxx=getSelection1(covariances,parents);\n  try {\n    Matrix covxxInv=covxx.inverse();\n    Matrix covxy=getSelection2(covariances,parents,i);\n    Matrix b=covxxInv.times(covxy);\n    double dot=0.0;\n    for (int j=0; j < covxy.getRowDimension(); j++) {\n      for (int k=0; k < covxy.getColumnDimension(); k++) {\n        dot+=covxy.get(j,k) * b.get(j,k);\n      }\n    }\n    residualVariance-=dot;\n    if (residualVariance <= 0) {\n      if (isVerbose()) {\n        out.println(\"Nonpositive residual varianceY: resVar / varianceY = \" + (residualVariance / covariances.get(i,i)));\n      }\n      return Double.NaN;\n    }\n    double c=getPenaltyDiscount();\n    return score(residualVariance,n,logn,p,c);\n  }\n catch (  Exception e) {\n    boolean removedOne=true;\n    while (removedOne) {\n      List<Integer> _parents=new ArrayList<>();\n      for (int y=0; y < parents.length; y++)       _parents.add(parents[y]);\n      _parents.removeAll(forbidden);\n      parents=new int[_parents.size()];\n      for (int y=0; y < _parents.size(); y++)       parents[y]=_parents.get(y);\n      removedOne=printMinimalLinearlyDependentSet(parents,covariances);\n    }\n    return Double.NaN;\n  }\n}\n", "docstring": "calculates the sample likelihood and bic score for i given its parents in a simple sem model", "partition": "test"}
{"idx": "2593", "code": "public static <NodeType extends IViewNode<?>>ZyProximityNode<?> createProximityNode(final Graph2D graph,final ZyGraphNode<?> attachedNode,final int degree,final boolean isIncoming){\n  Preconditions.checkNotNull(graph,\"Graph argument can not be null\");\n  Preconditions.checkNotNull(attachedNode,\"Target node argument can not be null\");\n  final ZyLabelContent labelcontent=new ZyLabelContent(null);\n  labelcontent.addLineContent(new ZyLineContent(String.valueOf(degree),new Font(\"New Courier\",Font.PLAIN,12),null));\n  final ZyProximityNodeRealizer<NodeType> r=new ZyProximityNodeRealizer<NodeType>(labelcontent);\n  final Node node=graph.createNode(r);\n  @SuppressWarnings(\"unchecked\") final ZyProximityNode<NodeType> infoNode=new ZyProximityNode<NodeType>(node,r,(ZyGraphNode<NodeType>)attachedNode,isIncoming);\n  final ZyNodeData<ZyProximityNode<NodeType>> data=new ZyNodeData<ZyProximityNode<NodeType>>(infoNode);\n  r.setUserData(data);\n  return infoNode;\n}\n", "docstring": "creates a proximity browsing node .", "partition": "test"}
{"idx": "2433", "code": "@Override @SuppressWarnings(\"unchecked\") public void completed(int bytesTransferred,boolean canInvokeDirect){\n  if (bytesTransferred == 0) {\n    bytesTransferred=-1;\n  }\n else {\n    updateBuffers(bytesTransferred);\n  }\n  releaseBuffers();\nsynchronized (result) {\n    if (result.isDone())     return;\n    enableReading();\n    if (scatteringRead) {\n      result.setResult((V)Long.valueOf(bytesTransferred));\n    }\n else {\n      result.setResult((V)Integer.valueOf(bytesTransferred));\n    }\n  }\n  if (canInvokeDirect) {\n    Invoker.invokeUnchecked(result);\n  }\n else {\n    Invoker.invoke(result);\n  }\n}\n", "docstring": "executed when the i / o has completed", "partition": "test"}
{"idx": "1346", "code": "private static Boolean isInsidePolygon(final GeoPoint point,final List<GeoPoint> polyPoints){\n  final double latitude=point.getLatitude();\n  final double longitude=point.getLongitude();\n  final double sinLatitude=Math.sin(latitude);\n  final double cosLatitude=Math.cos(latitude);\n  final double sinLongitude=Math.sin(longitude);\n  final double cosLongitude=Math.cos(longitude);\n  double arcDistance=0.0;\n  Double prevAngle=null;\n  for (  final GeoPoint polyPoint : polyPoints) {\n    final Double angle=computeAngle(polyPoint,sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (angle == null) {\n      return null;\n    }\n    if (prevAngle != null) {\n      double angleDelta=angle - prevAngle;\n      if (angleDelta < -Math.PI) {\n        angleDelta+=Math.PI * 2.0;\n      }\n      if (angleDelta > Math.PI) {\n        angleDelta-=Math.PI * 2.0;\n      }\n      if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n        return null;\n      }\n      arcDistance+=angleDelta;\n    }\n    prevAngle=angle;\n  }\n  if (prevAngle != null) {\n    final Double lastAngle=computeAngle(polyPoints.get(0),sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (lastAngle == null) {\n      return null;\n    }\n    double angleDelta=lastAngle - prevAngle;\n    if (angleDelta < -Math.PI) {\n      angleDelta+=Math.PI * 2.0;\n    }\n    if (angleDelta > Math.PI) {\n      angleDelta-=Math.PI * 2.0;\n    }\n    if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n      return null;\n    }\n    arcDistance+=angleDelta;\n  }\n  if (Math.abs(arcDistance) < Vector.MINIMUM_RESOLUTION) {\n    return null;\n  }\n  return arcDistance > 0.0;\n}\n", "docstring": "for a specified point and a list of poly points , determine based on point order whether the point should be considered in or out of the polygon .", "partition": "test"}
{"idx": "1890", "code": "@SuppressWarnings(\"UnusedReturnValue\") public int readOutlineFileMetadata(final PdfObject OutlinesObj,final PdfObjectReader currentPdfFile){\n  final int count=OutlinesObj.getInt(PdfDictionary.Count);\n  final PdfObject FirstObj=OutlinesObj.getDictionary(PdfDictionary.First);\n  currentPdfFile.checkResolved(FirstObj);\n  if (FirstObj != null) {\n    final Element root=OutlineDataXML.createElement(\"root\");\n    OutlineDataXML.appendChild(root);\n    final int level=0;\n    readOutlineLevel(root,currentPdfFile,FirstObj,level,false);\n  }\n  return count;\n}\n", "docstring": "read the outline data", "partition": "test"}
{"idx": "4095", "code": "protected int drawLegend(Canvas canvas,DefaultRenderer renderer,String[] titles,int left,int right,int y,int width,int height,int legendSize,Paint paint,boolean calculate){\n  float size=32;\n  if (renderer.isShowLegend()) {\n    float currentX=left;\n    float currentY=y + height - legendSize + size;\n    paint.setTextAlign(Component.LEFT);\n    paint.setTextSize(renderer.getLegendTextSize());\n    int sLength=Math.min(titles.length,renderer.getSeriesRendererCount());\n    for (int i=0; i < sLength; i++) {\n      SimpleSeriesRenderer r=renderer.getSeriesRendererAt(i);\n      final float lineSize=getLegendShapeWidth(i);\n      if (r.isShowLegendItem()) {\n        String text=titles[i];\n        if (titles.length == renderer.getSeriesRendererCount()) {\n          paint.setColor(r.getColor());\n        }\n else {\n          paint.setColor(ColorUtil.LTGRAY);\n        }\n        float[] widths=new float[text.length()];\n        paint.getTextWidths(text,widths);\n        float sum=0;\n        for (        float value : widths) {\n          sum+=value;\n        }\n        float extraSize=lineSize + 10 + sum;\n        float currentWidth=currentX + extraSize;\n        if (i > 0 && getExceed(currentWidth,renderer,right,width)) {\n          currentX=left;\n          currentY+=renderer.getLegendTextSize();\n          size+=renderer.getLegendTextSize();\n          currentWidth=currentX + extraSize;\n        }\n        if (getExceed(currentWidth,renderer,right,width)) {\n          float maxWidth=right - currentX - lineSize- 10;\n          if (isVertical(renderer)) {\n            maxWidth=width - currentX - lineSize- 10;\n          }\n          int nr=paint.breakText(text,true,maxWidth,widths);\n          text=text.substring(0,nr) + \"...\";\n        }\n        if (!calculate) {\n          drawLegendShape(canvas,r,currentX,currentY,i,paint);\n          drawString(canvas,text,currentX + lineSize + 5,currentY + 5,paint);\n        }\n        currentX+=extraSize;\n      }\n    }\n  }\n  return Math.round(size + renderer.getLegendTextSize());\n}\n", "docstring": "draws the chart legend .", "partition": "test"}
{"idx": "3955", "code": "@Override public boolean runAfter(List tasks,int size){\n  for (int i=0; i < size; i++) {\n    CacheTask t=(CacheTask)tasks.get(i);\n    if (t instanceof RegisterListenerTask || t instanceof LookupTask) {\n      ProxyReg otherReg=t.getProxyReg();\n      if (reg.equals(otherReg)) {\n        if (thisTaskSeqN > t.getSeqN())         return true;\n      }\n    }\n  }\n  return super.runAfter(tasks,size);\n}\n", "docstring": "returns true if the current instance of this task must be run after at least one task in the task manager queue . the criteria for determining what value to return : if the task list contains any registerlistenertasks or lookuptasks associated with this task \"'\" s lookup service ( proxyreg ) , and if those tasks were queued prior to this task ( have lower sequence numbers ) , then run those tasks before this task ( return true ) . additionally , if the task list contains any other serviceidtasks associated with this task \"'\" s service id which were queued prior to this task , then run those tasks before this task . if the criteria outlined above is not satisfied , then this task can be run immediately ( return false ) . this method was added to address bug id 6291851 .", "partition": "test"}
{"idx": "2462", "code": "public boolean threadSafeTimeout(long delayTime,TimeUnit unit,Action0 action){\n  boolean scheduled=true;\n  Thread currentThread=Thread.currentThread();\n  if (currentThread.equals(dutyThread)) {\n    timerWheel.newTimeout(delayTime,unit,null);\n  }\n else {\n    scheduled=actions.offer(null);\n  }\n  return scheduled;\n}\n", "docstring": "schedules timeout on the timerwheel in a thread - safe manner", "partition": "test"}
{"idx": "1464", "code": "public static ReilGraph copyReilCode(final Window parent,final INaviCodeNode node){\n  final ReilTranslator<INaviInstruction> translator=new ReilTranslator<INaviInstruction>();\n  try {\n    return translator.translate(new StandardEnvironment(),node);\n  }\n catch (  final InternalTranslationException e) {\n    CUtilityFunctions.logException(e);\n    final String message=\"E000XXX: \" + \"Could not show REIL code for node\";\n    final String description=CUtilityFunctions.createDescription(String.format(\"BinNavi could not show the REIL code for basic block at \\'%X\\'.\",node.getAddress()),new String[]{\"The instructions could not be converted to REIL code.\"},new String[]{\"You can not fix this problem yourself. Please contact \" + \"the BinNavi support.\"});\n    NaviErrorDialog.show(parent,message,description,e);\n  }\n  return null;\n}\n", "docstring": "copy reil code for node", "partition": "test"}
{"idx": "2059", "code": "@Override public boolean canBeCollidedWith(){\n  return true;\n}\n", "docstring": "returns true if other entities should be prevented from moving through this entity .", "partition": "test"}
{"idx": "3403", "code": "public void addResult(AMIdentity id,Map attrs){\n  searchResults.add(id);\n  resultsMap.put(id,attrs);\n}\n", "docstring": "adds an amidentity object to this search result .", "partition": "test"}
{"idx": "3619", "code": "private Handler<Void> installAfterHandler(final HttpServerRequest request,final Buffer buffer,final List<Listener> afterListener){\n  Handler<Void> afterHandler=null;\n  return afterHandler;\n}\n", "docstring": "this handler is called after the self request ( original request ) is performed successfully . the handler calls all listener ( after ) , so this requests happen after the original request is performed .", "partition": "test"}
{"idx": "628", "code": "public void insertTwin(Instruction inst,Instruction twin){\n  ListIterator<GCIRMapElement> iter=list.listIterator();\n  while (iter.hasNext()) {\n    GCIRMapElement newPtr=iter.next();\n    if (newPtr.getInstruction() == inst) {\n      iter.add(newPtr.createTwin(twin));\n      return;\n    }\n  }\n  throw new OptimizingCompilerException(\"GCIRMap.createTwin: \" + inst + \" not found\");\n}\n", "docstring": "this method inserts an entry for a \" twin \" instruction immediately after the original entry . if the instruction is not found in the gc map an exception is thrown .", "partition": "test"}
{"idx": "199", "code": "CryptoResult(final T result,final List<K> masterKeys,final CiphertextHeaders headers){\n  result_=result;\n  masterKeys_=Collections.unmodifiableList(masterKeys);\n  headers_=headers;\n  encryptionContext_=headers_.getEncryptionContextMap();\n}\n", "docstring": "note , does not make a defensive copy of any of the data .", "partition": "test"}
{"idx": "1722", "code": "private long[] determinePreferenceVector(Relation<V> relation,ModifiableDBIDs[] neighborIDs,StringBuilder msg){\n  if (strategy.equals(Strategy.APRIORI)) {\n    return determinePreferenceVectorByApriori(relation,neighborIDs,msg);\n  }\n else   if (strategy.equals(Strategy.MAX_INTERSECTION)) {\n    return determinePreferenceVectorByMaxIntersection(neighborIDs,msg);\n  }\n else {\n    throw new IllegalStateException(\"Should never happen!\");\n  }\n}\n", "docstring": "determines the preference vector according to the specified neighbor ids .", "partition": "test"}
{"idx": "2485", "code": "public void addPutAndGetTimeNanos(long duration){\n  putTimeNanos.addAndGet(duration);\n  getTimeNanos.addAndGet(duration);\n  if (delegate != null)   delegate.addPutAndGetTimeNanos(duration);\n}\n", "docstring": "increments put and get time accumulators .", "partition": "test"}
{"idx": "3272", "code": "public final boolean isOpen(){\n  return closed.get() == false;\n}\n", "docstring": "returns true if this lock is still open ie . has not been closed yet .", "partition": "test"}
{"idx": "2137", "code": "public void addSafeClass(SootClass clz){\n  safeClasses.add(clz.getName());\n}\n", "docstring": "denote that all methods of a class are safe .", "partition": "test"}
{"idx": "2765", "code": "private ReplicatorRuntimeConf(String serviceName){\n  replicatorHomeDir=locateReplicatorHomeDir();\n  replicatorLogDir=locateReplicatorLogDir();\n  replicatorConfDir=locateReplicatorConfDir();\n  replicatorProperties=new File(locateReplicatorConfDir(),\"static-\" + serviceName + \".properties\");\n  if (!replicatorProperties.isFile() || !replicatorProperties.canRead()) {\n    throw new ServerRuntimeException(\"Replicator static properties does not exist or is invalid: \" + replicatorProperties);\n  }\n  replicatorDynamicProperties=new File(replicatorConfDir,\"dynamic-\" + serviceName + \".properties\");\n  replicatorDynamicRole=new File(replicatorConfDir,\"dynamic-\" + serviceName + \".role\");\n  this.clearDynamicProperties=Boolean.parseBoolean(System.getProperty(CLEAR_DYNAMIC_PROPERTIES));\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "826", "code": "Sentence parseSentence(final String text,final ConversationContext ctx){\n  if (isEmpty()) {\n    return ConversationParser.parse(text,ctx);\n  }\n  String txt=text.trim();\n  final Sentence sentence=new SentenceImplementation(ctx,txt);\n  txt=ConversationParser.detectSentenceType(txt,sentence);\n  if (typeMatching) {\n    readTypeMatchExpressions(txt,ctx,sentence);\n  }\n else   if (exactMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (similarMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (jokerMatching) {\n    readJokerExpressions(txt,ctx,sentence);\n  }\n else   if (caseInsensitive) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n  return sentence;\n}\n", "docstring": "parse the given text string and create a sentence object using the current matching flags .", "partition": "test"}
{"idx": "2888", "code": "public static byte[] decode(String hexa) throws CoderException {\n  if (hexa == null) {\n    throw new CoderException(\"can\\'t decode empty String\");\n  }\n  if ((hexa.length() % 2) != 0) {\n    throw new CoderException(\"invalid hexadicimal String\");\n  }\n  int tamArray=hexa.length() / 2;\n  byte[] retorno=new byte[tamArray];\n  for (int i=0; i < tamArray; i++) {\n    retorno[i]=hexToByte(hexa.substring(i * 2,i * 2 + 2));\n  }\n  return retorno;\n}\n", "docstring": "decodes back a string to a byte array", "partition": "test"}
{"idx": "3544", "code": "public void findAndUndo(Object someObj){\n  if (someObj instanceof com.bbn.openmap.MapBean) {\n    logger.fine(\"ProjectionStack removing a MapBean.\");\n    MapBean map=getMapBean();\n    if (map != null && map == (MapBean)someObj) {\n      setMapBean(null);\n    }\n  }\n}\n", "docstring": "look at the object received in a maphandler status message and disconnect from it if necessary .", "partition": "test"}
{"idx": "416", "code": "public static KEYSTORE_TYPE fromString(String x) throws ConfigurationException {\n  for (  KEYSTORE_TYPE currentType : KEYSTORE_TYPE.values()) {\n    if (x.equalsIgnoreCase(currentType.toString()))     return currentType;\n  }\n  throw new ConfigurationException(MessageFormat.format(\"Cannot cast into a known CERTIFICATE_KEY_TYPE: {0}\",x));\n}\n", "docstring": "converts a string into the corresponding keystore_type", "partition": "test"}
{"idx": "175", "code": "public void add(int position,@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(position,item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(position);\n  }\n}\n", "docstring": "adds the specified item to the list with the specified position", "partition": "test"}
{"idx": "1369", "code": "public void addChannelMap(ChannelMap channelMap){\n  if (!mChannelMaps.contains(channelMap)) {\n    mChannelMaps.add(channelMap);\n    int index=mChannelMaps.indexOf(channelMap);\n    fireIntervalAdded(this,index,index);\n    broadcast(new ChannelMapEvent(channelMap,Event.ADD));\n  }\n}\n", "docstring": "adds the channel map to this model", "partition": "test"}
{"idx": "3798", "code": "protected void addInputNode_internal(BNode inputNode){\n  if (inputNodes.containsKey(inputNode.getId())) {\n    log.warning(\"node \" + inputNode.getId() + \" already included in the input nodes of \"+ nodeId);\n  }\n  inputNodes.put(inputNode.getId(),inputNode);\n}\n", "docstring": "adds a new incoming relation to the node . this method should never be called outside the addrelation method , to ensure consistency between the input and output links .", "partition": "test"}
{"idx": "1969", "code": "public long start(){\n  startTime=System.currentTimeMillis();\n  return startTime;\n}\n", "docstring": "start the stop watch .", "partition": "test"}
{"idx": "1287", "code": "public void enableDependency(Capability c){\n  if (doNotCheckCapabilities()) {\n    return;\n  }\n  if (c == Capability.NOMINAL_ATTRIBUTES) {\n    enableDependency(Capability.BINARY_ATTRIBUTES);\n  }\n else   if (c == Capability.BINARY_ATTRIBUTES) {\n    enableDependency(Capability.UNARY_ATTRIBUTES);\n  }\n else   if (c == Capability.UNARY_ATTRIBUTES) {\n    enableDependency(Capability.EMPTY_NOMINAL_ATTRIBUTES);\n  }\n else   if (c == Capability.NOMINAL_CLASS) {\n    enableDependency(Capability.BINARY_CLASS);\n  }\n  m_Dependencies.add(c);\n}\n", "docstring": "enables the dependency flag for the given capability enabling nominal_attributes also enables binary_attributes , unary_attributes and empty_nominal_attributes . enabling binary_attributes also enables unary_attributes and empty_nominal_attributes . enabling unary_attributes also enables empty_nominal_attributes . but nominal_class only enables binary_class , since normal schemes in weka don \"'\" t work with datasets that have only 1 class label ( or none ) .", "partition": "test"}
{"idx": "1867", "code": "public static ExecutionSystem newExecutionSystem(URI uri,Map<String,?> env) throws IOException {\n  return newExecutionSystem(uri,env,null);\n}\n", "docstring": "creates a new execution system for the specified uri . the number of execution systems with a given uri that may open at the same time is implementation dependent .", "partition": "test"}
{"idx": "3576", "code": "private static Stream<Method> extractMethods(Class clazz){\n  try {\n    Method[] methods=clazz.getMethods();\n    if (methods.length > 0) {\n      return Stream.of(methods);\n    }\n  }\n catch (  Exception|Error e) {\n    LOG.warn(\"Problems loading class at startup: {}\",clazz,e);\n  }\n  return Stream.empty();\n}\n", "docstring": "extract a set of methods from a given class .", "partition": "test"}
{"idx": "1797", "code": "public EMail createEMail(String value){\n  EmailField emailImpl=new EmailField();\n  try {\n    emailImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return emailImpl;\n}\n", "docstring": "returns email object with the specified value .", "partition": "test"}
{"idx": "763", "code": "@Override public synchronized void powerOnSelfTest() throws Error {\n  for (Iterator<WaveformSynthesizer> it=waveformSynthesizers.iterator(); it.hasNext(); ) {\n    WaveformSynthesizer ws=it.next();\n    ws.powerOnSelfTest();\n  }\n}\n", "docstring": "perform a power - on self test by processing some example input data .", "partition": "test"}
{"idx": "2898", "code": "public static ServerSocket createServerSocket(int port,InetAddress bindAddress) throws IOException {\n  ServerSocket socket=null;\n  if (SysProperties.ENABLE_ANONYMOUS_TLS) {\n    removeAnonFromLegacyAlgorithms();\n  }\n  setKeystore();\n  ServerSocketFactory f=SSLServerSocketFactory.getDefault();\n  SSLServerSocket secureSocket;\n  if (bindAddress == null) {\n    secureSocket=(SSLServerSocket)f.createServerSocket(port);\n  }\n else {\n    secureSocket=(SSLServerSocket)f.createServerSocket(port,0,bindAddress);\n  }\n  secureSocket.setEnabledProtocols(disableSSL(secureSocket.getEnabledProtocols()));\n  if (SysProperties.ENABLE_ANONYMOUS_TLS) {\n    String[] list=enableAnonymous(secureSocket.getEnabledCipherSuites(),secureSocket.getSupportedCipherSuites());\n    secureSocket.setEnabledCipherSuites(list);\n  }\n  socket=secureSocket;\n  return socket;\n}\n", "docstring": "create a secure server socket . if a bind address is specified , the socket is only bound to this address . if h2 . enableanonymoustls is true , an attempt is made to modify the security property jdk . tls . legacyalgorithms ( in newer jvms ) to allow anonymous tls . this system change is effectively permanent for the lifetime of the jvm .", "partition": "test"}
{"idx": "3097", "code": "public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  JComponent comp=(c instanceof JComponent) ? (JComponent)c : null;\n  if (g instanceof Graphics2D) {\n    Graphics2D g2=(Graphics2D)g;\n    g2.translate(x,y);\n    paint(g2,comp,width,height);\n    g2.translate(-x,-y);\n  }\n else {\n    BufferedImage img=new BufferedImage(IMG_SIZE,IMG_SIZE,BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g2=(Graphics2D)img.getGraphics();\n    paint(g2,comp,width,height);\n    g2.dispose();\n    ImageScalingHelper.paint(g,x,y,width,height,img,INSETS,INSETS,ImageScalingHelper.PaintType.PAINT9_STRETCH,ImageScalingHelper.PAINT_ALL);\n  }\n}\n", "docstring": "paints the border for the specified component with the specified position and size .", "partition": "test"}
{"idx": "556", "code": "public static <T>ParallelFlux<T> from(Publisher<? extends T> source,int parallelism){\n  return from(source,parallelism,QueueSupplier.SMALL_BUFFER_SIZE,QueueSupplier.small());\n}\n", "docstring": "take a publisher and prepare to consume it on parallallism number of \"'\" rails \"'\" , possibly ordered and round - robin fashion .", "partition": "test"}
{"idx": "4027", "code": "private boolean keyChainContainsPrivateKey(Collection<ECKey> keyChain,ECKey keyToAdd){\n  if (keyChain == null || keyToAdd == null) {\n    return false;\n  }\n else {\n    for (    ECKey loopKey : keyChain) {\n      if (Arrays.equals(keyToAdd.getPrivKeyBytes(),loopKey.getPrivKeyBytes())) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n", "docstring": "this method is here because there is no equals on eckey .", "partition": "test"}
{"idx": "3706", "code": "private void grow(){\n  int newCap=(entries.length << 1) + 1;\n  Object[] newEntries=new Object[newCap];\n  System.arraycopy(entries,0,newEntries,0,size);\n  entries=newEntries;\n}\n", "docstring": "expands capacity of internal arrays .", "partition": "test"}
{"idx": "12", "code": "@Override public boolean isTraceEnabled(){\n  return logger.isLoggable(Level.FINEST);\n}\n", "docstring": "is this logger instance enabled for the finest level ?", "partition": "test"}
{"idx": "4113", "code": "@Override public final E nextElement(){\n  E result=m_Vector.get(m_Counter);\n  m_Counter++;\n  if (m_Counter == m_SpecialElement) {\n    m_Counter++;\n  }\n  return result;\n}\n", "docstring": "returns the next element .", "partition": "test"}
{"idx": "2374", "code": "public GlowScheduler(GlowServer server,WorldScheduler worlds){\n  this.server=server;\n  this.worlds=worlds;\n  inTickTaskCondition=worlds.getAdvanceCondition();\n  tickEndRun=null;\n  primaryThread=Thread.currentThread();\n}\n", "docstring": "creates a new task scheduler .", "partition": "test"}
{"idx": "290", "code": "public FileCommandInfo(int fd,String command,int result,String parameters){\n  this(true,fd,command,result,parameters);\n}\n", "docstring": "example : 0x1001 , \" close \" , 0x0 , \" \"", "partition": "test"}
{"idx": "1232", "code": "public ConsulTopologyFraction(){\n  this.url=DEFAULT_URL;\n}\n", "docstring": "construct a default fraction using the default agent url of http : / / localhost : 8500 / .", "partition": "test"}
{"idx": "4251", "code": "public JdpBroadcaster(InetAddress address,InetAddress srcAddress,int port,int ttl) throws IOException, JdpException {\n  this.addr=address;\n  this.port=port;\n  ProtocolFamily family=(address instanceof Inet6Address) ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n  channel=DatagramChannel.open(family);\n  channel.setOption(StandardSocketOptions.SO_REUSEADDR,true);\n  channel.setOption(StandardSocketOptions.IP_MULTICAST_TTL,ttl);\n  if (srcAddress != null) {\n    NetworkInterface interf=NetworkInterface.getByInetAddress(srcAddress);\n    try {\n      channel.bind(new InetSocketAddress(srcAddress,0));\n    }\n catch (    UnsupportedAddressTypeException ex) {\n      throw new JdpException(\"Unable to bind to source address\");\n    }\n    channel.setOption(StandardSocketOptions.IP_MULTICAST_IF,interf);\n  }\n}\n", "docstring": "create a new broadcaster", "partition": "test"}
{"idx": "1315", "code": "public static int randomRangeInt(int min,int max){\n  return (int)(Math.random() < 0.5 ? ((1 - Math.random()) * (max - min) + min) : (Math.random() * (max - min) + min));\n}\n", "docstring": "returns a random integer between the value min and the value max .", "partition": "test"}
{"idx": "341", "code": "private static int lastIndexOf(Object o,@NotNull Object[] elements,int index){\n  if (o == null) {\n    for (int i=index; i >= 0; i--) {\n      if (elements[i] == null) {\n        return i;\n      }\n    }\n  }\n else {\n    for (int i=index; i >= 0; i--) {\n      if (o.equals(elements[i])) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n", "docstring": "static version of lastindexof .", "partition": "test"}
{"idx": "1321", "code": "public void closeStream(){\n  CarbonUtil.closeStreams(stream);\n  executorService.shutdown();\n}\n", "docstring": "below method will be used to close streams", "partition": "test"}
{"idx": "3406", "code": "public void testHasAttributes1() throws Throwable {\n  Document doc;\n  NodeList addrList;\n  Node addrNode;\n  boolean state;\n  doc=(Document)load(\"staff\",builder);\n  addrList=doc.getElementsByTagName(\"name\");\n  addrNode=addrList.item(0);\n  state=addrNode.hasAttributes();\n  assertFalse(\"throw_False\",state);\n}\n", "docstring": "runs the test case .", "partition": "test"}
{"idx": "252", "code": "public void await(int ID) throws InterruptedException {\n  if (parties == 1)   return;\n  final boolean startCondition=competitionCondition;\n  int competingFor=(locks.length * 2 - 1 - ID) / 2;\n  while (competingFor >= 0) {\n    final Lock node=locks[competingFor];\n    if (node.tryLock()) {\nsynchronized (node) {\n        while (competitionCondition == startCondition)         node.wait();\n      }\n      node.unlock();\n      wakeUpTarget(competingFor * 2 + 1);\n      wakeUpTarget(competingFor * 2 + 2);\n      return;\n    }\n else {\n      if (competingFor == 0)       break;\n      competingFor=(competingFor - 1) / 2;\n    }\n  }\n  competitionCondition=!competitionCondition;\n  wakeUpTarget(0);\n}\n", "docstring": "waits for all threads to reach this barrier .", "partition": "test"}
{"idx": "4021", "code": "public InputStreamReader(java.io.InputStream is,java.lang.String enc) throws java.io.UnsupportedEncodingException {\n  internal=is;\n  this.enc=enc.intern();\n}\n", "docstring": "create an inputstreamreader that uses the named character encoding . is - an inputstreamenc - the name of a supported character encoding - if the named encoding is not supported", "partition": "test"}
{"idx": "3974", "code": "public static float mean(float[] data,int[] inds){\n  float mean=0;\n  for (int i=0; i < inds.length; i++) {\n    if (Float.isNaN(data[inds[i]]))     throw new IllegalArgumentException(\"NaN not allowed in mean calculation\");\n    mean+=data[inds[i]];\n  }\n  mean/=inds.length;\n  return mean;\n}\n", "docstring": "compute the mean of all elements in the array with given indices . no missing values ( nan ) are allowed .", "partition": "test"}
{"idx": "3200", "code": "public static boolean isExplicitAllType(String[] types){\n  return types != null && types.length == 1 && ALL.equals(types[0]);\n}\n", "docstring": "identifies whether the array containing type names given as argument explicitly refers to all types the empty or null array doesn \"'\" t explicitly map to all types", "partition": "test"}
{"idx": "3913", "code": "public static boolean isUnlimitedStrengthPolicyAvailable(){\n  try {\n    return Cipher.getMaxAllowedKeyLength(\"AES\") >= 256;\n  }\n catch (  final NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return false;\n}\n", "docstring": "helper method to check whether the jvm has the unlimited strength policy installed", "partition": "test"}
{"idx": "797", "code": "private static boolean isBufferTooLarge(ByteBuffer buf){\n  return isBufferTooLarge(buf.capacity());\n}\n", "docstring": "returns true if the buffer is too large to be added to the buffer cache , false otherwise .", "partition": "test"}
{"idx": "3394", "code": "public void export(ByteBuffer buf){\n  buf.putInt(seqId);\n  if (info.isRowBlockEnabled())   buf.putInt(nRows);\n  export(primaryKey,buf);\n  for (  ByteArray cb : cellBlocks) {\n    export(cb,buf);\n  }\n}\n", "docstring": "write data to given buffer , like serialize", "partition": "test"}
{"idx": "3344", "code": "public static int columnsNumber(char c,int x,int prevX,int plainSpaceSize){\n  if (c != '\\\\t') {\n    return 1;\n  }\n  int result=(x - prevX) / plainSpaceSize;\n  if ((x - prevX) % plainSpaceSize > 0) {\n    result++;\n  }\n  return result;\n}\n", "docstring": "allows to answer how many columns are necessary for representation of the given char on a screen .", "partition": "test"}
{"idx": "1965", "code": "public int length(){\n  return text.length();\n}\n", "docstring": "retruns the length of the text . alternativ you can use gettext ( ) . length ( )", "partition": "test"}
{"idx": "936", "code": "private static synchronized String formatAndParse(SimpleDateFormat formatDate,SimpleDateFormat parseDate,String text){\n  try {\n    Date date=parseDate.parse(text);\n    String result=formatDate.format(date);\n    return result;\n  }\n catch (  ParseException e) {\n    logger.warning(\"Unable to parse:\" + text);\n  }\n  return \"\";\n}\n", "docstring": "synchronized because simpledatformat aren \"'\" t thread safe", "partition": "test"}
{"idx": "1672", "code": "private void loadConfigurationFromJvmParameters(){\n  String repositoryProperty=System.getProperty(REPOSITORY_PROPERTY);\n  if (null != repositoryProperty) {\n    String[] repositoryIpHost=repositoryProperty.split(\":\");\n    if (repositoryIpHost.length == 2) {\n      String repositoryIp=repositoryIpHost[0];\n      String repositoryPort=repositoryIpHost[1];\n      if (StringUtils.isNotBlank(repositoryIp) && StringUtils.isNotBlank(repositoryPort)) {\n        log.info(\"Repository information found in the JVM parameters: IP=\" + repositoryIp + \" Port=\"+ repositoryPort);\n        try {\n          int port=Integer.parseInt(repositoryPort);\n          setRepository(repositoryIp,port);\n        }\n catch (        Exception e) {\n          log.warn(\"Repository could not be defined from the data in the JVM parameters\",e);\n        }\n      }\n    }\n  }\n  String agentName=System.getProperty(AGENT_NAME_PROPERTY);\n  if (StringUtils.isNotBlank(agentName)) {\n    try {\n      log.info(\"Agent name found in the JVM parameters: AgentName=\" + agentName);\n      setAgentName(agentName);\n    }\n catch (    Exception e) {\n      log.warn(\"Agent name could not be defined from the data in the JVM parameters\",e);\n    }\n  }\n else {\n    try {\n      setAgentName(DEFAULT_AGENT_NAME);\n    }\n catch (    StorageException e) {\n      log.warn(\"Agent name could not be defined from default agent name\",e);\n    }\n  }\n}\n", "docstring": "checks if the jvm parameters have the repository and agent information .", "partition": "test"}
{"idx": "2639", "code": "public String charge(Properties ctx,int WindowNo,GridTab mTab,GridField mField,Object value){\n  Integer C_Charge_ID=(Integer)value;\n  if (C_Charge_ID == null || C_Charge_ID.intValue() == 0)   return \"\";\n  String sql=\"SELECT ChargeAmt FROM C_Charge WHERE C_Charge_ID=?\";\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,C_Charge_ID.intValue());\n    rs=pstmt.executeQuery();\n    if (rs.next()) {\n      mTab.setValue(\"PriceEntered\",rs.getBigDecimal(1));\n    }\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n    return e.getLocalizedMessage();\n  }\n finally {\n    DB.close(rs,pstmt);\n    rs=null;\n    pstmt=null;\n  }\n  return tax(ctx,WindowNo,mTab,mField,value);\n}\n", "docstring": "invoice batch line - charge . - updates priceentered from charge calles tax", "partition": "test"}
{"idx": "2147", "code": "private Map<String,AnnotationMirror> annosInPackage(PackageElement packageElement){\n  return createImportedAnnotationsMap(ElementFilter.typesIn(packageElement.getEnclosedElements()));\n}\n", "docstring": "all annotations defined in the package . keys are simple names .", "partition": "test"}
{"idx": "1824", "code": "public static void appendContentPrefix(HttpServletRequest request,Appendable urlBuffer) throws IOException {\n  appendContentPrefix(request,urlBuffer,null);\n}\n", "docstring": "appends content prefix to buffer . < p > scipio : note : orig ofbiz signature .", "partition": "test"}
{"idx": "890", "code": "@RpcMethod public void detachISO(String vmId,boolean isDeleteFile,AsyncMethodCallback<Host.AsyncClient.detach_iso_call> handler) throws RpcException {\n  ensureClient();\n  DetachISORequest detachISORequest=new DetachISORequest(vmId);\n  detachISORequest.setDelete_file(isDeleteFile);\n  clientProxy.setTimeout(DETACH_ISO_TIMEOUT_MS);\n  logger.info(\"detach_iso vm {}, target {}, request {}\",vmId,getHostIp(),detachISORequest);\n  try {\n    clientProxy.detach_iso(detachISORequest,handler);\n  }\n catch (  TException e) {\n    throw new RpcException(e.getMessage());\n  }\n}\n", "docstring": "this method performs an asynchronous thrift call to detach an iso from a vm . on completion , the specified handler is invoked .", "partition": "test"}
{"idx": "4201", "code": "public PKCS10Attribute(PKCS9Attribute attr){\n  this.attributeId=attr.getOID();\n  this.attributeValue=attr.getValue();\n}\n", "docstring": "constructs an attribute from pkcs9 attribute .", "partition": "test"}
{"idx": "2249", "code": "private void writeLocalCSV(MedtronicSensorRecord mostRecentData,Context context){\n  try {\n    if (mostRecentData == null || mostRecentData.bGValue == null)     log.debug(\"writeLocalCSV SAVING  EMPTY!!\");\n else     log.debug(\"writeLocalCSV SAVING --> \" + mostRecentData.bGValue);\n    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File(context.getFilesDir(),\"save.bin\")));\n    oos.writeObject(mostRecentData);\n    oos.flush();\n    oos.close();\n  }\n catch (  Exception e) {\n    Log.e(TAG,\"write to OutputStream failed\",e);\n    log.error(\"write to OutputStream failed\",e);\n  }\n}\n", "docstring": "this method saves a file with the last record read from the device", "partition": "test"}
{"idx": "3872", "code": "public String urlForPOISearch(String tag,BoundingBox bb,int limit,int timeout){\n  StringBuilder s=new StringBuilder();\n  s.append(mService + \"?data=\");\n  String sBB=\"(\" + bb.getLatSouth() + \",\"+ bb.getLonWest()+ \",\"+ bb.getLatNorth()+ \",\"+ bb.getLonEast()+ \")\";\n  String data=\"[out:json][timeout:\" + timeout + \"];(\"+ \"node[\"+ tag+ \"]\"+ sBB+ \";\"+ \"way[\"+ tag+ \"]\"+ sBB+ \";\"+ \"relation[\"+ tag+ \"]\"+ sBB+ \";\"+ \");out qt center \"+ limit+ \" tags;\";\n  Log.d(BonusPackHelper.LOG_TAG,\"data=\" + data);\n  s.append(URLEncoder.encode(data));\n  return s.toString();\n}\n", "docstring": "build the url to search for elements having a specific osm tag ( key = value ) , within a bounding box . elements will be osm nodes , ways and relations . ways and relations will have no geometry , only their center . < br > usage : urlforpoisearch ( \" amenity = cinema \" , map . getboundingbox ( ) , 200 , 30 ) ; < br >", "partition": "test"}
{"idx": "163", "code": "@SuppressWarnings(\"UnusedDeclaration\") public KeyValuePersistenceSettings(File settingsFile){\n  InputStream in;\n  try {\n    in=new FileInputStream(settingsFile);\n  }\n catch (  IOException e) {\n    throw new IgniteException(\"Failed to get input stream for Cassandra persistence settings file: \" + settingsFile.getAbsolutePath(),e);\n  }\n  init(loadSettings(in));\n}\n", "docstring": "constructs ignite cache key / value persistence settings .", "partition": "test"}
{"idx": "161", "code": "private void handleStateLeft(InetAddress endpoint,String[] pieces){\n  assert pieces.length >= 2;\n  Collection<Token> tokens=getTokensFor(endpoint);\n  if (logger.isDebugEnabled())   logger.debug(\"Node {} state left, tokens {}\",endpoint,tokens);\n  excise(tokens,endpoint,extractExpireTime(pieces));\n}\n", "docstring": "handle node leaving the ring . this will happen when a node is decommissioned", "partition": "test"}
{"idx": "1146", "code": "public static void deleteFileOrLog(File file){\n  if (!file.delete()) {\n    logger.warn(FAILED_DELETING_FILE + file.getPath());\n  }\n}\n", "docstring": "delete a file from the file system or log the failure if unable to delete it .", "partition": "test"}
{"idx": "3768", "code": "public static int poisson(double lambda){\n  int k=0;\n  double p=1.0;\n  double L=Math.exp(-lambda);\n  do {\n    k++;\n    p*=uniform();\n  }\n while (p >= L);\n  return k - 1;\n}\n", "docstring": "return an integer with a poisson distribution with mean lambda .", "partition": "test"}
{"idx": "4158", "code": "public void connect(){\n  connect(this.logWriter);\n}\n", "docstring": "connects to the currently configured system .", "partition": "test"}
{"idx": "622", "code": "public static Object invokeStatic(String clazz,String methodName,Class[] types,Object[] values) throws NoSuchMethodException {\n  try {\n    return invokeStatic(Class.forName(clazz),methodName,types,values);\n  }\n catch (  ClassNotFoundException e) {\n    throw new NoSuchMethodException(\"class \" + clazz + \" not found\");\n  }\n}\n", "docstring": "invokes the specified parameterless method if it exists .", "partition": "test"}
{"idx": "1726", "code": "private void initialize(ModelValidator validator,MClient client){\n  if (client == null)   m_globalValidators.add(validator);\n  m_validators.add(validator);\n  validator.initialize(this,client);\n}\n", "docstring": "initialize and add validator", "partition": "test"}
{"idx": "3806", "code": "@Override public int parse(DateTimeParseContext context,CharSequence text,int position){\n  int length=text.length();\n  if (position > length) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (position == length) {\n    return ~position;\n  }\n  char nextChar=text.charAt(position);\n  if (nextChar == '+' || nextChar == '-') {\n    return parseOffsetBased(context,text,position,position,OffsetIdPrinterParser.INSTANCE_ID_Z);\n  }\n else   if (length >= position + 2) {\n    char nextNextChar=text.charAt(position + 1);\n    if (context.charEquals(nextChar,'U') && context.charEquals(nextNextChar,'T')) {\n      if (length >= position + 3 && context.charEquals(text.charAt(position + 2),'C')) {\n        return parseOffsetBased(context,text,position,position + 3,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n      }\n      return parseOffsetBased(context,text,position,position + 2,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n    }\n else     if (context.charEquals(nextChar,'G') && length >= position + 3 && context.charEquals(nextNextChar,'M') && context.charEquals(text.charAt(position + 2),'T')) {\n      return parseOffsetBased(context,text,position,position + 3,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n    }\n  }\n  PrefixTree tree=getTree(context);\n  ParsePosition ppos=new ParsePosition(position);\n  String parsedZoneId=tree.match(text,ppos);\n  if (parsedZoneId == null) {\n    if (context.charEquals(nextChar,'Z')) {\n      context.setParsed(ZoneOffset.UTC);\n      return position + 1;\n    }\n    return ~position;\n  }\n  context.setParsed(ZoneId.of(parsedZoneId));\n  return ppos.getIndex();\n}\n", "docstring": "this implementation looks for the longest matching string . for example , parsing etc / gmt - 2 will return etc / gmc - 2 rather than just etc / gmc although both are valid .", "partition": "test"}
{"idx": "525", "code": "public Request header(String key,String value){\n  Objects.requireNonNull(key);\n  Objects.requireNonNull(value);\n  _headers.put(key,value);\n  return this;\n}\n", "docstring": "sets a header to use with http request", "partition": "test"}
{"idx": "2586", "code": "public static void removeObjectAtOffset(Object[] sourceArray,Object[] destinationArray,int offset){\n  System.arraycopy(sourceArray,0,destinationArray,0,offset);\n  System.arraycopy(sourceArray,offset + 1,destinationArray,offset,sourceArray.length - offset - 1);\n}\n", "docstring": "removes the object at the source array offset and copies all other objects to the destination array", "partition": "test"}
{"idx": "2515", "code": "public BigInteger generateClientCredentials(byte[] salt,byte[] identity,byte[] password){\n  this.x=SRP6Util.calculateX(digest,N,salt,identity,password);\n  this.a=selectPrivateValue();\n  this.A=g.modPow(a,N);\n  return A;\n}\n", "docstring": "generates client \"'\" s credentials given the client \"'\" s salt , identity and password", "partition": "test"}
{"idx": "3704", "code": "private void connect(){\n  if (!connected) {\n    updateInfo();\n    String connectString=\"tcp://\" + connectAddress + \":\"+ connectPort;\n    if (clientId == null || clientId.length() < 1) {\n      out(getDate() + Messages.MqttClientView_15 + connectString+ Messages.MqttClientView_16);\n      return;\n    }\n    try {\n      if (firstConnect) {\n        mqttClient=new MqttClient(connectString,clientId);\n        mqttClient.setCallback(this);\n        firstConnect=false;\n      }\n    }\n catch (    MqttException e) {\n      out(getDate() + Messages.MqttClientView_17 + e.getMessage());\n      e.printStackTrace();\n    }\n    connOpts=new MqttConnectOptions();\n    connOpts.setCleanSession(cleanStart);\n    connOpts.setConnectionTimeout(30);\n    connOpts.setKeepAliveInterval(keepAlive);\n    if (username.length() > 0 && password.length() > 0) {\n      connOpts.setPassword(password.toCharArray());\n      connOpts.setUserName(username);\n    }\n    if (useWill) {\n      if (willTopic == null || willTopic.equals(\"\")) {\n        out(Messages.MqttClientView_19);\n        return;\n      }\n      connOpts.setWill(mqttClient.getTopic(willTopic),willMessage.getBytes(),willQos,willRetain);\n    }\n    try {\n      out(getDate() + Messages.MqttClientView_20 + connectString);\n      mqttClient.connect(connOpts);\n      connected=true;\n      out(getDate() + Messages.MqttClientView_21 + clientId);\n    }\n catch (    MqttException e) {\n      out(getDate() + Messages.MqttClientView_22 + e.getMessage());\n      e.printStackTrace();\n    }\n  }\n else {\n    out(Messages.MqttClientView_23);\n  }\n}\n", "docstring": "connects to the broker", "partition": "test"}
{"idx": "3320", "code": "protected void putCommand(final Class commandClass,final String[] names){\n  Check.isTrue(names.length > 0,\"names.length > 0\");\n  _commandsToCanonicalNames.put(commandClass,names[0]);\n  for (int i=0; i < names.length; i++) {\n    _aliasesToCommands.put(names[i],commandClass);\n  }\n}\n", "docstring": "add a command in the hash map .", "partition": "test"}
{"idx": "215", "code": "public TaggedValueIterator(final String aLine,final boolean attemptFirstWord,final String... tags){\n  this.aLine=aLine;\n  this.attemptFirstWord=attemptFirstWord;\n  this.tags=tags;\n  tagPos=0;\n  nextResult=getNextResult();\n  if (attemptFirstWord) {\n    int a=0;\n    while (a < aLine.length()) {\n      if (aLine.charAt(a) == '>' || aLine.charAt(a) == '@' || Character.isWhitespace(aLine.charAt(a)))       a++;\n else       break;\n    }\n    int b=a + 1;\n    while (b < aLine.length()) {\n      if (Character.isLetterOrDigit(aLine.charAt(b)) || aLine.charAt(b) == '_')       b++;\n else       break;\n    }\n    if (b - a > 4) {\n      nextResult=aLine.substring(a,b);\n    }\n    tagPos=b;\n  }\n}\n", "docstring": "iterator over all values following an occurrence of tag in aline . example : aline = gi | 4444 | gi | 5555 and tag = gi | with return 4444 and then 5555 value consists of letters , digits or underscore", "partition": "test"}
{"idx": "1349", "code": "private TreeNode(long nodeValue,SnmpMibAgent agent,TreeNode sup){\n  this.nodeValue=nodeValue;\n  this.parent=sup;\n  agents.addElement(agent);\n}\n", "docstring": "only the treenode class can create an instance of treenode . the creation occurs when registering a new oid .", "partition": "test"}
{"idx": "3802", "code": "private void smoothSnapToPosition(int scrollY,int availableScrollHeight,AlphabeticalAppsList.FastScrollSectionInfo info){\n  mRv.removeCallbacks(mSmoothSnapNextFrameRunnable);\n  mRv.removeCallbacks(mFastScrollToTargetSectionRunnable);\n  trackAllChildViews();\n  if (mHasFastScrollTouchSettled) {\n    mCurrentFastScrollSection=info.sectionName;\n    mTargetFastScrollSection=null;\n    updateTrackedViewsFastScrollFocusState();\n  }\n else {\n    mCurrentFastScrollSection=null;\n    mTargetFastScrollSection=info.sectionName;\n    mHasFastScrollTouchSettled=false;\n    updateTrackedViewsFastScrollFocusState();\n    mRv.postDelayed(mFastScrollToTargetSectionRunnable,mHasFastScrollTouchSettledAtLeastOnce ? REPEAT_TOUCH_SETTLING_DURATION : INITIAL_TOUCH_SETTLING_DURATION);\n  }\n  int newScrollY=Math.min(availableScrollHeight,mRv.getPaddingTop() + mRv.getTop(info.fastScrollToItem.rowIndex));\n  int numFrames=mFastScrollFrames.length;\n  for (int i=0; i < numFrames; i++) {\n    mFastScrollFrames[i]=(newScrollY - scrollY) / numFrames;\n  }\n  mFastScrollFrameIndex=0;\n  mRv.postOnAnimation(mSmoothSnapNextFrameRunnable);\n}\n", "docstring": "smoothly snaps to a given position . we do this manually by calculating the keyframes ourselves and animating the scroll on the recycler view .", "partition": "test"}
{"idx": "333", "code": "public void requestSecondsUntilIdleLockout(){\n  operations.add(PasswordPolicyStateOperationType.GET_SECONDS_UNTIL_IDLE_LOCKOUT);\n}\n", "docstring": "returns the seconds until idle lockout .", "partition": "test"}
{"idx": "3197", "code": "private static String convertActionTypeToIntent(RamlActionType actionType,boolean isTargetCollection){\nswitch (actionType) {\ncase DELETE:\n    return \"delete\";\ncase GET:\n  return \"get\";\ncase POST:\nif (isTargetCollection) {\n  return \"create\";\n}\ncase PUT:\nreturn \"update\";\ncase PATCH:\nreturn \"modify\";\ndefault :\nreturn \"do\";\n}\n}\n", "docstring": "attempts to convert the http verb into a textual representation of intent based on rest conventions", "partition": "test"}
{"idx": "3899", "code": "public void waitForOperations(){\n  operator.waitForOperations();\n}\n", "docstring": "wait for the bucket operator to complete any pending asynchronous operations .", "partition": "test"}
{"idx": "1230", "code": "public void loadLogicalTablesWithGranularities(Map<String,TableGroup> nameGroupMap,Set<? extends Granularity> validGrains,ResourceDictionaries dictionaries){\n  for (  Map.Entry<String,TableGroup> entry : nameGroupMap.entrySet()) {\n    String logicalTableName=entry.getKey();\n    TableGroup group=entry.getValue();\n    loadLogicalTableWithGranularities(logicalTableName,group,validGrains,dictionaries);\n  }\n}\n", "docstring": "load several logical tables into the logicaldictionary . < p > note : this builds the logical tables as well .", "partition": "test"}
{"idx": "863", "code": "public boolean disableVMAX3Compression(URI blockObjectURI,StorageSystem storageSystem){\n  VirtualPool virtualPool=null;\n  StoragePool storagePool=null;\n  Volume volume=null;\n  if (URIUtil.isType(blockObjectURI,Volume.class)) {\n    volume=_dbClient.queryObject(Volume.class,blockObjectURI);\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockSnapshot.class)) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,blockObjectURI);\n    volume=_dbClient.queryObject(Volume.class,snapshot.getParent());\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockMirror.class)) {\n    BlockMirror mirror=_dbClient.queryObject(BlockMirror.class,blockObjectURI);\n    virtualPool=_dbClient.queryObject(VirtualPool.class,mirror.getVirtualPool());\n    storagePool=_dbClient.queryObject(StoragePool.class,mirror.getPool());\n  }\n  if (volume != null) {\n    virtualPool=_dbClient.queryObject(VirtualPool.class,volume.getVirtualPool());\n    storagePool=_dbClient.queryObject(StoragePool.class,volume.getPool());\n  }\n  return (checkIfProviderSupportsCompressionOperations(storageSystem) && !virtualPool.getCompressionEnabled() && storagePool.getCompressionEnabled());\n}\n", "docstring": "this method is will check if the storage pool associated with the volume supports compression . if it does support compression , it will check if the associated virtual pool has compression enabled . it will recommend the user to disable compression if the virtual pool has compression disabled and the storage pool enables compression by default .", "partition": "test"}
{"idx": "49", "code": "@Override public DocumentType createDocumentType(String qualifiedName,String publicID,String systemID){\n  checkQName(qualifiedName);\n  return new DocumentTypeImpl(null,qualifiedName,publicID,systemID);\n}\n", "docstring": "introduced in dom level 2 . < p > < p / > creates an empty documenttype node .", "partition": "test"}
{"idx": "308", "code": "public void shutdown(){\n  final long begin=System.currentTimeMillis();\n  log.info(\"ThreadPoolManager: Shutting down.\");\n  log.info(\"\\\\t... executing \" + getTaskCount(scheduledPool) + \" scheduled tasks.\");\n  log.info(\"\\\\t... executing \" + getTaskCount(instantPool) + \" instant tasks.\");\n  log.info(\"\\\\t... executing \" + getTaskCount(longRunningPool) + \" long running tasks.\");\n  log.info(\"\\\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  scheduledPool.shutdown();\n  instantPool.shutdown();\n  longRunningPool.shutdown();\n  workStealingPool.shutdown();\n  boolean success=false;\n  try {\n    success|=awaitTermination(5000);\n    scheduledPool.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    scheduledPool.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    success|=awaitTermination(10000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  log.info(\"\\\\t... success: \" + success + \" in \"+ (System.currentTimeMillis() - begin)+ \" msec.\");\n  log.info(\"\\\\t... \" + getTaskCount(scheduledPool) + \" scheduled tasks left.\");\n  log.info(\"\\\\t... \" + getTaskCount(instantPool) + \" instant tasks left.\");\n  log.info(\"\\\\t... \" + getTaskCount(longRunningPool) + \" long running tasks left.\");\n  log.info(\"\\\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  workStealingPool.shutdownNow();\n}\n", "docstring": "shutdown all thread pools .", "partition": "test"}
{"idx": "1381", "code": "private Component createSeparator(){\n  JSeparator sep=new JSeparator(SwingConstants.VERTICAL);\n  sep.setPreferredSize(new Dimension(2,30));\n  sep.setMinimumSize(new Dimension(2,30));\n  return sep;\n}\n", "docstring": "creates a vertical separator for visually separating status bar elements", "partition": "test"}
{"idx": "324", "code": "protected Workflow.Method createRemoveVolumesFromCGMethod(URI vplexURI,URI cgURI,List<URI> vplexVolumeURIs){\n  return new Workflow.Method(REMOVE_VOLUMES_FROM_CG_STEP,vplexURI,cgURI,vplexVolumeURIs);\n}\n", "docstring": "a method that creates the workflow method for removing vplex volumes from a consistency group .", "partition": "test"}
{"idx": "1120", "code": "public WritableRaster createCompatibleWritableRaster(int w,int h){\n  if (w <= 0 || h <= 0) {\n    throw new RasterFormatException(\"negative \" + ((w <= 0) ? \"width\" : \"height\"));\n  }\n  SampleModel sm=sampleModel.createCompatibleSampleModel(w,h);\n  return new BytePackedRaster(sm,new Point(0,0));\n}\n", "docstring": "creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .", "partition": "test"}
{"idx": "147", "code": "public void onBindHeaderViewHolder(RecyclerView.ViewHolder holder,int position){\n  onBindHeaderViewHolder(holder,position,Collections.emptyList());\n}\n", "docstring": "bind header with provided viewholder at specified position", "partition": "test"}
{"idx": "1451", "code": "public boolean removeOnItemClickListener(OnItemClickListener itemClickListener){\n  return clickListeners.remove(itemClickListener);\n}\n", "docstring": "remove item click listener from this view", "partition": "test"}
{"idx": "621", "code": "public static Vector2 pow(Vector2 o,double power){\n  return new Vector2(Math.pow(o.x,power),Math.pow(o.z,power));\n}\n", "docstring": "raises the x and y values of a vector2 to the given power .", "partition": "test"}
{"idx": "564", "code": "public static double distancePointLinePerpendicular(Coordinate p,Coordinate A,Coordinate B){\n  double len2=(B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  double s=((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2);\n}\n", "docstring": "computes the perpendicular distance from a point p to the ( infinite ) line containing the points ab", "partition": "test"}
{"idx": "2785", "code": "@Override public boolean batchFinished(){\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  Instances toFilter=getInputFormat();\n  int cutOff=(int)Math.round(toFilter.numInstances() * m_Percentage / 100);\n  if (m_Inverse) {\n    for (int i=0; i < cutOff; i++) {\n      push(toFilter.instance(i));\n    }\n  }\n else {\n    for (int i=cutOff; i < toFilter.numInstances(); i++) {\n      push(toFilter.instance(i));\n    }\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}\n", "docstring": "signify that this batch of input to the filter is finished . output ( ) may now be called to retrieve the filtered instances .", "partition": "test"}
{"idx": "601", "code": "public static boolean isModule(IResource resource){\n  return (resource != null && TLA_EXTENSION.equals(resource.getFileExtension()));\n}\n", "docstring": "determines if the given member is a tla + module", "partition": "test"}
{"idx": "3545", "code": "public Timestamp recalculateEstimatedCompletionDate(Long priority,Timestamp startDate){\n  if (exist()) {\n    getProductionRunRoutingTasks();\n    if (quantity == null)     getQuantity();\n    Timestamp endDate=null;\n    for (Iterator<GenericValue> iter=productionRunRoutingTasks.iterator(); iter.hasNext(); ) {\n      GenericValue routingTask=iter.next();\n      if (priority.compareTo(routingTask.getLong(\"priority\")) <= 0) {\n        long totalTime=ProductionRun.getEstimatedTaskTime(routingTask,quantity,dispatcher);\n        endDate=TechDataServices.addForward(TechDataServices.getTechDataCalendar(routingTask),startDate,totalTime);\n        routingTask.set(\"estimatedStartDate\",startDate);\n        routingTask.set(\"estimatedCompletionDate\",endDate);\n        startDate=endDate;\n      }\n    }\n    return endDate;\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "recalculated the estimatedcompletiondate property . use the quantity and the estimatedstartdate properties as entries parameters . < br / > read the listroutingtask and for each recalculated and update the estimatedstart and enddate in the object . < br / > no store in the database is done .", "partition": "test"}
{"idx": "1467", "code": "private void forceOverflow(){\n  forceOverflow();\n}\n", "docstring": "gratuitous and stupid recursion", "partition": "test"}
{"idx": "1514", "code": "public static Uri addMessage(ContentResolver resolver,String address,String body,String subject,Long date,boolean deliveryReport,long threadId){\n  final Uri CONTENT_URI=Uri.parse(\"content://sms/outbox\");\n  return addMessageToUri(resolver,CONTENT_URI,address,body,subject,date,true,deliveryReport,threadId);\n}\n", "docstring": "add an sms to the out box .", "partition": "test"}
{"idx": "1731", "code": "@SafeVarargs public final Token<TokenType> expect(TokenType... expected) throws SimpleParserException {\n  if (hasType(expected))   return this;\n  throw new SimpleParserException(line,column,\"Expected \" + Arrays.toString(expected) + \", but got \"+ toString());\n}\n", "docstring": "ensures that this token has one of the given expected types .", "partition": "test"}
{"idx": "3841", "code": "@SuppressWarnings(\"unchecked\") public void readFile(String fileName) throws JDOMException, IOException {\n  if (checkFile(fileName)) {\n    Element root=rootFromName(fileName);\n    Element roster;\n    if (root == null) {\n      log.warn(\"consist file could not be read\");\n      return;\n    }\n    roster=root.getChild(\"roster\");\n    if (roster == null) {\n      log.debug(\"consist file does not contain a roster entry\");\n      return;\n    }\n    Iterator<Element> consistIterator=root.getDescendants(new ElementFilter(\"consist\"));\n    try {\n      Element consist;\n      do {\n        consist=consistIterator.next();\n        consistFromXml(consist);\n      }\n while (consistIterator.hasNext());\n    }\n catch (    NoSuchElementException nde) {\n      log.debug(\"end of consist list\");\n    }\n  }\n else {\n    log.info(\"Consist file does not exist.  One will be created if necessary.\");\n  }\n}\n", "docstring": "read all consists from a file .", "partition": "test"}
{"idx": "2864", "code": "public void put(Song song){\n  if (!mSongs.contains(song)) {\n    mSongs.add(song);\n  }\n}\n", "docstring": "adds a song to the adapter", "partition": "test"}
{"idx": "1456", "code": "public void write(PrintStream out){\n  write(out,table);\n}\n", "docstring": "writes the algorithm \"'\" s internal representation as text .", "partition": "test"}
{"idx": "1360", "code": "private void fixSpannedWithSpaces(SpannableStringBuilder builder,int widthMeasureSpec,int heightMeasureSpec){\n  long startFix=System.currentTimeMillis();\n  FixingResult result=addSpacesAroundSpansUntilFixed(builder,widthMeasureSpec,heightMeasureSpec);\n  if (result.fixed) {\n    removeUnneededSpaces(widthMeasureSpec,heightMeasureSpec,builder,result);\n  }\n else {\n    fallbackToString(widthMeasureSpec,heightMeasureSpec);\n  }\n  long fixDuration=System.currentTimeMillis() - startFix;\n  Logger.d(TAG,\"fixSpannedWithSpaces() duration in ms: \" + fixDuration);\n}\n", "docstring": "add spaces around spans until the text is fixed , and then removes the unneeded spaces", "partition": "test"}
{"idx": "2545", "code": "@Override public LogMessage readNextLogMessage(){\n  try {\n    if (reader == null) {\n      return null;\n    }\n    while (true) {\n      String line=reader.readLine();\n      if (line == null) {\n        close();\n        if (currentLog != null && matchRegex(currentLog)) {\n          incrementLogCount(currentLog);\n          return currentLog;\n        }\n        return null;\n      }\n      fileLineNumber++;\n      LogMessage nextLog=null;\n      if (parser != null) {\n        nextLog=parser.parseLine(line,request);\n      }\n else {\n        for (        LogParser parser : parserTable) {\n          nextLog=parser.parseLine(line,request);\n          if (!nextLog.isContinuation()) {\n            this.parser=parser;\n            break;\n          }\n        }\n        if (nextLog == null || nextLog.isContinuation()) {\n          status.appendInfo(this.filePath,fileLineNumber);\n          continue;\n        }\n      }\n      if (nextLog.isContinuation()) {\n        if (currentLog != null) {\n          currentLog.appendMessage(LogUtil.stringToBytes(line));\n        }\n      }\n else       if (nextLog.isRejected()) {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=null;\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n      }\n else       if (nextLog.isRejectedLast()) {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=null;\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n        break;\n      }\n else {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=nextLog;\n          if (returnedLog.isHeader() && currentLog.isHeader()) {\n            continue;\n          }\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n else {\n          currentLog=nextLog;\n        }\n      }\n    }\n  }\n catch (  IOException e) {\n    status.appendErrFileName(filePath);\n  }\n  return null;\n}\n", "docstring": "read one log message from log file", "partition": "test"}
{"idx": "2897", "code": "@Override public double calculateM(double delta,double epsilon){\n  double i=1;\n  while (conf(i,delta) > epsilon / 2.0d) {\n    i=i + 10000;\n  }\n  if (i > 1) {\n    i=i - 10000;\n  }\n  while (conf(i,delta) > (epsilon / 2.0d)) {\n    i++;\n  }\n  return Math.ceil(i);\n}\n", "docstring": "calculates the m - value needed for the gss algorithm .", "partition": "test"}
{"idx": "1973", "code": "public static void close(@CheckForNull OutputStream outputStream){\n  if (outputStream == null) {\n    return;\n  }\n  try {\n    outputStream.close();\n  }\n catch (  IOException e) {\n  }\n}\n", "docstring": "close given outputstream , ignoring any resulting exception .", "partition": "test"}
{"idx": "809", "code": "public boolean sendViaDataSocket(byte[] bytes,int start,int len){\n  if (dataOutputStream == null) {\n    Log.i(TAG,\"Can\\'t send via null dataOutputStream\");\n    return false;\n  }\n  if (len == 0) {\n    return true;\n  }\n  try {\n    dataOutputStream.write(bytes,start,len);\n  }\n catch (  IOException e) {\n    Log.i(TAG,\"Couldn\\'t write output stream for data socket\");\n    Log.i(TAG,e.toString());\n    return false;\n  }\n  localDataSocket.reportTraffic(len);\n  return true;\n}\n", "docstring": "sends a byte array over the already - established data socket", "partition": "test"}
{"idx": "189", "code": "public void testNegPosFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=1;\n  byte rBytes[]={0,-128,9,56,100,0,0,1,1,90,1,-32,0,10,-126,21,82,-31,-95};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.and(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "and for a negative and a positive numbers ; the first is shorter", "partition": "test"}
{"idx": "3295", "code": "@Override public abstract List<JToolBar> createToolBars(Application a,@Nullable View p);\n", "docstring": "creates toolbars for the application .", "partition": "test"}
{"idx": "2561", "code": "public final ObjectProperty<Control> toggleNodeProperty(){\n  return this.toggleNode;\n}\n", "docstring": "* public properties *", "partition": "test"}
{"idx": "2845", "code": "private static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManagerInterface manager){\n  long now=System.currentTimeMillis();\n  long ancient=now - DateUtils.DAY_IN_MILLIS;\n  String[] projection=new String[]{CalendarContract.CalendarAlerts.ALARM_TIME};\n  if (Build.VERSION.SDK_INT >= 23 && ContextCompat.checkSelfPermission(context,Manifest.permission.READ_CALENDAR) != PackageManager.PERMISSION_GRANTED) {\n    Log.d(TAG,\"Manifest.permission.READ_CALENDAR is not granted\");\n    return;\n  }\n  Cursor cursor=cr.query(CalendarAlerts.CONTENT_URI,projection,WHERE_RESCHEDULE_MISSED_ALARMS,(new String[]{Long.toString(now),Long.toString(ancient),Long.toString(now)}),SORT_ORDER_ALARMTIME_ASC);\n  if (cursor == null) {\n    return;\n  }\n  if (DEBUG) {\n    Log.d(TAG,\"missed alarms found: \" + cursor.getCount());\n  }\n  try {\n    long alarmTime=-1;\n    while (cursor.moveToNext()) {\n      long newAlarmTime=cursor.getLong(0);\n      if (alarmTime != newAlarmTime) {\n        if (DEBUG) {\n          Log.w(TAG,\"rescheduling missed alarm. alarmTime: \" + newAlarmTime);\n        }\n        AlertUtils.scheduleAlarm(context,manager,newAlarmTime);\n        alarmTime=newAlarmTime;\n      }\n    }\n  }\n  finally {\n    cursor.close();\n  }\n}\n", "docstring": "searches the calendaralerts table for alarms that should have fired but have not and then reschedules them . this method can be called at boot time to restore alarms that may have been lost due to a phone reboot .", "partition": "test"}
{"idx": "2014", "code": "public void clientDisconnect(){\n  try {\n    OutHttpApp responseStream=_responseStream;\n    if (responseStream != null) {\n      responseStream.close();\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.FINER,e.toString(),e);\n  }\n  ConnectionTcp conn=connTcp();\n  if (conn != null) {\n    conn.clientDisconnect();\n  }\n  killKeepalive(\"client disconnect\");\n}\n", "docstring": "called when the client has disconnected", "partition": "test"}
{"idx": "1938", "code": "private ResolvedMigration createAvailableMigration(int version){\n  ResolvedMigration migration=new ResolvedMigration();\n  migration.setVersion(MigrationVersion.fromVersion(Integer.toString(version)));\n  migration.setDescription(\"abc\");\n  migration.setScript(\"x\");\n  migration.setType(MigrationType.CQL);\n  return migration;\n}\n", "docstring": "creates a new available migration with this version .", "partition": "test"}
{"idx": "1614", "code": "protected static double calcQ_i(double f,double lambda){\n  return lambda * Math.exp(-lambda * f);\n}\n", "docstring": "compute q_i ( exponential distribution , inliers )", "partition": "test"}
{"idx": "3473", "code": "public static void process(List<Packages> pkgList) throws Exception {\n  init();\n  String[] temps=templates.split(\",\");\n  String[] vmFiles=new String[temps.length];\n  for (int i=0; i < temps.length; i++) {\n    vmFiles[i]=temps[i] + \".vm\";\n  }\n  for (  Packages pkg : pkgList) {\n    for (    String vmFile : vmFiles) {\n      generator(vmFile,pkg);\n    }\n  }\n}\n", "docstring": "process main logic for create file", "partition": "test"}
{"idx": "2419", "code": "private String convertLessThanOneThousand(int number){\n  String soFar;\n  if (number % 100 < 20) {\n    soFar=numNames[number % 100];\n    number/=100;\n  }\n else {\n    soFar=numNames[number % 10];\n    number/=10;\n    String s=Integer.toString(number);\n    if (s.endsWith(\"2\") && !soFar.equals(\"\"))     soFar=\" VINT-I-\" + soFar.trim();\n else     if (soFar.equals(\"\"))     soFar=tensNames[number % 10] + soFar;\n else     soFar=tensNames[number % 10] + \"-\" + soFar;\n    number/=10;\n  }\n  if (number == 0)   return tensNames[number % 10] + soFar;\n  if (number > 1)   soFar=\"S\" + soFar;\n  if (number == 1 && !soFar.equals(\"\"))   number=0;\n  return numNames[number] + \" CENT\" + soFar;\n}\n", "docstring": "convert less than one thousand", "partition": "test"}
{"idx": "1309", "code": "protected static boolean networkMonitorExist(String nwMonName){\n  String classMethod=\"OpenSSOMonitoringUtil.networkMonitorExist: \";\n  if (debug.messageEnabled()) {\n    debug.message(classMethod + \"checking \" + nwMonName);\n  }\n  if ((nwMonName == null) || (nwMonName.length() == 0)) {\n    if (debug.warningEnabled()) {\n      debug.warning(classMethod + \"isNull\");\n    }\n    return false;\n  }\n  Set<String> ntwStats=NetworkMonitor.getInstanceNames();\n  String ss=nwMonName.toLowerCase();\n  if (ntwStats.contains(ss)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "return whether the specified network monitor has been instantiated in the entitlements service yet", "partition": "test"}
{"idx": "3599", "code": "public void createBounds(){\n  if (isEmpty() || hasSingleElement()) {\n    mBounds=null;\n    return;\n  }\n  int l=Integer.MAX_VALUE;\n  int t=Integer.MAX_VALUE;\n  int r=0;\n  int b=0;\n  for (  Selection.Element selection : getElements()) {\n    ConstraintWidget w=selection.widget;\n    l=Math.min(w.getDrawX(),l);\n    t=Math.min(w.getDrawY(),t);\n    r=Math.max(w.getDrawRight(),r);\n    b=Math.max(w.getDrawBottom(),b);\n  }\n  ConstraintWidget bounds=new ConstraintWidget(l,t,r - l,b - t);\n  bounds.setCompanionWidget(WidgetCompanion.create(bounds));\n  mBounds=new Element(bounds);\n  updateOriginFromBounds();\n}\n", "docstring": "if the selection has more than one element , it will create a temporary element object as the bounds of the entire selection . we then use this bounds object to snap the full selection on screen .", "partition": "test"}
{"idx": "675", "code": "public void processInvite(RequestEvent requestEvent,ServerTransaction serverTransaction){\n  final Request request=requestEvent.getRequest();\n  final SipProvider sipProvider=(SipProvider)requestEvent.getSource();\n  ServerTransaction st=serverTransaction;\n  try {\n    if (st == null) {\n      try {\n        st=sipProvider.getNewServerTransaction(request);\n      }\n catch (      TransactionUnavailableException tae) {\n        tae.printStackTrace();\n        return;\n      }\ncatch (      TransactionAlreadyExistsException taex) {\n        return;\n      }\n    }\n    final String toTag=\"\" + System.nanoTime();\n    Response response=messageFactory.createResponse(Response.RINGING,request);\n    ToHeader toHeader=(ToHeader)response.getHeader(ToHeader.NAME);\n    toHeader.setTag(toTag);\n    st.sendResponse(response);\n    response=messageFactory.createResponse(Response.OK,request);\n    final Address address=addressFactory.createAddress(\"Shootme <sip:\" + myAddress + \":\"+ myPort+ \">\");\n    final ContactHeader contactHeader=headerFactory.createContactHeader(address);\n    response.addHeader(contactHeader);\n    toHeader=(ToHeader)response.getHeader(ToHeader.NAME);\n    toHeader.setTag(toTag);\n    st.sendResponse(response);\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}\n", "docstring": "process the invite request .", "partition": "test"}
{"idx": "3479", "code": "public static boolean isNetworkAvailable(Context context){\n  ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo info=connectivityManager.getActiveNetworkInfo();\n  return info != null && info.isConnected();\n}\n", "docstring": "returns network availability status .", "partition": "test"}
{"idx": "1105", "code": "public static List<List<Double>> partitionVariable(List<Double> arr,int chunk){\n  int count=0;\n  List<List<Double>> ret=new ArrayList<List<Double>>();\n  while (count < arr.size()) {\n    List<Double> sublist=arr.subList(count,count + chunk);\n    count+=chunk;\n    ret.add(sublist);\n  }\n  for (  List<Double> lists : ret) {\n    if (lists.size() < chunk)     ret.remove(lists);\n  }\n  return ret;\n}\n", "docstring": "this will partition the given whole variable data applytransformtodestination in to the specified chunk number .", "partition": "test"}
{"idx": "2386", "code": "public Rect updateFastScrollerBounds(BaseRecyclerView rv,int lastTouchY){\n  mInvalidateRect.set(mBgBounds);\n  if (isVisible()) {\n    int edgePadding=rv.getMaxScrollbarWidth();\n    int bgPadding=(mBgOriginalSize - mTextBounds.height()) / 2;\n    int bgHeight=mBgOriginalSize;\n    int bgWidth=Math.max(mBgOriginalSize,mTextBounds.width() + (2 * bgPadding));\n    if (Utilities.isRtl(mRes)) {\n      mBgBounds.left=rv.getBackgroundPadding().left + (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.right=mBgBounds.left + bgWidth;\n    }\n else {\n      mBgBounds.right=rv.getWidth() - rv.getBackgroundPadding().right - (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.left=mBgBounds.right - bgWidth;\n    }\n    mBgBounds.top=lastTouchY - (int)(FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR * bgHeight);\n    mBgBounds.top=Math.max(edgePadding,Math.min(mBgBounds.top,rv.getHeight() - edgePadding - bgHeight));\n    mBgBounds.bottom=mBgBounds.top + bgHeight;\n  }\n else {\n    mBgBounds.setEmpty();\n  }\n  mInvalidateRect.union(mBgBounds);\n  return mInvalidateRect;\n}\n", "docstring": "updates the bounds for the fast scroller .", "partition": "test"}
{"idx": "614", "code": "public int findCarByRoadNumber(String roadNumber){\n  if (sysList != null) {\n    if (!roadNumber.equals(_roadNumber)) {\n      return getIndex(0,roadNumber);\n    }\n    int index=getIndex(_index,roadNumber);\n    if (index > 0) {\n      return index;\n    }\n    return getIndex(0,roadNumber);\n  }\n  return -1;\n}\n", "docstring": "search for car by road number", "partition": "test"}
{"idx": "4270", "code": "public static Object unserialize(Data data){\n  try {\n    Class clazz=(Class)Class.forName((String)data.get(\"class\"));\n    if (clazz.isEnum()) {\n      return Enum.valueOf(clazz,data.get(\"value\"));\n    }\n else     if (clazz == Vector3D.class) {\n      return new Vector3D(data.get(\"x\"),data.get(\"y\"),data.get(\"z\"));\n    }\n else     if (clazz == Vector2D.class) {\n      return new Vector2D(data.get(\"x\"),(double)data.get(\"y\"));\n    }\n else {\n      return unserialize(clazz,data);\n    }\n  }\n catch (  Exception e) {\n    throw new DataException(e);\n  }\n}\n", "docstring": "loads an object from its stored data , with an unknown class . the class of the object must be stored within the data .", "partition": "test"}
{"idx": "595", "code": "public static void showErrorMessage(String msg){\n  showErrorMessage(msg,3500);\n}\n", "docstring": "simplifies a common use case of showing an error message with an error icon that fades out after a few seconds", "partition": "test"}
{"idx": "3817", "code": "private String generateZonesetCloneName(String zonesetToClone){\n  try {\n    Thread.sleep(1000);\n  }\n catch (  InterruptedException ex) {\n    _log.warn(ex.getLocalizedMessage());\n  }\n  Calendar cal=Calendar.getInstance();\n  DateFormat dateFormat=new SimpleDateFormat(\"MMddyy-HHmmss\");\n  String dateString=dateFormat.format(cal.getTime());\n  String longName=MDSDialogProperties.getString(\"MDSDialog.zonesetCloneLongName.cmd\");\n  if (!longName.contains(\"!MDSDialog.zonesetCloneLongName.cmd!\")) {\n    return longName;\n  }\n  return \"ViPR-\" + zonesetToClone + \"-\"+ dateString;\n}\n", "docstring": "generate a unique name for the zoneset clone . the format of the zoneset clone name is \" vipr - < existing_zone > - mmddyy - hhmmss \" mmddyy and hhmmss refer to the date and the time - stamp that will help identify when the clone was taken .", "partition": "test"}
{"idx": "2755", "code": "private void printBootstrapMap(){\n  LOG.info(\"Bootstrap map:\");\n  for (  Integer i : chainMap.keySet()) {\n    LOG.info(String.format(\"  %6d: %d\",i,chainMap.get(i)));\n  }\n}\n", "docstring": "just a small method to show how many times each activity chain index was sampled . thie method is only needed during the development phase .", "partition": "test"}
{"idx": "1679", "code": "protected boolean removeTurntable(LayoutTurntable o){\n  if (!noWarnTurntable) {\n    int selectedValue=JOptionPane.showOptionDialog(this,rb.getString(\"Question4r\"),Bundle.getMessage(\"WarningTitle\"),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,new Object[]{Bundle.getMessage(\"ButtonYes\"),Bundle.getMessage(\"ButtonNo\"),rb.getString(\"ButtonYesPlus\")},Bundle.getMessage(\"ButtonNo\"));\n    if (selectedValue == 1) {\n      return (false);\n    }\n    if (selectedValue == 2) {\n      noWarnTurntable=true;\n    }\n  }\n  if (selectedObject == o) {\n    selectedObject=null;\n  }\n  if (prevSelectedObject == o) {\n    prevSelectedObject=null;\n  }\n  for (int j=0; j < o.getNumberRays(); j++) {\n    TrackSegment t=o.getRayConnectOrdered(j);\n    if (t != null) {\n      substituteAnchor(o.getRayCoordsIndexed(j),o,t);\n    }\n  }\n  for (int i=0; i < turntableList.size(); i++) {\n    LayoutTurntable lx=turntableList.get(i);\n    if (lx == o) {\n      turntableList.remove(i);\n      o.remove();\n      setDirty(true);\n      repaint();\n      return (true);\n    }\n  }\n  return (false);\n}\n", "docstring": "remove a layout turntable", "partition": "test"}
{"idx": "862", "code": "private boolean loadUnpackedUMD(String filename) throws IOException, GeneralJpcspException {\n  if (doUmdBuffering) {\n    return false;\n  }\n  File file=new File(filename);\n  if (file.exists()) {\n    RandomAccessFile raf=new RandomAccessFile(file,\"r\");\n    FileChannel roChannel=raf.getChannel();\n    ByteBuffer readbuffer=roChannel.map(FileChannel.MapMode.READ_ONLY,0,(int)roChannel.size());\n    emulator.load(\"disc0:/PSP_GAME/SYSDIR/EBOOT.BIN\",readbuffer);\n    raf.close();\n    log.info(\"Using unpacked UMD EBOOT.BIN image\");\n    return true;\n  }\n  return false;\n}\n", "docstring": "don \"'\" t call this directly , see loadumd ( file file )", "partition": "test"}
{"idx": "999", "code": "private List<Pair<String,Object>> toPairList(final Map<String,Object> bindings){\n  final List<Pair<String,Object>> blist=new ArrayList<Pair<String,Object>>();\n  for (  final Map.Entry<String,Object> pair : bindings.entrySet()) {\n    blist.add(new Pair<String,Object>(pair.getKey(),pair.getValue()));\n  }\n  return blist;\n}\n", "docstring": "converts a hash map of bindings to a list of binding pairs .", "partition": "test"}
{"idx": "94", "code": "private String liveness(){\n  boolean isClosed=false;\n  try {\n    if (isClosed()) {\n      isClosed=true;\n    }\n  }\n catch (  SQLException s) {\n    isClosed=true;\n  }\n  if (isClosed) {\n    return \"CLOSED\";\n  }\n  return \"OPEN\";\n}\n", "docstring": "provides a string representation of whether this connection is closed or not", "partition": "test"}
{"idx": "661", "code": "@Override public boolean isCellEditable(int row,int column){\n  EnvVar envVar=dataList.get(row);\n  if (column == COL_VALUE) {\n    return true;\n  }\n  return !envVar.isPredefined();\n}\n", "docstring": "checks if is cell editable .", "partition": "test"}
{"idx": "1985", "code": "public static String addAlpha(String originalColor,double alpha){\n  long alphaFixed=Math.round(alpha * 255);\n  String alphaHex=Long.toHexString(alphaFixed);\n  if (alphaHex.length() == 1) {\n    alphaHex=\"0\" + alphaHex;\n  }\n  originalColor=originalColor.replace(\"#\",\"#\" + alphaHex);\n  return originalColor;\n}\n", "docstring": "adds alpha to a hex color", "partition": "test"}
{"idx": "3639", "code": "public static boolean areIdentical(String playerIdent,OfflinePlayer compareTo){\n  return playerIdent.equals(getIdentificationForAsString(compareTo));\n}\n", "docstring": "returns whether a given ident matches that of another offline player", "partition": "test"}
{"idx": "3822", "code": "public boolean send(byte[] bytes){\n  if (!connected)   return false;\n  try {\n    outputStream.write(bytes);\n    outputStream.flush();\n    return true;\n  }\n catch (  IOException e) {\n    connected=false;\n    Log.e(TAG,\"Fail to send data\");\n    return false;\n  }\n finally {\n    if (!connected) {\n      closeConnection();\n    }\n  }\n}\n", "docstring": "send array of bytes to bluetooth output stream .", "partition": "test"}
{"idx": "665", "code": "private boolean validateCustomCatalog(String title,String value){\n  return false;\n}\n", "docstring": "check a field that defines a custom catalog", "partition": "test"}
{"idx": "2950", "code": "public static void compute(double minScore,double topPercent,double maxExpected,float minPercentIdentity,IReadBlock readBlock,String classificationName,BitSet activeMatchesForClassification){\n  activeMatchesForClassification.clear();\n  for (int i=0; i < readBlock.getNumberOfAvailableMatchBlocks(); i++) {\n    final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n    if (!matchBlock.isIgnore() && matchBlock.getBitScore() >= minScore && matchBlock.getExpected() <= maxExpected && matchBlock.getPercentIdentity() >= minPercentIdentity) {\n      if (matchBlock.getId(classificationName) > 0)       activeMatchesForClassification.set(i);\n    }\n  }\n  float bestScore=0;\n  for (int i=activeMatchesForClassification.nextSetBit(0); i != -1; i=activeMatchesForClassification.nextSetBit(i + 1)) {\n    final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n    float score=matchBlock.getBitScore();\n    if (score > bestScore)     bestScore=score;\n  }\n  applyTopPercentFilter(topPercent,bestScore,minPercentIdentity,readBlock,activeMatchesForClassification);\n}\n", "docstring": "get the set of matches active for the given read", "partition": "test"}
{"idx": "868", "code": "void removeRipple(Ripple ripple){\n  final Ripple[] ripples=mExitingRipples;\n  final int count=mExitingRipplesCount;\n  final int index=getRippleIndex(ripple);\n  if (index >= 0) {\n    System.arraycopy(ripples,index + 1,ripples,index,count - (index + 1));\n    ripples[count - 1]=null;\n    mExitingRipplesCount--;\n    invalidateSelf();\n  }\n}\n", "docstring": "removes a ripple from the exiting ripple list .", "partition": "test"}
{"idx": "806", "code": "public void addHttpSessionToken(String site,String token){\n  if (!site.contains(\":\")) {\n    site=site + (\":80\");\n  }\n  HttpSessionTokensSet siteTokens=sessionTokens.get(site);\n  if (siteTokens == null) {\n    siteTokens=new HttpSessionTokensSet();\n    sessionTokens.put(site,siteTokens);\n  }\n  log.info(\"Added new session token for site \\'\" + site + \"\\': \"+ token);\n  siteTokens.addToken(token);\n  unmarkRemovedDefaultSessionToken(site,token);\n}\n", "docstring": "adds a new session token for a particular site .", "partition": "test"}
{"idx": "376", "code": "private void saveInitialChildState(FacesContext facesContext,UIComponent component){\n  if (component instanceof EditableValueHolder && !component.isTransient()) {\n    String clientId=component.getClientId(facesContext);\n    SavedState state=new SavedState();\n    initialChildState.put(clientId,state);\n    state.populate((EditableValueHolder)component);\n  }\n  Iterator<UIComponent> iterator=component.getFacetsAndChildren();\n  while (iterator.hasNext()) {\n    saveChildState(facesContext,iterator.next());\n  }\n}\n", "docstring": "recursively create the initial state for the given component .", "partition": "test"}
{"idx": "3334", "code": "protected void onPageScrolled(int position,float offset,int offsetPixels){\n  if (mDecorChildCount > 0) {\n    final int scrollY=getScrollY();\n    int paddingTop=getPaddingTop();\n    int paddingBottom=getPaddingBottom();\n    final int height=getHeight();\n    final int childCount=getChildCount();\n    for (int i=0; i < childCount; i++) {\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      if (!lp.isDecor)       continue;\n      final int vgrav=lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;\n      int childTop=0;\nswitch (vgrav) {\ndefault :\n        childTop=paddingTop;\n      break;\ncase Gravity.TOP:\n    childTop=paddingTop;\n  paddingTop+=child.getHeight();\nbreak;\ncase Gravity.CENTER_VERTICAL:\nchildTop=Math.max((height - child.getMeasuredHeight()) / 2,paddingTop);\nbreak;\ncase Gravity.BOTTOM:\nchildTop=height - paddingBottom - child.getMeasuredHeight();\npaddingBottom+=child.getMeasuredHeight();\nbreak;\n}\nchildTop+=scrollY;\nfinal int childOffset=childTop - child.getTop();\nif (childOffset != 0) {\nchild.offsetTopAndBottom(childOffset);\n}\n}\n}\ndispatchOnPageScrolled(position,offset,offsetPixels);\nif (mPageTransformer != null) {\nfinal int scrollY=getScrollY();\nfinal int childCount=getChildCount();\nfor (int i=0; i < childCount; i++) {\nfinal View child=getChildAt(i);\nfinal LayoutParams lp=(LayoutParams)child.getLayoutParams();\nif (lp.isDecor) continue;\nfinal float transformPos=(float)(child.getTop() - scrollY) / getClientHeight();\nmPageTransformer.transformPage(child,transformPos);\n}\n}\nmCalledSuper=true;\n}\n", "docstring": "this method will be invoked when the current page is scrolled , either as part of a programmatically initiated smooth scroll or a user initiated touch scroll . if you override this method you must call through to the superclass implementation ( e . g . super . onpagescrolled ( position , offset , offsetpixels ) ) before onpagescrolled returns .", "partition": "test"}
{"idx": "3225", "code": "public SiteMonitor(String[] urlList){\n  siteUrlList=urlList;\n}\n", "docstring": "constructs a webtopnaming $ sitemonitor object with the provided site urls .", "partition": "test"}
{"idx": "1012", "code": "void postMessage(List<JetstreamMessage> msgs,DispatchQueueStats stats) throws MessageServiceException {\n  m_msgRcvCounter.addAndGet(msgs.size());\n  if ((monitorUpstreamQueueAndPauseTraffic() == UpstreamQueueState.FULL) && (m_paused.get())) {\n    if (!m_msgProcessor.hasAvailableCapacity(m_twentyPercentCapacity)) {\n      m_totalMsgsDropped.increment();\n      return;\n    }\n  }\n  List<Runnable> requests=new ArrayList<Runnable>(msgs.size());\n  for (int i=0, t=msgs.size(); i < t; i++) {\n    JetstreamMessage tm=msgs.get(i);\n    if (tm.getTopic() == null) {\n      m_totalMsgsDropped.increment();\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"Topic is not present in incoming message\");\n      }\n      continue;\n    }\n    MessageServiceRequest msr=new MessageServiceRequest(tm);\n    msr.setPriority(tm.getPriority());\n    msr.setSequenceid(tm.getSequenceId());\n    if (msr.getPriority() == JetstreamMessage.INTERNAL_MSG_PRIORITY) {\n      if (!m_internalMsgProcessor.processRequest(msr)) {\n        m_totalMsgsDropped.increment();\n        throw new MessageServiceException(MessageServiceException.BUFFER_FULL,\"Dispatch Queue Full\");\n      }\n      if (m_msgsRcvdPerSec.addAndGet(1) < 0)       m_msgsRcvdPerSec.set(0);\n      m_totalMsgsRcvd.increment();\n    }\n else {\n      requests.add(msr);\n    }\n  }\n  if (!requests.isEmpty()) {\n    int batchsize=requests.size();\n    if (!m_msgProcessor.processBatch(requests)) {\n      m_totalMsgsDropped.addAndGet(batchsize);\n      throw new MessageServiceException(MessageServiceException.BUFFER_FULL,\"High Priority Dispatch Queue Full - \" + \" Requested capacity = \" + batchsize + \" : available capacity = \"+ m_msgProcessor.getAvailableCapacity());\n    }\n    m_avgMsgsRcvdPerSec.add(batchsize);\n    m_totalMsgsRcvd.addAndGet(batchsize);\n  }\n  if (stats != null) {\n    stats.setHighPriorityQueueDepth((int)m_msgProcessor.getPendingRequests());\n    stats.setLowPriorityQueueDepth((int)m_msgProcessor.getPendingRequests());\n    stats.setMaxQueueDepth((int)m_msgProcessor.getMaxQueueSz());\n  }\n}\n", "docstring": "post a batch of messages .", "partition": "test"}
{"idx": "3616", "code": "protected void paintRangeRings(Point2D originPnt,Point2D dest,Graphics graphics,MapBean theMap){\n  Geo originGeo=new Geo(originPnt.getY(),originPnt.getX(),true);\n  Geo destGeo=new Geo(dest.getY(),dest.getX(),true);\n  double distance=originGeo.distance(destGeo);\n  for (int i=1; i <= Math.max(1,numRings); i++) {\n    double ringDist=distance * (double)i;\n    paintCircle(originGeo,ringDist,graphics,theMap);\n    paintLabel(originGeo,ringDist,graphics,theMap);\n  }\n}\n", "docstring": "paints the circles and their labels on the given graphics .", "partition": "test"}
{"idx": "3463", "code": "public final void wait() throws java.lang.InterruptedException {\n  wait(0);\n}\n", "docstring": "causes current thread to wait until another thread invokes the method or the method for this object . in other word \"'\" s this method behaves exactly as if it simply performs the call wait ( 0 ) . the current thread must own this object \"'\" s monitor . the thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object \"'\" s monitor to wake up either through a call to the notify method or the notifyall method . the thread then waits until it can re - obtain ownership of the monitor and resumes execution . this method should only be called by a thread that is the owner of this object \"'\" s monitor . see the notify method for a description of the ways in which a thread can become the owner of a monitor .", "partition": "test"}
{"idx": "1156", "code": "void copyNodeStructure(ArrayList<Node> destination){\n  while (destination.size() < nodes.size())   destination.add(new Node());\n  while (destination.size() > nodes.size())   destination.remove(0);\n  int n=nodes.size();\n  for (int i=0; i < n; i++) {\n    Node node0=nodes.get(i);\n    Node node1=destination.get(i);\n    node1.heightParameter=node0.heightParameter;\n    node1.rateParameter=node0.rateParameter;\n    node1.traitParameter=node0.traitParameter;\n    node1.partitioning=node0.partitioning;\n    node1.taxon=node0.taxon;\n    node1.bifurcation=node0.bifurcation;\n    node1.number=node0.number;\n    node1.myHashCode=node0.myHashCode;\n    if (node0.leftParent != null) {\n      node1.leftParent=storedNodes.get(nodes.indexOf(node0.leftParent));\n    }\n else {\n      node1.leftParent=null;\n    }\n    if (node0.rightParent != null) {\n      node1.rightParent=storedNodes.get(nodes.indexOf(node0.rightParent));\n    }\n else {\n      node1.rightParent=null;\n    }\n    if (node0.leftChild != null) {\n      node1.leftChild=storedNodes.get(nodes.indexOf(node0.leftChild));\n    }\n else {\n      node1.leftChild=null;\n    }\n    if (node0.rightChild != null) {\n      node1.rightChild=storedNodes.get(nodes.indexOf(node0.rightChild));\n    }\n else {\n      node1.rightChild=null;\n    }\n  }\n}\n", "docstring": "copies the node connections from this argmodel \"'\" s nodes array to the destination array . basically it connects up the nodes in destination in the same way as this argmodel is set up . this method is package private .", "partition": "test"}
{"idx": "2846", "code": "@Override default CompletableFuture<OptionalDouble> minDouble(final ToDoubleFunction<? super T> fn){\n  return CompletableFuture.supplyAsync(null,getExec());\n}\n", "docstring": "perform an asynchronous min operation", "partition": "test"}
{"idx": "4248", "code": "public boolean logoutUser(String username,HttpServletRequest req){\n  return logoutUser(username,req,true,true);\n}\n", "docstring": "basic internal api call to authsvc to logout a user .", "partition": "test"}
{"idx": "3844", "code": "protected void transcode(File file,Transcoder transcoder) throws IOException, TranscoderException {\n  transcoder.addTranscodingHint(XMLAbstractTranscoder.KEY_XML_PARSER_VALIDATING,Boolean.FALSE);\n  SVGDocument doc=cloneDocument();\n  TranscoderInput input=new TranscoderInput(doc);\n  OutputStream out=new BufferedOutputStream(new FileOutputStream(file));\n  TranscoderOutput output=new TranscoderOutput(out);\n  transcoder.transcode(input,output);\n  out.flush();\n  out.close();\n}\n", "docstring": "transcode a document into a file using the given transcoder .", "partition": "test"}
{"idx": "1260", "code": "protected int createHashCode(){\n  int result=uri.hashCode() ^ prefix.hashCode();\n  if (result == 0) {\n    result=0xbabe;\n  }\n  return result;\n}\n", "docstring": "factory method to create the hashcode allowing derived classes to change the behaviour", "partition": "test"}
{"idx": "2858", "code": "private static String stampToString(long tstamp,String formatMask){\n  StringBuilder sb=new StringBuilder(30);\n  Formatter fmt=new Formatter(sb,Locale.US);\n  int[] pieces=new int[NUMIDX];\n  ComponentTime.unpackBits(tstamp,pieces);\n  fmt.format(formatMask,pieces[YIDX],pieces[MIDX],pieces[DIDX],pieces[HIDX],pieces[IIDX],pieces[SIDX],pieces[UIDX]);\n  fmt.close();\n  return (sb.toString());\n}\n", "docstring": "convenience method for converting component time longs to strings", "partition": "test"}
{"idx": "3085", "code": "public QuadEdge makeEdge(Vertex o,Vertex d){\n  QuadEdge q=QuadEdge.makeEdge(o,d);\n  quadEdges.add(q);\n  return q;\n}\n", "docstring": "creates a new quadedge , recording it in the edges list .", "partition": "test"}
{"idx": "2140", "code": "protected static Map<String,Step> parse(Class<? extends RSLPStemmerBase> clazz,String resource){\n  try {\n    InputStream is=clazz.getResourceAsStream(resource);\n    LineNumberReader r=new LineNumberReader(new InputStreamReader(is,StandardCharsets.UTF_8));\n    Map<String,Step> steps=new HashMap<>();\n    String step;\n    while ((step=readLine(r)) != null) {\n      Step s=parseStep(r,step);\n      steps.put(s.name,s);\n    }\n    r.close();\n    return steps;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "parse a resource file into an rslp stemmer description .", "partition": "test"}
{"idx": "383", "code": "public void clearUnused(ConfigImpl config){\n  SystemOut.printDate(config.getOutWriter(),\"PagePool: \" + size() + \">(\"+ maxSize+ \")\");\n  if (size() > maxSize) {\n    Object[] keys=keys();\n    LongKeyList list=new LongKeyList();\n    for (int i=0; i < keys.length; i++) {\n      PageSource ps=getPageSource(keys[i],false);\n      long updateTime=ps.getLastAccessTime();\n      if (updateTime + timeout < System.currentTimeMillis()) {\n        long add=((ps.getAccessCount() - 1) * 10000);\n        if (add > timeout)         add=timeout;\n        list.add(updateTime + add,keys[i]);\n      }\n    }\n    while (size() > maxSize) {\n      Object key=list.shift();\n      if (key == null)       break;\n      remove(key);\n    }\n  }\n}\n", "docstring": "clear unused pages from page pool", "partition": "test"}
{"idx": "4227", "code": "public static boolean isChar(String desc){\n  return desc.endsWith(\"C\");\n}\n", "docstring": "tells whether a given type is a char", "partition": "test"}
{"idx": "200", "code": "public void stateChanged(ChangeEvent e){\n  if (ignoreUpdate) {\n    return;\n  }\n  double value=(double)(1800 - setpointSlider.getValue()) / 10;\n  setSetPoint(value);\n  sim.setSetPoint(value);\n}\n", "docstring": "handle a change in the slider by updating the dataset value . this automatically triggers a chart repaint .", "partition": "test"}
{"idx": "1815", "code": "public ActionRequestHelper dependsOn(ActionRequestHelper dependency){\n  mDependencies.add(dependency);\n  return this;\n}\n", "docstring": "this request will execute after the dependency completes .", "partition": "test"}
{"idx": "2825", "code": "public PronounceableFSM(URL url,boolean scanFromFront) throws IOException {\n  this.scanFromFront=scanFromFront;\n  InputStream is=Utilities.getInputStream(url);\n  loadText(is);\n  is.close();\n}\n", "docstring": "constructs a pronounceablefsm with information in the given url .", "partition": "test"}
{"idx": "279", "code": "public static void sort(byte[] array){\n  DualPivotQuicksort.sort(array);\n}\n", "docstring": "sorts the specified array in ascending numerical order .", "partition": "test"}
{"idx": "1400", "code": "public int size(){\n  if (hmap == null) {\n    return 0;\n  }\n  return hmap.size();\n}\n", "docstring": "return the size of the embedded map", "partition": "test"}
{"idx": "1926", "code": "Builder addEncodedQueryParameter(String encodedName,String encodedValue){\n  if (encodedName == null)   throw new IllegalArgumentException(\"encodedName == null\");\n  if (encodedQueryNamesAndValues == null)   encodedQueryNamesAndValues=new ArrayList<>();\n  encodedQueryNamesAndValues.add(canonicalize(encodedName,QUERY_COMPONENT_ENCODE_SET,true,true));\n  encodedQueryNamesAndValues.add(encodedValue != null ? canonicalize(encodedValue,QUERY_COMPONENT_ENCODE_SET,true,true) : null);\n  return this;\n}\n", "docstring": "adds the pre - encoded query parameter to this url \"'\" s query string .", "partition": "test"}
{"idx": "78", "code": "@Override public void onTmpFilesCopied(ResultCode result){\n  dismissLoadingDialog();\n  finish();\n}\n", "docstring": "process the result of copyanduploadcontenturistask", "partition": "test"}
{"idx": "3435", "code": "private static String removeSubTrailers(String decodedSubject){\n  int subStringStart=0;\n  int subStringEnd=decodedSubject.length();\n  int originalSize=decodedSubject.length();\n  int curPos=originalSize - 1;\n  while (true) {\n    char c=decodedSubject.charAt(curPos--);\n    if (c == WS) {\n      subStringEnd--;\n    }\n else {\n      if (subStringEnd > FWD_PARENS.length() && decodedSubject.endsWith(FWD_PARENS)) {\n        subStringEnd-=FWD_PARENS.length();\n      }\n      break;\n    }\n  }\n  decodedSubject=decodedSubject.substring(subStringStart,subStringEnd);\n  return decodedSubject;\n}\n", "docstring": "remove the remove_subj_trailers subj - trailer = \" ( fwd ) \" / wsp", "partition": "test"}
{"idx": "1502", "code": "public void makeDirty(){\n  betaChanged=true;\n  newMode=true;\n  precisionChanged=true;\n  regressionInterface.makeDirty(instance);\n}\n", "docstring": "forces a complete recalculation of the likelihood next time getlikelihood is called", "partition": "test"}
{"idx": "1552", "code": "public static byte[] toByteArray(String str){\n  int len=str.length();\n  StringTokenizer st=new StringTokenizer(str,\":\");\n  String[] newStrArray=new String[st.countTokens()];\n  int j=0;\n  while (st.hasMoreTokens()) {\n    newStrArray[j]=st.nextToken();\n    j++;\n  }\n  byte[] ret=new byte[newStrArray.length];\n  int tmp;\n  for (int i=0; i < newStrArray.length; i++) {\n    tmp=Integer.parseInt(newStrArray[i],16);\n    ret[i]=(byte)(tmp - 128);\n  }\n  return ret;\n}\n", "docstring": "converts a given hex string separated by colons to a byte array .", "partition": "test"}
{"idx": "2344", "code": "public void readPrefs(SharedPreferences settings,ActionFactory factory){\n  boolean visible=false;\n  String actionId=settings.getString(\"button_action_\" + name + \"_0\",\"\");\n  mainAction=factory.getAction(actionId);\n  if (mainAction != null)   visible=true;\n  menuActions.clear();\n  for (int i=0; i < maxMenuActions; i++) {\n    actionId=settings.getString(\"button_action_\" + name + \"_\"+ (i + 1),\"\");\n    UIAction a=factory.getAction(actionId);\n    if (a != null)     visible=true;\n    menuActions.add(a);\n  }\n  if (button != null)   button.setVisibility(visible ? View.VISIBLE : View.GONE);\n}\n", "docstring": "update button actions from preferences settings .", "partition": "test"}
{"idx": "1334", "code": "private void applyTo(ClassVisitor v,Field f){\n  if (Log.isLoggingOn()) {\n    Log.logLine(String.format(\"Visiting field %s\",f.toGenericString()));\n  }\n  v.visit(f);\n}\n", "docstring": "apply a visitor to a field .", "partition": "test"}
{"idx": "668", "code": "@Override public void addChild(WXComponent child,int index){\n  if (child == null || index < -1) {\n    return;\n  }\n  if (child instanceof WXBaseRefresh) {\n    if (!checkRefreshOrLoading(child)) {\n      mRefreshs.add(child);\n    }\n    return;\n  }\n  if (mChildren == null) {\n    mChildren=new ArrayList<>();\n  }\n  int count=mChildren.size();\n  index=index >= count ? -1 : index;\n  if (index == -1) {\n    mChildren.add(child);\n  }\n else {\n    mChildren.add(index,child);\n  }\n}\n", "docstring": "intercept refresh view and loading view", "partition": "test"}
{"idx": "4076", "code": "public static Range iterateToFindDomainBounds(XYDataset dataset,List visibleSeriesKeys,boolean includeInterval){\n  ParamChecks.nullNotPermitted(dataset,\"dataset\");\n  ParamChecks.nullNotPermitted(visibleSeriesKeys,\"visibleSeriesKeys\");\n  double minimum=Double.POSITIVE_INFINITY;\n  double maximum=Double.NEGATIVE_INFINITY;\n  if (includeInterval && dataset instanceof IntervalXYDataset) {\n    IntervalXYDataset ixyd=(IntervalXYDataset)dataset;\n    Iterator iterator=visibleSeriesKeys.iterator();\n    while (iterator.hasNext()) {\n      Comparable seriesKey=(Comparable)iterator.next();\n      int series=dataset.indexOf(seriesKey);\n      int itemCount=dataset.getItemCount(series);\n      for (int item=0; item < itemCount; item++) {\n        double xvalue=ixyd.getXValue(series,item);\n        double lvalue=ixyd.getStartXValue(series,item);\n        double uvalue=ixyd.getEndXValue(series,item);\n        if (!Double.isNaN(xvalue)) {\n          minimum=Math.min(minimum,xvalue);\n          maximum=Math.max(maximum,xvalue);\n        }\n        if (!Double.isNaN(lvalue)) {\n          minimum=Math.min(minimum,lvalue);\n        }\n        if (!Double.isNaN(uvalue)) {\n          maximum=Math.max(maximum,uvalue);\n        }\n      }\n    }\n  }\n else {\n    Iterator iterator=visibleSeriesKeys.iterator();\n    while (iterator.hasNext()) {\n      Comparable seriesKey=(Comparable)iterator.next();\n      int series=dataset.indexOf(seriesKey);\n      int itemCount=dataset.getItemCount(series);\n      for (int item=0; item < itemCount; item++) {\n        double x=dataset.getXValue(series,item);\n        if (!Double.isNaN(x)) {\n          minimum=Math.min(minimum,x);\n          maximum=Math.max(maximum,x);\n        }\n      }\n    }\n  }\n  if (minimum == Double.POSITIVE_INFINITY) {\n    return null;\n  }\n else {\n    return new Range(minimum,maximum);\n  }\n}\n", "docstring": "returns the range of x - values in the specified dataset for the data items belonging to the visible series .", "partition": "test"}
{"idx": "13", "code": "private static void useMissile(Player player){\n  StackableItem projectilesItem=null;\n  if (player.getRangeWeapon() != null) {\n    projectilesItem=player.getAmmunition();\n  }\n  if (projectilesItem == null) {\n    projectilesItem=player.getMissileIfNotHoldingOtherWeapon();\n  }\n  if (projectilesItem != null) {\n    projectilesItem.removeOne();\n  }\n}\n", "docstring": "remove an used up missile from an attacking player .", "partition": "test"}
{"idx": "3129", "code": "public static File createTempDir(File dir,boolean cleanup) throws IOException {\n  if (!dir.mkdirs() && !dir.exists()) {\n    throw new IOException(String.format(\"Failed to create directory structure \\'%s\\'\",dir.toString()));\n  }\n  if (cleanup) {\n    addCleanupHook(dir.toPath());\n  }\n  return dir;\n}\n", "docstring": "create directory that is automatically cleaned up after the jvm shuts down through use of a runtime shutdown hook .", "partition": "test"}
{"idx": "2437", "code": "public OkapiBM25(double k1,double b){\n  if (Double.isNaN(k1) || Double.isInfinite(k1) || k1 < 0)   throw new IllegalArgumentException(\"coefficient k1 must be a non negative constant, not \" + k1);\n  this.k1=k1;\n  if (Double.isNaN(b) || b < 0 || b > 1)   throw new IllegalArgumentException(\"coefficient b must be in the range [0,1], not \" + b);\n  this.b=b;\n}\n", "docstring": "creates a new okapi object", "partition": "test"}
{"idx": "2068", "code": "@Override protected Sensor createNewSensor(String systemName,String userName){\n  if (log.isDebugEnabled()) {\n    log.debug(\"createNewSensor \" + systemName + \" \"+ userName);\n  }\n  Sensor s;\n  String sName=SerialAddress.normalizeSystemName(systemName);\n  if (sName.equals(\"\")) {\n    log.error(\"Invalid Sensor system name - \" + systemName);\n    return null;\n  }\n  s=getBySystemName(sName);\n  if (s != null) {\n    log.error(\"Sensor with this name already exists - \" + systemName);\n    return null;\n  }\n  String altName=SerialAddress.convertSystemNameToAlternate(sName);\n  s=getBySystemName(altName);\n  if (s != null) {\n    log.error(\"Sensor with name \\'\" + systemName + \"\\' already exists as \\'\"+ altName+ \"\\'\");\n    return null;\n  }\n  int bit=SerialAddress.getBitFromSystemName(sName);\n  if ((bit <= 0) || (bit >= SENSORSPERNODE)) {\n    log.error(\"Sensor bit number, \" + Integer.toString(bit) + \", is outside the supported range, 1-\"+ Integer.toString(SENSORSPERNODE - 1));\n    return null;\n  }\n  if (userName == null) {\n    s=new SerialSensor(sName);\n  }\n else {\n    s=new SerialSensor(sName,userName);\n  }\n  SerialNode node=SerialAddress.getNodeFromSystemName(sName);\n  if (node == null) {\n    log.warn(\"Sensor \" + sName + \" refers to an undefined Serial Node.\");\n    return s;\n  }\n  node.registerSensor(s,bit);\n  if (log.isDebugEnabled()) {\n    log.debug(\"register \" + s.getSystemName() + \" in node \"+ node);\n  }\n  return s;\n}\n", "docstring": "create a new sensor if all checks are passed system name is normalized to ensure uniqueness .", "partition": "test"}
{"idx": "568", "code": "public static boolean isJellybeanOrLater(){\n  return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN;\n}\n", "docstring": "returns whether the sdk is the jellybean release or later .", "partition": "test"}
{"idx": "1246", "code": "public boolean isFinalState(int state){\n  return (state < 0) ? false : fFinalStateFlags[state];\n}\n", "docstring": "check whether the given state is one of the final states", "partition": "test"}
{"idx": "1159", "code": "private Member nextMember(Member.Type type){\n  return new TestMember(type,new Address(\"localhost\",++port),new Address(\"localhost\",port + 1000));\n}\n", "docstring": "returns the next server address .", "partition": "test"}
{"idx": "4198", "code": "private void loadIgnoreFile(final String srcFolder){\n  ignoreFile=IgnoreFile.load(srcFolder);\n  if (ignoreFile == null) {\n    loadDefaultExcludePattern(srcFolder);\n  }\n}\n", "docstring": "load ignore file using . tfignore file from users ; if user does not specify . tfignore , using ours !", "partition": "test"}
{"idx": "689", "code": "private void growEntries(){\n  int newLen=(next.length << 1) + 1;\n  int[] newNext=new int[newLen];\n  GridUnsafe.copyMemory(next,INT_ARR_OFF,newNext,INT_ARR_OFF,size << 2);\n  next=newNext;\n  nextEmpty=new int[newLen];\n  Arrays.fill(nextEmpty,-1);\n  Object[] newObjs=new Object[newLen];\n  System.arraycopy(objs,0,newObjs,0,size);\n  objs=newObjs;\n}\n", "docstring": "increases hash table capacity by lengthening entry arrays .", "partition": "test"}
{"idx": "2632", "code": "public boolean matchesRawNamePattern(Object item){\n  String prefix=patternMatcher.getPattern();\n  String text=getElementName(item);\n  if (text == null)   return false;\n  int textLength=text.length();\n  int prefixLength=prefix.length();\n  if (textLength < prefixLength) {\n    return false;\n  }\n  for (int i=prefixLength - 1; i >= 0; i--) {\n    if (Character.toLowerCase(prefix.charAt(i)) != Character.toLowerCase(text.charAt(i)))     return false;\n  }\n  return true;\n}\n", "docstring": "general method for matching raw name pattern . checks whether current pattern is prefix of name provided item .", "partition": "test"}
{"idx": "630", "code": "public static void toString(Iterator<?> iter,String separator,StringBuilder sb){\n  while (iter.hasNext()) {\n    sb.append(iter.next());\n    if (iter.hasNext()) {\n      sb.append(separator);\n    }\n  }\n}\n", "docstring": "converts an iterator to a string by concatenating all of the string representations of objects in the iterator , divided by a separator .", "partition": "test"}
{"idx": "2996", "code": "public static boolean isEmpty(String string){\n  if (null == string)   return true;\n  return string.equals(EMPTY);\n}\n", "docstring": "check if the given string is empty or null", "partition": "test"}
{"idx": "1101", "code": "private static Intent createMapActivityIntent(Context context,URLSpan[] urlSpans){\n  for (int span_i=0; span_i < urlSpans.length; span_i++) {\n    URLSpan urlSpan=urlSpans[span_i];\n    String urlString=urlSpan.getURL();\n    if (urlString.startsWith(GEO_PREFIX)) {\n      Intent geoIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(urlString));\n      geoIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n      return geoIntent;\n    }\n  }\n  return null;\n}\n", "docstring": "create an intent to take the user to maps , using the first map link available . if no links are found , return null .", "partition": "test"}
{"idx": "1228", "code": "private boolean needsUpdate(Long bundleVersion,String beanVersion){\n  if (beanVersion.contains(\"OAD\")) {\n    Log.i(TAG,\"Bundle version: \" + bundleVersion);\n    Log.i(TAG,\"Bean version: \" + beanVersion);\n    return true;\n  }\n else {\n    try {\n      long parsedVersion=Long.parseLong(beanVersion.split(\" \")[0]);\n      Log.i(TAG,\"Bundle version: \" + bundleVersion);\n      Log.i(TAG,\"Bean version: \" + parsedVersion);\n      if (bundleVersion > parsedVersion) {\n        return true;\n      }\n else {\n        Log.i(TAG,\"No update required!\");\n      }\n    }\n catch (    NumberFormatException e) {\n      Log.e(TAG,\"Couldn\\'t parse Bean Version: \" + beanVersion);\n      fail(BeanError.UNPARSABLE_FW_VERSION);\n    }\n  }\n  return false;\n}\n", "docstring": "helper function to determine whether a bean needs a fw update given a specific bundle version", "partition": "test"}
{"idx": "3503", "code": "private void updatePromoVisibility(float percentage){\n  if (isPromoAvailable()) {\n    mPromoVisible=true;\n    mPromoHeightPx=Math.round(MathUtils.clamp(percentage * mPromoContentHeightPx,0.f,mPromoContentHeightPx));\n    mPromoOpacity=percentage;\n  }\n else {\n    mPromoVisible=false;\n    mPromoHeightPx=0.f;\n    mPromoOpacity=0.f;\n  }\n}\n", "docstring": "updates the ui state for opt out promo .", "partition": "test"}
{"idx": "2698", "code": "@RequestProcessing(value=\"/member/{userName}/points\",method=HTTPRequestMethod.GET) @Before(adviceClass={StopwatchStartAdvice.class,AnonymousViewCheck.class,UserBlockCheck.class}) @After(adviceClass=StopwatchEndAdvice.class) public void showHomePoints(final HTTPRequestContext context,final HttpServletRequest request,final HttpServletResponse response,final String userName) throws Exception {\n  final JSONObject user=(JSONObject)request.getAttribute(User.USER);\n  request.setAttribute(Keys.TEMAPLTE_DIR_NAME,Symphonys.get(\"skinDirName\"));\n  final AbstractFreeMarkerRenderer renderer=new SkinRenderer();\n  context.setRenderer(renderer);\n  renderer.setTemplateName(\"/home/points.ftl\");\n  final Map<String,Object> dataModel=renderer.getDataModel();\n  filler.fillHeaderAndFooter(request,response,dataModel);\n  String pageNumStr=request.getParameter(\"p\");\n  if (Strings.isEmptyOrNull(pageNumStr) || !Strings.isNumeric(pageNumStr)) {\n    pageNumStr=\"1\";\n  }\n  final int pageNum=Integer.valueOf(pageNumStr);\n  final int pageSize=Symphonys.getInt(\"userHomePointsCnt\");\n  final int windowSize=Symphonys.getInt(\"userHomePointsWindowSize\");\n  fillHomeUser(dataModel,user);\n  avatarQueryService.fillUserAvatarURL(user);\n  final String followingId=user.optString(Keys.OBJECT_ID);\n  dataModel.put(Follow.FOLLOWING_ID,followingId);\n  final JSONObject userPointsResult=pointtransferQueryService.getUserPoints(user.optString(Keys.OBJECT_ID),pageNum,pageSize);\n  final List<JSONObject> userPoints=CollectionUtils.<JSONObject>jsonArrayToList(userPointsResult.optJSONArray(Keys.RESULTS));\n  dataModel.put(Common.USER_HOME_POINTS,userPoints);\n  final boolean isLoggedIn=(Boolean)dataModel.get(Common.IS_LOGGED_IN);\n  if (isLoggedIn) {\n    final JSONObject currentUser=(JSONObject)dataModel.get(Common.CURRENT_USER);\n    final String followerId=currentUser.optString(Keys.OBJECT_ID);\n    final boolean isFollowing=followQueryService.isFollowing(followerId,user.optString(Keys.OBJECT_ID));\n    dataModel.put(Common.IS_FOLLOWING,isFollowing);\n  }\n  user.put(UserExt.USER_T_CREATE_TIME,new Date(user.getLong(Keys.OBJECT_ID)));\n  final int pointsCnt=userPointsResult.optInt(Pagination.PAGINATION_RECORD_COUNT);\n  final int pageCount=(int)Math.ceil((double)pointsCnt / (double)pageSize);\n  final List<Integer> pageNums=Paginator.paginate(pageNum,pageSize,pageCount,windowSize);\n  if (!pageNums.isEmpty()) {\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM,pageNums.get(0));\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM,pageNums.get(pageNums.size() - 1));\n  }\n  dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM,pageNum);\n  dataModel.put(Pagination.PAGINATION_PAGE_COUNT,pageCount);\n  dataModel.put(Pagination.PAGINATION_PAGE_NUMS,pageNums);\n}\n", "docstring": "shows user home points page .", "partition": "test"}
{"idx": "2187", "code": "public void insert(Component component,int index){\n  if (index < 0) {\n    throw new IllegalArgumentException(\"index less than zero.\");\n  }\n  int nitems=getComponentCount();\n  Vector<Component> tempItems=new Vector<Component>();\n  for (int i=index; i < nitems; i++) {\n    tempItems.addElement(getComponent(index));\n    remove(index);\n  }\n  add(component);\n  for (  Component tempItem : tempItems) {\n    add(tempItem);\n  }\n}\n", "docstring": "inserts the specified component into the menu at a given position .", "partition": "test"}
{"idx": "3823", "code": "public void addTailArg(String arg){\n  _tailArgs.add(arg);\n}\n", "docstring": "adds an arg after the command and any options .", "partition": "test"}
{"idx": "3456", "code": "public static double cdf(double val,double rate){\n  if (val < 0.) {\n    return 0.;\n  }\n  return 1 - Math.exp(-rate * val);\n}\n", "docstring": "cumulative density , static version", "partition": "test"}
{"idx": "2573", "code": "protected void update(int length){\n  tickLabelValues.clear();\n  tickLabels.clear();\n  tickLabelPositions.clear();\n  if (scale.isLogScaleEnabled()) {\n    updateTickLabelForLogScale(length);\n  }\n else {\n    updateTickLabelForLinearScale(length);\n  }\n  updateTickVisibility();\n  updateTickLabelMaxLengthAndHeight();\n}\n", "docstring": "updates the tick labels .", "partition": "test"}
{"idx": "411", "code": "public void test_create_update() throws IOException {\n  final String id=\"test\";\n  final Map<String,Object> metadata=new HashMap<String,Object>();\n  metadata.put(FileMetadataSchema.ID,id);\n  metadata.put(\"foo\",\"bar\");\n  final int version0;\n  final long createTime0;\n  final byte[] expected0=new byte[]{1,2,3};\n{\n    version0=repo.create(metadata);\n    metadata.put(FileMetadataSchema.VERSION,Integer.valueOf(version0));\n    assertEquals(\"version\",0,version0);\n    RepositoryDocumentImpl doc=(RepositoryDocumentImpl)repo.read(id);\n    createTime0=doc.getVersionCreateTime();\n    Map<String,Object> actual=doc.asMap();\n    assertEquals(\"id\",id,actual.get(FileMetadataSchema.ID));\n    assertEquals(\"version\",version0,actual.get(FileMetadataSchema.VERSION));\n    assertEquals(\"user property\",\"bar\",actual.get(\"foo\"));\n    assertEquals(\"size\",metadata.size(),actual.size());\n    repo.copyStream(id,version0,new ByteArrayInputStream(expected0));\n    assertEquals(\"version0\",expected0,read(repo.inputStream(id,version0)));\n  }\n  final int version1;\n  final long createTime1;\n  final byte[] expected1=new byte[]{4,5,6};\n{\n    metadata.put(\"foo\",\"baz\");\n    DocumentImpl doc1=new DocumentImpl(metadata);\n    doc1.copyStream(expected1);\n    version1=repo.update(doc1);\n    assertEquals(\"version\",1,version1);\n    metadata.put(FileMetadataSchema.VERSION,Integer.valueOf(version1));\n    RepositoryDocumentImpl doc=(RepositoryDocumentImpl)repo.read(id);\n    createTime1=doc.getVersionCreateTime();\n    assertNotSame(\"createTime\",0L,createTime1);\n    assertNotSame(\"createTime\",createTime0,createTime1);\n    Map<String,Object> actual=doc.asMap();\n    assertEquals(\"id\",id,actual.get(FileMetadataSchema.ID));\n    assertEquals(\"version\",version1,actual.get(FileMetadataSchema.VERSION));\n    assertEquals(\"user property\",\"baz\",actual.get(\"foo\"));\n    assertEquals(\"size\",metadata.size(),actual.size());\n    assertEquals(\"version1\",expected1,read(repo.inputStream(id,version1)));\n    assertEquals(\"version0\",new byte[]{},read(repo.inputStream(id,version0)));\n{\n      ITPS tps=repo.readMetadata(id,createTime1 - 1L);\n      ITPV tpv=tps.get(FileMetadataSchema.VERSION);\n      assertEquals(\"version\",null,tpv.getValue());\n    }\n  }\n}\n", "docstring": "create an empty file and write some data on it . then update its metadata , verify the new metadata and the updated version , and then write some data on the new version . verify the both file versions can be read .", "partition": "test"}
{"idx": "3694", "code": "public void clearTransactions(int fromHeight){\n  lock.lock();\n  try {\n    if (fromHeight == 0) {\n      unspent.clear();\n      spent.clear();\n      pending.clear();\n      dead.clear();\n      transactions.clear();\n    }\n else {\n      throw new UnsupportedOperationException();\n    }\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "deletes transactions which appeared above the given block height from the wallet , but does not touch the keys . this is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up .", "partition": "test"}
{"idx": "1350", "code": "public Week(Date time){\n  this(time,TimeZone.getDefault(),Locale.getDefault());\n}\n", "docstring": "creates a time period for the week in which the specified date / time falls , using the default time zone and locale ( the locale can affect the day - of - the - week that marks the beginning of the week , as well as the minimal number of days in the first week of the year ) .", "partition": "test"}
{"idx": "634", "code": "public void actionPerformed(ActionEvent e){\n  navigateToPriorDemo();\n}\n", "docstring": "invoked when an action occurs .", "partition": "test"}
{"idx": "3171", "code": "protected int[] splitSentence(String sentence){\n  String[] w=sentence.split(\"\\\\\\\\s+\");\n  int[] words=new int[w.length];\n  for (int i=0; i < w.length; i++)   words[i]=Vocabulary.id(w[i]);\n  return words;\n}\n", "docstring": "splits a sentence ( on white space ) , then looks up the integer representations of each word using the supplied symbol table .", "partition": "test"}
{"idx": "441", "code": "public List<StructuredTranslation> KbestExtractOnHG(HyperGraph hg,int topN){\n  resetState();\n  if (hg == null || hg.goalNode == null) {\n    return emptyList();\n  }\n  final List<StructuredTranslation> kbest=new ArrayList<>(topN);\n  for (int k=1; k <= topN; k++) {\n    StructuredTranslation translation=getKthStructuredTranslation(hg.goalNode,k);\n    if (translation == null) {\n      break;\n    }\n    kbest.add(translation);\n  }\n  return kbest;\n}\n", "docstring": "this is an entry point for extracting k - best hypotheses as structuredtranslation objects . it computes all of them and returning a list of structuredtranslation objects . these objects hold all translation information ( string , tokens , features , alignments , score ) .", "partition": "test"}
{"idx": "1535", "code": "private static Object matchOrReplace(Context cx,Scriptable scope,Scriptable thisObj,Object[] args,RegExpImpl reImpl,GlobData data,boolean forceFlat){\n  NativeRegExp re;\n  String str=ScriptRuntime.toString(thisObj);\n  data.str=str;\n  Scriptable topScope=ScriptableObject.getTopLevelScope(scope);\n  if (args.length == 0) {\n    Object compiled=NativeRegExp.compileRE(cx,\"\",\"\",false);\n    re=new NativeRegExp(topScope,compiled);\n  }\n else   if (args[0] instanceof NativeRegExp) {\n    re=(NativeRegExp)args[0];\n  }\n else {\n    String src=ScriptRuntime.toString(args[0]);\n    String opt;\n    if (data.optarg < args.length) {\n      args[0]=src;\n      opt=ScriptRuntime.toString(args[data.optarg]);\n    }\n else {\n      opt=null;\n    }\n    Object compiled=NativeRegExp.compileRE(cx,src,opt,forceFlat);\n    re=new NativeRegExp(topScope,compiled);\n  }\n  data.global=(re.getFlags() & NativeRegExp.JSREG_GLOB) != 0;\n  int[] indexp={0};\n  Object result=null;\n  if (data.mode == RA_SEARCH) {\n    result=re.executeRegExp(cx,scope,reImpl,str,indexp,NativeRegExp.TEST);\n    if (result != null && result.equals(Boolean.TRUE))     result=Integer.valueOf(reImpl.leftContext.length);\n else     result=Integer.valueOf(-1);\n  }\n else   if (data.global) {\n    re.lastIndex=0;\n    for (int count=0; indexp[0] <= str.length(); count++) {\n      result=re.executeRegExp(cx,scope,reImpl,str,indexp,NativeRegExp.TEST);\n      if (result == null || !result.equals(Boolean.TRUE))       break;\n      if (data.mode == RA_MATCH) {\n        match_glob(data,cx,scope,count,reImpl);\n      }\n else {\n        if (data.mode != RA_REPLACE)         Kit.codeBug();\n        SubString lastMatch=reImpl.lastMatch;\n        int leftIndex=data.leftIndex;\n        int leftlen=lastMatch.index - leftIndex;\n        data.leftIndex=lastMatch.index + lastMatch.length;\n        replace_glob(data,cx,scope,reImpl,leftIndex,leftlen);\n      }\n      if (reImpl.lastMatch.length == 0) {\n        if (indexp[0] == str.length())         break;\n        indexp[0]++;\n      }\n    }\n  }\n else {\n    result=re.executeRegExp(cx,scope,reImpl,str,indexp,((data.mode == RA_REPLACE) ? NativeRegExp.TEST : NativeRegExp.MATCH));\n  }\n  return result;\n}\n", "docstring": "analog of c match_or_replace .", "partition": "test"}
{"idx": "4209", "code": "@Override public void send(Buffer buffer){\n  _outProxy.write(_outWriter,buffer,false);\n}\n", "docstring": "initialization when the websocket completes .", "partition": "test"}
{"idx": "4234", "code": "public static String removeQuotes(String s){\n  if (s == null) {\n    return null;\n  }\n  String trimmed=s.trim();\n  if (trimmed.length() == 0) {\n    return trimmed;\n  }\n  int i=nextNonQuoteIndex(trimmed,0,true);\n  int j=nextNonQuoteIndex(trimmed,trimmed.length() - 1,false);\n  return trimmed.substring(i,j + 1);\n}\n", "docstring": "trims white spaces and remove quotes from the string .", "partition": "test"}
{"idx": "1425", "code": "public static String normalizeUrl(String requestUrl) throws OAuthException {\n  if ((requestUrl == null) || (requestUrl.length() == 0)) {\n    throw new OAuthException(\"Request Url cannot be empty\");\n  }\n  URI uri;\n  try {\n    uri=new URI(requestUrl);\n  }\n catch (  URISyntaxException e) {\n    throw new OAuthException(e);\n  }\n  String authority=uri.getAuthority();\n  String scheme=uri.getScheme();\n  if (authority == null || scheme == null) {\n    throw new OAuthException(\"Invalid Request Url\");\n  }\n  authority=authority.toLowerCase();\n  scheme=scheme.toLowerCase();\n  if ((scheme.equals(\"http\") && uri.getPort() == 80) || (scheme.equals(\"https\") && uri.getPort() == 443)) {\n    int index=authority.lastIndexOf(\":\");\n    if (index >= 0) {\n      authority=authority.substring(0,index);\n    }\n  }\n  return scheme + \"://\" + authority+ uri.getRawPath();\n}\n", "docstring": "calculates the normalized request url , as per section 9 . 1 . 2 of the oauth spec . this removes the querystring from the url and the port ( if it is the standard http or https port ) .", "partition": "test"}
{"idx": "2251", "code": "public void deleteAuthenticationDomain(String realm,String cotName) throws AMConsoleException {\n  String[] param={realm,cotName};\n  logEvent(\"ATTEMPT_DELETE_AUTH_DOMAINS\",param);\n  try {\n    CircleOfTrustManager manager=getCircleOfTrustManager();\n    manager.deleteCircleOfTrust(realm,cotName);\n    logEvent(\"SUCCEED_DELETE_AUTH_DOMAIN\",param);\n  }\n catch (  COTException e) {\n    String strError=getErrorString(e);\n    String[] paramsEx={realm,cotName,strError};\n    logEvent(\"FEDERATION_EXCEPTION_DELETE_AUTH_DOMAIN\",paramsEx);\n    throw new AMConsoleException(strError);\n  }\n}\n", "docstring": "deletes an authentication domain ( circle of trust ) within a given realm .", "partition": "test"}
{"idx": "3317", "code": "public void addInputMethodListener(InputMethodListener l){\n  m_textPane.addInputMethodListener(l);\n}\n", "docstring": "add input method listener", "partition": "test"}
{"idx": "389", "code": "public void testmirror(File orig,File origni,File truecolor){\n  File mirror=TestSupport.addSuffixToName(orig,\"_mirror\");\n  File recov=TestSupport.addSuffixToName(orig,\"_recov\");\n  long crc0=0;\n  boolean interlaced;\n  boolean palete;\n{\n    PngReader pngr=new PngReader(orig);\n    PngWriter pngw=null;\n    try {\n      if (rand.nextBoolean())       pngr.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      palete=pngr.imgInfo.indexed;\n      pngr.prepareSimpleDigestComputation();\n      interlaced=pngr.isInterlaced();\n      pngw=new PngWriter(mirror,pngr.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_CYCLIC);\n      pngw.copyChunksFrom(pngr.getChunksList());\n      IImageLineSet<? extends IImageLine> lines=pngr.readRows();\n      for (int row=0; row < pngr.imgInfo.rows; row++) {\n        mirrorLine(lines.getImageLine(row),pngr.imgInfo);\n        pngw.writeRow(lines.getImageLine(row));\n      }\n      pngr.end();\n      crc0=PngHelperInternal.getDigest(pngr);\n      pngw.end();\n    }\n  finally {\n      pngr.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n{\n    PngReader pngr2=new PngReader(mirror);\n    PngWriter pngw=null;\n    try {\n      if (pngr2.imgInfo.bitDepth < 16 && rand.nextBoolean())       pngr2.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      pngw=new PngWriter(recov,pngr2.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_DEFAULT);\n      pngw.copyChunksFrom(pngr2.getChunksList());\n      for (int row=0; row < pngr2.imgInfo.rows; row++) {\n        IImageLine line=pngr2.readRow();\n        mirrorLine(line,pngr2.imgInfo);\n        pngw.writeRow(line);\n      }\n      pngr2.end();\n      pngw.end();\n    }\n  finally {\n      pngr2.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n  if (!interlaced)   TestSupport.testCrcEquals(recov,crc0);\n else   TestSupport.testSameCrc(recov,origni);\n  if (interlaced)   additionalTestInterlaced(orig,origni);\n  if (palete && truecolor.exists())   additionalTestPalette(orig,truecolor);\n}\n", "docstring": "takes a image , mirrors it using row - per - row int reading , mirror it again using byte ( if possible ) and compares if the original was interlaced , compares with origni", "partition": "test"}
{"idx": "584", "code": "private Integer scanYamlDirectiveNumber(Mark startMark){\n  char ch=reader.peek();\n  if (!Character.isDigit(ch)) {\n    throw new ScannerException(\"while scanning a directive\",startMark,\"expected a digit, but found \" + ch + \"(\"+ ((int)ch)+ \")\",reader.getMark());\n  }\n  int length=0;\n  while (Character.isDigit(reader.peek(length))) {\n    length++;\n  }\n  Integer value=Integer.parseInt(reader.prefixForward(length));\n  return value;\n}\n", "docstring": "read a % yaml directive number : this is either the major or the minor part . stop reading at a non - digit character ( usually either \"'\" . \"'\" or \"'\" \\\\ n \"'\" ) .", "partition": "test"}
{"idx": "1190", "code": "public String info(){\n  StringBuilder sb=new StringBuilder(\"Report: size: \" + tableSize + \", elements: \"+ elements+ \", loadFactor: \"+ loadFactor+ \", threshold: \"+ threshold);\n  sb.append(\", empty bins:\" + numEmpty);\n  int size=0;\n  int min=elements;\n  int max=-1;\n  for (int i=0; i < tableSize; i++) {\n    LinkedList<String> list=bins[i];\n    if (list != null) {\n      int sz=list.size();\n      size+=sz;\n      if (sz < min) {\n        min=sz;\n      }\n      if (sz > max) {\n        max=sz;\n      }\n    }\n  }\n  float avg=size;\n  int base=(tableSize - numEmpty);\n  if (base == 0) {\n    sb.append(\", average:0\");\n    sb.append(\", minListSize:0\");\n    sb.append(\", maxListSize:0\");\n  }\n else {\n    avg/=base;\n    sb.append(\", average:\" + avg);\n    sb.append(\", minListSize:\" + min);\n    sb.append(\", maxListSize:\" + max);\n  }\n  return sb.toString();\n}\n", "docstring": "return single line of output .", "partition": "test"}
{"idx": "1391", "code": "public String toString(){\n  return oid.toString();\n}\n", "docstring": "returns a string representation of the oid \"'\" s integer components in dot separated notation .", "partition": "test"}
{"idx": "3443", "code": "private static void skipMemberValue(int tag,ByteBuffer buf){\nswitch (tag) {\ncase 'e':\n    buf.getInt();\n  break;\ncase '@':\nskipAnnotation(buf,true);\nbreak;\ncase '[':\nskipArray(buf);\nbreak;\ndefault :\nbuf.getShort();\n}\n}\n", "docstring": "skips the annotation member value at the current position in the specified byte buffer . the cursor of the byte buffer must point immediately after the tag in a \" member_value structure . \"", "partition": "test"}
{"idx": "548", "code": "public void writeStartElement(String localName) throws XMLStreamException {\n  if (localName == null || localName.length() == 0) {\n    throw new XMLStreamException(\"Local Name cannot be null or empty\");\n  }\n  _state=STATE_ELEMENT;\n  if (_currentEle != null && _currentEle.getState() == ELEMENT_STARTTAG_OPEN) {\n    closeStartTag();\n  }\n  _currentEle=new Element(_currentEle,localName,false);\n  openStartTag();\n  _writer.write(localName);\n}\n", "docstring": "writes a start tag to the output .", "partition": "test"}
{"idx": "2464", "code": "public Value sample(){\n  int index=sampler.nextInt(actionValues.size());\n  if (actionValuesAsArray == null) {\n    actionValuesAsArray=actionValues.toArray(new Value[actionValues.size()]);\n  }\n  return actionValuesAsArray[index];\n}\n", "docstring": "returns a sample point for the action , assuming a uniform distribution over the action values", "partition": "test"}
{"idx": "1801", "code": "private void initializeLocalAndTargetInfo() throws Exception {\n  targetSiteInfo=coordinator.getTargetInfo(SiteInfo.class);\n  if (targetSiteInfo == null) {\n    targetSiteInfo=new SiteInfo();\n    try {\n      coordinator.setTargetInfo(targetSiteInfo,false);\n      log.info(\"Step1b: Target site info set to: {}\",targetSiteInfo);\n    }\n catch (    CoordinatorClientException e) {\n      log.info(\"Step1b: Wait another control node to set target\");\n      retrySleep();\n      throw e;\n    }\n  }\n  localVdcPropInfo=localRepository.getVdcPropertyInfo();\n  String localConfigVersion=localVdcPropInfo.getProperty(VdcConfigUtil.VDC_CONFIG_VERSION);\n  coordinator.setNodeSessionScopeInfo(new VdcConfigVersion(localConfigVersion));\n  targetVdcPropInfo=loadVdcConfig();\n  if (isGeoUpgradeFromPreYoda()) {\n    log.info(\"Detect vdc properties from preyoda. Keep local vdc config properties unchanged until all vdc configs are migrated to zk\");\n    localVdcPropInfo.addProperty(VdcConfigUtil.VDC_CONFIG_VERSION,String.valueOf(targetSiteInfo.getVdcConfigVersion()));\n    localRepository.setVdcPropertyInfo(localVdcPropInfo);\n  }\n else {\n    if (localVdcPropInfo.getProperty(VdcConfigUtil.VDC_CONFIG_VERSION) == null) {\n      localVdcPropInfo=new PropertyInfoExt(targetVdcPropInfo.getAllProperties());\n      localVdcPropInfo.addProperty(VdcConfigUtil.VDC_CONFIG_VERSION,String.valueOf(targetSiteInfo.getVdcConfigVersion()));\n      localRepository.setVdcPropertyInfo(localVdcPropInfo);\n      String vdc_ids=targetVdcPropInfo.getProperty(VdcConfigUtil.VDC_IDS);\n      String[] vdcIds=vdc_ids.split(\",\");\n      if (vdcIds.length > 1) {\n        log.info(\"More than one Vdc, rebooting\");\n        reboot();\n      }\n    }\n  }\n  targetPowerOffState=coordinator.getTargetInfo(PowerOffState.class);\n  if (targetPowerOffState == null) {\n    try {\n      coordinator.setTargetInfo(new PowerOffState(PowerOffState.State.NONE));\n      targetPowerOffState=coordinator.getTargetInfo(PowerOffState.class);\n      log.info(\"Step1b: Target poweroff state set to: {}\",PowerOffState.State.NONE);\n    }\n catch (    CoordinatorClientException e) {\n      log.info(\"Step1b: Wait another control node to set target\");\n      retrySleep();\n      throw e;\n    }\n  }\n}\n", "docstring": "initialize local and target info", "partition": "test"}
{"idx": "3281", "code": "static double svd_pythag(double a,double b){\n  double p, r, s, t, u, temp;\n  p=svd_dmax(Math.abs(a),Math.abs(b));\n  if (p != 0.0) {\n    temp=svd_dmin(Math.abs(a),Math.abs(b)) / p;\n    r=temp * temp;\n    t=4.0 + r;\n    while (t != 4.0) {\n      s=r / t;\n      u=1.0 + 2.0 * s;\n      p*=u;\n      temp=s / u;\n      r*=temp * temp;\n      t=4.0 + r;\n    }\n  }\n  return p;\n}\n", "docstring": "funtions used - - - - - - - - - - - - - utility dmax , dmin", "partition": "test"}
{"idx": "4239", "code": "public boolean equals(final ArtifactCoordinates obj){\n  return this == obj || obj != null && groupId.equals(obj.groupId) && artifactId.equals(obj.artifactId) && version.equals(obj.version) && classifier.equals(obj.classifier);\n}\n", "docstring": "determine whether this coordinates object equals the target object .", "partition": "test"}
{"idx": "1849", "code": "public Set<T> keySet(){\n  return Collections.unmodifiableSet(map.keySet());\n}\n", "docstring": "the item keys contained in the map .", "partition": "test"}
{"idx": "4066", "code": "private void applyImageMatrix(float width,float height,boolean center,boolean animate){\n  if (mBitmap != null && width > 0 && height > 0) {\n    mImageMatrix.reset();\n    mImageMatrix.postTranslate((width - mBitmap.getWidth()) / 2,(height - mBitmap.getHeight()) / 2);\n    mapImagePointsByImageMatrix();\n    if (mDegreesRotated > 0) {\n      mImageMatrix.postRotate(mDegreesRotated,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n      mapImagePointsByImageMatrix();\n    }\n    float scale=Math.min(width / BitmapUtils.getRectWidth(mImagePoints),height / BitmapUtils.getRectHeight(mImagePoints));\n    if (mScaleType == ScaleType.FIT_CENTER || (mScaleType == ScaleType.CENTER_INSIDE && scale < 1) || (scale > 1 && mAutoZoomEnabled)) {\n      mImageMatrix.postScale(scale,scale,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n      mapImagePointsByImageMatrix();\n    }\n    mImageMatrix.postScale(mZoom,mZoom,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n    mapImagePointsByImageMatrix();\n    RectF cropRect=mCropOverlayView.getCropWindowRect();\n    cropRect.offset(-mZoomOffsetX * mZoom,-mZoomOffsetY * mZoom);\n    if (center) {\n      mZoomOffsetX=width > BitmapUtils.getRectWidth(mImagePoints) ? 0 : Math.max(Math.min(width / 2 - cropRect.centerX(),-BitmapUtils.getRectLeft(mImagePoints)),getWidth() - BitmapUtils.getRectRight(mImagePoints)) / mZoom;\n      mZoomOffsetY=height > BitmapUtils.getRectHeight(mImagePoints) ? 0 : Math.max(Math.min(height / 2 - cropRect.centerY(),-BitmapUtils.getRectTop(mImagePoints)),getHeight() - BitmapUtils.getRectBottom(mImagePoints)) / mZoom;\n    }\n else {\n      mZoomOffsetX=Math.min(Math.max(mZoomOffsetX * mZoom,-cropRect.left),-cropRect.right + width) / mZoom;\n      mZoomOffsetY=Math.min(Math.max(mZoomOffsetY * mZoom,-cropRect.top),-cropRect.bottom + height) / mZoom;\n    }\n    mImageMatrix.postTranslate(mZoomOffsetX * mZoom,mZoomOffsetY * mZoom);\n    cropRect.offset(mZoomOffsetX * mZoom,mZoomOffsetY * mZoom);\n    mCropOverlayView.setCropWindowRect(cropRect);\n    mapImagePointsByImageMatrix();\n    if (animate) {\n      mAnimation.setEndState(mImagePoints,mImageMatrix);\n      mImageView.startAnimation(mAnimation);\n    }\n else {\n      mImageView.setImageMatrix(mImageMatrix);\n    }\n    updateImageBounds(false);\n  }\n}\n", "docstring": "apply matrix to handle the image inside the image view .", "partition": "test"}
{"idx": "964", "code": "private String idString(int id1,int id2){\n  return \"0x\" + Integer.toHexString(id2 & 0x7F) + \" 0x\"+ Integer.toHexString(id1 & 0x7F)+ \" (\"+ ((id2 & 0x7F) * 128 + (id1 & 0x7F))+ \")\";\n}\n", "docstring": "convert throttle id to a human friendly format .", "partition": "test"}
{"idx": "755", "code": "private static List<Size> pickUpToThree(List<Size> sizes){\n  List<Size> result=new ArrayList<Size>();\n  Size largest=sizes.get(0);\n  result.add(largest);\n  Size lastSize=largest;\n  for (  Size size : sizes) {\n    double targetArea=Math.pow(.5,result.size()) * area(largest);\n    if (area(size) < targetArea) {\n      if (!result.contains(lastSize) && (targetArea - area(lastSize) < area(size) - targetArea)) {\n        result.add(lastSize);\n      }\n else {\n        result.add(size);\n      }\n    }\n    lastSize=size;\n    if (result.size() == 3) {\n      break;\n    }\n  }\n  if (result.size() < 3 && !result.contains(lastSize)) {\n    result.add(lastSize);\n  }\n  return result;\n}\n", "docstring": "given a list of sizes of a similar aspect ratio , it tries to pick evenly spaced out options . it starts with the largest , then tries to find one at 50 % of the last chosen size for the subsequent size .", "partition": "test"}
{"idx": "3717", "code": "public void runWithRetries(RetryableTask task) throws Exception {\n  boolean maxSleepIntervalHit=false;\n  for (int i=0; i < numAttempts; i++) {\n    try {\n      task.run();\n      return;\n    }\n catch (    Exception e) {\n      if (i == numAttempts - 1) {\n        throw e;\n      }\n      int sleepTime;\n      if (maxSleepIntervalHit) {\n        sleepTime=maxSleepInterval;\n      }\n else {\n        sleepTime=baseSleepInterval * (int)Math.pow(2,i);\n      }\n      LOG.error(\"Got an exception! Sleeping for \" + sleepTime + \" seconds and retrying.\",e);\n      try {\n        Thread.sleep(sleepTime * 1000);\n      }\n catch (      InterruptedException ie) {\n        LOG.error(\"Unexpected interruption!\",ie);\n        throw ie;\n      }\n    }\n  }\n}\n", "docstring": "run a task , retrying a fixed number of times if there is a failure .", "partition": "test"}
{"idx": "1233", "code": "protected String buildQualifierRegex(String qualifierValue){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"^\");\n  sb.append(qualifierValue);\n  sb.append(\"$\");\n  return sb.toString();\n}\n", "docstring": "just used for like and not_like", "partition": "test"}
{"idx": "3595", "code": "public StreamThroughput(String statusMessagePrefix){\n  m_instanceCount=0;\n  m_sampleCount=0;\n  m_numSamples=0;\n  m_cumulativeTime=0;\n  m_startTime=System.currentTimeMillis();\n  m_statusMessagePrefix=statusMessagePrefix;\n}\n", "docstring": "construct a new streamthroughput", "partition": "test"}
{"idx": "1699", "code": "protected void expandFor(int index,double d){\n  if (index < size)   return;\n  int oldSize=size, capacity=vector.length;\n  size=index + 1;\n  if (capacity >= size)   return;\n  while (capacity < size)   capacity*=2;\n  double[] t=new double[capacity];\n  System.arraycopy(vector,0,t,0,oldSize);\n  if (d != 0)   Arrays.fill(t,oldSize,size,d);\n  vector=t;\n}\n", "docstring": "makes sure the capacity and size of the vector can accomodate the given index . the capacity of the vector is simply doubled until it can accomodate its size .", "partition": "test"}
{"idx": "546", "code": "private void recomputeSeperation(double[][] means,double[][] cdist,LongStatistic diststat){\n  final int k=means.length;\n  for (int i=1; i < k; i++) {\n    DoubleVector mi=DoubleVector.wrap(means[i]);\n    for (int j=0; j < i; j++) {\n      cdist[i][j]=cdist[j][i]=distanceFunction.distance(mi,DoubleVector.wrap(means[j]));\n    }\n  }\n  if (diststat != null) {\n    diststat.increment((k * (k - 1)) >> 1);\n  }\n}\n", "docstring": "recompute the separation of cluster means .", "partition": "test"}
{"idx": "225", "code": "public final boolean remove(final URI serviceURI){\n  boolean modified=false;\nsynchronized (this) {\n    if (aliases.remove(serviceURI) != null) {\n      modified=true;\n    }\n    final ServiceFactory factory=services.remove(serviceURI);\n    if (factory != null) {\n      modified=true;\n      if (factory instanceof CustomServiceFactory) {\n        customServices.remove(factory);\n      }\n    }\n  }\n  return modified;\n}\n", "docstring": "remove a service from the registry and / or set of known aliases .", "partition": "test"}
{"idx": "3966", "code": "public static void downto(float self,Number to,@ClosureParams(FirstParam.class) Closure closure){\n  float to1=to.floatValue();\n  if (self >= to1) {\n    for (float i=self; i >= to1; i--) {\n      closure.call(i);\n    }\n  }\n else   throw new GroovyRuntimeException(\"The argument (\" + to + \") to downto() cannot be greater than the value (\"+ self+ \") it\\'s called on.\");\n}\n", "docstring": "iterates from this number down to the given number , inclusive , decrementing by one each time .", "partition": "test"}
{"idx": "1179", "code": "@Deprecated private List<CharSequence> buildLimitedNetworksList(){\n  final Context context=getActivity();\n  final ArrayList<CharSequence> limited=Lists.newArrayList();\n  if (hasSubscription(context)) {\n    final String subscriberId=getActiveSubscriberId(context);\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobileAll(subscriberId))) {\n      limited.add(getText(R.string.data_usage_list_mobile));\n    }\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobile3gLower(subscriberId))) {\n      limited.add(getText(R.string.data_usage_tab_3g));\n    }\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobile4g(subscriberId))) {\n      limited.add(getText(R.string.data_usage_tab_4g));\n    }\n  }\n  if (mPolicyEditor.hasLimitedPolicy(buildTemplateWifiWildcard())) {\n    limited.add(getText(R.string.data_usage_tab_wifi));\n  }\n  if (mPolicyEditor.hasLimitedPolicy(buildTemplateEthernet())) {\n    limited.add(getText(R.string.data_usage_tab_ethernet));\n  }\n  return limited;\n}\n", "docstring": "build list of currently limited networks , which defines when background data is restricted .", "partition": "test"}
{"idx": "6", "code": "@Override public void datasetChanged(DatasetChangeEvent event){\n  super.datasetChanged(event);\n  if (this.subplots == null) {\n    return;\n  }\n  XYDataset dataset=null;\n  if (event.getDataset() instanceof XYDataset) {\n    dataset=(XYDataset)event.getDataset();\n  }\n  for (  XYPlot subplot : this.subplots) {\n    if (subplot.indexOf(dataset) >= 0) {\n      subplot.configureRangeAxes();\n    }\n  }\n}\n", "docstring": "receives notification of a change to the plot \"'\" s dataset . < p > the axis ranges are updated if necessary .", "partition": "test"}
{"idx": "2426", "code": "public void close(){\n  if (!isOpen)   return;\n  Log.d(TAG,\"Trying to close track\");\n  loadingLock.lock();\n  try {\n    save();\n    if (saveFileStream != null) {\n      SavingHelper.close(saveFileStream);\n      saveFileStream=null;\n    }\n    savingDisabled=true;\n    isOpen=false;\n    Log.i(TAG,\"Track closed\");\n  }\n  finally {\n    loadingLock.unlock();\n  }\n}\n", "docstring": "saves and closes the track . the object should not be used afterwards , as saving will be disabled . the save file will never be accessed by this object again , and isopen will be set to false . this will allow to open the track again .", "partition": "test"}
{"idx": "1042", "code": "@Override public void valueChanged(TreeSelectionEvent e){\n  if (preventEvent) {\n    return;\n  }\n  if (mainFrame != null) {\n    List<Operator> selectedOperators=getSelectedOperators();\n    if (selectedOperators != null && !selectedOperators.isEmpty()) {\n      mainFrame.selectOperators(selectedOperators);\n    }\n  }\n}\n", "docstring": "this method will be invoked after a user selection of an operator in the tree . causes a property table update and an update of the conditional action container .", "partition": "test"}
{"idx": "2817", "code": "public boolean free(T obj){\n  AtomicInteger topRef=_top;\n  while (true) {\n    final int top=topRef.get();\n    if (_capacity <= top) {\n      return false;\n    }\n    boolean isFree=_freeStack.compareAndSet(top,null,obj);\n    topRef.compareAndSet(top,top + 1);\n    if (isFree) {\n      return true;\n    }\n  }\n}\n", "docstring": "frees the object . if the free list is full , the object will be garbage collected .", "partition": "test"}
{"idx": "2685", "code": "private byte[] decode(DerInputStream in) throws IOException {\n  DerValue val=in.getDerValue();\n  byte[] derEncoding=val.toByteArray();\n  derEncoding[0]=DerValue.tag_SetOf;\n  DerInputStream derIn=new DerInputStream(derEncoding);\n  DerValue[] derVals=derIn.getSet(3,true);\n  PKCS9Attribute attrib;\n  ObjectIdentifier oid;\n  boolean reuseEncoding=true;\n  for (int i=0; i < derVals.length; i++) {\n    try {\n      attrib=new PKCS9Attribute(derVals[i]);\n    }\n catch (    ParsingException e) {\n      if (ignoreUnsupportedAttributes) {\n        reuseEncoding=false;\n        continue;\n      }\n else {\n        throw e;\n      }\n    }\n    oid=attrib.getOID();\n    if (attributes.get(oid) != null)     throw new IOException(\"Duplicate PKCS9 attribute: \" + oid);\n    if (permittedAttributes != null && !permittedAttributes.containsKey(oid))     throw new IOException(\"Attribute \" + oid + \" not permitted in this attribute set\");\n    attributes.put(oid,attrib);\n  }\n  return reuseEncoding ? derEncoding : generateDerEncoding();\n}\n", "docstring": "decode this set of pkcs9 attributes from the contents of its der encoding . ignores unsupported attributes when directed .", "partition": "test"}
{"idx": "4063", "code": "public static boolean isConnected(NetType netType,NetworkInfo networkInfo){\n  if (netType == NetType.Any && networkInfo != null && isConnected(networkInfo))   return true;\n else   if (netType == NetType.Wifi && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo))   return true;\n else   if (netType == NetType.Mobile && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo))   return true;\n  return false;\n}\n", "docstring": "according to the different type of network to determine whether the network connection .", "partition": "test"}
{"idx": "540", "code": "public boolean deleteLoadName(String load){\n  if (!_loadList.contains(load)) {\n    return false;\n  }\n  _loadList.remove(load);\n  log.debug(\"train (\" + getName() + \") delete car load \"+ load);\n  setDirtyAndFirePropertyChange(LOADS_CHANGED_PROPERTY,_loadList.size() + 1,_loadList.size());\n  return true;\n}\n", "docstring": "delete a load name that the train will either service or exclude . see setloadoption", "partition": "test"}
{"idx": "2941", "code": "public float toMeters(double pixels){\n  return (float)(pixels * METERS_PER_PIXELS);\n}\n", "docstring": "converts pixels to meters", "partition": "test"}
{"idx": "3449", "code": "private void registerChildListeners(){\n  Iterator<PropertyChangeListener> iter=fChildListeners.iterator();\n  while (iter.hasNext()) {\n    PropertyChangeListener listener=iter.next();\n    listener.register();\n  }\n}\n", "docstring": "register the child listeners on the child preference stores .", "partition": "test"}
{"idx": "2165", "code": "public static AnnotationMirror findEffectiveAnnotationInHierarchy(final QualifierHierarchy qualifierHierarchy,final AnnotatedTypeMirror toSearch,final AnnotationMirror top){\n  return findEffectiveAnnotationInHierarchy(qualifierHierarchy,toSearch,top,false);\n}\n", "docstring": "when comparing types against the bounds of a type variable , we may encounter other type variables , wildcards , and intersections in those bounds . this method traverses the bounds until it finds a concrete type from which it can pull an annotation .", "partition": "test"}
{"idx": "709", "code": "public void startLaunchNotifier(){\n  if (m_launchNotification == null)   throw new NullPointerException();\n  m_launchNotifierThread.setDaemon(true);\n  m_launchNotifierThread.start();\n}\n", "docstring": "creates a background thread that will call the launch notifier when the process terminates .", "partition": "test"}
{"idx": "2795", "code": "public String formatSQL(Object obj,Object expr){\n  String sql=null;\n  if (expr instanceof String) {\n    sql=(String)expr;\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL retrieved from state = \" + sql);\n    }\n  }\n else   if (obj != null) {\n    sql=toString(obj);\n    if (sql != null) {\n      if (sql.startsWith(\"prep\")) {\n        sql=sql.replaceFirst(\"prep[0-9]*: \",\"\");\n      }\n      sql=sql.replaceAll(\"X\\'.*\\'\",BINARY_SQL_MARKER);\n    }\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL derived from context = \" + sql);\n    }\n  }\n  return sql;\n}\n", "docstring": "this method attempts to return a sql statement . if an expression is supplied , and is string , it will be used . otherwise the method will attempt to derive an expression from the supplied object .", "partition": "test"}
{"idx": "3728", "code": "protected final void resolveIssue(HealthIssue healthIssue){\n  EventBus eventBus;\n  boolean wasIssueActive;\nsynchronized (mLock) {\n    if (mHealthEventBus == null) {\n      LOG.w(\"A health issue was resolved even though no event bus was registered to \" + \"handle it: %1$s.\",healthIssue.toString());\n      return;\n    }\n    eventBus=mHealthEventBus;\n    wasIssueActive=mActiveIssues.remove(healthIssue);\n  }\n  if (wasIssueActive) {\n    eventBus.post(healthIssue.resolved);\n  }\n}\n", "docstring": "marks as resolved the specified issue . < p / > < p > if the issue was not previously reported , this method does nothing .", "partition": "test"}
{"idx": "2320", "code": "public final static int parseInt(char[] digitChars,int offset,int len){\n  int num=digitChars[offset] - '0';\n  len+=offset;\n  if (++offset < len) {\n    num=(num * 10) + (digitChars[offset] - '0');\n    if (++offset < len) {\n      num=(num * 10) + (digitChars[offset] - '0');\n      if (++offset < len) {\n        num=(num * 10) + (digitChars[offset] - '0');\n        if (++offset < len) {\n          num=(num * 10) + (digitChars[offset] - '0');\n          if (++offset < len) {\n            num=(num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n              num=(num * 10) + (digitChars[offset] - '0');\n              if (++offset < len) {\n                num=(num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                  num=(num * 10) + (digitChars[offset] - '0');\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return num;\n}\n", "docstring": "fast method for parsing integers that are known to fit into regular 32 - bit signed int type . this means that length is between 1 and 9 digits ( inclusive ) < p > note : public to let unit tests call it", "partition": "test"}
{"idx": "3022", "code": "private int measureHeight(int measureSpec){\n  int result=0;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  mAscent=(int)mTextPaint.ascent();\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(-mAscent + mTextPaint.descent()) + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "docstring": "determines the height of this view", "partition": "test"}
{"idx": "2813", "code": "private void persistNewTemp(File fileCfg){\n  if (hsDeleteOnExit.size() == 0) {\n    logDebug(LogArea.CONFIG,\"No temp file names to persist on exit.\");\n    fileCfg.delete();\n    return;\n  }\n  logDebug(LogArea.CONFIG,\"Persisting %d temp file names into %s\",hsDeleteOnExit.size(),fileCfg.getAbsolutePath());\n  BufferedWriter writer=null;\n  try {\n    writer=new BufferedWriter(new FileWriter(fileCfg));\n    for (    File file : hsDeleteOnExit) {\n      if (!file.delete()) {\n        String f=file.getCanonicalPath();\n        writer.write(f);\n        writer.newLine();\n        logWarn(LogArea.JAR,\"JVM failed to release %s\",f);\n      }\n    }\n  }\n catch (  IOException e) {\n  }\n finally {\n    if (writer != null) {\n      try {\n        writer.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n}\n", "docstring": "creates file with temporary files list . this list will be used to delete temporary files on the next application launch . the method is called from shutdown ( ) .", "partition": "test"}
{"idx": "2794", "code": "public static void assertEquals(Object object1,Object object2){\n  checkAssertion(object1.equals(object2),null);\n}\n", "docstring": "asserts that given object1 equals object2 .", "partition": "test"}
{"idx": "1045", "code": "public static <U>AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass,String fieldName){\n  if (UnsafeHolder.isAvailable()) {\n    return new AtomicIntegerFieldUpdaterImpl<U>(tclass,fieldName);\n  }\n  return AtomicIntegerFieldUpdater.newUpdater(tclass,fieldName);\n}\n", "docstring": "creates an updater for objects with the given field . the class argument is needed to check that reflective types and generic types match .", "partition": "test"}
{"idx": "1301", "code": "public void addRow(Assignment head,double prob){\n  if (prob < 0.0f || prob > 1.02f) {\n    return;\n  }\n  headVars.addAll(head.getVariables());\n  table.put(head,prob);\n}\n", "docstring": "adds a new row to the probability table , assuming no conditional assignment . if the table already contains a probability , it is erased .", "partition": "test"}
{"idx": "1098", "code": "public void delItem(int index){\nsynchronized (getMenuTreeLock()) {\n    if (selectedIndex == index) {\n      selectItem(null,false);\n    }\n else     if (selectedIndex > index) {\n      selectedIndex--;\n    }\n    if (index < items.size()) {\n      items.remove(index);\n    }\n else {\n      if (log.isLoggable(PlatformLogger.Level.FINE)) {\n        log.fine(\"WARNING: Attempt to remove non-existing menu item, index : \" + index + \", item count : \"+ items.size());\n      }\n    }\n  }\n  updateSize();\n}\n", "docstring": "removes item at the specified index from items vector .", "partition": "test"}
{"idx": "2871", "code": "public void testCase19(){\n  byte aBytes[]={-127,100,56,7,98,-1,39,-128,127,75};\n  byte bBytes[]={27,-15,65,39,100};\n  int aSign=1;\n  int bSign=-1;\n  byte rBytes[]={12,-21,73,56,27};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.remainder(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "remainder of division of two numbers of different signs . the first is positive .", "partition": "test"}
{"idx": "3164", "code": "public void clear(){\n  Arrays.fill(ritems,0,rsize,null);\n  Arrays.fill(pitems,0,psize,null);\n  rsize=0;\n  psize=0;\n}\n", "docstring": "clear both rendering and picking queues .", "partition": "test"}
{"idx": "368", "code": "@Override public void evict(String key){\n  key=safetyKey(key);\n  final File file=new File(cacheDirectory,key);\n  file.delete();\n}\n", "docstring": "delete the object previously saved .", "partition": "test"}
{"idx": "3891", "code": "public int read() throws IOException {\n  int val;\n  if ((val=is.read()) < 0) {\n    return -1;\n  }\nswitch (val & 0xf0) {\ncase 0xc0:\ncase 0xd0:\n    val=((val & 0x1f) << 6) | (is.read() & 0x3f);\n  break;\ncase 0xe0:\nval=((val & 0x0f) << 12) | ((is.read() & 0x3f) << 6) | (is.read() & 0x3f);\nbreak;\ncase 0xf0:\nthrow new UnsupportedEncodingException();\ndefault :\nbreak;\n}\nreturn val;\n}\n", "docstring": "reads a single character .", "partition": "test"}
{"idx": "3648", "code": "void handleSelectionChanged(String selection){\n  if (mDidExpandSelection) {\n    mDidExpandSelection=false;\n    return;\n  }\n  if (selection == null || selection.isEmpty()) {\n    scheduleInvalidTapNotification();\n    if (mSelectionType == SelectionType.TAP) {\n      resetSelectionStates();\n      return;\n    }\n  }\n  if (selection != null && !selection.isEmpty()) {\n    unscheduleInvalidTapNotification();\n  }\n  mSelectedText=selection;\n  if (mWasTapGestureDetected) {\n    mSelectionType=SelectionType.TAP;\n    handleSelection(selection,mSelectionType);\n    mWasTapGestureDetected=false;\n  }\n else {\n    mHandler.handleSelectionModification(selection,mX,mY);\n  }\n}\n", "docstring": "handles a change in the current selection .", "partition": "test"}
{"idx": "1121", "code": "public static Response invalidEntity(ConstraintViolationException e){\n  StringBuilder errorMessage=new StringBuilder();\n  boolean firstPass=true;\n  for (  ConstraintViolation error : e.getConstraintViolations()) {\n    if (!firstPass) {\n      errorMessage.append(\", \");\n    }\n    errorMessage.append(String.format(\"%s %s (was %s)\",error.getPropertyPath(),error.getMessage(),error.getInvalidValue()));\n    firstPass=false;\n  }\n  ExternalException externalException=new ExternalException(ErrorCode.INVALID_ENTITY,errorMessage.toString(),null);\n  return externalException(externalException);\n}\n", "docstring": "return an error response generated by a validation failure , invalid json , etc .", "partition": "test"}
{"idx": "2529", "code": "public void test_filter_001() throws IOException {\n  final File basefile=File.createTempFile(getName(),\"-test\");\n  try {\n    final String basename=basefile.toString();\n    final NameAndExtensionFilter logFilter=new NameAndExtensionFilter(basename,\".log\");\n    assertSameFiles(new File[]{},logFilter.getFiles());\n  }\n  finally {\n    basefile.delete();\n  }\n}\n", "docstring": "test verifies that no files are found using a guarenteed unique basename .", "partition": "test"}
{"idx": "1075", "code": "public MLResults execute(Script script){\n  ScriptExecutor scriptExecutor=new ScriptExecutor(sparkMonitoringUtil);\n  scriptExecutor.setExplain(explain);\n  scriptExecutor.setExplainLevel(explainLevel);\n  scriptExecutor.setStatistics(statistics);\n  scriptExecutor.setInit(scriptHistoryStrings.isEmpty());\n  return execute(script,scriptExecutor);\n}\n", "docstring": "execute a dml or pydml script .", "partition": "test"}
{"idx": "3924", "code": "public void addTerm(SplitCondition condition){\n  terms.add(condition);\n}\n", "docstring": "this method adds a condition to the conjunction in the rule \"'\" s head", "partition": "test"}
{"idx": "4041", "code": "private int insertTestDataLocalDTTypes(PreparedStatement pstmt) throws Exception {\n  pstmt.setInt(1,1);\n  pstmt.setDate(2,testSqlDate);\n  pstmt.setTime(3,testSqlTime);\n  pstmt.setTimestamp(4,testSqlTimeStamp);\n  pstmt.setTimestamp(5,testSqlTimeStamp);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,2);\n  pstmt.setObject(2,testLocalDate);\n  pstmt.setObject(3,testLocalTime);\n  pstmt.setObject(4,testLocalDateTime);\n  pstmt.setObject(5,testLocalDateTime);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,3);\n  pstmt.setObject(2,testLocalDate,JDBCType.DATE);\n  pstmt.setObject(3,testLocalTime,JDBCType.TIME);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.TIMESTAMP);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.TIMESTAMP);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,4);\n  pstmt.setObject(2,testLocalDate,JDBCType.DATE,10);\n  pstmt.setObject(3,testLocalTime,JDBCType.TIME,8);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.TIMESTAMP,20);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.TIMESTAMP,20);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,5);\n  pstmt.setObject(2,testLocalDate,JDBCType.VARCHAR);\n  pstmt.setObject(3,testLocalTime,JDBCType.VARCHAR);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.VARCHAR);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.VARCHAR);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,6);\n  pstmt.setObject(2,testLocalDate,JDBCType.VARCHAR,10);\n  pstmt.setObject(3,testLocalTime,JDBCType.VARCHAR,8);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.VARCHAR,20);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.VARCHAR,20);\n  assertEquals(1,pstmt.executeUpdate());\n  if (pstmt instanceof CallableStatement) {\n    CallableStatement cstmt=(CallableStatement)pstmt;\n    cstmt.setInt(\"id\",7);\n    cstmt.setDate(\"d\",testSqlDate);\n    cstmt.setTime(\"t\",testSqlTime);\n    cstmt.setTimestamp(\"dt\",testSqlTimeStamp);\n    cstmt.setTimestamp(\"ts\",testSqlTimeStamp);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",8);\n    cstmt.setObject(\"d\",testLocalDate);\n    cstmt.setObject(\"t\",testLocalTime);\n    cstmt.setObject(\"dt\",testLocalDateTime);\n    cstmt.setObject(\"ts\",testLocalDateTime);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",9);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.DATE);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.TIME);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.TIMESTAMP);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.TIMESTAMP);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",10);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.DATE,10);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.TIME,8);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.TIMESTAMP,20);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.TIMESTAMP,20);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",11);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.VARCHAR);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.VARCHAR);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.VARCHAR);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.VARCHAR);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",12);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.VARCHAR,10);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.VARCHAR,8);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.VARCHAR,20);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.VARCHAR,20);\n    assertEquals(1,cstmt.executeUpdate());\n    return 12;\n  }\n  return 6;\n}\n", "docstring": "helper method for * setobject * tests . insert data into the given preparedstatement , or any of its subclasses , with the following structure : 1 - ` id ` int 2 - ` d ` date ( or any kind of * char ) 3 - ` t ` time ( or any kind of * char ) 4 - ` dt ` datetime ( or any kind of * char ) 5 - ` ts ` timestamp ( or any kind of * char )", "partition": "test"}
{"idx": "724", "code": "private byte[] toZLIB(RenderedImage image,Color bkg,String colorModel) throws IOException {\n  return ImageGraphics2D.toByteArray(image,ImageConstants.RAW,ImageConstants.ENCODING_FLATE_ASCII85,ImageGraphics2D.getRAWProperties(bkg,colorModel));\n}\n", "docstring": "creates the zlib bytes for pdf images", "partition": "test"}
{"idx": "468", "code": "private boolean fitsAsSingleLine(int col){\n  return (col + singleLineWidth() <= PcalTLAGen.wrapColumn) || (bodyFormulas.sf == null && (prcdFormulas == null || prcdFormulas.size() == 0));\n}\n", "docstring": "returns true iff format ( col ) should return a single - line version of the formula .", "partition": "test"}
{"idx": "2881", "code": "public void recordState(DialogueState state,String name){\n  states.put(name,state);\n  if (!listModel.contains(name)) {\n    int position=name.contains(CURRENT) ? 0 : Math.min(2,listModel.size());\n    listModel.add(position,name);\n  }\n}\n", "docstring": "records a dialogue state in the component and makes it available for display in the network selection list on the left side . the network is associated with a specific name . if the name already exists , the previous network is erased .", "partition": "test"}
{"idx": "2724", "code": "public Dimension minimumLayoutSize(Container target){\nsynchronized (target.getTreeLock()) {\n    Dimension dim=new Dimension(0,0);\n    if ((chart != null) && chart.isVisible()) {\n      Dimension d=chart.getMinimumSize();\n      dim.width=d.width;\n      dim.height=d.height;\n    }\n    if ((xLabel != null) && xLabel.isVisible()) {\n      Dimension d=xLabel.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    if ((yLabel != null) && yLabel.isVisible()) {\n      Dimension d=yLabel.getMinimumSize();\n      dim.width+=d.width + hgap;\n      dim.height=Math.max(d.height,dim.height);\n    }\n    if ((title != null) && title.isVisible()) {\n      Dimension d=title.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    Insets insets=target.getInsets();\n    dim.width+=insets.left + insets.right;\n    dim.height+=insets.top + insets.bottom;\n    return dim;\n  }\n}\n", "docstring": "returns the minimum dimensions needed to layout the components contained in the specified target container .", "partition": "test"}
{"idx": "4100", "code": "private CarbonDictionarySortInfo createColumnSortInfo(CarbonDictionarySortModel[] dictionarySortModels){\n  int[] sortIndex;\n  int[] sortIndexInverted;\n  Arrays.sort(dictionarySortModels);\n  sortIndex=new int[dictionarySortModels.length];\n  sortIndexInverted=new int[dictionarySortModels.length];\n  for (int i=0; i < dictionarySortModels.length; i++) {\n    CarbonDictionarySortModel dictionarySortModel=dictionarySortModels[i];\n    sortIndex[i]=dictionarySortModel.getKey();\n    sortIndexInverted[dictionarySortModel.getKey() - 1]=i + 1;\n  }\n  dictionarySortModels=null;\n  List<Integer> sortIndexList=convertToList(sortIndex);\n  List<Integer> sortIndexInvertedList=convertToList(sortIndexInverted);\n  return new CarbonDictionarySortInfo(sortIndexList,sortIndexInvertedList);\n}\n", "docstring": "the method prepares the sort_index and sort_index_inverted data", "partition": "test"}
{"idx": "4049", "code": "protected Object parseValue(String string){\n  int openParen=string.indexOf(\"(\");\n  String type=string.substring(0,openParen);\n  String value=string.substring(openParen + 1,string.length() - 1);\n  if (type.equals(\"String\")) {\n    return value;\n  }\n else   if (type.equals(\"Float\")) {\n    return new Float(Float.parseFloat(value));\n  }\n else   if (type.equals(\"Integer\")) {\n    return new Integer(Integer.parseInt(value));\n  }\n else   if (type.equals(\"List\")) {\n    StringTokenizer tok=new StringTokenizer(value,\",\");\n    int size=tok.countTokens();\n    int[] values=new int[size];\n    for (int i=0; i < size; i++) {\n      float fval=Float.parseFloat(tok.nextToken());\n      values[i]=Math.round(fval);\n    }\n    return values;\n  }\n else {\n    throw new Error(\"Unknown type: \" + type);\n  }\n}\n", "docstring": "coerces a string into a value .", "partition": "test"}
{"idx": "3009", "code": "public ExtensionQuery(String pluginId,String extensionPointName,String attributeName){\n  this.pluginId=extensionPointName.contains(\".\") ? null : pluginId;\n  this.extensionPointName=extensionPointName;\n  this.attributeName=attributeName;\n}\n", "docstring": "create a new instance .", "partition": "test"}
{"idx": "112", "code": "public static void closeQuiet(@Nullable Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    IOException ignored) {\n    }\n  }\n}\n", "docstring": "closes resource without reporting any error .", "partition": "test"}
{"idx": "1090", "code": "public static String constructNTPtime(long date){\n  long ntpTime=2208988800L;\n  long startTime=(date / SECONDS_TO_MILLISECONDS_CONVERSION_RATE) + ntpTime;\n  return String.valueOf(startTime);\n}\n", "docstring": "construct an ntp time from a date in milliseconds", "partition": "test"}
{"idx": "859", "code": "public static boolean validSkinSpecFile(String fileName){\n  File file=new File(Configuration.skinsDir(),fileName);\n  if (!file.exists() || !file.isFile()) {\n    return false;\n  }\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  try {\n    DocumentBuilder builder=dbf.newDocumentBuilder();\n    Document doc=builder.parse(file);\n    NodeList listOfComponents=doc.getElementsByTagName(UI_ELEMENT);\n    if (listOfComponents.getLength() > 0) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  Exception e) {\n    return false;\n  }\n}\n", "docstring": "checks whether the given path points to a file that is a valid skin specification .", "partition": "test"}
{"idx": "625", "code": "private void mapRequestToResponses(Matcher<Request> requestMatcher,ResponseSource responses){\n  mappings.add(new MatcherResponseSourcePair(requestMatcher,responses));\n}\n", "docstring": "set up a reaction to requests matching certain criteria . the supplied responsesource will be invoked for each request that matches the supplied matcher .", "partition": "test"}
{"idx": "3657", "code": "private void Legends(List<String> legends_list,List<Integer> color_code_list){\n  textPaint.setColor(Color.BLACK);\n  textPaint.setTextSize(20f);\n  int left=(int)(graphwidth * 0.1);\n  for (int i=0; i < legends_list.size(); i++) {\n    String label=legends_list.get(i);\n    float text_width=textPaint.measureText(label,0,label.length());\n    int color=color_code_list.get(i);\n    if (!((graphwidth - legendLeft) > (text_width + 60))) {\n      legendTop-=60;\n      legendLeft=left;\n    }\n    addLegends(canvas,color,legendTop,legendLeft,legendRight,legendBottom,label);\n    legendLeft+=((int)text_width + 60);\n  }\n}\n", "docstring": "this function calculates the position for each legend", "partition": "test"}
{"idx": "1430", "code": "private static String readName(DataInputStream dis,byte data[]) throws IOException {\n  int c=dis.readUnsignedByte();\n  if ((c & 0xc0) == 0xc0) {\n    c=((c & 0x3f) << 8) + dis.readUnsignedByte();\n    HashSet<Integer> jumps=new HashSet<Integer>();\n    jumps.add(c);\n    return readName(data,c,jumps);\n  }\n  if (c == 0) {\n    return \"\";\n  }\n  byte b[]=new byte[c];\n  dis.readFully(b);\n  String s=IDN.toUnicode(new String(b));\n  String t=readName(dis,data);\n  if (t.length() > 0) {\n    s=s + \".\" + t;\n  }\n  return s;\n}\n", "docstring": "parse a domain name starting at the current offset and moving the input stream pointer past this domain name ( even if cross references occure ) .", "partition": "test"}
{"idx": "2017", "code": "@SuppressWarnings(\"purity\") private static boolean isRegex(String s){\n  try {\n    Pattern.compile(s);\n  }\n catch (  PatternSyntaxException e) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "this method is a copy of regexutil . isregex . we cannot directly use regexutil , because it uses type annotations which cannot be used in ides ( yet ) .", "partition": "test"}
{"idx": "609", "code": "protected List<DecompoundedWord> makeSplit(String aWord){\n  List<DecompoundedWord> result=new ArrayList<DecompoundedWord>();\n  for (int i=0; i < aWord.length(); i++) {\n    String leftWord=aWord.substring(0,i + 1);\n    String rightWord=aWord.substring(i + 1);\n    boolean leftGood=dict.contains(leftWord) && leftWord.length() >= minWordLength;\n    boolean rightGood=rightWord.length() > minRestLength || rightWord.length() == 0;\n    if (leftGood && rightGood) {\n      DecompoundedWord split=DecompoundedWord.createFromString(leftWord + \"+\" + rightWord);\n      split.setSplitPos(i);\n      result.add(split);\n    }\n    for (    String morpheme : morphemes.getAll()) {\n      try {\n        String leftWithoutMorpheme=leftWord.substring(0,leftWord.length() - morpheme.length());\n        if (leftWord.endsWith(morpheme) && dict.contains(leftWithoutMorpheme) && rightGood) {\n          DecompoundedWord split=DecompoundedWord.createFromString(leftWithoutMorpheme + \"(\" + morpheme+ \")+\"+ rightWord);\n          split.setSplitPos(i);\n          result.add(split);\n        }\n      }\n catch (      StringIndexOutOfBoundsException e) {\n        continue;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "splits a word in two word .", "partition": "test"}
{"idx": "1915", "code": "public static boolean save(File file,String content){\n  boolean result;\n  BufferedWriter writer;\n  writer=null;\n  try {\n    writer=new BufferedWriter(new FileWriter(file));\n    writer.write(content);\n    writer.flush();\n    result=true;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    result=false;\n  }\n finally {\n    if (writer != null) {\n      try {\n        writer.close();\n      }\n catch (      Exception e) {\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "saves the content to a file .", "partition": "test"}
{"idx": "1439", "code": "public static boolean isSupportedAddRPProtectionVirtualPoolChange(Volume volume,VirtualPool currentVpool,VirtualPool newVpool,DbClient dbClient,StringBuffer notSuppReasonBuff){\n  s_logger.info(String.format(\"Checking isSupportedAddRPProtectionVirtualPoolChange from [%s] to [%s]...\",currentVpool.getLabel(),newVpool.getLabel()));\n  if (isSameVirtualPool(currentVpool,newVpool,notSuppReasonBuff)) {\n    return false;\n  }\n  if (volume.checkForRp() || VirtualPool.vPoolSpecifiesProtection(currentVpool)) {\n    notSuppReasonBuff.append(\"Can\\'t add RecoverPoint Protection since it already exists.\");\n    return false;\n  }\n  if (!VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && VirtualPool.vPoolSpecifiesRPVPlex(newVpool)) {\n    notSuppReasonBuff.append(\"Can\\'t add RecoverPoint+VPLEX Protection directly to non-VPLEX volume. Import to VPLEX first.\");\n    return false;\n  }\n  if (VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && !VirtualPool.vPoolSpecifiesHighAvailabilityDistributed(currentVpool) && VirtualPool.vPoolSpecifiesMetroPoint(newVpool)) {\n    notSuppReasonBuff.append(\"Can\\'t add MetroPoint Protection directly to VPLEX Local volume. \" + \"Upgrade from VPLEX Local to VPLEX Distributed first.\");\n    return false;\n  }\n  String[] include=new String[]{TYPE,VARRAYS,REF_VPOOL,MIRROR_VPOOL,FAST_EXPANSION,ACLS,INACTIVE,PROTOCOLS,PROVISIONING_TYPE,USE_MATCHED_POOLS,ARRAY_INFO,DRIVE_TYPE,AUTO_TIER_POLICY_NAME,HOST_IO_LIMIT_IOPS,HOST_IO_LIMIT_BANDWIDTH,VMAX_COMPRESSION_ENABLED,IS_THIN_VOLUME_PRE_ALLOCATION_ENABLED,ASSIGNED_STORAGE_POOLS};\n  Map<String,Change> changes=analyzeChanges(currentVpool,newVpool,include,null,null);\n  if (!changes.isEmpty()) {\n    notSuppReasonBuff.append(\"These target virtual pool differences are invalid: \");\n    fillInNotSupportedReasons(changes,notSuppReasonBuff);\n    return false;\n  }\n  include=new String[]{PROTECTION_VARRAY_SETTINGS};\n  changes=analyzeChanges(currentVpool,newVpool,include,null,null);\n  if (changes.isEmpty()) {\n    notSuppReasonBuff.append(\"These target virtual pool differences are required: \");\n    fillInNotSupportedReasons(changes,notSuppReasonBuff);\n    return false;\n  }\n  if (VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && (VirtualPool.vPoolSpecifiesRPVPlex(newVpool) || VirtualPool.vPoolSpecifiesMetroPoint(newVpool))) {\n    VirtualPoolChangeOperationEnum op=vplexCommonChecks(volume,currentVpool,newVpool,dbClient,notSuppReasonBuff,include);\n    if (op == null || !op.equals(VirtualPoolChangeOperationEnum.RP_PROTECTED)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "determines if the volume qualifies for rp protection . ( and if not , why not )", "partition": "test"}
{"idx": "3613", "code": "protected void work(final IResource resource,final List<WorkItem> resources,IProgressMonitor monitor){\n  IPreferenceStore store=FindbugsPlugin.getPluginPreferences(getProject());\n  boolean runAsJob=store.getBoolean(FindBugsConstants.KEY_RUN_ANALYSIS_AS_EXTRA_JOB);\n  FindBugsJob fbJob=new StartedFromBuilderJob(\"Finding bugs in \" + resource.getName() + \"...\",resource,resources);\n  if (runAsJob) {\n    if (DEBUG) {\n      FindbugsPlugin.log(\"cancelSimilarJobs\");\n    }\n    FindBugsJob.cancelSimilarJobs(fbJob);\n    if (DEBUG) {\n      FindbugsPlugin.log(\"scheduleAsSystem\");\n    }\n    fbJob.scheduleAsSystem();\n    if (DEBUG) {\n      FindbugsPlugin.log(\"done scheduleAsSystem\");\n    }\n  }\n else {\n    if (DEBUG) {\n      FindbugsPlugin.log(\"running fbJob\");\n    }\n    fbJob.run(monitor);\n    if (DEBUG) {\n      FindbugsPlugin.log(\"done fbJob\");\n    }\n  }\n}\n", "docstring": "run a findbugs analysis on the given resource as build job but not delaying the current java build", "partition": "test"}
{"idx": "2124", "code": "public static void trim(CharSequence aText,int[] aSpan){\n  int begin=aSpan[0];\n  int end=aSpan[1] - 1;\n  CharSequence data=aText;\n  while ((begin < (data.length() - 1)) && trimChar(data.charAt(begin))) {\n    begin++;\n  }\n  while ((end > 0) && trimChar(data.charAt(end))) {\n    end--;\n  }\n  end++;\n  aSpan[0]=begin;\n  aSpan[1]=end;\n}\n", "docstring": "remove trailing or leading whitespace from the annotation .", "partition": "test"}
{"idx": "1057", "code": "public void createClusterAsync(final String projectId,final ClusterCreateSpec clusterCreateSpec,final FutureCallback<Task> responseCallback) throws IOException {\n  String path=String.format(\"%s/%s/clusters\",getBasePath(),projectId);\n  createObjectAsync(path,serializeObjectAsJson(clusterCreateSpec),responseCallback);\n}\n", "docstring": "create a cluster in the specified project .", "partition": "test"}
{"idx": "2531", "code": "public void addCommands(PDFPage page,Matrix extra){\nsynchronized (commands) {\n    addPush();\n    if (extra != null) {\n      addXform(extra);\n    }\n    commands.addAll(page.getCommands());\n    addPop();\n  }\n  updateImages();\n}\n", "docstring": "add a collection of commands to the page list . this is probably invoked as the result of an xobject \"'\" do \"'\" command , or through a type 3 font .", "partition": "test"}
{"idx": "998", "code": "@Override public void update(DefaultApplicationState transState){\n  newCheckpoint(transState.getState(),transState.getStateHash(),transState.getLastCheckpointCID());\n  setLastCheckpointCID(transState.getLastCheckpointCID());\n}\n", "docstring": "updates this log , according to the information contained in the transferablestate object", "partition": "test"}
{"idx": "2245", "code": "@Override public void mouseEntered(MouseEvent evt){\n  delegate.mouseMoved(evt);\n}\n", "docstring": "pass mouseevent straight through to delegate", "partition": "test"}
{"idx": "3843", "code": "private int accept(FileDescriptor ssfd,FileDescriptor newfd,InetSocketAddress[] isaa) throws IOException {\n  return accept0(ssfd,newfd,isaa);\n}\n", "docstring": "accept a connection on a socket .", "partition": "test"}
{"idx": "2087", "code": "public static Charset forName(String charsetName){\n  return forName(charsetName,null);\n}\n", "docstring": "safely gets charset for the specified name", "partition": "test"}
{"idx": "2498", "code": "public static String findPreferredIDP(String realm,HttpServletRequest request){\n  if (request == null) {\n    return null;\n  }\n  String succinctID=request.getParameter(IFSConstants.PROVIDER_ID_KEY);\n  if ((succinctID == null) || succinctID.length() == 0) {\n    debug.message(\"FSUtils.findPreferredIDP::Pref IDP not found.\");\n    return null;\n  }\n  succinctID=succinctID.trim();\n  String preferredSuccinctId=null;\n  StringTokenizer st=new StringTokenizer(succinctID,\" \");\n  while (st.hasMoreTokens()) {\n    preferredSuccinctId=st.nextToken();\n    if ((preferredSuccinctId.length() < 28) && st.hasMoreTokens()) {\n      preferredSuccinctId=preferredSuccinctId + \"+\" + st.nextToken();\n    }\n  }\n  preferredSuccinctId=SAMLUtils.byteArrayToString(Base64.decode(preferredSuccinctId));\n  return getProviderIDFromSuccinctID(realm,preferredSuccinctId);\n}\n", "docstring": "finds the preferred idp from the httpservletrequest .", "partition": "test"}
{"idx": "1596", "code": "private long acquireWrite(boolean interruptible,long deadline){\n  WNode node=null, p;\n  for (int spins=-1; ; ) {\n    long m, s, ns;\n    if ((m=(s=state) & ABITS) == 0L) {\n      if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT))       return ns;\n    }\n else     if (spins < 0)     spins=(m == WBIT && wtail == whead) ? SPINS : 0;\n else     if (spins > 0) {\n      if (LockSupport.nextSecondarySeed() >= 0)       --spins;\n    }\n else     if ((p=wtail) == null) {\n      WNode hd=new WNode(WMODE,null);\n      if (U.compareAndSwapObject(this,WHEAD,null,hd))       wtail=hd;\n    }\n else     if (node == null)     node=new WNode(WMODE,p);\n else     if (node.prev != p)     node.prev=p;\n else     if (U.compareAndSwapObject(this,WTAIL,p,node)) {\n      p.next=node;\n      break;\n    }\n  }\n  for (int spins=-1; ; ) {\n    WNode h, np, pp;\n    int ps;\n    if ((h=whead) == p) {\n      if (spins < 0)       spins=HEAD_SPINS;\n else       if (spins < MAX_HEAD_SPINS)       spins<<=1;\n      for (int k=spins; ; ) {\n        long s, ns;\n        if (((s=state) & ABITS) == 0L) {\n          if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT)) {\n            whead=node;\n            node.prev=null;\n            return ns;\n          }\n        }\n else         if (LockSupport.nextSecondarySeed() >= 0 && --k <= 0)         break;\n      }\n    }\n else     if (h != null) {\n      WNode c;\n      Thread w;\n      while ((c=h.cowait) != null) {\n        if (U.compareAndSwapObject(h,WCOWAIT,c,c.cowait) && (w=c.thread) != null)         U.unpark(w);\n      }\n    }\n    if (whead == h) {\n      if ((np=node.prev) != p) {\n        if (np != null)         (p=np).next=node;\n      }\n else       if ((ps=p.status) == 0)       U.compareAndSwapInt(p,WSTATUS,0,WAITING);\n else       if (ps == CANCELLED) {\n        if ((pp=p.prev) != null) {\n          node.prev=pp;\n          pp.next=node;\n        }\n      }\n else {\n        long time;\n        if (deadline == 0L)         time=0L;\n else         if ((time=deadline - System.nanoTime()) <= 0L)         return cancelWaiter(node,node,false);\n        Thread wt=Thread.currentThread();\n        U.putObject(wt,PARKBLOCKER,this);\n        node.thread=wt;\n        if (p.status < 0 && (p != h || (state & ABITS) != 0L) && whead == h && node.prev == p)         U.park(false,time);\n        node.thread=null;\n        U.putObject(wt,PARKBLOCKER,null);\n        if (interruptible && Thread.interrupted())         return cancelWaiter(node,node,true);\n      }\n    }\n  }\n}\n", "docstring": "see above for explanation .", "partition": "test"}
{"idx": "2371", "code": "public void reset(){\n  Timber.i(\"resetting QueuedMediaPlayer...\");\n  mCurrentPlayer.reset();\n  mNextPlayer.reset();\n  mQueue=Collections.emptyList();\n  mQueueIndex=0;\n  mRequestedSeekPosition=0;\n  mPlayWhenPrepared=false;\n}\n", "docstring": "resets both mediaplayers , and clears the queue . this makes the current instance act like a new one , retaining any attached callbacks and other properties unrelated to the queue .", "partition": "test"}
{"idx": "1310", "code": "public void andWith(List<QueryPredicate> predicates){\n  children.addAll(predicates);\n}\n", "docstring": "adds multiple predicates that much be met by the vertices .", "partition": "test"}
{"idx": "1929", "code": "public final int decrementAndGet(){\n  return unsafe.getAndAddInt(this,valueOffset,-1) - 1;\n}\n", "docstring": "atomically decrements by one the current value .", "partition": "test"}
{"idx": "3578", "code": "protected void remove(int itemPosition){\n  if (itemPosition >= 0 && itemPosition < getItemCount()) {\n    list.remove(itemPosition);\n  }\n}\n", "docstring": "remove an item from the adapter \"'\" s list .", "partition": "test"}
{"idx": "1067", "code": "public static String buildResponseUrl(String tenant,LogoutState logoutState){\n  String retval=null;\n  LogoutResponse samlResponse=logoutState.generateResponseForTenant(tenant,logoutState.getMessageSource(),logoutState.getLocale());\n  if (samlResponse != null) {\n    log.info(\"SAML SLO Response is \" + samlResponse.toString());\n    retval=logoutState.generateResponseUrlForTenant(samlResponse,tenant);\n  }\n  return retval;\n}\n", "docstring": "helper method to generate logoutresponse redirect url", "partition": "test"}
{"idx": "4110", "code": "public List<LocalTime> top(int n){\n  List<LocalTime> top=new ArrayList<>();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values,ReverseIntComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(PackedLocalTime.asLocalTime(values[i]));\n  }\n  return top;\n}\n", "docstring": "returns the largest ( \" top \" ) n values in the column", "partition": "test"}
{"idx": "3417", "code": "private void sortAndCollapse(){\n  Collections.sort(mSpans);\n  mAddsSinceSort=0;\n  Iterator iter=mSpans.iterator();\n  Span span=null;\n  if (iter.hasNext()) {\n    span=(Span)iter.next();\n  }\n  while (iter.hasNext()) {\n    Span nextSpan=(Span)iter.next();\n    if (span.subsume(nextSpan)) {\n      iter.remove();\n    }\n else {\n      span=nextSpan;\n    }\n  }\n}\n", "docstring": "sort the spans in ascending order by their start position . after the spans are sorted collapse any spans that intersect into a single span . the result is a sorted , non - overlapping list of spans .", "partition": "test"}
{"idx": "229", "code": "public void testCase17(){\n  byte aBytes[]={-127,100,56,7,98,-1,39,-128,127,75};\n  byte bBytes[]={27,-15,65,39,100};\n  int aSign=1;\n  int bSign=1;\n  byte rBytes[]={12,-21,73,56,27};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.remainder(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "remainder of division of two positive numbers", "partition": "test"}
{"idx": "2564", "code": "public void start(){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Start address book monitoring\");\n  }\n  mCleanupExecutor=Executors.newSingleThreadExecutor();\n  if (!mObserverIsRegistered) {\n    mContactsContractObserver=new ContactsContractObserver(new Handler());\n    mContactsContractCursor=mContentResolver.query(Phone.CONTENT_URI,null,null,null,null);\n    CursorUtil.assertCursorIsNotNull(mContactsContractCursor,Phone.CONTENT_URI);\n    mContactsContractCursor.registerContentObserver(mContactsContractObserver);\n    mObserverIsRegistered=true;\n  }\n}\n", "docstring": "start address book monitoring", "partition": "test"}
{"idx": "2376", "code": "@Override public boolean execute(@NotNull PsiElement pe,@NotNull ResolveState state){\n  if (pe instanceof PsiVariable) {\n    final PsiVariable pvar=(PsiVariable)pe;\n    if (!myStaticSensitiveFlag || !myStaticScopeFlag || pvar.hasModifierProperty(PsiModifier.STATIC)) {\n      if (check(pvar,state)) {\n        myResultList.add(pvar);\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "always return true since we wanna get all vars in scope", "partition": "test"}
{"idx": "1440", "code": "private void writeObject(ObjectOutputStream oos) throws IOException {\n  oos.defaultWriteObject();\n  boolean writeFont=(f != OMText.DEFAULT_FONT);\n  oos.writeBoolean(writeFont);\n  if (writeFont) {\n    oos.writeObject(f.getName());\n    oos.writeInt(f.getSize());\n    oos.writeInt(f.getStyle());\n  }\n  writeStroke(oos,stroke,OMGraphic.BASIC_STROKE);\n  writeStroke(oos,textMatteStroke,DEFAULT_TEXT_MATTE_STROKE);\n}\n", "docstring": "write this object to a stream .", "partition": "test"}
{"idx": "3533", "code": "protected abstract void addFile(String relativeFilename) throws CommandException ;\n", "docstring": "runs the dvcs command for adding a new file , e . g . \"'\" git add \"'\" .", "partition": "test"}
{"idx": "4101", "code": "private void addFeature(JsonNode feature,int index){\n  PointFeature feat=null;\n  try {\n    feat=PointFeature.fromJsonNode(feature);\n  }\n catch (  EmptyPolygonException e) {\n    LOG.warn(\"Empty MultiPolygon, skipping.\");\n    return;\n  }\ncatch (  UnsupportedGeometryException e) {\n    LOG.warn(e.message);\n    return;\n  }\n  if (feat == null) {\n    return;\n  }\n  addFeature(feat,index);\n}\n", "docstring": "add one geojson feature to this freeformpointset from a jackson node tree . com . bedatadriven . geojson only exposed its streaming geometry parser as a public method . i made its tree parser public as well . geotools also has a geojson parser called geometryjson ( which otp wraps in geojsondeserializer ) but it consumes straight text , not a jackson model or streaming parser .", "partition": "test"}
{"idx": "2691", "code": "protected final void writeC(ByteBuffer buf,int value){\n  buf.put((byte)value);\n}\n", "docstring": "write byte to buffer .", "partition": "test"}
{"idx": "3387", "code": "void readFile(File file) throws org.jdom2.JDOMException, java.io.IOException {\n  XmlFile xf=new XmlFile(){\n  }\n;\n  xf.rootFromFile(file);\n}\n", "docstring": "ask sax to read and verify a file", "partition": "test"}
{"idx": "3910", "code": "private void refreshChallengeCounts(){\n  mDueChallengeCounts=mDueChallengeLogic.getDueChallengeCounts(mCategories);\n}\n", "docstring": "reloads the due challenge counts from the database .", "partition": "test"}
{"idx": "1785", "code": "private static Component findByName(Container root,String componentName){\n  if (verbose) {\n    log(\"findByName(\" + root + \", \"+ componentName+ \")\");\n  }\n  int count=root.getComponentCount();\n  for (int iter=0; iter < count; iter++) {\n    Component c=root.getComponentAt(iter);\n    String n=c.getName();\n    if (n != null && n.equals(componentName)) {\n      return c;\n    }\n    if (c instanceof Container) {\n      c=findByName((Container)c,componentName);\n      if (c != null) {\n        return c;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "finds a component with the given name , works even with ui \"'\" s that weren \"'\" t created with the gui builder", "partition": "test"}
{"idx": "1215", "code": "static boolean isPackageAccess(final int modifiers){\n  return (modifiers & ACCESS_TEST) == 0;\n}\n", "docstring": "returns whether a given set of modifiers implies package access .", "partition": "test"}
{"idx": "38", "code": "public static String constructQueueRedisKey(String queueName,String shardName,int priority,PinLaterJobState state){\n  return String.format(\"%s_%s_%s.p%1d_s%1d\",PINLATER_QUEUE_KEY_PREFIX,shardName,queueName,priority,state.getValue());\n}\n", "docstring": "constructs the redis queue sorted set key name given a queue name , shard id and priority .", "partition": "test"}
{"idx": "1812", "code": "private void removeGapsWithEdgeConcentration(int nodesLevel[]){\n  final int temp=m_nodes.size(), temp2=graphMatrix[0].length;\n  int tempCnt=1;\n  for (int n=0; n < temp; n++) {\n    for (int i=0; i < temp2; i++) {\n      if (graphMatrix[n][i] > 0) {\n        if (nodesLevel[i] > nodesLevel[n] + 1) {\n          int tempLevel=nodesLevel[n];\n          boolean tempNodePresent=false;\n          int k=temp;\n          int tempnode=n;\n          while (tempLevel < nodesLevel[i] - 1) {\n            tempNodePresent=false;\n            for (; k < graphMatrix.length; k++) {\n              if (graphMatrix[tempnode][k] > 0) {\n                tempNodePresent=true;\n                break;\n              }\n            }\n            if (tempNodePresent) {\n              tempnode=k;\n              k=k + 1;\n              tempLevel++;\n            }\n else {\n              if (tempnode != n) {\n                tempnode=k - 1;\n              }\n              break;\n            }\n          }\n          if (m_nodes.get(tempnode).nodeType == SINGULAR_DUMMY) {\n            m_nodes.get(tempnode).nodeType=PLURAL_DUMMY;\n          }\n          if (tempNodePresent) {\n            graphMatrix[tempnode][i]=graphMatrix[n][i];\n            graphMatrix[i][tempnode]=-graphMatrix[n][i];\n            graphMatrix[n][i]=0;\n            graphMatrix[i][n]=0;\n            continue;\n          }\n          int len=graphMatrix.length;\n          int tempMatrix[][]=new int[graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)][graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)];\n          int level=nodesLevel[tempnode] + 1;\n          copyMatrix(graphMatrix,tempMatrix);\n          String s1=new String(\"S\" + tempCnt++);\n          m_nodes.add(new GraphNode(s1,s1,SINGULAR_DUMMY));\n          int temp3[]=new int[nodeLevels[level].length + 1];\n          System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);\n          temp3[temp3.length - 1]=m_nodes.size() - 1;\n          nodeLevels[level]=temp3;\n          temp3=new int[m_nodes.size() + 1];\n          System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);\n          temp3[m_nodes.size() - 1]=level;\n          nodesLevel=temp3;\n          level++;\n          int m;\n          for (m=len; m < len + nodesLevel[i] - nodesLevel[tempnode] - 1 - 1; m++) {\n            String s2=new String(\"S\" + tempCnt++);\n            m_nodes.add(new GraphNode(s2,s2,SINGULAR_DUMMY));\n            temp3=new int[nodeLevels[level].length + 1];\n            System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);\n            temp3[temp3.length - 1]=m_nodes.size() - 1;\n            nodeLevels[level]=temp3;\n            temp3=new int[m_nodes.size() + 1];\n            System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);\n            temp3[m_nodes.size() - 1]=level;\n            nodesLevel=temp3;\n            level++;\n            tempMatrix[m][m + 1]=tempMatrix[n][i];\n            if (m > len) {\n              tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];\n            }\n          }\n          tempMatrix[m][i]=tempMatrix[n][i];\n          tempMatrix[tempnode][len]=tempMatrix[n][i];\n          tempMatrix[len][tempnode]=-1 * tempMatrix[n][i];\n          tempMatrix[i][m]=-1 * tempMatrix[n][i];\n          if (m > len) {\n            tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];\n          }\n          tempMatrix[n][i]=0;\n          tempMatrix[i][n]=0;\n          graphMatrix=tempMatrix;\n        }\n else {\n          graphMatrix[i][n]=-1 * graphMatrix[n][i];\n        }\n      }\n    }\n  }\n}\n", "docstring": "this method removes gaps from the graph . it tries to minimise the number of edges by concentrating multiple dummy nodes from the same parent and on the same vertical level into one . it takes as an argument of int [ ", "partition": "test"}
{"idx": "3564", "code": "void addReporter(String textReporter,int xx,int yy){\n  ReporterIcon l=new ReporterIcon(this);\n  l.setReporter(textReporter);\n  l.setLocation(xx,yy);\n  l.setSize(l.getPreferredSize().width,l.getPreferredSize().height);\n  l.setDisplayLevel(LABELS);\n  setDirty(true);\n  putItem(l);\n}\n", "docstring": "add a reporter icon to the panel", "partition": "test"}
{"idx": "930", "code": "public static byte[] readInputStream(InputStream i) throws IOException {\n  ByteArrayOutputStream b=new ByteArrayOutputStream();\n  copy(i,b);\n  return b.toByteArray();\n}\n", "docstring": "converts a small input stream to a byte array", "partition": "test"}
{"idx": "395", "code": "public static void writeToFile(String content,File dstFile) throws IOException {\n  BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(dstFile,false));\n  bufferedWriter.write(content);\n  bufferedWriter.close();\n}\n", "docstring": "save string into the file", "partition": "test"}
{"idx": "2193", "code": "private boolean isLatestDssKeystore(TSLParserResult parseResult){\n  List<String> englishSchemeInformationURIs=parseResult.getEnglishSchemeInformationURIs();\n  return englishSchemeInformationURIs.contains(ojUrl);\n}\n", "docstring": "this method checks if the oj url is still correct . if not , the dss keystore is outdated .", "partition": "test"}
{"idx": "3742", "code": "public void removeTreeModelListener(TreeModelListener l){\n  treeModelListeners.removeElement(l);\n}\n", "docstring": "removes a listener previously added with addtreemodellistener ( ) .", "partition": "test"}
{"idx": "1331", "code": "public boolean equalsIgnoreCase(final StrBuilder other){\n  if (this == other) {\n    return true;\n  }\n  if (this.size != other.size) {\n    return false;\n  }\n  final char thisBuf[]=this.buffer;\n  final char otherBuf[]=other.buffer;\n  for (int i=size - 1; i >= 0; i--) {\n    final char c1=thisBuf[i];\n    final char c2=otherBuf[i];\n    if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "checks the contents of this builder against another to see if they contain the same character content ignoring case .", "partition": "test"}
{"idx": "3886", "code": "public void testQuorumSucceed(){\n  quorum.succeed();\n  quorum.fail();\n  assertEquals(callbackResult.get(),0);\n  quorum.fail();\n  quorum.succeed();\n  assertEquals(callbackResult.get(),1);\n}\n", "docstring": "tests a successful quorum .", "partition": "test"}
{"idx": "632", "code": "private void schedulePlaylistSave(){\n  if (!mPlaylistLoading) {\n    if (mPlaylistSavePending.compareAndSet(false,true)) {\n      mThreadPoolManager.scheduleOnce(new PlaylistSaveTask(),2,TimeUnit.SECONDS);\n    }\n  }\n}\n", "docstring": "schedules a playlist save task . subsequent calls to this method will be ignored until the save event occurs , thus limiting repetitive playlist saving to a minimum .", "partition": "test"}
{"idx": "3163", "code": "public boolean isValid(World world){\n  return true;\n}\n", "docstring": "used to determine if a task is valid . this is called each time the task is accessed . it checks if the sender / creator is valid . it is crustal that the sender is valid , because task are stored in the sender . if this returns false the task is usually discarded .", "partition": "test"}
{"idx": "682", "code": "public void onMotion(MotionEvent event,Interaction iact){\n}\n", "docstring": "notifies listener of a mouse motion event . a motion event is dispatched when no button is currently pressed , in an isolated \" one shot \" interaction , and always goes to the layer hit by the event coordinates .", "partition": "test"}
{"idx": "1145", "code": "public void test_BSBM_Q1_noSolutions() throws Exception {\n  final TestHelper helper=new TestHelper(\"rto/BSBM-Q1\",\"rto/BSBM-Q1.rq\",new String[]{},\"rto/BSBM-Q1-noSolutions.srx\");\n  assertSameJoinOrder(new int[]{2,1,3,4,5},helper);\n}\n", "docstring": "test of bsbm q1 against an empty data set . there are no solutions in the data .", "partition": "test"}
{"idx": "3183", "code": "protected List<String> prepareSortKeyStatements(List<SortKey> sortKeys){\n  List<String> keys=new ArrayList<String>();\n  for (int i=0; i < sortKeys.size(); i++) {\n    SortKey sortKey=sortKeys.get(i);\n    keys.add(explicitMapping.getDbColumnName(sortKey.getField()) + (sortKey.isAscendingOrder() ? \" ASC\" : \" DESC\"));\n  }\n  return keys;\n}\n", "docstring": "loops through sort keys constructing the key statements .", "partition": "test"}
{"idx": "3238", "code": "private static boolean compareParam(String jdiffParam,Type reflectionParamType){\n  if (jdiffParam == null) {\n    return false;\n  }\n  String reflectionParam=typeToString(reflectionParamType);\n  if (jdiffParam.equals(reflectionParam)) {\n    return true;\n  }\n  int jdiffParamEndOffset=jdiffParam.indexOf(\"...\");\n  int reflectionParamEndOffset=reflectionParam.indexOf(\"[]\");\n  if (jdiffParamEndOffset != -1 && reflectionParamEndOffset != -1) {\n    jdiffParam=jdiffParam.substring(0,jdiffParamEndOffset);\n    reflectionParam=reflectionParam.substring(0,reflectionParamEndOffset);\n    return jdiffParam.equals(reflectionParam);\n  }\n  return false;\n}\n", "docstring": "compares the parameter from the api and the parameter from reflection .", "partition": "test"}
{"idx": "3866", "code": "@Ignore @Test public void test_DR_PGS_4NODES_2NODESDOWN_Validate_Receiver() throws Exception {\n  Integer lnPort=(Integer)vm0.invoke(null);\n  Integer nyPort=(Integer)vm1.invoke(null);\n  createCacheInVMs(nyPort,vm2,vm3);\n  createReceiverInVMs(vm2,vm3);\n  createCacheInVMs(lnPort,vm4,vm5,vm6,vm7);\n  vm4.invoke(null);\n  vm5.invoke(null);\n  vm6.invoke(null);\n  vm7.invoke(null);\n  vm4.invoke(null);\n  vm5.invoke(null);\n  vm6.invoke(null);\n  vm7.invoke(null);\n  startSenderInVMs(\"ln\",vm4,vm5,vm6,vm7);\n  vm2.invoke(null);\n  vm3.invoke(null);\n  vm4.invoke(null);\n  vm5.invoke(null);\n  vm6.invoke(null);\n  vm7.invoke(null);\n  Thread.sleep(60000);\n{\n    AsyncInvocation inv1=vm7.invokeAsync(null);\n    Thread.sleep(1000);\n    AsyncInvocation inv2=vm4.invokeAsync(null);\n    Thread.sleep(2000);\n    AsyncInvocation inv3=vm6.invokeAsync(null);\n    Thread.sleep(1500);\n    AsyncInvocation inv4=vm5.invokeAsync(null);\n    try {\n      inv1.join();\n      inv2.join();\n      inv3.join();\n      inv4.join();\n    }\n catch (    Exception e) {\n      Assert.fail(\"UnExpected Exception\",e);\n    }\n  }\n  vm6.invoke(null);\n  vm7.invoke(null);\n  vm2.invoke(null);\n}\n", "docstring": "below test is disabled intentionally 1 > in this release 8 . 0 , for rolling upgrade support queue name is changed to old style 2 > common parallel sender for different non colocated regions is not supported in 8 . 0 so no need to bother about parallelgatewaysenderqueue # convertpathtoname 3 > we have to enabled it in next release 4 > version based rolling upgrade support should be provided . based on the version of the gemfire qstring should be used between 8 . 0 and version prior to 8 . 0", "partition": "test"}
{"idx": "1411", "code": "void scramble(){\n  initialSize=getSize();\n  int a[]=new int[initialSize.height / 2];\n  double f=initialSize.width / (double)a.length;\n  for (int i=a.length; --i >= 0; ) {\n    a[i]=(int)(i * f);\n  }\n  for (int i=a.length; --i >= 0; ) {\n    int j=(int)(i * Math.random());\n    int t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n  }\n  arr=a;\n}\n", "docstring": "fill the array with random numbers from 0 . . n - 1 .", "partition": "test"}
{"idx": "2476", "code": "public static AttackStatus calculatePhysicalStatus(Creature attacker,Creature attacked,boolean isMainHand){\n  return calculatePhysicalStatus(attacker,attacked,isMainHand,0,100,false,false);\n}\n", "docstring": "manage attack status rate", "partition": "test"}
{"idx": "3102", "code": "@Override public void addShutdownWindow(final Window window){\n  if (m_isShutDown) {\n    closeWindow(window);\n    return;\n  }\nsynchronized (this) {\n    if (m_isShutDown) {\n      closeWindow(window);\n      return;\n    }\n    m_windowsToCloseOnShutdown.add(window);\n  }\n}\n", "docstring": "add a latch that will be released when the game shuts down .", "partition": "test"}
{"idx": "2189", "code": "@Override public String append(String path,InputStream is) throws MalformedURLException, IOException, AuthenticationException {\n  String resp=null;\n  ensureValidToken();\n  String spec=MessageFormat.format(\"/webhdfs/v1/{0}?op=APPEND&user.name={1}\",URLUtil.encodePath(path),this.principal);\n  String redirectUrl=null;\n  HttpURLConnection conn=authenticatedURL.openConnection(new URL(new URL(httpfsUrl),spec),token);\n  conn.setRequestMethod(\"POST\");\n  conn.setInstanceFollowRedirects(false);\n  conn.connect();\n  logger.info(\"Location:\" + conn.getHeaderField(\"Location\"));\n  resp=result(conn,true);\n  if (conn.getResponseCode() == 307)   redirectUrl=conn.getHeaderField(\"Location\");\n  conn.disconnect();\n  if (redirectUrl != null) {\n    conn=authenticatedURL.openConnection(new URL(redirectUrl),token);\n    conn.setRequestMethod(\"POST\");\n    conn.setDoOutput(true);\n    conn.setDoInput(true);\n    conn.setUseCaches(false);\n    conn.setRequestProperty(\"Content-Type\",\"application/octet-stream\");\n    final int _SIZE=is.available();\n    conn.setRequestProperty(\"Content-Length\",\"\" + _SIZE);\n    conn.setFixedLengthStreamingMode(_SIZE);\n    conn.connect();\n    OutputStream os=conn.getOutputStream();\n    copy(is,os);\n    is.close();\n    os.close();\n    resp=result(conn,true);\n    conn.disconnect();\n  }\n  return resp;\n}\n", "docstring": "curl - i - x post \" http : / / < host > : < port > / webhdfs / v1 / < path > ? op = append [ & buffersize = < int > ", "partition": "test"}
{"idx": "3064", "code": "public boolean remove(ImageInfo object){\n  final int location=getLocation(object);\n  final boolean removed=data.remove(object);\n  notifyItemRemoved(location);\n  return removed;\n}\n", "docstring": "removes the first occurrence of the specified object from the data .", "partition": "test"}
{"idx": "2929", "code": "private void processUnprocessed(){\n  boolean clean_processings=Boolean.getBoolean(\"Archive.processings.clean\");\n  logger.info(\"Archives processing clean instead of recovery \" + \"(Archive.processings.clean) requested by user (\" + clean_processings + \")\");\n  productService.processUnprocessed(!clean_processings);\n}\n", "docstring": "run recovery of stopped scanners . warning : do never perform archive . check when recovery is expected . this may cause data lost .", "partition": "test"}
{"idx": "2435", "code": "private static MetricValue number_to_metric_value_(Number elem){\n  if (elem == null)   return MetricValue.EMPTY;\n  final String num=elem.toString();\n  try {\n    return MetricValue.fromIntValue(Long.parseLong(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  try {\n    return MetricValue.fromDblValue(Double.parseDouble(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  return MetricValue.fromStrValue(num);\n}\n", "docstring": "work around for google gson parser emitting numbers as \"'\" lazily parsed \"'\" numbers .", "partition": "test"}
{"idx": "2448", "code": "public void stop(int timeout) throws InterruptedException {\n  if (!isclosed.compareAndSet(false,true)) {\n    return;\n  }\n  List<WebSocket> socketsToClose=null;\nsynchronized (connections) {\n    socketsToClose=new ArrayList<WebSocket>(connections);\n  }\n  for (  WebSocket ws : socketsToClose) {\n    ws.close(CloseFrame.GOING_AWAY);\n  }\nsynchronized (this) {\n    if (selectorthread != null) {\n      if (Thread.currentThread() != selectorthread) {\n      }\n      if (selectorthread != Thread.currentThread()) {\n        if (socketsToClose.size() > 0)         selectorthread.join(timeout);\n        selectorthread.interrupt();\n        selectorthread.join();\n      }\n    }\n  }\n}\n", "docstring": "closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads . if this method is called before the server is started it will never start .", "partition": "test"}
{"idx": "2900", "code": "public void deleteVVset(String nativeId) throws Exception {\n  _log.info(\"3PARDriver: deleteVVset enter\");\n  ClientResponse clientResp=null;\n  final String path=MessageFormat.format(URI_DELETE_CG,nativeId);\n  _log.info(\"3PARDriver:deleteVVset running delete VV Set \" + path);\n  try {\n    clientResp=delete(path);\n    if (clientResp == null) {\n      _log.error(\"3PARDriver:deleteVVset There is no response from 3PAR\");\n      throw new HP3PARException(\"There is no response from 3PAR\");\n    }\n else     if (clientResp.getStatus() != 200) {\n      String errResp=getResponseDetails(clientResp);\n      throw new HP3PARException(errResp);\n    }\n else {\n      _log.info(\"3PARDriver: deleteVVset success\");\n    }\n  }\n catch (  Exception e) {\n    throw e;\n  }\n finally {\n    if (clientResp != null) {\n      clientResp.close();\n    }\n    _log.info(\"3PARDriver:deleteVVset leave\");\n  }\n}\n", "docstring": "delete a vv set or consistency group", "partition": "test"}
{"idx": "1506", "code": "public static double sampleSkewStandardError(int size){\n  int n=size;\n  return Math.sqrt(6.0 * n * (n - 1) / ((n - 2) * (n + 1) * (n + 3)));\n}\n", "docstring": "return the standard error of the sample skew . ref : r . r . sokal , f . j . rohlf , biometry : the principles and practice of statistics in biological research ( w . h . freeman and company , new york , 1998 , 3rd edition ) p . 138 .", "partition": "test"}
{"idx": "301", "code": "private void addToSet(ObjectXmlPersist persist,IFile file,String setName) throws IOException, CoreException {\n  Collection<GraphEdgeMatcherDescriptor> updateSet=loadEdgeMatchers(persist,file);\n  persistUpdatedBundle(persist,file,updateSet,setName);\n}\n", "docstring": "add the set to an existing file .", "partition": "test"}
{"idx": "1237", "code": "public static BufferedImage toBufferedImage(Image img,int type){\n  if (img instanceof BufferedImage) {\n    return (BufferedImage)img;\n  }\n  BufferedImage bimage=new BufferedImage(img.getWidth(null),img.getHeight(null),type);\n  Graphics2D bGr=bimage.createGraphics();\n  bGr.drawImage(img,0,0,null);\n  bGr.dispose();\n  return bimage;\n}\n", "docstring": "converts a given image into a bufferedimage", "partition": "test"}
{"idx": "1413", "code": "private static int convertSRGBtoLinearRGB(int color){\n  float input, output;\n  input=color / 255.0f;\n  if (input <= 0.04045f) {\n    output=input / 12.92f;\n  }\n else {\n    output=(float)Math.pow((input + 0.055) / 1.055,2.4);\n  }\n  return Math.round(output * 255.0f);\n}\n", "docstring": "helper function to convert a color component in srgb space to linear rgb space . used to build a static lookup table .", "partition": "test"}
{"idx": "2359", "code": "@Override public PollResult startPoll(PollController conn){\n  if (!_lifecycle.isActive()) {\n    log.warning(this + \" select disabled\");\n    return PollResult.CLOSED;\n  }\n  SocketBar socket=conn.getSocket();\n  if (socket == null) {\n    log.warning(this + \" socket empty for \" + conn);\n    return PollResult.CLOSED;\n  }\n  SelectableChannel selChannel=socket.selectableChannel();\n  if (selChannel == null) {\n    log.warning(this + \" no channel for \" + socket);\n    return PollResult.CLOSED;\n  }\n  _connectionCount.incrementAndGet();\n  _activeCount.incrementAndGet();\n  _registerQueue.offer(conn);\n  return PollResult.START;\n}\n", "docstring": "adds a keepalive connection .", "partition": "test"}
{"idx": "3042", "code": "private void populateHostData(Host host,HostParam param){\n  if (param.getName() != null) {\n    host.setLabel(param.getName());\n  }\n  if (param.getHostName() != null) {\n    host.setHostName(param.getHostName());\n  }\n  if (param.getCluster() != null) {\n    host.setCluster(param.getCluster());\n  }\n  if (param.getOsVersion() != null) {\n    host.setOsVersion(param.getOsVersion());\n  }\n  if (param.getUserName() != null) {\n    host.setUsername(param.getUserName());\n  }\n  if (param.getPassword() != null) {\n    host.setPassword(param.getPassword());\n  }\n  if (param.getPortNumber() != null) {\n    host.setPortNumber(param.getPortNumber());\n  }\n  if (param.getUseSsl() != null) {\n    host.setUseSSL(param.getUseSsl());\n  }\n  if (param.getType() != null) {\n    host.setType(param.getType());\n  }\n  if (param.getDiscoverable() != null) {\n    host.setDiscoverable(param.getDiscoverable());\n  }\n  if (param.getVcenterDataCenter() != null) {\n    host.setVcenterDataCenter(NullColumnValueGetter.isNullURI(param.getVcenterDataCenter()) ? NullColumnValueGetter.getNullURI() : param.getVcenterDataCenter());\n  }\n  Cluster cluster=null;\n  if (!NullColumnValueGetter.isNullURI(param.getCluster())) {\n    cluster=queryObject(Cluster.class,param.getCluster(),true);\n    if (!NullColumnValueGetter.isNullURI(cluster.getVcenterDataCenter())) {\n      host.setVcenterDataCenter(cluster.getVcenterDataCenter());\n    }\n    if (!NullColumnValueGetter.isNullURI(cluster.getProject())) {\n      host.setProject(cluster.getProject());\n    }\n  }\n  if (param.getBootVolume() != null) {\n    host.setBootVolumeId(NullColumnValueGetter.isNullURI(param.getBootVolume()) ? NullColumnValueGetter.getNullURI() : param.getBootVolume());\n  }\n}\n", "docstring": "populate an instance of host with the provided host parameter", "partition": "test"}
{"idx": "1111", "code": "private void addClasses(Class<?>[] classes,HashSet<Class<?>> result,String fieldName){\n  if (classes == null || classes.length == 0)   Error.classesAbsent(fieldName,configuredClass);\n  for (  Class<?> classe : classes)   result.add(classe);\n}\n", "docstring": "adds to the result parameter all classes that aren \"'\" t present in it", "partition": "test"}
{"idx": "98", "code": "public boolean select(int position){\n  View v=mAllList.get(position);\n  if (mMultiChoiceAdapter != null) {\n    performVibrate();\n    performSelect(v,position,true);\n    return true;\n  }\n  return false;\n}\n", "docstring": "select a view from position in the adapter", "partition": "test"}
{"idx": "979", "code": "public static ResultSet pointTable(double x,double y){\n  GeometryFactory factory=new GeometryFactory();\n  SimpleResultSet rs=new SimpleResultSet();\n  rs.addColumn(\"THE_GEOM\",Types.JAVA_OBJECT,\"GEOMETRY\",0,0);\n  rs.addRow(factory.createPoint(new Coordinate(x,y)));\n  return rs;\n}\n", "docstring": "this method is called via reflection from the database .", "partition": "test"}
{"idx": "2085", "code": "static public URL findContainerXML(String _containerName){\n  URL _containerNameURL=null;\n  String _containerNameFilePath=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + _containerName+ \".xml\";\n  _containerNameURL=getResourceURL(_containerNameFilePath);\n  if (_containerNameURL != null) {\n    if (_logger.isLoggable(Level.INFO)) {\n      _logger.info(\"Loaded the container xml file < \" + _containerNameURL + \" >.\");\n    }\n  }\n  return _containerNameURL;\n}\n", "docstring": "look for the requested container xml file in the classpath ( resource ) under < some root dir > / config / < reqested_container_name > . xml . if the classpath contains < some root dir > first in classpath , it will attempt to look for the container xml file first in the file system under < some root dir > / config / < requested_container_name > . xml . container xml file contains the list of the spaces which are part of this container . fixed bug 26 / 06 / 06 gershon - http : / / 62 . 90 . 11 . 164 : 8080 / browse / app - 90 container . xml location mechanism must use getresource ( ) and load the container xml from resource according to the classpath", "partition": "test"}
{"idx": "3296", "code": "public static synchronized ResultSet executeQuery(String sqlStatement){\n  logger.trace(String.format(\"executeQuery( %s ) -->entry\",sqlStatement));\n  ResultSet R=null;\n  final Statement S=getStatement();\n  if (S == null) {\n    logger.error(\"executeQuery() <--exit (error: Statement unavailable)\");\n    return null;\n  }\n  try {\n    R=S.executeQuery(sqlStatement);\n    logger.trace(\"executeQuery() <--exit (normal): \" + (null == R));\n    return R;\n  }\n catch (  Throwable t) {\n    surfaceThrowable(String.format(\"executeQuery( %s )\",sqlStatement),t);\n    cleanup(S,R);\n  }\n  return null;\n}\n", "docstring": "this method is a thin wrapper for jdbc executequery ( ) . it exists primarily so that we can be assured of the properties of the resultset which is returned , and for consistency of error logging .", "partition": "test"}
{"idx": "1769", "code": "private static boolean addIfMatches(List<String> container,String statusLine,char x,char y){\n  if (matches(statusLine,x,y)) {\n    final String filename=statusLine.substring(3);\n    if (!container.contains(filename)) {\n      container.add(filename);\n    }\n    return true;\n  }\n  return false;\n}\n", "docstring": "adds files to container if they matched to template .", "partition": "test"}
{"idx": "961", "code": "public static AttribKey forHtmlAttrib(ElKey el,String localName){\n  return new AttribKey(el,HTML_NS,localName);\n}\n", "docstring": "looks up an attribute key by element and local name .", "partition": "test"}
{"idx": "2415", "code": "public static void dropIndex(Connection conn,String schema,String table) throws SQLException {\n  init(conn);\n  PreparedStatement prep=conn.prepareStatement(\"SELECT ID FROM \" + SCHEMA + \".INDEXES WHERE SCHEMA=? AND TABLE=?\");\n  prep.setString(1,schema);\n  prep.setString(2,table);\n  ResultSet rs=prep.executeQuery();\n  if (!rs.next()) {\n    return;\n  }\n  int indexId=rs.getInt(1);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".INDEXES WHERE ID=?\");\n  prep.setInt(1,indexId);\n  prep.execute();\n  createOrDropTrigger(conn,schema,table,false);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".ROWS WHERE INDEXID=? AND ROWNUM<10000\");\n  while (true) {\n    prep.setInt(1,indexId);\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".MAP M \"+ \"WHERE NOT EXISTS (SELECT * FROM \"+ SCHEMA+ \".ROWS R WHERE R.ID=M.ROWID) AND ROWID<10000\");\n  while (true) {\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n}\n", "docstring": "drop an existing full text index for a table . this method returns silently if no index for this table exists .", "partition": "test"}
{"idx": "3142", "code": "public static void nextBytes(byte[] bytes){\n  wasAccessed=true;\n  for (int i=0; i < bytes.length; )   for (int rnd=nextInt(), n=Math.min(bytes.length - i,4); n-- > 0; rnd>>=8)   bytes[i++]=(byte)rnd;\n}\n", "docstring": "replacement function for nextbytes", "partition": "test"}
{"idx": "1218", "code": "public static File toSLDFile(final File file){\n  final String path=file.getAbsolutePath();\n  final String base=path.substring(0,path.length() - 4);\n  String newPath=base + \".sld\";\n  File sld=new File(newPath);\n  if (sld.exists()) {\n    return sld;\n  }\n  newPath=base + \".SLD\";\n  sld=new File(newPath);\n  if (sld.exists()) {\n    return sld;\n  }\n  return null;\n}\n", "docstring": "figure out if a valid sld file is available .", "partition": "test"}
{"idx": "3878", "code": "@Override public int hashCode(){\n  int code=0;\n  if (fPublicId != null) {\n    code+=fPublicId.hashCode();\n  }\n  if (fLiteralSystemId != null) {\n    code+=fLiteralSystemId.hashCode();\n  }\n  if (fBaseSystemId != null) {\n    code+=fBaseSystemId.hashCode();\n  }\n  if (fExpandedSystemId != null) {\n    code+=fExpandedSystemId.hashCode();\n  }\n  if (fNamespace != null) {\n    code+=fNamespace.hashCode();\n  }\n  return code;\n}\n", "docstring": "returns a hash code for this object .", "partition": "test"}
{"idx": "2372", "code": "@Override public Expected<T> ifPresent(final Consumer<? super T> consumer){\n  if (this.value != null)   consumer.accept(this.value);\n  return this;\n}\n", "docstring": "if a value is present , invoke the consumer with the value .", "partition": "test"}
{"idx": "1135", "code": "protected String computeFullUrl(URL baseUrl,String link){\n  if (link == null || link.length() == 0) {\n    return null;\n  }\n  if (!link.startsWith(\"http\")) {\n    if (link.startsWith(\"/\")) {\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ link;\n    }\n else {\n      if (link.contains(\":\")) {\n        return null;\n      }\n      String path=baseUrl.getPath();\n      if (!path.endsWith(\"/\")) {\n        int sep=path.lastIndexOf(\"/\");\n        String file=path.substring(sep + 1);\n        if (file.contains(\".\") || file.contains(\"?\"))         path=path.substring(0,sep);\n      }\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ path+ \"/\"+ link;\n    }\n  }\n  link=normalizeUrlEnding(link);\n  String l=link.toLowerCase(Locale.ROOT);\n  if (l.endsWith(\".jpg\") || l.endsWith(\".jpeg\") || l.endsWith(\".png\")|| l.endsWith(\".gif\")) {\n    return null;\n  }\n  return link;\n}\n", "docstring": "computes the full url based on a base url and a possibly relative link found in the href param of an html anchor .", "partition": "test"}
{"idx": "1821", "code": "void write(Environment env,DataOutputStream out,ConstantPool tab) throws IOException {\n  out.writeByte(CONSTANT_NAMEANDTYPE);\n  out.writeShort(tab.index(name));\n  out.writeShort(tab.index(type));\n}\n", "docstring": "write the constant to the output stream", "partition": "test"}
{"idx": "1162", "code": "default Document putAll(Iterator<Field> fields){\n  while (fields.hasNext()) {\n    Field field=fields.next();\n    setValue(field.getName(),field.getValue());\n  }\n  return this;\n}\n", "docstring": "sets on this object all name / value pairs from the supplied object . if the supplied object is null , this method does nothing .", "partition": "test"}
{"idx": "1117", "code": "@Override public final void writeShort(int v) throws IOException {\n  work[0]=(byte)v;\n  work[1]=(byte)(v >> 8);\n  dis.write(work,0,2);\n}\n", "docstring": "write short , 16 - bits . like dataoutputstream . writeshort . also acts as a writeunsignedshort", "partition": "test"}
{"idx": "373", "code": "@RequestProcessing(value=\"/member/{userName}/following/tags\",method=HTTPRequestMethod.GET) @Before(adviceClass={StopwatchStartAdvice.class,AnonymousViewCheck.class,UserBlockCheck.class}) @After(adviceClass=StopwatchEndAdvice.class) public void showHomeFollowingTags(final HTTPRequestContext context,final HttpServletRequest request,final HttpServletResponse response,final String userName) throws Exception {\n  final JSONObject user=(JSONObject)request.getAttribute(User.USER);\n  request.setAttribute(Keys.TEMAPLTE_DIR_NAME,Symphonys.get(\"skinDirName\"));\n  final AbstractFreeMarkerRenderer renderer=new SkinRenderer();\n  context.setRenderer(renderer);\n  renderer.setTemplateName(\"/home/following-tags.ftl\");\n  final Map<String,Object> dataModel=renderer.getDataModel();\n  filler.fillHeaderAndFooter(request,response,dataModel);\n  String pageNumStr=request.getParameter(\"p\");\n  if (Strings.isEmptyOrNull(pageNumStr) || !Strings.isNumeric(pageNumStr)) {\n    pageNumStr=\"1\";\n  }\n  final int pageNum=Integer.valueOf(pageNumStr);\n  final int pageSize=Symphonys.getInt(\"userHomeFollowingTagsCnt\");\n  final int windowSize=Symphonys.getInt(\"userHomeFollowingTagsWindowSize\");\n  fillHomeUser(dataModel,user);\n  final String followingId=user.optString(Keys.OBJECT_ID);\n  dataModel.put(Follow.FOLLOWING_ID,followingId);\n  avatarQueryService.fillUserAvatarURL(user);\n  final JSONObject followingTagsResult=followQueryService.getFollowingTags(followingId,pageNum,pageSize);\n  final List<JSONObject> followingTags=(List<JSONObject>)followingTagsResult.opt(Keys.RESULTS);\n  dataModel.put(Common.USER_HOME_FOLLOWING_TAGS,followingTags);\n  final boolean isLoggedIn=(Boolean)dataModel.get(Common.IS_LOGGED_IN);\n  if (isLoggedIn) {\n    final JSONObject currentUser=(JSONObject)dataModel.get(Common.CURRENT_USER);\n    final String followerId=currentUser.optString(Keys.OBJECT_ID);\n    final boolean isFollowing=followQueryService.isFollowing(followerId,followingId);\n    dataModel.put(Common.IS_FOLLOWING,isFollowing);\n    for (    final JSONObject followingTag : followingTags) {\n      final String homeUserFollowingTagId=followingTag.optString(Keys.OBJECT_ID);\n      followingTag.put(Common.IS_FOLLOWING,followQueryService.isFollowing(followerId,homeUserFollowingTagId));\n    }\n  }\n  user.put(UserExt.USER_T_CREATE_TIME,new Date(user.getLong(Keys.OBJECT_ID)));\n  final int followingTagCnt=followingTagsResult.optInt(Pagination.PAGINATION_RECORD_COUNT);\n  final int pageCount=(int)Math.ceil(followingTagCnt / (double)pageSize);\n  final List<Integer> pageNums=Paginator.paginate(pageNum,pageSize,pageCount,windowSize);\n  if (!pageNums.isEmpty()) {\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM,pageNums.get(0));\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM,pageNums.get(pageNums.size() - 1));\n  }\n  dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM,pageNum);\n  dataModel.put(Pagination.PAGINATION_PAGE_COUNT,pageCount);\n  dataModel.put(Pagination.PAGINATION_PAGE_NUMS,pageNums);\n}\n", "docstring": "shows user home following tags page .", "partition": "test"}
{"idx": "551", "code": "public StrBuilder replaceFirst(final String searchStr,final String replaceStr){\n  final int searchLen=(searchStr == null ? 0 : searchStr.length());\n  if (searchLen > 0) {\n    final int index=indexOf(searchStr,0);\n    if (index >= 0) {\n      final int replaceLen=(replaceStr == null ? 0 : replaceStr.length());\n      replaceImpl(index,index + searchLen,searchLen,replaceStr,replaceLen);\n    }\n  }\n  return this;\n}\n", "docstring": "replaces the first instance of the search string with the replace string .", "partition": "test"}
{"idx": "1073", "code": "@Override public boolean lock(){\n  try {\n    if (!FileFactory.isFileExist(location,FileFactory.getFileType(tmpPath))) {\n      FileFactory.mkdirs(location,FileFactory.getFileType(tmpPath));\n    }\n    String lockFilePath=location + CarbonCommonConstants.FILE_SEPARATOR + lockFile;\n    if (!FileFactory.isFileExist(lockFilePath,FileFactory.getFileType(location))) {\n      FileFactory.createNewLockFile(lockFilePath,FileFactory.getFileType(location));\n    }\n    fileOutputStream=new FileOutputStream(lockFilePath);\n    channel=fileOutputStream.getChannel();\n    try {\n      fileLock=channel.tryLock();\n    }\n catch (    OverlappingFileLockException e) {\n      return false;\n    }\n    if (null != fileLock) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n", "docstring": "lock api for locking of the file channel of the lock file .", "partition": "test"}
{"idx": "2285", "code": "public void closeFile() throws IOException {\n  file.close();\n  file=null;\n}\n", "docstring": "close the file . the file may later be re - opened using openfile .", "partition": "test"}
{"idx": "3778", "code": "private void copyACls(final List<AccessControlLevel> accessControlLevels2){\n  for (  AccessControlLevel acl : this.accessControlLevels) {\n    accessControlLevels2.add(new AccessControlLevel(acl));\n  }\n}\n", "docstring": "copy acls for new configuration .", "partition": "test"}
{"idx": "3123", "code": "protected Object finish(Map settings) throws WizardException {\n  return provider.finish(settings);\n}\n", "docstring": "instantiate whatever object ( if any ) the wizard creates from its gathered data .", "partition": "test"}
{"idx": "3208", "code": "public static Container east(Component east){\n  return Container.encloseIn(new BorderLayout(),east,BorderLayout.EAST);\n}\n", "docstring": "convenience method that creates a border layout container and places the given component in the east", "partition": "test"}
{"idx": "3392", "code": "public boolean isSessionToken(String token){\nsynchronized (sessionTokens) {\n    return sessionTokens.contains(token);\n  }\n}\n", "docstring": "checks if is session token .", "partition": "test"}
{"idx": "3418", "code": "public int splitRandomly(ArrayModifiableDBIDs ind,int begin,int end,DoubleDataStore tpro,Random rand){\n  final int nele=end - begin;\n  DBIDArrayIter it=ind.iter();\n  double rs=tpro.doubleValue(it.seek(begin + rand.nextInt(nele)));\n  int minInd=begin, maxInd=end - 1;\n  while (minInd < maxInd) {\n    double currEle=tpro.doubleValue(it.seek(minInd));\n    if (currEle > rs) {\n      while (minInd < maxInd && tpro.doubleValue(it.seek(maxInd)) > rs) {\n        maxInd--;\n      }\n      if (minInd == maxInd) {\n        break;\n      }\n      ind.swap(minInd,maxInd);\n      maxInd--;\n    }\n    minInd++;\n  }\n  if (minInd == end - 1) {\n    minInd=(begin + end) >>> 1;\n  }\n  return minInd;\n}\n", "docstring": "split the data set randomly .", "partition": "test"}
{"idx": "3256", "code": "ServerMember update(Address clientAddress,Instant time){\n  if (clientAddress != null) {\n    this.clientAddress=clientAddress;\n    if (time.isAfter(updated)) {\n      this.updated=Assert.notNull(time,\"time\");\n    }\n  }\n  return this;\n}\n", "docstring": "updates the member client address .", "partition": "test"}
{"idx": "4207", "code": "public static RepaintManager currentManager(Component c){\n  return currentManager(AppContext.getAppContext());\n}\n", "docstring": "return the repaintmanager for the calling thread given a component .", "partition": "test"}
{"idx": "843", "code": "public synchronized void loadFromFile(){\n  entries.clear();\n  Path file=Paths.get(fileName);\n  try (BufferedReader reader=Files.newBufferedReader(file,CHARSET)){\n    String line;\n    do {\n      line=reader.readLine();\n      AddressbookEntry parsedEntry=parseLine(line);\n      if (parsedEntry != null) {\n        entries.put(parsedEntry.getName(),parsedEntry);\n      }\n    }\n while (line != null);\n  }\n catch (  IOException ex) {\n    LOGGER.warning(\"Error reading addressbook: \" + ex.getLocalizedMessage());\n  }\n  LOGGER.info(\"Read \" + entries.size() + \" addressbook entries from \"+ fileName);\n  scanCategories();\n}\n", "docstring": "loads the addressbook from file .", "partition": "test"}
{"idx": "1526", "code": "private boolean matchesAnyTag(String tagName){\n  return tagNames.contains(tagName);\n}\n", "docstring": "tries to match tagname to known tag names .", "partition": "test"}
{"idx": "934", "code": "public void add(DataSource source,boolean visible){\n  add(data.size(),source,visible);\n}\n", "docstring": "adds a new data series to the plot .", "partition": "test"}
{"idx": "727", "code": "private static int indexOf(int fromIndex,CharSequence csq){\n  if (csq == null)   return 0;\n  int length=csq.length();\n  int j=fromIndex;\n  int i=(j < length) ? csq.charAt(j++) : 0;\n  i<<=16;\n  i|=(j < length) ? csq.charAt(j++) : 0;\n  return i;\n}\n", "docstring": "returns the index starting at the specified index ( two characters at a time ) .", "partition": "test"}
{"idx": "4014", "code": "public static boolean isTrue(Map<String,Object> dict,String key){\n  return isTrue(dict,key,false);\n}\n", "docstring": "returns true if the dictionary contains true for the given key or false if no value is defined for the key .", "partition": "test"}
{"idx": "4117", "code": "public IonException(Throwable cause){\n  super(cause.getMessage(),cause);\n}\n", "docstring": "constructs a new exception with the given cause , copying the message from the cause into this instance .", "partition": "test"}
{"idx": "1249", "code": "public int hashCode(){\n  return font.hashCode() ^ glyphs.length;\n}\n", "docstring": "as a concrete subclass of object that implements equality , this must implement hashcode .", "partition": "test"}
{"idx": "1298", "code": "private boolean scrollViewCanScrollVertically(ScrollView scrollView,int direction){\n  final int offset=Math.max(0,scrollView.getScrollY());\n  final int range=computeVerticalScrollRange(scrollView) - scrollView.getHeight();\n  if (range == 0)   return false;\n  if (direction < 0) {\n    return offset > 0;\n  }\n else {\n    return offset < range - 1;\n  }\n}\n", "docstring": "copy from scrollview ( api level > = 14 )", "partition": "test"}
{"idx": "2922", "code": "public void attributeUpdate(PrintServiceAttributeEvent psae){\n  log.fine(\"attributeUpdate - \" + psae);\n}\n", "docstring": "print service attribute listener .", "partition": "test"}
{"idx": "2101", "code": "private static Object createAndBindItem(ParameterAccess parameters,Class<?> itemType){\n  try {\n    Object value=itemType.newInstance();\n    bind(value,parameters);\n    return value;\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new BindingException(\"Failed to instantiate new instance of \" + itemType,e);\n  }\n}\n", "docstring": "creates and binds the parameters to a new item .", "partition": "test"}
{"idx": "2937", "code": "public static void next(){\n  try {\n    if (musicPlaybackService != null) {\n      musicPlaybackService.next();\n    }\n  }\n catch (  final RemoteException ignored) {\n  }\n}\n", "docstring": "changes to the next track", "partition": "test"}
{"idx": "1781", "code": "public static int compare(Comparable c1,Comparable c2,boolean nullGreater){\n  if (c1 == c2) {\n    return 0;\n  }\n else   if (c1 == null) {\n    return (nullGreater ? 1 : -1);\n  }\n else   if (c2 == null) {\n    return (nullGreater ? -1 : 1);\n  }\n  return c1.compareTo(c2);\n}\n", "docstring": "null safe comparison of comparables .", "partition": "test"}
{"idx": "3920", "code": "public boolean isSegmentBalanced(){\n  if (m_lines.size() == 0 || m_doc.isMultiCurrency())   return true;\n  MAcctSchemaElement[] elements=m_acctSchema.getAcctSchemaElements();\n  for (int i=0; i < elements.length; i++) {\n    MAcctSchemaElement ase=elements[i];\n    if (ase.isBalanced() && !isSegmentBalanced(ase.getElementType()))     return false;\n  }\n  return true;\n}\n", "docstring": "are all segments balanced", "partition": "test"}
{"idx": "1384", "code": "public static double[][] computeWeightMatrix(final int quanth,final int quants,final int quantb){\n  final int dim=quanth * quants * quantb;\n  assert (dim > 0);\n  final double[][] m=new double[dim][dim];\n  for (int x=0; x < dim; x++) {\n    final int hx=x / (quantb * quants);\n    final int sx=(x / quantb) % quants;\n    final int bx=x % quantb;\n    for (int y=x; y < dim; y++) {\n      final int hy=y / (quantb * quants);\n      final int sy=(y / quantb) % quants;\n      final int by=y % quantb;\n      final double chx=Math.cos((hx + .5) / quanth * MathUtil.TWOPI);\n      final double chy=Math.cos((hy + .5) / quanth * MathUtil.TWOPI);\n      final double shx=MathUtil.cosToSin((hx + .5) / quanth * MathUtil.TWOPI,chx);\n      final double shy=MathUtil.cosToSin((hy + .5) / quanth * MathUtil.TWOPI,chy);\n      final double cos=chx * (sx + .5) / quants - chy * (sy + .5) / quants;\n      final double sin=shx * (sx + .5) / quants - shy * (sy + .5) / quants;\n      final double db=(bx - by) / (double)quantb;\n      final double val=1. - Math.sqrt((db * db + sin * sin + cos * cos) / 5);\n      m[x][y]=m[y][x]=val;\n    }\n  }\n  return m;\n}\n", "docstring": "compute the weight matrix for hsb similarity .", "partition": "test"}
{"idx": "2890", "code": "private void readHeader() throws OpenStegoException {\n  this.dataHeader=new DCTDataHeader(this,this.config);\n}\n", "docstring": "method to read header data from the input stream", "partition": "test"}
{"idx": "3388", "code": "public boolean isAllGranted(){\n  int count=0;\n  for (int i=0; i < mPerms.size(); i++) {\n    if (mPerms.get(mUserPermission.get(i)) == PackageManager.PERMISSION_GRANTED)     count++;\n  }\n  return count == mPerms.size();\n}\n", "docstring": "is all granted boolean .", "partition": "test"}
{"idx": "1910", "code": "public void removePositions(Collection<Integer> positions){\n  ArrayList<Integer> positionsList=new ArrayList<Integer>(positions);\n  Collections.sort(positionsList);\n  Collections.reverse(positionsList);\n  for (  int position : positionsList) {\n    mItems.remove(position);\n  }\n  notifyDataSetChanged();\n}\n", "docstring": "removes all elements at the specified positions in the list", "partition": "test"}
{"idx": "1472", "code": "public void copyText(){\n  int end, start;\n  end=selectedCharField.getSelectionEnd();\n  start=selectedCharField.getSelectionStart();\n  selectedCharField.selectAll();\n  selectedCharField.copy();\n  selectedCharField.select(start,end);\n}\n", "docstring": "copy text . copy all sample text to the system clipboard . remember the current caret position ( selection ) and restore that afterwards .", "partition": "test"}
{"idx": "552", "code": "protected abstract void internalPut(int index,byte b);\n", "docstring": "stores the byte at the index given .", "partition": "test"}
{"idx": "458", "code": "private List<Header> defaultHeaders(){\n  DateFormat dateFormat=new SimpleDateFormat(\"EEE, dd mmm yyyy HH:mm:ss zzz\");\n  List<Header> headers=new ArrayList<>();\n  headers.add(new BasicHeader(\"Date\",dateFormat.format(new Date())));\n  return headers;\n}\n", "docstring": "create default headers for server response .", "partition": "test"}
{"idx": "243", "code": "public static boolean verify(byte[] data,byte[] signature,byte[] pub){\n  Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n  ByteBuffer byteBuff=nativeECDSABuffer.get();\n  if (byteBuff == null) {\n    byteBuff=ByteBuffer.allocateDirect(32 + 8 + 520+ 520);\n    byteBuff.order(ByteOrder.nativeOrder());\n    nativeECDSABuffer.set(byteBuff);\n  }\n  byteBuff.rewind();\n  byteBuff.put(data);\n  byteBuff.putInt(signature.length);\n  byteBuff.putInt(pub.length);\n  byteBuff.put(signature);\n  byteBuff.put(pub);\n  return secp256k1_ecdsa_verify(byteBuff) == 1;\n}\n", "docstring": "verifies the given secp256k1 signature in native code . calling when enabled = = false is undefined ( probably library not loaded )", "partition": "test"}
{"idx": "4203", "code": "void addNext(Node<T> n){\n  nextNodes.add(n);\n  Collections.sort(nextNodes,isVertical ? verticalComparator : horizontalComparator);\n}\n", "docstring": "adds a \" next \" node ( node to the right or bottom ) to this divider \"'\" s list of next nodes .", "partition": "test"}
{"idx": "3527", "code": "public static void copy(DimensionsEvent aeDest,DimensionsEvent aeSrc){\n  GPOMutable destAggs=aeDest.getAggregates();\n  GPOMutable srcAggs=aeSrc.getAggregates();\n  if (srcAggs.getFieldsBoolean() != null) {\n    System.arraycopy(srcAggs.getFieldsBoolean(),0,destAggs.getFieldsBoolean(),0,srcAggs.getFieldsBoolean().length);\n  }\n  if (srcAggs.getFieldsCharacter() != null) {\n    System.arraycopy(srcAggs.getFieldsCharacter(),0,destAggs.getFieldsCharacter(),0,srcAggs.getFieldsCharacter().length);\n  }\n  if (srcAggs.getFieldsString() != null) {\n    System.arraycopy(srcAggs.getFieldsString(),0,destAggs.getFieldsString(),0,srcAggs.getFieldsString().length);\n  }\n  if (srcAggs.getFieldsShort() != null) {\n    System.arraycopy(srcAggs.getFieldsShort(),0,destAggs.getFieldsShort(),0,srcAggs.getFieldsShort().length);\n  }\n  if (srcAggs.getFieldsInteger() != null) {\n    System.arraycopy(srcAggs.getFieldsInteger(),0,destAggs.getFieldsInteger(),0,srcAggs.getFieldsInteger().length);\n  }\n  if (srcAggs.getFieldsLong() != null) {\n    System.arraycopy(srcAggs.getFieldsLong(),0,destAggs.getFieldsLong(),0,srcAggs.getFieldsLong().length);\n  }\n  if (srcAggs.getFieldsFloat() != null) {\n    System.arraycopy(srcAggs.getFieldsFloat(),0,destAggs.getFieldsFloat(),0,srcAggs.getFieldsFloat().length);\n  }\n  if (srcAggs.getFieldsDouble() != null) {\n    System.arraycopy(srcAggs.getFieldsDouble(),0,destAggs.getFieldsDouble(),0,srcAggs.getFieldsDouble().length);\n  }\n}\n", "docstring": "this is a utility method which copies the given src event to the given destination event .", "partition": "test"}
{"idx": "3096", "code": "public MessagePropertyKey(String description,Integer ordinal){\n  this.description=description;\n  this.ordinal=ordinal;\n}\n", "docstring": "creates a parameterized instance .", "partition": "test"}
{"idx": "3108", "code": "public boolean leave() throws KeeperException, InterruptedException {\n  zooKeeper.delete(rootPath + \"/\" + name,0);\n  while (true) {\nsynchronized (mutex) {\n      List<String> list=zooKeeper.getChildren(rootPath,true);\n      if (list.size() > 0) {\n        mutex.wait();\n      }\n else {\n        return true;\n      }\n    }\n  }\n}\n", "docstring": "wait until all nodes leave barrier", "partition": "test"}
{"idx": "3962", "code": "public List<SoftWrapImpl> removeStartingFrom(int offset){\n  int startIndex=getSoftWrapIndex(offset);\n  if (startIndex < 0) {\n    startIndex=-startIndex - 1;\n  }\n  if (startIndex >= myWraps.size()) {\n    return Collections.emptyList();\n  }\n  List<SoftWrapImpl> tail=myWraps.subList(startIndex,myWraps.size());\n  List<SoftWrapImpl> result=new ArrayList<SoftWrapImpl>(tail);\n  tail.clear();\n  return result;\n}\n", "docstring": "removes soft wraps with offsets equal or larger than a given offset from storage .", "partition": "test"}
{"idx": "1638", "code": "public void write(byte[] b,int offset,int length) throws IOException {\n  if (entry.getMethod() == DEFLATED) {\n    if (length > 0) {\n      if (!def.finished()) {\n        def.setInput(b,offset,length);\n        while (!def.needsInput()) {\n          deflate();\n        }\n      }\n    }\n  }\n else {\n    writeOut(b,offset,length);\n    written+=length;\n  }\n  crc.update(b,offset,length);\n}\n", "docstring": "writes bytes to zip entry .", "partition": "test"}
{"idx": "2315", "code": "public void readWwwAuthenticateHeader(String header){\n  if (header != null) {\n    mIsDigestAuthentication=header.startsWith(HttpDigestMd5Authentication.HTTP_DIGEST_SCHEMA);\n    if (!mIsDigestAuthentication) {\n      return;\n    }\n    String value=getValue(header,\"realm\");\n    mDigest.setRealm(value);\n    value=getValue(header,\"opaque\");\n    mDigest.setOpaque(value);\n    value=getValue(header,\"qop\");\n    mDigest.setQop(value);\n    value=getValue(header,\"nonce\");\n    mDigest.setNextnonce(value);\n  }\n}\n", "docstring": "read the www - authenticate header", "partition": "test"}
{"idx": "624", "code": "public void addButton(URL url,String info,ActionListener al){\n  JButton b=new JButton(new ImageIcon(url,info));\n  b.setToolTipText(info);\n  b.setMargin(new Insets(0,0,0,0));\n  b.addActionListener(al);\n  b.setBorderPainted(false);\n  add(b);\n}\n", "docstring": "add a button to the panel .", "partition": "test"}
{"idx": "2050", "code": "public int syncQuery(String query){\n  long start=System.currentTimeMillis();\n  int modified=execute(\"update\",UPDATE_COUNT_RESPONSE,query);\n  log.debug(\"Update query took {} millis and modified {} statements\",System.currentTimeMillis() - start,modified);\n  return modified;\n}\n", "docstring": "synchronizes the rdf repository \"'\" s representation of an entity to be exactly the provided statements .", "partition": "test"}
{"idx": "687", "code": "private static String parse(JsonValue base){\n  if (!base.isString()) {\n    return null;\n  }\n  return buildString(base.asString());\n}\n", "docstring": "start the string parsing . if base is not a string , will return null .", "partition": "test"}
{"idx": "2233", "code": "protected void dropTables(List<String> dropTableNames,SQLiteDatabase db){\n  if (dropTableNames != null && !dropTableNames.isEmpty()) {\n    String[] dropTableSQLS=new String[dropTableNames.size()];\n    for (int i=0; i < dropTableSQLS.length; i++) {\n      dropTableSQLS[i]=generateDropTableSQL(dropTableNames.get(i));\n    }\n    execute(dropTableSQLS,db);\n  }\n}\n", "docstring": "drop the tables by the passing table name .", "partition": "test"}
{"idx": "1934", "code": "private void removeOurUIs(){\n  for (  String uiName : UI_LIST) {\n    uiDefaults.remove(uiName + \"UI\");\n  }\n}\n", "docstring": "use our ui delegate for the specified ui control type .", "partition": "test"}
{"idx": "2999", "code": "protected FastMap<String> readDeclaredProperties(WidgetCreatorContext context){\n  FastMap<String> declaredProperties=new FastMap<String>();\n  String backColor=context.readWidgetProperty(\"backColor\");\n  if (backColor != null && backColor.length() > 0) {\n    declaredProperties.put(\"backColor\",backColor);\n  }\n  String fontName=context.readWidgetProperty(\"fontName\");\n  if (fontName != null && fontName.length() > 0) {\n    declaredProperties.put(\"fontName\",fontName);\n  }\n  String fontSize=context.readWidgetProperty(\"fontSize\");\n  if (fontSize != null && fontSize.length() > 0) {\n    declaredProperties.put(\"fontSize\",fontSize);\n  }\n  String foreColor=context.readWidgetProperty(\"foreColor\");\n  if (foreColor != null && foreColor.length() > 0) {\n    declaredProperties.put(\"foreColor\",foreColor);\n  }\n  String justification=context.readWidgetProperty(\"justification\");\n  if (justification != null && justification.length() > 0) {\n    declaredProperties.put(\"justification\",justification);\n  }\n  String bold=context.readWidgetProperty(\"bold\");\n  if (bold != null && bold.length() > 0) {\n    declaredProperties.put(\"bold\",bold);\n  }\n  String italic=context.readWidgetProperty(\"italic\");\n  if (italic != null && italic.length() > 0) {\n    declaredProperties.put(\"italic\",italic);\n  }\n  String subscript=context.readWidgetProperty(\"subscript\");\n  if (subscript != null && subscript.length() > 0) {\n    declaredProperties.put(\"subscript\",subscript);\n  }\n  String superscript=context.readWidgetProperty(\"superscript\");\n  if (superscript != null && superscript.length() > 0) {\n    declaredProperties.put(\"superscript\",superscript);\n  }\n  String underline=context.readWidgetProperty(\"underline\");\n  if (underline != null && underline.length() > 0) {\n    declaredProperties.put(\"underline\",underline);\n  }\n  String strikethrough=context.readWidgetProperty(\"strikethrough\");\n  if (strikethrough != null && strikethrough.length() > 0) {\n    declaredProperties.put(\"strikethrough\",strikethrough);\n  }\n  return declaredProperties;\n}\n", "docstring": "reads all declared properties in the component span tag . these properties will be used to initialise the basic formatter . it will be done by method initbasicformatteroptions", "partition": "test"}
{"idx": "498", "code": "public boolean mouseDragged(MouseEvent e){\n  if (grabbed_plot_graphics_) {\n    int x=e.getX();\n    int y=e.getY();\n    int dx=x - prevX;\n    int dy=y - prevY;\n    plotX+=dx;\n    plotY+=dy;\n    prevX=x;\n    prevY=y;\n    graph.resize(plotX,plotY,plotWidth,plotHeight);\n    OMGraphicList plotGraphics=graph.getPlotGraphics();\n    plotGraphics.generate(getProjection(),true);\n    repaint();\n  }\n  return false;\n}\n", "docstring": "called whenever the mouse is dragged on this layer and one of the requested mouse modes is active .", "partition": "test"}
{"idx": "972", "code": "public void addTestCall(GenericAccessibleObject<?> call) throws IllegalArgumentException {\n  Inputs.checkNull(call);\n  testMethods.add(call);\n}\n", "docstring": "add a test call", "partition": "test"}
{"idx": "3360", "code": "private void loadLatestExtensionVersions(){\n  try {\n    List<Extension> all=registryManager.getExtensions();\n    if (!all.isEmpty()) {\n      setLatestExtensionVersions(getLatestVersions(all));\n    }\n  }\n catch (  RegistryException e) {\n    String msg=RegistryException.logRegistryException(e.getType(),this);\n    warnings.addStartupError(msg);\n    LOG.error(msg);\n    msg=getText(\"admin.extensions.couldnt.load\",new String[]{cfg.getRegistryUrl()});\n    warnings.addStartupError(msg);\n    LOG.error(msg);\n  }\n finally {\n    if (getLatestExtensionVersions() == null) {\n      setLatestExtensionVersions(new ArrayList<Extension>());\n    }\n  }\n}\n", "docstring": "reload the list of registered extensions , loading only the latest extension versions .", "partition": "test"}
{"idx": "2278", "code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Node nameNode;\n  CharacterData child;\n  String childData;\n  doc=(Document)load(\"staff\",true);\n  elementList=doc.getElementsByTagName(\"address\");\n  nameNode=elementList.item(0);\n  child=(CharacterData)nameNode.getFirstChild();\n  child.deleteData(4,50);\n  childData=child.getData();\n  assertEquals(\"characterdataDeleteDataExceedsLengthAssert\",\"1230\",childData);\n}\n", "docstring": "runs the test case .", "partition": "test"}
{"idx": "2694", "code": "public RSAPublicKey parsePEMPublicKey(String pem) throws GeneralSecurityException {\n  try {\n    byte[] bs=decodeAsciiArmoredPEM(pem);\n    ByteBuffer data=ByteBuffer.wrap(bs);\n    final ASN1Object ob=asn1Parser.parseASN1(data);\n    final List<ASN1Object> seq=asn1ObjectToSequence(ob,2);\n    final BigInteger modulus=asn1ObjectToBigInt(seq.get(0));\n    final BigInteger exponent=asn1ObjectToBigInt(seq.get(1));\n    return createKeyFromModulusAndExponent(modulus,exponent);\n  }\n catch (  IllegalArgumentException e) {\n    throw new InvalidKeyException();\n  }\n}\n", "docstring": "parse a pkcs1 pem encoded rsa public key into the modulus / exponent components and construct a new rsapublickey", "partition": "test"}
{"idx": "642", "code": "public int checkBookiesUp(int count,int timeout) throws Exception {\n  ZooKeeper zkc=connectZooKeeper(zkHost,zkPort,zkTimeoutSec);\n  try {\n    int mostRecentSize=0;\n    for (int i=0; i < timeout; i++) {\n      try {\n        List<String> children=zkc.getChildren(\"/ledgers/available\",false);\n        children.remove(\"readonly\");\n        mostRecentSize=children.size();\n        if ((mostRecentSize > count) || LOG.isDebugEnabled()) {\n          LOG.info(\"Found \" + mostRecentSize + \" bookies up, \"+ \"waiting for \"+ count);\n          if ((mostRecentSize > count) || LOG.isTraceEnabled()) {\n            for (            String child : children) {\n              LOG.info(\" server: \" + child);\n            }\n          }\n        }\n        if (mostRecentSize == count) {\n          break;\n        }\n      }\n catch (      KeeperException e) {\n      }\n      Thread.sleep(1000);\n    }\n    return mostRecentSize;\n  }\n  finally {\n    zkc.close();\n  }\n}\n", "docstring": "check that a number of bookies are available", "partition": "test"}
{"idx": "1453", "code": "public static String padRight(final String s,final int length){\n  final int pad=length - s.length();\n  return pad > 0 ? s + getSpaceString(pad) : s;\n}\n", "docstring": "pad a string on the right with spaces till it is at least the specified length .", "partition": "test"}
{"idx": "2238", "code": "private static void removeReferenceToConnection(final HttpConnectionWithReference connection){\nsynchronized (REFERENCE_TO_CONNECTION_SOURCE) {\n    REFERENCE_TO_CONNECTION_SOURCE.remove(connection.reference);\n  }\n}\n", "docstring": "removes the reference being stored for the given connection . this method should be called when the connection manager again has a direct reference to the connection .", "partition": "test"}
{"idx": "2541", "code": "private String dateToString(Date input){\n  if (input == null) {\n    return null;\n  }\n else {\n    return input.toString();\n  }\n}\n", "docstring": "converts the input to a string with special missing value handling", "partition": "test"}
{"idx": "3187", "code": "public synchronized void close() throws IOException {\n  if (in == null)   return;\n  in.close();\n  in=null;\n  buf=null;\n}\n", "docstring": "closes this input stream and releases any system resources associated with the stream . once the stream has been closed , further read ( ) , unread ( ) , available ( ) , reset ( ) , or skip ( ) invocations will throw an ioexception . closing a previously closed stream has no effect .", "partition": "test"}
{"idx": "2771", "code": "public static boolean isNewer(long ts1,long size1,long ts2,long size2){\n  return ts1 > ts2 || (ts1 == ts2 && size1 < size2);\n}\n", "docstring": "determines if a file is newer than another by comparing the timestamps and sizes . this heuristic is consisten with the behavior of rotating log files : at the instant the file is rotated there will likely exist two files with the same timestamp ; in that case , knowing nothing else about the files , the old file is almost certainly the one which has more data , since the newer file has just been created ( or truncated ) and would not have enough data yet . todo : the edge case where the new file fills so quickly ( within 1 second ) to become as large as the old file will escape this heuristic . this is * exceedingly rare * to happen in reality however , and will soon rectify itself ( within 1 second ) since the timestamp of the file that \"'\" s being written to will change , and the sizes won \"'\" t matter anymore .", "partition": "test"}
{"idx": "1267", "code": "private PDFPage createPage(int pagenum,PDFObject pageObj) throws IOException {\n  int rotation=0;\n  RectF mediabox=null;\n  RectF cropbox=null;\n  PDFObject mediaboxObj=getInheritedValue(pageObj,\"MediaBox\");\n  if (mediaboxObj != null) {\n    mediabox=parseRect(mediaboxObj);\n  }\n  PDFObject cropboxObj=getInheritedValue(pageObj,\"CropBox\");\n  if (cropboxObj != null) {\n    cropbox=parseRect(cropboxObj);\n  }\n  PDFObject rotateObj=getInheritedValue(pageObj,\"Rotate\");\n  if (rotateObj != null) {\n    rotation=rotateObj.getIntValue();\n  }\n  RectF bbox=((cropbox == null) ? mediabox : cropbox);\n  return new PDFPage(pagenum,bbox,rotation,cache);\n}\n", "docstring": "create a pdf page object by finding the relevant inherited properties", "partition": "test"}
{"idx": "139", "code": "private long checkFileHeader(BufferedFileDataInput bfdi) throws ReplicatorException, InterruptedException {\n  int magic=0;\n  short major=0;\n  short minor=0;\n  try {\n    bfdi.waitAvailable(HEADER_LENGTH,HEADER_WAIT_MILLIS);\n    magic=bfdi.readInt();\n    major=bfdi.readShort();\n    minor=bfdi.readShort();\n    baseSeqno=bfdi.readLong();\n  }\n catch (  IOException e) {\n    throw new THLException(\"Failed to read file header from  \" + file.getAbsolutePath(),e);\n  }\n  if (magic != MAGIC_NUMBER)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : invalid magic number\");\n  if (major != MAJOR_VERSION)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : incompatible major version\");\n  if (minor != MINOR_VERSION)   logger.warn(\"Minor version mismatch : file \" + file.getAbsolutePath() + \" using format \"+ major+ \".\"+ minor+ \" - Tungsten running version \"+ MAJOR_VERSION+ \".\"+ MINOR_VERSION);\n  return baseSeqno;\n}\n", "docstring": "read the file header and return the log sequence number stored in the file header .", "partition": "test"}
{"idx": "3248", "code": "public void changeState(){\n  linked=!linked;\n  link=linked ? linkedImIc.getImage() : unlinkedImIc.getImage();\n  repaint();\n}\n", "docstring": "changes the lock icon \"'\" s image to whatever it currently is not . also changes the locked flag accordingly .", "partition": "test"}
{"idx": "1052", "code": "public void addItem(Artist artist,int position){\n  if (artist == null)   throw new NullPointerException(\"The item cannot be null\");\n  if (position < getItemCount() || position > getItemCount())   throw new IllegalArgumentException(\"The position must be between 0 and lastIndex + 1\");\n  artists.add(position,artist);\n  notifyItemInserted(position);\n}\n", "docstring": "add item in determined index", "partition": "test"}
{"idx": "2938", "code": "private void drawBitmapWithStroke(Canvas canvas,Bitmap bitmap,int centerX,int centerY,float radius,Paint drawPaint){\n  drawPaint.setStyle(Paint.Style.FILL);\n  float strokeRadius=radius + mRadiusStrokeWidth;\n  drawPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n  canvas.drawCircle(centerX,centerY,strokeRadius,drawPaint);\n  drawPaint.setXfermode(null);\n  final int halfBitmapWidth=bitmap.getWidth() / 2;\n  final int halfBitmapHeight=bitmap.getHeight() / 2;\n  BitmapShader bitmapShader=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);\n  Matrix shaderMatrix=new Matrix();\n  float minSize=bitmap.getWidth() > bitmap.getHeight() ? bitmap.getHeight() : bitmap.getWidth();\n  float scale=radius * 2 / minSize;\n  shaderMatrix.setScale(scale,scale);\n  shaderMatrix.postTranslate(centerX - (halfBitmapWidth * scale),centerY - (halfBitmapHeight * scale));\n  bitmapShader.setLocalMatrix(shaderMatrix);\n  drawPaint.setShader(bitmapShader);\n  canvas.drawCircle(centerX,centerY,radius,drawPaint);\n  drawPaint.setShader(null);\n}\n", "docstring": "draw single bitmap with the giving centerx , centery and radius", "partition": "test"}
{"idx": "2989", "code": "public RequirementsBuilder addRequireProperty(String name,RequirementsBuilder builder){\n  addProperty(name,builder);\n  requiredProperties.add(name);\n  return this;\n}\n", "docstring": "add a required property of type object .", "partition": "test"}
{"idx": "2672", "code": "public boolean hasDescendant(Pattern pattern){\n  Queue<BNode> nodesToProcess=new LinkedList<BNode>();\n  nodesToProcess.add(this);\n  while (!nodesToProcess.isEmpty()) {\n    BNode currentNode=nodesToProcess.poll();\n    for (    BNode descendantNode : currentNode.getOutputNodes()) {\n      Matcher matcher=pattern.matcher(descendantNode.getId());\n      if (matcher.matches()) {\n        return true;\n      }\n      if (!nodesToProcess.contains(descendantNode)) {\n        nodesToProcess.add(descendantNode);\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if at there exists at least one descendant whose identifier matches the regular expression pattern , and false otherwise", "partition": "test"}
{"idx": "2726", "code": "public javax2.sip.address.TelURL createTelURL(String uri) throws ParseException {\n  if (uri == null)   throw new NullPointerException(\"null url\");\n  String telUrl=\"tel:\" + uri;\n  try {\n    StringMsgParser smp=new StringMsgParser();\n    TelURLImpl timp=(TelURLImpl)smp.parseUrl(telUrl);\n    return (TelURL)timp;\n  }\n catch (  ParseException ex) {\n    throw new ParseException(ex.getMessage(),0);\n  }\n}\n", "docstring": "creates a telurl based on given uri string . the scheme or \"'\" + \"'\" should not be included in the phonenumber string argument .", "partition": "test"}
{"idx": "716", "code": "public void completeHeartbeat(Database database,long seqno,String eventId) throws SQLException {\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update\");\n  Statement st=null;\n  ResultSet rs=null;\n  Timestamp sts=new Timestamp(0);\n  Timestamp now=new Timestamp(System.currentTimeMillis());\n  ArrayList<Column> whereClause=new ArrayList<Column>();\n  ArrayList<Column> values=new ArrayList<Column>();\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update: \" + now);\n  try {\n    st=database.createStatement();\n    rs=st.executeQuery(sourceTsQuery);\n    if (rs.next())     sts=rs.getTimestamp(1);\n  }\n  finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n    if (st != null) {\n      try {\n        st.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n  }\n  long lag_millis=now.getTime() - sts.getTime();\n  hbId.setValue(KEY);\n  whereClause.add(hbId);\n  hbSeqno.setValue(seqno);\n  hbEventId.setValue(eventId);\n  hbTargetTstamp.setValue(now);\n  hbLagMillis.setValue(lag_millis);\n  values.add(hbSeqno);\n  values.add(hbEventId);\n  values.add(hbTargetTstamp);\n  values.add(hbLagMillis);\n  database.update(hbTable,whereClause,values);\n}\n", "docstring": "execute this call to fill in heartbeat data on the slave . this call must be invoked after a heartbeat event is applied .", "partition": "test"}
{"idx": "1770", "code": "public static String encodeFromString(String plain,String charset) throws CoderException, UnsupportedEncodingException {\n  return encode(plain.getBytes(charset));\n}\n", "docstring": "encodes a string to base64 string", "partition": "test"}
{"idx": "965", "code": "public EtagCache resetStats(){\n  hits.set(0);\n  misses.set(0);\n  return this;\n}\n", "docstring": "reset stats tracked for cache hits and misses", "partition": "test"}
{"idx": "3407", "code": "public void startDocument(XMLLocator locator,String encoding,NamespaceContext namespaceContext,Augmentations augs) throws XNIException {\n  fNamespaceContext=namespaceContext;\n  try {\n    if (fDocumentHandler != null) {\n      if (locator != null) {\n        fDocumentHandler.setDocumentLocator(new LocatorProxy(locator));\n      }\n      fDocumentHandler.startDocument();\n    }\n    if (fContentHandler != null) {\n      if (locator != null) {\n        fContentHandler.setDocumentLocator(new LocatorProxy(locator));\n      }\n      fContentHandler.startDocument();\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}\n", "docstring": "the start of the document .", "partition": "test"}
{"idx": "1055", "code": "public void encode(OutputStream out) throws IOException {\n  DerOutputStream tmp=new DerOutputStream();\n  if (this.extensionValue == null) {\n    this.extensionId=PKIXExtensions.ReasonCode_Id;\n    this.critical=false;\n    encodeThis();\n  }\n  super.encode(tmp);\n  out.write(tmp.toByteArray());\n}\n", "docstring": "write the extension to the deroutputstream .", "partition": "test"}
{"idx": "1337", "code": "public TaskResourceRep unlinkTargetVolumesFromSnapshotSession(URI snapSessionURI,SnapshotSessionUnlinkTargetsParam param){\n  return unlinkTargetVolumesFromSnapshotSession(snapSessionURI,param,OperationTypeEnum.UNLINK_SNAPSHOT_SESSION_TARGET);\n}\n", "docstring": "implements a request to unlink the passed targets from the blocksnapshotsession instance with the passed uri .", "partition": "test"}
{"idx": "4012", "code": "public static Object deserializeObject(final byte[] objBytes,final ClassLoader loader) throws IOException, ClassNotFoundException {\n  ObjectInputStream objIn=null;\n  try {\n    objIn=new ClassLoaderObjectInputStream(new ByteArrayInputStream(objBytes),loader);\n    return objIn.readObject();\n  }\n  finally {\n    close(objIn);\n  }\n}\n", "docstring": "convenience method to de - serialize a byte array back into an object who \"'\" s class type is resolved by the specific classloader . < p / >", "partition": "test"}
{"idx": "4055", "code": "public void execute() throws IOException {\n  String key=\"mqtt-\" + (System.currentTimeMillis() / 1000);\n  String b64Key=Base64.encode(key);\n  sendHandshakeRequest(b64Key);\n  receiveHandshakeResponse(b64Key);\n}\n", "docstring": "executes a websocket handshake . will throw an ioexception if the handshake fails", "partition": "test"}
{"idx": "3825", "code": "public InlineURIHandler(final String namespace){\n  this.namespace=namespace;\n  this.len=namespace.length();\n}\n", "docstring": "create a handler for the supplied namespace prefix - the handler will be invoked iff it is the registered handler having the longest prefix lte to the actual uri .", "partition": "test"}
{"idx": "2927", "code": "private void insertBefore(Instruction[] list,Instruction s){\n  for (  Instruction x : list) {\n    s.insertBefore(x);\n  }\n}\n", "docstring": "inserts each instruction in a list before another instruction .", "partition": "test"}
{"idx": "3987", "code": "private Vector<SnmpVarBind> splitFrom(Vector<SnmpVarBind> original,int limit){\n  int max=original.size();\n  Vector<SnmpVarBind> result=new Vector<>(max - limit);\n  int i=limit;\n  for (Enumeration<SnmpVarBind> e=original.elements(); e.hasMoreElements(); --i) {\n    SnmpVarBind var=e.nextElement();\n    if (i > 0)     continue;\n    result.addElement(new SnmpVarBind(var.oid,var.value));\n  }\n  return result;\n}\n", "docstring": "this method creates a new vector which does not contain the first element up to the specified limit .", "partition": "test"}
{"idx": "1848", "code": "public void doStressTest(TempTripleStore tmp,InferenceEngine inf,int ntrials,int D,int N){\n  AbstractTripleStore store=inf.database;\n  assertSameGraphs(tmp,store);\n  for (int trial=0; trial < ntrials; trial++) {\n    MDC.put(\"trial\",\"trial=\" + trial);\n    retractAndAssert(inf,store,0,D,N);\n    assertSameGraphs(tmp,store);\n    MDC.remove(\"trial\");\n  }\n}\n", "docstring": "a stress test for truth maintenance using an arbitrary data set . the test scans the statement indices in some order , selecting n explicit statement to retract . it then retracts them , updates the closure , and then re - asserts them and verifies that original closure was restored . < p > note : this test by itself does not guarentee that any entailments of those explicit statements were removed - we need to write other tests for that . repeat several times on the dataset , potentially doing multiple retractions before we back out of them .", "partition": "test"}
{"idx": "949", "code": "@SuppressWarnings(\"unchecked\") public void registerDefaultDeviceTypes(){\n  final HashMap<String,String> devicesList=DefaultPlatform.getDeviceServiceMap();\n  for (  HashMap.Entry<String,String> entry : devicesList.entrySet()) {\n    String key=entry.getKey();\n    String value=entry.getValue();\n    try {\n      registerDeviceService((Class<DeviceService>)Class.forName(key),(Class<DiscoveryProvider>)Class.forName(value));\n    }\n catch (    ClassNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "registers a commonly - used set of deviceservices with discoverymanager . this method will be called on first call of startdiscovery if no deviceservices have been registered . - castdiscoveryprovider + castservice - ssdpdiscoveryprovider + dialservice + dlnaservice ( limited to lg tvs , currently ) + netcasttvservice + rokuservice + webostvservice + multiscreenservice - zeroconfdiscoveryprovider + airplayservice", "partition": "test"}
{"idx": "4138", "code": "private static void map(final StringBuilder buffer,final ByteSequence sequence,final boolean trim,final boolean foldCase){\n  final String value=sequence.toString();\n  for (int i=0; i < value.length(); i++) {\n    final char c=value.charAt(i);\n    if (MAP_2_NULL.contains(c)) {\n      continue;\n    }\n    if (MAP_2_SPACE.contains(c)) {\n      if (canMapToSpace(buffer,trim)) {\n        buffer.append(SPACE_CHAR);\n      }\n      continue;\n    }\n    if (foldCase) {\n      final String mapping=CASE_MAP_TABLE.get(c);\n      if (mapping != null) {\n        buffer.append(mapping);\n        continue;\n      }\n    }\n    buffer.append(c);\n  }\n}\n", "docstring": "checks each character and replaces it with its mapping .", "partition": "test"}
{"idx": "4264", "code": "public static String serializeExpression(Node s){\n  if (s instanceof ASTTerm) {\n    ASTTerm a=(ASTTerm)s;\n    return (a.isNotFlag() ? \"!\" : \"\") + \" \" + a.getTerm();\n  }\n  String prefix=\"\";\n  String suffix=\"\";\n  String join=\" \";\n  if (s instanceof ASTExpression) {\n    ASTExpression a=(ASTExpression)s;\n    prefix=(a.isNotFlag() ? \"!\" : \"\") + \"(\";\n    suffix=\")\";\n    join=\" \" + a.getType() + \" \";\n  }\n  List<String> children=new ArrayList<String>();\n  for (int i=0; i < s.jjtGetNumChildren(); i++) {\n    children.add(serializeExpression(s.jjtGetChild(i)));\n  }\n  return prefix + StringUtils.join(children,join) + suffix;\n}\n", "docstring": "serialize a node ( and it \"'\" s children ) to a parsable string .", "partition": "test"}
{"idx": "3753", "code": "static ByteBuffer newByteBuffer(int capacity){\n  ByteBuffer newbb=ByteBuffer.allocate(capacity);\n  newbb.order(ByteOrder.LITTLE_ENDIAN);\n  return newbb;\n}\n", "docstring": "create a ` bytebuffer ` with a given capacity .", "partition": "test"}
{"idx": "3259", "code": "public byte[] serializeToBuffer(Object o) throws IOException {\n  ByteArrayOutputStream bufOut=new ByteArrayOutputStream();\n  try {\n    serialize(bufOut,o);\n    bufOut.flush();\n    return bufOut.toByteArray();\n  }\n  finally {\n    bufOut.close();\n  }\n}\n", "docstring": "serializes the object into a byte buffer .", "partition": "test"}
{"idx": "3809", "code": "@Secured public void addPay_Simple(long userId,BigDecimal amount,Date created,PaymentType payType,String details,boolean updateCache) throws ConcurrentUpdateSqlException, Exception {\n  checkAccessFor_ADMIN();\n  amount=amount.abs();\n  long id=universal.nextSeqFor(payments);\n  PaymentExt payment=PaymentExt.createSystemPayment(id,userId,amount,created,payType,details);\n  BigDecimal newVal=doPayment(userId,payment,updateCache);\n  log.info(\"pay added: userId=\" + userId + (newVal != null ? \", newBalance=\" + newVal : \"\")+ \", req=\"+ getReqInfoStr());\n}\n", "docstring": "positive amount . no unblocks if blocked", "partition": "test"}
{"idx": "497", "code": "private int keyToLevel(String key){\n  String[] token=key.split(\"/\");\n  return (token.length - 1);\n}\n", "docstring": "given a key , find the level", "partition": "test"}
{"idx": "437", "code": "public static <T>CompletableFuture<T> exceptionallyCompletedFuture(Throwable throwable){\n  final CompletableFuture<T> future=new CompletableFuture<T>();\n  future.completeExceptionally(throwable);\n  return future;\n}\n", "docstring": "returns a new completablefuture that is already exceptionally completed with the given exception .", "partition": "test"}
{"idx": "3170", "code": "public static ServiceConfiguration create(InputStream inStream) throws IOException, IllegalArgumentException {\n  try {\n    checkNotNull(inStream);\n    Properties properties=new Properties();\n    properties.load(inStream);\n    return (create(properties));\n  }\n  finally {\n    if (inStream != null) {\n      inStream.close();\n    }\n  }\n}\n", "docstring": "creates serviceconfiguration and loads it with populated attribute values loaded from provided inputstream property file .", "partition": "test"}
{"idx": "1786", "code": "public boolean isFingerprint(ClassTemplate classTemplate){\n  return fingerprintClass.equals(classTemplate.getImplementingClass());\n}\n", "docstring": "tests if a template contains methods with signatures that are required by the filter object . the filter object is meant to be a \" self reflecting \" object . meaning it can be cast to usable interfaces without explicitly reflecting the classes .", "partition": "test"}
{"idx": "2767", "code": "private void updateMenuState(){\n  m_appendAnd.setEnabled(m_criteriumNode.allowAppend(CAndCriterium.class));\n  m_appendOr.setEnabled(m_criteriumNode.allowAppend(COrCriterium.class));\n  m_appendNot.setEnabled(m_criteriumNode.allowAppend(CNotCriterium.class));\n  m_insertAnd.setEnabled(m_criteriumNode.allowInsert(CAndCriterium.class));\n  m_insertOr.setEnabled(m_criteriumNode.allowInsert(COrCriterium.class));\n  m_insertNot.setEnabled(m_criteriumNode.allowInsert(CNotCriterium.class));\n  m_conditionSubmenu.setEnabled(m_criteriumNode.allowAppend(CConditionCriterium.class));\n  m_remove.setEnabled(!m_criteriumNode.isRoot());\n  m_removeAll.setEnabled(m_criteriumNode.getChildCount() != 0);\n}\n", "docstring": "updates the state of the context menu depending on the state of the criterium tree .", "partition": "test"}
{"idx": "2354", "code": "private boolean canContain(ElementContainmentInfo child,ElementContainmentInfo top,int topIndex){\n  int childTypes=child.types;\n  int contents=top.contents;\n  int transparencyAllowed=childTypes & (top.transparentToContents & ~contents);\n  for (int containerIndex=topIndex - 1; transparencyAllowed != 0; --containerIndex) {\n    if (containerIndex < 0) {\n      contents|=transparencyAllowed;\n      break;\n    }\n    ElementContainmentInfo container=openElements.get(containerIndex);\n    contents|=transparencyAllowed & container.contents;\n    transparencyAllowed=transparencyAllowed & container.transparentToContents & ~contents;\n  }\n  return (contents & childTypes) != 0;\n}\n", "docstring": "takes into account transparency when figuring out what can be contained .", "partition": "test"}
{"idx": "1791", "code": "public synchronized void show(Bundle options){\n  if (DEBUG)   Log.d(TAG,\"show(); mKeyguardView==\" + mKeyguardView);\n  boolean enableScreenRotation=shouldEnableScreenRotation();\n  maybeCreateKeyguardLocked(enableScreenRotation,false,options);\n  maybeEnableScreenRotation(enableScreenRotation);\n  final int visFlags=View.STATUS_BAR_DISABLE_HOME;\n  if (DEBUG)   Log.v(TAG,\"show:setSystemUiVisibility(\" + Integer.toHexString(visFlags) + \")\");\n  mKeyguardHost.setSystemUiVisibility(visFlags);\n  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);\n  mKeyguardHost.setVisibility(View.VISIBLE);\n  mKeyguardView.show();\n  mKeyguardView.requestFocus();\n}\n", "docstring": "show the keyguard . will handle creating and attaching to the view manager lazily .", "partition": "test"}
{"idx": "3615", "code": "public static void removeConnectionList(Integer tab){\n  TABBED_CONNECTIONS.remove(tab.intValue());\n}\n", "docstring": "remove the list of connections at the supplied index", "partition": "test"}
{"idx": "2944", "code": "public static <T>T jsonToObject(String jsonString,Class<T> klass){\n  T objectFromJson=null;\n  try {\n    GfJsonObject jsonObject=new GfJsonObject(jsonString);\n    objectFromJson=klass.newInstance();\n    Method[] declaredMethods=klass.getDeclaredMethods();\n    Map<String,Method> methodsMap=new HashMap<String,Method>();\n    for (    Method method : declaredMethods) {\n      methodsMap.put(method.getName(),method);\n    }\n    int noOfFields=jsonObject.size();\n    Iterator<String> keys=jsonObject.keys();\n    while (keys.hasNext()) {\n      String key=keys.next();\n      Method method=methodsMap.get(\"set\" + capitalize(key));\n      if (method != null) {\n        Class<?>[] parameterTypes=method.getParameterTypes();\n        if (parameterTypes.length == 1) {\n          Class<?> parameterType=parameterTypes[0];\n          Object value=jsonObject.get(key);\n          if (isPrimitiveOrWrapper(parameterType)) {\n            value=getPrimitiveOrWrapperValue(parameterType,value);\n          }\n else           if (isArray(parameterType)) {\n            value=toArray(value,parameterType);\n          }\n else           if (isList(parameterType)) {\n            value=toList(value,parameterType);\n          }\n else           if (isMap(parameterType)) {\n            value=toMap(value,parameterType);\n          }\n else           if (isSet(parameterType)) {\n            value=toSet(value,parameterType);\n          }\n else {\n            value=jsonToObject(value.toString(),parameterType);\n          }\n          method.invoke(objectFromJson,new Object[]{value});\n          noOfFields--;\n        }\n      }\n    }\n    if (noOfFields != 0) {\n      throw new IllegalArgumentException(\"Not enough setter methods for fields in given JSON String : \" + jsonString + \" in class : \"+ klass);\n    }\n  }\n catch (  InstantiationException e) {\n    throw new IllegalArgumentException(\"Couldn\\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  IllegalAccessException e) {\n    throw new IllegalArgumentException(\"Couldn\\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  GfJsonException e) {\n    throw new IllegalArgumentException(\"Couldn\\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  IllegalArgumentException e) {\n    throw new IllegalArgumentException(\"Couldn\\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  InvocationTargetException e) {\n    throw new IllegalArgumentException(\"Couldn\\'t convert JSON to Object of type \" + klass,e);\n  }\n  return objectFromJson;\n}\n", "docstring": "converts given json string in to a object . refer http : / / www . json . org / to construct a json format .", "partition": "test"}
{"idx": "1932", "code": "@Override public synchronized void clear(){\n  File[] files=mRootDirectory.listFiles();\n  if (files != null) {\n    for (    File file : files) {\n      file.delete();\n    }\n  }\n  mEntries.clear();\n  VolleyLog.d(\"Cache cleared.\");\n}\n", "docstring": "clears the cache . deletes all cached files from disk .", "partition": "test"}
{"idx": "159", "code": "protected void markUsed(Entry entry){\n  entry.lastUsed=System.nanoTime();\n}\n", "docstring": "marks the specified entry as used by setting its last used time to the current time in nanoseconds .", "partition": "test"}
{"idx": "2699", "code": "private static double norm(final double[] v){\n  double agg=0;\n  for (int i=0; i < v.length; i++) {\n    agg+=(v[i] * v[i]);\n  }\n  return Math.sqrt(agg);\n}\n", "docstring": "returns the norm l2 . sqrt ( sum_i ( v_i ^ 2 ) )", "partition": "test"}
{"idx": "878", "code": "private void notifyClassObservers(ClassDescriptor classDescriptor){\n  for (  IClassObserver observer : classObserverList) {\n    observer.observeClass(classDescriptor);\n  }\n}\n", "docstring": "notify all iclassobservers that we are visiting given class .", "partition": "test"}
{"idx": "3699", "code": "public BusMovement(BusMovement proto){\n  super(proto);\n  this.controlSystem=proto.controlSystem;\n  this.id=nextID++;\n  controlSystem.registerBus(this);\n  startMode=true;\n}\n", "docstring": "create a new instance from a prototype", "partition": "test"}
{"idx": "472", "code": "private long buildSize(int durationInSeconds,LinkInfo linfo){\n  long result=-1;\n  double bitRateSum=0;\nswitch (linfo.fmt) {\ncase 5:\n    bitRateSum=0.25 + 64d / 1024d;\n  break;\ncase 6:\nbitRateSum=0.8 + 64d / 1024d;\nbreak;\ncase 17:\nbitRateSum=0.05 + 24d / 1024d;\nbreak;\ncase 18:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 22:\nbitRateSum=2.9 + 192d / 1024d;\nbreak;\ncase 34:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 35:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 36:\nbitRateSum=0.17 + 38d / 1024d;\nbreak;\ncase 37:\nbitRateSum=5.9 + 192d / 1024d;\nbreak;\ncase 38:\nbitRateSum=5 + 192d / 1024d;\nbreak;\ncase 43:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 44:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 45:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 46:\nbitRateSum=3 + 192d / 1024d;\nbreak;\ncase 82:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 83:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 84:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 85:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 100:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 101:\nbitRateSum=1 + 192d / 1024d;\nbreak;\ncase 102:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 133:\nbitRateSum=0.3 + 256d / 1024d;\nbreak;\ncase 134:\nbitRateSum=0.4 + 256d / 1024d;\nbreak;\ncase 135:\nbitRateSum=1 + 256d / 1024d;\nbreak;\ncase 136:\nbitRateSum=1.5 + 256d / 1024d;\nbreak;\ncase 137:\nbitRateSum=2.9 + 256d / 1024d;\nbreak;\ncase 139:\nbitRateSum=48d / 1024d;\nbreak;\ncase 140:\nbitRateSum=128d / 1024d;\nbreak;\ncase 141:\nbitRateSum=256d / 1024d;\nbreak;\n}\nbitRateSum=bitRateSum * 1024 * 1024;\nresult=(long)(Math.ceil((bitRateSum * durationInSeconds) / 8));\nreturn result;\n}\n", "docstring": "upper guess to determine the duration in bytes , using highest bitrate of the stream .", "partition": "test"}
{"idx": "2642", "code": "public void flush() throws IOException {\n  WspUtil.writeUint8(os_,0x01);\n  writePublicIdentifier(os_,publicID_);\n  WspUtil.writeUintvar(os_,WapConstants.MIB_ENUM_UTF_8);\n  writeStringTable(os_);\n  wbxmlBody_.close();\n  wbxmlBody_.writeTo(os_);\n  os_.flush();\n}\n", "docstring": "writes the wbxml to stream .", "partition": "test"}
{"idx": "240", "code": "public void addDropItem(final String name,final double probability,final int min,final int max){\n  dropsItems.add(new DropItem(name,probability,min,max));\n}\n", "docstring": "adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn \"'\" t been called first , this will change all creatures of this kind .", "partition": "test"}
{"idx": "800", "code": "protected boolean checkExternalStorageAndNotify(String fileName){\n  if (fileName != null && fileName.startsWith(\"null\")) {\n    alertDownloadFailure(R.string.download_no_sdcard_dlg_title);\n    return false;\n  }\n  String status=Environment.getExternalStorageState();\n  if (!status.equals(Environment.MEDIA_MOUNTED)) {\n    int title;\n    if (status.equals(Environment.MEDIA_SHARED)) {\n      title=R.string.download_sdcard_busy_dlg_title;\n    }\n else {\n      title=R.string.download_no_sdcard_dlg_title;\n    }\n    alertDownloadFailure(title);\n    return false;\n  }\n  return true;\n}\n", "docstring": "check the external storage and notify user on error .", "partition": "test"}
{"idx": "4004", "code": "@Override public synchronized void start(){\n  LOGGER.info(\"Starting the C2MON alive timer mechanism.\");\n  timer=new Timer(\"C2MON-alive-timer\");\n  timer.schedule(this,INITIAL_SCAN_DELAY,SCAN_INTERVAL);\n  running=true;\n}\n", "docstring": "starts the timer . alive timers will be checked from then on .", "partition": "test"}
{"idx": "1939", "code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver observer){\n  if (img == null) {\n    return true;\n  }\n  if (xform == null || xform.isIdentity()) {\n    return drawImage(img,0,0,null,observer);\n  }\n  if (isHiDPIImage(img)) {\n    final int w=img.getWidth(null);\n    final int h=img.getHeight(null);\n    final AffineTransform tx=new AffineTransform(transform);\n    transform(xform);\n    boolean result=drawHiDPIImage(img,0,0,w,h,0,0,w,h,null,observer);\n    transform.setTransform(tx);\n    invalidateTransform();\n    return result;\n  }\n  try {\n    return imagepipe.transformImage(this,img,xform,observer);\n  }\n catch (  InvalidPipeException e) {\n    try {\n      revalidateAll();\n      return imagepipe.transformImage(this,img,xform,observer);\n    }\n catch (    InvalidPipeException e2) {\n      return false;\n    }\n  }\n finally {\n    surfaceData.markDirty();\n  }\n}\n", "docstring": "draw an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics2d . the given transformation is applied to the image before the transform attribute in the graphics2d state is applied . the rendering attributes applied include the clip , transform , paint or color and composite attributes . note that the result is undefined , if the given transform is non - invertible .", "partition": "test"}
{"idx": "1894", "code": "public boolean isSourceModified(Resource resource){\n  boolean modified=true;\n  String fileName=resource.getName();\n  String path=(String)templatePaths.get(fileName);\n  File currentFile=null;\n  for (int i=0; currentFile == null && i < paths.size(); i++) {\n    String testPath=(String)paths.get(i);\n    File testFile=new File(testPath,fileName);\n    if (testFile.canRead()) {\n      currentFile=testFile;\n    }\n  }\n  File file=new File(path,fileName);\n  if (currentFile == null || !file.exists()) {\n  }\n else   if (currentFile.equals(file) && file.canRead()) {\n    modified=(file.lastModified() != resource.getLastModified());\n  }\n  return modified;\n}\n", "docstring": "how to keep track of all the modified times across the paths . note that a file might have appeared in a directory which is earlier in the path ; so we should search the path and see if the file we find that way is the same as the one that we have cached .", "partition": "test"}
{"idx": "1053", "code": "public void expandAndSelectIfExists(RepositoryLocation location){\n  if (location.parent() != null) {\n    expandIfExists(location.parent(),location.getName());\n  }\n else {\n    expandIfExists(location,null);\n  }\n  scrollPathToVisible(getSelectionPath());\n}\n", "docstring": "expands the tree to select the given entry if it exists .", "partition": "test"}
{"idx": "1398", "code": "protected JavaElementDelta createDeltaTree(IJavaElement element,JavaElementDelta delta){\n  JavaElementDelta childDelta=delta;\n  ArrayList ancestors=getAncestors(element);\n  if (ancestors == null) {\n    if (equalsAndSameParent(delta.getElement(),getElement())) {\n      this.kind=delta.kind;\n      this.changeFlags=delta.changeFlags;\n      this.movedToHandle=delta.movedToHandle;\n      this.movedFromHandle=delta.movedFromHandle;\n    }\n  }\n else {\n    for (int i=0, size=ancestors.size(); i < size; i++) {\n      IJavaElement ancestor=(IJavaElement)ancestors.get(i);\n      JavaElementDelta ancestorDelta=new JavaElementDelta(ancestor);\n      ancestorDelta.addAffectedChild(childDelta);\n      childDelta=ancestorDelta;\n    }\n  }\n  return childDelta;\n}\n", "docstring": "creates the nested delta deltas based on the affected element its delta , and the root of this delta tree . returns the root of the created delta tree .", "partition": "test"}
{"idx": "753", "code": "public void showDroidsafeTextMarkers(IEditorPart openedEditor,String className){\n  if (openedEditor != null && openedEditor instanceof ITextEditor && fProcessedClasses != null) {\n    ITextEditor editor=(ITextEditor)openedEditor;\n    if (fProcessedClasses.contains(className)) {\n      if (fClassesNeedUpdate.contains(className)) {\n        ClassMarkerProcessor classProcessor=get(className);\n        classProcessor.updateTaintMarkers(editor);\n        fClassesNeedUpdate.remove(className);\n      }\n    }\n else {\n      fProcessedClasses.add(className);\n      Map<String,Map<IntRange,Map<String,Set<CallLocationModel>>>> classTaintedDataMap=fTaintedDataMap.get(className);\n      Map<String,Set<IntRange>> classUnreachableMethodMap=fUnreachableSourceMethodMap.get(className);\n      if (classTaintedDataMap != null || classUnreachableMethodMap != null) {\n        IEditorInput input=editor.getEditorInput();\n        if (input instanceof FileEditorInput) {\n          ClassMarkerProcessor classProcessor=get(className);\n          classProcessor.showDroidsafeTextMarkers(editor);\n        }\n      }\n    }\n  }\n}\n", "docstring": "displays the annotations of the droidsafe text markers for the given class name in the given java editor .", "partition": "test"}
{"idx": "48", "code": "protected boolean needToRefetchData(){\n  long now=System.currentTimeMillis();\n  long last=lastDataFetchTime;\n  if ((last + fetchIntervalMillis) < now) {\n    lastDataFetchTime=now;\n    return true;\n  }\n  return false;\n}\n", "docstring": "fetches data if it hasn \"'\" t been fetched in a while .", "partition": "test"}
{"idx": "2420", "code": "public static boolean isEmbeddedBase64Image(String uri){\n  return (uri != null && uri.startsWith(\"data:image/\"));\n}\n", "docstring": "detect if an uri represents an embedded base 64 image .", "partition": "test"}
{"idx": "3939", "code": "public static final void writeStringArrayXml(String[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"string-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  for (int i=0; i < N; i++) {\n    out.startTag(null,\"item\");\n    out.attribute(null,\"value\",val[i]);\n    out.endTag(null,\"item\");\n  }\n  out.endTag(null,\"string-array\");\n}\n", "docstring": "flatten a string [ ", "partition": "test"}
{"idx": "153", "code": "public void mouseClicked(MouseEvent e){\n  if (e.getClickCount() > 1) {\n    System.gc();\n  }\n}\n", "docstring": "invoked when the mouse has been clicked on a component .", "partition": "test"}
{"idx": "1698", "code": "public static Subject createAMIdentitySubject(PolicyManager pm,AMIdentity user) throws PolicyException {\n  SubjectTypeManager mgr=pm.getSubjectTypeManager();\n  Subject subject=mgr.getSubject(\"AMIdentitySubject\");\n  Set<String> set=new HashSet<String>();\n  set.add(user.getUniversalId());\n  subject.setValues(set);\n  return subject;\n}\n", "docstring": "returns a subject for the given amidentity .", "partition": "test"}
{"idx": "3089", "code": "private Shape decodeEdge(int width,int height){\n  path.reset();\n  path.moveTo(width - 2,0);\n  path.lineTo(width - 2,height - 4);\n  path.lineTo(width - 4,height - 2);\n  path.lineTo(3,height - 2);\n  return path;\n}\n", "docstring": "create the button edge shape .", "partition": "test"}
{"idx": "3438", "code": "public static String inflate(String name){\n  return inflate(name,gPrefix);\n}\n", "docstring": "inflate a short name into a full gdata uri using gprefix ( ending in \" # \" ) . names that already look like uris are left alone . for example , \" foo \" becomes \" http : / / schemas . google . com / g / 2005 # foo \" .", "partition": "test"}
{"idx": "3462", "code": "@SuppressLint(\"DrawAllocation\") @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int maxWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int maxHeight=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.UNSPECIFIED)   maxWidth=Integer.MAX_VALUE;\n  if (heightMode == MeasureSpec.UNSPECIFIED)   maxHeight=Integer.MAX_VALUE;\n  int paddingLeft=getPaddingLeft();\n  int paddingTop=getPaddingTop();\n  int paddingRight=getPaddingRight();\n  int paddingBottom=getPaddingBottom();\n  int maxRightBound=maxWidth - paddingRight;\n  int maxBottomBound=maxHeight - paddingBottom;\n  int left;\n  int top;\n  int right;\n  int bottom;\n  int rightBound=paddingLeft;\n  int maxRightNoPadding=rightBound;\n  int bottomBound;\n  int lastMaxBottom=paddingTop;\n  int maxBottom=lastMaxBottom;\n  int childWidth;\n  int childHeight;\n  int lineStartIndex=0;\n  int lineEndIndex=0;\n  rectList.clear();\n  int childCount=getChildCount();\n  for (int index=0; index < childCount; index++) {\n    final View child=getChildAt(index);\n    child.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);\n    if (child.getVisibility() == View.GONE)     continue;\n    final AutoWrapLayout.LayoutParams lp=(AutoWrapLayout.LayoutParams)child.getLayoutParams();\n    childWidth=child.getMeasuredWidth();\n    childHeight=child.getMeasuredHeight();\n    left=rightBound + lp.leftMargin;\n    right=left + childWidth;\n    rightBound=right + lp.rightMargin;\n    if (rightBound > maxRightBound) {\n      lineEndIndex=index;\n      adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,lineEndIndex);\n      if (maxBottom >= maxBottomBound)       break;\n      if (lineEndIndex == lineStartIndex) {\n        child.measure(MeasureSpec.makeMeasureSpec(maxWidth - paddingLeft - paddingRight- lp.leftMargin- lp.rightMargin,MeasureSpec.AT_MOST),MeasureSpec.UNSPECIFIED);\n        childWidth=child.getMeasuredWidth();\n        childHeight=child.getMeasuredHeight();\n      }\n      left=paddingLeft + lp.leftMargin;\n      right=left + childWidth;\n      rightBound=right + lp.rightMargin;\n      lastMaxBottom=maxBottom;\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n      lineStartIndex=index;\n    }\n else {\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n    }\n    if (rightBound > maxRightNoPadding)     maxRightNoPadding=rightBound;\n    if (bottomBound > maxBottom)     maxBottom=bottomBound;\n    Rect rect=new Rect();\n    rect.left=left;\n    rect.top=top;\n    rect.right=right;\n    rect.bottom=bottom;\n    rectList.add(rect);\n  }\n  adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,rectList.size());\n  int measuredWidth;\n  int measuredHeight;\n  if (widthMode == MeasureSpec.EXACTLY)   measuredWidth=maxWidth;\n else   measuredWidth=maxRightNoPadding + paddingRight;\n  if (heightMode == MeasureSpec.EXACTLY)   measuredHeight=maxHeight;\n else {\n    measuredHeight=maxBottom + paddingBottom;\n    if (heightMode == MeasureSpec.AT_MOST)     measuredHeight=measuredHeight > maxHeight ? maxHeight : measuredHeight;\n  }\n  setMeasuredDimension(measuredWidth,measuredHeight);\n}\n", "docstring": "each row or line at least show one child horizontal only show child can show or partly show in parent", "partition": "test"}
{"idx": "514", "code": "protected final StringBuilder write(StringBuilder sb,final Object... objects){\n  for (  Object string : objects)   sb.append(string);\n  return sb;\n}\n", "docstring": "this method adds to the sb the objects .", "partition": "test"}
{"idx": "919", "code": "protected final void firePropertyChange(PropertyChangeEvent evt){\n  pcs.firePropertyChange(evt);\n}\n", "docstring": "fire an existing propertychangeevent to any registered listeners . no event is fired if the given event \"'\" s old and new values are equal and non - null .", "partition": "test"}
{"idx": "106", "code": "public grammaticalityEstimator(Set FileNames,int iMinChar,int iMaxChar,int iCharWindow,int iMinWord,int iMaxWord,int iWordWindow){\n  iMinCharNGram=iMinChar;\n  iMaxCharNGram=iMaxChar;\n  iMinWordNGram=iMinWord;\n  iMaxWordNGram=iMaxWord;\n  iWordDist=iWordWindow;\n  iCharDist=iCharWindow;\n  DistroDocs=new TreeMap<Integer,DistributionDocument>();\n  DistroWordDocs=new TreeMap<Integer,DistributionWordDocument>();\n  StringBuffer sb=new StringBuffer();\n  Iterator iTexts=FileNames.iterator();\n  while (iTexts.hasNext()) {\n    String sFile=(String)iTexts.next();\n    try {\n      BufferedReader bf=new BufferedReader(new FileReader(sFile));\n      String sTmp;\n      while ((sTmp=bf.readLine()) != null)       sb.append(sTmp);\n      bf.close();\n    }\n catch (    FileNotFoundException ex) {\n      ex.printStackTrace(System.err);\n    }\ncatch (    IOException ex) {\n      ex.printStackTrace(System.err);\n    }\n    sb.append((char)0);\n  }\n  FullTextDataString=sb.toString();\n  for (int iCnt=iMinCharNGram; iCnt <= iMaxCharNGram; iCnt++) {\n    DistroDocs.put(iCnt,new DistributionDocument(iCharDist,iCnt));\n  }\n  for (int iCnt=iMinWordNGram; iCnt <= iMaxWordNGram; iCnt++) {\n    DistroWordDocs.put(iCnt,new DistributionWordDocument(iWordDist,iCnt));\n  }\n}\n", "docstring": "creates a new instance of grammaticalityestimator , using a given set of documents for training .", "partition": "test"}
{"idx": "3193", "code": "public void runCommercial(String stream,int length){\n  if (stream == null || stream.isEmpty()) {\n    commercialResult(stream,\"Can\\'t run commercial, not on a channel.\",TwitchApi.RequestResult.FAILED);\n  }\n else {\n    String channel=\"#\" + stream;\n    if (isChannelOpen(channel)) {\n      g.printLine(channel,\"Trying to run \" + length + \"s commercial..\");\n    }\n else {\n      g.printLine(\"Trying to run \" + length + \"s commercial.. (\"+ stream+ \")\");\n    }\n    api.runCommercial(stream,settings.getString(\"token\"),length);\n  }\n}\n", "docstring": "tries to run a commercial on the given stream with the given length . outputs a message about it in the appropriate channel .", "partition": "test"}
{"idx": "1364", "code": "private void resolveProtocols(ClassLoader loader){\n  ServiceLoader<ProtocolManagerFactory> serviceLoader=ServiceLoader.load(ProtocolManagerFactory.class,loader);\n  loadProtocolManagerFactories(serviceLoader);\n}\n", "docstring": "finds protocol support from a given classloader .", "partition": "test"}
{"idx": "219", "code": "public static double normalPDF(double x,double variance,double meanValue){\n  double standardDeviation=Math.sqrt(variance);\n  return (1 / (standardDeviation * Math.sqrt(2 * Math.PI))) * Math.pow(Math.E,-((x - meanValue) * (x - meanValue)) / (2 * variance));\n}\n", "docstring": "calculate a normal probability density function ( pdf ) based on a variance and mean value", "partition": "test"}
{"idx": "1281", "code": "private static void renderHandler(FacesContext context,UIComponent component,Collection<ClientBehaviorContext.Parameter> params,String handlerName,Object handlerValue,String behaviorEventName,String submitTarget,boolean needsSubmit,boolean includeExec) throws IOException {\n  ResponseWriter writer=context.getResponseWriter();\n  String userHandler=getNonEmptyUserHandler(handlerValue);\n  List<ClientBehavior> behaviors=getClientBehaviors(component,behaviorEventName);\n  if ((null != behaviors) && (behaviors.size() > 0) && Util.componentIsDisabled(component)) {\n    behaviors=null;\n  }\n  if (params == null) {\n    params=Collections.emptyList();\n  }\n  String handler=null;\nswitch (getHandlerType(behaviors,params,userHandler,needsSubmit,includeExec)) {\ncase USER_HANDLER_ONLY:\n    handler=userHandler;\n  break;\ncase SINGLE_BEHAVIOR_ONLY:\nhandler=getSingleBehaviorHandler(context,component,behaviors.get(0),params,behaviorEventName,submitTarget,needsSubmit);\nbreak;\ncase SUBMIT_ONLY:\nhandler=getSubmitHandler(context,component,params,submitTarget,true);\nbreak;\ncase CHAIN:\nhandler=getChainedHandler(context,component,behaviors,params,behaviorEventName,userHandler,submitTarget,needsSubmit);\nbreak;\ndefault :\nassert (false);\n}\nwriter.writeAttribute(handlerName,handler,null);\n}\n", "docstring": "renders a handler script , which may require chaining together the user - specified event handler , any scripts required by attached behaviors , and also possibly the mojarra . jsfcljs ( ) \" submit \" script .", "partition": "test"}
{"idx": "3863", "code": "public static double[] parseVectorString(String vectorString){\n  String[] parsedString=vectorString.split(\",\");\n  double[] vector=new double[parsedString.length];\n  for (int j=0; j < parsedString.length; j++) {\n    double val=Utils.doubleParsable(parsedString[j]);\n    vector[j]=Double.isNaN(val) ? 0 : val;\n  }\n  return vector;\n}\n", "docstring": "converts a string representation of a vector ( e . g . \" 1 , 0 , 0 , 1 , 0 \" ) into a double array . invalid characters are converted to 0 .", "partition": "test"}
{"idx": "1394", "code": "void addString(int c){\n  if (strpos == str.length) {\n    char newstr[]=new char[str.length + 128];\n    System.arraycopy(str,0,newstr,0,str.length);\n    str=newstr;\n  }\n  str[strpos++]=(char)c;\n}\n", "docstring": "add a char to the string buffer .", "partition": "test"}
{"idx": "3606", "code": "public void testBytesAsSource() throws Exception {\n  String JSON=\"[ 1, 2, 3, 4 ]\";\n  byte[] b=JSON.getBytes(\"UTF-8\");\n  int offset=50;\n  int len=b.length;\n  byte[] src=new byte[offset + len + offset];\n  System.arraycopy(b,0,src,offset,len);\n  JsonFactory jf=new JsonFactory();\n  JsonParser jp=jf.createJsonParser(src,offset,len);\n  assertToken(JsonToken.START_ARRAY,jp.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(1,jp.getIntValue());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(2,jp.getIntValue());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(3,jp.getIntValue());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(4,jp.getIntValue());\n  assertToken(JsonToken.END_ARRAY,jp.nextToken());\n  assertNull(jp.nextToken());\n  jp.close();\n}\n", "docstring": "simple unit test that verifies that passing in a byte array as source works as expected .", "partition": "test"}
{"idx": "2792", "code": "private synchronized boolean startDequeue(){\n  int threads=Math.min(queue.size(),maxThreads);\n  for (int i=0; i < threads; i++) {\n    ResourceThread t=(ResourceThread)queue.firstElement();\n    queue.removeElementAt(0);\n    running.addElement(t);\n    threadCount++;\n  }\n  for (Enumeration e=running.elements(); e.hasMoreElements(); ) {\n    ResourceThread t=(ResourceThread)e.nextElement();\n    t.go();\n  }\n  return (threads > 0);\n}\n", "docstring": "starts dequeuing the queue into the running pool and launch them", "partition": "test"}
{"idx": "4249", "code": "public static Operation createOperationToUpdateOrCreateNetworkInterface(ComputeState existingComputeState,NetworkInterfaceState networkInterface,List<String> tenantLinks,StatelessService service,boolean isPublic){\n  String existingInterfaceLink=getExistingNetworkInterfaceLink(existingComputeState,isPublic);\n  Operation networkInterfaceOperation=null;\n  if (existingInterfaceLink == null) {\n    networkInterfaceOperation=createPostOperation(service,networkInterface,NetworkInterfaceService.FACTORY_LINK);\n  }\n else {\n    networkInterfaceOperation=createPatchOperation(service,networkInterface,existingInterfaceLink);\n  }\n  return networkInterfaceOperation;\n}\n", "docstring": "compares the ip addresses of the instance on aws and maps those to the network interfaces in the system . 1 ) if an existing mapping is found for a private or public interface then it is updated . 2 ) else a new mapping is creating . 3 ) the string \" public - interface / private - interfaces \" is embedded in the document self link along with the uuid to avoid collisions while save some extra lookups during updates .", "partition": "test"}
{"idx": "3538", "code": "protected void onFailedClosingUrlConnection(URLConnection urlConnection,IOException cause){\n}\n", "docstring": "override if you want to get notified if the url connection fails to close . does nothing by default .", "partition": "test"}
{"idx": "1729", "code": "public Perspective createUserPerspective(final String name,final boolean show){\n  Perspective perspective=model.addPerspective(name,true);\n  perspective.store(context);\n  if (show) {\n    showPerspective(name);\n  }\n  return perspective;\n}\n", "docstring": "creates a user - defined perspectives , and possibly switches to this new perspective immediately . the new perspective will be a copy of the current one .", "partition": "test"}
{"idx": "3654", "code": "public ModifiableSolrParams add(String name,String... val){\n  String[] old=vals.put(name,val);\n  if (old != null) {\n    if (val == null || val.length < 1) {\n      String[] both=new String[old.length + 1];\n      System.arraycopy(old,0,both,0,old.length);\n      both[old.length]=null;\n      vals.put(name,both);\n    }\n else {\n      String[] both=new String[old.length + val.length];\n      System.arraycopy(old,0,both,0,old.length);\n      System.arraycopy(val,0,both,old.length,val.length);\n      vals.put(name,both);\n    }\n  }\n  return this;\n}\n", "docstring": "add the given values to any existing name", "partition": "test"}
{"idx": "1937", "code": "public static SortedSet<Integer> adjustPosition(Set<Integer> positions,int startPosition,int endPosition,int adjustBy){\n  SortedSet<Integer> newPositions=new TreeSet<>();\n  for (  Integer entry : positions) {\n    int position=entry;\n    if (position < startPosition || position > endPosition) {\n      newPositions.add(position);\n    }\n else     if (adjustBy > 0) {\n      newPositions.add(position + adjustBy);\n    }\n else     if (adjustBy < 0) {\n      if (position > startPosition + adjustBy && position <= startPosition) {\n        ;\n      }\n else {\n        newPositions.add(position + adjustBy);\n      }\n    }\n  }\n  return newPositions;\n}\n", "docstring": "internal method to handle the selections if items are added / removed", "partition": "test"}
{"idx": "3838", "code": "protected static byte[] hkdfExpand(byte[] ikm,byte[] salt,byte[] info,int length) throws InvalidKeyException, NoSuchAlgorithmException {\n  HKDFBytesGenerator hkdf=new HKDFBytesGenerator(new SHA256Digest());\n  hkdf.init(new HKDFParameters(ikm,salt,info));\n  byte[] okm=new byte[length];\n  hkdf.generateBytes(okm,0,length);\n  return okm;\n}\n", "docstring": "convenience method for computing the hmac key derivation function . the real work is offloaded to bouncycastle .", "partition": "test"}
{"idx": "269", "code": "private static double parseDoubleValue(String parseString,String openTag,String closeTag,DataTypeValidationException exception) throws DataTypeValidationException {\n  String tagValue;\n  tagValue=parseStringValue(parseString,openTag,closeTag,exception);\n  double doubleValue;\n  try {\n    doubleValue=Double.parseDouble(tagValue);\n  }\n catch (  NumberFormatException e) {\n    throw e;\n  }\n  return doubleValue;\n}\n", "docstring": "parses out and converts the text located between first occurrences of the open and closed tags into double .", "partition": "test"}
{"idx": "3499", "code": "public LayoutBlock createNewLayoutBlock(String systemName,String userName){\n  LayoutBlock block=null;\n  if (userName == null || userName.equals(\"\")) {\n    log.error(\"Attempt to create a LayoutBlock with no user name\");\n    return null;\n  }\n  block=getByUserName(userName);\n  if (block != null) {\n    return null;\n  }\n  String sName=\"\";\n  if (systemName == null) {\n    boolean found=true;\n    while (found) {\n      sName=\"ILB\" + blkNum;\n      blkNum++;\n      block=getBySystemName(sName);\n      if (block == null) {\n        found=false;\n      }\n    }\n  }\n else {\n    block=getBySystemName((systemName.toUpperCase()));\n    if (block != null) {\n      return null;\n    }\n    sName=systemName.toUpperCase();\n  }\n  block=new LayoutBlock(sName,userName);\n  register(block);\n  return block;\n}\n", "docstring": "method to create a new layoutblock if the layoutblock does not exist returns null if a layoutblock with the same systemname or username already exists , or if there is trouble creating a new layoutblock . note that since the username is used to address layoutblocks , the user name must be present . if the user name is not present , the new layoutblock is not created , and null is returned .", "partition": "test"}
{"idx": "4194", "code": "private synchronized void postEvent(EventInfo eventInfo){\n  eventQueue.add(eventInfo);\n  notifyAll();\n}\n", "docstring": "queue the given event in the event queue .", "partition": "test"}
{"idx": "2885", "code": "long cleanup(long now){\n  int inUseConnectionCount=0;\n  int idleConnectionCount=0;\n  RealConnection longestIdleConnection=null;\n  long longestIdleDurationNs=Long.MIN_VALUE;\nsynchronized (this) {\n    for (Iterator<RealConnection> i=connections.iterator(); i.hasNext(); ) {\n      RealConnection connection=i.next();\n      if (pruneAndGetAllocationCount(connection,now) > 0) {\n        inUseConnectionCount++;\n        continue;\n      }\n      idleConnectionCount++;\n      long idleDurationNs=now - connection.idleAtNanos;\n      if (idleDurationNs > longestIdleDurationNs) {\n        longestIdleDurationNs=idleDurationNs;\n        longestIdleConnection=connection;\n      }\n    }\n    if (longestIdleDurationNs >= this.keepAliveDurationNs || idleConnectionCount > this.maxIdleConnections) {\n      connections.remove(longestIdleConnection);\n    }\n else     if (idleConnectionCount > 0) {\n      return keepAliveDurationNs - longestIdleDurationNs;\n    }\n else     if (inUseConnectionCount > 0) {\n      return keepAliveDurationNs;\n    }\n else {\n      cleanupRunning=false;\n      return -1;\n    }\n  }\n  closeQuietly(longestIdleConnection.socket());\n  return 0;\n}\n", "docstring": "performs maintenance on this pool , evicting the connection that has been idle the longest if either it has exceeded the keep alive limit or the idle connections limit . < p > returns the duration in nanos to sleep until the next scheduled call to this method . returns - 1 if no further cleanups are required .", "partition": "test"}
{"idx": "1150", "code": "default Document putAll(Map<? extends CharSequence,Object> fields){\n  if (fields != null) {\n    for (    Map.Entry<? extends CharSequence,Object> entry : fields.entrySet()) {\n      set(entry.getKey(),entry.getValue());\n    }\n  }\n  return this;\n}\n", "docstring": "sets on this object all key / value pairs from the supplied map . if the supplied map is null , this method does nothing .", "partition": "test"}
{"idx": "90", "code": "MutableBigInteger(MutableBigInteger val){\n  intLen=val.intLen;\n  value=Arrays.copyOfRange(val.value,val.offset,val.offset + intLen);\n}\n", "docstring": "construct a new mutablebiginteger with a magnitude equal to the specified mutablebiginteger .", "partition": "test"}
{"idx": "2600", "code": "protected void drawCenterText(Canvas c){\n  CharSequence centerText=mChart.getCenterText();\n  if (mChart.isDrawCenterTextEnabled() && centerText != null) {\n    MPPointF center=mChart.getCenterCircleBox();\n    MPPointF offset=mChart.getCenterTextOffset();\n    float x=center.x + offset.x;\n    float y=center.y + offset.y;\n    float innerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();\n    RectF holeRect=mRectBuffer[0];\n    holeRect.left=x - innerRadius;\n    holeRect.top=y - innerRadius;\n    holeRect.right=x + innerRadius;\n    holeRect.bottom=y + innerRadius;\n    RectF boundingRect=mRectBuffer[1];\n    boundingRect.set(holeRect);\n    float radiusPercent=mChart.getCenterTextRadiusPercent() / 100f;\n    if (radiusPercent > 0.0) {\n      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);\n    }\n    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {\n      mCenterTextLastBounds.set(boundingRect);\n      mCenterTextLastValue=centerText;\n      float width=mCenterTextLastBounds.width();\n      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);\n    }\n    float layoutHeight=mCenterTextLayout.getHeight();\n    c.save();\n    if (Build.VERSION.SDK_INT >= 18) {\n      Path path=mDrawCenterTextPathBuffer;\n      path.reset();\n      path.addOval(holeRect,Path.Direction.CW);\n      c.clipPath(path);\n    }\n    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);\n    mCenterTextLayout.draw(c);\n    c.restore();\n    MPPointF.recycleInstance(center);\n    MPPointF.recycleInstance(offset);\n  }\n}\n", "docstring": "draws the unit text in the center of the pie chart makes most sense when center - hole is enabled", "partition": "test"}
{"idx": "2513", "code": "public final void addValidationError(String error){\n  validationErrors.add(error);\n}\n", "docstring": "add a new validation error to the accumulating validation errors", "partition": "test"}
{"idx": "754", "code": "private static void resolveNewExpression(NewExpression objSubjectExpression,HashSet<String> objTypesSet){\n  ClassReference objClassRef=objSubjectExpression.getClassReference();\n  if (null == objClassRef || null == objClassRef.getFQN()) {\n    objTypesSet.add(Types.strResolvingAbortedOnPsiLevel);\n    return;\n  }\n  objTypesSet.add(objClassRef.getFQN());\n}\n", "docstring": "will resolve type of new expression", "partition": "test"}
{"idx": "1819", "code": "private void heapifyUp(int twopos,Comparable<Object> cur){\n  while (twopos > 0) {\n    final int parent=(twopos - 1) >>> 1;\n    Comparable<Object> par=twoheap[parent];\n    if (cur.compareTo(par) <= 0) {\n      break;\n    }\n    twoheap[twopos]=par;\n    twopos=parent;\n  }\n  twoheap[twopos]=cur;\n}\n", "docstring": "heapify - up method for 2 - ary heap .", "partition": "test"}
{"idx": "510", "code": "public static String readCharacterSizedString(InputStream stream) throws IOException {\n  StringBuilder result=new StringBuilder();\n  int strLen=readUINT16(stream);\n  int character=stream.read();\n  character|=stream.read() << 8;\n  do {\n    if (character != 0) {\n      result.append((char)character);\n      character=stream.read();\n      character|=stream.read() << 8;\n    }\n  }\n while (character != 0 || (result.length() + 1) > strLen);\n  if (strLen != (result.length() + 1)) {\n    throw new IllegalStateException(\"Invalid Data for current interpretation\");\n  }\n  return result.toString();\n}\n", "docstring": "this method reads a utf - 16 string , which length is given on the number of characters it consists of . < br > the stream must be at the number of characters . this number contains the terminating zero character ( uint16 ) .", "partition": "test"}
{"idx": "2449", "code": "public Storage(){\n  this(new File(getTemporaryStorageDirectoryString()));\n}\n", "docstring": "creates new instance of storage for storing temporary data . the storage directory is initialized by gettemporarystoragedirectory ( ) value .", "partition": "test"}
{"idx": "3372", "code": "public static int countMatches(String string,char c){\n  int n=0;\n  for (  char tc : string.toCharArray()) {\n    if (c == tc)     n++;\n  }\n  return n;\n}\n", "docstring": "counts the amount of times a certain character is part of a string", "partition": "test"}
{"idx": "2143", "code": "private boolean checkMatchIp(Map<String,Object> rows){\n  boolean matchEther=false;\n  String val=(String)rows.get(StaticFlowEntryPusher.COLUMN_DL_TYPE);\n  if (val != null) {\n    int type=0;\n    if (val.startsWith(\"0x\")) {\n      type=Integer.parseInt(val.substring(2),16);\n    }\n else {\n      try {\n        type=Integer.parseInt(val);\n      }\n catch (      NumberFormatException e) {\n      }\n    }\n    if (type == 2048)     matchEther=true;\n  }\n  if ((rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_DST) || rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_SRC) || rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_PROTO)|| rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_TOS)) && (matchEther == false))   return false;\n  return true;\n}\n", "docstring": "checks to see if the user matches ip information without checking for the correct ether - type ( 2048 ) .", "partition": "test"}
{"idx": "1083", "code": "@HLEFunction(nid=0x7ED29E40,version=150) public int sceRtcSetTick(TPointer timeAddr,TPointer64 ticksAddr){\n  long ticks=ticksAddr.getValue() - rtcMagicOffset;\n  ScePspDateTime time=ScePspDateTime.fromMicros(ticks);\n  time.write(timeAddr);\n  return 0;\n}\n", "docstring": "set a psptime struct based on ticks .", "partition": "test"}
{"idx": "1608", "code": "public DefaultHeatMapDataset(int xSamples,int ySamples,double minX,double maxX,double minY,double maxY){\n  if (xSamples < 1) {\n    throw new IllegalArgumentException(\"Requires \\'xSamples\\' > 0\");\n  }\n  if (ySamples < 1) {\n    throw new IllegalArgumentException(\"Requires \\'ySamples\\' > 0\");\n  }\n  if (Double.isInfinite(minX) || Double.isNaN(minX)) {\n    throw new IllegalArgumentException(\"\\'minX\\' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(maxX) || Double.isNaN(maxX)) {\n    throw new IllegalArgumentException(\"\\'maxX\\' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(minY) || Double.isNaN(minY)) {\n    throw new IllegalArgumentException(\"\\'minY\\' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(maxY) || Double.isNaN(maxY)) {\n    throw new IllegalArgumentException(\"\\'maxY\\' cannot be INF or NaN.\");\n  }\n  this.xSamples=xSamples;\n  this.ySamples=ySamples;\n  this.minX=minX;\n  this.maxX=maxX;\n  this.minY=minY;\n  this.maxY=maxY;\n  this.zValues=new double[xSamples][];\n  for (int x=0; x < xSamples; x++) {\n    this.zValues[x]=new double[ySamples];\n  }\n}\n", "docstring": "creates a new dataset where all the z - values are initially 0 . this is a fixed size array of z - values .", "partition": "test"}
{"idx": "1134", "code": "private void changeOpenAMDebugFolder(String newOpenAMDebugFolder){\n  SystemPropertiesManager.initializeProperties(DebugConstants.CONFIG_DEBUG_DIRECTORY,newOpenAMDebugFolder);\n}\n", "docstring": "change the debug logs folder", "partition": "test"}
{"idx": "3659", "code": "public String encode(){\n  StringBuffer sb=new StringBuffer();\n  encode(sb);\n  return sb.toString();\n}\n", "docstring": "returns the encoded string representing the object type signature .", "partition": "test"}
{"idx": "1794", "code": "public void actionPerformed(ActionEvent ae){\n  String command=ae.getActionCommand();\n  if (command == DisplayPaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" displaying palette\");\n    }\n    showPalette();\n  }\n else   if (command == HidePaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" hiding palette\");\n    }\n    hidePalette();\n  }\n else   if (command == DisplayPropertiesCmd) {\n    Inspector inspector=new Inspector();\n    inspector.inspectPropertyConsumer(this);\n  }\n}\n", "docstring": "the default actionperformed method for layer . make sure you call super . actionperformed if you care about receiving palette show / hide commands . this method is also set up to receive the displaypropertiescmd , and will bring up the inspector for the layer .", "partition": "test"}
{"idx": "4133", "code": "private static byte[] encode(double latitude,double longitude){\n  byte[] bytes=new byte[2 * Integer.BYTES];\n  NumericUtils.intToSortableBytes(encodeLatitude(latitude),bytes,0);\n  NumericUtils.intToSortableBytes(encodeLongitude(longitude),bytes,Integer.BYTES);\n  return bytes;\n}\n", "docstring": "sugar encodes a single point as a byte array", "partition": "test"}
{"idx": "177", "code": "protected final boolean readAvailableBlocking() throws IOException {\n  char[] buffer=myBuffer;\n  StringBuilder token=myTextBuffer;\n  token.setLength(0);\n  boolean read=false;\n  int n;\n  while ((n=myReader.read(buffer)) > 0) {\n    if (myScheduledSubmitter != null)     myScheduledSubmitter.cancel(true);\n    read=true;\nsynchronized (myTextBuffer) {\n      processLine(buffer,token,n);\n    }\n    myScheduledSubmitter=myExecutorService.submit(myTokenSubmitter);\n  }\n  submitToken();\n  return read;\n}\n", "docstring": "reads data with blocking . should be used in case when ready method always returns false for your input stream . should be used if we want to to make our reader exit when end of stream reached . could be used if we prefer io - blocking over cpu sleeping .", "partition": "test"}
{"idx": "4171", "code": "protected ReplacedElement newIrreplaceableImageElement(int cssWidth,int cssHeight){\n  BufferedImage missingImage;\n  ReplacedElement mre;\n  try {\n    missingImage=ImageUtil.createCompatibleBufferedImage(cssWidth,cssHeight,BufferedImage.TYPE_INT_RGB);\n    Graphics2D g=missingImage.createGraphics();\n    g.setColor(Color.BLACK);\n    g.setBackground(Color.WHITE);\n    g.setFont(new Font(\"Serif\",Font.PLAIN,12));\n    g.drawString(\"Missing\",0,12);\n    g.dispose();\n    mre=new ImageReplacedElement(missingImage,cssWidth,cssHeight);\n  }\n catch (  Exception e) {\n    mre=new EmptyReplacedElement(cssWidth < 0 ? 0 : cssWidth,cssHeight < 0 ? 0 : cssHeight);\n  }\n  return mre;\n}\n", "docstring": "returns a replacedelement for some element in the stream which should be replaceable , but is not . this might be the case for an element like img , where the source isn \"'\" t provided .", "partition": "test"}
{"idx": "638", "code": "public void putAll(Map<? extends K,? extends V> m){\n  tryPresize(m.size());\n  for (  Map.Entry<? extends K,? extends V> e : m.entrySet())   putVal(e.getKey(),e.getValue(),false);\n}\n", "docstring": "copies all of the mappings from the specified map to this one . these mappings replace any mappings that this map had for any of the keys currently in the specified map .", "partition": "test"}
{"idx": "2040", "code": "final public void println(String s){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    if (s == null)     out.write(_nullChars,0,_nullChars.length);\n else     out.write(s,0,s.length());\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "writes a string followed by a newline .", "partition": "test"}
{"idx": "228", "code": "protected boolean isCorrectMethod(Method method,Object[] args){\n  return (proxySignature.equals(method.getName()) && args.length == 1);\n}\n", "docstring": "compare the method that was called to the intended method when the osxadapter instance was created ( e . g . handleabout , handlequit , handleopenfile , etc . ) .", "partition": "test"}
{"idx": "3331", "code": "public TestTree sort(){\n  Collections.sort(suites);\n  suites.forEach(null);\n  return this;\n}\n", "docstring": "sorts the encapsulated test suites by their name in alphabetic order , then returns with the current ( sorted ) instance .", "partition": "test"}
{"idx": "2617", "code": "protected static int[] concat(@Nullable int[] arr,int... obj){\n  int[] newArr;\n  if (arr == null || arr.length == 0)   newArr=obj;\n else {\n    newArr=Arrays.copyOf(arr,arr.length + obj.length);\n    System.arraycopy(obj,0,newArr,arr.length,obj.length);\n  }\n  return newArr;\n}\n", "docstring": "concatenates elements to an int array .", "partition": "test"}
{"idx": "2107", "code": "public boolean startsWith(CharSeq prefix){\n  return str.startsWith(prefix.str);\n}\n", "docstring": "tests whether this charseq starts with the specified prefix", "partition": "test"}
{"idx": "4128", "code": "private Integer countFragmentFilteredPages(List<String> templateFragments,boolean whitelist) throws WikiApiException {\n  try {\n    int count=0;\n    PreparedStatement statement=null;\n    ResultSet result=null;\n    try {\n      StringBuffer sqlString=new StringBuffer();\n      StringBuffer subconditions=new StringBuffer();\n      sqlString.append(\"SELECT distinct(count(*)) FROM \" + GeneratorConstants.TABLE_TPLID_TPLNAME + \" as tpl, \"+ GeneratorConstants.TABLE_TPLID_PAGEID+ \" AS p WHERE tpl.templateId = p.templateId \"+ (whitelist ? \"AND\" : \"AND NOT\")+ \" (\");\n      for (      @SuppressWarnings(\"unused\") String fragment : templateFragments) {\n        if (subconditions.length() != 0) {\n          subconditions.append(\"OR \");\n        }\n        subconditions.append(\"tpl.templateName LIKE ?\");\n      }\n      sqlString.append(subconditions);\n      sqlString.append(\")\");\n      statement=connection.prepareStatement(sqlString.toString());\n      int curIdx=1;\n      for (      String fragment : templateFragments) {\n        fragment=fragment.toLowerCase();\n        fragment=fragment.trim();\n        fragment=fragment.replaceAll(\" \",\"_\");\n        statement.setString(curIdx++,fragment + \"%\");\n      }\n      result=execute(statement);\n      if (result == null) {\n        return 0;\n      }\n      if (result.next()) {\n        count=result.getInt(1);\n      }\n    }\n  finally {\n      if (statement != null) {\n        statement.close();\n      }\n      if (result != null) {\n        result.close();\n      }\n    }\n    return count;\n  }\n catch (  Exception e) {\n    throw new WikiApiException(e);\n  }\n}\n", "docstring": "returns the number of all pages that contain a template the name of which starts with any of the the given strings .", "partition": "test"}
{"idx": "1214", "code": "public static void threadSleep(long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  InterruptedException ex) {\n    Log.e(\"Exception\",StringUtils.exceptionStackTraceToString(ex));\n  }\n}\n", "docstring": "makes the thread sleep for some time", "partition": "test"}
{"idx": "1719", "code": "@Override public void keyPressed(KeyEvent e){\nsynchronized (keyLock) {\n    keysDown.add(e.getKeyCode());\n  }\n}\n", "docstring": "this method cannot be called directly .", "partition": "test"}
{"idx": "3785", "code": "public void rollback(Throwable t){\n  log.debug(\"  ROLLBACK: deleting \" + tempFile + \" due to \"+ t);\n  try {\n    fileContentStore.delete(tempFile,node);\n  }\n catch (  Exception e) {\n    t.addSuppressed(e);\n  }\n}\n", "docstring": "rollback the download ( delete the temporary file )", "partition": "test"}
{"idx": "2104", "code": "public static boolean isZoningRequired(DbClient dbClient,VirtualArray nh){\n  if (nh.getAutoSanZoning() == false) {\n    _log.info(\"SAN Zoning is not enabled for Neighborhood: \" + nh.getLabel());\n    return false;\n  }\n  return NetworkUtil.areNetworkSystemDiscovered(dbClient);\n}\n", "docstring": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "partition": "test"}
{"idx": "761", "code": "public static Date parseText(String dateStr){\n  try {\n    return mSimpleTextFormat.parse(dateStr);\n  }\n catch (  ParseException e) {\n    e.printStackTrace();\n    throw new RuntimeException(\"date formatDateTime error\");\n  }\n}\n", "docstring": "parse string to datetime", "partition": "test"}
{"idx": "1554", "code": "int maxLength(){\n  FontMetrics fm=getFontMetrics(getFont());\n  int m=0;\n  int end=items.size();\n  for (int i=0; i < end; i++) {\n    int l=fm.stringWidth(((String)items.elementAt(i)));\n    m=Math.max(m,l);\n  }\n  return m;\n}\n", "docstring": "return the length of the largest item in the list", "partition": "test"}
{"idx": "3589", "code": "public static boolean compareResults(SolrClient controlClient,SolrClient cloudClient) throws SolrServerException, IOException {\n  return compareResults(controlClient,cloudClient,null,null);\n}\n", "docstring": "compares the results of the control and cloud clients .", "partition": "test"}
{"idx": "2314", "code": "@Override public boolean onPreferenceClick(Preference preference){\n  if (preference == mPlayExample) {\n    getSampleText();\n    return true;\n  }\n  return false;\n}\n", "docstring": "called when mplayexample is clicked", "partition": "test"}
{"idx": "893", "code": "private synchronized void persistProfileAndNotifyChange(AuthnProvider modifiedProvider,boolean newObject){\n  modifiedProvider.setLastModified(System.currentTimeMillis());\n  if (newObject) {\n    _dbClient.createObject(modifiedProvider);\n  }\n else {\n    _dbClient.persistObject(modifiedProvider);\n  }\n  notifyChange();\n}\n", "docstring": "update the timestamp and notify", "partition": "test"}
{"idx": "1013", "code": "public boolean unsetOrdering(Object first,Object second){\n  DigraphNode firstPONode=(DigraphNode)poNodes.get(first);\n  DigraphNode secondPONode=(DigraphNode)poNodes.get(second);\n  return firstPONode.removeEdge(secondPONode) || secondPONode.removeEdge(firstPONode);\n}\n", "docstring": "removes any ordering between two nodes .", "partition": "test"}
{"idx": "326", "code": "int convertMouse(MouseEvent event){\n  int result;\n  if (panelFont == null)   return (NO_MOUSE);\n  int colOff=event.getX() - GRID_WIDTH - PANEL_MARGIN;\n  int colNum=colOff / horizStep;\n  int colRem=colOff % horizStep;\n  if ((colNum >= panelColumns) || (colRem < TEXT_MARGIN) || (colRem > (horizStep - GRID_WIDTH - TEXT_MARGIN))) {\n    return (NO_MOUSE);\n  }\n  int rowOff=event.getY() - GRID_WIDTH - PANEL_MARGIN;\n  int rowNum=rowOff / vertiStep;\n  int rowRem=rowOff % vertiStep;\n  if ((rowRem < TEXT_MARGIN) || (rowRem > (vertiStep - GRID_WIDTH - TEXT_MARGIN))) {\n    return (NO_MOUSE);\n  }\n  result=cornerIndex + (rowNum * panelColumns) + colNum;\n  if (result >= cellCount)   return (NO_MOUSE);\n  return (result);\n}\n", "docstring": "convert mouse . convert mouse coordinates to a cell index . return < no_mouse > if the mouse is not well - centered on a defined character .", "partition": "test"}
{"idx": "1140", "code": "public double nextGaussian(){\n  if (mHaveNextNextGaussian) {\n    mHaveNextNextGaussian=false;\n    return mNextNextGaussian;\n  }\n else {\n    double v1, v2, s;\n    do {\n      v1=2 * nextDouble() - 1;\n      v2=2 * nextDouble() - 1;\n      s=v1 * v1 + v2 * v2;\n    }\n while (s >= 1 || s == 0);\n    final double multiplier=StrictMath.sqrt(-2 * StrictMath.log(s) / s);\n    mNextNextGaussian=v2 * multiplier;\n    mHaveNextNextGaussian=true;\n    return v1 * multiplier;\n  }\n}\n", "docstring": "return the next gaussian see knuth , acp , section 3 . 4 . 1 algorithm c .", "partition": "test"}
{"idx": "79", "code": "public synchronized OMGraphicList prepare(){\n  Projection projection=getProjection();\n  boolean DEBUG_FINE=logger.isLoggable(Level.FINE);\n  if (projection == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": prepare called with null projection\");\n    }\n    return new OMGraphicList();\n  }\n  if (spatialIndex == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": spatialIndex is null!\");\n    }\n    OMGraphicList list=getList();\n    if (list != null) {\n      list.generate(projection,true);\n      return list;\n    }\n else {\n      return new OMGraphicList();\n    }\n  }\n  Point2D ul=projection.getUpperLeft();\n  Point2D lr=projection.getLowerRight();\n  double ulLat=ul.getY();\n  double ulLon=ul.getX();\n  double lrLat=lr.getY();\n  double lrLon=lr.getX();\n  OMGraphicList list=new OMGraphicList();\n  if (ProjMath.isCrossingDateline(ulLon,lrLon,projection.getScale())) {\n    if (DEBUG_FINE) {\n      logger.fine(\"ShapeLayer.computeGraphics(): Dateline is on screen\");\n    }\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(ulLon,ymin,180.0d,ymax,list,drawingAttributes,projection,coordTransform);\n      list=spatialIndex.getOMGraphics(-180.0d,ymin,lrLon,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n else {\n    double xmin=Math.min(ulLon,lrLon);\n    double xmax=Math.max(ulLon,lrLon);\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(xmin,ymin,xmax,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    java.io.IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "create the omgraphics using the shape file and spatialindex .", "partition": "test"}
{"idx": "2717", "code": "private static StsdData parseStsd(ParsableByteArray stsd,int trackId,long durationUs,int rotationDegrees,String language,boolean isQuickTime){\n  stsd.setPosition(Atom.FULL_HEADER_SIZE);\n  int numberOfEntries=stsd.readInt();\n  StsdData out=new StsdData(numberOfEntries);\n  for (int i=0; i < numberOfEntries; i++) {\n    int childStartPosition=stsd.getPosition();\n    int childAtomSize=stsd.readInt();\n    Assertions.checkArgument(childAtomSize > 0,\"childAtomSize should be positive\");\n    int childAtomType=stsd.readInt();\n    if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3 || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1 || childAtomType == Atom.TYPE_s263 || childAtomType == Atom.TYPE_vp08 || childAtomType == Atom.TYPE_vp09) {\n      parseVideoSampleEntry(stsd,childAtomType,childStartPosition,childAtomSize,trackId,durationUs,rotationDegrees,out,i);\n    }\n else     if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3 || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt) {\n      parseAudioSampleEntry(stsd,childAtomType,childStartPosition,childAtomSize,trackId,durationUs,language,isQuickTime,out,i);\n    }\n else     if (childAtomType == Atom.TYPE_TTML) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_TTML,MediaFormat.NO_VALUE,durationUs,language);\n    }\n else     if (childAtomType == Atom.TYPE_tx3g) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_TX3G,MediaFormat.NO_VALUE,durationUs,language);\n    }\n else     if (childAtomType == Atom.TYPE_wvtt) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_MP4VTT,MediaFormat.NO_VALUE,durationUs,language);\n    }\n else     if (childAtomType == Atom.TYPE_stpp) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_TTML,MediaFormat.NO_VALUE,durationUs,language,0);\n    }\n    stsd.setPosition(childStartPosition + childAtomSize);\n  }\n  return out;\n}\n", "docstring": "parses a stsd atom ( defined in 14496 - 12 ) .", "partition": "test"}
{"idx": "2530", "code": "public void resetTeleMissileAttacks(){\n  pendingTeleMissileAttacks.removeAllElements();\n}\n", "docstring": "resets the pending rams list .", "partition": "test"}
{"idx": "3857", "code": "void addNewTable(String name,int tdefPageNumber,Short type,String linkedDbName,String linkedTableName) throws IOException {\n  addTable(name,Integer.valueOf(tdefPageNumber),type,linkedDbName,linkedTableName);\n  addToSystemCatalog(name,tdefPageNumber,type,linkedDbName,linkedTableName,_tableParentId);\n  addToAccessControlEntries(tdefPageNumber,_tableParentId,_newTableSIDs);\n}\n", "docstring": "adds a newly created table to the relevant internal database structures .", "partition": "test"}
{"idx": "2627", "code": "public void characters(char ch[],int start,int length) throws SAXException {\n  m_valueBuffer.append(ch,start,length);\n}\n", "docstring": "characters read from xml are assigned to a variable , based on the current m_context . no checks are being done , it is assumed that the context is correct .", "partition": "test"}
{"idx": "1290", "code": "public int availableInProcess(){\n  return Math.max(0,maxInProcess - pending.size());\n}\n", "docstring": "a connection can only have so many things in process happening on it at once , where \" in process \" refers to the maximum number of in - process requests less the number of pending responses .", "partition": "test"}
{"idx": "1158", "code": "private void validateWill(String dest,Object payload){\n  if ((dest == null) || (payload == null)) {\n    throw new IllegalArgumentException();\n  }\n  MqttTopic.validate(dest,false);\n}\n", "docstring": "validates the will fields .", "partition": "test"}
{"idx": "608", "code": "private void walkParseTree(List<SwiftBaseListener> listeners,TopLevelContext tree){\n  ParseTreeWalker walker=new ParseTreeWalker();\n  listeners.forEach(null);\n}\n", "docstring": "walks the provided parse tree using the list of listeners .", "partition": "test"}
{"idx": "3377", "code": "public void execute(){\n  mPlayer.setLoopMode(mDoLoop);\n  mThread=new Thread(this,\"Movie Player\");\n  mThread.start();\n}\n", "docstring": "creates a new thread , and starts execution of the player .", "partition": "test"}
{"idx": "36", "code": "protected void notifyStateChange(int oldState,int newState){\n  mState=newState;\n  if (oldState != newState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(oldState),Integer.valueOf(newState));\n  }\n}\n", "docstring": "change the stored state value and do notification , but don \"'\" t change anything in the hardware", "partition": "test"}
{"idx": "559", "code": "public Channel chan(final String topic,final JsonNode payload){\n  LOG.log(Level.FINE,\"chan: {0}, {1}\",new Object[]{topic,payload});\n  final Channel channel=new Channel(topic,payload,Socket.this);\nsynchronized (channels) {\n    channels.add(channel);\n  }\n  return channel;\n}\n", "docstring": "retrieve a channel instance for the specified topic", "partition": "test"}
{"idx": "3864", "code": "public String globalInfo(){\n  return \"A filter that removes a range of\" + \" attributes from the dataset. Will \" + \"re-order the remaining attributes \"+ \"if invert matching sense is turned \"+ \"on and the attribute column indices \"+ \"are not specified in ascending order.\";\n}\n", "docstring": "returns a string describing this filter", "partition": "test"}
{"idx": "3098", "code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) public static LineByLineFileInputOperator restoreCheckPoint(LineByLineFileInputOperator checkPointOper,ByteArrayOutputStream bos) throws Exception {\n  Kryo kryo=new Kryo();\n  Input lInput=new Input(bos.toByteArray());\n  LineByLineFileInputOperator oper=kryo.readObject(lInput,checkPointOper.getClass());\n  lInput.close();\n  return oper;\n}\n", "docstring": "restores the checkpointed operator .", "partition": "test"}
{"idx": "1820", "code": "public void insert(String key,char val){\n  int len=key.length() + 1;\n  if (freenode + len > eq.length) {\n    redimNodeArrays(eq.length + BLOCK_SIZE);\n  }\n  char strkey[]=new char[len--];\n  key.getChars(0,len,strkey,0);\n  strkey[len]=0;\n  root=insert(root,strkey,0,val);\n}\n", "docstring": "branches are initially compressed , needing one node per key plus the size of the string key . they are decompressed as needed when another key with same prefix is inserted . this saves a lot of space , specially for long keys .", "partition": "test"}
{"idx": "3847", "code": "public void handleTblRequestHandlerListButtonAddRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    SCSAML2SOAPBindingRequestHandlerListAddViewBean vb=(SCSAML2SOAPBindingRequestHandlerListAddViewBean)getViewBean(SCSAML2SOAPBindingRequestHandlerListAddViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n}\n", "docstring": "handles add request handler request .", "partition": "test"}
{"idx": "2266", "code": "private static boolean useCompactFontFormat(Map<String,Object> args,int compatibilityVersion){\n  String value=(String)args.get(EMBEDASCFF);\n  boolean useCFF=true;\n  if (compatibilityVersion < MxmlConfiguration.VERSION_4_0)   useCFF=false;\n  if (value != null) {\n    useCFF=Boolean.parseBoolean(value.trim());\n  }\n  return useCFF;\n}\n", "docstring": "the cff flag determines whether font information should be embedded in the compact font format using swf tag definefont4 .", "partition": "test"}
{"idx": "461", "code": "@Override public void parse(InputStream in,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (in == null) {\n    throw new IllegalArgumentException(\"Input stream cannot be \\'null\\'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be \\'null\\'\");\n  }\n  InputSource inputSource=new InputSource(new BOMInputStream(in,false));\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}\n", "docstring": "parses the data from the supplied inputstream , using the supplied baseuri to resolve any relative uri references .", "partition": "test"}
{"idx": "1711", "code": "public CreateIndexRequest source(XContentBuilder source){\n  return source(source.bytes());\n}\n", "docstring": "sets the settings and mappings as a single source .", "partition": "test"}
{"idx": "3113", "code": "public void testIterator() throws InterruptedException {\n  LinkedBlockingQueue q=populatedQueue(SIZE);\n  Iterator it=q.iterator();\n  while (it.hasNext()) {\n    assertEquals(it.next(),q.take());\n  }\n}\n", "docstring": "iterator iterates through all elements", "partition": "test"}
{"idx": "1062", "code": "private void addPropertyType(URI p,Resource t){\n  OwlProperty prop=getProperty(p);\n  if (t.equals(OWL.TRANSITIVEPROPERTY)) {\n    prop.setTransitive();\n  }\n else   if (t.equals(OWL.SYMMETRICPROPERTY)) {\n    prop.setSymmetric();\n  }\n else   if (t.equals(OWL2.ASYMMETRICPROPERTY)) {\n    prop.setAsymmetric();\n  }\n else   if (t.equals(OWL.FUNCTIONALPROPERTY)) {\n    prop.setFunctional();\n  }\n else   if (t.equals(OWL.INVERSEFUNCTIONALPROPERTY)) {\n    prop.setInverseFunctional();\n  }\n else   if (t.equals(OWL2.IRREFLEXIVEPROPERTY)) {\n    prop.setIrreflexive();\n  }\n}\n", "docstring": "add a particular characteristic to a property .", "partition": "test"}
{"idx": "1415", "code": "static float rotateY(float pX,float pY,float cX,float cY,float angleInDegrees){\n  double angle=Math.toRadians(angleInDegrees);\n  return (float)(Math.sin(angle) * (pX - cX) + Math.cos(angle) * (pY - cY) + cY);\n}\n", "docstring": "rotate point p around center point c .", "partition": "test"}
{"idx": "1727", "code": "void crossOver(BayesNetRepresentation other){\n  boolean[] bits=new boolean[m_bits.length];\n  for (int i=0; i < m_bits.length; i++) {\n    bits[i]=m_bits[i];\n  }\n  int iCrossOverPoint=m_bits.length;\n  do {\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=bits[i];\n    }\n    iCrossOverPoint=m_random.nextInt(m_bits.length);\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=other.m_bits[i];\n    }\n  }\n while (hasCycles());\n  calcGlobalScore();\n}\n", "docstring": "apply cross - over operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .", "partition": "test"}
{"idx": "2620", "code": "public void shutdown(){\n  scheduledExecutorService.shutdownNow();\n}\n", "docstring": "shut down the health checker .", "partition": "test"}
{"idx": "3625", "code": "protected AbstractRegexNPAnnotator(String pattern,boolean caseSensitive,double confidence){\n  this(Pattern.compile(pattern,caseSensitive ? 0 : Pattern.CASE_INSENSITIVE),0,confidence);\n}\n", "docstring": "new instance , based on the supplied pattern . uses the whole matched regex as the entity text .", "partition": "test"}
{"idx": "3732", "code": "public boolean isUnparsedEntity(String entityName){\n  Entity entity=(Entity)fEntities.get(entityName);\n  if (entity == null) {\n    return false;\n  }\n  return entity.isUnparsed();\n}\n", "docstring": "checks whether an entity given by name is unparsed .", "partition": "test"}
{"idx": "3364", "code": "public ClientPropertiesBuilder withProxyHostName(String proxyHostName){\n  properties.setProperty(CLIENT_SERVICE_PROXY_HOST_NAME,proxyHostName);\n  return this;\n}\n", "docstring": "if a proxy is used to access the odata web service this specifies it \"'\" s host name / ip address .", "partition": "test"}
{"idx": "3772", "code": "private static void checkKey(String key) throws MalformedObjectNameException {\n  if (key == null)   throw new NullPointerException(\"Invalid key (null)\");\n  final int len=key.length();\n  if (len == 0)   throw new MalformedObjectNameException(\"Invalid key (empty)\");\n  final char[] k=key.toCharArray();\n  final int endKey=parseKey(k,0);\n  if (endKey < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + k[endKey] + \"\\'\");\n}\n", "docstring": "check if the supplied key is a valid key .", "partition": "test"}
{"idx": "3792", "code": "@Override public void onEvent(ProjectEvent event){\n  if (event.getType() == ProjectEvent.EventType.UPDATED || event.getType() == ProjectEvent.EventType.CREATED) {\n    update(event);\n  }\n}\n", "docstring": "there is a change on the project that we \"'\" re monitoring , whatever the type of event is , we need to updated the runner .", "partition": "test"}
{"idx": "3507", "code": "public static final void showGUIMessage(final String user_message,final BufferedImage image,final String title){\n  if (image == null) {\n    return;\n  }\n  final ImagePanel display=new ImagePanel(image);\n  display.setLayout(new BorderLayout());\n  if (user_message != null) {\n    display.add(new JLabel(user_message),BorderLayout.SOUTH);\n  }\n  final int width=image.getWidth();\n  final int height=image.getHeight();\n  display.setSize(new Dimension(width + 10,height + 10));\n  JOptionPane.showConfirmDialog(contentPane,display,title,JOptionPane.DEFAULT_OPTION,JOptionPane.PLAIN_MESSAGE);\n}\n", "docstring": "display message if in gui mode", "partition": "test"}
{"idx": "2575", "code": "static public void assertStatementIndicesConsistent(final AbstractTripleStore db,final int maxerrors){\n  if (log.isInfoEnabled())   log.info(\"Verifying statement indices\");\n  final AtomicInteger nerrs=new AtomicInteger(0);\n  final int from, to;\n  if (db.getSPOKeyArity() == 3) {\n    from=SPOKeyOrder.FIRST_TRIPLE_INDEX;\n    to=SPOKeyOrder.LAST_TRIPLE_INDEX;\n  }\n else {\n    from=SPOKeyOrder.FIRST_QUAD_INDEX;\n    to=SPOKeyOrder.LAST_QUAD_INDEX;\n  }\n  for (int i=from; i <= to; i++) {\n    for (int j=from; j <= to; j++) {\n      if (i <= j) {\n        continue;\n      }\n      assertSameStatements(db,SPOKeyOrder.valueOf(i),SPOKeyOrder.valueOf(j),nerrs,maxerrors);\n    }\n  }\n  assertEquals(0,nerrs.get());\n}\n", "docstring": "validates that the same statements are found in each of the statement indices .", "partition": "test"}
{"idx": "4086", "code": "protected static String shortenClassname(String nam,char c){\n  final int lastdot=nam.lastIndexOf(c);\n  if (lastdot >= 0) {\n    nam=nam.substring(lastdot + 1);\n  }\n  return nam;\n}\n", "docstring": "shorten the class name .", "partition": "test"}
{"idx": "3971", "code": "public ResourceListParser parse() throws ParserConfigurationException, SAXException, ParseFailureException {\n  try {\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(mInputSource,this);\n    return this;\n  }\n catch (  IOException e) {\n    throw new ParseFailureException(\"Failed to parse input source!\",e);\n  }\n}\n", "docstring": "parse the resource list", "partition": "test"}
{"idx": "445", "code": "public static double quantile(double p,double alpha,double beta){\n  if (Double.isNaN(alpha) || Double.isNaN(beta) || Double.isNaN(p)|| alpha < 0. || beta < 0.) {\n    return Double.NaN;\n  }\n  if (p < 0 || p > 1) {\n    return Double.NaN;\n  }\n  if (p == 0) {\n    return 0.0;\n  }\n  if (p == 1) {\n    return 1.0;\n  }\n  if (p > 0.5) {\n    return 1 - rawQuantile(1 - p,beta,alpha,logBeta(beta,alpha));\n  }\n else {\n    return rawQuantile(p,alpha,beta,logBeta(alpha,beta));\n  }\n}\n", "docstring": "compute quantile ( inverse cdf ) for beta distributions .", "partition": "test"}
{"idx": "606", "code": "protected void drawCylinder(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean isShadow){\n  int h4=h / 4;\n  int r=w - 1;\n  if (fillColor != null || fillPaint != null) {\n    Area area=new Area(new Rectangle(x,y + h4 / 2,r,h - h4));\n    area.add(new Area(new Rectangle(x,y + h4 / 2,r,h - h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y,r,h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y + h - h4,r,h4)));\n    if (isShadow) {\n      g.setColor(mxConstants.SHADOW_COLOR);\n      g.translate(mxConstants.SHADOW_OFFSETX,mxConstants.SHADOW_OFFSETY);\n      g.fill(area);\n      g.translate(-mxConstants.SHADOW_OFFSETX,-mxConstants.SHADOW_OFFSETY);\n    }\n    if (fillPaint != null) {\n      g.setPaint(fillPaint);\n    }\n else {\n      g.setColor(fillColor);\n    }\n    g.fill(area);\n  }\n  if (penColor != null) {\n    g.setColor(penColor);\n    int h2=h4 / 2;\n    g.drawOval(x,y,r,h4);\n    g.drawLine(x,y + h2,x,y + h - h2);\n    g.drawLine(x + w - 1,y + h2,x + w - 1,y + h - h2);\n    g.drawArc(x,y + h - h4,r,h4,0,-180);\n  }\n}\n", "docstring": "draws a cylinder for the given parameters .", "partition": "test"}
{"idx": "1692", "code": "@Override public void onDetachedFromRecyclerView(RecyclerView recyclerView){\n  super.onDetachedFromRecyclerView(recyclerView);\n  mAttachedRecyclerViewPool.remove(recyclerView);\n}\n", "docstring": "implementation of adapter . ondetachedfromrecyclerview ( recyclerview ) < p > called when this expandablerecycleradapter is detached from a recyclerview .", "partition": "test"}
{"idx": "2951", "code": "public E[] toArray(E[] a){\n  if (a.length != array.length()) {\n    throw new ElasticsearchGenerationException(\"AtomicArrays can only be copied to arrays of the same size\");\n  }\n  for (int i=0; i < array.length(); i++) {\n    a[i]=array.get(i);\n  }\n  return a;\n}\n", "docstring": "copies the content of the underlying atomic array to a normal one .", "partition": "test"}
{"idx": "118", "code": "private static MappingObject ObjectAt(PCalLocation loc,MappingObject[][] map){\n  return map[loc.getLine()][loc.getColumn()];\n}\n", "docstring": "returns the mappingobject at the location in map indicated by loc .", "partition": "test"}
{"idx": "2595", "code": "protected CCAnimation(String name,float delay,ArrayList<CCSpriteFrame> frames){\n  delay_=delay;\n  name_=name;\n  frames_=new ArrayList<CCSpriteFrame>();\n  if (frames != null)   frames_.addAll(frames);\n}\n", "docstring": "initializes a ccanimation with a name , delay and an array of ccspriteframes .", "partition": "test"}
{"idx": "1696", "code": "@Override public int hashCode(){\n  if (location != null)   return location.hashCode();\n else   return 0;\n}\n", "docstring": "returns the hash code value for this object .", "partition": "test"}
{"idx": "4052", "code": "protected void notifyTimestampsToGateways(EntryEventImpl event){\n  VersionTagHolder updateTimeStampEvent=new VersionTagHolder(event.getVersionTag());\n  updateTimeStampEvent.setOperation(Operation.UPDATE_VERSION_STAMP);\n  updateTimeStampEvent.setKeyInfo(event.getKeyInfo());\n  updateTimeStampEvent.setGenerateCallbacks(false);\n  updateTimeStampEvent.distributedMember=event.getDistributedMember();\n  updateTimeStampEvent.setNewEventId(getSystem());\n  if (event.getRegion() instanceof BucketRegion) {\n    BucketRegion br=(BucketRegion)event.getRegion();\n    PartitionedRegion pr=br.getPartitionedRegion();\n    updateTimeStampEvent.setRegion(pr);\n    if (pr.isParallelWanEnabled()) {\n      br.handleWANEvent(updateTimeStampEvent);\n    }\n    if (pr.isInitialized()) {\n      pr.notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,updateTimeStampEvent);\n    }\n  }\n else {\n    updateTimeStampEvent.setRegion(event.getRegion());\n    notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,updateTimeStampEvent);\n  }\n}\n", "docstring": "this notifies all wan sites about updated timestamp on local site .", "partition": "test"}
{"idx": "1793", "code": "private boolean passesSanityCheck(AccessibilityEvent event){\n  final CharSequence afterText=getEventText(event);\n  final CharSequence beforeText=event.getBeforeText();\n  if ((event.getAddedCount() == 0) && (event.getRemovedCount() == beforeText.length())) {\n    return true;\n  }\n  if (afterText == null || beforeText == null) {\n    return false;\n  }\n  final int diff=(event.getAddedCount() - event.getRemovedCount());\n  return ((beforeText.length() + diff) == afterText.length());\n}\n", "docstring": "checks whether the event \"'\" s reported properties match its actual properties , e . g . does the added count minus the removed count reflect the actual change in length between the current and previous text contents .", "partition": "test"}
{"idx": "3050", "code": "public static void delete(File fileOrFolder) throws IOException {\n  if (fileOrFolder != null)   delete(fileOrFolder.toPath());\n}\n", "docstring": "a method that will delete a file or folder . folders are removed recursively .", "partition": "test"}
{"idx": "732", "code": "public MetaDataColumnDescriptor(String columnName,int jdbcType,Object defaultValue){\n  _columnName=columnName.toUpperCase();\n  _jdbcType=jdbcType;\n  _defaultValue=defaultValue;\n}\n", "docstring": "creates a new descriptor instance .", "partition": "test"}
{"idx": "2674", "code": "public static boolean isCglibProxy(Object object){\n  return ClassUtils.isCglibProxyClass(object.getClass());\n}\n", "docstring": "check whether the given object is a cglib proxy .", "partition": "test"}
{"idx": "3234", "code": "ConverterSet add(Converter converter,Converter[] removed){\n  Converter[] converters=iConverters;\n  int length=converters.length;\n  for (int i=0; i < length; i++) {\n    Converter existing=converters[i];\n    if (converter.equals(existing)) {\n      if (removed != null) {\n        removed[0]=null;\n      }\n      return this;\n    }\n    if (converter.getSupportedType() == existing.getSupportedType()) {\n      Converter[] copy=new Converter[length];\n      for (int j=0; j < length; j++) {\n        if (j != i) {\n          copy[j]=converters[j];\n        }\n else {\n          copy[j]=converter;\n        }\n      }\n      if (removed != null) {\n        removed[0]=existing;\n      }\n      return new ConverterSet(copy);\n    }\n  }\n  Converter[] copy=new Converter[length + 1];\n  System.arraycopy(converters,0,copy,0,length);\n  copy[length]=converter;\n  if (removed != null) {\n    removed[0]=null;\n  }\n  return new ConverterSet(copy);\n}\n", "docstring": "returns a copy of this set , with the given converter added . if a matching converter is already in the set , the given converter replaces it . if the converter is exactly the same as one already in the set , the original set is returned .", "partition": "test"}
{"idx": "2127", "code": "private T[] ensureCapacity(int minCapacity){\n  if (tmp.length < minCapacity) {\n    int newSize=minCapacity;\n    newSize|=newSize >> 1;\n    newSize|=newSize >> 2;\n    newSize|=newSize >> 4;\n    newSize|=newSize >> 8;\n    newSize|=newSize >> 16;\n    newSize++;\n    if (newSize < 0)     newSize=minCapacity;\n else     newSize=Math.min(newSize,a.length >>> 1);\n    T[] newArray=(T[])new Object[newSize];\n    tmp=newArray;\n  }\n  return tmp;\n}\n", "docstring": "ensures that the external array tmp has at least the specified number of elements , increasing its size if necessary . the size increases exponentially to ensure amortized linear time complexity .", "partition": "test"}
{"idx": "3588", "code": "private File findFile(File directory,String name) throws FileNotFoundException {\n  File file=new File(directory,name);\n  if (file.exists()) {\n    return file;\n  }\n  for (  String child : directory.list()) {\n    if (child.equalsIgnoreCase(name)) {\n      return new File(directory,child);\n    }\n  }\n  throw new FileNotFoundException(\"Missing file: \" + file);\n}\n", "docstring": "finds the named file in the named directory . this tries extra hard to avoid case - insensitive - naming problems , where the requested file is available in a different casing .", "partition": "test"}
{"idx": "697", "code": "public void classLoaderDestroy(DynamicClassLoader loader){\n  Method destroy=getDestroyMethod(_resource.getClass());\n  if (destroy == null)   return;\n  try {\n    destroy.invoke(_resource);\n  }\n catch (  Throwable e) {\n    log.log(Level.WARNING,e.toString(),e);\n  }\n}\n", "docstring": "handles the case where a class loader is dropped .", "partition": "test"}
{"idx": "2870", "code": "private void runTimeoutTask(){\n  while (isActive()) {\n    reapTimeouts();\n    try {\n      Thread.sleep(_timeoutReapInterval);\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "docstring": "running process accepting connections .", "partition": "test"}
{"idx": "2319", "code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver obs){\n  return mGraphics.drawImage(img,xform,obs);\n}\n", "docstring": "draws an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics2d . the given transformation is applied to the image before the transform attribute in the graphics2d state is applied . the rendering attributes applied include the clip , transform , and composite attributes . note that the result is undefined , if the given transform is noninvertible .", "partition": "test"}
{"idx": "3471", "code": "public static AnnotationBinding[] addStandardAnnotations(AnnotationBinding[] recordedAnnotations,long annotationTagBits,LookupEnvironment env){\n  int count=0;\n  if ((annotationTagBits & TagBits.AnnotationTargetMASK) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationRetentionMASK) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationDeprecated) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationDocumented) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationInherited) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationOverride) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationSuppressWarnings) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationPolymorphicSignature) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationSafeVarargs) != 0)   count++;\n  if (count == 0)   return recordedAnnotations;\n  int index=recordedAnnotations.length;\n  AnnotationBinding[] result=new AnnotationBinding[index + count];\n  System.arraycopy(recordedAnnotations,0,result,0,index);\n  if ((annotationTagBits & TagBits.AnnotationTargetMASK) != 0)   result[index++]=buildTargetAnnotation(annotationTagBits,env);\n  if ((annotationTagBits & TagBits.AnnotationRetentionMASK) != 0)   result[index++]=buildRetentionAnnotation(annotationTagBits,env);\n  if ((annotationTagBits & TagBits.AnnotationDeprecated) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_DEPRECATED,env);\n  if ((annotationTagBits & TagBits.AnnotationDocumented) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_ANNOTATION_DOCUMENTED,env);\n  if ((annotationTagBits & TagBits.AnnotationInherited) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_ANNOTATION_INHERITED,env);\n  if ((annotationTagBits & TagBits.AnnotationOverride) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE,env);\n  if ((annotationTagBits & TagBits.AnnotationSuppressWarnings) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_SUPPRESSWARNINGS,env);\n  if ((annotationTagBits & TagBits.AnnotationPolymorphicSignature) != 0)   result[index++]=buildMarkerAnnotationForMemberType(TypeConstants.JAVA_LANG_INVOKE_METHODHANDLE_$_POLYMORPHICSIGNATURE,env);\n  if ((annotationTagBits & TagBits.AnnotationSafeVarargs) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_SAFEVARARGS,env);\n  return result;\n}\n", "docstring": "add the standard annotations encoded in the tag bits to the recorded annotations .", "partition": "test"}
{"idx": "2052", "code": "private BufferedImage toBufferedImage(final Image image){\n  if (image instanceof BufferedImage) {\n    return (BufferedImage)image;\n  }\n  if (image instanceof VolatileImage) {\n    VolatileImage volatileImage=(VolatileImage)image;\n    return volatileImage.getSnapshot();\n  }\n  GraphicsEnvironment graphicsEnvironment=GraphicsEnvironment.getLocalGraphicsEnvironment();\n  GraphicsDevice graphicsDevice=graphicsEnvironment.getDefaultScreenDevice();\n  GraphicsConfiguration graphicsConfiguration=graphicsDevice.getDefaultConfiguration();\n  BufferedImage bufferedImage=graphicsConfiguration.createCompatibleImage(image.getWidth(null),image.getHeight(null));\n  Graphics2D g=bufferedImage.createGraphics();\n  g.drawImage(image,0,0,null);\n  g.dispose();\n  return bufferedImage;\n}\n", "docstring": "convert the specified image to a bufferedimage , if necessary .", "partition": "test"}
{"idx": "3869", "code": "public List<URI> volumeURIs(List<URI> uris,boolean delete,boolean remediate,ValCk... checks){\n  List<URI> remediatedURIs=new ArrayList<URI>();\n  List<Volume> volumes=dbClient.queryObject(Volume.class,uris);\n  List<Volume> remediatedVolumes=volumes(volumes,delete,remediate,checks);\n  for (  Volume volume : remediatedVolumes) {\n    remediatedURIs.add(volume.getId());\n  }\n  return remediatedURIs;\n}\n", "docstring": "validates a list of volumes", "partition": "test"}
{"idx": "832", "code": "public static void init(String[] args){\n  try {\n    compiler.initCompiler(args);\n    if (VM.BuildForAdaptiveSystem && VM.BuildWithBaseBootImageCompiler) {\n      optCompiler.initCompiler(args);\n    }\n  }\n catch (  Throwable e) {\n    while (e != null) {\n      e.printStackTrace();\n      e=e.getCause();\n    }\n  }\n}\n", "docstring": "initialize boot image compiler .", "partition": "test"}
{"idx": "1209", "code": "public void store() throws SAMLException {\n  try {\n    keyProvider.store();\n  }\n catch (  KeyStoreException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  CertificateException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  IOException e) {\n    throw new SAMLException(e.getMessage());\n  }\n}\n", "docstring": "store the keystore changes", "partition": "test"}
{"idx": "1480", "code": "static public String normalizeToEncoding(String origString_,Charset encoding_){\n  String normString=origString_;\n  CharsetEncoder encoder=encoding_.newEncoder();\n  if (!encoder.canEncode(origString_)) {\n    final int length=origString_.length();\n    char[] normSeq=new char[(origString_.length())];\n    int charNum=0;\n    for (int offset=0; offset < length; ) {\n      Pair<Character,Integer> replacement=normalizeCodepoint(origString_,encoding_,offset);\n      Character replacedChar=replacement.getFirst();\n      int codepoint=replacement.getSecond();\n      if (null != replacedChar) {\n        normSeq[charNum]=replacedChar;\n        charNum++;\n      }\n      offset+=Character.charCount(codepoint);\n    }\n    normString=new String(normSeq);\n  }\n  return normString;\n}\n", "docstring": "tries to normalize string to specified encoding . the number of characters returned should be the same , and tokens should remain contiguous in the output ; non - recognized characters will be substituted for * something * .", "partition": "test"}
{"idx": "969", "code": "static boolean allowsPopup(FormObject formObject){\nswitch (formObject.getParameterConstant(PdfDictionary.Subtype)) {\ncase PdfDictionary.Text:\ncase PdfDictionary.Square:\ncase PdfDictionary.Highlight:\ncase PdfDictionary.Underline:\ncase PdfDictionary.StrickOut:\ncase PdfDictionary.Stamp:\n    return true;\ndefault :\n  return false;\n}\n}\n", "docstring": "utility method to check if formobject should have a popup", "partition": "test"}
{"idx": "4091", "code": "public void onEnterElementConsumed(String uri,String localName,String qname,Attributes atts) throws SAXException {\n  attStack.push(currentAtts=new AttributesImpl(atts));\n  nsEffectiveStack.push(new Integer(nsEffectivePtr));\n  nsEffectivePtr=namespaces.size();\n}\n", "docstring": "called by the generated handler code when an enter element event is consumed . < p > pushes a new attribute set . < p > note that attributes are not pushed at the startelement method , because the processing of the enterelement event can trigger other attribute events and etc . < p > this method will be called from one of handlers when it truely consumes the enterelement event .", "partition": "test"}
{"idx": "2585", "code": "public void testSplitEscapedSemicolons(){\n  Properties inner=PropertyUtils.splitPropertiesOnSemicolon(PropertyUtils.escapeBackSlashesIfNotNull(\"foo=bar;baz=blorple\\\\\\\\;zot;windows=c:\\\\\\\\test;glorg=gluux\"));\n  assertEquals(4,inner.size());\n  assertEquals(\"bar\",inner.getProperty(\"foo\"));\n  assertEquals(\"blorple;zot\",inner.getProperty(\"baz\"));\n  assertEquals(\"gluux\",inner.getProperty(\"glorg\"));\n  assertEquals(\"c:\\\\\\\\test\",inner.getProperty(\"windows\"));\n}\n", "docstring": "test split of escaped semicolons .", "partition": "test"}
{"idx": "2727", "code": "public EvoSVMModel(ExampleSet exampleSet,List<SupportVector> supportVectors,Kernel kernel,double bias){\n  super(exampleSet,ExampleSetUtilities.SetsCompareOption.ALLOW_SUPERSET,ExampleSetUtilities.TypesCompareOption.ALLOW_SAME_PARENTS);\n  this.supportVectors=supportVectors;\n  if (supportVectors == null || supportVectors.size() == 0) {\n    throw new IllegalArgumentException(\"Null or empty support vector collection: not possible to predict values!\");\n  }\n  this.kernel=kernel;\n  this.bias=bias;\n  if (this.kernel instanceof DotKernel) {\n    this.weights=new double[getNumberOfAttributes()];\n    for (int i=0; i < getNumberOfSupportVectors(); i++) {\n      SupportVector sv=getSupportVector(i);\n      if (sv != null) {\n        double[] x=sv.getX();\n        double alpha=sv.getAlpha();\n        double y=sv.getY();\n        for (int j=0; j < weights.length; j++) {\n          weights[j]+=y * alpha * x[j];\n        }\n      }\n else {\n        this.weights=null;\n        break;\n      }\n    }\n  }\n}\n", "docstring": "creates a classification model .", "partition": "test"}
{"idx": "2041", "code": "private static URI refragUri(URI uri,String frag) throws URISyntaxException {\n  return new URI(uri.getScheme(),uri.getSchemeSpecificPart(),frag);\n}\n", "docstring": "return a new uri with a different fragment .", "partition": "test"}
{"idx": "149", "code": "public void rectangle(double x,double y,double halfWidth,double halfHeight){\n  if (halfWidth < 0)   throw new IllegalArgumentException(\"half width can\\'t be negative\");\n  if (halfHeight < 0)   throw new IllegalArgumentException(\"half height can\\'t be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * halfWidth);\n  double hs=factorY(2 * halfHeight);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Rectangle2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "docstring": "draws a rectangle of given half width and half height , centered on ( x , y ) .", "partition": "test"}
{"idx": "562", "code": "private void addDefaultUri() throws IgniteSpiException {\n  assert uriEncodedList != null;\n  URI uri;\n  try {\n    uri=U.resolveWorkDirectory(DFLT_DEPLOY_DIR,false).toURI();\n  }\n catch (  IgniteCheckedException e) {\n    throw new IgniteSpiException(\"Failed to initialize default file scanner\",e);\n  }\n  uriEncodedList.add(uri);\n}\n", "docstring": "add configuration for file scanner .", "partition": "test"}
{"idx": "3961", "code": "protected boolean updateAttachmentPoint(){\n  boolean moved=false;\n  this.oldAPs=attachmentPoints;\n  if (attachmentPoints == null || attachmentPoints.isEmpty())   return false;\n  List<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n  if (attachmentPoints != null)   apList.addAll(attachmentPoints);\n  Map<Long,AttachmentPoint> newMap=getAPMap(apList);\n  if (newMap == null || newMap.size() != apList.size()) {\n    moved=true;\n  }\n  if (moved) {\n    log.info(\"updateAttachmentPoint: ap {}  newmap {} \",attachmentPoints,newMap);\n    List<AttachmentPoint> newAPList=new ArrayList<AttachmentPoint>();\n    if (newMap != null)     newAPList.addAll(newMap.values());\n    this.attachmentPoints=newAPList;\n  }\n  return moved;\n}\n", "docstring": "update the known attachment points . this method is called whenever topology changes . the method returns true if there \"'\" s any change to the list of attachment points - - which indicates a possible device move .", "partition": "test"}
{"idx": "245", "code": "public static String formattingFinishedPercentage(final RolloutGroup rolloutGroup,final float finishedPercentage){\n  float tmpFinishedPercentage=0;\nswitch (rolloutGroup.getStatus()) {\ncase READY:\ncase SCHEDULED:\ncase ERROR:\n    tmpFinishedPercentage=0.0F;\n  break;\ncase FINISHED:\ntmpFinishedPercentage=100.0F;\nbreak;\ncase RUNNING:\ntmpFinishedPercentage=finishedPercentage;\nbreak;\ndefault :\nbreak;\n}\nreturn String.format(\"%.1f\",tmpFinishedPercentage);\n}\n", "docstring": "formats the finished percentage of a rollout group into a string with one digit after comma .", "partition": "test"}
{"idx": "2077", "code": "@Override public void drawItem(Graphics2D g2,CategoryItemRendererState state,Rectangle2D dataArea,CategoryPlot plot,CategoryAxis domainAxis,ValueAxis rangeAxis,CategoryDataset dataset,int row,int column,int pass){\n  int visibleRow=state.getVisibleSeriesIndex(row);\n  if (visibleRow < 0) {\n    return;\n  }\n  Number dataValue=dataset.getValue(row,column);\n  if (dataValue == null) {\n    return;\n  }\n  double value=dataValue.doubleValue();\n  PlotOrientation orientation=plot.getOrientation();\n  double barW0=calculateBarW0(plot,orientation,dataArea,domainAxis,state,visibleRow,column);\n  RectangleEdge edge=plot.getRangeAxisEdge();\n  double barL=rangeAxis.valueToJava2D(value,dataArea,edge);\n  Line2D line;\n  double x, y;\n  if (orientation.isHorizontal()) {\n    x=barL;\n    y=barW0 + state.getBarWidth() / 2.0;\n    line=new Line2D.Double(barL,barW0,barL,barW0 + state.getBarWidth());\n  }\n else {\n    x=barW0 + state.getBarWidth() / 2.0;\n    y=barL;\n    line=new Line2D.Double(barW0,barL,barW0 + state.getBarWidth(),barL);\n  }\n  if (state.getElementHinting()) {\n    beginElementGroup(g2,dataset.getRowKey(row),dataset.getColumnKey(column));\n  }\n  Stroke itemStroke=getItemStroke(row,column);\n  Paint itemPaint=getItemPaint(row,column);\n  g2.setStroke(itemStroke);\n  g2.setPaint(itemPaint);\n  g2.draw(line);\n  if (state.getElementHinting()) {\n    endElementGroup(g2);\n  }\n  CategoryItemLabelGenerator generator=getItemLabelGenerator(row,column);\n  if (generator != null && isItemLabelVisible(row,column)) {\n    drawItemLabel(g2,orientation,dataset,row,column,x,y,(value < 0.0));\n  }\n  int datasetIndex=plot.indexOf(dataset);\n  updateCrosshairValues(state.getCrosshairState(),dataset.getRowKey(row),dataset.getColumnKey(column),value,datasetIndex,barW0,barL,orientation);\n  EntityCollection entities=state.getEntityCollection();\n  if (entities != null) {\n    addItemEntity(entities,dataset,row,column,line.getBounds());\n  }\n}\n", "docstring": "draws the bar for a single ( series , category ) data item .", "partition": "test"}
{"idx": "1470", "code": "public static EjbJarXmlVersion valueOf(DocumentType docType) throws NullPointerException {\n  return valueOf(docType.getPublicId());\n}\n", "docstring": "returns the version corresponding to the given document type .", "partition": "test"}
{"idx": "1980", "code": "public boolean contains(List<Integer> hashes){\n  Iterator<Integer> ni=hashes.iterator();\n  for (int i=0; i < hashFunctions; ++i) {\n    if (!testBit((int)((ni.next() & 0xFFFFFFFFL) % (filter.length * 8)))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "check if the filter contains data with precomputed hashes .", "partition": "test"}
{"idx": "4253", "code": "public Vector rotateInDegree(double degree){\n  return rotateInRadian(Math.toRadians(degree));\n}\n", "docstring": "return a new instance of vector rotated from the given number of degrees .", "partition": "test"}
{"idx": "3084", "code": "protected void clearDataLists(int obdService){\nswitch (obdService) {\ncase OBD_SVC_DATA:\ncase OBD_SVC_FREEZEFRAME:\n    pidSupported.clear();\n  PidPvs.clear();\nbreak;\ncase OBD_SVC_READ_CODES:\ncase OBD_SVC_PENDINGCODES:\ncase OBD_SVC_PERMACODES:\ntCodes.clear();\nbreak;\ncase OBD_SVC_VEH_INFO:\npidSupported.clear();\nVidPvs.clear();\nbreak;\n}\n}\n", "docstring": "clear data lists for selected service", "partition": "test"}
{"idx": "1886", "code": "public SecretBlock(Mario player,Group parent,int stageZone,float xPos,float yPos,float yoloWidth,Image... hitState){\n  super(BLOCK_COLLISION_DATA,xPos,yPos,0,0,(Image)null);\n  this.hitState=hitState[0];\n  yoloView=new ImageView(hitState[1]);\n  yoloView.setFitWidth(yoloWidth);\n  this.parent=parent;\n  zone=stageZone;\n}\n", "docstring": "constructs a single secretblock ( tile which generates one - ups in original game , but \" yolo \" image in this game ) .", "partition": "test"}
{"idx": "1002", "code": "private static void byte2hex(byte b,StringBuffer buf){\n  int high=((b & 0xf0) >> 4);\n  int low=(b & 0x0f);\n  buf.append(HEX_DIGITS[high]);\n  buf.append(HEX_DIGITS[low]);\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "1661", "code": "public static String extractMusicIDFromMediaID(@NonNull String mediaID){\n  int pos=mediaID.indexOf(LEAF_SEPARATOR);\n  if (pos >= 0) {\n    return mediaID.substring(pos + 1);\n  }\n  return null;\n}\n", "docstring": "extracts unique musicid from the mediaid . mediaid is , by this sample \"'\" s convention , a concatenation of category ( eg \" by_genre \" ) , categoryvalue ( eg \" classical \" ) and unique musicid . this is necessary so we know where the user selected the music from , when the music exists in more than one music list , and thus we are able to correctly build the playing queue .", "partition": "test"}
{"idx": "1570", "code": "protected void drawConnectorCenters(Canvas c){\n  List<Connection> connections=mBlock.getAllConnections();\n  Paint paint=new Paint();\n  paint.setStyle(Paint.Style.FILL);\n  for (int i=0; i < connections.size(); i++) {\n    Connection conn=connections.get(i);\n    if (conn.inDragMode()) {\n      if (conn.isConnected()) {\n        paint.setColor(Color.RED);\n      }\n else {\n        paint.setColor(Color.MAGENTA);\n      }\n    }\n else {\n      if (conn.isConnected()) {\n        paint.setColor(Color.GREEN);\n      }\n else {\n        paint.setColor(Color.CYAN);\n      }\n    }\n    mTempWorkspacePoint.set(conn.getPosition().x - mBlock.getPosition().x,conn.getPosition().y - mBlock.getPosition().y);\n    mHelper.workspaceToVirtualViewDelta(mTempWorkspacePoint,mTempConnectionPosition);\n    if (mHelper.useRtl()) {\n      mTempConnectionPosition.x+=mBlockViewSize.x;\n    }\n    c.drawCircle(mTempConnectionPosition.x,mTempConnectionPosition.y,10,paint);\n  }\n}\n", "docstring": "this is a developer testing function subclasses can call to draw dots at the model \"'\" s location of all connections on this block . never called by default .", "partition": "test"}
{"idx": "1046", "code": "private boolean tryStep(final double t0,final double[] y0,final double step,final int k,final double[] scale,final double[][] f,final double[] yMiddle,final double[] yEnd) throws MathIllegalArgumentException, MathIllegalStateException {\n  final int n=sequence[k];\n  final double subStep=step / n;\n  final double subStep2=2 * subStep;\n  double t=t0 + subStep;\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=y0[i] + subStep * f[0][i];\n  }\n  f[1]=computeDerivatives(t,yEnd);\n  final double[] yTmp=y0.clone();\n  for (int j=1; j < n; ++j) {\n    if (2 * j == n) {\n      System.arraycopy(yEnd,0,yMiddle,0,y0.length);\n    }\n    t+=subStep;\n    for (int i=0; i < y0.length; ++i) {\n      final double middle=yEnd[i];\n      yEnd[i]=yTmp[i] + subStep2 * f[j][i];\n      yTmp[i]=middle;\n    }\n    f[j + 1]=computeDerivatives(t,yEnd);\n    if (performTest && (j <= maxChecks) && (k < maxIter)) {\n      double initialNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=f[0][l] / scale[l];\n        initialNorm+=ratio * ratio;\n      }\n      double deltaNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=(f[j + 1][l] - f[0][l]) / scale[l];\n        deltaNorm+=ratio * ratio;\n      }\n      if (deltaNorm > 4 * FastMath.max(1.0e-15,initialNorm)) {\n        return false;\n      }\n    }\n  }\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n  }\n  return true;\n}\n", "docstring": "perform integration over one step using substeps of a modified midpoint method .", "partition": "test"}
{"idx": "1889", "code": "private void createInsertList(final IItem item,List<IItem> tempList,List<IItem> insertList,int depth,int removed){\n  if (!tempList.contains(item)) {\n    tempList.add(item);\n    if (depth == 0) {\n      insertList.add(item);\n    }\n    if (item.getItems() != null) {\n      depth++;\n      for (      IItem child : item.getItems()) {\n        createInsertList(child,tempList,insertList,depth,removed);\n      }\n    }\n  }\n else {\n    insertList.remove(item);\n    removed++;\n  }\n}\n", "docstring": "recursive helper method for createinsertlist", "partition": "test"}
{"idx": "3994", "code": "public static void chunkTaskSync(RegionWrapper region,final RunnableVal<int[]> task){\n  final int p1x=region.minX;\n  final int p1z=region.minZ;\n  final int p2x=region.maxX;\n  final int p2z=region.maxZ;\n  final int bcx=p1x >> 4;\n  final int bcz=p1z >> 4;\n  final int tcx=p2x >> 4;\n  final int tcz=p2z >> 4;\n  task.value=new int[7];\n  for (int x=bcx; x <= tcx; x++) {\n    for (int z=bcz; z <= tcz; z++) {\n      task.value[0]=x;\n      task.value[1]=z;\n      task.value[2]=task.value[0] << 4;\n      task.value[3]=task.value[1] << 4;\n      task.value[4]=task.value[2] + 15;\n      task.value[5]=task.value[3] + 15;\n      task.value[6]=0;\n      if (task.value[0] == bcx) {\n        task.value[2]=p1x;\n        task.value[6]=1;\n      }\n      if (task.value[0] == tcx) {\n        task.value[4]=p2x;\n        task.value[6]=1;\n      }\n      if (task.value[1] == bcz) {\n        task.value[3]=p1z;\n        task.value[6]=1;\n      }\n      if (task.value[1] == tcz) {\n        task.value[5]=p2z;\n        task.value[6]=1;\n      }\n      task.run();\n    }\n  }\n}\n", "docstring": "the int [ ", "partition": "test"}
{"idx": "3286", "code": "private long loadLargestMessageId(){\n  ReleaseMessage releaseMessage=releaseMessageRepository.findTopByOrderByIdDesc();\n  return releaseMessage == null ? 0 : releaseMessage.getId();\n}\n", "docstring": "find largest message id as the current start point", "partition": "test"}
{"idx": "1434", "code": "public void addToGlobalBlacklist(String host){\n  addToGlobalBlacklist(host,System.currentTimeMillis() + this.globalBlacklistTimeout);\n}\n", "docstring": "adds a host to the blacklist .", "partition": "test"}
{"idx": "2920", "code": "public static double L_RankLoss(int y[],int r[]){\n  int L=y.length;\n  ArrayList<Integer> tI=new ArrayList<Integer>();\n  ArrayList<Integer> fI=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      tI.add(j);\n    }\n else {\n      fI.add(j);\n    }\n  }\n  if (!tI.isEmpty() && !fI.isEmpty()) {\n    int c=0;\n    for (    int k : tI) {\n      for (      int l : fI) {\n        if (position(k,r) < position(l,r)) {\n          c++;\n        }\n      }\n    }\n    return (double)c / (double)(tI.size() * fI.size());\n  }\n else {\n    return 0.0;\n  }\n}\n", "docstring": "rank loss - the average fraction of labels which are not correctly ordered . thanks to noureddine yacine nair benrekia for providing bug fix for this .", "partition": "test"}
{"idx": "3365", "code": "public static void verifySetterMethods(Class<?> clazz,MappedField... fields){\n  String methodName=null;\n  String fieldName=null;\n  Class<?> fieldType=null;\n  try {\n    for (    MappedField field : fields) {\n      fieldName=field.getName();\n      fieldType=field.getType();\n      String customSet=field.setMethod();\n      if (!isNull(customSet) && !customSet.equals(Constants.DEFAULT_ACCESSOR_VALUE))       try {\n        clazz.getMethod(customSet,fieldType);\n        field.setMethod(customSet);\n        continue;\n      }\n catch (      Exception e) {\n        Error.customMethod(\"set\",customSet,clazz);\n      }\n      methodName=mSet(fieldName);\n      clazz.getMethod(methodName,fieldType);\n      field.setMethod(methodName);\n    }\n  }\n catch (  Exception e) {\n    Error.method(methodName,fieldName,clazz);\n  }\n}\n", "docstring": "verifies that the setter methods are compliant with the naming convention .", "partition": "test"}
{"idx": "946", "code": "private void applyTradingBonus(Player player){\n  player.incrementTradescore();\n}\n", "docstring": "rewards player for a successfull trade", "partition": "test"}
{"idx": "773", "code": "public UrbanSimZoneCSVWriterV2(String matsim4opusTempDirectory,String matsimOutputDirectory){\n  this.matsim4opusTempDirectory=matsim4opusTempDirectory;\n  this.matsimOutputDirectory=matsimOutputDirectory;\n  try {\n    log.info(\"Initializing UrbanSimZoneCSVWriterV2 ...\");\n    zoneWriter=IOUtils.getBufferedWriter(matsim4opusTempDirectory + FILE_NAME);\n    log.info(\"Writing data into \" + matsim4opusTempDirectory + FILE_NAME+ \" ...\");\n    zoneWriter.write(Labels.ZONE_ID + \",\" + Labels.ACCESSIBILITY_BY_FREESPEED+ \",\"+ Labels.ACCESSIBILITY_BY_CAR+ \",\"+ Labels.ACCESSIBILITY_BY_BIKE+ \",\"+ Labels.ACCESSIBILITY_BY_WALK+ \",\"+ Labels.ACCESSIBILITY_BY_PT);\n    zoneWriter.newLine();\n    log.info(\"... done!\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "writes the header for zones csv file", "partition": "test"}
{"idx": "187", "code": "public static <R,A,B>CompletionStage<R> combine(CompletionStage<A> a,CompletionStage<B> b,BiFunction<A,B,R> function){\n  return a.thenCombine(b,function);\n}\n", "docstring": "combines multiple stages by applying a function .", "partition": "test"}
{"idx": "2155", "code": "public static void assertSpecificLang(String specificLang) throws XMPException {\n  if (specificLang == null || specificLang.length() == 0) {\n    throw new XMPException(\"Empty specific language\",XMPError.BADPARAM);\n  }\n}\n", "docstring": "asserts that a specific language is set .", "partition": "test"}
{"idx": "3341", "code": "public ServiceHost startFactory(Service instanceService){\n  final Class<? extends Service> serviceClass=instanceService.getClass();\n  return startFactory(serviceClass,null);\n}\n", "docstring": "starts a default factory service for the given instance service . note that this will not start the instance service .", "partition": "test"}
{"idx": "4032", "code": "public synchronized byte[] lookupAudio(String inputtype,String locale,String voice,String outputparams,String style,String effects,String inputtext) throws SQLException {\n  if (inputtype == null || locale == null || voice == null || inputtext == null) {\n    throw new NullPointerException(\"Null argument\");\n  }\n  byte[] audio=null;\n  String query=\"Select outputaudio FROM marycache WHERE inputtype = \\'\" + inputtype + \"\\' AND outputtype = \\'AUDIO\\' AND locale = \\'\"+ locale+ \"\\' AND voice = \\'\"+ voice+ \"\\' AND outputparams = \\'\"+ outputparams+ \"\\' AND style = \\'\"+ style+ \"\\' AND effects = \\'\"+ effects+ \"\\' AND inputtext = ?\";\n  PreparedStatement st=connection.prepareStatement(query);\n  st.setString(1,inputtext);\n  ResultSet results=st.executeQuery();\n  if (results.next()) {\n    audio=results.getBytes(1);\n  }\n  return audio;\n}\n", "docstring": "carry out a lookup in the cache with the given parameters , for a request with output type audio .", "partition": "test"}
{"idx": "307", "code": "public int read() throws IOException {\n  if (inputStream == null) {\n    reopen();\n  }\n  count(1);\n  return inputStream.read();\n}\n", "docstring": "read from the file .", "partition": "test"}
{"idx": "1763", "code": "@Override public CompletableFuture<Optional<T>> max(final Comparator<? super T> comparator){\n  return CompletableFuture.supplyAsync(null,exec);\n}\n", "docstring": "perform an asyncrhonous min operation", "partition": "test"}
{"idx": "2710", "code": "public static String replace(String str,char oldChar,String newStr){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < str.length(); i++) {\n    char ch=str.charAt(i);\n    if (ch == oldChar) {\n      buf.append(newStr);\n    }\n else {\n      buf.append(ch);\n    }\n  }\n  return buf.toString();\n}\n", "docstring": "returns a string with all occurrences of oldchar replaced by newstr", "partition": "test"}
{"idx": "2186", "code": "public char[] toCharArray(){\n  char[] newValue=new char[count];\n  System.arraycopy(buf,0,newValue,0,count);\n  return newValue;\n}\n", "docstring": "returns a copy of the input data .", "partition": "test"}
{"idx": "1079", "code": "@SafeVarargs public final void add(T... newItems){\n  add(Arrays.asList(newItems));\n}\n", "docstring": "add new items to the table .", "partition": "test"}
{"idx": "3440", "code": "private void writeAttr(String name,String val) throws IOException {\n  writeAttr(name,val,true);\n}\n", "docstring": "writes the xml attribute name / val . a null val means that the attribute is missing .", "partition": "test"}
{"idx": "581", "code": "protected void load_raw_characters(StringBuilder sb) throws IOException {\n  int c=read_char();\n  for (; ; ) {\n    c=read_char();\nswitch (c) {\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:\n      continue;\ncase -1:\n    return;\ndefault :\n  if (!IonTokenConstsX.is7bitValue(c)) {\n    c=read_large_char_sequence(c);\n  }\n}\nif (IonUTF8.needsSurrogateEncoding(c)) {\nsb.append(IonUTF8.highSurrogate(c));\nc=IonUTF8.lowSurrogate(c);\n}\nsb.append((char)c);\n}\n}\n", "docstring": "this is used to load a previously marked set of bytes into the stringbuilder without escaping . it expects the caller to have set a save point so that the eof will stop us at the right time . this does handle utf8 decoding and surrogate encoding as the bytes are transfered .", "partition": "test"}
{"idx": "703", "code": "public static ThreadDump create(){\n  ThreadDump threadDump=_threadDumpRef.get();\n  if (threadDump == null) {\n    threadDump=new ThreadDumpPro();\n    _threadDumpRef.compareAndSet(null,threadDump);\n    threadDump=_threadDumpRef.get();\n  }\n  return threadDump;\n}\n", "docstring": "returns the singleton instance , creating if necessary . an instance of com . caucho . server . admin . prothreaddump will be returned if available and licensed . prothreaddump includes the uri of the request the thread is processing , if applicable .", "partition": "test"}
{"idx": "289", "code": "private Workflow.Method createVolumesMethod(URI systemURI,URI poolURI,List<URI> volumeURIs,VirtualPoolCapabilityValuesWrapper capabilities){\n  return new Workflow.Method(\"createVolumes\",systemURI,poolURI,volumeURIs,capabilities);\n}\n", "docstring": "return a workflow . method for createvolumes .", "partition": "test"}
{"idx": "585", "code": "public static final String toBitString(int i[]){\n  StringBuilder sb=new StringBuilder(i.length);\n  for (  int b : i) {\n    sb.append(b);\n  }\n  return sb.toString();\n}\n", "docstring": "tobitstring - returns a string representation of i [ ", "partition": "test"}
{"idx": "3638", "code": "public boolean equals(Object object){\n  if (object == null || !(object instanceof SessionID)) {\n    return false;\n  }\n  SessionID another=(SessionID)object;\n  return encryptedString.equals(another.encryptedString);\n}\n", "docstring": "compares this session id to the specified object . the result is true if and only if the argument is not null and the random string and server name are the same in both objects .", "partition": "test"}
{"idx": "3045", "code": "public DisjointSets(int numElements){\n  array=new int[numElements];\n  Arrays.fill(array,-1);\n}\n", "docstring": "construct a disjoint sets object .", "partition": "test"}
{"idx": "2455", "code": "@Override public Void visitType(TypeElement e,Void p){\n  scan(e.getTypeParameters(),p);\n  checkCamelCase(e,true);\n  super.visitType(e,p);\n  return null;\n}\n", "docstring": "check the name of a type and its enclosed elements and type parameters .", "partition": "test"}
{"idx": "4162", "code": "public void replaceNonOptionalNonMinusNodesWith(final List<IGroupMemberNode> ordered,final boolean recomputeDefinitelyProduced){\n  nonOptionalNonMinusNodes.clear();\n  nonOptionalNonMinusNodes.addAll(ordered);\n  if (recomputeDefinitelyProduced) {\n    recomputeDefinitelyProduced();\n  }\n}\n", "docstring": "the new ordered list of non - optional non - minus nodes . if recomputeddefinitelyproduced variables is set to false , the definitely produced variables will not be recomputed ( this is a performance tweak which can be exploited when reordering the nodes only , for instance ) .", "partition": "test"}
{"idx": "1957", "code": "public void skip(int count) throws IOException {\n  int skipCount=Math.min(limit - position,count);\n  while (true) {\n    position+=skipCount;\n    count-=skipCount;\n    if (count == 0)     break;\n    skipCount=Math.min(count,capacity);\n    require(skipCount);\n  }\n}\n", "docstring": "discards the specified number of bytes .", "partition": "test"}
{"idx": "2173", "code": "protected void drawCloud(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  GeneralPath path=new GeneralPath();\n  path.moveTo((float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.curveTo((float)(x + 0.05 * w),(float)(y + 0.25 * h),(float)x,(float)(y + 0.5 * h),(float)(x + 0.16 * w),(float)(y + 0.55 * h));\n  path.curveTo((float)x,(float)(y + 0.66 * h),(float)(x + 0.18 * w),(float)(y + 0.9 * h),(float)(x + 0.31 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + 0.4 * w),(float)(y + h),(float)(x + 0.7 * w),(float)(y + h),(float)(x + 0.8 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.8 * h),(float)(x + w),(float)(y + 0.6 * h),(float)(x + 0.875 * w),(float)(y + 0.5 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.3 * h),(float)(x + 0.8 * w),(float)(y + 0.1 * h),(float)(x + 0.625 * w),(float)(y + 0.2 * h));\n  path.curveTo((float)(x + 0.5 * w),(float)(y + 0.05 * h),(float)(x + 0.3 * w),(float)(y + 0.05 * h),(float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.closePath();\n  drawPath(path,fillColor,fillPaint,penColor,shadow);\n}\n", "docstring": "draws a cloud shape for the given parameters .", "partition": "test"}
{"idx": "1273", "code": "public static void deleteFile(File file) throws AdeUsageException {\n  if (!file.delete()) {\n    throw new AdeUsageException(FAILED_DELETING_FILE + file.getPath());\n  }\n}\n", "docstring": "delete a file from file system .", "partition": "test"}
{"idx": "2509", "code": "public static boolean checkGMLFootprint(String footprint){\n  try {\n    Configuration configuration=new GMLConfiguration();\n    Parser parser=new Parser(configuration);\n    Geometry geom=(Geometry)parser.parse(new InputSource(new StringReader(footprint)));\n    if (!geom.isEmpty() && !geom.isValid()) {\n      logger.error(\"Wrong footprint\");\n      return false;\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Error in extracted footprint: \" + e.getMessage());\n    return false;\n  }\n  return true;\n}\n", "docstring": "check gml footprint validity", "partition": "test"}
{"idx": "570", "code": "private static boolean isEnabled(){\n  if (SystemUtils.IS_OS_WINDOWS) {\n    return false;\n  }\n  try {\n    List<String> lines=CommandUtil.executeCommandAndGetLines(Collections.singletonList(\"sestatus\"));\n    for (    String line : lines) {\n      if (line.contains(\"SELinux status\")) {\n        if (line.contains(\"enabled\")) {\n          Logger.info(\"SELinux is enabled on this system\");\n          return true;\n        }\n        return false;\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n  return false;\n}\n", "docstring": "check whether selinux is enabled or not .", "partition": "test"}
{"idx": "420", "code": "public static KeyStore load(File keyStoreFile,Password password) throws CryptoException, FileNotFoundException {\n  KeyStoreType keyStoreType=null;\n  try {\n    keyStoreType=CryptoFileUtil.detectKeyStoreType(new FileInputStream(keyStoreFile));\n  }\n catch (  FileNotFoundException ex) {\n    throw ex;\n  }\ncatch (  IOException ex) {\n    throw new CryptoException(res.getString(\"NoLoadKeyStore.exception.message\"),ex);\n  }\n  if (keyStoreType == null) {\n    return null;\n  }\n  return load(keyStoreFile,password,keyStoreType);\n}\n", "docstring": "load a keystore , auto - detecting the type , from a file accessed by a password .", "partition": "test"}
{"idx": "789", "code": "private void retrieveWaypoints(SearchQuery query,ArrayList<Waypoint> waypoints){\n  String queryLikeSelection2=\"%\" + query.textQuery + \"%\";\n  String[] waypointSelectionArgs=new String[]{queryLikeSelection2,queryLikeSelection2,queryLikeSelection2};\n  Cursor cursor=null;\n  try {\n    cursor=providerUtils.getWaypointCursor(WAYPOINT_SELECTION_QUERY,waypointSelectionArgs,WAYPOINT_SELECTION_ORDER,MAX_SCORED_WAYPOINTS);\n    if (cursor != null) {\n      waypoints.ensureCapacity(cursor.getCount());\n      while (cursor.moveToNext()) {\n        Waypoint waypoint=providerUtils.createWaypoint(cursor);\n        if (LocationUtils.isValidLocation(waypoint.getLocation())) {\n          waypoints.add(waypoint);\n        }\n      }\n    }\n  }\n  finally {\n    if (cursor != null) {\n      cursor.close();\n    }\n  }\n}\n", "docstring": "retrieves waypoints matching the given query from the database .", "partition": "test"}
{"idx": "4120", "code": "public MersenneTwister(){\n  mt=new int[N];\n  setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}\n", "docstring": "creates a new random number generator . < p > the instance is initialized using the current time plus the system identity hash code of this instance as the seed .", "partition": "test"}
{"idx": "1219", "code": "private String insertProperties(String template,Map<String,String> properties){\n  for (  Entry<String,String> entry : properties.entrySet()) {\n    template=template.replace(entry.getKey(),entry.getValue());\n  }\n  return template;\n}\n", "docstring": "inserts properties to the template .", "partition": "test"}
{"idx": "1056", "code": "public DriverTask unexportVolumesFromInitiators(List<Initiator> initiators,List<StorageVolume> volumes){\n  LOG.info(\"Unexporting volumes from initiators\");\n  DriverTask task=new DellSCDriverTask(\"unexportVolumes\");\n  ScServer server=null;\n  StringBuilder errBuffer=new StringBuilder();\n  int volumesUnmapped=0;\n  for (  StorageVolume volume : volumes) {\n    String ssn=volume.getStorageSystemId();\n    boolean isSnapshot=StringUtils.countMatches(volume.getNativeId(),\".\") == 2;\n    try {\n      StorageCenterAPI api=connectionManager.getConnection(ssn);\n      ScVolume scVol=null;\n      if (isSnapshot) {\n        scVol=api.findReplayView(volume.getNativeId());\n        if (scVol != null) {\n          api.deleteVolume(scVol.instanceId);\n          volumesUnmapped++;\n          continue;\n        }\n      }\n else {\n        scVol=api.getVolume(volume.getNativeId());\n      }\n      if (scVol == null) {\n        throw new DellSCDriverException(String.format(\"Unable to find volume %s\",volume.getNativeId()));\n      }\n      if (server == null) {\n        server=findScServer(api,ssn,initiators);\n      }\n      if (server == null) {\n        throw new DellSCDriverException(SERVER_CREATE_FAIL_MSG);\n      }\n      ScMappingProfile[] mappingProfiles=api.findMappingProfiles(server.instanceId,scVol.instanceId);\n      for (      ScMappingProfile mappingProfile : mappingProfiles) {\n        api.deleteMappingProfile(mappingProfile.instanceId);\n      }\n      volumesUnmapped++;\n      LOG.info(\"Volume \\'{}\\' unexported from server \\'{}\\'\",scVol.name,server.name);\n    }\n catch (    StorageCenterAPIException|DellSCDriverException dex) {\n      String error=String.format(\"Error unmapping volume %s: %s\",volume.getDisplayName(),dex);\n      LOG.error(error);\n      errBuffer.append(String.format(\"%s%n\",error));\n      if (SERVER_CREATE_FAIL_MSG.equals(dex.getMessage())) {\n        break;\n      }\n    }\n  }\n  task.setMessage(errBuffer.toString());\n  if (volumesUnmapped == volumes.size()) {\n    task.setStatus(TaskStatus.READY);\n  }\n else   if (volumesUnmapped == 0) {\n    task.setStatus(TaskStatus.FAILED);\n  }\n else {\n    task.setStatus(TaskStatus.PARTIALLY_FAILED);\n  }\n  return task;\n}\n", "docstring": "remove volume exports to initiators .", "partition": "test"}
{"idx": "2232", "code": "public static Node serializableInstance(){\n  return new GraphNode(\"X\");\n}\n", "docstring": "generates a simple exemplar of this class to test serialization .", "partition": "test"}
{"idx": "959", "code": "protected MapleQuestRequirement(MapleQuest quest,ReadBin data) throws IOException {\n  this.quest=quest;\n  this.dayByDay=data.readByte() > 0;\n  this.normalAutoStart=data.readByte() > 0;\n  this.lvmin=data.readShort();\n  this.lvmax=data.readShort();\n  this.mbmin=data.readShort();\n  this.charismaMin=data.readShort();\n  this.charmMin=data.readShort();\n  this.craftMin=data.readShort();\n  this.insightMin=data.readShort();\n  this.senseMin=data.readShort();\n  this.willMin=data.readShort();\n  this.pop=data.readShort();\n  this.pettamenessmin=data.readShort();\n  this.subJobFlag=data.readShort();\n  this.npc=data.readInt();\n  this.interval=data.readInt();\n  this.end=data.readString();\n  this.startscript=data.readString();\n  this.endscript=data.readString();\n  short size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int field=data.readInt();\n    fieldEnter.add(field);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    short job=data.readShort();\n    jobs.add(job);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    boolean acquire=data.readByte() > 0;\n    skills.put(id,acquire);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    byte state=data.readByte();\n    byte order=data.readByte();\n    quests.put(id,state);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    int count=data.readInt();\n    byte order=data.readByte();\n    items.put(id,count);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    int count=data.readInt();\n    mobs.put(id,count);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    pets.add(id);\n  }\n}\n", "docstring": "creates a new instance of maplequestrequirement .", "partition": "test"}
{"idx": "1095", "code": "public int addDir(File file){\n  if (!file.exists()) {\n    return 0;\n  }\n  String[] names=getNames(getFiles(file,\".class\"));\n  loadClass(file,names);\n  return 1;\n}\n", "docstring": "adds new locations for command classes", "partition": "test"}
{"idx": "2712", "code": "public TypeDeclaration canonicalize(){\n  List<Type> sts=getSatisfiedTypes();\n  if (sts.isEmpty()) {\n    return unit.getAnythingDeclaration();\n  }\n else   if (sts.size() == 1) {\n    Type st=sts.get(0);\n    if (st.isExactlyNothing()) {\n      return unit.getNothingDeclaration();\n    }\n  }\n  for (  Type st : sts) {\n    if (st.isUnion()) {\n      List<Type> caseTypes=st.getCaseTypes();\n      List<Type> ulist=new ArrayList<Type>(caseTypes.size());\n      for (      Type ct : caseTypes) {\n        List<Type> ilist=new ArrayList<Type>(sts.size());\n        for (        Type pt : sts) {\n          if (pt == st) {\n            addToIntersection(ilist,ct,unit);\n          }\n else {\n            addToIntersection(ilist,pt,unit);\n          }\n        }\n        Type it=canonicalIntersection(ilist,unit);\n        addToUnion(ulist,it);\n      }\n      TypeDeclaration result=new UnionType(unit);\n      result.setCaseTypes(ulist);\n      return result;\n    }\n  }\n  return this;\n}\n", "docstring": "apply the distributive rule x & ( y | z ) = = x & y | x & z to simplify the intersection to a canonical form with no parens . the result is a union of intersections , instead of an intersection of unions .", "partition": "test"}
{"idx": "197", "code": "public List<ValidationErrorMessage> validate(){\n  errorMessageIds.clear();\n  if (paymentProduct == null) {\n    throw new NullPointerException(\"Error validating PaymentRequest, please set a paymentProduct first.\");\n  }\n  for (  PaymentProductField field : paymentProduct.getPaymentProductFields()) {\n    if (!isFieldInAccountOnFileAndNotAltered(field)) {\n      errorMessageIds.addAll(field.validateValue(getValue(field.getId())));\n    }\n  }\n  return errorMessageIds;\n}\n", "docstring": "validates all fields based on their value and their validationrules if a field is prefilled from the account on file , but it has been altered , it will be validated .", "partition": "test"}
{"idx": "186", "code": "public QueryStringQueryBuilder field(String field){\n  if (fields == null) {\n    fields=new ArrayList<>();\n  }\n  fields.add(field);\n  return this;\n}\n", "docstring": "adds a field to run the query string against .", "partition": "test"}
{"idx": "380", "code": "@Override public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumRules\");\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration of the additional measure names", "partition": "test"}
{"idx": "1490", "code": "public synchronized void init(){\n  ArrayList<Warrant> tempList=new ArrayList<Warrant>();\n  List<String> systemNameList=_manager.getSystemNameList();\n  Iterator<String> iter=systemNameList.iterator();\n  while (iter.hasNext()) {\n    Warrant w=_manager.getBySystemName(iter.next());\n    if (!_warList.contains(w)) {\n      w.addPropertyChangeListener(this);\n    }\n else {\n      _warList.remove(w);\n    }\n    tempList.add(w);\n  }\n  for (int i=0; i < _warList.size(); i++) {\n    Warrant w=_warList.get(i);\n    if (!_warNX.contains(w)) {\n      w.removePropertyChangeListener(this);\n    }\n  }\n  for (int i=0; i < _warNX.size(); i++) {\n    tempList.add(_warNX.get(i));\n  }\n  _warList=tempList;\n}\n", "docstring": "preserve current listeners so that there is no gap to miss a propertychange", "partition": "test"}
{"idx": "3537", "code": "private static boolean versionMatches(Integer v1,int v2){\n  if (v1 == null || v1 == 0 || v2 == 0) {\n    return true;\n  }\n  return v1.equals(v2);\n}\n", "docstring": "determines if a kvno matches another kvno . used in the method findkey ( etype , version , keys ) . always returns true if either input is null or zero , in case any side does not have kvno info available . note : zero is included because n / a is not a legal value for kvno in javax . security . auth . kerberos . kerberoskey . therefore , the info that the kvno is n / a might be lost when converting between encryptionkey and kerberoskey .", "partition": "test"}
{"idx": "3803", "code": "private void updatePropertyToValue2() throws Exception {\n  properties.put(TEST_KEY,TEST_VALUE_2);\n  updatePropertiesFile();\n}\n", "docstring": "updates the key in the persistent property store to \" value 2 \" .", "partition": "test"}
{"idx": "550", "code": "private void traverseInternal(Object root,boolean yieldRoot,IdentityHashMap<Object,Object> seen){\n  if (root == null || seen.containsKey(root)) {\n    return;\n  }\n  if (yieldRoot) {\n    if (!visit(root)) {\n      return;\n    }\n  }\n  seen.put(root,root);\n  if (root instanceof JSONObject) {\n    JSONObject json=(JSONObject)root;\n    Iterator<String> keys=json.keys();\n    while (keys.hasNext()) {\n      String key=keys.next();\n      try {\n        traverseInternal(json.get(key),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof JSONArray) {\n    JSONArray array=(JSONArray)root;\n    for (int i=0; i < array.length(); ++i) {\n      try {\n        traverseInternal(array.get(i),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof Map) {\n    Map<?,?> map=(Map<?,?>)root;\n    for (    Object value : map.values()) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof List) {\n    List<?> list=(List<?>)root;\n    for (    Object value : list) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof ParseObject) {\n    if (traverseParseObjects) {\n      ParseObject object=(ParseObject)root;\n      for (      String key : object.keySet()) {\n        traverseInternal(object.get(key),true,seen);\n      }\n    }\n  }\n else   if (root instanceof ParseACL) {\n    ParseACL acl=(ParseACL)root;\n    ParseUser user=acl.getUnresolvedUser();\n    if (user != null && user.isCurrentUser()) {\n      traverseInternal(user,true,seen);\n    }\n  }\n}\n", "docstring": "internal implementation of traverse .", "partition": "test"}
{"idx": "354", "code": "public boolean onEvent(ActionResult result){\nsynchronized (this) {\n    String requestId=result.getResponseInfo().mRequestId;\n    if (requestId == null) {\n      return false;\n    }\n    boolean eventRemoved=mRequestIds.remove(requestId);\n    if (eventRemoved) {\n      Class key=null;\n      for (      Class type : mLastRequestIdByType.keySet()) {\n        if (requestId.equals(mLastRequestIdByType.get(type))) {\n          key=type;\n          break;\n        }\n      }\n      if (key != null) {\n        mLastRequestIdByType.remove(key);\n      }\n    }\n    return eventRemoved;\n  }\n}\n", "docstring": "required method to be called if you are using requestkeeper to funnel your requests .", "partition": "test"}
{"idx": "3402", "code": "public RE extractRE() throws InterruptedException {\n  arden();\n  if (!coeffs.isEmpty()) {\n    throw new RuntimeException(\"production still has free variables\");\n  }\n  return unionREs(terms);\n}\n", "docstring": "extract the regular expression associated with this recursive production . fails if there are references to other productions in coeffs .", "partition": "test"}
{"idx": "2113", "code": "@Override public void startup() throws Exception {\n  Log.d(Mary.LOG,\"Register UnitSelection voices:\");\n  List<String> voiceNames=MaryProperties.getList(\"unitselection.voices.list\");\n  for (  String voiceName : voiceNames) {\n    long time=System.currentTimeMillis();\n    Voice unitSelVoice=new UnitSelectionVoice(voiceName,this);\n    Log.d(Mary.LOG,\"Voice \\'\" + unitSelVoice + \"\\'\");\n    Voice.registerVoice(unitSelVoice);\n    long newtime=System.currentTimeMillis() - time;\n    Log.i(Mary.LOG,\"Loading of voice \" + voiceName + \" took \"+ newtime+ \" milliseconds\");\n  }\n  Log.i(Mary.LOG,\"started.\");\n}\n", "docstring": "start up the waveform synthesizer . this must be called once before calling synthesize ( ) .", "partition": "test"}
{"idx": "2465", "code": "@Override public void channelClosed(ChannelHandlerContext channelHandlerContext,ChannelStateEvent channelStateEvent) throws Exception {\n  curr_conns.decrementAndGet();\n  channelGroup.remove(channelHandlerContext.getChannel());\n}\n", "docstring": "on close we manage some statistics , and remove this connection from the channel group .", "partition": "test"}
{"idx": "1838", "code": "@Override protected String extractKey(final String name){\n  final String key=unescape(name.substring(0,name.length() - 4));\n  return key.equals(\"\\\\0\") ? null : key;\n}\n", "docstring": "given a filename , the unescape method returns the key which originated it .", "partition": "test"}
{"idx": "2080", "code": "public void put(String name,String supported,String authScheme,String level,boolean isDefault){\n  SAMLv2AuthContext c=new SAMLv2AuthContext();\n  c.name=name;\n  c.supported=supported;\n  if (authScheme.length() != 0 && authScheme != null) {\n    int index=authScheme.lastIndexOf(\"=\");\n    c.value=authScheme.substring(index + 1);\n    c.key=authScheme.substring(0,index);\n  }\n else {\n    c.value=\"\";\n    c.key=\"\";\n  }\n  c.level=level;\n  c.isDefault=isDefault;\n  collections.put(name,c);\n}\n", "docstring": "adds samlv2authcontext to the collection .", "partition": "test"}
{"idx": "1176", "code": "public static X500Name x500PrincipalToX500Name(X500Principal principal){\n  return X500Name.getInstance(KseX500NameStyle.INSTANCE,principal.getEncoded());\n}\n", "docstring": "convert an x . 500 principal to an x . 500 name .", "partition": "test"}
{"idx": "4097", "code": "private void disableButtons(){\n  setFireEnabled(false);\n  setSkipEnabled(false);\n  setTwistEnabled(false);\n  setNextEnabled(false);\n  butDone.setEnabled(false);\n  setFlipArmsEnabled(false);\n  setFireModeEnabled(false);\n  setNextTargetEnabled(false);\n}\n", "docstring": "disables all buttons in the interface", "partition": "test"}
{"idx": "361", "code": "private static String findRelativePath(String filePath,String dirPath){\n  String relPath;\n  if (!dirPath.endsWith(File.separator)) {\n    dirPath=dirPath + File.separator;\n  }\n  if (filePath.startsWith(dirPath)) {\n    relPath=filePath.substring(dirPath.length());\n  }\n else {\n    relPath=filePath;\n  }\n  return relPath;\n}\n", "docstring": "determine the path to the file relative to the given directory path .", "partition": "test"}
{"idx": "3693", "code": "public static final String trunc(final String str,final int length){\n  if (str == null) {\n    return str;\n  }\n  if (str.length() <= length) {\n    return str;\n  }\n  return str.substring(0,length);\n}\n", "docstring": "truncate string to a given length .", "partition": "test"}
{"idx": "1754", "code": "private void insertProsodySettings(Utterance utterance,Element element){\n  Element prosody=(Element)DomUtils.getAncestor(element,MaryXML.PROSODY);\n  if (prosody == null) {\n    return;\n  }\n  Element voice=(Element)DomUtils.getAncestor(element,MaryXML.VOICE);\n  if (voice != null && DomUtils.isAncestor(prosody,voice)) {\n    return;\n  }\n  Element paragraph=(Element)DomUtils.getAncestor(element,MaryXML.PARAGRAPH);\n  if (paragraph != null && DomUtils.isAncestor(prosody,paragraph)) {\n    return;\n  }\n  for (  String att : PROSODY_ATTRIBUTES) {\n    String val=prosody.getAttribute(att);\n    if (!val.equals(\"\")) {\n      utterance.setString(att,val);\n    }\n  }\n}\n", "docstring": "for a given element , extract essential settings defined by the closest ancestor prosody element and save them into the utterance . note that prosody settings outside of a paragraph or voice element , are not to be stored here , since they are dealt with elsewhere or are not relevant .", "partition": "test"}
{"idx": "3703", "code": "private void kdRangeSearch(int left,int right,int axis,O query,ModifiableDoubleDBIDList res,DBIDArrayIter iter,double radius){\n  if (right - left <= leafsize) {\n    for (iter.seek(left); iter.getOffset() < right; iter.advance()) {\n      double dist=norm.distance(query,relation.get(iter));\n      countObjectAccess();\n      countDistanceComputation();\n      if (dist <= radius) {\n        res.add(dist,iter);\n      }\n    }\n    return;\n  }\n  final int middle=(left + right) >>> 1;\n  O split=relation.get(iter.seek(middle));\n  countObjectAccess();\n  final double delta=split.doubleValue(axis) - query.doubleValue(axis);\n  final boolean onleft=(delta >= 0);\n  final boolean onright=(delta <= 0);\n  final boolean close=(Math.abs(delta) <= radius);\n  final int next=(axis + 1) % dims;\n  if (close) {\n    double dist=norm.distance(query,split);\n    countDistanceComputation();\n    if (dist <= radius) {\n      assert (iter.getOffset() == middle);\n      res.add(dist,iter);\n    }\n  }\n  if (left < middle && (onleft || close)) {\n    kdRangeSearch(left,middle,next,query,res,iter,radius);\n  }\n  if (middle + 1 < right && (onright || close)) {\n    kdRangeSearch(middle + 1,right,next,query,res,iter,radius);\n  }\n}\n", "docstring": "perform a knn search on the kd - tree .", "partition": "test"}
{"idx": "2918", "code": "public void removeListeners(){\n  listeners.clear();\n}\n", "docstring": "remove all existing listeners .", "partition": "test"}
{"idx": "2947", "code": "protected String[][] toArray(){\n  int i;\n  int n;\n  int ii;\n  int nn;\n  int x;\n  int y;\n  String[][] result;\n  String[][] tmpResult;\n  int cols;\n  int rows;\n  boolean valueExists;\n  rows=getVisibleRowCount();\n  if (getShowAverage()) {\n    rows++;\n  }\n  cols=getVisibleColCount();\n  if (getShowStdDev()) {\n    cols=cols * 3;\n  }\n else {\n    cols=cols * 2;\n  }\n  result=new String[rows + 2][cols + 1];\n  result[0][0]=trimString(\"Dataset\",getRowNameWidth());\n  x=1;\n  for (ii=0; ii < getColCount(); ii++) {\n    i=getDisplayCol(ii);\n    if (getColHidden(i)) {\n      continue;\n    }\n    result[0][x]=trimString(removeFilterName(getColName(i)),getColNameWidth());\n    x++;\n    if (getShowStdDev()) {\n      result[0][x]=\"\";\n      x++;\n    }\n    result[0][x]=\"\";\n    x++;\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (!getRowHidden(i)) {\n      result[y][0]=trimString(removeFilterName(getRowName(i)),getRowNameWidth());\n      y++;\n    }\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (getRowHidden(i)) {\n      continue;\n    }\n    x=1;\n    for (nn=0; nn < getColCount(); nn++) {\n      n=getDisplayCol(nn);\n      if (getColHidden(n)) {\n        continue;\n      }\n      valueExists=(!Double.isNaN(getMean(n,i)));\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\n        result[y][x]=doubleToString(getMean(n,i),getMeanPrec());\n      }\n      x++;\n      if (getShowStdDev()) {\n        if (!valueExists) {\n          result[y][x]=\"\";\n        }\n else         if (Double.isInfinite(getStdDev(n,i))) {\n          result[y][x]=\"Inf\";\n        }\n else {\n          result[y][x]=doubleToString(getStdDev(n,i),getStdDevPrec());\n        }\n        x++;\n      }\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\nswitch (getSignificance(n,i)) {\ncase SIGNIFICANCE_TIE:\n          result[y][x]=TIE_STRING;\n        break;\ncase SIGNIFICANCE_WIN:\n      result[y][x]=WIN_STRING;\n    break;\ncase SIGNIFICANCE_LOSS:\n  result[y][x]=LOSS_STRING;\nbreak;\n}\n}\nx++;\n}\ny++;\n}\nif (getShowAverage()) {\ny=result.length - 2;\nx=0;\nresult[y][0]=\"Average\";\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=doubleToString(getAverage(i),getMeanPrec());\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=\"\";\nx++;\n}\n}\ny=result.length - 1;\nx=0;\nresult[y][0]=LEFT_PARENTHESES + WIN_STRING + \"/\"+ TIE_STRING+ \"/\"+ LOSS_STRING+ RIGHT_PARENTHESES;\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=\"\";\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=LEFT_PARENTHESES + getSignificanceCount(i,SIGNIFICANCE_WIN) + \"/\"+ getSignificanceCount(i,SIGNIFICANCE_TIE)+ \"/\"+ getSignificanceCount(i,SIGNIFICANCE_LOSS)+ RIGHT_PARENTHESES;\nx++;\n}\ntmpResult=new String[result.length][result[0].length - 1];\nx=0;\nfor (i=0; i < result[0].length; i++) {\nif (((i == 3) && (getShowStdDev())) || ((i == 2) && (!getShowStdDev()))) {\ncontinue;\n}\nfor (n=0; n < result.length; n++) {\ntmpResult[n][x]=result[n][i];\n}\nx++;\n}\nresult=tmpResult;\nreturn result;\n}\n", "docstring": "returns a 2 - dimensional array with the prepared data . includes the column and row names . hidden cols / rows are already excluded . < br > first row : column names < br > last row : wins / ties / losses < br > first col : row names < br >", "partition": "test"}
{"idx": "1922", "code": "public Operation copyTo(Extent target){\n  BlockTransformExtent extent=new BlockTransformExtent(original,transform,worldData.getBlockRegistry());\n  ForwardExtentCopy copy=new ForwardExtentCopy(extent,original.getRegion(),original.getOrigin(),target,original.getOrigin());\n  copy.setTransform(transform);\n  return copy;\n}\n", "docstring": "create an operation to copy from the original clipboard to the given extent .", "partition": "test"}
{"idx": "1460", "code": "void checkAfterUnmarshalled(){\n  assertEquals(shortVal.shortValue(),0x1122);\n  assertEquals(longVal,0x8877665544332211L);\n  assertNull(aArr);\n  assertNull(strVal);\n  assertEquals(doubleVal,123.456);\n}\n", "docstring": "checks correctness of the state after unmarshalling .", "partition": "test"}
{"idx": "2350", "code": "static void removeRedundantAffix(TranslatorUtils.IContain iContain,List<String> strList){\n  if (strList.size() <= 1) {\n    return;\n  }\n  int w=0;\n  for (  String str : strList) {\n    if (w == 0 || !iContain.containFunc(str,strList.get(w - 1))) {\n      strList.set(w,str);\n      w++;\n    }\n  }\n  strList=strList.subList(0,w);\n}\n", "docstring": "this function ensures that prefix / suffix sets aren \"'\" t redundant . for example , if we know \" ab \" is a possible prefix , then it doesn \"'\" t help at all to know that \" abc \" is also a possible prefix , so delete \" abc \" .", "partition": "test"}
{"idx": "831", "code": "public GlowTask(Plugin owner,Runnable task,boolean sync,long delay,long period){\n  super(task,null);\n  taskId=nextTaskId.getAndIncrement();\n  description=task.toString();\n  this.owner=owner;\n  this.delay=delay;\n  this.period=period;\n  counter=0;\n  this.sync=sync;\n}\n", "docstring": "creates a new task with the specified number of ticks between consecutive calls to execute ( ) .", "partition": "test"}
{"idx": "1000", "code": "public void addMessageObserver(final MessageObserver observer){\n  if (observer == null) {\n    throw new NullPointerException();\n  }\n else   if (messageObservers == null) {\n    initMessageObserverList();\n  }\n  messageObservers.add(observer);\n}\n", "docstring": "adds the specified message observer .", "partition": "test"}
{"idx": "2542", "code": "private static int componentSize(Component component,FormSpec formSpec,int cellSize,FormLayout.Measure minMeasure,FormLayout.Measure prefMeasure){\n  if (formSpec == null) {\n    return prefMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.MINIMUM) {\n    return minMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.PREFERRED) {\n    return prefMeasure.sizeOf(component);\n  }\n else {\n    return Math.min(cellSize,prefMeasure.sizeOf(component));\n  }\n}\n", "docstring": "computes and returns the pixel size of the given component using the given form specification , measures , and cell size .", "partition": "test"}
{"idx": "1356", "code": "public Config(SamlAuthorityConfiguration samlAuthorityConfig,TokenRestrictions tokenRestrictions,Collection<List<Certificate>> validCerts,long clockTolerance,Collection<IDPConfig> inExternalIdps){\n  Validate.notNull(samlAuthorityConfig);\n  Validate.notNull(tokenRestrictions);\n  Validate.notEmpty(validCerts);\n  List<Certificate> authorityCert=samlAuthorityConfig.getSigningCertificateChain();\n  boolean authorityCertInValidCerts=false;\n  for (  List<Certificate> currentChain : validCerts) {\n    Validate.notEmpty(currentChain);\n    Validate.noNullElements(currentChain);\n    if (!authorityCertInValidCerts && currentChain.equals(authorityCert)) {\n      authorityCertInValidCerts=true;\n    }\n  }\n  Validate.isTrue(authorityCertInValidCerts,\"signing certificate chain is not in valid chains.\");\n  Validate.isTrue(clockTolerance >= 0);\n  this.samlAuthorityConfig=samlAuthorityConfig;\n  this.validCerts=validCerts;\n  this.clockTolerance=clockTolerance;\n  this.tokenRestrictions=tokenRestrictions;\n  HashMap<String,IDPConfig> idpsSet=new HashMap<String,IDPConfig>();\n  if (inExternalIdps != null) {\n    for (    IDPConfig conf : inExternalIdps) {\n      if (conf != null) {\n        idpsSet.put(conf.getEntityID(),conf);\n      }\n    }\n  }\n  this.externalIdps=Collections.unmodifiableMap(idpsSet);\n}\n", "docstring": "creates a new configuration", "partition": "test"}
{"idx": "1548", "code": "void assertThreadsStayAlive(long millis,Thread... threads){\n  try {\n    delay(millis);\n    for (    Thread thread : threads)     assertTrue(thread.isAlive());\n  }\n catch (  InterruptedException fail) {\n    threadFail(\"Unexpected InterruptedException\");\n  }\n}\n", "docstring": "checks that the threads do not terminate within the given millisecond delay .", "partition": "test"}
{"idx": "1523", "code": "public StatArchiveReader(String archiveName) throws IOException {\n  this(new File[]{new File(archiveName)},null,false);\n}\n", "docstring": "creates a statarchivereader that will read the named archive file .", "partition": "test"}
{"idx": "2837", "code": "public void addConnection(Connection connection){\n  if (connection == null)   throw new IllegalArgumentException(\"connection cannot be null.\");\nsynchronized (connectionsLock) {\n    Connection[] newConnections=new Connection[connections.length + 1];\n    newConnections[0]=connection;\n    System.arraycopy(connections,0,newConnections,1,connections.length);\n    connections=newConnections;\n  }\n  connection.addListener(invokeListener);\n  if (TRACE)   trace(\"kryonet\",\"Added connection to ObjectSpace: \" + connection);\n}\n", "docstring": "allows the remote end of the specified connection to access objects registered in this objectspace .", "partition": "test"}
{"idx": "3960", "code": "protected void newLine(PrintWriter file,String string,boolean isManifest){\n  String[] lines=string.split(NEW_LINE);\n  for (  String line : lines) {\n    String[] words=line.split(SPACE);\n    StringBuffer sb=new StringBuffer();\n    for (    String word : words) {\n      if (checkStringLength(sb.toString() + word,isManifest)) {\n        sb.append(word + SPACE);\n      }\n else {\n        sb.setLength(sb.length() - 1);\n        addLine(file,sb.toString());\n        sb=new StringBuffer(word + SPACE);\n      }\n    }\n    if (sb.length() > 0) {\n      sb.setLength(sb.length() - 1);\n    }\n    addLine(file,sb.toString());\n  }\n}\n", "docstring": "writes a string to a file . checks for string length , and will automatically wrap lines .", "partition": "test"}
{"idx": "2501", "code": "final public void println(float v){\n  String s=String.valueOf(v);\n  write(s,0,s.length());\n  println();\n}\n", "docstring": "prints a float followed by a newline .", "partition": "test"}
{"idx": "3431", "code": "protected boolean needToEscapeXMLSpecialCharacters(String hostEntityID,String remoteEntityID,String realm){\n  return true;\n}\n", "docstring": "decides whether it needs to escape xml special characters for attribute values or not .", "partition": "test"}
{"idx": "3579", "code": "protected String chooseRandomEnemys(){\n  final List<String> enemyList=new LinkedList<String>(enemyForces.keySet());\n  final int enemySize=enemyList.size();\n  final int position=Rand.rand(enemySize);\n  return enemyList.get(position);\n}\n", "docstring": "function for choosing random enemy from map", "partition": "test"}
{"idx": "4226", "code": "protected boolean isNumeric(String text){\n  text=text.trim();\n  int tlen=text.length();\n  for (int i=0; i < tlen; i++) {\n    if (Character.isDigit(text.charAt(i)) == false) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "utility method for subclasses to determine if an entire string is digits", "partition": "test"}
{"idx": "2242", "code": "public void remove(final CreatureRespawnPoint point){\n  respawnPoints.remove(point);\n}\n", "docstring": "remove a creature respawn point from the zone .", "partition": "test"}
{"idx": "2300", "code": "@Override public void stop(Runnable arg0){\n  stop();\n  arg0.run();\n}\n", "docstring": "smart lifecycle stop implementation . closes the db connection pool .", "partition": "test"}
{"idx": "593", "code": "private HashMap addAttr(SvcReg reg,EntryClass eclass,int fldidx,Object value){\n  HashMap[] attrMaps=serviceByAttr.get(eclass);\n  if (attrMaps == null) {\n    attrMaps=new HashMap[eclass.getNumFields()];\n    serviceByAttr.put(eclass,attrMaps);\n  }\n  HashMap map=attrMaps[fldidx];\n  if (map == null) {\n    map=new HashMap(11);\n    attrMaps[fldidx]=map;\n  }\n  ArrayList regs=(ArrayList)map.get(value);\n  if (regs == null) {\n    regs=new ArrayList(3);\n    map.put(value,regs);\n  }\n else   if (regs.contains(reg))   return map;\n  regs.add(reg);\n  return map;\n}\n", "docstring": "put the service under the given attribute value for the given defining class and field , if it isn \"'\" t already there . return the hashmap for the given class and field .", "partition": "test"}
{"idx": "2814", "code": "public void addWritten(byte[] value){\n  writeSetLock.lock();\n  writeSet.add(new TimestampValuePair(ets,value));\n  writeSetLock.unlock();\n}\n", "docstring": "add a value that shall be written to the writeset", "partition": "test"}
{"idx": "4087", "code": "@Override public void flip(X11ComponentPeer peer,Component target,VolatileImage xBackBuffer,int x1,int y1,int x2,int y2,BufferCapabilities.FlipContents flipAction){\n  if (flipAction == BufferCapabilities.FlipContents.COPIED) {\n    SurfaceManager vsm=SurfaceManager.getManager(xBackBuffer);\n    SurfaceData sd=vsm.getPrimarySurfaceData();\n    if (sd instanceof GLXVSyncOffScreenSurfaceData) {\n      GLXVSyncOffScreenSurfaceData vsd=(GLXVSyncOffScreenSurfaceData)sd;\n      SurfaceData bbsd=vsd.getFlipSurface();\n      Graphics2D bbg=new SunGraphics2D(bbsd,Color.black,Color.white,null);\n      try {\n        bbg.drawImage(xBackBuffer,0,0,null);\n      }\n  finally {\n        bbg.dispose();\n      }\n    }\n else {\n      Graphics g=peer.getGraphics();\n      try {\n        g.drawImage(xBackBuffer,x1,y1,x2,y2,x1,y1,x2,y2,null);\n      }\n  finally {\n        g.dispose();\n      }\n      return;\n    }\n  }\n else   if (flipAction == BufferCapabilities.FlipContents.PRIOR) {\n    return;\n  }\n  OGLSurfaceData.swapBuffers(peer.getContentWindow());\n  if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {\n    Graphics g=xBackBuffer.getGraphics();\n    try {\n      g.setColor(target.getBackground());\n      g.fillRect(0,0,xBackBuffer.getWidth(),xBackBuffer.getHeight());\n    }\n  finally {\n      g.dispose();\n    }\n  }\n}\n", "docstring": "performs the native glx flip operation for the given target component .", "partition": "test"}
{"idx": "2761", "code": "public static LeftRegularBipartiteGraphSegment buildRandomLeftRegularBipartiteGraph(int leftSize,int rightSize,int leftDegree,Random random){\n  LeftRegularBipartiteGraphSegment leftRegularBipartiteGraphSegment=new LeftRegularBipartiteGraphSegment(leftSize / 2,leftDegree,rightSize / 2,leftSize / 2,2.0,Integer.MAX_VALUE,new IdentityEdgeTypeMask(),new NullStatsReceiver());\n  LongSet addedIds=new LongOpenHashSet(leftDegree);\n  for (int i=0; i < leftSize; i++) {\n    addedIds.clear();\n    for (int j=0; j < leftDegree; j++) {\n      long idToAdd;\n      do {\n        idToAdd=random.nextInt(rightSize);\n      }\n while (addedIds.contains(idToAdd));\n      addedIds.add(idToAdd);\n      leftRegularBipartiteGraphSegment.addEdge(i,idToAdd,(byte)0);\n    }\n  }\n  return leftRegularBipartiteGraphSegment;\n}\n", "docstring": "build a random left - regular bipartite graph of given left and right sizes .", "partition": "test"}
{"idx": "4267", "code": "@Override public synchronized void removeDataSourceListener(DataSourceListener dsl){\n  m_dataSourceListeners.remove(dsl);\n}\n", "docstring": "remove a datasource listener", "partition": "test"}
{"idx": "4047", "code": "public static byte[] decode(String s) throws java.io.IOException {\n  return decode(s,NO_OPTIONS);\n}\n", "docstring": "decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .", "partition": "test"}
{"idx": "3985", "code": "public void removeDTEDDirectoryHandler(DTEDDirectoryHandler handler){\n  directories.remove(handler);\n}\n", "docstring": "remove a dted directoryhandler from the list used for the dtedframecache .", "partition": "test"}
{"idx": "1836", "code": "public void removeGroupListener(final GroupListener listener){\n  groupListeners.remove(listener);\n}\n", "docstring": "remove a group listener .", "partition": "test"}
{"idx": "222", "code": "public boolean updateStatsAndReturnIfAllowed(){\n  long now=SystemClock.elapsedRealtime();\n  long deltaMs=now - mLastRequestTimestamp;\n  if (deltaMs < mDelayMs)   return false;\n  mLastRequestTimestamp=now;\n  if (deltaMs < 2 * mDelayMs) {\n    mDelayMs=Math.min(MAX_DELAY,mDelayMs * 2);\n  }\n else {\n    mDelayMs=MIN_DELAY;\n  }\n  return true;\n}\n", "docstring": "updates the prediction stats and return whether prediction is allowed . the policy is : 1 . if the client does not wait more than mdelayms , decline the request . 2 . if the client waits for more than mdelayms but less than 2 * mdelayms , accept the request and double mdelayms . 3 . if the client waits for more than 2 * mdelayms , accept the request and reset mdelayms . and : 100ms < = mdelayms < = 10s . this way , if an application sends a burst of requests , it is quickly seriously throttled . if it stops being this way , back to normal .", "partition": "test"}
{"idx": "2970", "code": "public int threeWayDistance(Key k1,Key k2){\n  byte[] h0=hash;\n  byte[] h1=k1.hash;\n  byte[] h2=k2.hash;\n  int mmi=mismatch(h1,h2);\n  if (mmi == -1)   return 0;\n  int h=Byte.toUnsignedInt(h0[mmi]);\n  int a=Byte.toUnsignedInt(h1[mmi]);\n  int b=Byte.toUnsignedInt(h2[mmi]);\n  return Integer.compareUnsigned(a ^ h,b ^ h);\n}\n", "docstring": "compares the distance of two keys relative to this one using the xor metric", "partition": "test"}
{"idx": "157", "code": "public int toInt(Element el,String attributeName){\n  return Caster.toIntValue(el.getAttribute(attributeName),Integer.MIN_VALUE);\n}\n", "docstring": "reads a xml element attribute ans cast it to a int value", "partition": "test"}
{"idx": "4006", "code": "protected static void writeRowCountDefinitions(TableCreator creator,ByteBuffer buffer){\n  writeRowCountDefinitions(creator,buffer,creator.getIndexCount());\n}\n", "docstring": "writes the index row count definitions into a table definition buffer .", "partition": "test"}
{"idx": "3510", "code": "private void baselineLayout(int origin,int size){\n  int ascent;\n  int descent;\n  if (baselineAnchoredToTop) {\n    ascent=prefAscent;\n    descent=size - ascent;\n  }\n else {\n    ascent=size - prefDescent;\n    descent=prefDescent;\n  }\n  for (  Spring spring : springs) {\n    Alignment alignment=spring.getAlignment();\n    if (alignment == null || alignment == Alignment.BASELINE) {\n      int baseline=spring.getBaseline();\n      if (baseline >= 0) {\n        int springMax=spring.getMaximumSize(VERTICAL);\n        int springPref=spring.getPreferredSize(VERTICAL);\n        int height=springPref;\n        int y;\nswitch (spring.getBaselineResizeBehavior()) {\ncase CONSTANT_ASCENT:\n          y=origin + ascent - baseline;\n        height=Math.min(descent,springMax - baseline) + baseline;\n      break;\ncase CONSTANT_DESCENT:\n    height=Math.min(ascent,springMax - springPref + baseline) + (springPref - baseline);\n  y=origin + ascent + (springPref - baseline) - height;\nbreak;\ndefault :\ny=origin + ascent - baseline;\nbreak;\n}\nspring.setSize(VERTICAL,y,height);\n}\n else {\nsetChildSize(spring,VERTICAL,origin,size);\n}\n}\n else {\nsetChildSize(spring,VERTICAL,origin,size);\n}\n}\n}\n", "docstring": "lays out springs that have a baseline along the baseline . all others are centered .", "partition": "test"}
{"idx": "502", "code": "public void makeTreeOfWritables(Iterable<Pair<String,Integer>> flatData){\n  Text key=new Text();\n  for (  Pair<String,Integer> pair : flatData) {\n    key.set(pair.key);\n    ArrayList<IntWritable> valList;\n    if (!mockInput.containsKey(key)) {\n      valList=new ArrayList<>();\n      mockInput.put(key,valList);\n      key=new Text();\n    }\n else     valList=(ArrayList<IntWritable>)mockInput.get(key);\n    valList.add(new IntWritable(pair.value()));\n  }\n}\n", "docstring": "generate one - key - multiple - values tree from array of key - value pairs , and wrap its into writable objects . the result is placed into mock input .", "partition": "test"}
{"idx": "4074", "code": "public void addLine(int startLine,String sourceFile,int repeatCount,int outputLine,int outputIncrement){\n  _lines.add(new Line(startLine,sourceFile,repeatCount,outputLine,outputIncrement));\n}\n", "docstring": "adds a line from the smap", "partition": "test"}
{"idx": "3917", "code": "private AMSetupDSConfig(){\n  Map map=ServicesDefaultValues.getDefaultValues();\n  dsManager=(String)map.get(SetupConstants.CONFIG_VAR_DS_MGR_DN);\n  suffix=(String)map.get(SetupConstants.CONFIG_VAR_ROOT_SUFFIX);\n  dsHostName=(String)map.get(SetupConstants.CONFIG_VAR_DIRECTORY_SERVER_HOST);\n  dsPort=(String)map.get(SetupConstants.CONFIG_VAR_DIRECTORY_SERVER_PORT);\n  dsAdminPwd=(String)map.get(SetupConstants.CONFIG_VAR_DS_MGR_PWD);\n  basedir=(String)map.get(SetupConstants.CONFIG_VAR_BASE_DIR);\n  deployuri=(String)map.get(SetupConstants.CONFIG_VAR_SERVER_URI);\n}\n", "docstring": "constructs a new instance .", "partition": "test"}
{"idx": "4259", "code": "public boolean addTagId(final Long tagId){\n  if (tagId != null && tagId > 0) {\n    return tagIds.add(tagId);\n  }\n  return false;\n}\n", "docstring": "adds the given tag id to this request .", "partition": "test"}
{"idx": "4250", "code": "public CodeSourceFacade(final CodeSource codeSource){\n  this.location=codeSource.getLocation();\n  final Certificate[] certificates=codeSource.getCertificates();\n  if (null == certificates || 0 == certificates.length) {\n    LOGGER.warning(String.format(\"no certificate found for %s\",codeSource));\n    this.firstCertificate=null;\n    return;\n  }\n  this.firstCertificate=(X509Certificate)certificates[0];\n}\n", "docstring": "creates a new code source .", "partition": "test"}
{"idx": "1126", "code": "public Node selectFirst(String query){\n  List<Node> selectedNodes=select(query);\n  if (selectedNodes.isEmpty()) {\n    return null;\n  }\n  return selectedNodes.get(0);\n}\n", "docstring": "selects nodes using css3 selector query and returns the very first one .", "partition": "test"}
{"idx": "259", "code": "public StateInteractive extent_to_whole_connections(){\n  Set<BrdItem> selected_items=new TreeSet<BrdItem>();\n  for (  BrdItem curr_item : items_list) {\n    if (curr_item instanceof BrdConnectable) {\n      selected_items.addAll(curr_item.get_connection_items());\n    }\n  }\n  if (selected_items.isEmpty()) {\n    return return_state;\n  }\n  items_list=selected_items;\n  actlog_start_scope(LogfileScope.EXTEND_TO_WHOLE_CONNECTIONS);\n  filter();\n  i_brd.repaint();\n  return this;\n}\n", "docstring": "select also all items belonging to any connection of the current selected items .", "partition": "test"}
{"idx": "1811", "code": "private BuddyPanelController(){\n  buddyPanel=new JPanel();\n  buddyPanel.setLayout(new SBoxLayout(SBoxLayout.VERTICAL));\n  model=new BuddyListModel();\n  JList<Buddy> list=new BuddyPanel(model);\n  buddyPanel.add(list,SLayout.EXPAND_X);\n}\n", "docstring": "creates a new buddypanelcontroller .", "partition": "test"}
{"idx": "1607", "code": "public static void unregisterBaggageHandler(BaggageHandler handler){\n  handlers.remove(handler);\n}\n", "docstring": "remove an existing baggage handler that was previously registered . method does nothing if the handler isn \"'\" t currently registered .", "partition": "test"}
{"idx": "1257", "code": "public String toString(){\n  StringBuffer result=new StringBuffer(ipAddress.toString());\n  result.append(\"/\");\n  result.append(extendedNetworkPrefix);\n  return result.toString();\n}\n", "docstring": "convert the ip range into a string representation .", "partition": "test"}
{"idx": "2287", "code": "public static Corleone context(String jobContext){\n  if (jobContext == null || jobContext.equals(\"\")) {\n    throw new IllegalArgumentException(\"Job context must not be null or empty.\");\n  }\n  contexts.clear();\n  contexts.add(jobContext);\n  return getInstance();\n}\n", "docstring": "provides a corleone instance to work on the given context .", "partition": "test"}
{"idx": "1909", "code": "public String format(double val){\n  DecimalFormat df=getDoubleFormat();\n  if (df != null) {\n    return df.format(val);\n  }\n  return Double.toString(val);\n}\n", "docstring": "formats the given double values .", "partition": "test"}
{"idx": "664", "code": "public DagIterator(Graph pattern){\n  for (  Edge edge : pattern.getEdges()) {\n    if (Edges.isDirectedEdge(edge) || Edges.isUndirectedEdge(edge)) {\n      continue;\n    }\n    throw new IllegalArgumentException(\"The graph may consist only of \" + \"directed and undirected edges: \" + edge);\n  }\n  decoratedGraphs.add(new DecoratedGraph(pattern));\n}\n", "docstring": "the given pattern must be a pattern . if it does not consist entirely of directed and undirected edges and if it is not acyclic , it is rejected .", "partition": "test"}
{"idx": "3746", "code": "public void touch(){\n  candiesStore=null;\n}\n", "docstring": "cleans the candies store so that it will be read from file next time .", "partition": "test"}
{"idx": "3037", "code": "@NotNull public static String sha1(@NotNull File keyStoreFile) throws Exception {\n  return sha1(keyStoreFile,null,null);\n}\n", "docstring": "get the sha1 hash of the first signing certificate inside a keystore , encoded as base16 ( each byte separated by \"'\" : \"'\" ) .", "partition": "test"}
{"idx": "11", "code": "public static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}\n", "docstring": "converts to object array .", "partition": "test"}
{"idx": "3504", "code": "private ValueGeometry(byte[] bytes,Geometry geometry){\n  this.bytes=bytes;\n  this.geometry=geometry;\n  this.hashCode=Arrays.hashCode(bytes);\n}\n", "docstring": "create a new geometry objects .", "partition": "test"}
{"idx": "2558", "code": "public static IFitsHeader lookup(String key){\n  int keyLength=key.length();\n  if (keyLength > 0 && Character.isDigit(key.charAt(keyLength - 1))) {\n    StringBuilder builder=new StringBuilder();\n    for (int index=0; index < keyLength; index++) {\n      char character=key.charAt(index);\n      if (Character.isDigit(character)) {\n        if (builder.charAt(builder.length() - 1) != 'n') {\n          builder.append('n');\n        }\n      }\n else {\n        builder.append(character);\n      }\n    }\n    return STANDARD_KEYS.get(builder.toString());\n  }\n  return STANDARD_KEYS.get(key);\n}\n", "docstring": "lookup a string key in the standard key sets .", "partition": "test"}
{"idx": "2688", "code": "protected static boolean eq(Object o1,Object o2){\n  return o1 == null ? o2 == null : o1.equals(o2);\n}\n", "docstring": "helper method to check for equality between two object , including null checks .", "partition": "test"}
{"idx": "2934", "code": "private void sendResponse(Document doc,MessageFactory messageFactory,String contentType,HttpServletResponse res) throws IOException, SOAPException {\n  SOAPMessage reply=messageFactory.createMessage();\n  SOAPHeader header=reply.getSOAPHeader();\n  header.detachNode();\n  SOAPBody replyBody=reply.getSOAPBody();\n  res.setHeader(\"Content-Type\",contentType);\n  replyBody.addDocument(doc);\n  reply.saveChanges();\n  OutputStream os=res.getOutputStream();\n  reply.writeTo(os);\n  os.flush();\n}\n", "docstring": "send a response back to the client . this could be either a soap fault or a correct dsml response .", "partition": "test"}
{"idx": "3476", "code": "protected synchronized void readDontVerify() throws IOException, FileEncryptionException {\n  if (backingRandomAccessFile.length() < headerSize()) {\n    throw new FileEncryptionException(\"Invalid file header\");\n  }\n  long oldpos=backingRandomAccessFile.getFilePointer();\n  backingRandomAccessFile.seek(0);\n  byte[] header_data=new byte[headerSize() - FileHeader.AUTH_TAG_SIZE];\n  backingRandomAccessFile.read(header_data);\n  backingRandomAccessFile.seek(oldpos);\n  DataInputStream istream=new DataInputStream(new ByteArrayInputStream(header_data));\n  byte[] tmpmagic=new byte[PANBOX_FILE_MAGIC.length];\n  istream.read(tmpmagic);\n  if (!Arrays.equals(tmpmagic,PANBOX_FILE_MAGIC)) {\n    throw new FileEncryptionException(\"Invalid magic number in file header\");\n  }\n  byte[] tmpversion=new byte[PANBOX_FILE_VERSION.length];\n  istream.read(tmpversion);\n  if (!Arrays.equals(tmpversion,PANBOX_FILE_VERSION)) {\n    throw new FileEncryptionException(\"Invalid version in file header. Expected version is \" + PANBOX_FILE_VERSION.toString());\n  }\n  this.shareKeyVersion=istream.readInt();\n  istream.close();\n}\n", "docstring": "reads magic + share key version without verification", "partition": "test"}
{"idx": "3677", "code": "public DistributedLogMultiStreamWriter build(){\n  Preconditions.checkArgument((null != _streams && !_streams.isEmpty()),\"No streams provided\");\n  Preconditions.checkNotNull(_client,\"No distributedlog client provided\");\n  Preconditions.checkNotNull(_codec,\"No compression codec provided\");\n  Preconditions.checkArgument(_firstSpeculativeTimeoutMs > 0 && _firstSpeculativeTimeoutMs <= _maxSpeculativeTimeoutMs && _speculativeBackoffMultiplier > 0 && _maxSpeculativeTimeoutMs < _requestTimeoutMs,\"Invalid speculative timeout settings\");\n  return new DistributedLogMultiStreamWriter(_streams,_client,Math.min(_bufferSize,MAX_LOGRECORDSET_SIZE),_flushIntervalMicros,_requestTimeoutMs,_firstSpeculativeTimeoutMs,_maxSpeculativeTimeoutMs,_speculativeBackoffMultiplier,_codec,_ticker,_executorService);\n}\n", "docstring": "build the multi stream writer .", "partition": "test"}
{"idx": "4238", "code": "private void checkAlterPeriodConverters() throws SecurityException {\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n  }\n}\n", "docstring": "checks whether the user has permission \"'\" convertermanager . alterperiodconverters \"'\" .", "partition": "test"}
{"idx": "474", "code": "public void addPropertyChangeListener(String propertyName,PropertyChangeListener listener){\n  propertyChangeSupport.addPropertyChangeListener(propertyName,listener);\n}\n", "docstring": "adds the property change listener .", "partition": "test"}
{"idx": "2054", "code": "public void remove(DirectedEdge de){\n  outEdges.remove(de);\n}\n", "docstring": "drops a member of this directededgestar .", "partition": "test"}
{"idx": "3041", "code": "public void closeWindow(){\n  WindowEvent ev=new WindowEvent(frame,WindowEvent.WINDOW_CLOSING);\n  frame.dispatchEvent(ev);\n}\n", "docstring": "closes the window ( and opendial ) .", "partition": "test"}
{"idx": "904", "code": "public void writeAll(ResultSet rs,boolean includeColumnNames,boolean trim) throws SQLException, IOException {\n  if (includeColumnNames) {\n    writeColumnNames(rs);\n  }\n  while (rs.next()) {\n    writeNext(resultService.getColumnValues(rs,trim));\n  }\n}\n", "docstring": "writes the entire resultset to a csv file . the caller is responsible for closing the resultset .", "partition": "test"}
{"idx": "4210", "code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase EipPackage.ROUTE__OWNED_ENDPOINTS:\n    return ownedEndpoints != null && !ownedEndpoints.isEmpty();\ncase EipPackage.ROUTE__OWNED_CHANNELS:\n  return ownedChannels != null && !ownedChannels.isEmpty();\ncase EipPackage.ROUTE__NAME:\nreturn NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);\ncase EipPackage.ROUTE__EXCHANGE_TYPE:\nreturn exchangeType != EXCHANGE_TYPE_EDEFAULT;\n}\nreturn super.eIsSet(featureID);\n}\n", "docstring": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "360", "code": "public static boolean isAutoNew(Properties ctx,int WindowNo){\n  if (ctx == null)   throw new IllegalArgumentException(\"Require Context\");\n  String s=getContext(ctx,WindowNo,\"AutoNew\",false);\n  if (s != null) {\n    if (s.equals(\"Y\"))     return true;\n else     return false;\n  }\n  return isAutoNew(ctx);\n}\n", "docstring": "is window auto new record ( if not set use default )", "partition": "test"}
{"idx": "1229", "code": "public void clear(FacesContext facesContext,Map<String,Object> viewMap){\n  if (LOGGER.isLoggable(Level.FINEST)) {\n    LOGGER.log(Level.FINEST,\"Clearing @ViewScoped CDI beans for given view map: {0}\");\n  }\n  Map<String,ViewScopeContextObject> contextMap=getContextMap(facesContext,viewMap);\n  if (contextMap != null) {\n    destroyBeans(viewMap,contextMap);\n  }\n}\n", "docstring": "clear the given view map .", "partition": "test"}
{"idx": "3646", "code": "public void fireNeuronMoved(final Neuron moved){\n  for (  NeuronListener listener : neuronListeners) {\n    listener.neuronMoved(new NetworkEvent<Neuron>(this,moved));\n  }\n}\n", "docstring": "fire a network changed event to all registered model listeners .", "partition": "test"}
{"idx": "3553", "code": "public boolean isDefined(Object attrName){\n  return table.containsKey(attrName);\n}\n", "docstring": "tells whether a given attribute is defined .", "partition": "test"}
{"idx": "181", "code": "private Set<Integer> findValues(String string){\n  Set<Integer> results=new TreeSet<Integer>();\n  for (  String str : string.split(\",\")) {\n    if (!str.equals(\"\")) {\n      results.add(findValue(str));\n    }\n  }\n  return results;\n}\n", "docstring": "search for a string in the enumeration .", "partition": "test"}
{"idx": "2362", "code": "public ConfigureCoerceiveParsingDialog_NB(CoerciveParsing coerciveParsing){\n  this.coerciveParsing=coerciveParsing;\n  initComponents();\n  final IterateModel numberOfTagsIterator=coerciveParsing.getNumberOfTagsIterator();\n  configureIterateModel_NB2.setStartAt(String.valueOf(numberOfTagsIterator.getStartAt()));\n  configureIterateModel_NB2.setStopAt(String.valueOf(numberOfTagsIterator.getStopAt()));\n  configureIterateModel_NB2.setIncrement(String.valueOf(numberOfTagsIterator.getIncrement()));\n  configureIterateModel_NB2.setIterateStrategie(numberOfTagsIterator.getIterateStrategie());\n  List<String> tagNames=Arrays.asList(coerciveParsing.getTagNames());\n  configureStringList_NB1.setStringList(tagNames);\n}\n", "docstring": "creates new form configurecoerceiveparsingdialog_nb", "partition": "test"}
{"idx": "328", "code": "public synchronized String generateCallIdentifier(String address){\n  String date=Long.toString(System.currentTimeMillis() + callIDCounter++ + rand.nextLong());\n  byte cid[]=digester.digest(date.getBytes());\n  String cidString=Utils.toHexString(cid);\n  return cidString + \"@\" + address;\n}\n", "docstring": "generate a call identifier . this is useful when we want to generate a call identifier in advance of generating a message .", "partition": "test"}
{"idx": "2537", "code": "public static float roundDecimal(float value){\n  return roundDecimal(value,Math.log10(INT_PRECISION));\n}\n", "docstring": "static method to round a float value to the number of decimal places defined by decimal_places .", "partition": "test"}
{"idx": "897", "code": "public StringBuilder encodeBody(StringBuilder buffer){\n  return buffer.append(contentEncoding);\n}\n", "docstring": "canonical encoding of body of the header .", "partition": "test"}
{"idx": "2570", "code": "public void obtain(long timeout_ms) throws IOException, InterruptedException, TimeoutException {\n  Long quit_time=System.currentTimeMillis() + timeout_ms;\n  if (fileLock != null && fileLock.isValid()) {\n    return;\n  }\n  do {\n    try {\n      fileLock=fileToLock.tryLock();\n      return;\n    }\n catch (    OverlappingFileLockException e) {\n      Thread.sleep(1000);\n    }\n  }\n while (System.currentTimeMillis() < quit_time);\n  throw new TimeoutException();\n}\n", "docstring": "locks the file , with a timeout ( non - blocking ) .", "partition": "test"}
{"idx": "3744", "code": "public ProjectedStream addView(String namespace,String name,List<Expression> parameters){\n  views.add(View.create(namespace,name,parameters));\n  return this;\n}\n", "docstring": "adds a parameterized view to the stream .", "partition": "test"}
{"idx": "3422", "code": "public static IntStream concat(IntStream a,IntStream b){\n  Objects.requireNonNull(a);\n  Objects.requireNonNull(b);\n  Spliterator.OfInt split=new Streams.ConcatSpliterator.OfInt(a.spliterator(),b.spliterator());\n  IntStream stream=StreamSupport.intStream(split,a.isParallel() || b.isParallel());\n  return stream.onClose(Streams.composedClose(a,b));\n}\n", "docstring": "creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream . the resulting stream is ordered if both of the input streams are ordered , and parallel if either of the input streams is parallel . when the resulting stream is closed , the close handlers for both input streams are invoked .", "partition": "test"}
{"idx": "3930", "code": "private void markReserved(int ropReg,int category){\n  reservedRopRegs.set(ropReg,ropReg + category,true);\n}\n", "docstring": "marks a range of rop registers as \" reserved for a local variable . \"", "partition": "test"}
{"idx": "1432", "code": "public void deepFill(MaryNode specTree){\n  tree=specTree;\n  numberOfLeaves=0;\n  sortNode(0,tree);\n}\n", "docstring": "fill a tree which specifies a feature hierarchy but no corresponding units .", "partition": "test"}
{"idx": "1676", "code": "public static Element createElement(Document doc,String tag,String nsURI,String prefix){\n  String qName=(prefix == null || prefix.length() == 0) ? tag : prefix + \":\" + tag;\n  return doc.createElementNS(nsURI,qName);\n}\n", "docstring": "creates an element in the specified namespace , with the specified tag and namespace prefix .", "partition": "test"}
{"idx": "4172", "code": "public boolean greaterThan(FXGVersion version){\n  return (compareTo(version) > 0);\n}\n", "docstring": "compares whether this fxgversion \"'\" s value is greater than the value of the version parameter .", "partition": "test"}
{"idx": "87", "code": "@Override public void onAdded(final RPObject object){\n  if (isUser(object)) {\n    if (object.has(\"adminlevel\")) {\n      adminlevel=object.getInt(\"adminlevel\");\n    }\n  }\n}\n", "docstring": "an object was added .", "partition": "test"}
{"idx": "2459", "code": "void putChannel(final StoredClientChannel channel){\n  putChannel(channel,true);\n}\n", "docstring": "adds the given channel to this set of stored states , broadcasting the contract and refund transactions when the channel expires and notifies the wallet of an update to this wallet extension", "partition": "test"}
{"idx": "516", "code": "public static double computeMAD(double[] x,double median){\n  for (int i=0; i < x.length; i++) {\n    x[i]=Math.abs(x[i] - median);\n  }\n  double mad=QuickSelect.median(x);\n  if (!(mad > 0.)) {\n    double min=Double.POSITIVE_INFINITY;\n    for (    double xi : x) {\n      if (xi > 0. && xi < min) {\n        min=xi;\n      }\n    }\n    if (min < Double.POSITIVE_INFINITY) {\n      mad=min;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  if (mad == Double.POSITIVE_INFINITY) {\n    double max=0.;\n    for (    double xi : x) {\n      if (xi < Double.POSITIVE_INFINITY && xi > max) {\n        max=xi;\n      }\n    }\n    if (max < Double.POSITIVE_INFINITY) {\n      mad=max;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  return mad;\n}\n", "docstring": "compute the median absolute deviation from median .", "partition": "test"}
{"idx": "499", "code": "public void load(GeneralSubtrees generalSubtrees){\n  List<GeneralSubtree> generalSubtreesList=generalSubtrees.getGeneralSubtrees();\n  Collections.sort(generalSubtreesList,new GeneralSubtreeBaseComparator());\n  data=new Object[generalSubtreesList.size()][3];\n  int i=0;\n  for (  GeneralSubtree generalSubtree : generalSubtreesList) {\n    data[i][0]=generalSubtree;\n    data[i][1]=generalSubtree;\n    data[i][2]=generalSubtree;\n    i++;\n  }\n  fireTableDataChanged();\n}\n", "docstring": "load the generalsubtreestablemodel with general subtrees .", "partition": "test"}
{"idx": "1587", "code": "public DefaultActionGroup(@NotNull AnAction... actions){\n  this(Arrays.asList(actions));\n}\n", "docstring": "creates an action group containing the specified actions .", "partition": "test"}
{"idx": "1633", "code": "public GenericSipMsrpSession createMsrpSession(ContactId contact,String featureTag,String[] acceptTypes,String[] acceptWrappedTypes){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Initiate a MSRP session with contact \" + contact);\n  }\n  return new OriginatingSipMsrpSession(this,contact,featureTag,mRcsSettings,System.currentTimeMillis(),mContactManager,acceptTypes,acceptWrappedTypes);\n}\n", "docstring": "initiate a msrp session", "partition": "test"}
{"idx": "2568", "code": "public User toEntity(UserDTO dto){\n  return toEntity(dto,1);\n}\n", "docstring": "converts the passed dto to a user . convenient for query by example .", "partition": "test"}
{"idx": "1714", "code": "public static String tmpJournal(){\n  final File file=Code.wrapThrow(null);\n  file.deleteOnExit();\n  return file.getAbsolutePath();\n}\n", "docstring": "create a tmp journal file for test cases .", "partition": "test"}
{"idx": "2129", "code": "public static double calcRotationAngleInDegrees(PointF centerPt,PointF targetPt){\n  double theta=Math.atan2(targetPt.y - centerPt.y,targetPt.x - centerPt.x);\n  double angle=Math.toDegrees(theta);\n  if (angle < 0) {\n    angle+=360;\n  }\n  return angle;\n}\n", "docstring": "calculates the angle from centerpt to targetpt in degrees . the return should range from [ 0 , 360 ) , rotating clockwise , 0 and 360 degrees represents east , 90 degrees represents south , etc . . . < p / > assumes all points are in the same coordinate space . if they are not , you will need to call swingutilities . convertpointtoscreen or equivalent on all arguments before passing them to this function .", "partition": "test"}
{"idx": "786", "code": "public boolean isFlying(){\n  return (flyThroughDialog != null);\n}\n", "docstring": "determine if in flight", "partition": "test"}
{"idx": "3497", "code": "public void dispose(){\n  clearListeners();\n  if (attributes != null) {\n    attributes.clear();\n  }\n  removed(null);\n}\n", "docstring": "method called when layer detects that it has been removed from maphandler , assumes it \"'\" s being thrown away . use this method to let go of everything and to make any calls necessary to remove from listener lists that might not get picked up via maphandler calls .", "partition": "test"}
{"idx": "3705", "code": "synchronized void addTracer(Tracer tracer){\n  if (curTracers.add(tracer)) {\n    LOG.trace(toString() + \": adding tracer \" + tracer.toString());\n  }\n}\n", "docstring": "add a new tracer .", "partition": "test"}
{"idx": "1006", "code": "protected void warningOccurred(int code){\n  cbLock.lock();\n  try {\n    if ((code < 0) || (code > MAX_WARNING)) {\n      throw new InternalError(\"Invalid warning index\");\n    }\n    processWarningOccurred(\"com.sun.imageio.plugins.jpeg.JPEGImageReaderResources\",Integer.toString(code));\n  }\n  finally {\n    cbLock.unlock();\n  }\n}\n", "docstring": "called by the native code or other classes to signal a warning . the code is used to lookup a localized message to be used when sending warnings to listeners .", "partition": "test"}
{"idx": "1054", "code": "public static void saveProvisioningValidity(Context context,long validity){\n  if (validity <= 0L) {\n    return;\n  }\n  long next=System.currentTimeMillis() + validity;\n  SharedPreferences preferences=context.getSharedPreferences(AndroidRegistryFactory.RCS_PREFS_NAME,Activity.MODE_PRIVATE);\n  SharedPreferences.Editor editor=preferences.edit();\n  editor.putLong(REGISTRY_PROVISIONING_VALIDITY,validity);\n  editor.putLong(REGISTRY_PROVISIONING_EXPIRATION,next);\n  editor.commit();\n}\n", "docstring": "save the provisioning validity in shared preferences", "partition": "test"}
{"idx": "459", "code": "public AemParsys clear(){\n  List<WebElement> list=currentScope.findElements(By.cssSelector(SELECTOR_FOR_COMPONENT_IN_PARSYS));\n  list.forEach(null);\n  return this;\n}\n", "docstring": "remove all components in parsys .", "partition": "test"}
{"idx": "2778", "code": "@Override public XADataSource createXADataSource(Properties properties) throws SQLException {\n  Properties propertiesCopy=new Properties();\n  if (properties != null) {\n    propertiesCopy.putAll(properties);\n  }\n  rejectUnsupportedOptions(propertiesCopy);\n  rejectPoolingOptions(propertiesCopy);\n  JdbcDataSource dataSource=new JdbcDataSource();\n  setupH2DataSource(dataSource,propertiesCopy);\n  return dataSource;\n}\n", "docstring": "creates a pooled xa data source .", "partition": "test"}
{"idx": "1542", "code": "public static Set<Interval> mergeIntervalToSet(Set<Interval> intervals,Interval intervalToMerge){\n  LinkedHashSet<Interval> copyOfOriginalSet=new LinkedHashSet<>(intervals);\n  copyOfOriginalSet.add(intervalToMerge);\n  return mergeIntervalSet(copyOfOriginalSet);\n}\n", "docstring": "merge an interval into the given interval set .", "partition": "test"}
{"idx": "2668", "code": "private void routeSingleGetRequest(RequestAndResponse requestAndResponse,String uri) throws IOException, ServletException {\n  if (uri.startsWith(\"/notebooks/\")) {\n    handleHtmlShowNotebooks(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/quotations/\")) {\n    handleHtmlShowQuotations(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/sources/\")) {\n    handleHtmlShowSources(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/source/\")) {\n    handleHtmlShowSource(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/notebook/\")) {\n    handleHtmlShowNotebook(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/search/\")) {\n    handleHtmlSearch(requestAndResponse);\n  }\n else   if (uri.equals(\"/help/\")) {\n    handleHtmlBasicHelp(requestAndResponse);\n  }\n else   if (uri.equals(\"/advancedHelp/\")) {\n    handleHtmlAdvancedHelp(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/help/\")) {\n    handleHtmlHelp(requestAndResponse);\n  }\n else   if (uri.equals(\"/backup/\")) {\n    handleHtmlUserBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/restore/\")) {\n    handleHtmlUserRestoreForm(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/account/\")) {\n    handleHtmlShowAccount(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/accounts/\")) {\n    handleHtmlShowAccounts(requestAndResponse);\n  }\n else   if (uri.equals(\"/shutdown/\")) {\n    handleHtmlShutdownForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/clear/\")) {\n    handleHtmlClearForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/onlineBackup/\")) {\n    handleHtmlOnlineBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/checkForErrors/\")) {\n    handleHtmlCheckForErrorsForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/backups/\")) {\n    handleHtmlShowDBBackups(requestAndResponse);\n  }\n else   if (uri.equals(\"/offlineBackup/\")) {\n    handleHtmlOfflineDbBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteJson/\")) {\n    handleJsonShowEntry(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteParentJson/\")) {\n    handleJsonShowEntryParent(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteChildrenJson/\")) {\n    handleJsonShowEntryChildren(requestAndResponse);\n  }\n else   if (uri.equals(\"/searchNotesJson/\")) {\n    handleJsonSearchNotes(requestAndResponse);\n  }\n else   if (uri.equals(\"/newNotebook/\")) {\n    handleHtmlNewNotebookForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/nothing/\")) {\n    handleHtmlNothing(requestAndResponse);\n  }\n else   if (uri.equals(\"/couldNotCreateNote/\")) {\n    handleHtmlCouldNotCreateNote(requestAndResponse);\n  }\n else   if (uri.equals(\"/restoreBackupCommand/\")) {\n    handleHtmlShowRestoreDbBackupCommand(requestAndResponse);\n  }\n else   if (uri.equals(\"/signedOut/\")) {\n    handleHtmlShowSignedOut(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/changePassword/\")) {\n    handleHtmlChangePassword(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/changeAccount/\")) {\n    handleHtmlChangeAccount(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/closeAccount/\")) {\n    handleHtmlCloseAccount(requestAndResponse);\n  }\n else   if (uri.equals(\"/isSignedIn/\")) {\n    handleJsonIsSignedIn(requestAndResponse);\n  }\n else   if (uri.equals(\"/restoreFrame/\")) {\n    handleHtmlUserRestoreFrame(requestAndResponse);\n  }\n else {\n    returnHtml404(requestAndResponse);\n  }\n}\n", "docstring": "routes a single get request .", "partition": "test"}
{"idx": "2136", "code": "private void dial(String contactInformation,boolean makeTheCall,boolean usePhoneSpeaker){\n  if (contactInformation.equals(\"\")) {\n    String lastRecipient=RecipientCmd.getLastRecipientNumber();\n    String lastRecipientName=RecipientCmd.getLastRecipientName();\n    if (lastRecipient != null) {\n      doDial(lastRecipientName,lastRecipient,makeTheCall,usePhoneSpeaker);\n    }\n else {\n      send(\"error: last recipient not set\");\n    }\n  }\n else {\n    ResolvedContact resolvedContact=mContactsResolver.resolveContact(contactInformation,ContactsResolver.TYPE_ALL);\n    if (resolvedContact == null) {\n      send(R.string.chat_no_match_for,contactInformation);\n    }\n else     if (resolvedContact.isDistinct()) {\n      doDial(resolvedContact.getName(),resolvedContact.getNumber(),makeTheCall,usePhoneSpeaker);\n    }\n else {\n      askForMoreDetails(resolvedContact.getCandidates());\n    }\n  }\n}\n", "docstring": "dial the specified contact", "partition": "test"}
{"idx": "513", "code": "public PersistedQueue(final File queueEnvPath,final String queueName,final int cacheSize){\n  queueEnvPath.mkdirs();\n  final EnvironmentConfig dbEnvConfig=new EnvironmentConfig();\n  dbEnvConfig.setTransactional(false);\n  dbEnvConfig.setAllowCreate(true);\n  this.dbEnv=new Environment(queueEnvPath,dbEnvConfig);\n  DatabaseConfig dbConfig=new DatabaseConfig();\n  dbConfig.setTransactional(false);\n  dbConfig.setAllowCreate(true);\n  dbConfig.setDeferredWrite(true);\n  this.queueDatabase=dbEnv.openDatabase(null,queueName,dbConfig);\n  this.queueName=queueName;\n  this.cacheSize=cacheSize;\n  this.opsCounter=0;\n}\n", "docstring": "creates instance of persistent queue .", "partition": "test"}
{"idx": "1795", "code": "public static String toString(LocalDate data){\n  return data == null ? \"\" : data.format(formatter(\"dd/MM/yyyy\"));\n}\n", "docstring": "converte localdatetime para string no formato dd / mm / yyyy", "partition": "test"}
{"idx": "3241", "code": "private void handleStartElement(XMLStreamReader parser,Set<Node> childrenFound,Handler handler,Map<String,Object> values,Stack<Set<String>> stack,boolean recordStarted) throws IOException, XMLStreamException {\n  Node n=getMatchingNode(parser,childNodes);\n  Map<String,Object> decends=new HashMap<>();\n  if (n != null) {\n    childrenFound.add(n);\n    n.parse(parser,handler,values,stack,recordStarted);\n    return;\n  }\n  Node dn=this;\n  do {\n    if (dn.wildCardNodes != null) {\n      n=getMatchingNode(parser,dn.wildCardNodes);\n      if (n != null) {\n        childrenFound.add(n);\n        n.parse(parser,handler,values,stack,recordStarted);\n        break;\n      }\n      for (      Node nn : dn.wildCardNodes)       decends.put(nn.name,nn);\n    }\n    dn=dn.wildAncestor;\n  }\n while (dn != null);\n  if (n == null) {\n    int count=1;\n    while (count != 0) {\n      int token=parser.next();\n      if (token == START_ELEMENT) {\n        Node nn=(Node)decends.get(parser.getLocalName());\n        if (nn != null) {\n          childrenFound.add(nn);\n          nn.parse(parser,handler,values,stack,recordStarted);\n        }\n else         count++;\n      }\n else       if (token == END_ELEMENT)       count--;\n    }\n  }\n}\n", "docstring": "if a new tag is encountered , check if it is of interest or not by seeing if it matches against our node tree . if we have deperted from the node tree then walk back though the tree \"'\" s ancestor nodes checking to see if any / / expressions exist for the node and compare them against the new tag . if matched then \" jump \" to that node , otherwise ignore the tag . note , the list of / / expressions found while walking back up the tree is chached in the hashmap decends . then if the new tag is to be skipped , any inner chil tags are compared against the cache and jumped to if matched .", "partition": "test"}
{"idx": "63", "code": "public int read() throws IOException {\n  int b0=fInputStream.read();\n  if (b0 > 0x80) {\n    throw new IOException(Localizer.getMessage(\"jsp.error.xml.invalidASCII\",Integer.toString(b0)));\n  }\n  return b0;\n}\n", "docstring": "read a single character . this method will block until a character is available , an i / o error occurs , or the end of the stream is reached . < p > subclasses that intend to support efficient single - character input should override this method .", "partition": "test"}
{"idx": "3644", "code": "private void initializeLayer(List<Neuron> layer,NeuronUpdateRule nodeType,int nodes){\n  for (int i=0; i < nodes; i++) {\n    Neuron node=new Neuron(getParentNetwork(),nodeType);\n    layer.add(node);\n  }\n}\n", "docstring": "helper method to initialize a layer by adding the desired number of neurons with the desired neuron update rule .", "partition": "test"}
{"idx": "1512", "code": "public void reset(boolean clear){\n  gotVersion=false;\n  gotHeaderLength=false;\n  gotHeader=false;\n  gotBody=false;\n  gotBodyBoundary=false;\n  headerLength=0;\n  bodyLength=0;\n  bodyBytesReceived=0;\n  if (clear) {\n    bufferOffset=0;\n    buffer.clear();\n    bodyFile=null;\n    if (bodyStream != null) {\n      try {\n        bodyStream.close();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n      bodyStream=null;\n    }\n  }\n}\n", "docstring": "reset the state of the receiver in preparation for a new sessionmessage .", "partition": "test"}
{"idx": "316", "code": "default B with(String key,int value){\n  return with(key,Integer.toString(value));\n}\n", "docstring": "associate the given value with the specified key .", "partition": "test"}
{"idx": "2901", "code": "private int findKeyCommentIndex(String keyName){\n  for (int i=0; i < keyValComments.size(); i++) {\n    String t=keyValComments.get(i);\n    String targetedKey=\"! \" + keyName + \": \";\n    if (t.startsWith(targetedKey)) {\n      return i;\n    }\n  }\n  if (log.isDebugEnabled()) {\n    log.debug(\"Did not find key \" + keyName);\n  }\n  return -1;\n}\n", "docstring": "finds the index of the specified key within the array containing key / value comments", "partition": "test"}
{"idx": "537", "code": "protected void stopBKCluster() throws Exception {\n  if (bkc != null) {\n    bkc.close();\n  }\n  for (  BookieServer server : bs) {\n    server.shutdown();\n    AutoRecoveryMain autoRecovery=autoRecoveryProcesses.get(server);\n    if (autoRecovery != null && isAutoRecoveryEnabled()) {\n      autoRecovery.shutdown();\n      LOG.debug(\"Shutdown auto recovery for bookieserver:\" + server.getLocalAddress());\n    }\n  }\n  bs.clear();\n  for (  File f : tmpDirs) {\n    FileUtils.deleteDirectory(f);\n  }\n}\n", "docstring": "stop cluster . also , stops all the auto recovery processes for the bookie cluster , if isautorecoveryenabled is true .", "partition": "test"}
{"idx": "1168", "code": "public final boolean skipAny(char c,CharSequence csq){\n  int i=index;\n  int n=csq.length();\n  for (; (i < n) && (csq.charAt(i) == c); i++) {\n  }\n  if (i == index)   return false;\n  index=i;\n  return true;\n}\n", "docstring": "moves this cursor forward until it points to a character different from the specified character .", "partition": "test"}
{"idx": "401", "code": "private void displayAllStringDefinedInStringXml(){\n  SimpleIconFontTextView textView=(SimpleIconFontTextView)findViewById(R.id.text_view_1);\n  List<String> list=new ArrayList<>();\n  list.add(getString(R.string.gems_logo));\n  String text=TextUtils.join(\" \",list);\n  textView.setText(text);\n}\n", "docstring": "display the string defined in the string xml file : iconfont_string . xml", "partition": "test"}
{"idx": "1652", "code": "public boolean ifTaskCompletedSuccessOrFailureFromResponse(ResponseOnSingeRequest myResponse){\n  boolean isCompleted=false;\n  try {\n    if (myResponse == null || myResponse.isFailObtainResponse()) {\n      return isCompleted;\n    }\n    String responseBody=myResponse.getResponseBody();\n    if (responseBody.matches(successRegex) || responseBody.matches(failureRegex)) {\n      isCompleted=true;\n    }\n  }\n catch (  Exception t) {\n    logger.error(\"fail\" + t);\n  }\n  return isCompleted;\n}\n", "docstring": "if task completed success or failure from response .", "partition": "test"}
{"idx": "4119", "code": "@Override public void done(){\n  super.done();\n  if (mNumTestsExpected > mNumTestsRun) {\n    handleTestRunFailed(String.format(\"Test run incomplete. Expected %d tests, received %d\",mNumTestsExpected,mNumTestsRun));\n  }\n else   if (mTestRunInProgress) {\n    handleTestRunFailed(\"No test results\");\n  }\n}\n", "docstring": "called by parent when adb session is complete .", "partition": "test"}
{"idx": "1527", "code": "default void shutdown(){\n  Platform.exit();\n}\n", "docstring": "shuts down the application by delegating service cleanups to the application thread .", "partition": "test"}
{"idx": "3670", "code": "public boolean equals(Object object){\n  if (!(object instanceof ObjectInstance)) {\n    return false;\n  }\n  ObjectInstance val=(ObjectInstance)object;\n  if (!name.equals(val.getObjectName()))   return false;\n  if (className == null)   return (val.getClassName() == null);\n  return className.equals(val.getClassName());\n}\n", "docstring": "compares the current object instance with another object instance .", "partition": "test"}
{"idx": "3810", "code": "private void removeAllObjects(){\n  logger.debug(\"CLEANING screen object list\");\n  texts.clear();\n}\n", "docstring": "remove all map objects .", "partition": "test"}
{"idx": "2633", "code": "public static @Nonnull <T>T valueOrDefault(@Nullable T value,@Nonnull T defaultValue){\n  return value == null ? defaultValue : value;\n}\n", "docstring": "returns a value if that value is not null , or a specified default value otherwise .", "partition": "test"}
{"idx": "2842", "code": "@Override public void run(){\n  try {\n    for (; ; ) {\n      int n=portGetn(port,bufferAddress,MAX_EVENT_COUNT);\n      assert n > 0;\n      long address=bufferAddress;\n      for (int i=0; i < n; i++) {\n        boolean shutdown=processEvent(address);\n        if (shutdown)         return;\n        address+=SIZEOF_PORT_EVENT;\n      }\n    }\n  }\n catch (  UnixException x) {\n    x.printStackTrace();\n  }\n}\n", "docstring": "poller main loop . blocks on port_getn waiting for events and then processes them .", "partition": "test"}
{"idx": "317", "code": "public static <X>void sortTopN(X[] array,int offset,int limit,Comparator<? super X> comp){\n  partitionTopN(array,offset,limit,comp);\n  Arrays.sort(array,offset,(int)Math.min((long)offset + limit,array.length),comp);\n}\n", "docstring": "find the top limit values using given comparator and place them as in a full array sort , in descending order .", "partition": "test"}
{"idx": "3287", "code": "public void removeChangeListener(ChangeListener l){\n  if (listeners == null)   return;\n  listeners.remove(l);\n}\n", "docstring": "removes a changelistener from this loader .", "partition": "test"}
{"idx": "3137", "code": "public void addMutedUsername(final String username,final Date muteTill){\n  if (isUsernameMuted(username)) {\n    removeMutedUsername(username);\n  }\n  Timestamp muteTillTs=null;\n  if (muteTill != null) {\n    muteTillTs=new Timestamp(muteTill.getTime());\n  }\n  s_logger.fine(\"Muting username:\" + username);\n  final Connection con=Database.getConnection();\n  try {\n    final PreparedStatement ps=con.prepareStatement(\"insert into muted_usernames (username, mute_till) values (?, ?)\");\n    ps.setString(1,username);\n    ps.setTimestamp(2,muteTillTs);\n    ps.execute();\n    ps.close();\n    con.commit();\n  }\n catch (  final SQLException sqle) {\n    if (sqle.getErrorCode() == 30000) {\n      s_logger.info(\"Tried to create duplicate muted username:\" + username + \" error:\"+ sqle.getMessage());\n      return;\n    }\n    s_logger.log(Level.SEVERE,\"Error inserting muted username:\" + username,sqle);\n    throw new IllegalStateException(sqle.getMessage());\n  }\n finally {\n    DbUtil.closeConnection(con);\n  }\n}\n", "docstring": "mute the given username . if mutetill is not null , the mute will expire when mutetill is reached . < p > if this username is already muted , this call will update the mute_end .", "partition": "test"}
{"idx": "1475", "code": "public HttpMethodClient(){\n  this(5000,10000,3 * 60000);\n}\n", "docstring": "creates a new http method client with default timeouts .", "partition": "test"}
{"idx": "1620", "code": "public void validate(Set setData) throws ValidationException {\n  for (Iterator iter=setData.iterator(); iter.hasNext(); ) {\n    performValidation((String)iter.next());\n  }\n}\n", "docstring": "performs validation on a set of string .", "partition": "test"}
{"idx": "613", "code": "private boolean isRelevant(Object service,Entry[] attributes){\n  LOOP:   for (  Entry e : _serviceAttributes) {\n    for (    Entry en : attributes) {\n      if (e.equals(en))       continue LOOP;\n    }\n    return false;\n  }\n  boolean flag=false;\n  for (  Entry en : attributes) {\n    if (_serviceName.equals(en)) {\n      flag=true;\n      break;\n    }\n  }\n  if (!flag)   return false;\n  flag=false;\n  for (  Class cl : _classes) {\n    if (cl.isInstance(service)) {\n      flag=true;\n      break;\n    }\n  }\n  return flag;\n}\n", "docstring": "is relevant service . used as filter for the incoming events .", "partition": "test"}
{"idx": "485", "code": "private double melToLinFreq(double inputFreq){\n  return (700.0 * (Math.pow(10.0,(inputFreq / 2595.0)) - 1.0));\n}\n", "docstring": "compute linear frequency from mel frequency .", "partition": "test"}
{"idx": "167", "code": "private void addCdcColSpecs(ArrayList<ColumnSpec> cdcSpecs,OneRowChange cdcRowChangeData){\n  int cdcPos=cdcSpecs.size();\n  if (cdcColumnsAtFront)   cdcPos=0;\n  ColumnSpec spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1);\n  spec.setName(\"CDC_OP_TYPE\");\n  spec.setType(java.sql.Types.VARCHAR);\n  spec.setLength(1);\n  cdcSpecs.add(cdcPos,spec);\n  spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1 + 1);\n  spec.setName(\"CDC_TIMESTAMP\");\n  spec.setType(java.sql.Types.TIMESTAMP);\n  cdcSpecs.add(cdcPos + 1,spec);\n  spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1 + 2);\n  spec.setName(\"CDC_SEQUENCE_NUMBER\");\n  spec.setType(java.sql.Types.BIGINT);\n  cdcSpecs.add(cdcPos + 2,spec);\n}\n", "docstring": "add cdc column specifications .", "partition": "test"}
{"idx": "3165", "code": "private ParsePosition next(final ParsePosition pos){\n  pos.setIndex(pos.getIndex() + 1);\n  return pos;\n}\n", "docstring": "convenience method to advance parse position by 1", "partition": "test"}
{"idx": "3185", "code": "public static String addCvDescription(String toolTip,String cvDescription,String mask){\n  String descString=cvDescription;\n  String temp=getMaskDescription(mask);\n  if (temp.length() > 0) {\n    descString=descString + \" \" + temp;\n  }\n  if (PaneProgFrame.getShowCvNumbers() && (descString != null)) {\n    if (toolTip == null) {\n      toolTip=descString;\n    }\n else {\n      toolTip=addTextHTMLaware(toolTip,\" (\" + descString + \")\");\n    }\n  }\n else   if (toolTip == null) {\n    toolTip=\"\";\n  }\n  return toolTip;\n}\n", "docstring": "optionally add cv numbers and bit numbers to tool tip text based on roster preferences setting . < p > needs to be independent of variablevalue methods to allow use by non - standard elements such as speedtablevarvalue , dccaddresspanel , fnmappanel .", "partition": "test"}
{"idx": "2626", "code": "public DimensionedScalar(String fieldValue) throws IllegalArgumentException {\n  super(\"\",\"\");\n  Matcher matcher=PATTERN.matcher(fieldValue);\n  if (matcher.find()) {\n    String name=matcher.group(1);\n    String dimensions=matcher.group(2);\n    String value=matcher.group(3);\n    setName(name);\n    setValue(value);\n    this.dimensions=new Dimensions(dimensions);\n  }\n else {\n    throw new DictionaryException(\"CANNOT PARSE:  >\" + fieldValue + \"<\");\n  }\n}\n", "docstring": "la stringa contiene il value del field di cui bisogna fare il parsing per estrarre valore e unita \"'\" di misura", "partition": "test"}
{"idx": "3851", "code": "static Field findField(Object instance,String name) throws NoSuchFieldException {\n  for (Class<?> clazz=instance.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    try {\n      Field field=clazz.getDeclaredField(name);\n      if (!field.isAccessible()) {\n        field.setAccessible(true);\n      }\n      return field;\n    }\n catch (    NoSuchFieldException e) {\n    }\n  }\n  throw new NoSuchFieldException(\"Field \" + name + \" not found in \"+ instance.getClass());\n}\n", "docstring": "locates a given field anywhere in the class inheritance hierarchy .", "partition": "test"}
{"idx": "850", "code": "public long startstack(){\n  return Long.parseLong(fields[27]);\n}\n", "docstring": "the address of the start ( i . e . , bottom ) of the stack .", "partition": "test"}
{"idx": "841", "code": "public byte[] readRawBytes(final int size) throws IOException {\n  if (size < 0) {\n    throw InvalidProtocolBufferNanoException.negativeSize();\n  }\n  if (bufferPos + size > currentLimit) {\n    skipRawBytes(currentLimit - bufferPos);\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n  if (size <= bufferSize - bufferPos) {\n    final byte[] bytes=new byte[size];\n    System.arraycopy(buffer,bufferPos,bytes,0,size);\n    bufferPos+=size;\n    return bytes;\n  }\n else {\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n}\n", "docstring": "read a fixed size of bytes from the input .", "partition": "test"}
{"idx": "1943", "code": "@Override public int length(){\n  return set.size();\n}\n", "docstring": "returns the set length", "partition": "test"}
{"idx": "2123", "code": "private void addConnectionView(Connection connection){\n  PlatformImpl.runAndWait(null);\n}\n", "docstring": "add a view for the given connection to the pipeline view . this method figures out the positioning and other details of adding the connection .", "partition": "test"}
{"idx": "137", "code": "protected void closeCallbacksExceptListener(){\n  closeCacheCallback(getCacheLoader());\n  closeCacheCallback(getCacheWriter());\n  closeCacheCallback(getEvictionController());\n}\n", "docstring": "the listener is not closed until after the afterregiondestroy event", "partition": "test"}
{"idx": "719", "code": "public void removeCategoriesListener(SnapshotCategoriesListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "removes a listener for changes of registered snapshot categories .", "partition": "test"}
{"idx": "541", "code": "private ComputeState validateComputeName(String awsId,String vmName) throws Throwable {\n  if (this.isAwsClientMock) {\n    return null;\n  }\n  ComputeState computeState=getComputeByAWSId(this.host,awsId);\n  String tagNameValue=computeState.name;\n  assertNotNull(\"\\'displayName\\' property should be present\",tagNameValue);\n  assertEquals(vmName,tagNameValue);\n  return computeState;\n}\n", "docstring": "validates the tag information on a compute state matches an expected virtual machine name .", "partition": "test"}
{"idx": "1137", "code": "public ReferenceBinding[] convertToRawTypes(ReferenceBinding[] originalTypes,boolean forceErasure,boolean forceRawEnclosingType){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] convertedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    ReferenceBinding convertedType=(ReferenceBinding)convertToRawType(forceErasure ? originalType.erasure() : originalType,forceRawEnclosingType);\n    if (convertedType != originalType) {\n      if (convertedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,convertedTypes=new ReferenceBinding[length],0,i);\n      }\n      convertedTypes[i]=convertedType;\n    }\n else     if (convertedTypes != originalTypes) {\n      convertedTypes[i]=originalType;\n    }\n  }\n  return convertedTypes;\n}\n", "docstring": "convert an array of types in raw forms . only allocate an array if anything is different .", "partition": "test"}
{"idx": "1333", "code": "public void addVMArguments(String vmArgumentName,String vmArgumentValue){\n  VmArgumentData vmArg=new VmArgumentData(vmArgumentName,vmArgumentValue);\n  vmSet.add(vmArg);\n}\n", "docstring": "adds the given vm argument .", "partition": "test"}
{"idx": "511", "code": "protected void processChildren(QueryNode queryTree) throws QueryNodeException {\n  List<QueryNode> children=queryTree.getChildren();\n  ChildrenList newChildren;\n  if (children != null && children.size() > 0) {\n    newChildren=allocateChildrenList();\n    try {\n      for (      QueryNode child : children) {\n        child=processIteration(child);\n        if (child == null) {\n          throw new NullPointerException();\n        }\n        newChildren.add(child);\n      }\n      List<QueryNode> orderedChildrenList=setChildrenOrder(newChildren);\n      queryTree.set(orderedChildrenList);\n    }\n  finally {\n      newChildren.beingUsed=false;\n    }\n  }\n}\n", "docstring": "this method is called every time a child is processed .", "partition": "test"}
{"idx": "1085", "code": "private BigInteger oddModPow(BigInteger y,BigInteger z){\n  if (y.equals(ONE))   return this;\n  if (signum == 0)   return ZERO;\n  int[] base=mag.clone();\n  int[] exp=y.mag;\n  int[] mod=z.mag;\n  int modLen=mod.length;\n  if ((modLen & 1) != 0) {\n    int[] x=new int[modLen + 1];\n    System.arraycopy(mod,0,x,1,modLen);\n    mod=x;\n    modLen++;\n  }\n  int wbits=0;\n  int ebits=bitLength(exp,exp.length);\n  if ((ebits != 17) || (exp[0] != 65537)) {\n    while (ebits > bnExpModThreshTable[wbits]) {\n      wbits++;\n    }\n  }\n  int tblmask=1 << wbits;\n  int[][] table=new int[tblmask][];\n  for (int i=0; i < tblmask; i++)   table[i]=new int[modLen];\n  long n0=(mod[modLen - 1] & LONG_MASK) + ((mod[modLen - 2] & LONG_MASK) << 32);\n  long inv=-MutableBigInteger.inverseMod64(n0);\n  int[] a=leftShift(base,base.length,modLen << 5);\n  MutableBigInteger q=new MutableBigInteger(), a2=new MutableBigInteger(a), b2=new MutableBigInteger(mod);\n  b2.normalize();\n  MutableBigInteger r=a2.divide(b2,q);\n  table[0]=r.toIntArray();\n  if (table[0].length < modLen) {\n    int offset=modLen - table[0].length;\n    int[] t2=new int[modLen];\n    System.arraycopy(table[0],0,t2,offset,table[0].length);\n    table[0]=t2;\n  }\n  int[] b=montgomerySquare(table[0],mod,modLen,inv,null);\n  int[] t=Arrays.copyOf(b,modLen);\n  for (int i=1; i < tblmask; i++) {\n    table[i]=montgomeryMultiply(t,table[i - 1],mod,modLen,inv,null);\n  }\n  int bitpos=1 << ((ebits - 1) & (32 - 1));\n  int buf=0;\n  int elen=exp.length;\n  int eIndex=0;\n  for (int i=0; i <= wbits; i++) {\n    buf=(buf << 1) | (((exp[eIndex] & bitpos) != 0) ? 1 : 0);\n    bitpos>>>=1;\n    if (bitpos == 0) {\n      eIndex++;\n      bitpos=1 << (32 - 1);\n      elen--;\n    }\n  }\n  int multpos=ebits;\n  ebits--;\n  boolean isone=true;\n  multpos=ebits - wbits;\n  while ((buf & 1) == 0) {\n    buf>>>=1;\n    multpos++;\n  }\n  int[] mult=table[buf >>> 1];\n  buf=0;\n  if (multpos == ebits)   isone=false;\n  while (true) {\n    ebits--;\n    buf<<=1;\n    if (elen != 0) {\n      buf|=((exp[eIndex] & bitpos) != 0) ? 1 : 0;\n      bitpos>>>=1;\n      if (bitpos == 0) {\n        eIndex++;\n        bitpos=1 << (32 - 1);\n        elen--;\n      }\n    }\n    if ((buf & tblmask) != 0) {\n      multpos=ebits - wbits;\n      while ((buf & 1) == 0) {\n        buf>>>=1;\n        multpos++;\n      }\n      mult=table[buf >>> 1];\n      buf=0;\n    }\n    if (ebits == multpos) {\n      if (isone) {\n        b=mult.clone();\n        isone=false;\n      }\n else {\n        t=b;\n        a=montgomeryMultiply(t,mult,mod,modLen,inv,a);\n        t=a;\n        a=b;\n        b=t;\n      }\n    }\n    if (ebits == 0)     break;\n    if (!isone) {\n      t=b;\n      a=montgomerySquare(t,mod,modLen,inv,a);\n      t=a;\n      a=b;\n      b=t;\n    }\n  }\n  int[] t2=new int[2 * modLen];\n  System.arraycopy(b,0,t2,modLen,modLen);\n  b=montReduce(t2,mod,modLen,(int)inv);\n  t2=Arrays.copyOf(b,modLen);\n  return new BigInteger(1,t2);\n}\n", "docstring": "returns a biginteger whose value is x to the power of y mod z . assumes : z is odd & & x < z .", "partition": "test"}
{"idx": "3030", "code": "private void sendCONNECTRequest() throws IOException {\n  int port=url.getPort();\n  requests.set(0,HTTP_CONNECT + \" \" + connectRequestURI(url)+ \" \"+ httpVersion,null);\n  requests.setIfNotSet(\"User-Agent\",userAgent);\n  String host=url.getHost();\n  if (port != -1 && port != url.getDefaultPort()) {\n    host+=\":\" + String.valueOf(port);\n  }\n  requests.setIfNotSet(\"Host\",host);\n  requests.setIfNotSet(\"Accept\",acceptString);\n  if (http.getHttpKeepAliveSet()) {\n    requests.setIfNotSet(\"Proxy-Connection\",\"keep-alive\");\n  }\n  setPreemptiveProxyAuthentication(requests);\n  if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n    logger.fine(requests.toString());\n  }\n  http.writeRequests(requests,null);\n}\n", "docstring": "send a connect request for establishing a tunnel to proxy server", "partition": "test"}
{"idx": "2725", "code": "private void checkResourceChange(final Resource resource,final Group group,final Callback callback,final AtomicBoolean isChanged) throws Exception {\n  if (isChanged(resource,group.getName())) {\n    isChanged.compareAndSet(false,true);\n    callback.onResourceChanged(resource);\n    lifecycleCallback.onResourceChanged(resource);\n  }\n}\n", "docstring": "will check if a given resource was changed and will invoke the appropriate callback .", "partition": "test"}
{"idx": "501", "code": "public static void writeToFile(File file,String contents) throws IOException {\n  FileOutputStream fos=new FileOutputStream(file);\n  fos.write(contents.getBytes());\n  fos.close();\n}\n", "docstring": "writes the contents to the file at the given location ( this creates the file or deletes its existing contents . )", "partition": "test"}
{"idx": "2494", "code": "public static DateTime parseRfc822(String str) throws ParseException {\n  Date date;\nsynchronized (dateTimeFormat822) {\n    try {\n      date=dateTimeFormat822.parse(str);\n    }\n catch (    java.text.ParseException e) {\n      throw new ParseException(e);\n    }\n  }\n  return new DateTime(date);\n}\n", "docstring": "parses the value as an rfc 822 date / time .", "partition": "test"}
{"idx": "191", "code": "public Sentence asSentence(){\n  return Sentence.newConjunction(sentences);\n}\n", "docstring": "returns the list of sentences in the knowledge base chained together as a single sentence .", "partition": "test"}
{"idx": "2146", "code": "public static String write(POSMikheevCounter counter){\n  return POSBaseLineCounter.write(counter);\n}\n", "docstring": "write an instance of posmikheevcounter class to json format", "partition": "test"}
{"idx": "3566", "code": "public ConversionException(final Throwable cause){\n  super(cause.getMessage());\n  this.cause=cause;\n}\n", "docstring": "construct a new exception with the specified root cause .", "partition": "test"}
{"idx": "1433", "code": "public int nodeCount(){\n  return nodes == null ? 0 : nodes.size();\n}\n", "docstring": "return the number of nodes in the is way", "partition": "test"}
{"idx": "4180", "code": "public void cfgPackage(ConfigurationValue cfgval,String name,String desc){\n  packages.add(new PackageInfo(name,desc));\n  packageNames.add(name);\n}\n", "docstring": "assigns description to a package", "partition": "test"}
{"idx": "1606", "code": "public static String arrayToHexString(byte[] array){\n  return arrayToHexString(array,0,array.length);\n}\n", "docstring": "helper method to convert a byte [ ", "partition": "test"}
{"idx": "1674", "code": "private void testViewAlterAndCommandCache() throws SQLException {\n  deleteDb(\"view\");\n  Connection conn=getConnection(\"view\");\n  Statement stat=conn.createStatement();\n  stat.execute(\"create table t0(id int primary key)\");\n  stat.execute(\"create table t1(id int primary key)\");\n  stat.execute(\"insert into t0 values(0)\");\n  stat.execute(\"insert into t1 values(1)\");\n  stat.execute(\"create view v1 as select * from t0\");\n  ResultSet rs=stat.executeQuery(\"select * from v1\");\n  assertTrue(rs.next());\n  assertEquals(0,rs.getInt(1));\n  stat.execute(\"create or replace view v1 as select * from t1\");\n  rs=stat.executeQuery(\"select * from v1\");\n  assertTrue(rs.next());\n  assertEquals(1,rs.getInt(1));\n  conn.close();\n  deleteDb(\"view\");\n}\n", "docstring": "make sure that when we change a view , that change in reflected in other sessions command cache .", "partition": "test"}
{"idx": "1564", "code": "public static String selectText(XPathExpression expr,Node context){\n  try {\n    return (String)expr.evaluate(context,XPathConstants.STRING);\n  }\n catch (  XPathExpressionException e) {\n    throw new XmlException(e);\n  }\n}\n", "docstring": "evaluates the xpath expression as text .", "partition": "test"}
{"idx": "2594", "code": "public static boolean isZoningRequired(DbClient dbClient,URI varrayUri){\n  if (varrayUri != null) {\n    VirtualArray nh=dbClient.queryObject(VirtualArray.class,varrayUri);\n    if (nh != null) {\n      return isZoningRequired(dbClient,nh);\n    }\n  }\n  return false;\n}\n", "docstring": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "partition": "test"}
{"idx": "160", "code": "@Override public String execute(){\n  return SUCCESS;\n}\n", "docstring": "default : just returns \" success \"", "partition": "test"}
{"idx": "9", "code": "public Entry updateOrCreateSource(User user,String id,String url,String title,Long modTime,Long createTime,boolean isAdmin,Errors errors){\n  if (user == null) {\n    Errors.add(errors,errorMessages.errorUserIsNull());\n    return null;\n  }\n  if (url == null) {\n    Errors.add(errors,errorMessages.errorUrlIsNull());\n    return null;\n  }\n  Entry source=getEntryByUserIdAndUrl(user.getId(),url);\n  if (source == null) {\n    if (url.isEmpty()) {\n      Errors.add(errors,errorMessages.errorUrlIsEmpty());\n      return null;\n    }\n    if (title == null) {\n      Errors.add(errors,errorMessages.errorTitleIsNull());\n      return null;\n    }\n    if (title.isEmpty()) {\n      Errors.add(errors,errorMessages.errorTitleIsEmpty());\n      return null;\n    }\n    if (modTime == null) {\n      Errors.add(errors,errorMessages.errorModTimeIsNull());\n      return null;\n    }\n    if (createTime == null) {\n      Errors.add(errors,errorMessages.errorCreateTimeIsNull());\n      return null;\n    }\n    if (id != null && !idGenerator.isIdWellFormed(id)) {\n      Errors.add(errors,errorMessages.errorIdIsInvalid());\n      return null;\n    }\n    if (createTime.longValue() > modTime.longValue()) {\n      modTime=createTime;\n    }\n    if (url != null) {\n      url=cleanUpText(url);\n    }\n    if (title != null) {\n      title=cleanUpText(title);\n    }\n    source=new Entry();\n    source.setDb(db);\n    if (id == null) {\n      id=idGenerator.getAnotherId();\n    }\n    source.setId(id);\n    source.setSourceUrl(url);\n    source.setSourceTitle(title);\n    source.setCreateTime(createTime);\n    source.setType(Constants.source);\n    source.setUserId(user.getId());\n    db.persistEntry(source);\n  }\n else   if (!canUserModifyEntry(user,source,isAdmin)) {\n    Errors.add(errors,errorMessages.errorUserIsNotEntitledToModifyTheSource());\n    return null;\n  }\n  source.setModTime(modTime);\n  return source;\n}\n", "docstring": "api method . returns an entry for the source indexed by the user and the url . this method creates it if it didn \"'\" t already exist .", "partition": "test"}
{"idx": "402", "code": "public static void checkHTTPRequestLength(HttpServletRequest request) throws ServletException {\n  int maxContentLength=SAMLUtils.getMaxContentLength();\n  if (maxContentLength != 0) {\n    int length=request.getContentLength();\n    if (length == -1) {\n      throw new ServletException(bundle.getString(\"unknownLength\"));\n    }\n    if (length > maxContentLength) {\n      if (debug.messageEnabled()) {\n        debug.message(\"FSUtils.checkHTTPRequestLength: \" + \"content length too large\" + length);\n      }\n      throw new ServletException(bundle.getString(\"largeContentLength\"));\n    }\n  }\n}\n", "docstring": "checks content length of a http request to avoid dos attack . in case idff inter - op with other idff vendor who may not provide content length in httpservletrequest . we decide to support no length restriction for http communication . here , we use a special value ( e . g . 0 ) to indicate that no enforcement is required .", "partition": "test"}
{"idx": "804", "code": "public ComponentConfigBuilder addItemInMultifield(String multifieldLabel,int index,String itemType,String itemLabel,String value){\n  String type=String.format(\"multifield#%s#%s\",index,itemType);\n  String label=String.format(\"%s#%s\",multifieldLabel,itemLabel);\n  config.add(new ConfigurationEntry(currentTab,type,label,value));\n  return this;\n}\n", "docstring": "adds multifield entry , equivalent of : | tab_name | multifield # index # itemtype | multifieldlabel # itemlabel | value |", "partition": "test"}
{"idx": "2769", "code": "public static String formatListToString(List<String> list){\n  String result=\"\";\n  for (  String s : list)   result+=s + \"\\\\t\\\\t\";\n  result=result.trim();\n  return result.toUpperCase();\n}\n", "docstring": "formats the list objects from the pokemodel into formatted strings that are easily readable .", "partition": "test"}
{"idx": "3244", "code": "public static ArrayList<Long> loadWorkspaceScreensDb(Context context){\n  final ContentResolver contentResolver=context.getContentResolver();\n  final Uri screensUri=LauncherSettings.WorkspaceScreens.CONTENT_URI;\n  final Cursor sc=contentResolver.query(screensUri,null,null,null,LauncherSettings.WorkspaceScreens.SCREEN_RANK);\n  ArrayList<Long> screenIds=new ArrayList<Long>();\n  try {\n    final int idIndex=sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);\n    while (sc.moveToNext()) {\n      try {\n        screenIds.add(sc.getLong(idIndex));\n      }\n catch (      Exception e) {\n        Launcher.addDumpLog(TAG,\"Desktop items loading interrupted\" + \" - invalid screens: \" + e,true);\n      }\n    }\n  }\n  finally {\n    if (sc != null) {\n      sc.close();\n    }\n  }\n  return screenIds;\n}\n", "docstring": "loads the workspace screen ids in an ordered list .", "partition": "test"}
{"idx": "1958", "code": "public void test_concurrent_modification_insert(){\n  final BTree btree;\n{\n    IndexMetadata md=new IndexMetadata(UUID.randomUUID());\n    md.setBranchingFactor(20);\n    btree=BTree.create(new SimpleMemoryRawStore(),md);\n    btree.insert(10,\"Bryan\");\n    btree.insert(20,\"Mike\");\n    btree.insert(30,\"James\");\n  }\n{\n    ITupleCursor2<String> cursor=newCursor(btree);\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.seek(20));\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.tuple());\n    btree.insert(15,\"Paul\");\n    assertEquals(TestKeyBuilder.asSortKey(20),cursor.currentKey());\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.tuple());\n    assertEquals(new TestTuple<String>(15,\"Paul\"),cursor.prior());\n    assertEquals(new TestTuple<String>(15,\"Paul\"),cursor.tuple());\n    btree.remove(15);\n    assertEquals(null,cursor.tuple());\n    assertEquals(TestKeyBuilder.asSortKey(15),cursor.currentKey());\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.next());\n    btree.remove(20);\n    assertEquals(null,cursor.tuple());\n    assertEquals(TestKeyBuilder.asSortKey(20),cursor.currentKey());\n    btree.insert(25,\"Allen\");\n    assertEquals(TestKeyBuilder.asSortKey(20),cursor.currentKey());\n    assertEquals(null,cursor.tuple());\n    assertEquals(new TestTuple<String>(25,\"Allen\"),cursor.next());\n    assertEquals(new TestTuple<String>(25,\"Allen\"),cursor.tuple());\n  }\n}\n", "docstring": "unit test for concurrent modification resulting from insert ( ) and remove ( ) .", "partition": "test"}
{"idx": "2074", "code": "@SuppressWarnings({\"SuspiciousNameCombination\"}) public static double normalCdf(double y){\n  double f, h;\n  int j;\n  double dcphi, x, z, f1, f2, f3, f4, f5;\n  x=y;\n  if (Math.abs(x) > 15.) {\n    dcphi=0.;\n  }\n else {\n    j=(int)Math.floor(Math.abs(x) * 16. + .5);\n    z=j * .0625;\n    h=Math.abs(x) - z;\n    f=r[j];\n    f1=f * z - 1;\n    f2=f + z * f1;\n    f3=f1 * 2. + z * f2;\n    f4=f2 * 3 + z * f3;\n    f5=f3 * 4 + z * f4;\n    dcphi=f + h * (f1 * 120. + h * (f2 * 60. + h * (f3 * 20. + h * (f4 * 5. + h * f5)))) / 120.;\n    dcphi=dcphi * .3989422804014326779 * Math.exp(x * -.5 * x);\n  }\n  if (x < 0.) {\n    return dcphi;\n  }\n else {\n    return (1.0 - dcphi);\n  }\n}\n", "docstring": "normal cumulative distribution function ( the value which results by integrating the normal distribution function from negative infinity up to y ) .", "partition": "test"}
{"idx": "1987", "code": "protected DateTimeData parse(String str,int durationType) throws SchemaDateTimeException {\n  int len=str.length();\n  DateTimeData date=new DateTimeData(str,this);\n  int start=0;\n  char c=str.charAt(start++);\n  if (c != 'P' && c != '-') {\n    throw new SchemaDateTimeException();\n  }\n else {\n    date.utc=(c == '-') ? '-' : 0;\n    if (c == '-' && str.charAt(start++) != 'P') {\n      throw new SchemaDateTimeException();\n    }\n  }\n  int negate=1;\n  if (date.utc == '-') {\n    negate=-1;\n  }\n  boolean designator=false;\n  int endDate=indexOf(str,start,len,'T');\n  if (endDate == -1) {\n    endDate=len;\n  }\n else   if (durationType == YEARMONTHDURATION_TYPE) {\n    throw new SchemaDateTimeException();\n  }\n  int end=indexOf(str,start,endDate,'Y');\n  if (end != -1) {\n    if (durationType == DAYTIMEDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.year=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  end=indexOf(str,start,endDate,'M');\n  if (end != -1) {\n    if (durationType == DAYTIMEDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.month=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  end=indexOf(str,start,endDate,'D');\n  if (end != -1) {\n    if (durationType == YEARMONTHDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.day=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  if (len == endDate && start != len) {\n    throw new SchemaDateTimeException();\n  }\n  if (len != endDate) {\n    end=indexOf(str,++start,len,'H');\n    if (end != -1) {\n      date.hour=negate * parseInt(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    end=indexOf(str,start,len,'M');\n    if (end != -1) {\n      date.minute=negate * parseInt(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    end=indexOf(str,start,len,'S');\n    if (end != -1) {\n      date.second=negate * parseSecond(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    if (start != len || str.charAt(--start) == 'T') {\n      throw new SchemaDateTimeException();\n    }\n  }\n  if (!designator) {\n    throw new SchemaDateTimeException();\n  }\n  return date;\n}\n", "docstring": "parses , validates and computes normalized version of duration object", "partition": "test"}
{"idx": "2663", "code": "void deleteChild(PolicyNode childNode){\n  if (isImmutable) {\n    throw new IllegalStateException(\"PolicyNode is immutable\");\n  }\n  mChildren.remove(childNode);\n}\n", "docstring": "deletes the specified child node of this node , if it exists .", "partition": "test"}
{"idx": "287", "code": "public void enablePan(BluetoothAdapter adapter){\n  if (mPan == null)   mPan=(BluetoothPan)connectProxy(adapter,BluetoothProfile.PAN);\n  assertNotNull(mPan);\n  long start=System.currentTimeMillis();\n  mPan.setBluetoothTethering(true);\n  long stop=System.currentTimeMillis();\n  assertTrue(mPan.isTetheringOn());\n  writeOutput(String.format(\"enablePan() completed in %d ms\",(stop - start)));\n}\n", "docstring": "enables pan tethering on the local device and checks to make sure that tethering is enabled .", "partition": "test"}
{"idx": "2974", "code": "static void loadDirectory(File file,ModuleCandidate candidate) throws IOException {\n  File[] files=file.listFiles();\n  if (files != null)   for (  File f : files)   loadSubDirectory(file,f,candidate);\n}\n", "docstring": "load a module candidate from a directory . this is usually used in - sim - - search .", "partition": "test"}
{"idx": "3587", "code": "private void feedForward(Vec input,List<Vec> activations,List<Vec> derivatives){\n  Vec x=input;\n  for (int i=0; i < Ws.size(); i++) {\n    Matrix W_i=Ws.get(i);\n    Vec b_i=bs.get(i);\n    Vec a_i=activations.get(i);\n    a_i.zeroOut();\n    W_i.multiply(x,1,a_i);\n    a_i.mutableAdd(b_i);\n    a_i.applyFunction(f);\n    Vec d_i=derivatives.get(i);\n    a_i.copyTo(d_i);\n    d_i.applyFunction(f.getD());\n    x=a_i;\n  }\n}\n", "docstring": "feeds a vector through the network to get an output", "partition": "test"}
{"idx": "1442", "code": "public static double relativeOverlap(SpatialComparable box1,SpatialComparable box2){\n  final int dim=assertSameDimensionality(box1,box2);\n  double overlap=1.;\n  double vol1=1.;\n  double vol2=1.;\n  for (int i=0; i < dim; i++) {\n    final double box1min=box1.getMin(i);\n    final double box1max=box1.getMax(i);\n    final double box2min=box2.getMin(i);\n    final double box2max=box2.getMax(i);\n    final double omax=Math.min(box1max,box2max);\n    final double omin=Math.max(box1min,box2min);\n    if (omax <= omin) {\n      return 0.;\n    }\n    overlap*=omax - omin;\n    vol1*=box1max - box1min;\n    vol2*=box2max - box2min;\n  }\n  return overlap / (vol1 + vol2);\n}\n", "docstring": "computes the volume of the overlapping box between two spatialcomparables and return the relation between the volume of the overlapping box and the volume of both spatialcomparable .", "partition": "test"}
{"idx": "1646", "code": "private Token toPrefixToken(ILeafNode leaf){\n  Lexer lexer=new InternalN4JSLexer();\n  String text=leaf.getText();\n  String prefix=text.substring(0,endOffset - leaf.getTotalOffset());\n  ANTLRStringStream stream=new ANTLRStringStream(prefix);\n  lexer.setCharStream(stream);\n  Token nextToken=lexer.nextToken();\n  return new CommonToken(nextToken.getType(),nextToken.getText());\n}\n", "docstring": "produce an antlr token for the prefix of the given leaf that overlaps the requested region", "partition": "test"}
{"idx": "3299", "code": "protected static boolean checkRawModulesTables(final CConnection connection,final String databaseName,final int rawModuleId){\n  Preconditions.checkNotNull(connection,\"IE02261: Connection argument can not be null\");\n  Preconditions.checkNotNull(databaseName,\"IE02262: Database name argument can not be null\");\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be a positive integer\",rawModuleId);\n  final ImmutableSet<String> rawTableNames=ImmutableSet.of(String.format(CTableNames.RAW_ADDRESS_COMMENTS_TABLE,rawModuleId),String.format(CTableNames.RAW_ADDRESS_REFERENCES_TABLE,rawModuleId),String.format(CTableNames.RAW_BASE_TYPES,rawModuleId),String.format(CTableNames.RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_BASIC_BLOCKS_TABLE,rawModuleId),String.format(CTableNames.RAW_CALLGRAPH_TABLE,rawModuleId),String.format(CTableNames.RAW_CONTROL_FLOW_GRAPHS_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_NODES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_SUBSTITUTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TREE_NODES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TREES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TYPES_TABLE,rawModuleId),String.format(CTableNames.RAW_FUNCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_INSTRUCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_OPERANDS_TABLE,rawModuleId),String.format(CTableNames.RAW_SECTIONS,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TYPE_INSTANCES,rawModuleId),String.format(CTableNames.RAW_TYPE_INSTACES,rawModuleId),String.format(CTableNames.RAW_TYPES,rawModuleId));\n  final Pair<CConnection,String> cacheKey=new Pair<>(connection,databaseName);\n  if (PostgreSQLDatabaseFunctions.queryCache(cacheKey,rawTableNames)) {\n    return true;\n  }\n else {\n    if (!PostgreSQLDatabaseFunctions.fillCache(cacheKey)) {\n      return false;\n    }\n    return PostgreSQLDatabaseFunctions.queryCache(cacheKey,rawTableNames);\n  }\n}\n", "docstring": "checks the existence of all necessary raw module tables .", "partition": "test"}
{"idx": "650", "code": "protected void stopWraparoundTest(){\n  if (testRunning && wrapTest) {\n    wrapTimer.stop();\n    statusText1.setText(\"Wraparound Test Stopped, \" + Integer.toString(numErrors) + \" Errors Found\");\n    statusText1.setVisible(true);\n    statusText2.setText(Integer.toString(numIterations) + \" Cycles Completed\");\n    statusText2.setVisible(true);\n  }\n}\n", "docstring": "local method to stop a wraparound test", "partition": "test"}
{"idx": "4170", "code": "public boolean isModified(){\nsynchronized (this) {\n    if (_isChecking || _isModified) {\n      return _isModified;\n    }\n    _isChecking=true;\n  }\n  try {\n    long now;\n    now=CurrentTime.currentTime();\n    if (now < _lastCheckTime + _checkInterval)     return _isModified;\n    _lastCheckTime=now;\n    for (int i=_dependencyList.size() - 1; i >= 0; i--) {\n      Dependency dependency=_dependencyList.get(i);\n      if (dependency.isModified()) {\n        dependency.logModified(log());\n        _isModified=true;\n        return _isModified;\n      }\n    }\n    return _isModified;\n  }\n  finally {\n    _isChecking=false;\n  }\n}\n", "docstring": "returns true if the underlying dependencies have changed .", "partition": "test"}
{"idx": "2656", "code": "public double SumOutlinkAuthorityScore(Page page){\n  List<String> outLinks=page.getOutlinks();\n  double authScore=0;\n  for (int i=0; i < outLinks.size(); i++) {\n    Page outLink=pTable.get(outLinks.get(i));\n    if (outLink != null) {\n      authScore+=outLink.authority;\n    }\n  }\n  return authScore;\n}\n", "docstring": "calculate the hub score of a page by summing the authority scores of that page \"'\" s outlinks .", "partition": "test"}
{"idx": "3366", "code": "static public String randomPositiveFloat(int whole,int decimal){\n  StringBuilder output=new StringBuilder();\n  output.append(rnd.nextInt(8) + 1);\n  for (int i=0; i < whole - 1; i++) {\n    output.append(rnd.nextInt(9));\n  }\n  output.append(\".\");\n  for (int i=0; i < decimal; i++) {\n    output.append(rnd.nextInt(9));\n  }\n  return output.toString();\n}\n", "docstring": "get a random , positive float", "partition": "test"}
{"idx": "3938", "code": "public void put(Buffer buffer){\n  if (buffer.getLength() <= 2) {\n    return;\n  }\n  byte[] currentRtpPacketData=((byte[])buffer.getData());\n  H264RtpHeaders h264RtpHeaders=new H264RtpHeaders(currentRtpPacketData);\n  if (h264RtpHeaders.getFUI_F()) {\n    return;\n  }\n  if (reassembledData == null) {\n    timestamp=buffer.getTimestamp();\n    format=buffer.getFormat();\n    seqNumber=buffer.getSequenceNumber();\n    reassembledDataNALHeader=h264RtpHeaders.getNALHeader();\n    reassembledData=new byte[JavaPacketizer.H264_MAX_RTP_PKTS][H264_FRAME_PACKET_SIZE];\n    reassembledDataSize=new int[JavaPacketizer.H264_MAX_RTP_PKTS];\n    reassembledDataHasStart=false;\n    reassembledDataHasEnd=false;\n  }\n  int posSeq=(int)(buffer.getSequenceNumber() & VIDEO_DECODER_MAX_PAYLOADS_CHUNKS_MASK);\n  int payloadStartPosition=h264RtpHeaders.getHeaderSize();\n  int payloadLength=buffer.getLength() - h264RtpHeaders.getHeaderSize();\n  if (h264RtpHeaders.getFUI_TYPE() == H264RtpHeaders.AVC_NALTYPE_FUA) {\n    reassembledDataHasStart|=(h264RtpHeaders.getFUH_S());\n    reassembledDataHasEnd|=(h264RtpHeaders.getFUH_E());\n    reassembledDataPosSeqStart=((h264RtpHeaders.getFUH_S()) ? posSeq : reassembledDataPosSeqStart);\n    reassembledDataPosSeqEnd=((h264RtpHeaders.getFUH_E()) ? posSeq : reassembledDataPosSeqEnd);\n  }\n  reassembledDataSize[posSeq]=payloadLength;\n  reassembledDataFullSize+=payloadLength;\n  System.arraycopy(currentRtpPacketData,payloadStartPosition,reassembledData[posSeq],0,payloadLength);\n  videoOrientation=buffer.getVideoOrientation();\n}\n", "docstring": "add the buffer ( which contains a fragment ) to the assembler .", "partition": "test"}
{"idx": "1918", "code": "public void flush(){\n  final BigdataSailRepositoryConnection cxn=tlTx.get();\n  if (cxn != null) {\n    Code.wrapThrow(null);\n  }\n}\n", "docstring": "flush the statement buffers to the indices without committing .", "partition": "test"}
{"idx": "3486", "code": "public synchronized int copyDirect(int pageId,OutputStream out) throws IOException {\n  byte[] buffer=new byte[pageSize];\n  if (pageId >= pageCount) {\n    return -1;\n  }\n  file.seek((long)pageId << pageSizeShift);\n  file.readFullyDirect(buffer,0,pageSize);\n  readCount++;\n  out.write(buffer,0,pageSize);\n  return pageId + 1;\n}\n", "docstring": "copy the next page to the output stream .", "partition": "test"}
{"idx": "3540", "code": "private void pushAnnotatorsRef(String values){\n  annotatorsRef.push(annotatorsRef.peek());\n  setAnnotatorsRef(values);\n}\n", "docstring": "pushes a new level of annotators references and base the new one on the given values .", "partition": "test"}
{"idx": "3788", "code": "protected boolean position(Projection proj){\n  if (proj == null) {\n    logger.fine(\"OMRasterObject: null projection in position!\");\n    return false;\n  }\n  projWidth=proj.getWidth();\n  projHeight=proj.getHeight();\nswitch (renderType) {\ncase RENDERTYPE_LATLON:\n    if (!proj.isPlotable(lat,lon)) {\n      if (DEBUG) {\n        logger.fine(\"OMRasterObject: point is not plotable!\");\n      }\n      setNeedToReposition(true);\n      return false;\n    }\n  point1=(Point)proj.forward(lat,lon,new Point());\nbreak;\ncase RENDERTYPE_XY:\npoint1=new Point(x,y);\nbreak;\ncase RENDERTYPE_OFFSET:\nif (!proj.isPlotable(lat,lon)) {\nif (DEBUG) {\nlogger.fine(\"OMRasterObject: point is not plotable!\");\n}\nsetNeedToReposition(true);\nreturn false;\n}\npoint1=(Point)proj.forward(lat,lon,new Point());\npoint1.x+=x;\npoint1.y+=y;\nbreak;\ncase RENDERTYPE_UNKNOWN:\nif (DEBUG) {\nlogger.fine(\"OMRasterObject.position(): ignoring unknown rendertype, wingin\\' it\");\n}\nif (lat == 0 && lon == 0) {\nif (x == 0 && y == 0) {\nif (DEBUG) {\nlogger.fine(\"OMRasterObject.position(): Not enough info in object to place it reasonably.\");\n}\npoint1=new Point(-width,-height);\npoint2=new Point(0,0);\nreturn false;\n}\n else {\npoint1=new Point(x,y);\n}\n}\n else {\nif (!proj.isPlotable(lat,lon)) {\nlogger.fine(\"OMRasterObject: point is not plotable!\");\nreturn false;\n}\npoint1=(Point)proj.forward(lat,lon,new Point());\n}\nbreak;\n}\npoint2=new Point(0,0);\npoint2.x=point1.x + width;\npoint2.y=point1.y + height;\nsetNeedToReposition(false);\nreturn true;\n}\n", "docstring": "since the image doesn \"'\" t necessarily need to be regenerated when it is merely moved , raster objects have this function , called from generate ( ) and when a placement attribute is changed .", "partition": "test"}
{"idx": "1370", "code": "@Override public boolean add(E o){\n  if (null == o) {\n    throw new NullPointerException();\n  }\n  if (offer(o)) {\n    return true;\n  }\n  throw new IllegalStateException();\n}\n", "docstring": "adds an element to the queue .", "partition": "test"}
{"idx": "24", "code": "@Override public AggregateableEvaluation aggregate(Evaluation evaluation){\n  m_Incorrect+=evaluation.incorrect();\n  m_Correct+=evaluation.correct();\n  m_Unclassified+=evaluation.unclassified();\n  m_MissingClass+=evaluation.m_MissingClass;\n  m_WithClass+=evaluation.m_WithClass;\n  if (evaluation.m_ConfusionMatrix != null) {\n    double[][] newMatrix=evaluation.confusionMatrix();\n    if (newMatrix != null) {\n      for (int i=0; i < m_ConfusionMatrix.length; i++) {\n        for (int j=0; j < m_ConfusionMatrix[i].length; j++) {\n          m_ConfusionMatrix[i][j]+=newMatrix[i][j];\n        }\n      }\n    }\n  }\n  double[] newClassPriors=evaluation.m_ClassPriors;\n  if (newClassPriors != null && m_ClassPriors != null) {\n    for (int i=0; i < this.m_ClassPriors.length; i++) {\n      m_ClassPriors[i]=newClassPriors[i];\n    }\n  }\n  m_ClassPriorsSum=evaluation.m_ClassPriorsSum;\n  m_TotalCost+=evaluation.totalCost();\n  m_SumErr+=evaluation.m_SumErr;\n  m_SumAbsErr+=evaluation.m_SumAbsErr;\n  m_SumSqrErr+=evaluation.m_SumSqrErr;\n  m_SumClass+=evaluation.m_SumClass;\n  m_SumSqrClass+=evaluation.m_SumSqrClass;\n  m_SumPredicted+=evaluation.m_SumPredicted;\n  m_SumSqrPredicted+=evaluation.m_SumSqrPredicted;\n  m_SumClassPredicted+=evaluation.m_SumClassPredicted;\n  m_SumPriorAbsErr+=evaluation.m_SumPriorAbsErr;\n  m_SumPriorSqrErr+=evaluation.m_SumPriorSqrErr;\n  m_SumKBInfo+=evaluation.m_SumKBInfo;\n  double[] newMarginCounts=evaluation.m_MarginCounts;\n  if (newMarginCounts != null) {\n    for (int i=0; i < m_MarginCounts.length; i++) {\n      m_MarginCounts[i]+=newMarginCounts[i];\n    }\n  }\n  m_ComplexityStatisticsAvailable=evaluation.m_ComplexityStatisticsAvailable;\n  m_CoverageStatisticsAvailable=evaluation.m_CoverageStatisticsAvailable;\n  m_SumPriorEntropy+=evaluation.m_SumPriorEntropy;\n  m_SumSchemeEntropy+=evaluation.m_SumSchemeEntropy;\n  m_TotalSizeOfRegions+=evaluation.m_TotalSizeOfRegions;\n  m_TotalCoverage+=evaluation.m_TotalCoverage;\n  ArrayList<Prediction> predsToAdd=evaluation.m_Predictions;\n  if (predsToAdd != null) {\n    if (m_Predictions == null) {\n      m_Predictions=new ArrayList<Prediction>();\n    }\n    for (int i=0; i < predsToAdd.size(); i++) {\n      m_Predictions.add(predsToAdd.get(i));\n    }\n  }\n  return this;\n}\n", "docstring": "adds the statistics encapsulated in the supplied evaluation object into this one . does not perform any checks for compatibility between the supplied evaluation object and this one .", "partition": "test"}
{"idx": "3468", "code": "public final void sample(){\n  long sum=_sum.getAndSet(0);\n  int count=_count.getAndSet(0);\n  if (count != 0)   _value=sum / (double)count;\n else   _value=0;\n}\n", "docstring": "return the probe \"'\" s next sample .", "partition": "test"}
{"idx": "2116", "code": "public static Color decode(String color,Color defaultColor){\n  if (color == null) {\n    return defaultColor;\n  }\n  Color c=getNamedColor(color);\n  if (c == null) {\n    try {\n      c=Color.decode(color);\n    }\n catch (    NumberFormatException ex) {\n      return defaultColor;\n    }\n  }\n  return c;\n}\n", "docstring": "decodes an html color and turns it into a color object . supports some named colors and string formats that are supported by color . decode ( ) . if no color can be decoded , returns the defaultcolor specified by the caller .", "partition": "test"}
{"idx": "2972", "code": "public void removeChildAt(int index){\n  if ((index < 0) || (children == null) || (index >= children.size())) {\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  Element child=(Element)children.get(index);\n  child.setParent(null);\n  children.remove(index);\n}\n", "docstring": "removes the child at the given index", "partition": "test"}
{"idx": "264", "code": "protected void doFloodBDDP(long pinSwitch,OFPacketIn pi,FloodlightContext cntx){\n  TopologyInstance ti=getCurrentInstance(false);\n  Set<Long> switches=ti.getSwitchesInOpenflowDomain(pinSwitch);\n  if (switches == null) {\n    switches=new HashSet<Long>();\n    switches.add(pinSwitch);\n  }\n  for (  long sid : switches) {\n    IOFSwitch sw=floodlightProvider.getSwitch(sid);\n    if (sw == null)     continue;\n    Collection<Short> enabledPorts=sw.getEnabledPortNumbers();\n    if (enabledPorts == null)     continue;\n    Set<Short> ports=new HashSet<Short>();\n    ports.addAll(enabledPorts);\n    Set<Short> portsKnownToTopo=ti.getPortsWithLinks(sid);\n    if (portsKnownToTopo != null) {\n      for (      short p : portsKnownToTopo) {\n        NodePortTuple npt=new NodePortTuple(sid,p);\n        if (ti.isBroadcastDomainPort(npt) == false) {\n          ports.remove(p);\n        }\n      }\n    }\n    Set<Short> portsToEliminate=getPortsToEliminateForBDDP(sid);\n    if (portsToEliminate != null) {\n      ports.removeAll(portsToEliminate);\n    }\n    if (pinSwitch == sid) {\n      ports.remove(pi.getInPort());\n    }\n    doMultiActionPacketOut(pi.getPacketData(),sw,ports,cntx);\n  }\n}\n", "docstring": "the bddp packets are forwarded out of all the ports out of an openflowdomain . get all the switches in the same openflow domain as the sw ( disabling tunnels ) . then get all the external switch ports and send these packets out .", "partition": "test"}
{"idx": "3362", "code": "public void cancelAutoCompletion(){\n  if (inCompletion) {\n    textField.setText(textBefore);\n    textField.setCaretPosition(caretPosBefore);\n    prevCompletion=null;\n    prevCompletionIndex=0;\n    inCompletion=false;\n  }\n}\n", "docstring": "cancels the current completion , which means the state of the text is returned to what it was before completion and the info popup is closed if necessary .", "partition": "test"}
{"idx": "918", "code": "private void onTrackPointElementStart(Attributes attributes) throws SAXException {\n  String latitude=attributes.getValue(ATT_LAT);\n  String longitude=attributes.getValue(ATT_LON);\n  if (latitude == null || longitude == null) {\n    throw new SAXException(createErrorMessage(\"Point with no longitude or latitude.\"));\n  }\n  try {\n    latitudeValue=Double.parseDouble(latitude);\n    longitudeValue=Double.parseDouble(longitude);\n  }\n catch (  NumberFormatException e) {\n    throw new SAXException(createErrorMessage(\"Unable to parse latitude/longitude: \" + latitude + \"/\"+ longitude),e);\n  }\n}\n", "docstring": "on track point element start .", "partition": "test"}
{"idx": "2978", "code": "private boolean checkIfInitiatorForRPBeforeMigration(Initiator initiator){\n  if (initiator == null) {\n    return false;\n  }\n  boolean isRP=true;\n  if (NullColumnValueGetter.isNullValue(initiator.getHostName()) || !NullColumnValueGetter.isNullURI(initiator.getHost())) {\n    isRP=false;\n  }\n  log.debug(\"RP initiator? \" + (isRP ? \"Yes!\" : \"No!\"));\n  return isRP;\n}\n", "docstring": "check if the passed in initiator is for rp", "partition": "test"}
{"idx": "4176", "code": "public void addMetaObject(MetaObject object){\n  for (int k=0; k < MetaObjects.size(); ++k) {\n    if (MetaObjects.get(k) == null) {\n      MetaObjects.set(k,object);\n      return;\n    }\n  }\n  MetaObjects.add(object);\n}\n", "docstring": "add a metaobject to the state .", "partition": "test"}
{"idx": "3172", "code": "public static boolean isFailure(List<Action> actions){\n  return actions.isEmpty();\n}\n", "docstring": "checks whether a list of actions is empty .", "partition": "test"}
{"idx": "3304", "code": "public static double enlargementScaled(SpatialComparable exist,SpatialComparable addit,double scale){\n  final int dim=assertSameDimensionality(exist,addit);\n  double v1=1.;\n  double v2=1.;\n  for (int i=0; i < dim; i++) {\n    final double emin=exist.getMin(i);\n    final double emax=exist.getMax(i);\n    final double amin=addit.getMin(i);\n    final double amax=addit.getMax(i);\n    final double min=Math.min(emin,amin);\n    final double max=Math.max(emax,amax);\n    v1*=(max - min) * scale;\n    v2*=(emax - emin) * scale;\n  }\n  return v2 - v1;\n}\n", "docstring": "compute the enlargement obtained by adding an object to an existing object .", "partition": "test"}
{"idx": "1687", "code": "public void delItems(int s,int e){\n  boolean hsbWasVisible=hsbVis;\n  boolean vsbWasVisible=vsbVis;\n  int oldLastDisplayed=lastItemDisplayed();\n  if (log.isLoggable(PlatformLogger.Level.FINE)) {\n    log.fine(\"Deleting from \" + s + \" to \"+ e);\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Last displayed item: \" + oldLastDisplayed + \", items in window \"+ itemsInWindow()+ \", size \"+ items.size());\n  }\n  if (items.size() == 0) {\n    return;\n  }\n  if (s > e) {\n    int tmp=s;\n    s=e;\n    e=tmp;\n  }\n  if (s < 0) {\n    s=0;\n  }\n  if (e >= items.size()) {\n    e=items.size() - 1;\n  }\n  boolean repaintNeeded=(s >= getFirstVisibleItem() && s <= getLastVisibleItem());\n  for (int i=s; i <= e; i++) {\n    items.removeElementAt(s);\n    int j=posInSel(i);\n    if (j != -1) {\n      int newsel[]=new int[selected.length - 1];\n      System.arraycopy(selected,0,newsel,0,j);\n      System.arraycopy(selected,j + 1,newsel,j,selected.length - (j + 1));\n      selected=newsel;\n    }\n  }\n  int diff=(e - s) + 1;\n  for (int i=0; i < selected.length; i++) {\n    if (selected[i] > e) {\n      selected[i]-=diff;\n    }\n  }\n  int options=PAINT_VSCROLL;\n  if (getFocusIndex() > e) {\n    setFocusIndex(getFocusIndex() - (e - s + 1));\n    options|=PAINT_FOCUS;\n  }\n else   if (getFocusIndex() >= s && getFocusIndex() <= e) {\n    int focusBound=(items.size() > 0) ? 0 : -1;\n    setFocusIndex(Math.max(s - 1,focusBound));\n    options|=PAINT_FOCUS;\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Multiple selections: \" + multipleSelections);\n  }\n  if (vsb.getValue() >= s) {\n    if (vsb.getValue() <= e) {\n      vsb.setValue(e + 1 - diff);\n    }\n else {\n      vsb.setValue(vsb.getValue() - diff);\n    }\n  }\n  int oldMaxLength=maxLength;\n  maxLength=maxLength();\n  if (maxLength != oldMaxLength) {\n    options|=PAINT_HSCROLL;\n  }\n  layout();\n  repaintNeeded|=(vsbWasVisible ^ vsbVis) || (hsbWasVisible ^ hsbVis);\n  if (repaintNeeded) {\n    options|=PAINT_ALL;\n  }\n  repaint(s,oldLastDisplayed,options);\n}\n", "docstring": "delete items starting with s ( start position ) to e ( end position ) including s and e if s < 0 then s = 0 if e > = items . size ( ) then e = items . size ( ) - 1", "partition": "test"}
{"idx": "3819", "code": "private StringBuffer buildSelectQuery(String schemaName,String tableName,ArrayList<OneRowChange.ColumnSpec> keys,ArrayList<OneRowChange.ColumnVal> keyValues){\n  StringBuffer stmt=new StringBuffer();\n  stmt.append(\"SELECT * FROM \");\n  stmt.append(conn.getDatabaseObjectName(schemaName) + \".\" + conn.getDatabaseObjectName(tableName));\n  stmt.append(\" WHERE \");\n  printColumnSpec(stmt,keys,keyValues,PrintMode.ASSIGNMENT,\" AND \");\n  return stmt;\n}\n", "docstring": "constructs a sql statement template later used for prepared statement .", "partition": "test"}
{"idx": "4166", "code": "public static List<String> readToList(Reader r) throws IOException {\n  try (BufferedReader in=new BufferedReader(r)){\n    List<String> l=new ArrayList<>();\n    String line=null;\n    while ((line=in.readLine()) != null)     l.add(line);\n    return Collections.unmodifiableList(l);\n  }\n }\n", "docstring": "read the reader line for line and return the result in a list", "partition": "test"}
{"idx": "2443", "code": "private void appendContainerConfig(DockerSlaveTemplate slaveTemplate,CreateContainerCmd containerConfig){\n  Map<String,String> labels=containerConfig.getLabels();\n  if (labels == null) {\n    labels=new HashMap<>();\n  }\n  labels.put(DOCKER_CLOUD_LABEL,getDisplayName());\n  labels.put(DOCKER_TEMPLATE_LABEL,slaveTemplate.getId());\n  containerConfig.withLabels(labels);\n}\n", "docstring": "cloud specific container config options", "partition": "test"}
{"idx": "3231", "code": "public void writeEntry(CCacheOutputStream cos) throws IOException {\n  cos.write16(adType);\n  cos.write32(adData.length);\n  cos.write(adData,0,adData.length);\n}\n", "docstring": "writes the entry \"'\" s data fields in fcc format to an output stream .", "partition": "test"}
{"idx": "2783", "code": "public void writeTag(String tag,Font value){\n  startTag(tag);\n  writeTag(\"name\",value.getName());\n  int style=value.getStyle();\n  if ((style & Font.BOLD) != 0 && (style & Font.ITALIC) != 0) {\n    writeTag(STYLE,\"BOLDITALIC\");\n  }\n else   if ((style & Font.BOLD) != 0) {\n    writeTag(STYLE,\"BOLD\");\n  }\n else   if ((style & Font.ITALIC) != 0) {\n    writeTag(STYLE,\"ITALIC\");\n  }\n else {\n    writeTag(STYLE,\"PLAIN\");\n  }\n  writeTag(\"size\",value.getSize());\n  closeTag();\n}\n", "docstring": "writes & lt ; tag & gt ; value & lt ; / tag & gt ; to output stream", "partition": "test"}
{"idx": "3243", "code": "public static Discretization discretize(double[] _data,double[] cutoffs,String variableName,List<String> categories){\n  if (cutoffs == null) {\n    throw new NullPointerException();\n  }\n  for (int i=0; i < cutoffs.length - 1; i++) {\n    if (!(cutoffs[i] <= cutoffs[i + 1])) {\n      throw new NullPointerException(\"Cutoffs must be in nondecreasing order.\");\n    }\n  }\n  if (variableName == null) {\n    throw new NullPointerException();\n  }\n  int numCategories=cutoffs.length + 1;\n  if (categories != null && categories.size() != numCategories) {\n    throw new IllegalArgumentException(\"If specified, the list of \" + \"categories names must be one longer than the length of \" + \"the cutoffs array.\");\n  }\n  DiscreteVariable variable;\n  if (categories == null) {\n    variable=new DiscreteVariable(variableName,numCategories);\n  }\n else {\n    variable=new DiscreteVariable(variableName,categories);\n  }\n  int[] discreteData=new int[_data.length];\n  loop:   for (int i=0; i < _data.length; i++) {\n    if (Double.isNaN(_data[i])) {\n      discreteData[i]=DiscreteVariable.MISSING_VALUE;\n      continue;\n    }\n    for (int j=0; j < cutoffs.length; j++) {\n      if (_data[i] > Double.NEGATIVE_INFINITY && _data[i] < Double.POSITIVE_INFINITY && _data[i] < cutoffs[j]) {\n        discreteData[i]=j;\n        continue loop;\n      }\n    }\n    discreteData[i]=cutoffs.length;\n  }\n  return new Discretization(variable,discreteData);\n}\n", "docstring": "discretizes the continuous data in the given column using the specified cutoffs and category names . the following scheme is used . if cutoffs [ i - 1 ", "partition": "test"}
{"idx": "72", "code": "public boolean resourceSupportAR(Integer id){\n  if (id == null) {\n    return false;\n  }\n  return resourceSupportAR(id.intValue());\n}\n", "docstring": "checks whether a given resource id supports advanced reservations or not .", "partition": "test"}
{"idx": "3433", "code": "public void test_journal_oneIndexNoData() throws IOException, InterruptedException, ExecutionException {\n  final File out=File.createTempFile(getName(),Options.JNL);\n  try {\n    final Journal src=getStore(getProperties());\n    try {\n      final String NAME=\"testIndex\";\n      src.registerIndex(new IndexMetadata(NAME,UUID.randomUUID()));\n      src.commit();\n      final Future<Journal> f=src.compact(out);\n      final Journal newJournal=f.get();\n      try {\n        assertNotNull(newJournal.getIndex(NAME));\n        AbstractBTreeTestCase.assertSameBTree(src.getIndex(NAME),newJournal.getIndex(NAME));\n      }\n  finally {\n        newJournal.destroy();\n      }\n    }\n  finally {\n      src.destroy();\n    }\n  }\n  finally {\n    out.delete();\n  }\n}\n", "docstring": "test of a journal on which a single index has been register ( and the journal committed ) but no data was written onto the index .", "partition": "test"}
{"idx": "2090", "code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase EipPackage.CONDITIONAL_ROUTE__CONDITION:\n    return CONDITION_EDEFAULT == null ? condition != null : !CONDITION_EDEFAULT.equals(condition);\ncase EipPackage.CONDITIONAL_ROUTE__CHANNEL:\n  return channel != null;\n}\nreturn super.eIsSet(featureID);\n}\n", "docstring": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "3828", "code": "public void updateEnd(Logger log){\n  m_instanceCount++;\n  m_sampleCount++;\n  double end=System.currentTimeMillis();\n  double temp=end - m_updateStart;\n  m_cumulativeTime+=temp;\n  boolean toFastToMeasure=false;\n  if ((end - m_startTime) >= m_sampleTime) {\n    computeUpdate(end);\n    if (log != null) {\n      log.statusMessage(m_statusMessagePrefix + \"Processed \" + m_instanceCount+ \" insts @ \"+ m_avInstsPerSec / m_numSamples + \" insts/sec\" + (toFastToMeasure ? \"*\" : \"\"));\n    }\n    m_sampleCount=0;\n    m_cumulativeTime=0;\n    m_startTime=System.currentTimeMillis();\n  }\n}\n", "docstring": "register a throughput measurement end point . collects counts and statistics . will update the status area for the kf step in question if the sample period has elapsed .", "partition": "test"}
{"idx": "508", "code": "public void start(){\n  if (runner == null) {\n    runner=new Thread(this,\"Runner\");\n    runner.start();\n  }\n}\n", "docstring": "we \"'\" re starting the thread", "partition": "test"}
{"idx": "3925", "code": "public void removeIndexInterval(int index0,int index1){\n  int rmMinIndex=Math.min(index0,index1);\n  int rmMaxIndex=Math.max(index0,index1);\n  int gapLength=(rmMaxIndex - rmMinIndex) + 1;\n  for (int i=rmMinIndex; i <= maxIndex; i++) {\n    setState(i,value.get(i + gapLength));\n  }\n  int leadIndex=this.leadIndex;\n  if (leadIndex == 0 && rmMinIndex == 0) {\n  }\n else   if (leadIndex > rmMaxIndex) {\n    leadIndex=this.leadIndex - gapLength;\n  }\n else   if (leadIndex >= rmMinIndex) {\n    leadIndex=rmMinIndex - 1;\n  }\n  int anchorIndex=this.anchorIndex;\n  if (anchorIndex == 0 && rmMinIndex == 0) {\n  }\n else   if (anchorIndex > rmMaxIndex) {\n    anchorIndex=this.anchorIndex - gapLength;\n  }\n else   if (anchorIndex >= rmMinIndex) {\n    anchorIndex=rmMinIndex - 1;\n  }\n  if (leadIndex != this.leadIndex || anchorIndex != this.anchorIndex) {\n    updateLeadAnchorIndices(anchorIndex,leadIndex);\n  }\n  fireValueChanged();\n}\n", "docstring": "remove the indices in the interval index0 , index1 ( inclusive ) from the selection model . this is typically called to sync the selection model width a corresponding change in the data model . note that ( as always ) index0 need not be & lt ; = index1 .", "partition": "test"}
{"idx": "3922", "code": "public static byte[] readBinaryFile(File sourceFile){\n  byte[] result=null;\n  try {\n    BufferedInputStream input;\n    input=new BufferedInputStream(new FileInputStream(sourceFile));\n    int num=input.available();\n    result=new byte[num];\n    input.read(result,0,num);\n    input.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    result=null;\n  }\n  return result;\n}\n", "docstring": "reads a binary input file into a byte array", "partition": "test"}
{"idx": "4217", "code": "public static ArrayList<String> stringToArrayList(String string){\n  return new ArrayList<>(Arrays.asList(string.split(\",\")));\n}\n", "docstring": "make arraylist from \" , \" separated string", "partition": "test"}
{"idx": "4152", "code": "public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (!(obj instanceof URIName)) {\n    return false;\n  }\n  URIName other=(URIName)obj;\n  return uri.equals(other.getURI());\n}\n", "docstring": "compares this name with another , for equality .", "partition": "test"}
{"idx": "1940", "code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  super.beginDisplay(event,false);\n  resetButtonState(TBL_BUTTON_DELETE);\n  AgentsModel model=(AgentsModel)getModel();\n  String agentType=getDisplayIDType();\n  Object[] param={agentType};\n  ptModel.setPageTitleText(model.getLocalizedString(\"agenttype.\" + agentType));\n  ptModel.setPageTitleHelpMessage(model.getLocalizedString(\"agenttype.\" + agentType + \".help\"));\n  tblModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agents.title.name\"),param));\n  tblModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblGroupModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.title.name\"),param));\n  tblGroupModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  tblGroupModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  getAgentNames();\n  CCButton b=(CCButton)getChild(TBL_BUTTON_DELETE);\n  b.setDisabled(true);\n  b=(CCButton)getChild(TBL_BUTTON_DELETE_GROUP);\n  b.setDisabled(true);\n}\n", "docstring": "sets the agent title and populates the agent and agent group action table .", "partition": "test"}
{"idx": "1422", "code": "public PageOfCollections fetchPage(PageOfCollections page,SolrZkClient zkClient) throws KeeperException, InterruptedException {\n  List<String> children=getCollections(zkClient);\n  page.selected=children;\n  if (page.start == 0 && page.rows == -1 && page.filter == null && children.size() > 10) {\n    page.rows=20;\n    page.start=0;\n  }\n  if (page.filterType == FilterType.name && page.filter != null)   children=page.applyNameFilter(children);\n  if (page.filterType != FilterType.status)   page.selectPage(children);\n  return page;\n}\n", "docstring": "gets the requested page of collections after applying filters and offsets .", "partition": "test"}
{"idx": "1115", "code": "private void addToQueue(SerialMessage serialMessage){\n  if (serialMessage == null) {\n    return;\n  }\n  if (!msgQueue.contains(serialMessage) && msgQueue.remainingCapacity() > 1) {\n    msgQueue.add(serialMessage);\n  }\n  sendMessage();\n}\n", "docstring": "move the messages to the queue", "partition": "test"}
{"idx": "2358", "code": "@Override public boolean accept(File f){\n  if (f != null) {\n    if (f.isDirectory()) {\n      return true;\n    }\n    String extension=getExtension(f);\n    if (extension != null && filters.get(getExtension(f)) != null) {\n      return true;\n    }\n    ;\n  }\n  return false;\n}\n", "docstring": "return true if this file should be shown in the directory pane , false if it shouldn \"'\" t . files that begin with \" . \" are ignored .", "partition": "test"}
{"idx": "3521", "code": "public boolean isGerund(){\n  return typeString.startsWith(VERB_GERUND);\n}\n", "docstring": "determine if the expression contains a verb in gerund form .", "partition": "test"}
{"idx": "1306", "code": "public void addListener(ColorMapListener listener){\n  listeners.add(listener);\n}\n", "docstring": "add a color map listener", "partition": "test"}
{"idx": "698", "code": "public boolean deleteAttachmentPoint(DatapathId sw,OFPort port){\n  AttachmentPoint ap=new AttachmentPoint(sw,port,new Date(0));\n  if (this.oldAPs != null) {\n    ArrayList<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n    apList.addAll(this.oldAPs);\n    int index=apList.indexOf(ap);\n    if (index > 0) {\n      apList.remove(index);\n      this.oldAPs=apList;\n    }\n  }\n  if (this.attachmentPoints != null) {\n    ArrayList<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n    apList.addAll(this.attachmentPoints);\n    int index=apList.indexOf(ap);\n    if (index > 0) {\n      apList.remove(index);\n      this.attachmentPoints=apList;\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "delete ( sw , port ) from the list of list of attachment points and oldaps .", "partition": "test"}
{"idx": "685", "code": "void removeKnownObject(ParseObject object){\nsynchronized (mutex) {\n    knownObjects.remove(object);\n  }\n}\n", "docstring": "removes an object that is known to not be in the relation . this is used for offline caching .", "partition": "test"}
{"idx": "2604", "code": "public String toMatlab(){\n  StringBuffer result;\n  int i;\n  int n;\n  result=new StringBuffer();\n  result.append(\"[\");\n  for (i=0; i < getRowDimension(); i++) {\n    if (i > 0) {\n      result.append(\"; \");\n    }\n    for (n=0; n < getColumnDimension(); n++) {\n      if (n > 0) {\n        result.append(\" \");\n      }\n      result.append(Double.toString(get(i,n)));\n    }\n  }\n  result.append(\"]\");\n  return result.toString();\n}\n", "docstring": "converts the matrix into a single line matlab string : matrix is enclosed by parentheses , rows are separated by semicolon and single cells by blanks , e . g . , [ 1 2 ; 3 4 ", "partition": "test"}
{"idx": "2280", "code": "public static Template create(String value){\n  if (Settings.isFunction(value)) {\n    return new FunctionalTemplate(value);\n  }\n  if (Graph.isRelational(value)) {\n    try {\n      return new RelationalTemplate(value);\n    }\n catch (    Exception e) {\n      log.warning(\"illegal relational structure: \" + value + \")\");\n      return new StringTemplate(value);\n    }\n  }\n else   if (RegexTemplate.isPossibleRegex(value)) {\n    try {\n      if (ArithmeticTemplate.isArithmeticExpression(value)) {\n        return new ArithmeticTemplate(value);\n      }\n      return new RegexTemplate(value);\n    }\n catch (    PatternSyntaxException e) {\n      log.warning(\"illegal pattern: \" + value + \")\");\n      return new StringTemplate(value);\n    }\n  }\n else {\n    return new StringTemplate(value);\n  }\n}\n", "docstring": "creates a new template based on the string value . this method finds the best template representation for the string and returns the result .", "partition": "test"}
{"idx": "2430", "code": "public static int brighter(int c){\n  int r=red(c), g=green(c), b=blue(c);\n  int i=(int)(1.0 / (1.0 - scale));\n  if (r == 0 && g == 0 && b == 0) {\n    return rgba(i,i,i,alpha(c));\n  }\n  if (r > 0 && r < i)   r=i;\n  if (g > 0 && g < i)   g=i;\n  if (b > 0 && b < i)   b=i;\n  return rgba(Math.min(255,(int)(r / scale)),Math.min(255,(int)(g / scale)),Math.min(255,(int)(b / scale)),alpha(c));\n}\n", "docstring": "get a brighter shade of an input color .", "partition": "test"}
{"idx": "1409", "code": "public DNetscapeCaRevocationUrl(JDialog parent,byte[] value) throws IOException {\n  super(parent);\n  setTitle(res.getString(\"DNetscapeCaRevocationUrl.Title\"));\n  initComponents();\n  prepopulateWithValue(value);\n}\n", "docstring": "creates a new dnetscapecarevocationurl dialog .", "partition": "test"}
{"idx": "3412", "code": "public SSLEngine initSslEngine(boolean client) throws Exception {\n  KeyStore keyStore=loadKeystore(properties.sslKeyStorePath(),properties.sslKeyStorePassword());\n  KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n  keyManagerFactory.init(keyStore,keyStoreKeyPass(properties));\n  KeyStore trustStore;\n  if (properties.sslTrustStorePath() != null) {\n    LOGGER.debug(\"Using separate trust store\");\n    trustStore=loadKeystore(properties.sslTrustStorePath(),properties.sslTrustStorePassword());\n  }\n else {\n    trustStore=keyStore;\n    LOGGER.debug(\"Using key store as trust store\");\n  }\n  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n  trustManagerFactory.init(trustStore);\n  KeyManager[] keyManagers=keyManagerFactory.getKeyManagers();\n  TrustManager[] trustManagers=trustManagerFactory.getTrustManagers();\n  SSLContext sslContext=SSLContext.getInstance(\"TLS\");\n  sslContext.init(keyManagers,trustManagers,null);\n  SSLEngine sslEngine=sslContext.createSSLEngine();\n  sslEngine.setUseClientMode(client);\n  sslEngine.setWantClientAuth(true);\n  sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());\n  sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());\n  sslEngine.setEnableSessionCreation(true);\n  return sslEngine;\n}\n", "docstring": "initializes an ssl engine .", "partition": "test"}
{"idx": "2348", "code": "public void type(String string){\n  for (int i=0; i < string.length(); i++) {\n    char c=string.charAt(i);\n    type(c);\n  }\n}\n", "docstring": "simulate keyboard type to type out a string . this types upper case letter by using shift + lower case letter . almost every typeable character on ansi keyboard is supported .", "partition": "test"}
{"idx": "902", "code": "@Override public void close() throws IOException {\n  if (mBufferCount > 0) {\n    try {\n      mQueue.write(mBuffer,0,mBufferCount);\n    }\n catch (    InterruptedException e) {\n      throw new IOException(\"GzipAsynchOutputStream interrupted during write/3\");\n    }\n    mBufferCount=0;\n  }\n  mQueue.close();\n  try {\n    mThread.join();\n  }\n catch (  InterruptedException e) {\n    throw new IOException(\"AsynchOutputStream interrupted during close\");\n  }\n finally {\n    super.close();\n  }\n  checkException();\n}\n", "docstring": "this also io errors that happened in the gzip thread .", "partition": "test"}
{"idx": "2454", "code": "public static void printStackTrace(Throwable e){\n  try {\n    Debug.printStackTrace(e);\n  }\n catch (  Throwable f) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "used in environments where full debug may not be available", "partition": "test"}
{"idx": "1185", "code": "private void handleSubscribe(String[] args){\nswitch (args[1]) {\ncase \"rr\":\n    TestSubscriber<Payload> rrsub=new TestSubscriber<>(0L);\n  payloadSubscribers.put(args[2],rrsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rrclient=createClient.get();\nPublisher<Payload> rrpub=rrclient.requestResponse(new PayloadImpl(args[3],args[4]));\nrrpub.subscribe(rrsub);\nbreak;\ncase \"rs\":\nTestSubscriber<Payload> rssub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rssub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsclient=createClient.get();\nPublisher<Payload> rspub=rsclient.requestStream(new PayloadImpl(args[3],args[4]));\nrspub.subscribe(rssub);\nbreak;\ncase \"sub\":\nTestSubscriber<Payload> rsubsub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rsubsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsubclient=createClient.get();\nPublisher<Payload> rsubpub=rsubclient.requestSubscription(new PayloadImpl(args[3],args[4]));\nrsubpub.subscribe(rsubsub);\nbreak;\ncase \"fnf\":\nTestSubscriber<Void> fnfsub=new TestSubscriber<>(0L);\nfnfSubscribers.put(args[2],fnfsub);\nidToType.put(args[2],args[1]);\nReactiveSocket fnfclient=createClient.get();\nPublisher<Void> fnfpub=fnfclient.fireAndForget(new PayloadImpl(args[3],args[4]));\nfnfpub.subscribe(fnfsub);\nbreak;\ndefault :\nbreak;\n}\n}\n", "docstring": "this function takes in the arguments for the subscribe command , and subscribes an instance of testsubscriber with an initial request of 0 ( which means don \"'\" t immediately make a request ) to an instance of the corresponding publisher", "partition": "test"}
{"idx": "1363", "code": "public boolean isInside(Point point){\n  return bounds.contains(point);\n}\n", "docstring": "returns true if the point is inside this sprite . uses board coordinates , not screen coordinates . by default , just checks our bounding rectangle , though some sprites override this for a smaller sensitive area .", "partition": "test"}
{"idx": "101", "code": "private static final void waitForEditorToBeActive(IEditorPart internalFileEditor,IWorkbenchPage page){\n  long start=System.currentTimeMillis();\n  long end=start;\n  do {\n    end=System.currentTimeMillis();\n  }\n while (page.getActiveEditor() != internalFileEditor && (end - start) < 5000);\n  if (page.getActiveEditor() != internalFileEditor)   logger.warn(\"selected editor was not activated within timout\");\n}\n", "docstring": "get editor for provided file , returns once editor is active or after timeout", "partition": "test"}
{"idx": "2538", "code": "@AssistedInject public RunnerImpl(@NotNull RunnerLocalizationConstant locale,@NotNull RunnerCounter runnerCounter,@NotNull GetEnvironmentsUtil util,@NotNull @Assisted RunOptions runOptions,@NotNull @Assisted Scope environmentScope,@Nullable @Assisted String environmentName){\n  this.runOptions=runOptions;\n  this.ram=runOptions.getMemorySize();\n  this.title=RUNNER_NAME + runnerCounter.getRunnerNumber() + (environmentName == null ? \"\" : \" - \" + getCorrectName(environmentName));\n  this.activeTab=locale.runnerTabConsole();\n  this.status=IN_QUEUE;\n  this.scope=environmentScope;\n  creationTime=System.currentTimeMillis();\n  String environmentId=runOptions.getEnvironmentId();\n  if (environmentId == null || environmentId.startsWith(\"project:/\")) {\n    this.type=util.getType();\n  }\n else {\n    this.type=util.getCorrectCategoryName(runOptions.getEnvironmentId());\n  }\n  if (environmentId != null) {\n    runOptions.setEnvironmentId(environmentId);\n  }\n}\n", "docstring": "this runner needs runner options ( user configurations ) and environment name ( inputted by user ) . it analyzes all given information and get necessary information .", "partition": "test"}
{"idx": "385", "code": "public ShortInterleavedRaster(SampleModel sampleModel,DataBuffer dataBuffer,Point origin){\n  this(sampleModel,dataBuffer,new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}\n", "docstring": "constructs a shortinterleavedraster with the given samplemodel and databuffer . the raster \"'\" s upper left corner is origin and it is the same sizes the samplemodel . the databuffer is not initialized and must be a databufferushort compatible with samplemodel . samplemodel must be of type pixelinterleavedsamplemodel or singlepixelpackedsamplemodel .", "partition": "test"}
{"idx": "2219", "code": "@Nullable private Operator.Kind parseOperator(TokenStream tokens){\n  if (tokens.has(\"=\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.EQUALS;\n  }\n  if (tokens.has(\"!\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.NOT_EQUALS;\n  }\n  if (tokens.has(\"<\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.LESS_EQUAL;\n    }\n    return Operator.Kind.LESS;\n  }\n  if (tokens.has(\">\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.GREATER_EQUAL;\n    }\n    return Operator.Kind.GREATER;\n  }\n  return null;\n}\n", "docstring": "check for and get an operator kind .", "partition": "test"}
{"idx": "1532", "code": "public void update(List<Race> races){\n  if (currentRace == null) {\n    return;\n  }\n  if (races.contains(currentRace)) {\n    setRace(races.get(races.indexOf(currentRace)));\n  }\n}\n", "docstring": "give this list of races , whereas the dialog picks out the one it currently has open ( if present ) .", "partition": "test"}
{"idx": "3135", "code": "private final void resetDTX(AffineTransform at){\n  fsref=null;\n  dtx=at;\n  invdtx=null;\n  if (!dtx.isIdentity()) {\n    try {\n      invdtx=dtx.createInverse();\n    }\n catch (    NoninvertibleTransformException e) {\n    }\n  }\n  if (gti != null) {\n    gti.strikesRef=null;\n  }\n}\n", "docstring": "change the dtx for the strike refs we use . keeps a reference to the at . at must not contain translation . called by setrendertransform , setdtx , initfontdata .", "partition": "test"}
{"idx": "1882", "code": "private boolean isAnnotation(){\n  return implInterfaces.contains(\"java.lang.annotation.Annotation\");\n}\n", "docstring": "sees if the class under test is actually an annotation .", "partition": "test"}
{"idx": "3079", "code": "public byte[] readBytes() throws IOException {\n  int len=readInt();\n  if (len == -1) {\n    return null;\n  }\n  byte[] b=DataUtils.newBytes(len);\n  in.readFully(b);\n  return b;\n}\n", "docstring": "read a byte array .", "partition": "test"}
{"idx": "2713", "code": "public static void openOtherUri(final String url,final Activity activity){\n  Intent intent=new Intent(Intent.ACTION_VIEW,Uri.parse(url));\n  activity.startActivity(intent);\n}\n", "docstring": "start the application in browser to see the url or choose by other application to view this uri", "partition": "test"}
{"idx": "1632", "code": "public static <T>T instance(Class<T> clazz){\n  try {\n    return clazz.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "docstring": "creates a new instance of the class represented by the given class object", "partition": "test"}
{"idx": "2721", "code": "public void performActions() throws Throwable {\n  for (  Throwing.Runnable action : actions) {\n    action.run();\n  }\n}\n", "docstring": "runs the commands that have been queued up .", "partition": "test"}
{"idx": "1325", "code": "private static void expandNumberAt(String numberString,int startIndex,WordRelation wordRelation){\n  expandNumber(numberString.substring(startIndex,numberString.length()),wordRelation);\n}\n", "docstring": "returns the number string list of the given string starting at the given index . e . g . , expandnumberat ( \" 1100 \" , 1 ) gives \" one hundred \"", "partition": "test"}
{"idx": "2680", "code": "private void cleanupMinidumpFile(){\n  if (!CrashFileManager.tryMarkAsUploaded(mFileToUpload)) {\n    Log.w(TAG,\"Unable to mark \" + mFileToUpload + \" as uploaded.\");\n    if (!mFileToUpload.delete()) {\n      Log.w(TAG,\"Cannot delete \" + mFileToUpload);\n    }\n  }\n}\n", "docstring": "mark file we just uploaded for cleanup later . we do not immediately delete the file for testing reasons , but if marking the file fails , we do delete it right away .", "partition": "test"}
{"idx": "3715", "code": "public int generateChallengeToken(InetSocketAddress address){\n  int token=random.nextInt();\n  challengeTokens.put(address,token);\n  return token;\n}\n", "docstring": "generate a new token .", "partition": "test"}
{"idx": "4143", "code": "private static void deserializeHeader(KdbHeader kdbHeader,DataInput dataInput) throws IOException {\n  kdbHeader.setFlags(dataInput.readInt());\n  kdbHeader.setVersion(dataInput.readInt());\n  byte[] buffer=new byte[16];\n  dataInput.readFully(buffer);\n  kdbHeader.setMasterSeed(buffer);\n  buffer=new byte[16];\n  dataInput.readFully(buffer);\n  kdbHeader.setEncryptionIv(buffer);\n  kdbHeader.setGroupCount(dataInput.readInt());\n  kdbHeader.setEntryCount(dataInput.readInt());\n  byte[] buffer32=new byte[32];\n  dataInput.readFully(buffer32);\n  kdbHeader.setContentHash(buffer32);\n  buffer32=new byte[32];\n  dataInput.readFully(buffer32);\n  kdbHeader.setTransformSeed(buffer32);\n  kdbHeader.setTransformRounds(dataInput.readInt());\n}\n", "docstring": "deserialize a header from a source into the supplied kdbheader", "partition": "test"}
{"idx": "2835", "code": "public static String decode(String encoded,AMEncryption encr){\n  if (checkCaller()) {\n    try {\n      ISSecurityPermission isp=new ISSecurityPermission(\"access\",\"adminpassword\");\n      if (securityManager != null) {\n        securityManager.checkPermission(isp);\n      }\n    }\n catch (    SecurityException e) {\n      Debug debug=Debug.getInstance(\"amSDK\");\n      debug.error(\"Security Alert: Unauthorized access to \" + \"Encoding/Decoding password utility: Returning NULL\",e);\n      return null;\n    }\n  }\n  if (encoded == null || encoded.length() == 0) {\n    return (null);\n  }\n  byte[] encData=null;\n  encData=Base64.decode(encoded.trim());\n  if (encData == null) {\n    return null;\n  }\n  byte[] rawData=encr.decrypt(encData);\n  if (rawData == null) {\n    return (null);\n  }\n  String answer=null;\n  try {\n    answer=new String(rawData,\"utf-8\");\n  }\n catch (  UnsupportedEncodingException uue) {\n    Debug debug=Debug.getInstance(\"amSDK\");\n    debug.error(\"Crypt:: Unsupported encoding UTF-8\",uue);\n    answer=new String(rawData);\n  }\n  return (answer);\n}\n", "docstring": "decode an encoded string", "partition": "test"}
{"idx": "2460", "code": "@SuppressWarnings(\"ResultOfMethodCallIgnored\") public static void pipeInputToOutputStream(InputStream in,File fileOut,boolean ignoreErrors) throws IOException {\n  if (fileOut == null) {\n    logger.error(\"The output filename doesn\\'t exist or is invalid\");\n    if (!ignoreErrors) {\n      throw new IOException(\"The output filename doesn\\'t exist or is invalid\");\n    }\n  }\n else {\n    File parent=fileOut.getParentFile();\n    if (parent != null && !parent.exists()) {\n      parent.mkdirs();\n    }\n    OutputStream fileStream=null;\n    try {\n      fileStream=new FileOutputStream(fileOut);\n      pipeInputToOutputStream(in,fileStream,true,ignoreErrors);\n    }\n catch (    IOException e) {\n      if (fileStream != null) {\n        try {\n          fileStream.close();\n        }\n catch (        IOException ex) {\n          logger.error(\"Cannot close stream - {}\",ex.getMessage());\n        }\n      }\n      if (!ignoreErrors) {\n        throw e;\n      }\n    }\n  }\n}\n", "docstring": "convenient way of sending data from an input stream to an output file in the most efficient way possible", "partition": "test"}
{"idx": "814", "code": "void addLocation(String location){\n  if (fLocationList.contains(location)) {\n    return;\n  }\n  fLocationList.add(location);\n  fTableViewer.refresh();\n  fTableViewer.setChecked(location,true);\n  fTableViewer.setSelection(new StructuredSelection(location));\n  validateLocations();\n}\n", "docstring": "adds the given location to the table", "partition": "test"}
{"idx": "4205", "code": "public final String readUTF() throws IOException {\n  return decodeUTF(readUnsignedShort());\n}\n", "docstring": "see the general contract of the readutf method of datainput . bytes for this operation are read from the contained input stream .", "partition": "test"}
{"idx": "3217", "code": "public static final String toString(String str){\n  if (str == null)   return \"null\";\n  ByteArrayOutputStream buffer=new ByteArrayOutputStream();\n  toByteArray(buffer,str);\n  return buffer.toString();\n}\n", "docstring": "provides a java string literal representing the parameter string . this includes surrounding double quotes , and quoted special characters , including utf escape sequences when necessary . < p > this function works only for ascii character encoding , and assumes this is the default encoding .", "partition": "test"}
{"idx": "1051", "code": "public void saveIndexes(){\n  ArrayList toSave=new ArrayList();\nsynchronized (this) {\n    Object[] valueTable=this.indexes.valueTable;\n    for (int i=0, l=valueTable.length; i < l; i++) {\n      Index index=(Index)valueTable[i];\n      if (index != null)       toSave.add(index);\n    }\n  }\n  boolean allSaved=true;\n  for (int i=0, length=toSave.size(); i < length; i++) {\n    Index index=(Index)toSave.get(i);\n    ReadWriteMonitor monitor=index.monitor;\n    if (monitor == null)     continue;\n    try {\n      monitor.enterRead();\n      if (index.hasChanged()) {\n        if (monitor.exitReadEnterWrite()) {\n          try {\n            saveIndex(index);\n          }\n catch (          IOException e) {\n            if (JobManager.VERBOSE) {\n              Util.verbose(\"-> got the following exception while saving:\",System.err);\n              e.printStackTrace();\n            }\n            allSaved=false;\n          }\n finally {\n            monitor.exitWriteEnterRead();\n          }\n        }\n else {\n          allSaved=false;\n        }\n      }\n    }\n  finally {\n      monitor.exitRead();\n    }\n  }\n  if (this.participantsContainers != null && this.participantUpdated) {\n    writeParticipantsIndexNamesFile();\n    this.participantUpdated=false;\n  }\n  this.needToSave=!allSaved;\n}\n", "docstring": "commit all index memory changes to disk", "partition": "test"}
{"idx": "3965", "code": "private boolean checkDisband(Legion legion){\n  if (legion.isDisbanding()) {\n    if ((System.currentTimeMillis() / 1000) > legion.getDisbandTime()) {\n      disbandLegion(legion);\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "method that checks if a legion is disbanding", "partition": "test"}
{"idx": "2868", "code": "public StrBuilder replace(int startIndex,int endIndex,String replaceStr){\n  endIndex=validateRange(startIndex,endIndex);\n  int insertLen=(replaceStr == null ? 0 : replaceStr.length());\n  replaceImpl(startIndex,endIndex,endIndex - startIndex,replaceStr,insertLen);\n  return this;\n}\n", "docstring": "replaces a portion of the string builder with another string . the length of the inserted string does not have to match the removed length .", "partition": "test"}
{"idx": "399", "code": "public static boolean containsInLineFeatures(StyledLayerDescriptor sld){\n  if (sld != null) {\n    for (    StyledLayer layer : sld.layers()) {\n      if (layer instanceof UserLayer) {\n        UserLayer userLayer=(UserLayer)layer;\n        if (userLayer.getInlineFeatureDatastore() != null) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "checks to see if sld contains inline features .", "partition": "test"}
{"idx": "1065", "code": "private ODataFeed readFeedLogPerf(String query,Map<String,String> params) throws IOException, ODataException {\n  long delta_time=System.currentTimeMillis();\n  ODataFeed feed=client.readFeed(query,params);\n  log(Level.DEBUG,\"query(\" + query + \") done in \"+ delta_time+ \"ms\");\n  return feed;\n}\n", "docstring": "logs how much time an odata command consumed .", "partition": "test"}
{"idx": "2160", "code": "public static SourceDataQuality fromXML(Element domElement){\n  NodeList fields=domElement.getChildNodes();\n  int fieldsCount=fields.getLength();\n  String fieldName;\n  String fieldValueString;\n  Node fieldNode;\n  SourceDataQuality result=new SourceDataQuality();\n  for (int i=0; i != fieldsCount; i++) {\n    fieldNode=fields.item(i);\n    if (fieldNode.getNodeType() == Node.ELEMENT_NODE) {\n      fieldName=fieldNode.getNodeName();\n      Node fieldValueNode=fieldNode.getFirstChild();\n      if (fieldValueNode != null) {\n        fieldValueString=fieldValueNode.getNodeValue();\n      }\n else {\n        fieldValueString=\"\";\n      }\n      if (fieldName.equals(XML_ELEMENT_QUALITY_CODE)) {\n        result.qualityCode=Short.parseShort(fieldValueString);\n      }\n else       if (fieldName.equals(XML_ELEMENT_QUALITY_DESC)) {\n        result.description=fieldValueString;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "create a sourcedataquality object from its xml representation . the format of the xml required is determined by the output of the toxml ( ) method .", "partition": "test"}
{"idx": "3710", "code": "private static String trimVersion(String apiVersion){\n  if (apiVersion == null) {\n    return null;\n  }\n else {\n    String[] versionParts=apiVersion.split(\"/\");\n    return versionParts[versionParts.length - 1];\n  }\n}\n", "docstring": "separates apiversion for apigroup / apiversion combination .", "partition": "test"}
{"idx": "3300", "code": "public Currency read(String symbol){\n  return Currency.getInstance(symbol);\n}\n", "docstring": "this method is used to convert the string value given to an appropriate representation . this is used when an object is being deserialized from the xml document and the value for the string representation is required .", "partition": "test"}
{"idx": "3757", "code": "public HoltWintersModelBuilder alpha(double alpha){\n  this.alpha=alpha;\n  return this;\n}\n", "docstring": "alpha controls the smoothing of the data . alpha = 1 retains no memory of past values ( e . g . a random walk ) , while alpha = 0 retains infinite memory of past values ( e . g . the series mean ) . useful values are somewhere in between . defaults to 0 . 5 .", "partition": "test"}
{"idx": "2042", "code": "@Override public void paint(final PPaintContext ppc){\n  final Paint paint=getPaint();\n  if (paint != null) {\n    final Graphics2D g2=ppc.getGraphics();\n    final PBounds bounds=getUnionOfChildrenBounds(null);\n    if (fillBackground) {\n      g2.setPaint(backgroundColor);\n      g2.fillRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding);\n    }\n    if (drawOutline) {\n      g2.setPaint(lineColor);\n      g2.drawRoundRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding,ROUNDING_WIDTH_HEIGHT,ROUNDING_WIDTH_HEIGHT);\n    }\n  }\n}\n", "docstring": "change the default paint to fill an expanded bounding box based on its children \"'\" s bounds .", "partition": "test"}
{"idx": "375", "code": "ObservedObject createObservedObject(ObjectName object){\n  return new ObservedObject(object);\n}\n", "docstring": "factory method for observedobject creation .", "partition": "test"}
{"idx": "1625", "code": "public void addCheckBoxActionListener(ActionListener al){\n  m_enableDistributedExperiment.addActionListener(al);\n}\n", "docstring": "enable objects to listen for changes to the check box", "partition": "test"}
{"idx": "152", "code": "private static int numInitialSplits(long numRecords){\n  final int maxSplits=100;\n  final long recordsPerSplit=10000;\n  return (int)Math.min(maxSplits,numRecords / recordsPerSplit + 1);\n}\n", "docstring": "pick a number of initial splits based on the number of records expected to be processed .", "partition": "test"}
{"idx": "2122", "code": "public static String stringOfChar(char ch,int count){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < count; i++) {\n    buf.append(ch);\n  }\n  return buf.toString();\n}\n", "docstring": "returns a string of the given length consisting entirely of the given character", "partition": "test"}
{"idx": "2511", "code": "public OrionEditorInit(final TextEditorConfiguration configuration,final CodeAssistantFactory codeAssistantFactory,final QuickAssistAssistant quickAssist,final OrionEditorPresenter textEditor){\n  this.configuration=configuration;\n  this.codeAssistantFactory=codeAssistantFactory;\n  this.quickAssist=quickAssist;\n  this.textEditor=textEditor;\n}\n", "docstring": "the quick assist assistant .", "partition": "test"}
{"idx": "1645", "code": "public static long readUINT32(InputStream stream) throws IOException {\n  long result=0;\n  for (int i=0; i <= 24; i+=8) {\n    result|=(long)stream.read() << i;\n  }\n  return result;\n}\n", "docstring": "reads 4 bytes from stream and interprets them as uint32 . < br >", "partition": "test"}
{"idx": "3335", "code": "private void reflectMemberVariablesInFinalButton(){\n  final boolean lastPageReached=(viewPager.getCurrentItem() + 1) == pages.size();\n  final boolean buttonShouldBeInvisible=!lastPageReached || finalButtonDisabled;\n  final boolean buttonIsCurrentlyInvisible=finalButton.getVisibility() == View.INVISIBLE;\n  final boolean shouldUpdateButton=buttonShouldBeInvisible != buttonIsCurrentlyInvisible;\n  if (shouldUpdateButton) {\n    final Animator buttonAnimator=buttonShouldBeInvisible ? buttonAnimatorFactory.newFinalButtonDisappearAnimator(finalButton) : buttonAnimatorFactory.newFinalButtonAppearAnimator(finalButton);\n    if (buttonShouldBeInvisible) {\n      disableButton(buttonAnimator,finalButton);\n    }\n else {\n      enableButton(buttonAnimator,finalButton);\n    }\n  }\n}\n", "docstring": "enables or disables the final button , so that it matches the current member variables .", "partition": "test"}
{"idx": "242", "code": "public int hashCode(){\n  int h=hash;\n  if (h == -1) {\n    try {\n      h=Arrays.hashCode(X509CertImpl.getEncodedInternal(this));\n    }\n catch (    CertificateException e) {\n      h=0;\n    }\n    hash=h;\n  }\n  return h;\n}\n", "docstring": "returns a hashcode value for this certificate from its encoded form .", "partition": "test"}
{"idx": "2879", "code": "public String toZString(){\n  StringBuilder buffer=new StringBuilder(32);\n  try {\n    printZ(buffer);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Exception printing to StringBuilder\",e);\n  }\n  return buffer.toString();\n}\n", "docstring": "returns the string representation ( in ion format ) of this timestamp in utc .", "partition": "test"}
{"idx": "515", "code": "public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  int vocabSize=in.readInt();\n  for (int i=0; i < vocabSize; i++) {\n    String line=in.readUTF();\n    Vocabulary.id(line);\n  }\n  numTokens=in.readDouble();\n  countFuncs=new long[in.readInt()][2];\n  for (int i=0; i < countFuncs.length; i++) {\n    countFuncs[i][0]=in.readLong();\n    countFuncs[i][1]=in.readLong();\n  }\n  typesFuncs=new long[in.readInt()][2];\n  for (int i=0; i < typesFuncs.length; i++) {\n    typesFuncs[i][0]=in.readLong();\n    typesFuncs[i][1]=in.readLong();\n  }\n  quantizationBase=in.readDouble();\n  bf=new BloomFilter();\n  bf.readExternal(in);\n}\n", "docstring": "read a bloom filter lm from an external file .", "partition": "test"}
{"idx": "2990", "code": "public HeadRule(String dir,String rule){\n  String[] tmp=P_TAGSETS.split(rule);\n  int i, size=tmp.length;\n  b_r2l=dir.equals(DIR_RIGHT_TO_LEFT);\n  a_tagSets=new HeadTagSet[size];\n  for (i=0; i < size; i++)   a_tagSets[i]=new HeadTagSet(tmp[i]);\n}\n", "docstring": "constructs a new headrule by decoding the specific head tagsets .", "partition": "test"}
{"idx": "542", "code": "public static String fromTag(IntArrayTag tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  int value : tag.getValue()) {\n    IntTag i=new IntTag(value);\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromTag(i));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}\n", "docstring": "creates a mojangson string from the given intarray tag .", "partition": "test"}
{"idx": "3557", "code": "protected void reply(RequestContext context,String key,String message){\n  try {\n    HttpServletRequest request=context.getRequest();\n    String filename=request.getRemoteAddr();\n    end(filename,key,message);\n  }\n catch (  Exception e) {\n  }\n}\n", "docstring": "emits an \" end \" line for a successful reply .", "partition": "test"}
{"idx": "4080", "code": "public InvitationStatus waitInvitationAnswer(){\n  return waitInvitationAnswer(mRingingPeriod);\n}\n", "docstring": "wait session invitation answer", "partition": "test"}
{"idx": "2826", "code": "private char[] applyFloatPadding(final char[] ca4,final boolean noDigits){\n  char[] ca5=ca4;\n  if (fieldWidthSet) {\n    int i;\n    int j;\n    final int nBlanks;\n    if (leftJustify) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        for (i=0; i < ca4.length; i++) {\n          ca5[i]=ca4[i];\n        }\n        for (j=0; j < nBlanks; j++, i++) {\n          ca5[i]=' ';\n        }\n      }\n    }\n else     if (!leadingZeros || noDigits) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        for (i=0; i < nBlanks; i++) {\n          ca5[i]=' ';\n        }\n        for (j=0; j < ca4.length; i++, j++) {\n          ca5[i]=ca4[j];\n        }\n      }\n    }\n else     if (leadingZeros) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        i=0;\n        j=0;\n        if (ca4[0] == '-') {\n          ca5[0]='-';\n          i++;\n          j++;\n        }\n        for (int k=0; k < nBlanks; i++, k++) {\n          ca5[i]='0';\n        }\n        for (; j < ca4.length; i++, j++) {\n          ca5[i]=ca4[j];\n        }\n      }\n    }\n  }\n  return ca5;\n}\n", "docstring": "apply zero or blank , left or right padding .", "partition": "test"}
{"idx": "223", "code": "public boolean verifyServerEvidenceMessage(BigInteger serverM2) throws CryptoException {\n  if ((this.A == null) || (this.M1 == null) || (this.S == null)) {\n    throw new CryptoException(\"Impossible to compute and verify M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\n  }\n  BigInteger computedM2=SRP6Util.calculateM2(digest,N,A,M1,S);\n  if (computedM2.equals(serverM2)) {\n    this.M2=serverM2;\n    return true;\n  }\n  return false;\n}\n", "docstring": "authenticates the server evidence message m2 received and saves it only if correct .", "partition": "test"}
{"idx": "3076", "code": "public Key(byte[] hash){\n  if (hash.length != SHA1_HASH_LENGTH) {\n    throw new IllegalArgumentException(\"Invalid Hash must be 20bytes, was: \" + hash.length);\n  }\n  System.arraycopy(hash,0,this.hash,0,SHA1_HASH_LENGTH);\n}\n", "docstring": "creates a key with this hash", "partition": "test"}
{"idx": "3336", "code": "public void testDecoder6(){\n  boolean res;\n  String originalAppIdName=mAppIdName;\n  int originalContentTypeValue=mContentTypeValue;\n  Random rd=new Random();\n  for (int i=0; i < OMA_APPLICATION_ID_NAMES.length; i++) {\n    mAppIdName=OMA_APPLICATION_ID_NAMES[i];\n    mContentTypeValue=rd.nextInt(0x0FFF);\n    byte[] pdu=createPDU(6);\n    WspTypeDecoder pduDecoder=new WspTypeDecoder(pdu);\n    res=pduDecoder.seekXWapApplicationId(mWspHeaderStart,mWspHeaderStart + mWspHeaderLen - 1);\n    assertTrue(res);\n    int index=(int)pduDecoder.getValue32();\n    res=pduDecoder.decodeXWapApplicationId(index);\n    assertTrue(res);\n    Log.d(LOG_TAG,\"mAppIdValue: [\" + mAppIdName + \"], val: [\"+ pduDecoder.getValueString()+ \"]\");\n    assertTrue(mAppIdName.equals(pduDecoder.getValueString()));\n  }\n  mAppIdName=originalAppIdName;\n  mContentTypeValue=originalContentTypeValue;\n}\n", "docstring": "wsptypedecoder test , decode string appid test", "partition": "test"}
{"idx": "1194", "code": "public void balanceSegments(){\n  MAcctSchemaElement[] elements=m_acctSchema.getAcctSchemaElements();\n  for (int i=0; i < elements.length; i++) {\n    MAcctSchemaElement ase=elements[i];\n    if (ase.isBalanced())     balanceSegment(ase.getElementType());\n  }\n}\n", "docstring": "balance all segments . - for all balancing segments - for all segment values - if balance < > 0 create dueto / duefrom line overwriting the segment value", "partition": "test"}
{"idx": "1283", "code": "protected synchronized void received(int responseCode,String stream,String json){\n  FollowerInfo result=parseFollowers(stream,json);\n  if (result != null) {\n    noError(stream);\n    cached.put(stream,result);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(result);\n      if (hasNewFollowers(result.followers)) {\n        listener.newFollowers(result);\n      }\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(result);\n    }\n    requested.add(stream);\n  }\n else {\n    String errorMessage=\"\";\n    if (responseCode == 404) {\n      errorMessage=\"Channel not found.\";\n      error(stream,10);\n    }\n else     if (responseCode == 200) {\n      errorMessage=\"Parse error.\";\n      error(stream,1);\n    }\n else     if (responseCode == 401 || responseCode == 403) {\n      errorMessage=\"Access denied.\";\n      error(stream,1);\n    }\n else     if (responseCode == 422) {\n      errorMessage=\"No data for this channel.\";\n      error(stream,10);\n    }\n else {\n      errorMessage=\"Request error.\";\n      error(stream,1);\n    }\n    FollowerInfo errorResult=new FollowerInfo(type,stream,errorMessage);\n    cached.put(stream,errorResult);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(errorResult);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(errorResult);\n    }\n  }\n}\n", "docstring": "received data from the api , so parse it or handle a possible error , then give it to the listener .", "partition": "test"}
{"idx": "3353", "code": "public void addListener(final ProjectorListener projectorListener){\n  if (listeners == null) {\n    listeners=new ArrayList<ProjectorListener>();\n  }\n  listeners.add(projectorListener);\n}\n", "docstring": "add a projector listener .", "partition": "test"}
{"idx": "1089", "code": "public static float mean(float[] data,int startIndex,int endIndex){\n  float mean=0;\n  int total=0;\n  startIndex=Math.max(startIndex,0);\n  startIndex=Math.min(startIndex,data.length - 1);\n  endIndex=Math.max(endIndex,0);\n  endIndex=Math.min(endIndex,data.length - 1);\n  if (startIndex > endIndex)   startIndex=endIndex;\n  for (int i=startIndex; i <= endIndex; i++) {\n    if (Float.isNaN(data[i]))     throw new IllegalArgumentException(\"NaN not allowed in mean calculation\");\n    mean+=data[i];\n    total++;\n  }\n  mean/=total;\n  return mean;\n}\n", "docstring": "compute the mean of all elements in the array . no missing values ( nan ) are allowed .", "partition": "test"}
{"idx": "2424", "code": "public static String readFileAsString(File file) throws FileNotFoundException {\n  return readFileAsString(file.getAbsolutePath());\n}\n", "docstring": "devuelve el contenido de un file como string", "partition": "test"}
{"idx": "444", "code": "private String stripCodeValueSentences(String string){\n  return string.replaceAll(\"This result code corresponds to the LDAP result code value of \\\\\\\\{@code \\\\\\\\d+\\\\\\\\}.\",\"\");\n}\n", "docstring": "returns a string with lines sentences of the following form removed : this result code corresponds to the ldap result code value of & # x7b ; & # x40 ; code 0 & # x7d ; .", "partition": "test"}
{"idx": "2534", "code": "private void notifyActivityStateChanged(Bundle bundle){\n  if (!mRecords.isEmpty()) {\n    Log.d(TAG,\"notifyActivityStatusChanged:clients = \" + mRecords.size());\nsynchronized (mRecords) {\n      Iterator<Record> iterator=mRecords.iterator();\n      while (iterator.hasNext()) {\n        Record record=(Record)iterator.next();\n        FmRadioListener listener=record.mCallback;\n        if (listener == null) {\n          iterator.remove();\n          return;\n        }\n        listener.onCallBack(bundle);\n      }\n    }\n  }\n}\n", "docstring": "call back from service to activity", "partition": "test"}
{"idx": "912", "code": "private void analyzeClassFields(String className,int action){\n  try {\n    Class<?> dynamicClass=Class.forName(className);\n    Field[] fields=dynamicClass.getDeclaredFields();\n    for (    Field field : fields) {\n      if (isPrivateAndNonPrimitive(field)) {\n        oneToAnyConditions(className,field,action);\n        manyToAnyConditions(className,field,action);\n      }\n    }\n  }\n catch (  ClassNotFoundException ex) {\n    ex.printStackTrace();\n    throw new DatabaseGenerateException(DatabaseGenerateException.CLASS_NOT_FOUND + className);\n  }\n}\n", "docstring": "introspection of the passed in class . analyze the fields of current class and find out the associations of it .", "partition": "test"}
{"idx": "4163", "code": "public static String toString(Accountable a){\n  StringBuilder sb=new StringBuilder();\n  toString(sb,a,0);\n  return sb.toString();\n}\n", "docstring": "returns a string description of an accountable and any nested resources . this is intended for development and debugging .", "partition": "test"}
{"idx": "2474", "code": "private String partiallyEscapeAssertionValue(String assertionValue){\n  StringBuilder sb=new StringBuilder(assertionValue.length());\n  for (int j=0; j < assertionValue.length(); j++) {\n    char c=assertionValue.charAt(j);\n    if (c == '*') {\n      sb.append(c);\n    }\n else {\n      sb.append(Filter.escapeAssertionValue(String.valueOf(c)));\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "escapes the provided assertion value according to the ldap standard . as a special case this method does not escape the \"'\" * \"'\" character , in order to be able to use wildcards in filters .", "partition": "test"}
{"idx": "1198", "code": "public static int putInt(byte[] bytes,int offset,int val){\n  if (littleEndian) {\n    val=Integer.reverseBytes(val);\n  }\n  theUnsafe.putInt(bytes,offset + BYTE_ARRAY_BASE_OFFSET,val);\n  return offset + Bytes.SIZEOF_INT;\n}\n", "docstring": "put an int value out to the specified byte array position in big - endian format .", "partition": "test"}
{"idx": "3416", "code": "public static void saveXStream(File saveTo,Object model,Instances header) throws Exception {\n  Vector<Object> v=new Vector<Object>();\n  v.add(model);\n  if (header != null) {\n    v.add(header);\n  }\n  v.trimToSize();\n  XStream.write(saveTo.getAbsolutePath(),v);\n}\n", "docstring": "save a model in xstream deep object serialized xml form .", "partition": "test"}
{"idx": "2073", "code": "public Object take() throws InterruptedException, ForceReattemptException {\n  throw new UnsupportedOperationException();\n}\n", "docstring": "it removes the first key from the queue .", "partition": "test"}
{"idx": "2670", "code": "boolean removeEdge(SparseEdge e){\n  boolean removedEdge=edges.remove(e);\n  boolean removedNeighbour=neighbours.remove(e.getOpposite(this));\n  if (removedEdge && removedNeighbour)   return true;\n else   if (!removedEdge && !removedNeighbour)   return false;\n else   throw new RuntimeException(\"Graph connectivity appears to be inconsitent!\");\n}\n", "docstring": "disconnects this vertex from an edge .", "partition": "test"}
{"idx": "325", "code": "private static int showUrlsPrompt(Component parent,List<String> urls){\n  String text=\"<html><body style=\\'width: 100px;\\'>\";\n  for (  String url : urls) {\n    url=splitUrl(url);\n    text+=url + \"<br />\";\n  }\n  String okOption=\"Open URL\";\n  if (urls.size() > 1) {\n    okOption=\"Open \" + urls.size() + \" URLs\";\n  }\n  String[] options={okOption,\"Cancel\"};\n  if (urls.size() == 1) {\n    options=new String[]{okOption,\"Copy URL\",\"Cancel\"};\n  }\n  int chosenOption=JOptionPane.showOptionDialog(parent,text,\"Open in default browser?\",JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,1);\n  return chosenOption;\n}\n", "docstring": "actually show the dialog that contain the given urls and give the user the option to open the url , copy it or cancel the dialog .", "partition": "test"}
{"idx": "3729", "code": "private static boolean test(ODatabaseDocumentPool pool,String dbURL,String user,String password,boolean finalTry){\n  ODatabaseDocumentTx db=null;\n  try {\n    logger.info(\"Verifying the DB.\");\n    db=pool.acquire(dbURL,user,password);\n    Iterator<ODocument> iter=db.browseClass(\"config\");\n    if (iter.hasNext()) {\n      iter.next();\n    }\n  }\n catch (  OException ex) {\n    if (finalTry) {\n      logger.info(\"Exceptions encountered in verifying the DB\",ex);\n    }\n else {\n      logger.debug(\"DB exception in testing.\",ex);\n    }\n    return false;\n  }\n finally {\n    if (db != null) {\n      db.close();\n    }\n  }\n  return true;\n}\n", "docstring": "perform a basic access on the db for a rudimentary test", "partition": "test"}
{"idx": "1293", "code": "public boolean zoneExportRemoveVolumes(List<NetworkZoningParam> zoningParams,Collection<URI> volumeURIs,String stepId){\n  NetworkZoningParam zoningParam=zoningParams.get(0);\n  _log.info(String.format(\"Entering zoneExportRemoveVolumes for ExportGroup: %s Volumes: %s\",zoningParam.getExportGroupDisplay(),volumeURIs.toString()));\n  return doZoneExportMasksDelete(zoningParams,volumeURIs,stepId);\n}\n", "docstring": "removes the indicated volumes from the zones given by the zoning parameters . if the fczonereferences for a zone are all removed ( and there are no existing volumes in the associated export mask ) , the zones will be removed from switch .", "partition": "test"}
{"idx": "1191", "code": "public boolean peekSample(MediaCodec.BufferInfo out_bufferInfo){\n  update();\n  boolean result=false;\n  if (!mAvailableOutputBuffers.isEmpty()) {\n    int index=mAvailableOutputBuffers.peek();\n    MediaCodec.BufferInfo info=mOutputBufferInfo[index];\n    out_bufferInfo.set(info.offset,info.size,info.presentationTimeUs,info.flags);\n    result=true;\n  }\n  return result;\n}\n", "docstring": "performs a peek ( ) operation in the queue to extract media info for the buffer ready to be released i . e . the head element of the queue .", "partition": "test"}
{"idx": "362", "code": "public boolean init(){\n  log.config(\"\");\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = \\'Y\\' \"+ \"                 AND p.IsActive = \\'Y\\' \"+ \"                 AND l.IsActive = \\'Y\\' \"+ \"                 AND cl.IsActive = \\'Y\\' \"+ \"                 AND pp.ASP_Status = \\'S\\') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = \\'Y\\' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = \\'S\\') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = \\'Y\\' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = \\'H\\')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive=\\'Y\\' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language=\\'\" + Env.getAD_Language(Env.getCtx()) + \"\\'\"+ \" AND p.IsActive=\\'Y\\' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  Rows rows=new Rows();\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs,rows);\n      isPair=!isPair;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_wEditors.size() || m_mFields2.size() != m_wEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    centerPanel.appendChild(rows);\n    dynamicDisplay();\n  }\n else   dispose();\n  return hasFields;\n}\n", "docstring": "read fields to display", "partition": "test"}
{"idx": "1307", "code": "protected void computePDists(Relation<O> relation,KNNQuery<O> knn,WritableDoubleDataStore pdists){\n  FiniteProgress prdsProgress=LOG.isVerbose() ? new FiniteProgress(\"pdists\",relation.size(),LOG) : null;\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    final KNNList neighbors=knn.getKNNForDBID(iditer,kreach + 1);\n    int ks=0;\n    double ssum=0.;\n    for (DoubleDBIDListIter neighbor=neighbors.iter(); neighbor.valid() && ks < kreach; neighbor.advance()) {\n      if (DBIDUtil.equal(neighbor,iditer)) {\n        continue;\n      }\n      final double d=neighbor.doubleValue();\n      ssum+=d * d;\n      ks++;\n    }\n    double pdist=ks > 0 ? Math.sqrt(ssum / ks) : 0.;\n    pdists.putDouble(iditer,pdist);\n    LOG.incrementProcessed(prdsProgress);\n  }\n  LOG.ensureCompleted(prdsProgress);\n}\n", "docstring": "compute the probabilistic distances used by loop .", "partition": "test"}
{"idx": "2758", "code": "protected void addTags(E data,Builder builder){\n  PlatformIdent platformIdent=cachedDataService.getPlatformIdentForId(data.getPlatformIdent());\n  builder.tag(Series.TAG_AGENT_ID,String.valueOf(data.getPlatformIdent()));\n  if (null != platformIdent) {\n    builder.tag(Series.TAG_AGENT_NAME,platformIdent.getAgentName());\n  }\n}\n", "docstring": "adds needed tags related to the data to the builder . when overriding sub - classes should call super first .", "partition": "test"}
{"idx": "1323", "code": "public static List seriesNameListFromDataArray(Object[][] data){\n  int seriesCount=data.length;\n  List seriesNameList=new java.util.ArrayList(seriesCount);\n  for (int i=0; i < seriesCount; i++) {\n    seriesNameList.add(\"Series \" + (i + 1));\n  }\n  return seriesNameList;\n}\n", "docstring": "utility method for automatically generating series names .", "partition": "test"}
{"idx": "2932", "code": "public void delete(String name) throws IOException {\n  if (name.equalsIgnoreCase(SUBJECT_NAME)) {\n    names=null;\n  }\n else {\n    throw new IOException(\"Attribute name not recognized by \" + \"CertAttrSet:SubjectAlternativeName.\");\n  }\n  encodeThis();\n}\n", "docstring": "delete the attribute value .", "partition": "test"}
{"idx": "619", "code": "public static boolean isAndroidSdkDirInLocalPropertiesFile(@NotNull File projectDir){\n  String androidHome=getAndroidHomeFromLocalPropertiesFile(projectDir);\n  if (!Strings.isNullOrEmpty(androidHome)) {\n    String msg=String.format(\"Found Android SDK home at \\'%1$s\\' (from local.properties file)\",androidHome);\n    LOG.info(msg);\n    return true;\n  }\n  return false;\n}\n", "docstring": "indicates whether the path of the android sdk home directory is specified in a local . properties file .", "partition": "test"}
{"idx": "1594", "code": "public Map<String,String> parse(final String str,char separator){\n  if (str == null) {\n    return new HashMap<>();\n  }\n  return parse(str.toCharArray(),separator);\n}\n", "docstring": "extracts a map of name / value pairs from the given string . names are expected to be unique .", "partition": "test"}
{"idx": "3268", "code": "public static String rightPad(String s,int minLength,char filling){\n  int ln=s.length();\n  if (minLength <= ln) {\n    return s;\n  }\n  StringBuilder res=new StringBuilder(minLength);\n  res.append(s);\n  int dif=minLength - ln;\n  for (int i=0; i < dif; i++) {\n    res.append(filling);\n  }\n  return res.toString();\n}\n", "docstring": "pads the string at the right with the specified character until it reaches the desired length . if the string is longer than this length , then it returns the unchanged string .", "partition": "test"}
{"idx": "3515", "code": "GradleException formatViolationsFor(Formatter formatter,List<File> problemFiles) throws IOException {\n  return new GradleException(DiffMessageFormatter.messageFor(this,formatter,problemFiles));\n}\n", "docstring": "returns an exception which indicates problem files nicely .", "partition": "test"}
{"idx": "1984", "code": "public Pair<Integer,List<Long>> next(){\n  try {\n    classesProcessed++;\n    Integer key=iterator.next();\n    long pos=classificationBlockRMA2.getPos(key);\n    int count=classificationBlockRMA2.getSum(key);\n    classDumpReader.seek(pos);\n    List<Long> list=new LinkedList<>();\n    for (int i=0; i < count; i++)     list.add(classDumpReader.readLong());\n    return new Pair<>(key,list);\n  }\n catch (  Exception e) {\n    Basic.caught(e);\n    error=true;\n    return null;\n  }\n}\n", "docstring": "returns the next element in the iteration .", "partition": "test"}
{"idx": "925", "code": "public StatefulRefreshToken(JsonValue token) throws InvalidGrantException {\n  super(token);\n  if (!OAUTH_REFRESH_TOKEN.equals(getTokenName())) {\n    throw new InvalidGrantException(\"Token is not an refresh token: \" + getTokenId());\n  }\n}\n", "docstring": "constructs a new refreshtoken backed with the data in the specified jsonvalue .", "partition": "test"}
{"idx": "3339", "code": "private RelyingParty validateRelyingParty(HttpServletRequest request,String tenantName){\n  Validate.notNull(request,\"request\");\n  Validate.notEmpty(tenantName,\"tenantName\");\n  DefaultIdmAccessorFactory idmFactory=new DefaultIdmAccessorFactory();\n  Validate.notNull(idmFactory,\"idmFactory\");\n  IdmAccessor idmAccessor=idmFactory.getIdmAccessor();\n  idmAccessor.setTenant(tenantName);\n  String encodedEntityId=request.getParameter(Shared.RELYINGPARTY_ENTITYID);\n  if (encodedEntityId == null || encodedEntityId.isEmpty()) {\n    logger.error(\"No Relying Party\\'s entity ID found. Ignore the request!\");\n    return null;\n  }\n  String rpEntityId=new String(Base64.decode(encodedEntityId));\n  RelyingParty rp=idmAccessor.getRelyingPartyByUrl(rpEntityId);\n  if (rp != null) {\n    return rp;\n  }\n else {\n    logger.error(\"Unknown relying party: \" + rpEntityId);\n    return null;\n  }\n}\n", "docstring": "this method validates the relying party .", "partition": "test"}
{"idx": "3695", "code": "@Override public boolean load(final Player player,final List<String> args){\n  groovyBinding.setVariable(\"player\",player);\n  if (args != null) {\n    groovyBinding.setVariable(\"args\",args.toArray(new String[args.size()]));\n  }\n else {\n    groovyBinding.setVariable(\"args\",new String[0]);\n  }\n  final GroovyShell interp=new GroovyShell(groovyBinding);\n  boolean ret=true;\n  preExecute(player,args);\n  try {\n    final File f=new File(groovyScript);\n    interp.evaluate(f);\n  }\n catch (  final Exception e) {\n    logger.error(\"Exception while sourcing file \" + groovyScript,e);\n    setMessage(e.getMessage());\n    ret=false;\n  }\ncatch (  final Error e) {\n    logger.error(\"Exception while sourcing file \" + groovyScript,e);\n    setMessage(e.getMessage());\n    ret=false;\n  }\n  postExecute(player,args,ret);\n  return (ret);\n}\n", "docstring": "initial load of this script .", "partition": "test"}
{"idx": "29", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection with respect to the named event", "partition": "test"}
{"idx": "32", "code": "public QuickActionView addActions(Collection<Action> actions){\n  checkShown();\n  mActions.addAll(actions);\n  return this;\n}\n", "docstring": "adds a collection of actions to the quickactionview", "partition": "test"}
{"idx": "2164", "code": "@Override public synchronized void addDataSourceListener(DataSourceListener dsl){\n  m_dataSourceListeners.addElement(dsl);\n  if (m_format != null) {\n    DataSetEvent e=new DataSetEvent(this,m_format);\n    dsl.acceptDataSet(e);\n  }\n}\n", "docstring": "add a datasource listener", "partition": "test"}
{"idx": "1664", "code": "public String toString(){\n  String str=\"\";\n  String followedBy=\"\";\n  int lastType=-1;\n  String lastString=\"\";\n  int singlesCount=0;\n  for (Enumeration e=formatConstraints.elements(); e.hasMoreElements(); ) {\n    FormatConstraint constraint=(FormatConstraint)e.nextElement();\n    if (constraint.count == FormatConstraint.COUNT_EXACTLY_ONE) {\n      if (lastType != -1) {\n        if (lastType != constraint.type) {\n          str+=followedBy + singlesCount + lastString;\n          followedBy=\" followed by \";\n          singlesCount=1;\n          lastType=constraint.type;\n          lastString=constraint.toString();\n        }\n else {\n          singlesCount++;\n        }\n      }\n else {\n        lastType=constraint.type;\n        lastString=constraint.toString();\n        singlesCount=1;\n      }\n    }\n else {\n      if (lastType != -1) {\n        str+=followedBy + singlesCount + lastString;\n        followedBy=\" followed by \";\n        lastType=-1;\n        singlesCount=0;\n        lastString=\"\";\n      }\n      str+=followedBy + constraint.toString();\n      followedBy=\" followed by \";\n    }\n  }\n  if (lastType != -1) {\n    str+=followedBy + singlesCount + lastString;\n  }\n  return str;\n}\n", "docstring": "a printout of a user - friendly string describing the format", "partition": "test"}
{"idx": "1236", "code": "private void decideUILookAndFeel(MainOptions options){\n  try {\n    boolean systemPlaf=false;\n    systemPlaf=options.system_plaf;\n    String systemPlafReq=System.getenv(\"systemplaf\");\n    if (systemPlafReq != null && systemPlafReq.equalsIgnoreCase(\"true\"))     systemPlaf=true;\n    if (systemPlaf)     UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n  }\n catch (  Exception exc) {\n    exc.printStackTrace();\n  }\n}\n", "docstring": "normally the look and feel should be the standard one , java , allow to set the systemplaf to have the system look and feel", "partition": "test"}
{"idx": "3992", "code": "@Override protected void drawXLabels(List<Double> xLabels,Double[] xTextLabelLocations,Canvas canvas,Paint paint,int left,int top,int bottom,double xPixelsPerUnit,double minX,double maxX){\n  int length=xLabels.size();\n  if (length > 0) {\n    boolean showLabels=mRenderer.isShowLabels();\n    boolean showGridY=mRenderer.isShowGridY();\n    DateFormat format=getDateFormat(xLabels.get(0),xLabels.get(length - 1));\n    for (int i=0; i < length; i++) {\n      long label=Math.round(xLabels.get(i));\n      float xLabel=(float)(left + xPixelsPerUnit * (label - minX));\n      if (showLabels) {\n        paint.setColor(mRenderer.getXLabelsColor());\n        canvas.drawLine(xLabel,bottom,xLabel,bottom + mRenderer.getLabelsTextSize() / 3,paint);\n        drawText(canvas,format.format(new Date(label)),xLabel,bottom + mRenderer.getLabelsTextSize() * 4 / 3,paint,mRenderer.getXLabelsAngle());\n      }\n      if (showGridY) {\n        paint.setColor(mRenderer.getGridColor());\n        canvas.drawLine(xLabel,bottom,xLabel,top,paint);\n      }\n    }\n  }\n  drawXTextLabels(xTextLabelLocations,canvas,paint,true,left,top,bottom,xPixelsPerUnit,minX,maxX);\n}\n", "docstring": "the graphical representation of the labels on the x axis .", "partition": "test"}
{"idx": "178", "code": "public void deleteObligation(final Obligation obligation,int basicBlockId) throws ObligationAcquiredOrReleasedInLoopException {\n  Map<ObligationSet,State> updatedStateMap=new HashMap<ObligationSet,State>();\n  for (Iterator<State> i=stateIterator(); i.hasNext(); ) {\n    State state=i.next();\n    checkCircularity(state,obligation,basicBlockId);\n    ObligationSet obligationSet=state.getObligationSet();\n    obligationSet.remove(obligation);\n    if (!obligationSet.isEmpty()) {\n      updatedStateMap.put(obligationSet,state);\n    }\n  }\n  replaceMap(updatedStateMap);\n}\n", "docstring": "remove an obligation from every state in the stateset .", "partition": "test"}
{"idx": "691", "code": "private void clear(){\n  valid=false;\n  if ((listenerObjects == null) || listenerObjects.isEmpty()) {\n    deregisterListener();\n  }\n  ssm=null;\n  if (SMSEntry.cacheSMSEntries) {\n    orgConfigs.clear();\n    globalConfigs.clear();\n  }\n}\n", "docstring": "clears instance cache and deregisters listeners", "partition": "test"}
{"idx": "3637", "code": "public boolean canSpawnWorkers(){\n  boolean canSpawnWorker=false;\n  if (verboseLogLevel > 5) {\n    Utilities.verboseLog(\"canSpawnWorkers - gridName: \" + gridName + \" tier : \"+ tier+ \" maxTierDepth: \"+ maxTierDepth+ \" lifeRemaing: \"+ lifeRemaining()+ \" maximumLifeMillis: \"+ maximumLifeMillis);\n  }\n  if (!gridName.equals(\"lsf\")) {\n    return false;\n  }\n  if (clusterState != null) {\n    Long timeSinceClusterLastUpdatedClusterState=System.currentTimeMillis() - clusterState.getLastUpdated();\n    Utilities.verboseLog(\"timeSinceClusterLastUpdatedClusterState: \" + timeSinceClusterLastUpdatedClusterState);\n    if (timeSinceClusterLastUpdatedClusterState > 2 * gridCheckInterval * 1000) {\n      Utilities.verboseLog(\"ClusterState is not uptodate:\" + clusterState.toString());\n      return false;\n    }\n  }\n else {\n    return false;\n  }\n  if (tier == maxTierDepth) {\n    return false;\n  }\n  if (lifeRemaining() < (maximumLifeMillis * 0.25)) {\n    return false;\n  }\nswitch (tier) {\ncase 1:\n    canSpawnWorker=true;\n  break;\ncase 2:\ncanSpawnWorker=true;\nbreak;\ncase 3:\ncanSpawnWorker=true;\nbreak;\ncase 4:\ncanSpawnWorker=true;\nbreak;\ndefault :\nif (gridThrottle) {\ncanSpawnWorker=false;\n}\n else {\ncanSpawnWorker=true;\n}\n}\nreturn canSpawnWorker;\n}\n", "docstring": "check if this worker can spawn any worker", "partition": "test"}
{"idx": "4222", "code": "@Deprecated public static EpisodeMatchingResult detectEpisodeFromFilename(File file){\n  LOGGER.debug(\"Detect episodes/seasons from file \" + file.getName());\n  EpisodeMatchingResult result=new EpisodeMatchingResult();\n  String fileName=file.getName();\n  result=parseString(fileName);\n  Collections.sort(result.episodes);\n  Matcher matcher=stackingMarkerPattern.matcher(result.name);\n  result.stackingMarkerFound=matcher.matches();\n  LOGGER.debug(\"returning result \" + result);\n  return result;\n}\n", "docstring": "detect episode from filename .", "partition": "test"}
{"idx": "1100", "code": "private void checkPermission(Object object,NamespacePermissionEnum[] permissions,List<AccessDeniedException> accessDeniedExceptions){\n  if (object != null) {\n    if (object instanceof Collection) {\n      Collection<?> collection=(Collection<?>)object;\n      for (      Object element : collection) {\n        checkPermission(element,permissions,accessDeniedExceptions);\n      }\n    }\n else     if (object instanceof String) {\n      try {\n        checkPermission((String)object,permissions);\n      }\n catch (      AccessDeniedException accessDeniedException) {\n        accessDeniedExceptions.add(accessDeniedException);\n      }\n    }\n else {\n      throw new IllegalStateException(String.format(\"Object must be of type %s or %s. Actual object.class = %s\",String.class,Collection.class,object.getClass()));\n    }\n  }\n}\n", "docstring": "checks the current user \"'\" s permissions against the given object which may represent a single or multiple namespaces . allowed types are string or collection of string .", "partition": "test"}
{"idx": "1404", "code": "public static double parseDoubleDefault(String s,double def){\n  if (s == null) {\n    return def;\n  }\n  try {\n    return Double.parseDouble(s);\n  }\n catch (  NumberFormatException e) {\n    return def;\n  }\n}\n", "docstring": "parses a double safely , returning a default if nothing can be sanely parsed from it .", "partition": "test"}
{"idx": "1798", "code": "public AddressLookup(String serverUrl,String serialNo,String password){\n  this.serverUrl=serverUrl.trim();\n  this.clientID=serialNo.trim();\n  this.accessCode=password.trim();\n}\n", "docstring": "creates a new instance of addresslookup .", "partition": "test"}
{"idx": "1622", "code": "public List<String> listMyDBs(String owner,boolean restricted){\n  Connection conn=null;\n  try {\n    conn=getConnection();\n    return listMyDBs(conn,owner,restricted);\n  }\n catch (  Exception ex) {\n    logger.log(Level.SEVERE,\"Exception\",ex);\n  }\n finally {\n    DBUtils.close(conn);\n  }\n  return null;\n}\n", "docstring": "list database groups the specific user has provided passwords", "partition": "test"}
{"idx": "1753", "code": "public static String format(String message,Object[] arguments){\n  return MessageFormat.format(message,arguments);\n}\n", "docstring": "formats the given string with the given argument .", "partition": "test"}
{"idx": "2276", "code": "public void testParseClientHandshake() throws Exception {\n  for (int splitPos=1; splitPos < 5; splitPos++) {\n    log.info(\"Checking split position: \" + splitPos);\n    ByteBuffer tmp=clientHandshakePacket();\n    ByteBuffer[] split=split(tmp,splitPos);\n    GridNioSession ses=new MockNioSession();\n    ses.addMeta(MARSHALLER.ordinal(),new GridClientOptimizedMarshaller());\n    GridTcpRestParser parser=new GridTcpRestParser(false);\n    Collection<GridClientMessage> lst=new ArrayList<>(1);\n    for (    ByteBuffer buf : split) {\n      GridClientMessage r;\n      while (buf.hasRemaining() && (r=parser.decode(ses,buf)) != null)       lst.add(r);\n      assertTrue(\"Parser has left unparsed bytes.\",buf.remaining() == 0);\n    }\n    assertEquals(1,lst.size());\n    GridClientHandshakeRequest req=(GridClientHandshakeRequest)F.first(lst);\n    assertNotNull(req);\n    assertEquals(U.bytesToShort(new byte[]{5,0},0),req.version());\n  }\n}\n", "docstring": "tests correct parsing of client handshake packets .", "partition": "test"}
{"idx": "2082", "code": "private void replaceCollapsedEdges(){\n  List newEdges=new ArrayList();\n  for (Iterator it=edgeList.iterator(); it.hasNext(); ) {\n    Edge e=(Edge)it.next();\n    if (e.isCollapsed()) {\n      it.remove();\n      newEdges.add(e.getCollapsedEdge());\n    }\n  }\n  edgeList.addAll(newEdges);\n}\n", "docstring": "if edges which have undergone dimensional collapse are found , replace them with a new edge which is a l edge", "partition": "test"}
{"idx": "1110", "code": "protected final void updateBorderText(final String text){\n  Preconditions.checkNotNull(text,\"IE01842: Text argument can not be null\");\n  m_titledBorder.setTitle(text);\n  updateUI();\n}\n", "docstring": "updates the border text of the component .", "partition": "test"}
{"idx": "973", "code": "public void serialize(KXmlSerializer serializer) throws IOException {\n  mDeviceInfo.serialize(serializer);\n  serializeHostInfo(serializer);\n  serializeTestSummary(serializer);\n  monkeyTag.serialize(serializer);\n  List<TestPackageResult> pkgs=new ArrayList<TestPackageResult>(mPackageMap.values());\n  Collections.sort(pkgs,new PkgComparator());\n  for (  TestPackageResult r : pkgs) {\n    r.serialize(serializer);\n  }\n}\n", "docstring": "serialize the test results to xml .", "partition": "test"}
{"idx": "20", "code": "protected boolean validate(final char[] component,final int soffset,int eoffset,final BitSet generous){\n  if (eoffset == -1) {\n    eoffset=component.length - 1;\n  }\n  for (int i=soffset; i <= eoffset; i++) {\n    if (!generous.get(component[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "validate the uri characters within a specific component . the component must be performed after escape encoding . or it doesn \"'\" t include escaped characters . < p > it \"'\" s not that much strict , generous . the strict validation might be performed before being called this method .", "partition": "test"}
{"idx": "756", "code": "public static void copyToClipboard(Transferable t){\n  ClipboardHelper.copyToClipboard(t);\n}\n", "docstring": "copies the given transferable to the system \"'\" s clipboard .", "partition": "test"}
{"idx": "765", "code": "public void deleteEntityConfig(String realm,String federationId) throws WSFederationMetaException {\n  if (federationId == null) {\n    return;\n  }\n  if (realm == null) {\n    realm=\"/\";\n  }\n  String[] objs={federationId,realm};\n  try {\n    Map oldAttrs=configInst.getConfiguration(realm,federationId);\n    Set oldValues=(Set)oldAttrs.get(ATTR_ENTITY_CONFIG);\n    if (oldValues == null || oldValues.isEmpty()) {\n      LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_DESCRIPTOR_DELETE_ENTITY_CONFIG,objs,null);\n      throw new WSFederationMetaException(\"entity_config_not_exist\",objs);\n    }\n    IDPSSOConfigElement idpconfig=getIDPSSOConfig(realm,federationId);\n    if (idpconfig != null) {\n      removeFromCircleOfTrust(idpconfig,realm,federationId);\n    }\n    SPSSOConfigElement spconfig=getSPSSOConfig(realm,federationId);\n    if (spconfig != null) {\n      removeFromCircleOfTrust(spconfig,realm,federationId);\n    }\n    Set attr=new HashSet();\n    attr.add(ATTR_ENTITY_CONFIG);\n    configInst.deleteConfiguration(realm,federationId,attr);\n    LogUtil.access(Level.INFO,LogUtil.ENTITY_CONFIG_DELETED,objs,null);\n    WSFederationMetaCache.putEntityConfig(realm,federationId,null);\n  }\n catch (  ConfigurationException e) {\n    debug.error(\"WSFederationMetaManager.deleteEntityConfig:\",e);\n    String[] data={e.getMessage(),federationId,realm};\n    LogUtil.error(Level.INFO,LogUtil.CONFIG_ERROR_DELETE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(e);\n  }\n}\n", "docstring": "deletes the extended entity configuration under the realm .", "partition": "test"}
{"idx": "617", "code": "public Location newLocation(String name){\n  Location location=getLocationByName(name);\n  if (location == null) {\n    _id++;\n    location=new Location(Integer.toString(_id),name);\n    Integer oldSize=Integer.valueOf(_locationHashTable.size());\n    _locationHashTable.put(location.getId(),location);\n    setDirtyAndFirePropertyChange(LISTLENGTH_CHANGED_PROPERTY,oldSize,Integer.valueOf(_locationHashTable.size()));\n  }\n  return location;\n}\n", "docstring": "finds an existing location or creates a new location if needed requires location \"'\" s name creates a unique id for this location", "partition": "test"}
{"idx": "3260", "code": "ModulePointer resolve(String modName){\n  return (ModulePointer)context.get(modName);\n}\n", "docstring": "find the modulepointer that the string modname resolves to ; return null if either modname is not found in the context or if it is found and resolves to null , i . e . is not yet resolved .", "partition": "test"}
{"idx": "743", "code": "public static Configuration load(Reader reader) throws IOException {\n  try {\n    Properties properties=new Properties();\n    properties.load(reader);\n    return from(properties);\n  }\n  finally {\n    reader.close();\n  }\n}\n", "docstring": "obtain a configuration instance by loading the properties from the supplied reader .", "partition": "test"}
{"idx": "2866", "code": "@Override public boolean equals(Object o){\n  return o.hashCode() == hashCode();\n}\n", "docstring": "returns true if the object is a complex effect with an identical content", "partition": "test"}
{"idx": "2472", "code": "void remove(SuperCardToast superCardToast){\n  mList.remove(superCardToast);\n}\n", "docstring": "removes a supercardtoast from the list .", "partition": "test"}
{"idx": "901", "code": "public void removeCustomSashFormListener(ICustomSashFormListener listener){\n  if (customSashFormListeners != null) {\n    customSashFormListeners.remove(listener);\n  }\n}\n", "docstring": "removes the custom sashform listener .", "partition": "test"}
{"idx": "684", "code": "public HeldLocksGrant refresh(long expirationDateMs){\n  return new HeldLocksGrant(grantId,creationDateMs,expirationDateMs,lockMap,lockTimeout,versionId);\n}\n", "docstring": "this should only be called by the lock service . calling this method won \"'\" t actually refresh the grant .", "partition": "test"}
{"idx": "3188", "code": "private static SSLSocketFactory trustAllHosts(HttpsURLConnection connection){\n  SSLSocketFactory oldFactory=connection.getSSLSocketFactory();\n  try {\n    SSLContext sc=SSLContext.getInstance(\"TLS\");\n    sc.init(null,trustAllCerts,new java.security.SecureRandom());\n    SSLSocketFactory newFactory=sc.getSocketFactory();\n    connection.setSSLSocketFactory(newFactory);\n  }\n catch (  Exception e) {\n    LOG.e(LOG_TAG,e.getMessage(),e);\n  }\n  return oldFactory;\n}\n", "docstring": "this function will install a trust manager that will blindly trust all ssl certificates . the reason this code is being added is to enable developers to do development using self signed ssl certificates on their web server . the standard httpsurlconnection class will throw an exception on self signed certificates if this code is not run .", "partition": "test"}
{"idx": "671", "code": "public void consume(int eventCount,long timeoutInMillis,Predicate<Event> condition) throws TimeoutException {\n  if (eventCount < 0)   throw new IllegalArgumentException(\"The eventCount may not be negative\");\n  if (eventCount == 0)   return;\n  int eventsRemaining=eventCount;\n  final long stopTime=System.currentTimeMillis() + timeoutInMillis;\n  while (eventsRemaining > 0 && System.currentTimeMillis() < stopTime) {\n    Event nextEvent=queue.poll();\n    if (nextEvent != null) {\n      if (condition.test(nextEvent)) {\n        --eventsRemaining;\n        consumedEvents.accept(nextEvent);\n      }\n else {\n        ignoredEvents.accept(nextEvent);\n      }\n    }\n  }\n  if (eventsRemaining > 0) {\n    throw new TimeoutException(\"Received \" + (eventCount - eventsRemaining) + \" of \"+ eventCount+ \" in \"+ timeoutInMillis+ \"ms\");\n  }\n}\n", "docstring": "blocks until the listener has consume the specified number of matching events , blocking at most the specified number of milliseconds . if this method has not reached the number of matching events and comes across events that do not satisfy the predicate , those events are consumed and ignored .", "partition": "test"}
{"idx": "1996", "code": "private Node<K,V> findNode(Object key){\n  if (key == null)   throw new NullPointerException();\n  Comparator<? super K> cmp=comparator;\n  outer:   for (; ; ) {\n    for (Node<K,V> b=findPredecessor(key,cmp), n=b.next; ; ) {\n      Object v;\n      int c;\n      if (n == null)       break outer;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      if ((v=n.value) == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (b.value == null || v == n)       break;\n      if ((c=cpr(cmp,key,n.key)) == 0)       return n;\n      if (c < 0)       break outer;\n      b=n;\n      n=f;\n    }\n  }\n  return null;\n}\n", "docstring": "returns node holding key or null if no such , clearing out any deleted nodes seen along the way . repeatedly traverses at base - level looking for key starting at predecessor returned from findpredecessor , processing base - level deletions as encountered . some callers rely on this side - effect of clearing deleted nodes . restarts occur , at traversal step centered on node n , if : ( 1 ) after reading n \"'\" s next field , n is no longer assumed predecessor b \"'\" s current successor , which means that we don \"'\" t have a consistent 3 - node snapshot and so cannot unlink any subsequent deleted nodes encountered . ( 2 ) n \"'\" s value field is null , indicating n is deleted , in which case we help out an ongoing structural deletion before retrying . even though there are cases where such unlinking doesn \"'\" t require restart , they aren \"'\" t sorted out here because doing so would not usually outweigh cost of restarting . ( 3 ) n is a marker or n \"'\" s predecessor \"'\" s value field is null , indicating ( among other possibilities ) that findpredecessor returned a deleted node . we can \"'\" t unlink the node because we don \"'\" t know its predecessor , so rely on another call to findpredecessor to notice and return some earlier predecessor , which it will do . this check is only strictly needed at beginning of loop , ( and the b . value check isn \"'\" t strictly needed at all ) but is done each iteration to help avoid contention with other threads by callers that will fail to be able to change links , and so will retry anyway . the traversal loops in doput , doremove , and findnear all include the same three kinds of checks . and specialized versions appear in findfirst , and findlast and their variants . they can \"'\" t easily share code because each uses the reads of fields held in locals occurring in the orders they were performed .", "partition": "test"}
{"idx": "3282", "code": "public static void writeFixInt32(final OutputStream output,final int val) throws IOException {\n  output.write((val >>> 24) & 0xFF);\n  output.write((val >>> 16) & 0xFF);\n  output.write((val >>> 8) & 0xFF);\n  output.write(val & 0xFF);\n}\n", "docstring": "write a fixed - width 32 bit integer in network byte order ( big - endian ) .", "partition": "test"}
{"idx": "1077", "code": "public void removeEventListener(ZWaveEventListener eventListener){\nsynchronized (zwaveEventListeners) {\n    zwaveEventListeners.remove(eventListener);\n  }\n}\n", "docstring": "remove a listener for zwave events to this controller .", "partition": "test"}
{"idx": "4078", "code": "private void checkComplianceAttributes(AttrSet attrSet,boolean ignoreCompliance) throws AMException {\n  if (!ignoreCompliance && ComplianceServicesImpl.isComplianceUserDeletionEnabled()) {\n    complianceImpl.verifyAttributes(attrSet);\n  }\n}\n", "docstring": "checks for compliance related attributes if applicable . the check can be over - ridden by setting the ignorecompliance to true", "partition": "test"}
{"idx": "69", "code": "public void testGetTableTypesOrder() throws Exception {\n  DatabaseMetaData dmd=con.getMetaData();\n  ResultSet rs=dmd.getTableTypes();\n  String previousType=\"\";\n  while (rs.next()) {\n    String type=rs.getString(1);\n    assertTrue(type.compareTo(previousType) >= 0);\n    previousType=type;\n  }\n  rs.close();\n}\n", "docstring": "test for bug [ 974036 ", "partition": "test"}
{"idx": "2597", "code": "public synchronized void addMessages(ArrayList<SmsMmsMessage> newMessages){\n  if (newMessages != null) {\n    messages.addAll(0,newMessages);\n    UpdateMessageCount();\n  }\n}\n", "docstring": "add a list of new messages to the end of the current message list .", "partition": "test"}
{"idx": "2477", "code": "public T vertexProcessor(final BiConsumer<Vertex,Map<String,Object>> vertexProcessor){\n  this.vertexProcessor=Optional.ofNullable(vertexProcessor);\n  return extendingClass.cast(this);\n}\n", "docstring": "the function supplied here may be called more than once per vertex depending on the implementation .", "partition": "test"}
{"idx": "2366", "code": "protected int readBlock(){\n  blockSize=read();\n  int n=0;\n  if (blockSize > 0) {\n    try {\n      int count;\n      while (n < blockSize) {\n        count=blockSize - n;\n        rawData.get(block,n,count);\n        n+=count;\n      }\n    }\n catch (    final Exception e) {\n      Log.w(TAG,\"Error Reading Block\",e);\n      status=STATUS_FORMAT_ERROR;\n    }\n  }\n  return n;\n}\n", "docstring": "reads next variable length block from input .", "partition": "test"}
{"idx": "3854", "code": "public boolean isPageInRange(int pageNumber){\n  for (int ind=0; ind < sequenceStarts.size(); ind++) {\n    if (sequenceStarts.get(ind) <= pageNumber && pageNumber <= sequenceEnds.get(ind))     return true;\n  }\n  return false;\n}\n", "docstring": "checks if a given page is present in the range built so far .", "partition": "test"}
{"idx": "2786", "code": "public void computeParameters(){\n  if (ellps == null) {\n    ellps=Ellipsoid.WGS_84;\n  }\n  if (mode == MODE_BELGIUM) {\n    alpha=0.00014204d;\n  }\n else {\n    alpha=0d;\n  }\n  double phi1=ProjMath.degToRad(lambert_sp_one);\n  double phi2=ProjMath.degToRad(lambert_sp_two);\n  double phif=ProjMath.degToRad(referenceLatitude);\n  double e=ellps.ecc;\n  double sinphi;\n  sinphi=Math.sin(phi1);\n  double m1=lambMsfn(sinphi,Math.cos(phi1),e);\n  double t1=lambTsfn(phi1,sinphi,e);\n  if (MoreMath.approximately_equal(phi1,phi2,EPS10)) {\n    n=sinphi;\n  }\n else {\n    sinphi=Math.sin(phi2);\n    double m2=lambMsfn(sinphi,Math.cos(phi2),e);\n    double t2=lambTsfn(phi2,sinphi,e);\n    n=Math.log(m1 / m2) / Math.log(t1 / t2);\n  }\n  F=m1 / (n * Math.pow(t1,n));\n  if (MoreMath.approximately_equal(phi1,phi2,EPS10)) {\n    rf=0.0d;\n  }\n else {\n    rf=ellps.radius * F * Math.pow(lambTsfn(phif,Math.sin(phif),e),n);\n  }\n  lamdaf=ProjMath.degToRad(centralMeridian);\n  locationCenterXPixel=((double)getWidth() / 2d);\n  locationCenterYPixel=((double)getHeight() / 2d);\n  locationPixelsPerLambert=(double)getPPM() / getScale();\n  LatLonPoint origin=new LatLonPoint.Double(referenceLatitude,centralMeridian);\n  Point2D lp=LLToWorld(origin.getY(),origin.getX(),new Point2D.Double());\n  locationOriginX=lp.getX();\n  locationOriginY=lp.getY();\n  LatLonPoint center=getCenter();\n  lp=LLToWorld(center.getY(),center.getX(),lp);\n  locationCenterXLambert=lp.getX();\n  locationCenterYLambert=lp.getY();\n  locationOriginXfPixel=locationCenterXPixel + (locationOriginX - locationCenterXLambert) * locationPixelsPerLambert;\n  locationOriginYfPixel=locationCenterYPixel - (locationOriginY - locationCenterYLambert) * locationPixelsPerLambert;\n  if (Debug.debugging(\"Lambert\")) {\n    Debug.output(\"Creating LambertConformal: center x = \" + locationCenterXLambert + \", center y = \"+ locationCenterYLambert);\n    Debug.output(\"Creating LambertConformal: origin x = \" + locationOriginX + \", origin y = \"+ locationOriginY);\n  }\n}\n", "docstring": "called when some fundamental parameters change . < p > each projection will decide how to respond to this change . for instance , they may need to recalculate \" constant \" parameters used in the forward ( ) and inverse ( ) calls . < p >", "partition": "test"}
{"idx": "2505", "code": "private static void lookForChanges(DataObject left,DataObject right,HashMap<String,Change> changes,Set<String> included,Set<String> excluded,Set<String> contained){\n  Class refClass=left.getClass();\n  Method[] methods=refClass.getMethods();\n  for (  Method method : methods) {\n    boolean contain=false;\n    Name nameAnn=method.getAnnotation(Name.class);\n    if (nameAnn == null) {\n      continue;\n    }\n    String key=nameAnn.value();\n    if (contained != null && contained.contains(key)) {\n      contain=true;\n    }\n else     if (included != null && !included.contains(key)) {\n      continue;\n    }\n    if (excluded.contains(key)) {\n      continue;\n    }\n    Class type=method.getReturnType();\n    try {\n      Object obja=method.invoke(left);\n      Object objb=method.invoke(right);\n      if (type == StringSet.class) {\n        if (contain) {\n          analyzeNewStringSetContainsOldStringSetValues((StringSet)obja,(StringSet)objb,key,changes);\n        }\n else {\n          analyzeStringSets((StringSet)obja,(StringSet)objb,key,changes);\n        }\n      }\n else       if (type == StringMap.class) {\n        analyzeStringMaps((StringMap)obja,(StringMap)objb,key,changes);\n      }\n else       if (type == StringSetMap.class) {\n        analyzeStringSetMaps((StringSetMap)obja,(StringSetMap)objb,key,changes);\n      }\n else {\n        if (!isEqual(obja,objb)) {\n          Change change=new Change(key,obja,objb,nameAnn.value());\n          changes.put(key,change);\n        }\n      }\n    }\n catch (    IllegalAccessException ex) {\n      throw new ServiceCodeException(ServiceCode.UNFORSEEN_ERROR,ex,ex.getMessage(),new String[]{});\n    }\ncatch (    InvocationTargetException ex) {\n      throw new ServiceCodeException(ServiceCode.UNFORSEEN_ERROR,ex,ex.getMessage(),new String[]{});\n    }\n  }\n}\n", "docstring": "scans the methods looking for ones annotated with the name annotation . when found ( if not excluded ) , invokes the method on each of the dataobjects and then compares the results .", "partition": "test"}
{"idx": "2830", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return APPKEY;\ncase 2:\n  return SEND_TIME;\ncase 3:\nreturn LOAD_INFO;\ncase 4:\nreturn STATUS;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "2615", "code": "URLClassLoader newLoader(URL base){\n  return new URLClassLoader(new URL[]{base});\n}\n", "docstring": "creates a class loader with the given base url as its classpath .", "partition": "test"}
{"idx": "3275", "code": "@Override public void close() throws IOException {\n  try {\n    out.close();\n  }\n  finally {\n    lockFile.delete();\n  }\n}\n", "docstring": "closes the file writer and deletes the lockfile ( if possible ) .", "partition": "test"}
{"idx": "3347", "code": "public PlaLineInt translate_by(PlaVectorInt p_vector){\n  if (p_vector.equals(PlaVectorInt.ZERO))   return this;\n  PlaPointInt new_a=point_a.translate_by(p_vector);\n  PlaPointInt new_b=point_b.translate_by(p_vector);\n  return new PlaLineInt(new_a,new_b);\n}\n", "docstring": "translates the line by p_vector", "partition": "test"}
{"idx": "3352", "code": "protected byte[] generateSalt(){\n  return HEADER.getBytes(Constants.UTF8);\n}\n", "docstring": "generate the random salt bytes if required .", "partition": "test"}
{"idx": "536", "code": "private void checkDuplicateNamesDuringDelete(List<Integer> ids){\n  ArrayList<Entity> myEntities=game.getPlayerEntities(game.getPlayer(localPlayerNumber),false);\n  Hashtable<String,ArrayList<Integer>> rawNameToId=new Hashtable<String,ArrayList<Integer>>((int)(myEntities.size() * 1.26));\n  for (  Entity e : myEntities) {\n    String rawName=e.getShortNameRaw();\n    ArrayList<Integer> namedIds=rawNameToId.get(rawName);\n    if (namedIds == null) {\n      namedIds=new ArrayList<Integer>();\n    }\n    namedIds.add(e.getId());\n    rawNameToId.put(rawName,namedIds);\n  }\n  for (  int id : ids) {\n    Entity removedEntity=game.getEntity(id);\n    if (removedEntity == null) {\n      continue;\n    }\n    String removedRawName=removedEntity.getShortNameRaw();\n    Integer count=duplicateNameHash.get(removedEntity.getShortNameRaw());\n    if ((count != null) && (count > 1)) {\n      ArrayList<Integer> namedIds=rawNameToId.get(removedRawName);\n      for (      Integer i : namedIds) {\n        Entity e=game.getEntity(i);\n        String eRawName=e.getShortNameRaw();\n        if (eRawName.equals(removedRawName) && (e.duplicateMarker > removedEntity.duplicateMarker)) {\n          e.duplicateMarker--;\n          e.generateShortName();\n          e.generateDisplayName();\n          if (!ids.contains(e.getId())) {\n            sendUpdateEntity(e);\n          }\n        }\n      }\n      duplicateNameHash.put(removedEntity.getShortNameRaw(),new Integer(count - 1));\n    }\n else     if (count != null) {\n      duplicateNameHash.remove(removedEntity.getShortNameRaw());\n    }\n  }\n}\n", "docstring": "if we remove an entity , we may need to update the duplicate identifier .", "partition": "test"}
{"idx": "2196", "code": "void rememberFactory(String host,RMISocketFactory factory){\nsynchronized (successTable) {\n    while (hostList.size() >= MaxRememberedHosts) {\n      successTable.remove(hostList.elementAt(0));\n      hostList.removeElementAt(0);\n    }\n    hostList.addElement(host);\n    successTable.put(host,factory);\n  }\n}\n", "docstring": "remember a successful factory for connecting to host . currently , excess hosts are removed from the remembered list using a least recently created strategy .", "partition": "test"}
{"idx": "4104", "code": "public void write(Writer writer) throws Exception {\n  writer.write(toString());\n  writer.flush();\n}\n", "docstring": "writes the current dom document into the given writer .", "partition": "test"}
{"idx": "3584", "code": "private static boolean isOlderThanLeopard(){\n  String version=System.getProperty(\"os.version\");\n  StringTokenizer tk=new StringTokenizer(version,\".\");\n  int major=Integer.parseInt(tk.nextToken());\n  int minor=Integer.parseInt(tk.nextToken());\n  return major == 10 && minor < 6;\n}\n", "docstring": "determines if this is running a mac osx lower than leopard", "partition": "test"}
{"idx": "828", "code": "protected boolean checkProsodicPosition(Element currentRulePart,String prosodicPositionType){\n  NamedNodeMap attNodes=currentRulePart.getAttributes();\n  for (int z=0; z < attNodes.getLength(); z++) {\n    Node el=attNodes.item(z);\n    String currentAtt=el.getNodeName();\n    String currentVal=el.getNodeValue();\n    if (currentAtt.equals(\"type\")) {\n      if (!currentVal.startsWith(\"!\")) {\n        if (!prosodicPositionType.equals(currentVal))         return false;\n      }\n else {\n        currentVal=currentVal.substring(1,currentVal.length());\n        if (prosodicPositionType.equals(currentVal))         return false;\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "checks rule part with tag \" prosodicposition \" ; there is only the \" type \" attribute right now : checks if prosodic position of a token is the same as the value of the type attribute in the rule ; values : prenuclear , nuclearparagraphfinal , nuclearparagraphnonfinal , postnuclear", "partition": "test"}
{"idx": "247", "code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }\n", "docstring": "transfer all the sequences listed in the supplied file , interpreting entries appropriately .", "partition": "test"}
{"idx": "3373", "code": "private ImageIcon addColor(ImageIcon icon,Color color){\n  if (icon == null || color == null) {\n    return icon;\n  }\n  BufferedImage newImage=new BufferedImage(icon.getIconWidth(),icon.getIconWidth(),BufferedImage.TYPE_INT_ARGB);\n  Graphics g=newImage.getGraphics();\n  g.setColor(color);\n  g.drawImage(icon.getImage(),0,0,color,null);\n  g.dispose();\n  return new ImageIcon(newImage);\n}\n", "docstring": "adds a background color to the given icon , if an icon and color is actually given , otherwise the original icon is returned .", "partition": "test"}
{"idx": "2006", "code": "public static double max(final double a,final double b){\n  if (a > b) {\n    return a;\n  }\n  if (a < b) {\n    return b;\n  }\n  if (a != b) {\n    return Double.NaN;\n  }\n  long bits=Double.doubleToRawLongBits(a);\n  if (bits == 0x8000000000000000L) {\n    return b;\n  }\n  return a;\n}\n", "docstring": "compute the maximum of two values", "partition": "test"}
{"idx": "3169", "code": "public void exec(String description,String[] baseCommand) throws BackupException {\n  exec(description,baseCommand,null,null,null,false,false);\n}\n", "docstring": "convenience method to execute command without providing input or output .", "partition": "test"}
{"idx": "2766", "code": "public static long[] asLongArray(final List<Long> l){\n  final long[] a=new long[l.size()];\n  for (int i=0; i < a.length; i++) {\n    a[i]=l.get(i);\n  }\n  return a;\n}\n", "docstring": "return list of boxed longs as a primitive array .", "partition": "test"}
{"idx": "2954", "code": "private static Set<String> createCategoriesSet(Set<String> categories){\n  Set<String> result=new HashSet<>();\n  for (  String cat : categories) {\n    result.add(StringUtil.toLowerCase(cat));\n  }\n  return result;\n}\n", "docstring": "creates a new set with the given categories , making them all lowercase in the process . duplicate categories that were only differentiated by case will of course be reduced to one lowercase one by the set .", "partition": "test"}
{"idx": "121", "code": "public static synchronized void indexDocument(CodeIndexDocument codeIndexDocument) throws IOException {\n  Queue<CodeIndexDocument> queue=new ConcurrentLinkedQueue<>();\n  queue.add(codeIndexDocument);\n  indexDocuments(queue);\n  queue=null;\n}\n", "docstring": "possibly better in ultra low memory environments ? reuses the above method by creating a queue with one element and passes it in .", "partition": "test"}
{"idx": "811", "code": "@Override public void bookmarksOrHistoryPicker(ComboViews startView){\n  if (mTabControl.getCurrentWebView() == null) {\n    return;\n  }\n  if (isInCustomActionMode()) {\n    endActionMode();\n  }\n  Bundle extras=new Bundle();\n  extras.putBoolean(BrowserBookmarksPage.EXTRA_DISABLE_WINDOW,!mTabControl.canCreateNewTab());\n  mUi.showComboView(startView,extras);\n}\n", "docstring": "open the go page .", "partition": "test"}
{"idx": "1082", "code": "private static ClassInfo findOrCreateClass(String t){\n  if (!t.endsWith(\"[]\")) {\n    return ClassInfo.findOrCreateClass(t);\n  }\n else {\n    String baseType=t.substring(0,t.indexOf(\"[]\"));\n    int level=(t.length() - t.indexOf(\"[]\")) / 2;\n    String s=\"\";\n    for (int i=0; i < level; ++i)     s+=\"[\";\n    if (baseType.equals(\"int\"))     s+=\"I\";\n else     if (baseType.equals(\"boolean\"))     s+=\"B\";\n else     s+=\"L\" + baseType + \";\";\n    return ClassInfo.findOrCreateClass(s);\n  }\n}\n", "docstring": "convert pscout - style type name to canonical form", "partition": "test"}
{"idx": "1629", "code": "public final V extractFirst(){\n  if (size() > 0) {\n    if (GWT.isScript()) {\n      V ret=jsArray.get(0);\n      jsArray.remove(0);\n      return ret;\n    }\n else {\n      return javaArray.remove(0);\n    }\n  }\n  return null;\n}\n", "docstring": "retrieve the first element and remove it from the list", "partition": "test"}
{"idx": "3175", "code": "public void waitForMessageToArrive(){\n  LOG.info(\"Waiting for message to arrive\");\n  long start=System.currentTimeMillis();\nsynchronized (messages) {\n    try {\n      while (hasReceivedMessage()) {\n        messages.wait(4000);\n      }\n    }\n catch (    InterruptedException e) {\n      LOG.info(\"Caught: \" + e);\n    }\n  }\n  long end=System.currentTimeMillis() - start;\n  LOG.info(\"End of wait for \" + end + \" millis\");\n}\n", "docstring": "use to wait for a single message to arrive .", "partition": "test"}
{"idx": "1993", "code": "public StrBuilder insert(int index,boolean value){\n  validateIndex(index);\n  if (value) {\n    ensureCapacity(size + 4);\n    System.arraycopy(buffer,index,buffer,index + 4,size - index);\n    buffer[index++]='t';\n    buffer[index++]='r';\n    buffer[index++]='u';\n    buffer[index]='e';\n    size+=4;\n  }\n else {\n    ensureCapacity(size + 5);\n    System.arraycopy(buffer,index,buffer,index + 5,size - index);\n    buffer[index++]='f';\n    buffer[index++]='a';\n    buffer[index++]='l';\n    buffer[index++]='s';\n    buffer[index]='e';\n    size+=5;\n  }\n  return this;\n}\n", "docstring": "inserts the value into this builder .", "partition": "test"}
{"idx": "1613", "code": "public void addTickMarkSection(final Section SECTION){\n  if (null == SECTION)   return;\n  tickMarkSections.add(SECTION);\n  Collections.sort(tickMarkSections,new SectionComparator());\n  fireUpdateEvent(REDRAW_EVENT);\n}\n", "docstring": "adds the given section to the list of tickmark sections .", "partition": "test"}
{"idx": "2652", "code": "private void drawHost(Graphics2D g2){\n  Coord loc=node.getLocation();\n  if (drawCoverage && node.isRadioActive()) {\n    ArrayList<NetworkInterface> interfaces=new ArrayList<NetworkInterface>();\n    interfaces.addAll(node.getInterfaces());\n    for (    NetworkInterface ni : interfaces) {\n      double range=ni.getTransmitRange();\n      Ellipse2D.Double coverage;\n      coverage=new Ellipse2D.Double(scale(loc.getX() - range),scale(loc.getY() - range),scale(range * 2),scale(range * 2));\n      g2.setColor(rangeColor);\n      g2.draw(coverage);\n    }\n  }\n  if (drawConnections) {\n    g2.setColor(conColor);\n    Coord c1=node.getLocation();\n    ArrayList<Connection> conList=new ArrayList<Connection>();\n    conList.addAll(node.getConnections());\n    for (    Connection c : conList) {\n      DTNHost otherNode=c.getOtherNode(node);\n      Coord c2;\n      if (otherNode == null) {\n        continue;\n      }\n      c2=otherNode.getLocation();\n      g2.drawLine(scale(c1.getX()),scale(c1.getY()),scale(c2.getX()),scale(c2.getY()));\n    }\n  }\n  g2.setColor(hostColor);\n  g2.drawRect(scale(loc.getX() - 1),scale(loc.getY() - 1),scale(2),scale(2));\n  if (isHighlighted()) {\n    g2.setColor(highlightedNodeColor);\n    g2.fillRect(scale(loc.getX()) - 3,scale(loc.getY()) - 3,6,6);\n  }\n  if (drawNodeName) {\n    g2.setColor(hostNameColor);\n    g2.drawString(node.toString(),scale(loc.getX()),scale(loc.getY()));\n  }\n}\n", "docstring": "visualize node \"'\" s location , radio ranges and connections", "partition": "test"}
{"idx": "711", "code": "public static String expandHiddenDir(final String filename){\n  final int macro=filename.indexOf(hiddenDirMacro,0);\n  String expandedFilter;\n  if (macro == -1) {\n    return filename;\n  }\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expanding macro\");\n  }\n  expandedFilter=filename.replaceFirst(\"\\\\\\\\$dir\\\\\\\\$\",StringUtils.chomp(Path.hidden(),\"/\"));\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expandedFilter: \" + expandedFilter);\n  }\n  return expandedFilter;\n}\n", "docstring": "transforms \" something $ dir $ / other / \" to \" something / path / to / hidden / other / \"", "partition": "test"}
{"idx": "3923", "code": "@SuppressWarnings(\"rawtypes\") public void test_streamAPI(){\n  final List<IBindingSet> expectedSolutions=new ArrayList<IBindingSet>();\n{\n    final IBindingSet expected=new ListBindingSet();\n    expected.set(Var.var(\"x\"),new Constant<IV>(termId));\n    expectedSolutions.add(expected);\n  }\n{\n    final IBindingSet expected=new ListBindingSet();\n    expected.set(Var.var(\"x\"),new Constant<IV>(termId));\n    expected.set(Var.var(\"y\"),new Constant<IV>(blobIV));\n    expectedSolutions.add(expected);\n  }\n  doEncodeDecodeTest(expectedSolutions);\n}\n", "docstring": "unit test of the stream - oriented api .", "partition": "test"}
{"idx": "1942", "code": "public NvpBuilder addRaw(final String name,final String value){\n  npv.put(name,value);\n  return this;\n}\n", "docstring": "add raw name value pair .", "partition": "test"}
{"idx": "4115", "code": "public InputBuilder<T> repeatAll(int times){\n  List<T> toAppend=new ArrayList<>();\n  for (int i=0; i < times; i++) {\n    toAppend.addAll(input);\n  }\n  input.addAll(toAppend);\n  return this;\n}\n", "docstring": "repeat the current input list", "partition": "test"}
{"idx": "1143", "code": "@Nullable GridCacheMvccCandidate addEntry(GridLocalCacheEntry entry) throws GridCacheEntryRemovedException {\n  GridCacheMvccCandidate c=entry.addLocal(threadId,lockVer,null,null,timeout,!inTx(),inTx(),implicitSingle(),true);\n  entries.add(entry);\n  if (c == null && timeout < 0) {\n    if (log.isDebugEnabled())     log.debug(\"Failed to acquire lock with negative timeout: \" + entry);\n    onFailed();\n    return null;\n  }\n  if (c != null) {\n    entry.readyLocal(c);\n  }\n  return c;\n}\n", "docstring": "adds entry to future .", "partition": "test"}
{"idx": "679", "code": "public static int parseString(String value){\n  return Integer.parseInt(value);\n}\n", "docstring": "parse string value returning a int .", "partition": "test"}
{"idx": "75", "code": "public boolean isPDFLicense(){\n  String key=getSummary();\n  return key != null && key.length() > 25;\n}\n", "docstring": "is there a pdf license", "partition": "test"}
{"idx": "3283", "code": "public static void queueCubeLoad(ICubicWorld world,CubeIO loader,CubeProviderServer cache,int x,int y,int z,Consumer<Cube> runnable){\n  QueuedCube key=new QueuedCube(x,y,z,world);\n  AsyncCubeIOProvider task=cubeTasks.get(key);\n  if (task == null) {\n    task=new AsyncCubeIOProvider(key,loader);\n    task.addCallback(runnable);\n    cubeTasks.put(key,task);\n    pool.execute(task);\n  }\n else {\n    task.addCallback(runnable);\n  }\n  Column loadedColumn;\n  if ((loadedColumn=cache.getLoadedColumn(x,z)) == null) {\n    cache.asyncGetColumn(x,z,IProviderExtras.Requirement.LIGHT,null);\n  }\n else {\n    task.setColumn(loadedColumn);\n  }\n}\n", "docstring": "queue a cube load , running the specified callback when the load has finished . this may cause a two tick delay if the column has to be loaded , too ! if you need it faster , consider sync loading either column or both cube and column .", "partition": "test"}
{"idx": "305", "code": "public synchronized static LuaState newLuaState(){\n  int i=getNextStateIndex();\n  LuaState L=new LuaState(i);\n  states.add(i,L);\n  return L;\n}\n", "docstring": "method that creates a new instance of luastate", "partition": "test"}
{"idx": "3176", "code": "public Date(String date){\n  String[] fields=date.split(\"/\");\n  if (fields.length != 3) {\n    throw new IllegalArgumentException(\"Invalid date\");\n  }\n  month=Integer.parseInt(fields[0]);\n  day=Integer.parseInt(fields[1]);\n  year=Integer.parseInt(fields[2]);\n  if (!isValid(month,day,year))   throw new IllegalArgumentException(\"Invalid date\");\n}\n", "docstring": "initializes new date specified as a string in form mm / dd / yyyy .", "partition": "test"}
{"idx": "2461", "code": "public E take() throws InterruptedException {\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null)       available.await();\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n else         if (leader != null)         available.await();\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            available.awaitNanos(delay);\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}\n", "docstring": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .", "partition": "test"}
{"idx": "4081", "code": "private boolean moveWithinSelectedRange(JTable table,int dx,int dy,ListSelectionModel rsm,ListSelectionModel csm){\n  int totalCount;\n  int minX, maxX, minY, maxY;\n  boolean rs=table.getRowSelectionAllowed();\n  boolean cs=table.getColumnSelectionAllowed();\n  if (rs && cs) {\n    totalCount=table.getSelectedRowCount() * table.getSelectedColumnCount();\n    minX=csm.getMinSelectionIndex();\n    maxX=csm.getMaxSelectionIndex();\n    minY=rsm.getMinSelectionIndex();\n    maxY=rsm.getMaxSelectionIndex();\n  }\n else   if (rs) {\n    totalCount=table.getSelectedRowCount();\n    minX=0;\n    maxX=table.getColumnCount() - 1;\n    minY=rsm.getMinSelectionIndex();\n    maxY=rsm.getMaxSelectionIndex();\n  }\n else   if (cs) {\n    totalCount=table.getSelectedColumnCount();\n    minX=csm.getMinSelectionIndex();\n    maxX=csm.getMaxSelectionIndex();\n    minY=0;\n    maxY=table.getRowCount() - 1;\n  }\n else {\n    totalCount=0;\n    minX=maxX=minY=maxY=0;\n  }\n  boolean stayInSelection;\n  if (totalCount == 0 || (totalCount == 1 && table.isCellSelected(leadRow,leadColumn))) {\n    stayInSelection=false;\n    maxX=table.getColumnCount() - 1;\n    maxY=table.getRowCount() - 1;\n    minX=Math.min(0,maxX);\n    minY=Math.min(0,maxY);\n  }\n else {\n    stayInSelection=true;\n  }\n  if (dy == 1 && leadColumn == -1) {\n    leadColumn=minX;\n    leadRow=-1;\n  }\n else   if (dx == 1 && leadRow == -1) {\n    leadRow=minY;\n    leadColumn=-1;\n  }\n else   if (dy == -1 && leadColumn == -1) {\n    leadColumn=maxX;\n    leadRow=maxY + 1;\n  }\n else   if (dx == -1 && leadRow == -1) {\n    leadRow=maxY;\n    leadColumn=maxX + 1;\n  }\n  leadRow=Math.min(Math.max(leadRow,minY - 1),maxY + 1);\n  leadColumn=Math.min(Math.max(leadColumn,minX - 1),maxX + 1);\n  do {\n    calcNextPos(dx,minX,maxX,dy,minY,maxY);\n  }\n while (stayInSelection && !table.isCellSelected(leadRow,leadColumn));\n  return stayInSelection;\n}\n", "docstring": "called to move within the selected range of the given jtable . this method uses the table \"'\" s notion of selection , which is important to allow the user to navigate between items visually selected on screen . this notion may or may not be the same as what could be determined by directly querying the selection models . it depends on certain table properties ( such as whether or not row or column selection is allowed ) . when performing modifications , it is recommended that caution be taken in order to preserve the intent of this method , especially when deciding whether to query the selection models or interact with jtable directly .", "partition": "test"}
{"idx": "526", "code": "public void updateUI(){\n  super.updateUI();\n  setBackground(new Color(255,255,255,0));\n  setWrapStyleWord(true);\n  setHighlighter(null);\n  setEditable(false);\n  LookAndFeel.installBorder(this,\"Label.border\");\n  LookAndFeel.installColorsAndFont(this,\"Label.background\",\"Label.foreground\",\"Label.font\");\n  if (resizeHandler != null) {\n    resizeHandler.componentResized(null);\n  }\n  SizePolicy policy=(SizePolicy)getClientProperty(SizePolicy.class);\n  if (policy != null) {\n    GUIUtils.restrictSize(this,policy);\n  }\n}\n", "docstring": "tells the look and feel to reset some of the values for this component so that it doesn \"'\" t use jtextarea \"'\" s default values . do not call this method yourself !", "partition": "test"}
{"idx": "2010", "code": "private void scheduleCommercial(int length){\n  Long delay=commercialDelay.getSettingValue();\n  if (delay == null) {\n    setCommercialResult(\"Invalid delay specified.\");\n    clearCommercialButtonsSelection();\n  }\n else {\n    scheduledCommercialTime=System.currentTimeMillis() + delay * 1000;\n    scheduledCommercialLength=length;\n    update();\n  }\n}\n", "docstring": "schedules a commercial of the given length to be run after the delay currently set in the delay input field .", "partition": "test"}
{"idx": "3250", "code": "public void recordEndTime(){\n  int msDiff=(int)(System.currentTimeMillis() - _currentRequestStartTime.get());\n  _log.info(\"Request response time: {} ms\",msDiff);\n  updateOrResetReqRspAvgLstHr(updateOrResetReqRspAvgLstMin(msDiff,false),false);\n  updateMinMaxReqRspMs(msDiff);\n  if (msDiff >= SUSPISCIOUS_RSP_TIME_MS) {\n    _alertLog.warn(MessageFormat.format(\"Request took an unusually long time to complete: {0}ms\",msDiff));\n  }\n  _currentRequestStartTime.remove();\n}\n", "docstring": "computes the response time of the request that just finished for the local thread and updates the request response average in the last minute , and propagates to the request response per minute per hour counter . updates min / max response time . if the response is above suspicious_resp_time_ms , log a warning .", "partition": "test"}
{"idx": "713", "code": "public void updateValue(final Object value,final boolean isSelected,boolean sync){\n  if (isReadOnly()) {\n    return;\n  }\n  if (GenericFormFactory.isTextForm(formType)) {\n    textString=(String)value;\n    if (textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n  }\n else {\n    textString=(String)value;\n    this.isSelected=isSelected;\n    if (isSelected != lastIsSelected && lastTextString != null && textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n    lastIsSelected=isSelected;\n  }\n  if ((sync && guiType != FormFactory.ULC) && guiComp != null) {\n    syncGUI(value);\n  }\n}\n", "docstring": "allow us to update value ( and sync to gui version if exists", "partition": "test"}
{"idx": "2823", "code": "public static void putShort(long addr,short val){\n  if (UNALIGNED)   UNSAFE.putShort(addr,val);\n else   putShortByByte(addr,val,BIG_ENDIAN);\n}\n", "docstring": "stores given short value . alignment aware .", "partition": "test"}
{"idx": "1808", "code": "private void accesBreakpointInstruction(ArrayList<Instruction> instructions,int lineNumber,int op,BPINSTRUCTION_STATUS status){\n  for (int i=0; i < instructions.size(); i++) {\n    Instruction currInst=instructions.get(i);\n    if (op == 0) {\n      if (currInst instanceof MRJobInstruction) {\n        MRJobInstruction currMRInst=(MRJobInstruction)currInst;\n        if (currMRInst.findMRInstructions(lineNumber)) {\n          BreakPointInstruction breakpoint=new BreakPointInstruction();\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(instID++);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.add(i,breakpoint);\n          DMLBreakpointManager.insertBreakpoint(breakpoint,lineNumber);\n          return;\n        }\n      }\n else       if (currInst instanceof CPInstruction || currInst instanceof SPInstruction) {\n        if (currInst.getLineNum() == lineNumber) {\n          BreakPointInstruction breakpoint=new BreakPointInstruction();\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(instID++);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.add(i,breakpoint);\n          DMLBreakpointManager.insertBreakpoint(breakpoint,lineNumber);\n          return;\n        }\n      }\n else       if (currInst instanceof BreakPointInstruction && currInst.getLineNum() == lineNumber) {\n        BreakPointInstruction breakpoint=(BreakPointInstruction)currInst;\n        breakpoint.setBPInstructionStatus(BPINSTRUCTION_STATUS.ENABLED);\n        breakpoint.setBPInstructionLocation(location);\n        instructions.set(i,breakpoint);\n        DMLBreakpointManager.updateBreakpoint(lineNumber,status);\n        return;\n      }\n    }\n else {\n      if (currInst instanceof BreakPointInstruction && currInst.getLineNum() == lineNumber) {\n        if (op == 1) {\n          BreakPointInstruction breakpoint=(BreakPointInstruction)currInst;\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(currInst.getInstID());\n          breakpoint.setBPInstructionStatus(status);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.set(i,breakpoint);\n          DMLBreakpointManager.updateBreakpoint(lineNumber,status);\n        }\n else {\n          instructions.remove(i);\n          DMLBreakpointManager.removeBreakpoint(lineNumber,status);\n        }\n        return;\n      }\n    }\n  }\n}\n", "docstring": "access breakpoint instruction at specified line number in set of instructions ( if valid )", "partition": "test"}
{"idx": "2551", "code": "public SelectionInputDialog(Window owner,String key,boolean editable,T[] selectionValues,T initialSelectionValue,InputValidator<T> inputValidator,Object... keyArguments){\n  this(owner,key,selectionValues,initialSelectionValue,inputValidator,keyArguments);\n  comboBox.setEditable(editable);\n}\n", "docstring": "create a selectioninputdialog whose combobox can be editable .", "partition": "test"}
{"idx": "3666", "code": "public static List<INaviProject> loadProjects(final AbstractSQLProvider provider,final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {\n  PostgreSQLDatabaseFunctions.checkArguments(provider,debuggerManager);\n  final CConnection connection=provider.getConnection();\n  final List<INaviProject> projects=new ArrayList<>();\n  if (!PostgreSQLHelpers.hasTable(connection,CTableNames.PROJECTS_TABLE)) {\n    return projects;\n  }\n  String query=\"SELECT id, name, description, creation_date, modification_date, \" + \" (SELECT count(*) FROM \" + CTableNames.ADDRESS_SPACES_TABLE + \" WHERE project_id = \"+ CTableNames.PROJECTS_TABLE+ \".id) \"+ \" AS addressspace_count FROM \"+ CTableNames.PROJECTS_TABLE;\n  try (ResultSet resultSet=connection.executeQuery(query,true)){\n    while (resultSet.next()) {\n      final int projectId=resultSet.getInt(\"id\");\n      final String name=PostgreSQLHelpers.readString(resultSet,\"name\");\n      final String description=PostgreSQLHelpers.readString(resultSet,\"description\");\n      final int addressSpaceCount=resultSet.getInt(\"addressspace_count\");\n      final Timestamp creationDate=resultSet.getTimestamp(\"creation_date\");\n      final Timestamp modificationDate=resultSet.getTimestamp(\"modification_date\");\n      final List<DebuggerTemplate> debuggers=PostgreSQLDatabaseFunctions.getAssignedDebuggers(connection,projectId,debuggerManager);\n      projects.add(new CProject(projectId,name,description == null ? \"\" : description,creationDate,modificationDate,addressSpaceCount,debuggers,provider));\n    }\n  }\n catch (  final SQLException e) {\n    throw new CouldntLoadDataException(e);\n  }\n  return new ArrayList<INaviProject>(projects);\n}\n", "docstring": "loads the projects of a database .", "partition": "test"}
{"idx": "2394", "code": "public void addIncludes(String[] definitions){\n  addStrings(INCLUDES,definitions);\n  addStrings(linker_more,INCLUDES,definitions);\n  newLinkerOptionsAfterCompile.add(INCLUDES);\n}\n", "docstring": "adds a list of definitions to the existing list of definitions .", "partition": "test"}
{"idx": "2655", "code": "public boolean intersects(final PlanetModel planetModel,final Plane q,final GeoPoint[] notablePoints,final GeoPoint[] moreNotablePoints,final Membership[] bounds,final Membership... moreBounds){\n  if (isNumericallyIdentical(q)) {\n    for (    GeoPoint p : notablePoints) {\n      if (meetsAllBounds(p,bounds,moreBounds)) {\n        return true;\n      }\n    }\n    for (    GeoPoint p : moreNotablePoints) {\n      if (meetsAllBounds(p,bounds,moreBounds)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  final double lineVectorX=y * q.z - z * q.y;\n  final double lineVectorY=z * q.x - x * q.z;\n  final double lineVectorZ=x * q.y - y * q.x;\n  if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n    return false;\n  }\n  double x0;\n  double y0;\n  double z0;\n  final double denomYZ=this.y * q.z - this.z * q.y;\n  final double denomXZ=this.x * q.z - this.z * q.x;\n  final double denomXY=this.x * q.y - this.y * q.x;\n  if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n    if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomYZ;\n    x0=0.0;\n    y0=(-this.D * q.z - this.z * -q.D) * denom;\n    z0=(this.y * -q.D + this.D * q.y) * denom;\n  }\n else   if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n    if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomXZ;\n    x0=(-this.D * q.z - this.z * -q.D) * denom;\n    y0=0.0;\n    z0=(this.x * -q.D + this.D * q.x) * denom;\n  }\n else {\n    if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomXY;\n    x0=(-this.D * q.y - this.y * -q.D) * denom;\n    y0=(this.x * -q.D + this.D * q.x) * denom;\n    z0=0.0;\n  }\n  final double A=lineVectorX * lineVectorX * planetModel.inverseAbSquared + lineVectorY * lineVectorY * planetModel.inverseAbSquared + lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n  final double B=2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n  final double C=x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n  final double BsquaredMinus=B * B - 4.0 * A * C;\n  if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n    final double inverse2A=1.0 / (2.0 * A);\n    final double t=-B * inverse2A;\n    final double pointX=lineVectorX * t + x0;\n    final double pointY=lineVectorY * t + y0;\n    final double pointZ=lineVectorZ * t + z0;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(pointX,pointY,pointZ)) {\n        return false;\n      }\n    }\n    for (    final Membership bound : moreBounds) {\n      if (!bound.isWithin(pointX,pointY,pointZ)) {\n        return false;\n      }\n    }\n    return true;\n  }\n else   if (BsquaredMinus > 0.0) {\n    final double inverse2A=1.0 / (2.0 * A);\n    final double sqrtTerm=Math.sqrt(BsquaredMinus);\n    final double t1=(-B + sqrtTerm) * inverse2A;\n    final double t2=(-B - sqrtTerm) * inverse2A;\n    final double point1X=lineVectorX * t1 + x0;\n    final double point1Y=lineVectorY * t1 + y0;\n    final double point1Z=lineVectorZ * t1 + z0;\n    boolean point1Valid=true;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(point1X,point1Y,point1Z)) {\n        point1Valid=false;\n        break;\n      }\n    }\n    if (point1Valid) {\n      for (      final Membership bound : moreBounds) {\n        if (!bound.isWithin(point1X,point1Y,point1Z)) {\n          point1Valid=false;\n          break;\n        }\n      }\n    }\n    if (point1Valid) {\n      return true;\n    }\n    final double point2X=lineVectorX * t2 + x0;\n    final double point2Y=lineVectorY * t2 + y0;\n    final double point2Z=lineVectorZ * t2 + z0;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(point2X,point2Y,point2Z)) {\n        return false;\n      }\n    }\n    for (    final Membership bound : moreBounds) {\n      if (!bound.isWithin(point2X,point2Y,point2Z)) {\n        return false;\n      }\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "determine whether the plane intersects another plane within the bounds provided .", "partition": "test"}
{"idx": "758", "code": "final private String attrDef2AttrDesc(Attributes attrs) throws NamingException {\n  StringBuffer attrDesc=new StringBuffer(\"( \");\n  Attribute attr=null;\n  int count=0;\n  attr=attrs.get(NUMERICOID_ID);\n  if (attr != null) {\n    attrDesc.append(writeNumericOID(attr));\n    count++;\n  }\n else {\n    throw new ConfigurationException(\"Attribute type doesn\\'t\" + \"have a numeric OID\");\n  }\n  attr=attrs.get(NAME_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDescrs(attr));\n    count++;\n  }\n  attr=attrs.get(DESC_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  attr=attrs.get(OBSOLETE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(SUP_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(EQUALITY_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(ORDERING_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SUBSTR_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SYNTAX_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SINGLE_VAL_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(COLLECTIVE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(NO_USER_MOD_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(USAGE_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  if (count < attrs.size()) {\n    String attrId=null;\n    for (NamingEnumeration<? extends Attribute> ae=attrs.getAll(); ae.hasMoreElements(); ) {\n      attr=ae.next();\n      attrId=attr.getID();\n      if (attrId.equals(NUMERICOID_ID) || attrId.equals(NAME_ID) || attrId.equals(SYNTAX_ID)|| attrId.equals(DESC_ID)|| attrId.equals(SINGLE_VAL_ID)|| attrId.equals(EQUALITY_ID)|| attrId.equals(ORDERING_ID)|| attrId.equals(SUBSTR_ID)|| attrId.equals(NO_USER_MOD_ID)|| attrId.equals(USAGE_ID)|| attrId.equals(SUP_ID)|| attrId.equals(COLLECTIVE_ID)|| attrId.equals(OBSOLETE_ID)) {\n        continue;\n      }\n else {\n        attrDesc.append(writeQDStrings(attr));\n      }\n    }\n  }\n  attrDesc.append(\")\");\n  return attrDesc.toString();\n}\n", "docstring": "translate attributes that describe an attribute definition into the string description as defined in rfc 2252 .", "partition": "test"}
{"idx": "3896", "code": "public static boolean isRegistered(Class<?> clazz){\n  return regModules.containsKey(clazz.getName());\n}\n", "docstring": "has this class already been registered .", "partition": "test"}
{"idx": "2367", "code": "public void addRun(final Run run){\n  runs.add(run);\n  run.setId(runIdCounter++);\n}\n", "docstring": "will add the run to the list .", "partition": "test"}
{"idx": "57", "code": "public static void copy(InputStream is,Resource out,boolean closeIS) throws IOException {\n  OutputStream os=null;\n  try {\n    os=toBufferedOutputStream(out.getOutputStream());\n  }\n catch (  IOException ioe) {\n    IOUtil.closeEL(os);\n    throw ioe;\n  }\n  copy(is,os,closeIS,true);\n}\n", "docstring": "copy a input resource to a output resource", "partition": "test"}
{"idx": "3976", "code": "public Result doComparisonTest(Properties properties) throws Exception {\n  final long timeout=Long.parseLong(properties.getProperty(TestOptions.TIMEOUT));\n  final int ntrials=Integer.parseInt(properties.getProperty(TestOptions.NTRIALS));\n  final int nclients=Integer.parseInt(properties.getProperty(TestOptions.NCLIENTS));\n  final double percentReaders=Double.parseDouble(properties.getProperty(TestOptions.PERCENT_READERS));\n  final double percentWritersWillFlush=Double.parseDouble(properties.getProperty(TestOptions.PERCENT_WRITER_WILL_FLUSH));\n  final int reclen=Integer.parseInt(properties.getProperty(TestOptions.RECLEN));\n  final int nwritesPerTask=Integer.parseInt(properties.getProperty(TestOptions.NWRITES));\n  final int nreadsPerTask=Integer.parseInt(properties.getProperty(TestOptions.NREADS));\n  final AtomicInteger nerr=new AtomicInteger();\n  final Result result=doMRMWTest(store,timeout,ntrials,nclients,percentReaders,percentWritersWillFlush,reclen,nwritesPerTask,nreadsPerTask,nerr);\n  return result;\n}\n", "docstring": "setup and run a test .", "partition": "test"}
{"idx": "3875", "code": "private static int createPackedParams(SunGraphics2D sg2d,GlyphList gl){\n  return (((gl.usePositions() ? 1 : 0) << OFFSET_POSITIONS) | ((gl.isSubPixPos() ? 1 : 0) << OFFSET_SUBPIXPOS) | ((gl.isRGBOrder() ? 1 : 0) << OFFSET_RGBORDER)| ((sg2d.lcdTextContrast & 0xff) << OFFSET_CONTRAST));\n}\n", "docstring": "packs the given parameters into a single int value in order to save space on the rendering queue . note that most of these parameters are only used for rendering lcd - optimized text , but conditionalizing this work wouldn \"'\" t make any impact on performance , so we will pack those parameters even in the non - lcd case .", "partition": "test"}
{"idx": "3552", "code": "public static void writeListOfLongs(List list,boolean hasLongIDs,DataOutput out) throws IOException {\n  if (list == null) {\n    out.writeInt(-1);\n  }\n else {\n    out.writeInt(list.size());\n    out.writeBoolean(hasLongIDs);\n    for (Iterator it=list.iterator(); it.hasNext(); ) {\n      Long l=(Long)it.next();\n      if (hasLongIDs) {\n        out.writeLong(l.longValue());\n      }\n else {\n        out.writeInt((int)l.longValue());\n      }\n    }\n  }\n}\n", "docstring": "write a set of long objects", "partition": "test"}
{"idx": "364", "code": "public void testAndNotNegNegFirstLonger(){\n  byte aBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  byte bBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  int aSign=-1;\n  int bSign=-1;\n  byte rBytes[]={73,-92,-48,4,12,6,4,32,48,64,0,8,2};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.andNot(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "andnot for two negative numbers ; the first is longer", "partition": "test"}
{"idx": "1870", "code": "@Contract(pure=true) public static boolean startsWithConcatenation(@NotNull String string,@NotNull String... prefixes){\n  int offset=0;\n  for (  String prefix : prefixes) {\n    int prefixLen=prefix.length();\n    if (!string.regionMatches(offset,prefix,0,prefixLen)) {\n      return false;\n    }\n    offset+=prefixLen;\n  }\n  return true;\n}\n", "docstring": "equivalent to string . startswith ( prefixes [ 0 ", "partition": "test"}
{"idx": "1516", "code": "private final Object internalReplace(Object k,Object v,Object cv){\n  int h=spread(k.hashCode());\n  Object oldVal=null;\n  for (Node[] tab=table; ; ) {\n    Node f;\n    int i, fh;\n    Object fk;\n    if (tab == null || (f=tabAt(tab,i=(tab.length - 1) & h)) == null)     break;\n else     if ((fh=f.hash) == MOVED) {\n      if ((fk=f.key) instanceof TreeBin) {\n        TreeBin t=(TreeBin)fk;\n        boolean validated=false;\n        boolean deleted=false;\n        t.acquire(0);\n        try {\n          if (tabAt(tab,i) == f) {\n            validated=true;\n            TreeNode p=t.getTreeNode(h,k,t.root);\n            if (p != null) {\n              Object pv=p.val;\n              if (cv == null || cv == pv || cv.equals(pv)) {\n                oldVal=pv;\n                if ((p.val=v) == null) {\n                  deleted=true;\n                  t.deleteTreeNode(p);\n                }\n              }\n            }\n          }\n        }\n  finally {\n          t.release(0);\n        }\n        if (validated) {\n          if (deleted)           counter.add(-1L);\n          break;\n        }\n      }\n else       tab=(Node[])fk;\n    }\n else     if ((fh & HASH_BITS) != h && f.next == null)     break;\n else     if ((fh & LOCKED) != 0) {\n      checkForResize();\n      f.tryAwaitLock(tab,i);\n    }\n else     if (f.casHash(fh,fh | LOCKED)) {\n      boolean validated=false;\n      boolean deleted=false;\n      try {\n        if (tabAt(tab,i) == f) {\n          validated=true;\n          for (Node e=f, pred=null; ; ) {\n            Object ek, ev;\n            if ((e.hash & HASH_BITS) == h && ((ev=e.val) != null) && ((ek=e.key) == k || k.equals(ek))) {\n              if (cv == null || cv == ev || cv.equals(ev)) {\n                oldVal=ev;\n                if ((e.val=v) == null) {\n                  deleted=true;\n                  Node en=e.next;\n                  if (pred != null)                   pred.next=en;\n else                   setTabAt(tab,i,en);\n                }\n              }\n              break;\n            }\n            pred=e;\n            if ((e=e.next) == null)             break;\n          }\n        }\n      }\n  finally {\n        if (!f.casHash(fh | LOCKED,fh)) {\n          f.hash=fh;\nsynchronized (f) {\n            f.notifyAll();\n          }\n          ;\n        }\n      }\n      if (validated) {\n        if (deleted)         counter.add(-1L);\n        break;\n      }\n    }\n  }\n  return oldVal;\n}\n", "docstring": "implementation for the four public remove / replace methods : replaces node value with v , conditional upon match of cv if non - null . if resulting value is null , delete .", "partition": "test"}
{"idx": "321", "code": "public static String addToCartBulk(HttpServletRequest request,HttpServletResponse response){\n  String categoryId=request.getParameter(\"category_id\");\n  ShoppingCart cart=getCartObject(request);\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCartHelper cartHelper=new ShoppingCartHelper(delegator,dispatcher,cart);\n  String controlDirective;\n  Map<String,Object> result;\n  Map<String,Object> paramMap=UtilHttp.getParameterMap(request);\n  String catalogId=CatalogWorker.getCurrentCatalogId(request);\n  result=cartHelper.addToCartBulk(catalogId,categoryId,paramMap);\n  controlDirective=processResult(result,request);\n  if (controlDirective.equals(ERROR)) {\n    return \"error\";\n  }\n else {\n    return \"success\";\n  }\n}\n", "docstring": "adds all products in a category according to quantity request parameter for each ; if no parameter for a certain product in the category , or if quantity is 0 , do not add", "partition": "test"}
{"idx": "3554", "code": "private void showPreloadingStage(){\n  Stage preloadingStage=new Stage(StageStyle.UNDECORATED);\n  preloadingStage.initOwner(primaryStage);\n  preloadingStage.setScene(new PreloadingScene());\n  preloadingStage.show();\n  primaryStage.setOnShowing(null);\n}\n", "docstring": "shows preloading stage with scene while fxgl is being configured .", "partition": "test"}
{"idx": "404", "code": "public void push(Notification notification,NotificationResponseListener listener){\n  final String notificationTopic=notification.getTopic();\n  final String topic=notificationTopic == null ? defaultTopic : notificationTopic;\n  Request req=Utils.buildRequest(client,topic,notification,gateway);\n  semaphore.acquireUninterruptibly();\n  req.send(new ResponseListener(semaphore,notification,listener));\n}\n", "docstring": "sends a notification to the apple push notification service .", "partition": "test"}
{"idx": "1383", "code": "public byte[] generateSignature() throws CryptoException, DataLengthException {\n  contentDigest.doFinal(mDash,mDash.length - hLen - sLen);\n  if (sLen != 0) {\n    random.nextBytes(salt);\n    System.arraycopy(salt,0,mDash,mDash.length - sLen,sLen);\n  }\n  byte[] h=new byte[hLen];\n  contentDigest.update(mDash,0,mDash.length);\n  contentDigest.doFinal(h,0);\n  block[block.length - sLen - 1- hLen- 1]=0x01;\n  System.arraycopy(salt,0,block,block.length - sLen - hLen- 1,sLen);\n  byte[] dbMask=maskGeneratorFunction1(h,0,h.length,block.length - hLen - 1);\n  for (int i=0; i != dbMask.length; i++) {\n    block[i]^=dbMask[i];\n  }\n  block[0]&=(0xff >> ((block.length * 8) - emBits));\n  System.arraycopy(h,0,block,block.length - hLen - 1,hLen);\n  block[block.length - 1]=trailer;\n  byte[] b=cipher.processBlock(block,0,block.length);\n  clearBlock(block);\n  return b;\n}\n", "docstring": "generate a signature for the message we \"'\" ve been loaded with using the key we were initialised with .", "partition": "test"}
{"idx": "4035", "code": "public void findPackageAndClass() throws IOException {\n  packageName=null;\n  className=null;\n  LineNumberReader reader=new LineNumberReader(new FileReader(inputFile));\n  try {\n    while (className == null || packageName == null) {\n      String line=reader.readLine();\n      if (line == null)       break;\n      if (packageName == null) {\n        Matcher matcher=PACKAGE_PATTERN.matcher(line);\n        if (matcher.find()) {\n          packageName=matcher.group(1);\n        }\n      }\n      if (className == null) {\n        Matcher matcher=CLASS_PATTERN.matcher(line);\n        if (matcher.find()) {\n          className=matcher.group(1);\n        }\n      }\n    }\n    if (className == null) {\n      className=\"Yylex\";\n    }\n  }\n  finally {\n    reader.close();\n  }\n}\n", "docstring": "peek into . flex file to get package and class name", "partition": "test"}
{"idx": "2336", "code": "public int[] breadthFirstSearch(int intialValue,IBFSTraversable<N> traversable,int firstValue,IIntegerBfsNextValueIterator<N> nextValueIterator,List<Integer> sourcesIndex){\n  int[] results=new int[nodes.length];\n  Arrays.fill(results,intialValue);\n  boolean[] alreadyScanned=new boolean[nodes.length];\n  Arrays.fill(alreadyScanned,false);\n  Set<Integer> currentNodesIndex=new HashSet<>(sourcesIndex);\n  iterativeIntegerBreadthFirstSearch(results,alreadyScanned,currentNodesIndex,firstValue,0,traversable,nextValueIterator);\n  return results;\n}\n", "docstring": "breadth - first search implementation for integers . see double implementation for the parameters details . note that for compilation reasons parameters are in a different order compared to the double version hint : you can compute distances by providing to the sources by providing a + 1 next value visitor", "partition": "test"}
{"idx": "1744", "code": "protected void release(){\n  AppContext tempAppContext=null;\nsynchronized (grabReleaseSynchronizer) {\n    if (usageCount > 1) {\n      --usageCount;\n    }\n else {\nsynchronized (threadGroupSynchronizer) {\n        tempAppContext=resetAppContext();\n      }\n    }\n  }\n  if (tempAppContext != null) {\n    try {\n      tempAppContext.dispose();\n    }\n catch (    IllegalThreadStateException e) {\n    }\n  }\n}\n", "docstring": "release this appletclassloader and its threadgroup / appcontext . if nothing else has grabbed this appletclassloader , its threadgroup and appcontext will be destroyed . because this method may destroy the appletclassloader \"'\" s threadgroup , this method should not be called from within the appletclassloader \"'\" s threadgroup . changed modifier to protected in order to be able to overwrite this function in pluginclassloader . java", "partition": "test"}
{"idx": "2622", "code": "protected int splitListIndex(List<Pair<Double,Integer>> S){\n  return S.size() / 2;\n}\n", "docstring": "determines which index to use as the splitting index for the vp radius", "partition": "test"}
{"idx": "2185", "code": "protected double defaultMaxRadius(){\n  return Math.sqrt(2.0);\n}\n", "docstring": "returns the default max radius", "partition": "test"}
{"idx": "3990", "code": "private static <T>int migrateAll(Migration<T> migration) throws Exception {\n  int migrated=0;\n  for (  T entity : migration.getAllEntities()) {\n    try {\n      if (migration.isMigrated(entity))       continue;\n    }\n catch (    Exception x) {\n      LOG.error(\"Couldn\\'t check if the entity \\'{}\\' is migrated due to occurred error\",entity);\n      throw x;\n    }\n    try {\n      migration.migrate(entity);\n    }\n catch (    Exception x) {\n      LOG.error(\"Error migrating the entity \\'{}\",entity);\n      throw x;\n    }\n    migrated++;\n  }\n  return migrated;\n}\n", "docstring": "migrates entities and skips those which are already migrated .", "partition": "test"}
{"idx": "363", "code": "public void resetSingleton(){\n  root=null;\n  tmpFileCounter.set(0);\n  accessedFiles.clear();\n  shouldAllThrowIOException=false;\n  classesThatShouldThrowIOException.clear();\nsynchronized (leakingResources) {\n    for (    LeakingResource resource : leakingResources) {\n      try {\n        resource.release();\n      }\n catch (      Exception e) {\n        logger.warn(\"Failed to release resource: \" + e.getMessage(),e);\n      }\n    }\n    leakingResources.clear();\n  }\n}\n", "docstring": "reset the internal state of this singleton", "partition": "test"}
{"idx": "2255", "code": "public String resolveParentRelationName(String parentName,Object parent,String childName,Object child){\n  return parentName;\n}\n", "docstring": "follow the most conventional pattern , returns the parentname unchanged .", "partition": "test"}
{"idx": "1366", "code": "public final static int caculateInSampleSize(BitmapFactory.Options options,int rqsW,int rqsH){\n  final int height=options.outHeight;\n  final int width=options.outWidth;\n  int inSampleSize=1;\n  if (rqsW == 0 || rqsH == 0)   return 1;\n  if (height > rqsH || width > rqsW) {\n    final int heightRatio=Math.round((float)height / (float)rqsH);\n    final int widthRatio=Math.round((float)width / (float)rqsW);\n    inSampleSize=heightRatio < widthRatio ? heightRatio : widthRatio;\n  }\n  return inSampleSize;\n}\n", "docstring": "caculate the bitmap samplesize", "partition": "test"}
{"idx": "54", "code": "private Map<URI,ExportMask> createExportMaskMap(Set<URI> placedMasks){\n  Map<URI,ExportMask> exportMaskMap=new HashMap<>();\n  Iterator<ExportMask> exportMaskIterator=dbClient.queryIterativeObjects(ExportMask.class,placedMasks,true);\n  while (exportMaskIterator.hasNext()) {\n    ExportMask exportMask=exportMaskIterator.next();\n    exportMaskMap.put(exportMask.getId(),exportMask);\n  }\n  return exportMaskMap;\n}\n", "docstring": "given a set of exportmask uris , return a map of exportmask uri to exportmask object", "partition": "test"}
{"idx": "124", "code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n  in.defaultReadObject();\n  i18n=Environment.getI18n();\n  beanContextChildSupport=new BeanContextChildSupport(this);\n}\n", "docstring": "handle serialization a little bit better , replacing the i18n and beancontextchildsupport .", "partition": "test"}
{"idx": "4178", "code": "public synchronized void addRecentItem(T item){\n  item=fromString(toString(item));\n  if (m_RecentItems.size() > 0) {\n    if (item.equals(m_RecentItems.get(0)))     return;\n  }\n  m_RecentItems.remove(item);\n  m_RecentItems.add(0,item);\n  while (m_RecentItems.size() > m_MaxCount)   m_RecentItems.remove(m_RecentItems.size() - 1);\n  if (m_IgnoreChanges)   return;\n  writeProps();\n  updateMenu();\n  notifyRecentItemListenersOfAdd(item);\n}\n", "docstring": "adds the item to the internal list .", "partition": "test"}
{"idx": "463", "code": "public JSONObject remove(String name){\n  if (name == null) {\n    throw new NullPointerException(\"name is null\");\n  }\n  int index=indexOf(name);\n  if (index != -1) {\n    table.remove(index);\n    names.remove(index);\n    values.remove(index);\n  }\n  return this;\n}\n", "docstring": "removes a member with the specified name from this object . if this object contains multiple members with the given name , only the last one is removed . if this object does not contain a member with the specified name , the object is not modified .", "partition": "test"}
{"idx": "1640", "code": "@Override public int clampViewPositionHorizontal(View child,int left,int dx){\n  if (mDraggedView == null) {\n    return 0;\n  }\n  final int leftBound=0 - MAX_OVERFLOW - (mColumnSizeSide / 2);\n  final int rightBound=getWidth() + MAX_OVERFLOW + (mColumnSizeSide / 2);\n  return Math.min(Math.max(left,leftBound),rightBound);\n}\n", "docstring": "override method used to configure the horizontal drag . restrict the motion of the dragged child view along the horizontal axis .", "partition": "test"}
{"idx": "2203", "code": "public Pair<String,String> next(){\n  try {\n    currentHeaderPosition=nextHeaderPosition;\n    String readHeader=nextLine;\n    nextHeaderPosition+=readHeader.length() + endOfLineBytes;\n    readHeader=\">\" + readHeader.substring(1);\n    String readSequence=r.readLine();\n    nextHeaderPosition+=readSequence.length() + endOfLineBytes;\n    String comments=r.readLine();\n    nextHeaderPosition+=comments.length() + endOfLineBytes;\n    if (comments.startsWith(\"+\")) {\n      String qualityValues=r.readLine();\n      nextHeaderPosition+=qualityValues.length() + endOfLineBytes;\n    }\n    nextLine=r.readLine();\n    return new Pair<>(readHeader,readSequence);\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n  return null;\n}\n", "docstring": "gets next fasta record", "partition": "test"}
{"idx": "2678", "code": "public synchronized void addFrame(final Image image,final long frameDuration){\n  totalDuration+=frameDuration;\n  frames.add(new AnimFrame(image,totalDuration));\n}\n", "docstring": "adds an image to the animation with the specified duration ( time to display the image ) .", "partition": "test"}
{"idx": "1392", "code": "private static void createOrgAuthConfig(String realmName) throws Exception {\n  String classMethod=\"UpgradeUtils:createOrgAuthConfig: \";\n  OrganizationConfigManager org=new OrganizationConfigManager(ssoToken,realmName);\n  ServiceConfig orgConfig=org.getServiceConfig(AUTH_SERVICE_NAME);\n  if (orgConfig != null) {\n    Map aa=orgConfig.getAttributes();\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"Org is :\" + realmName);\n      debug.message(classMethod + \"Attribute Map is :\" + aa);\n    }\n    String orgName=realmName;\n    if (LDAPUtils.isDN(realmName)) {\n      orgName=LDAPUtils.rdnValueFromDn(realmName);\n    }\n    String authConfigName=orgName + \"-authconfig\";\n    String adminAuthConfigName=orgName + \"-admin-authconfig\";\n    Set authConfigAttrValue=(Set)aa.get(ATTR_ORG_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"authConfigAttrValue : \" + authConfigAttrValue);\n    }\n    Set newVal=new HashSet();\n    if (authConfigAttrValue.size() != 1 && !authConfigAttrValue.contains(authConfigName)) {\n      newVal.add(authConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ORG_AUTH_MODULE,authConfigAttrValue,newVal);\n    }\n    Set adminConfigAttrValue=(Set)aa.get(ATTR_ADMIN_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(\"adminauthConfigAttrValue : \" + adminConfigAttrValue);\n    }\n    if (adminConfigAttrValue.size() != 1 && !adminConfigAttrValue.contains(adminAuthConfigName)) {\n      newVal.clear();\n      newVal.add(adminAuthConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ADMIN_AUTH_MODULE,adminConfigAttrValue,newVal);\n    }\n    aa=orgConfig.getAttributes();\n    ServiceConfig s=org.getServiceConfig(AUTH_CONFIG_SERVICE);\n    ServiceConfig authConfig=s.getSubConfig(NAMED_CONFIG);\n    if (authConfig == null) {\n      s.addSubConfig(NAMED_CONFIG,null,0,null);\n      authConfig=s.getSubConfig(NAMED_CONFIG);\n    }\n    Map aMap=new HashMap();\n    aMap.put(ATTR_AUTH_CONFIG,authConfigAttrValue);\n    authConfig.addSubConfig(authConfigName,SUB_NAMED_CONFIG,0,aMap);\n    aMap.clear();\n    aMap.put(ATTR_AUTH_CONFIG,adminConfigAttrValue);\n    authConfig.addSubConfig(adminAuthConfigName,SUB_NAMED_CONFIG,0,aMap);\n  }\n}\n", "docstring": "creates auth configurations for auth modules configuration in core auth service .", "partition": "test"}
{"idx": "1837", "code": "public SetChangelogMapping(String source,String taskName,int changelogPartitionNumber){\n  super(source);\n  setType(TYPE);\n  setKey(taskName);\n  putMessageValue(CHANGELOG_VALUE_KEY,String.valueOf(changelogPartitionNumber));\n}\n", "docstring": "the change log mapping message is used to store changelog partition information for a given task name .", "partition": "test"}
{"idx": "1004", "code": "public static DoubleVector rnorm(int n,double mean,double sd,Random random){\n  if (sd < 0.0)   throw new IllegalArgumentException(\"standard deviation < 0.0\");\n  if (sd == 0.0)   return new DoubleVector(n,mean);\n  DoubleVector v=new DoubleVector(n);\n  for (int i=0; i < n; i++)   v.set(i,(random.nextGaussian() + mean) / sd);\n  return v;\n}\n", "docstring": "generates a sample of a normal distribution .", "partition": "test"}
{"idx": "1328", "code": "public void stop(){\nsynchronized (privateInstanceLock) {\n    if (connectionAcceptThread == null) {\n      return;\n    }\n  }\n  isStopped.set(true);\n  try {\n    connectionAcceptThread.interrupt();\n    connectionAcceptThread.join();\n  }\n catch (  InterruptedException e) {\n  }\n  try {\n    serverSocket.close();\n  }\n catch (  IOException e) {\n  }\n}\n", "docstring": "stops the communicator . all open connections to the remote server will be terminated . once this method has been called , the communicator cannot be restarted .", "partition": "test"}
{"idx": "1760", "code": "protected Size2D drawVertical(Graphics2D g2,Rectangle2D chartArea){\n  double startX;\n  double topSpace=0.0;\n  double bottomSpace=0.0;\n  double leftSpace=0.0;\n  double rightSpace=0.0;\n  double w=getWidth();\n  double h=getHeight();\n  RectangleInsets padding=getPadding();\n  if (padding != null) {\n    topSpace=padding.calculateTopOutset(h);\n    bottomSpace=padding.calculateBottomOutset(h);\n    leftSpace=padding.calculateLeftOutset(w);\n    rightSpace=padding.calculateRightOutset(w);\n  }\n  if (getPosition() == RectangleEdge.LEFT) {\n    startX=chartArea.getX() + leftSpace;\n  }\n else {\n    startX=chartArea.getMaxX() - rightSpace - w;\n  }\n  VerticalAlignment alignment=getVerticalAlignment();\n  double startY=0.0;\n  if (alignment == VerticalAlignment.CENTER) {\n    startY=chartArea.getMinY() + topSpace + chartArea.getHeight() / 2.0 - h / 2.0;\n  }\n else   if (alignment == VerticalAlignment.TOP) {\n    startY=chartArea.getMinY() + topSpace;\n  }\n else   if (alignment == VerticalAlignment.BOTTOM) {\n    startY=chartArea.getMaxY() - bottomSpace - h;\n  }\n  g2.drawImage(this.image,(int)startX,(int)startY,(int)w,(int)h,null);\n  return new Size2D(chartArea.getWidth() + leftSpace + rightSpace,h + topSpace + bottomSpace);\n}\n", "docstring": "draws the title on a java 2d graphics device ( such as the screen or a printer ) .", "partition": "test"}
{"idx": "1358", "code": "public void cancelUnnamedTasks(){\n  if (unnamedTaskExecutor != null) {\n    unnamedTaskExecutor.shutdownNow();\n  }\n}\n", "docstring": "cancel all open and running unnamed tasks", "partition": "test"}
{"idx": "2903", "code": "InMemoryEntryStore(){\n  entries=Maps.newHashMap();\n  topLevelEntries=Sets.newHashSet();\n  children=HashMultimap.create();\n}\n", "docstring": "creates a new inmemoryentrystore which provides constant time storage and retrieval of entries by id or parent id .", "partition": "test"}
{"idx": "271", "code": "public void addRtcpListener(RtcpEventListener listener){\n  listeners.addElement(listener);\n}\n", "docstring": "add a rtcp event listener", "partition": "test"}
{"idx": "1277", "code": "public void actionPerformed(java.awt.event.ActionEvent e){\n  Object source=e.getSource();\n  if (!(source instanceof JMenuItem))   return;\n  JMenuItem mi=(JMenuItem)source;\n  String name=mi.getText();\n  OMGraphicHandlerLayer targetLayer=(OMGraphicHandlerLayer)layers.get(name);\n  if (targetLayer == null) {\n    Debug.message(\"defaultdndcatcher\",\"ERROR> DefaultDnDCatcher::actionPerformed: \" + \"no layer found with name \" + name);\n    return;\n  }\n  targetLayer.doAction((OMGraphic)transferData,new OMAction(OMAction.UPDATE_GRAPHIC_MASK));\n}\n", "docstring": "invoked when an action from the popup menu occurs .", "partition": "test"}
{"idx": "1395", "code": "protected void findCandidateCrossings(S2Point a,S2Point b,List<Integer> candidateCrossings){\n  Preconditions.checkState(indexComputed);\n  ArrayList<S2CellId> cover=Lists.newArrayList();\n  getCovering(a,b,false,cover);\n  Set<Integer> uniqueSet=new HashSet<Integer>();\n  getEdgesInParentCells(cover,uniqueSet);\n  getEdgesInChildrenCells(a,b,cover,uniqueSet);\n  candidateCrossings.clear();\n  candidateCrossings.addAll(uniqueSet);\n}\n", "docstring": "appends to \" candidatecrossings \" all edge references which may cross the given edge . this is done by covering the edge and then finding all references of edges whose coverings overlap this covering . parent cells are checked level by level . child cells are checked all at once by taking advantage of the natural ordering of s2cellids .", "partition": "test"}
{"idx": "950", "code": "private static void removeDependencySubsets(String swcLocation,Map<String,Set<String>> dependencyMap,SwcDependencyInfoImpl depInfo){\n  Set<String> removeSet=new HashSet<String>();\n  SwcExternalScriptInfo externalInfo=depInfo.getSwcExternalScriptInfo(swcLocation);\n  Map<String,Set<String>> externalsBySwc=new HashMap<String,Set<String>>();\n  for (  String swcDependLocation : dependencyMap.get(swcLocation)) {\n    for (    String swcDependLocation2 : dependencyMap.get(swcLocation)) {\n      if (swcDependLocation.equals(swcDependLocation2))       continue;\n      Set<String> externalScripts=externalsBySwc.get(swcDependLocation);\n      Set<String> externalScripts2=externalsBySwc.get(swcDependLocation2);\n      if (externalScripts == null) {\n        externalScripts=externalInfo.getExternalScripts(swcDependLocation);\n        externalsBySwc.put(swcDependLocation,externalScripts);\n      }\n      if (externalScripts2 == null) {\n        externalScripts2=externalInfo.getExternalScripts(swcDependLocation2);\n        externalsBySwc.put(swcDependLocation2,externalScripts2);\n      }\n      if (externalScripts2.size() > externalScripts.size() && externalScripts2.containsAll(externalScripts)) {\n        removeSet.add(swcDependLocation);\n        break;\n      }\n    }\n  }\n  Set<String> dependencySet=dependencyMap.get(swcLocation);\n  dependencySet.removeAll(removeSet);\n}\n", "docstring": "look at the dependency information and remove swc dependencies that are subsets of other swc dependencies .", "partition": "test"}
{"idx": "3771", "code": "public Iterator<String> iterateSerializers(){\n  return serializers.iterator();\n}\n", "docstring": "iterate over view serializers", "partition": "test"}
{"idx": "2457", "code": "private double Poisson(double x){\n  return Math.exp(-m_Lambda + (x * Math.log(m_Lambda)) - logFac(x));\n}\n", "docstring": "returns value for poisson distribution", "partition": "test"}
{"idx": "3288", "code": "public static RequestLog dump(){\n  RequestLog current=RLOG.get();\n  RequestLog copy=new RequestLog(current);\n  current.clear();\n  RLOG.remove();\n  return copy;\n}\n", "docstring": "exports a snapshot of the request log of the current thread and also resets the request log for that thread .", "partition": "test"}
{"idx": "4122", "code": "public static byte[] encryptPassword(final String password,final byte[] seed) throws NoSuchAlgorithmException {\n  if (password == null || password.equals(\"\")) {\n    return new byte[0];\n  }\n  final MessageDigest messageDigest=MessageDigest.getInstance(\"SHA-1\");\n  final byte[] stage1=messageDigest.digest(password.getBytes());\n  messageDigest.reset();\n  final byte[] stage2=messageDigest.digest(stage1);\n  messageDigest.reset();\n  messageDigest.update(seed);\n  messageDigest.update(stage2);\n  final byte[] digest=messageDigest.digest();\n  final byte[] returnBytes=new byte[digest.length];\n  for (int i=0; i < digest.length; i++) {\n    returnBytes[i]=(byte)(stage1[i] ^ digest[i]);\n  }\n  return returnBytes;\n}\n", "docstring": "encrypts a password < p > protocol for authentication is like this : 1 . mysql server sends a random array of bytes ( the seed ) 2 . client makes a sha1 digest of the password 3 . client hashes the output of 2 4 . client digests the seed 5 . client updates the digest with the output from 3 6 . an xor of the output of 5 and 2 is sent to server 7 . server does the same thing and verifies that the scrambled passwords match", "partition": "test"}
{"idx": "3087", "code": "default B with(String key,long value){\n  return with(key,Long.toString(value));\n}\n", "docstring": "associate the given value with the specified key .", "partition": "test"}
{"idx": "3492", "code": "public KeyValueListParser(String pairDelimiterRegex,String keyValDelimiterRegex){\n  pairDelimiter=Pattern.compile(pairDelimiterRegex);\n  keyValDelimiter=Pattern.compile(keyValDelimiterRegex);\n}\n", "docstring": "create a parser that uses the given regexes to parse a list of key value pairs .", "partition": "test"}
{"idx": "1860", "code": "private static void logOsInfo(){\n  Logger.appendLog(\"[Main][I]User Os is \" + Cfg.getOs());\n  Logger.appendLog(\"[Main][I]Os name : \" + Os.getOsName());\n  Logger.appendLog(\"[Main][I]User Platform is : \" + Os.platform());\n  Logger.appendLog(\"[Main][I]JAVA version : \" + System.getProperty(\"java.version\"));\n  Logger.appendLog(\"[Main][I]Available cores (cpu) = \" + HostInfo.availableCpus());\n  Logger.appendLog(\"[Main][I]Max allocated memory = \" + HostInfo.getMaxMemory() + \" bytes\");\n}\n", "docstring": "log system informations to the log file this have no effect on the software it \"'\" s here for logging purpose", "partition": "test"}
{"idx": "3419", "code": "public static String noPrefix(String path,String prefix){\n  Objects.requireNonNull(path,\"path must not be null\");\n  Objects.requireNonNull(prefix,\"prefix must not be null\");\n  return path.startsWith(prefix) ? path.substring(prefix.length()) : path;\n}\n", "docstring": "drops a prefix from a path if it exists or returns original path if prefix does not match .", "partition": "test"}
{"idx": "2993", "code": "public void testSubtractMathContextDiffScalePosNeg(){\n  String a=\"1231212478987482988429808779810457634781384756794987\";\n  int aScale=15;\n  String b=\"747233429293018787918347987234564568\";\n  int bScale=-10;\n  String c=\"-7.4723342916989754E+45\";\n  int cScale=-29;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  MathContext mc=new MathContext(17,RoundingMode.DOWN);\n  BigDecimal result=aNumber.subtract(bNumber,mc);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",cScale,result.scale());\n}\n", "docstring": "subtract two numbers of different scales using mathcontext ; the first is positive", "partition": "test"}
{"idx": "710", "code": "private static void encode(List<AclEntry> acl,long address){\n  long offset=address;\n  for (  AclEntry ace : acl) {\n    int flags=0;\n    UserPrincipal who=ace.principal();\n    if (!(who instanceof UnixUserPrincipals.User))     throw new ProviderMismatchException();\n    UnixUserPrincipals.User user=(UnixUserPrincipals.User)who;\n    int uid;\n    if (user.isSpecial()) {\n      uid=-1;\n      if (who == UnixUserPrincipals.SPECIAL_OWNER)       flags|=ACE_OWNER;\n else       if (who == UnixUserPrincipals.SPECIAL_GROUP)       flags|=(ACE_GROUP | ACE_IDENTIFIER_GROUP);\n else       if (who == UnixUserPrincipals.SPECIAL_EVERYONE)       flags|=ACE_EVERYONE;\n else       throw new AssertionError(\"Unable to map special identifier\");\n    }\n else {\n      if (user instanceof UnixUserPrincipals.Group) {\n        uid=user.gid();\n        flags|=ACE_IDENTIFIER_GROUP;\n      }\n else {\n        uid=user.uid();\n      }\n    }\n    int type;\nswitch (ace.type()) {\ncase ALLOW:\n      type=ACE_ACCESS_ALLOWED_ACE_TYPE;\n    break;\ncase DENY:\n  type=ACE_ACCESS_DENIED_ACE_TYPE;\nbreak;\ncase AUDIT:\ntype=ACE_SYSTEM_AUDIT_ACE_TYPE;\nbreak;\ncase ALARM:\ntype=ACE_SYSTEM_ALARM_ACE_TYPE;\nbreak;\ndefault :\nthrow new AssertionError(\"Unable to map ACE type\");\n}\nSet<AclEntryPermission> aceMask=ace.permissions();\nint mask=0;\nif (aceMask.contains(AclEntryPermission.READ_DATA)) mask|=ACE_READ_DATA;\nif (aceMask.contains(AclEntryPermission.WRITE_DATA)) mask|=ACE_WRITE_DATA;\nif (aceMask.contains(AclEntryPermission.APPEND_DATA)) mask|=ACE_APPEND_DATA;\nif (aceMask.contains(AclEntryPermission.READ_NAMED_ATTRS)) mask|=ACE_READ_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.WRITE_NAMED_ATTRS)) mask|=ACE_WRITE_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.EXECUTE)) mask|=ACE_EXECUTE;\nif (aceMask.contains(AclEntryPermission.DELETE_CHILD)) mask|=ACE_DELETE_CHILD;\nif (aceMask.contains(AclEntryPermission.READ_ATTRIBUTES)) mask|=ACE_READ_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.WRITE_ATTRIBUTES)) mask|=ACE_WRITE_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.DELETE)) mask|=ACE_DELETE;\nif (aceMask.contains(AclEntryPermission.READ_ACL)) mask|=ACE_READ_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_ACL)) mask|=ACE_WRITE_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_OWNER)) mask|=ACE_WRITE_OWNER;\nif (aceMask.contains(AclEntryPermission.SYNCHRONIZE)) mask|=ACE_SYNCHRONIZE;\nSet<AclEntryFlag> aceFlags=ace.flags();\nif (aceFlags.contains(AclEntryFlag.FILE_INHERIT)) flags|=ACE_FILE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.DIRECTORY_INHERIT)) flags|=ACE_DIRECTORY_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.NO_PROPAGATE_INHERIT)) flags|=ACE_NO_PROPAGATE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.INHERIT_ONLY)) flags|=ACE_INHERIT_ONLY_ACE;\nunsafe.putInt(offset + OFFSETOF_UID,uid);\nunsafe.putInt(offset + OFFSETOF_MASK,mask);\nunsafe.putShort(offset + OFFSETOF_FLAGS,(short)flags);\nunsafe.putShort(offset + OFFSETOF_TYPE,(short)type);\noffset+=SIZEOF_ACE_T;\n}\n}\n", "docstring": "encode the acl to the given buffer", "partition": "test"}
{"idx": "1231", "code": "public Process(final String xmlString) throws IOException, XMLException {\n  initContext();\n  StringReader in=new StringReader(xmlString);\n  readProcess(in);\n  in.close();\n}\n", "docstring": "reads an process configuration from an xml string .", "partition": "test"}
{"idx": "3736", "code": "default ByteBuffer serialize(T value){\n  ByteBuffer buffer=ByteBuffer.allocate(size(value));\n  serialize(value,buffer);\n  return buffer;\n}\n", "docstring": "serialize to a byte buffer", "partition": "test"}
{"idx": "2549", "code": "protected boolean isIDPProxyEnabled(FSAuthnRequest authnRequest) throws FSException {\n  if (authnRequest.getMinorVersion() != IFSConstants.FF_12_PROTOCOL_MINOR_VERSION) {\n    return false;\n  }\n  FSScoping scoping=authnRequest.getScoping();\n  if (scoping != null && scoping.getProxyCount() == 0) {\n    return false;\n  }\n  String enabledString=IDFFMetaUtils.getFirstAttributeValueFromConfig(spConfig,IFSConstants.ENABLE_IDP_PROXY);\n  if (enabledString != null && enabledString.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "checks if the identity provider is configured for proxying the authentication requests for a requesting service provider .", "partition": "test"}
{"idx": "2833", "code": "private boolean isIndexable(String term){\n  return (term.length() < 30) && (term.length() > 2);\n}\n", "docstring": "checks a term if it can be processed indexed .", "partition": "test"}
{"idx": "1891", "code": "private int decodeRunLength(int k){\n  if ((k & 1) == 1) {\n    return ((k >>> 1) & 63) ^ 63;\n  }\n else {\n    return Integer.numberOfLeadingZeros(k << p + (31 - sp)) + 1;\n  }\n}\n", "docstring": "more of less the opposite of the encoding function but just for getting out run lengths .", "partition": "test"}
{"idx": "3309", "code": "public String fullForm(final String str,final String lowString){\n  String ret=lowString;\n  PrefixEntry found=prefixMap.get(str);\n  if (found != null) {\n    ret=found.prefixSingular + ret;\n  }\n else {\n    for (    PrefixEntry entry : prefixEndList) {\n      if (str.endsWith(entry.keyword)) {\n        ret=Grammar.addPrefixIfNotAlreadyThere(ret,entry.prefixSingular,entry.prefixPlural);\n        break;\n      }\n    }\n  }\n  return ret;\n}\n", "docstring": "prefix one of the registered nouns with an expression like \" piece of \" .", "partition": "test"}
{"idx": "2976", "code": "static int writeVarLong(OutputStream out,long x) throws IOException {\n  int len=0;\n  while ((x & ~0x7f) != 0) {\n    out.write((byte)(0x80 | (x & 0x7f)));\n    x>>>=7;\n    len++;\n  }\n  out.write((byte)x);\n  return ++len;\n}\n", "docstring": "write a variable size long value .", "partition": "test"}
{"idx": "1251", "code": "public void cleanStart(){\n  Connection conn=getConnection(true,true);\n  if (conn == null)   throw new IllegalStateException(\"No Database\");\n  dropDatabase(conn);\n  createUser(conn);\n  createDatabase(conn);\n  try {\n    if (conn != null)     conn.close();\n  }\n catch (  SQLException e2) {\n    log.log(Level.SEVERE,\"close connection\",e2);\n  }\n  conn=null;\n}\n", "docstring": "clean start - drop & re - create db", "partition": "test"}
{"idx": "3011", "code": "public void testFilteredClassifier(){\n  Instances data;\n  int i;\n  if (m_FilteredClassifier == null) {\n    return;\n  }\n  try {\n    data=getFilteredClassifierData();\n    m_FilteredClassifier.buildClassifier(data);\n    for (i=0; i < data.numInstances(); i++) {\n      m_FilteredClassifier.classifyInstance(data.instance(i));\n    }\n  }\n catch (  Exception e) {\n    fail(\"Problem with FilteredClassifier: \" + e.toString());\n  }\n}\n", "docstring": "tests the filter in conjunction with the filteredclassifier", "partition": "test"}
{"idx": "2810", "code": "public static boolean isPrimitiveDatatype(IRI datatype){\n  return datatype.equals(XMLSchema.DURATION) || datatype.equals(XMLSchema.DATETIME) || datatype.equals(XMLSchema.TIME)|| datatype.equals(XMLSchema.DATE)|| datatype.equals(XMLSchema.GYEARMONTH)|| datatype.equals(XMLSchema.GYEAR)|| datatype.equals(XMLSchema.GMONTHDAY)|| datatype.equals(XMLSchema.GDAY)|| datatype.equals(XMLSchema.GMONTH)|| datatype.equals(XMLSchema.STRING)|| datatype.equals(XMLSchema.BOOLEAN)|| datatype.equals(XMLSchema.BASE64BINARY)|| datatype.equals(XMLSchema.HEXBINARY)|| datatype.equals(XMLSchema.FLOAT)|| datatype.equals(XMLSchema.DECIMAL)|| datatype.equals(XMLSchema.DOUBLE)|| datatype.equals(XMLSchema.ANYURI)|| datatype.equals(XMLSchema.QNAME)|| datatype.equals(XMLSchema.NOTATION);\n}\n", "docstring": "checks whether the supplied datatype is a primitive xml schema datatype .", "partition": "test"}
{"idx": "3727", "code": "public void acquireProbabilities(final String string){\n  if (string.length() < 2) {\n    return;\n  }\n  for (int i=2; i < string.length(); ++i) {\n    final char previousChar=string.charAt(i - 2);\n    final char currentChar=string.charAt(i - 1);\n    final char nextChar=string.charAt(i);\n    final String key=previousChar + \"\" + currentChar;\n    if (!sequences.contains(key)) {\n      sequences.add(key);\n    }\n    HashMap<Character,Integer> probabilities=sequenceProbabilities.get(key);\n    if (probabilities == null) {\n      probabilities=new HashMap<>();\n      sequenceProbabilities.put(key,probabilities);\n    }\n    int existingValue=probabilities.getOrDefault(nextChar,0);\n    ++existingValue;\n    probabilities.put(nextChar,existingValue);\n  }\n}\n", "docstring": "parses the specified string to determine the probability of a character appearing after the previous two characters beginning with the third character in the string and ending with the last .", "partition": "test"}
{"idx": "2385", "code": "public final void readFromStream(DataInputStream dis,int version) throws IOException, ChessParseError {\n  event=dis.readUTF();\n  site=dis.readUTF();\n  date=dis.readUTF();\n  round=dis.readUTF();\n  white=dis.readUTF();\n  black=dis.readUTF();\n  startPos=TextIO.readFEN(dis.readUTF());\n  currentPos=new Position(startPos);\n  timeControl=dis.readUTF();\n  if (version >= 2) {\n    whiteTimeControl=dis.readUTF();\n    blackTimeControl=dis.readUTF();\n  }\n else {\n    whiteTimeControl=\"?\";\n    blackTimeControl=\"?\";\n  }\n  int nTags=dis.readInt();\n  tagPairs.clear();\n  for (int i=0; i < nTags; i++) {\n    TagPair tp=new TagPair();\n    tp.tagName=dis.readUTF();\n    tp.tagValue=dis.readUTF();\n    tagPairs.add(tp);\n  }\n  rootNode=new Node();\n  Node.readFromStream(dis,rootNode);\n  currentNode=rootNode;\n  int pathLen=dis.readInt();\n  for (int i=0; i < pathLen; i++)   goForward(dis.readInt());\n  updateListener();\n}\n", "docstring": "de - serialize from input stream .", "partition": "test"}
{"idx": "3101", "code": "public Shape chartToScreenShape(Shape s){\n  GeneralPath p=new GeneralPath();\n  Transform inverse=Transform.makeTranslation(getAbsoluteX(),getAbsoluteY());\n  if (currentTransform != null) {\n    inverse.concatenate(currentTransform);\n  }\n  p.append(s.getPathIterator(inverse),false);\n  return p;\n}\n", "docstring": "converts a screen coordinate spaced shape to the same shape in the chart coordinate space", "partition": "test"}
{"idx": "3833", "code": "protected void adjustCanopies(double[] densities){\n  if (m_numClustersRequested < 0) {\n    assignCanopiesToCanopyCenters();\n    m_trainingData=new Instances(m_canopies,0);\n    return;\n  }\n  if (m_canopies.numInstances() > m_numClustersRequested) {\n    int[] sortedIndexes=Utils.stableSort(densities);\n    Instances finalCanopies=new Instances(m_canopies,0);\n    int count=0;\n    for (int i=sortedIndexes.length - 1; count < m_numClustersRequested; i--) {\n      finalCanopies.add(m_canopies.instance(sortedIndexes[i]));\n      count++;\n    }\n    m_canopies=finalCanopies;\n    List<double[][]> tempCanopyCenters=new ArrayList<double[][]>();\n    List<double[]> tempT2Dists=new ArrayList<double[]>();\n    List<double[]> tempMissings=new ArrayList<double[]>();\n    count=0;\n    for (int i=sortedIndexes.length - 1; count < finalCanopies.numInstances(); i--) {\n      tempCanopyCenters.add(m_canopyCenters.get(sortedIndexes[i]));\n      tempT2Dists.add(m_canopyT2Density.get(sortedIndexes[i]));\n      tempMissings.add(m_canopyNumMissingForNumerics.get(sortedIndexes[i]));\n      count++;\n    }\n    m_canopyCenters=tempCanopyCenters;\n    m_canopyT2Density=tempT2Dists;\n    m_canopyNumMissingForNumerics=tempMissings;\n  }\n else   if (m_canopies.numInstances() < m_numClustersRequested && m_trainingData != null && m_trainingData.numInstances() > 0) {\n    Random r=new Random(getSeed());\n    for (int i=0; i < 10; i++) {\n      r.nextInt();\n    }\n    HashMap<DecisionTableHashKey,Integer> initC=new HashMap<DecisionTableHashKey,Integer>();\n    DecisionTableHashKey hk=null;\n    for (int i=0; i < m_canopies.numInstances(); i++) {\n      try {\n        hk=new DecisionTableHashKey(m_canopies.instance(i),m_canopies.numAttributes(),true);\n        initC.put(hk,null);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n    }\n    for (int j=m_trainingData.numInstances() - 1; j >= 0; j--) {\n      int instIndex=r.nextInt(j + 1);\n      try {\n        hk=new DecisionTableHashKey(m_trainingData.instance(instIndex),m_trainingData.numAttributes(),true);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n      if (!initC.containsKey(hk)) {\n        Instance newInstance=m_trainingData.instance(instIndex);\n        m_canopies.add(newInstance);\n        double[] density=new double[1];\n        density[0]=1.0;\n        m_canopyT2Density.add(density);\n        double[][] center=new double[newInstance.numAttributes()][0];\n        double[] numMissingNumerics=new double[newInstance.numAttributes()];\n        updateCanopyCenter(newInstance,center,numMissingNumerics);\n        m_canopyCenters.add(center);\n        m_canopyNumMissingForNumerics.add(numMissingNumerics);\n        initC.put(hk,null);\n      }\n      m_trainingData.swap(j,instIndex);\n      if (m_canopies.numInstances() == m_numClustersRequested) {\n        break;\n      }\n    }\n  }\n  assignCanopiesToCanopyCenters();\n  m_trainingData=new Instances(m_canopies,0);\n}\n", "docstring": "adjust the final number of canopies to match the user - requested number ( if possible )", "partition": "test"}
{"idx": "774", "code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    ByteBuffer buffer=ByteBuffer.wrap((byte[])newVal);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      aggVal+=buffer.getLong();\n      count+=buffer.getDouble();\n      firstTime=false;\n    }\n    return;\n  }\n  aggVal+=(Long)newVal;\n  count++;\n  firstTime=false;\n}\n", "docstring": "average aggregate function which will add all the aggregate values and it will increment the total count every time , for average value", "partition": "test"}
{"idx": "3343", "code": "public ConstraintMap createAssignmentConstraints(final AnnotatedTypeMirror assignedTo,final AnnotatedTypeMirror boxedReturnType,final AnnotatedExecutableType methodType,final Set<AFConstraint> afArgumentConstraints,final Map<TypeVariable,AnnotatedTypeMirror> inferredArgs,final Set<TypeVariable> targets,final AnnotatedTypeFactory typeFactory){\n  final LinkedList<AFConstraint> assignmentAfs=new LinkedList<>();\n  for (  AnnotatedTypeVariable typeParam : methodType.getTypeVariables()) {\n    final TypeVariable target=typeParam.getUnderlyingType();\n    final AnnotatedTypeMirror inferredType=inferredArgs.get(target);\n    if (inferredType != null) {\n      assignmentAfs.add(new A2F(inferredType,typeParam.getUpperBound()));\n      assignmentAfs.add(new F2A(typeParam.getLowerBound(),inferredType));\n    }\n else {\n      assignmentAfs.add(new F2A(typeParam,typeParam.getUpperBound()));\n      assignmentAfs.add(new A2F(typeParam.getLowerBound(),typeParam));\n    }\n  }\n  for (  AFConstraint argConstraint : afArgumentConstraints) {\n    if (argConstraint instanceof F2A) {\n      assignmentAfs.add(argConstraint);\n    }\n  }\n  LinkedList<AFConstraint> substitutedAssignmentConstraints=new LinkedList<>();\n  for (  AFConstraint afConstraint : assignmentAfs) {\n    substitutedAssignmentConstraints.add(afConstraint.substitute(inferredArgs));\n  }\n  final AnnotatedTypeMirror substitutedReturnType=TypeArgInferenceUtil.substitute(inferredArgs,boxedReturnType);\n  substitutedAssignmentConstraints.add(new F2A(substitutedReturnType,assignedTo));\n  final Set<AFConstraint> reducedConstraints=new LinkedHashSet<>();\n  reduceAfConstraints(typeFactory,reducedConstraints,substitutedAssignmentConstraints,targets);\n  final Set<TUConstraint> tuAssignmentConstraints=afToTuConstraints(reducedConstraints,targets);\n  addConstraintsBetweenTargets(tuAssignmentConstraints,targets,true,typeFactory);\n  return constraintMapBuilder.build(targets,tuAssignmentConstraints,typeFactory);\n}\n", "docstring": "the first half of step 6 . this method creates constraints : a ) between the bounds of types that are already inferred and their inferred arguments b ) between the assignment context and the return type of the method ( with the previously inferred arguments substituted into these constraints )", "partition": "test"}
{"idx": "432", "code": "public final void goToNextPage(){\n  final boolean isLastPage=viewPager.getCurrentItem() == (pages.size() - 1);\n  if (!isLastPage) {\n    viewPager.setCurrentItem(viewPager.getCurrentItem() + 1,true);\n  }\n}\n", "docstring": "navigates to the next page ( if not already there ) .", "partition": "test"}
{"idx": "2156", "code": "public int onBlockExploded(){\n  return (int)(fuseTime / 2 + Math.random() * fuseTime / 4);\n}\n", "docstring": "called when the block for of this explosive is destroy by an explosion", "partition": "test"}
{"idx": "3310", "code": "public void clearPasswordExpirationWarnedTime(){\n  operations.add(PasswordPolicyStateOperationType.CLEAR_PASSWORD_EXPIRATION_WARNED_TIME);\n}\n", "docstring": "clears the password expiration warned time .", "partition": "test"}
{"idx": "2757", "code": "private P filterLargeValueSets(FilterSpec fs,MetaDataObject rootMeta,F root,boolean forceEntityBased,JoinType defaultPredicateJoinType){\n  ArrayList<FilterSpec> specs=new ArrayList<>();\n  List<?> list=new ArrayList<>((Collection<?>)fs.getValue());\n  for (int i=0; i < list.size(); i+=ORACLE_PARAM_LIMIT) {\n    int nextOffset=i + Math.min(list.size() - i,ORACLE_PARAM_LIMIT);\n    List<?> batchList=list.subList(i,nextOffset);\n    specs.add(new FilterSpec(fs.getAttributePath(),fs.getOperator(),batchList));\n  }\n  FilterSpec orSpec=FilterSpec.or(specs);\n  return filterSpecListToPredicate(rootMeta,root,orSpec,forceEntityBased,defaultPredicateJoinType);\n}\n", "docstring": "split filters with two many value possibilities . for example , oracle cannot handle more than 1000 .", "partition": "test"}
{"idx": "4153", "code": "void repaintChildren(){\n  for (  Component child : panel.getComponents()) {\n    child.repaint();\n  }\n}\n", "docstring": "request repainting of all the child panels .", "partition": "test"}
{"idx": "171", "code": "private void createMigrationTaskPage(){\n  MigrationTaskEditor migrationTaskEditor=new MigrationTaskEditor(migrationTask,getContainer());\n  int index=addPage(migrationTaskEditor.getControl());\n  setPageText(index,\"Task\");\n  taskListeners.add(migrationTaskEditor);\n}\n", "docstring": "create the basic editor .", "partition": "test"}
{"idx": "2884", "code": "protected ConnectionStateSSLv3(SSLSessionImpl session){\n  try {\n    CipherSuite cipherSuite=session.cipherSuite;\n    boolean is_exportabe=cipherSuite.isExportable();\n    hash_size=cipherSuite.getMACLength();\n    int key_size=(is_exportabe) ? cipherSuite.keyMaterial : cipherSuite.expandedKeyMaterial;\n    int iv_size=cipherSuite.ivSize;\n    block_size=cipherSuite.getBlockSize();\n    String algName=cipherSuite.getBulkEncryptionAlgorithm();\n    String hashName=cipherSuite.getHashName();\n    if (logger != null) {\n      logger.println(\"ConnectionStateSSLv3.create:\");\n      logger.println(\"  cipher suite name: \" + session.getCipherSuite());\n      logger.println(\"  encryption alg name: \" + algName);\n      logger.println(\"  hash alg name: \" + hashName);\n      logger.println(\"  hash size: \" + hash_size);\n      logger.println(\"  block size: \" + block_size);\n      logger.println(\"  IV size:\" + iv_size);\n      logger.println(\"  key size: \" + key_size);\n    }\n    byte[] clientRandom=session.clientRandom;\n    byte[] serverRandom=session.serverRandom;\n    byte[] key_block=new byte[2 * hash_size + 2 * key_size + 2 * iv_size];\n    byte[] seed=new byte[clientRandom.length + serverRandom.length];\n    System.arraycopy(serverRandom,0,seed,0,serverRandom.length);\n    System.arraycopy(clientRandom,0,seed,serverRandom.length,clientRandom.length);\n    PRF.computePRF_SSLv3(key_block,session.master_secret,seed);\n    byte[] client_mac_secret=new byte[hash_size];\n    byte[] server_mac_secret=new byte[hash_size];\n    byte[] client_key=new byte[key_size];\n    byte[] server_key=new byte[key_size];\n    boolean is_client=!session.isServer;\n    System.arraycopy(key_block,0,client_mac_secret,0,hash_size);\n    System.arraycopy(key_block,hash_size,server_mac_secret,0,hash_size);\n    System.arraycopy(key_block,2 * hash_size,client_key,0,key_size);\n    System.arraycopy(key_block,2 * hash_size + key_size,server_key,0,key_size);\n    IvParameterSpec clientIV=null;\n    IvParameterSpec serverIV=null;\n    if (is_exportabe) {\n      if (logger != null) {\n        logger.println(\"ConnectionStateSSLv3: is_exportable\");\n      }\n      MessageDigest md5=MessageDigest.getInstance(\"MD5\");\n      md5.update(client_key);\n      md5.update(clientRandom);\n      md5.update(serverRandom);\n      client_key=md5.digest();\n      md5.update(server_key);\n      md5.update(serverRandom);\n      md5.update(clientRandom);\n      server_key=md5.digest();\n      key_size=cipherSuite.expandedKeyMaterial;\n      if (block_size != 0) {\n        md5.update(clientRandom);\n        md5.update(serverRandom);\n        clientIV=new IvParameterSpec(md5.digest(),0,iv_size);\n        md5.update(serverRandom);\n        md5.update(clientRandom);\n        serverIV=new IvParameterSpec(md5.digest(),0,iv_size);\n      }\n    }\n else     if (block_size != 0) {\n      clientIV=new IvParameterSpec(key_block,2 * hash_size + 2 * key_size,iv_size);\n      serverIV=new IvParameterSpec(key_block,2 * hash_size + 2 * key_size + iv_size,iv_size);\n    }\n    if (logger != null) {\n      logger.println(\"is exportable: \" + is_exportabe);\n      logger.println(\"master_secret\");\n      logger.print(session.master_secret);\n      logger.println(\"client_random\");\n      logger.print(clientRandom);\n      logger.println(\"server_random\");\n      logger.print(serverRandom);\n      logger.println(\"client_mac_secret\");\n      logger.print(client_mac_secret);\n      logger.println(\"server_mac_secret\");\n      logger.print(server_mac_secret);\n      logger.println(\"client_key\");\n      logger.print(client_key,0,key_size);\n      logger.println(\"server_key\");\n      logger.print(server_key,0,key_size);\n      if (clientIV != null) {\n        logger.println(\"client_iv\");\n        logger.print(clientIV.getIV());\n        logger.println(\"server_iv\");\n        logger.print(serverIV.getIV());\n      }\n else {\n        logger.println(\"no IV.\");\n      }\n    }\n    if (algName == null) {\n      encCipher=new NullCipher();\n      decCipher=new NullCipher();\n    }\n else {\n      encCipher=Cipher.getInstance(algName);\n      decCipher=Cipher.getInstance(algName);\n      if (is_client) {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(client_key,0,key_size,algName),clientIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(server_key,0,key_size,algName),serverIV);\n      }\n else {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(server_key,0,key_size,algName),serverIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(client_key,0,key_size,algName),clientIV);\n      }\n    }\n    messageDigest=MessageDigest.getInstance(hashName);\n    if (is_client) {\n      mac_write_secret=client_mac_secret;\n      mac_read_secret=server_mac_secret;\n    }\n else {\n      mac_write_secret=server_mac_secret;\n      mac_read_secret=client_mac_secret;\n    }\n    if (hashName.equals(\"MD5\")) {\n      pad_1=SSLv3Constants.MD5pad1;\n      pad_2=SSLv3Constants.MD5pad2;\n    }\n else {\n      pad_1=SSLv3Constants.SHApad1;\n      pad_2=SSLv3Constants.SHApad2;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new AlertException(AlertProtocol.INTERNAL_ERROR,new SSLProtocolException(\"Error during computation of security parameters\"));\n  }\n}\n", "docstring": "creates the instance of ssl v3 connection state . all of the security parameters are provided by session object .", "partition": "test"}
{"idx": "2770", "code": "@Override public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {\n  if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {\n    SNMP_ADAPTOR_LOGGER.logp(Level.FINEST,dbgTag,\"removeNotificationListener\",\"Removing listener \" + listener);\n  }\n  notifBroadcaster.removeNotificationListener(listener);\n}\n", "docstring": "removes the specified listener from this communicatorserver . note that if the listener has been registered with different handback objects or notification filters , all entries corresponding to the listener will be removed .", "partition": "test"}
{"idx": "2427", "code": "@Override public List chunkString(String sToChunk){\n  Integer[] iRes=splitPointsByDelimiterList(sToChunk,getDelimiters());\n  String[] sRes=splitStringByDelimiterPoints(sToChunk,iRes);\n  return Arrays.asList(sRes);\n}\n", "docstring": "returns a list of string chunks , derived from a given string .", "partition": "test"}
{"idx": "479", "code": "public static <S>boolean containsAtleastOne(Collection<S> left,Collection<S> right){\n  if (left == null || right == null) {\n    return false;\n  }\n  for (  S id : left) {\n    if (right.contains(id)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if right hand collection has atleast one same item as left hand collection .", "partition": "test"}
{"idx": "2764", "code": "static public void process(String input,String output,String packFileName){\n  process(new Settings(),input,output,packFileName);\n}\n", "docstring": "packs using defaults settings .", "partition": "test"}
{"idx": "4182", "code": "private void createBlockMirrorData(String name,int numBlockMirrors) throws Exception {\n  Volume volume=new Volume();\n  URI volumeURI=URIUtil.createId(Volume.class);\n  testVolumeURIs.add(volumeURI);\n  volume.setId(volumeURI);\n  volume.setLabel(\"blockMirrorVolume\");\n  URI cgUri=createBlockConsistencyGroup(\"blockMirrorVolume-cg\");\n  volume.setConsistencyGroup(cgUri);\n  _dbClient.createObject(volume);\n  for (int i=1; i <= numBlockMirrors; i++) {\n    BlockMirror blockMirror=new BlockMirror();\n    URI blockMirrorURI=URIUtil.createId(BlockMirror.class);\n    testBlockMirrorURIs.add(blockMirrorURI);\n    blockMirror.setId(blockMirrorURI);\n    blockMirror.setLabel(name + i);\n    blockMirror.setConsistencyGroup(cgUri);\n    _dbClient.createObject(blockMirror);\n  }\n}\n", "docstring": "creates the blockobject blockmirror data .", "partition": "test"}
{"idx": "202", "code": "private void initializeLayout(){\n  GridLayout gl=new GridLayout(0,2);\n  gl.setVgap(5);\n  setLayout(gl);\n  add(new JLabel(\"Frozen: \"));\n  add(frozenDD);\n  add(new JLabel(\"Upper Bound:\"));\n  add(tfUpBound);\n  add(new JLabel(\"Lower Bound\"));\n  add(tfLowBound);\n  add(new JLabel(\"Increment:\"));\n  add(tfIncrement);\n  add(new JLabel(\"Delay:\"));\n  add(tfDelay);\n  setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n}\n", "docstring": "lays out the panel", "partition": "test"}
{"idx": "2539", "code": "public String globalInfo(){\n  return \"Generates a single train/test split and calls the appropriate \" + \"SplitEvaluator to generate some results.\";\n}\n", "docstring": "returns a string describing this result producer", "partition": "test"}
{"idx": "1173", "code": "private void reloadModelWithNewValue(final Long newValue){\n  final long newValueAsPrimitive=newValue == null ? getModelUpdatePeriod() : newValue;\n  for (  final PropertyChangeListener listener : modelUpdatePeriodListeners) {\n    final PropertyChangeEvent event=new PropertyChangeEvent(this,\"model\",getModelUpdatePeriod(),newValueAsPrimitive);\n    listener.propertyChange(event);\n  }\n}\n", "docstring": "notify all listeners about cacheperiod property changed . if passed newvalue is null , the oldvalue is taken as new value . this is the case when the reloadmodel is invoked .", "partition": "test"}
{"idx": "1911", "code": "private void resetShapeBounds(){\n  RoundRectangle2D.Double rrect=(RoundRectangle2D.Double)shape;\n  rrect.setRoundRect(0,0,getBounds().width - 1,getBounds().height - 1,10,10);\n}\n", "docstring": "rests the boundaries of the shape which is drawn as the rubberband . the boundaries of the shape need to be set so that when drawn they lie just inside the boundaries of the component on all four sides .", "partition": "test"}
{"idx": "3246", "code": "protected String e(String s) throws Exception {\n  return fmt.format(parser.parse(s,null));\n}\n", "docstring": "macro : expected : parses s , fmts", "partition": "test"}
{"idx": "666", "code": "public FunctionExecutionPooledExecutor(BlockingQueue<Runnable> q,int poolSize,PoolStatHelper stats,ThreadFactory tf){\n  this(q,poolSize,stats,tf,Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + \"IDLE_THREAD_TIMEOUT\",30000 * 60),false);\n}\n", "docstring": "sets timeout to idle_thread_timeout", "partition": "test"}
{"idx": "937", "code": "private void throwArrayIndexOutOfBoundsException(int itemIndex){\n  throw new ArrayIndexOutOfBoundsException(\"Your item index can\\'t be 0 or greater than space item size,\" + \" your items size is \" + spaceItems.size() + \", your current index is :\"+ itemIndex);\n}\n", "docstring": "throw array index out of bounds exception", "partition": "test"}
{"idx": "419", "code": "public JSONObject toJson() throws JSONException {\n  JSONObject json=new JSONObject();\n  JSONArray jpods=new JSONArray();\n  for (  DiasporaPod pod : pods) {\n    jpods.put(pod.toJson());\n  }\n  json.put(\"pods\",jpods);\n  json.put(\"timestamp\",System.currentTimeMillis());\n  return json;\n}\n", "docstring": "convert diasporapodlist to json", "partition": "test"}
{"idx": "1344", "code": "public void replace(ClassNode type,int n){\n  remove(n);\n  push(type);\n}\n", "docstring": "replace n top level elements with new element of given type", "partition": "test"}
{"idx": "2516", "code": "public void build(SolrCore core,SolrIndexSearcher searcher) throws IOException {\n  LOG.info(\"SolrSuggester.build(\" + name + \")\");\n  dictionary=dictionaryFactory.create(core,searcher);\n  lookup.build(dictionary);\n  if (storeDir != null) {\n    File target=getStoreFile();\n    if (!lookup.store(new FileOutputStream(target))) {\n      LOG.error(\"Store Lookup build failed\");\n    }\n else {\n      LOG.info(\"Stored suggest data to: \" + target.getAbsolutePath());\n    }\n  }\n}\n", "docstring": "build the underlying lucene suggester", "partition": "test"}
{"idx": "759", "code": "public static <T>Collection<T> makeImmutable(Collection<T> mutableCollection){\n  Collection<T> newCollection;\n  try {\n    @SuppressWarnings(\"unchecked\") Class<Collection<T>> cls=(Class<Collection<T>>)mutableCollection.getClass();\n    newCollection=cls.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n  for (  T element : mutableCollection) {\n    newCollection.add(Utils.makeImmutable(element));\n  }\n  return Collections.unmodifiableCollection(newCollection);\n}\n", "docstring": "a recursive call to make a collection and all it \"'\" s values immutable .", "partition": "test"}
{"idx": "1718", "code": "private void applyL1Reg(final double eta_t,Vec x){\n  if (lambda1 > 0) {\n    l1U+=eta_t * lambda1;\n    for (int k=0; k < ws.length; k++) {\n      final Vec w_k=ws[k];\n      final double[] l1Q_k=l1Q[k];\n      for (      IndexValue iv : x) {\n        final int i=iv.getIndex();\n        final double z=w_k.get(i);\n        double newW_i=0;\n        if (z > 0)         newW_i=Math.max(0,z - (l1U + l1Q_k[i]));\n else         if (z < 0)         newW_i=Math.min(0,z + (l1U - l1Q_k[i]));\n        l1Q_k[i]+=(newW_i - z);\n        w_k.set(i,newW_i);\n      }\n    }\n  }\n}\n", "docstring": "applies l1 regularization to the model", "partition": "test"}
{"idx": "3201", "code": "public static double incompleteBetaFraction2(double a,double b,double x){\n  double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;\n  double k1, k2, k3, k4, k5, k6, k7, k8;\n  double r, t, ans, z, thresh;\n  int n;\n  k1=a;\n  k2=b - 1.0;\n  k3=a;\n  k4=a + 1.0;\n  k5=1.0;\n  k6=a + b;\n  k7=a + 1.0;\n  ;\n  k8=a + 2.0;\n  pkm2=0.0;\n  qkm2=1.0;\n  pkm1=1.0;\n  qkm1=1.0;\n  z=x / (1.0 - x);\n  ans=1.0;\n  r=1.0;\n  n=0;\n  thresh=3.0 * MACHEP;\n  do {\n    xk=-(z * k1 * k2) / (k3 * k4);\n    pk=pkm1 + pkm2 * xk;\n    qk=qkm1 + qkm2 * xk;\n    pkm2=pkm1;\n    pkm1=pk;\n    qkm2=qkm1;\n    qkm1=qk;\n    xk=(z * k5 * k6) / (k7 * k8);\n    pk=pkm1 + pkm2 * xk;\n    qk=qkm1 + qkm2 * xk;\n    pkm2=pkm1;\n    pkm1=pk;\n    qkm2=qkm1;\n    qkm1=qk;\n    if (qk != 0) {\n      r=pk / qk;\n    }\n    if (r != 0) {\n      t=Math.abs((ans - r) / r);\n      ans=r;\n    }\n else {\n      t=1.0;\n    }\n    if (t < thresh) {\n      return ans;\n    }\n    k1+=1.0;\n    k2-=1.0;\n    k3+=2.0;\n    k4+=2.0;\n    k5+=1.0;\n    k6+=1.0;\n    k7+=2.0;\n    k8+=2.0;\n    if ((Math.abs(qk) + Math.abs(pk)) > big) {\n      pkm2*=biginv;\n      pkm1*=biginv;\n      qkm2*=biginv;\n      qkm1*=biginv;\n    }\n    if ((Math.abs(qk) < biginv) || (Math.abs(pk) < biginv)) {\n      pkm2*=big;\n      pkm1*=big;\n      qkm2*=big;\n      qkm1*=big;\n    }\n  }\n while (++n < 300);\n  return ans;\n}\n", "docstring": "continued fraction expansion # 2 for incomplete beta integral .", "partition": "test"}
{"idx": "2720", "code": "public boolean hasMapObjects(){\n  return mapObjects != null && !mapObjects.isEmpty();\n}\n", "docstring": "indicates whether this map layer has any map objects .", "partition": "test"}
{"idx": "2893", "code": "public static boolean pointOutsidePrefSize(JTable table,int row,int column,Point p){\n  if (table.convertColumnIndexToModel(column) != 0 || row == -1) {\n    return true;\n  }\n  TableCellRenderer tcr=table.getCellRenderer(row,column);\n  Object value=table.getValueAt(row,column);\n  Component cell=tcr.getTableCellRendererComponent(table,value,false,false,row,column);\n  Dimension itemSize=cell.getPreferredSize();\n  Rectangle cellBounds=table.getCellRect(row,column,false);\n  cellBounds.width=itemSize.width;\n  cellBounds.height=itemSize.height;\n  assert (p.x >= cellBounds.x && p.y >= cellBounds.y);\n  return p.x > cellBounds.x + cellBounds.width || p.y > cellBounds.y + cellBounds.height;\n}\n", "docstring": "returns true if the given point is outside the preferredsize of the item at the given row of the table . ( column must be 0 ) . does not check the \" table . isfilelist \" property . that should be checked before calling this method . this is used to make windowsl & f jfilechooser act like native dialogs .", "partition": "test"}
{"idx": "836", "code": "static boolean lessThanUnsignedLong(long x1,long x2){\n  return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);\n}\n", "docstring": "returns true if x1 is less than x2 , when both values are treated as unsigned long .", "partition": "test"}
{"idx": "2478", "code": "synchronized boolean release(){\n  d(\"release()\");\n  if (state == BUSY) {\n    state=IDLE;\n    idleSince=System.currentTimeMillis();\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "changes the state of a connectiondesc from busy to idle and records the current time so that we will know how long it has been idle .", "partition": "test"}
{"idx": "55", "code": "public ImmutableArray2<K> insert(int index,K obj){\n  int len=length + 1;\n  int newLen=len;\n  boolean extendable;\n  if (index == len - 1) {\n    AtomicBoolean x=canExtend;\n    if (x != null) {\n      canExtend=null;\n      if (array.length > index && x.getAndSet(false)) {\n        array[index]=obj;\n        return new ImmutableArray2<K>(array,len,true);\n      }\n    }\n    extendable=true;\n    newLen=len + 4;\n  }\n else {\n    extendable=false;\n  }\n  @SuppressWarnings(\"unchecked\") K[] a2=(K[])new Object[newLen];\n  DataUtils.copyWithGap(array,a2,length,index);\n  a2[index]=obj;\n  return new ImmutableArray2<K>(a2,len,extendable);\n}\n", "docstring": "insert an entry at this index .", "partition": "test"}
{"idx": "255", "code": "public void addEvent(SimEvent newEvent){\n  newEvent.setSerial(serial++);\n  sortedSet.add(newEvent);\n}\n", "docstring": "adds a new event to the queue . adding a new event to the queue preserves the temporal order of the events in the queue .", "partition": "test"}
{"idx": "4125", "code": "private byte[] writeCheckedBytes(MessageNano proto){\n  BackupProtos.CheckedMessage wrapper=new BackupProtos.CheckedMessage();\n  wrapper.payload=MessageNano.toByteArray(proto);\n  CRC32 checksum=new CRC32();\n  checksum.update(wrapper.payload);\n  wrapper.checksum=checksum.getValue();\n  return MessageNano.toByteArray(wrapper);\n}\n", "docstring": "wrap a proto in a checkedmessage and compute the checksum .", "partition": "test"}
{"idx": "277", "code": "public static BNode parseBNode(String nTriplesBNode,ValueFactory valueFactory) throws IllegalArgumentException {\n  if (nTriplesBNode.startsWith(\"_:\")) {\n    return valueFactory.createBNode(nTriplesBNode.substring(2));\n  }\n else {\n    throw new IllegalArgumentException(\"Not a legal N-Triples Blank Node: \" + nTriplesBNode);\n  }\n}\n", "docstring": "parses an n - triples bnode , creates an object for it using the supplied valuefactory and returns this object .", "partition": "test"}
{"idx": "2144", "code": "public static double powQuick(double value,double power){\n  if (USE_JDK_MATH) {\n    return STRICT_MATH ? StrictMath.pow(value,power) : Math.pow(value,power);\n  }\n  return FastMath.exp(power * FastMath.logQuick(value));\n}\n", "docstring": "quick pow , with a max relative error of about 3 . 5e - 2 for | a ^ b | & lt ; 1e10 , of about 0 . 17 for | a ^ b | & lt ; 1e50 , and worse accuracy above .", "partition": "test"}
{"idx": "3266", "code": "public void push(final Type value){\n  if (value == null) {\n    mv.visitInsn(Opcodes.ACONST_NULL);\n  }\n else {\nswitch (value.getSort()) {\ncase Type.BOOLEAN:\n      mv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Boolean\",\"TYPE\",CLDESC);\n    break;\ncase Type.CHAR:\n  mv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Character\",\"TYPE\",CLDESC);\nbreak;\ncase Type.BYTE:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Byte\",\"TYPE\",CLDESC);\nbreak;\ncase Type.SHORT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Short\",\"TYPE\",CLDESC);\nbreak;\ncase Type.INT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Integer\",\"TYPE\",CLDESC);\nbreak;\ncase Type.FLOAT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Float\",\"TYPE\",CLDESC);\nbreak;\ncase Type.LONG:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Long\",\"TYPE\",CLDESC);\nbreak;\ncase Type.DOUBLE:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Double\",\"TYPE\",CLDESC);\nbreak;\ndefault :\nmv.visitLdcInsn(value);\n}\n}\n}\n", "docstring": "generates the instruction to push the given value on the stack .", "partition": "test"}
{"idx": "2043", "code": "public final synchronized byte[] toByteArray(){\n  ByteArrayOutputStream baos=null;\n  DataOutputStream dos=null;\n  try {\n    baos=new ByteArrayOutputStream(32768);\n    dos=new DataOutputStream(baos);\n    game.writeToStream(dos);\n    dos.flush();\n    return baos.toByteArray();\n  }\n catch (  IOException e) {\n    return null;\n  }\n finally {\n    if (dos != null)     try {\n      dos.close();\n    }\n catch (    IOException ex) {\n    }\n    if (baos != null)     try {\n      baos.close();\n    }\n catch (    IOException ex) {\n    }\n  }\n}\n", "docstring": "serialize to byte array .", "partition": "test"}
{"idx": "3082", "code": "public void closeFile(){\n  closeFile(true);\n}\n", "docstring": "closes the current tab", "partition": "test"}
{"idx": "132", "code": "public void add(@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(items.size());\n  }\n}\n", "docstring": "adds the specified item to the end of the list", "partition": "test"}
{"idx": "4168", "code": "protected static boolean isCglibGetCallbacks(AnnotatedMethod am){\n  Class<?> rt=am.getRawType();\n  if (rt == null || !rt.isArray()) {\n    return false;\n  }\n  Class<?> compType=rt.getComponentType();\n  Package pkg=compType.getPackage();\n  if (pkg != null) {\n    String pname=pkg.getName();\n    if (pname.startsWith(\"net.sf.cglib\") || pname.startsWith(\"org.hibernate.repackage.cglib\")) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "this method was added to address [ jackson - 53 ", "partition": "test"}
{"idx": "1061", "code": "private Sha256Hash calculateHash(){\n  try {\n    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(HEADER_SIZE);\n    writeHeader(bos);\n    return new Sha256Hash(Utils.reverseBytes(doubleDigest(bos.toByteArray())));\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "calculates the block hash by serializing the block and hashing the resulting bytes .", "partition": "test"}
{"idx": "4154", "code": "private static String readComment(String input,int index){\n  String comment=null;\n  Matcher matcher=COMMENT_PATTERN.matcher(input.substring(index));\n  if (matcher.find()) {\n    comment=matcher.group(1);\n    comment=comment.substring(1);\n  }\n  return comment;\n}\n", "docstring": "reads the first comment line from the input , and returns the comment line ( including the line break character ) without the leading \" # \" .", "partition": "test"}
{"idx": "1182", "code": "@Override public int compare(NewSplitEmittedTerm term1,NewSplitEmittedTerm term2){\n  return term1.compareTo(term2);\n}\n", "docstring": "compares term key 1 to term key 2 . note that terms are unique only in conjunction with their associated split and flush .", "partition": "test"}
{"idx": "4068", "code": "public static void closeQuiet(@Nullable SelectionKey rsrc){\n  if (rsrc != null)   closeQuiet(rsrc.channel());\n}\n", "docstring": "quietly closes given resource ignoring possible checked exceptions .", "partition": "test"}
{"idx": "1539", "code": "private static LDAPFilter createORFilter(FilterSet filterSet) throws LDAPException, IOException {\n  List<JAXBElement<?>> list=filterSet.getFilterGroup();\n  ArrayList<RawFilter> filters=new ArrayList<>(list.size());\n  for (  JAXBElement<?> filter : list) {\n    filters.add(createFilter(filter));\n  }\n  return LDAPFilter.createORFilter(filters);\n}\n", "docstring": "returns a new or search filter with the provided filter components .", "partition": "test"}
{"idx": "2916", "code": "public int size(){\n  return _attrs.size();\n}\n", "docstring": "get the number of attributes in the attribute set", "partition": "test"}
{"idx": "2326", "code": "private void writeLog(String cmd){\n  try {\n    if (m_writer == null) {\n      File file=File.createTempFile(\"create\",\".log\");\n      m_writer=new PrintWriter(new FileWriter(file));\n      log.info(file.toString());\n    }\n    m_writer.println(cmd);\n    m_writer.flush();\n  }\n catch (  Exception e) {\n    log.severe(e.toString());\n  }\n}\n", "docstring": "write to file log", "partition": "test"}
{"idx": "2284", "code": "private void writeJarPostResource(Element postResourceEl,String path){\n  postResourceEl.setAttribute(\"className\",JAR_RESOURCE_SET);\n  postResourceEl.setAttribute(\"base\",path.replace(\"&\",\"&amp;\"));\n}\n", "docstring": "write jar post resource", "partition": "test"}
{"idx": "1076", "code": "public void disable(RichFormatterFeature feature){\n  features.remove(feature);\n}\n", "docstring": "disable a specific feature on this rich formatter .", "partition": "test"}
{"idx": "506", "code": "private void renderForeground(final ExecutionUnit process,final Graphics2D g2,boolean printing){\n  if (drawHighlight && !printing && (model.isDragStarted() || model.isDropTargetSet() && model.isImportDragged()) || model.isOperatorSourceHovered()) {\nswitch (RapidMinerGUI.getDragHighlighteMode()) {\ncase FULL:\ncase BORDER:\n      drawDragBorder(process,g2);\n    break;\ncase NONE:\ndefault :\n  break;\n}\n}\n}\n", "docstring": "renders the drag border if needed .", "partition": "test"}
{"idx": "2821", "code": "static void policyChanged(String serviceTypeName,PolicyEvent pe){\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"PolicyEvaulator.policyChanged():serviceTypeName=\" + serviceTypeName);\n  }\n  resourceNamesMap.remove(serviceTypeName);\n  Cache resourceNamesCache=(Cache)resourceNamesMap.get(serviceTypeName);\n  if ((resourceNamesCache == null) || (resourceNamesCache.isEmpty())) {\n    return;\n  }\n  try {\n    DEBUG.error(\"PolicyEvaluator.policyChanged: enterred try block\");\n    ServiceTypeManager stm=ServiceTypeManager.getServiceTypeManager();\n    ServiceType serviceType=stm.getServiceType(serviceTypeName);\n    Set resourceNamesToRemove=new HashSet();\nsynchronized (resourceNamesCache) {\n      Enumeration resourceNames=resourceNamesCache.keys();\n      while (resourceNames.hasMoreElements()) {\n        String resourceName=(String)resourceNames.nextElement();\n        if (resourceNamesToRemove.contains(resourceName)) {\n          continue;\n        }\n        Set affectedResourceNames=pe.getResourceNames();\n        Iterator iter=affectedResourceNames.iterator();\n        while (iter.hasNext()) {\n          String affectedResourceName=(String)iter.next();\n          if (serviceType.compare(resourceName,affectedResourceName) != ResourceMatch.NO_MATCH) {\n            resourceNamesToRemove.add(resourceName);\n          }\n        }\n      }\n      Iterator iter1=resourceNamesToRemove.iterator();\n      while (iter1.hasNext()) {\n        String resourceNameToRemove=(String)iter1.next();\n        resourceNamesCache.remove(resourceNameToRemove);\n      }\n    }\n  }\n catch (  SSOException e) {\n    DEBUG.error(\"PolicyEvaluator.policyChanged:\",e);\n  }\ncatch (  PolicyException pex) {\n    DEBUG.error(\"PolicyEvaluator.policyChanged:\",pex);\n  }\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"PolicyEvaulator.policyChanged():serviceTypeName=\" + serviceTypeName + \", new cached resoruceNames=\"+ resourceNamesMap.get(serviceTypeName));\n  }\n}\n", "docstring": "handles policychanged notifications - clears the cached resource names for the service type name", "partition": "test"}
{"idx": "4188", "code": "public static StringBuffer replaceString(StringBuffer buffer,String[] parameters){\n  int placeHolderPosition=-1;\n  String placeHolder=null;\n  for (int i=0; i < parameters.length; i++) {\n    if (parameters[i] == null) {\n      break;\n    }\n    placeHolder=\"%\" + (i + 1) + \"%\";\n    placeHolderPosition=buffer.indexOf(placeHolder);\n    if (placeHolderPosition != -1) {\n      buffer.replace(placeHolderPosition,placeHolderPosition + placeHolder.length(),parameters[i]);\n    }\n else {\n      break;\n    }\n  }\n  return buffer;\n}\n", "docstring": "replaces the place holders by parameters", "partition": "test"}
{"idx": "3409", "code": "public void registerObserver(RuleChangesObserver observer){\n  observers.add(observer);\n}\n", "docstring": "registers an observer to be notified on routing rules changes .", "partition": "test"}
{"idx": "1390", "code": "public static boolean isWritable(final File file,final boolean makeDirs){\n  if (file == null) {\n    Log.e(FileUtils.class,\"isWritable(): Null or Empty parameter given\");\n    return false;\n  }\n  final String fileParentDir=file.getParent();\n  if (!TextUtils.isEmpty(fileParentDir)) {\n    final File fileDir=new File(fileParentDir);\n    if (!fileDir.exists()) {\n      if (makeDirs)       return makeDirsForFile(file);\n else       return false;\n    }\n  }\n  boolean isWritable=true;\n  if (file.exists())   isWritable=file.canWrite();\n else {\n    try {\n      isWritable=file.createNewFile();\n    }\n catch (    IOException e) {\n    }\n    if (isWritable)     isWritable=file.delete();\n  }\n  return isWritable;\n}\n", "docstring": "method checks if file could be written / deleted or created . method will create path / mkdirs if makedirs set to true and file \"'\" s path doesn \"'\" t exists .", "partition": "test"}
{"idx": "2088", "code": "public NSNumber(int i){\n  doubleValue=longValue=i;\n  type=INTEGER;\n}\n", "docstring": "creates an integer number .", "partition": "test"}
{"idx": "1850", "code": "public void onStart(){\n  if (mAudioMirrorBuffer == null) {\n    mAudioMirrorBuffer=new byte[262144];\n  }\n  if (mStreamer != null) {\n    mStreamer.start();\n  }\n  if (mInsecureStreamer != null) {\n    mInsecureStreamer.start();\n  }\n}\n", "docstring": "called when the playback service starts", "partition": "test"}
{"idx": "2106", "code": "public boolean hasNameValue(String name){\n  return nameValueMap.containsKey(name.toLowerCase());\n}\n", "docstring": "returns a boolean telling if this namevaluelist has a record with this name", "partition": "test"}
{"idx": "4008", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return PATH;\ncase 2:\n  return OFFSET_LBA;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "2995", "code": "public static void overwrite(long[] vector,long val,int offset,int len){\n  int idx=offset >> 6;\n  int bitIdx=offset & 63;\n  int truncatedValLen=Math.min(len,64 - bitIdx);\n  vector[idx]&=~(maskBelow(truncatedValLen) << bitIdx);\n  vector[idx]|=val << bitIdx;\n  if (len != truncatedValLen) {\n    long mask=maskBelow(len - truncatedValLen);\n    vector[idx + 1]&=~mask;\n    vector[idx + 1]|=(val >>> truncatedValLen);\n  }\n}\n", "docstring": "overwrites a bit range within the vector .", "partition": "test"}
{"idx": "26", "code": "protected void startAdditionalServices(final Cache cache,final Map<String,Object> options) throws Exception {\n}\n", "docstring": "this method is called immediately following cache creation in the spawned process , but prior to setting the running flag in the status file . so the spawning process will block until this method completes .", "partition": "test"}
{"idx": "1724", "code": "private void onUser(@NotNull TLAbsUser absUser){\n  User currentUser=null;\n  User user=null;\n  if (absUser instanceof TLUser) {\n    final TLUser tlUser=(TLUser)absUser;\n    if (tlUser.isMutualContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserContact(currentUser,tlUser);\n    }\n else     if (tlUser.isDeleted()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserDelete(currentUser,tlUser);\n    }\n else     if (tlUser.isContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserRequest(currentUser,tlUser);\n    }\n else     if (tlUser.isSelf() || !tlUser.isBot()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserForeign(currentUser,tlUser);\n    }\n else {\n      BotLogger.info(LOGTAG,\"Bot received\");\n    }\n  }\n  if ((currentUser == null) && (user != null)) {\n    databaseManager.addUser(user);\n  }\n else   if (user != null) {\n    databaseManager.updateUser(user);\n  }\n}\n", "docstring": "add a user to database", "partition": "test"}
{"idx": "2742", "code": "private synchronized void addTableLockObject(AbsoluteTableIdentifier absoluteTableIdentifier){\n  if (null == tableLockMap.get(absoluteTableIdentifier)) {\n    tableLockMap.put(absoluteTableIdentifier,new Object());\n  }\n}\n", "docstring": "method to add table level lock if lock is not present for the table", "partition": "test"}
{"idx": "813", "code": "public static double[] normalizeZscore(double[] x){\n  double mn=mean(x,0);\n  double sd=standardDeviation(x,0);\n  for (int i=0; i < x.length; i++)   if (!Double.isNaN(x[i]))   x[i]=(x[i] - mn) / sd;\n  return x;\n}\n", "docstring": "calcualtes x_i = ( x_i - mean ( x ) ) / std ( x ) this function can deal with nans", "partition": "test"}
{"idx": "852", "code": "public boolean match(MimeType other){\n  if (this == other)   return true;\n  if (type != null && other.type != null && !type.equals(other.type))   return false;\n  if (subtype != null && other.subtype != null && !subtype.equals(other.subtype))   return false;\n  return true;\n}\n", "docstring": "checks if given mimetype is covered by current mimetype", "partition": "test"}
{"idx": "644", "code": "protected ArrayList<KeyNamePair> loadRMAData(int C_BPartner_ID){\n  ArrayList<KeyNamePair> list=new ArrayList<KeyNamePair>();\n  String sqlStmt=\"SELECT r.M_RMA_ID, r.DocumentNo || \\'-\\' || r.Amt from M_RMA r \" + \"WHERE ISSOTRX=\\'N\\' AND r.DocStatus in (\\'CO\\', \\'CL\\') \" + \"AND r.C_BPartner_ID=? \"+ \"AND NOT EXISTS (SELECT * FROM C_Invoice inv \"+ \"WHERE inv.M_RMA_ID=r.M_RMA_ID AND inv.DocStatus IN (\\'CO\\', \\'CL\\'))\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sqlStmt,null);\n    pstmt.setInt(1,C_BPartner_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      list.add(new KeyNamePair(rs.getInt(1),rs.getString(2)));\n    }\n    rs.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sqlStmt.toString(),e);\n  }\n finally {\n    if (pstmt != null) {\n      try {\n        pstmt.close();\n      }\n catch (      Exception ex) {\n        log.severe(\"Could not close prepared statement\");\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "load pbartner dependent order / invoice / shipment field .", "partition": "test"}
{"idx": "4245", "code": "public static void notEmpty(String string,String msg){\n  if (string == null || string.length() == 0)   throw new IllegalArgumentException(msg);\n}\n", "docstring": "validates that the string is not empty", "partition": "test"}
{"idx": "2303", "code": "private void testMultiStatement(){\n  MVStore s=MVStore.open(null);\n  TransactionStore ts=new TransactionStore(s);\n  ts.init();\n  Transaction tx;\n  TransactionMap<String,String> m;\n  long startUpdate;\n  tx=ts.begin();\n  startUpdate=tx.setSavepoint();\n  m=tx.openMap(\"test\");\n  m.setSavepoint(startUpdate);\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertTrue(m.trySet(\"1\",\"Hello\",true));\n  assertTrue(m.trySet(\"2\",\"World\",true));\n  assertNull(m.get(\"1\"));\n  assertNull(m.get(\"2\"));\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertEquals(\"Hello\",m.get(\"1\"));\n  assertEquals(\"World\",m.get(\"2\"));\n  assertEquals(\"Hello\",m.get(\"1\"));\n  assertTrue(m.trySet(\"1\",null,true));\n  assertTrue(m.trySet(\"2\",\"Hello\",true));\n  assertEquals(\"World\",m.get(\"2\"));\n  assertTrue(m.trySet(\"2\",null,true));\n  assertTrue(m.trySet(\"3\",\"World\",true));\n  assertEquals(\"Hello\",m.get(\"1\"));\n  assertEquals(\"World\",m.get(\"2\"));\n  assertNull(m.get(\"3\"));\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertNull(m.get(\"1\"));\n  assertEquals(\"Hello\",m.get(\"2\"));\n  assertEquals(\"World\",m.get(\"3\"));\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertTrue(m.trySet(\"2\",null,true));\n  assertTrue(m.trySet(\"1\",\"Hello\",true));\n  assertTrue(m.trySet(\"3\",null,true));\n  assertFalse(m.trySet(\"1\",\"World\",true));\n  tx.rollbackToSavepoint(startUpdate);\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertNull(m.get(\"1\"));\n  assertEquals(\"Hello\",m.get(\"2\"));\n  assertEquals(\"World\",m.get(\"3\"));\n  tx.commit();\n  ts.close();\n  s.close();\n}\n", "docstring": "tests behavior when used for a sequence of sql statements . each statement uses a savepoint . within a statement , changes by the statement itself are not seen ; the change is only seen when the statement finished . < p > update statements that change the key of multiple rows may use delete / add pairs to do so ( they don \"'\" t need to first delete all entries and then re - add them ) . trying to add multiple values for the same key is not allowed ( an update statement that would result in a duplicate key ) .", "partition": "test"}
{"idx": "2962", "code": "@HLEUnimplemented @HLEFunction(nid=0xCFE9E999,version=271) public int sceUsbCamSetupVideoEx(pspUsbCamSetupVideoExParam usbCamSetupVideoExParam,TPointer workArea,int workAreaSize){\n  this.workArea=workArea.getAddress();\n  this.workAreaSize=workAreaSize;\n  resolution=convertResolutionExToResolution(usbCamSetupVideoExParam.resolution);\n  frameRate=usbCamSetupVideoExParam.framerate;\n  whiteBalance=usbCamSetupVideoExParam.wb;\n  saturation=usbCamSetupVideoExParam.saturation;\n  brightness=usbCamSetupVideoExParam.brightness;\n  contrast=usbCamSetupVideoExParam.contrast;\n  sharpness=usbCamSetupVideoExParam.sharpness;\n  imageEffectMode=usbCamSetupVideoExParam.effectmode;\n  frameSize=usbCamSetupVideoExParam.framesize;\n  evLevel=usbCamSetupVideoExParam.evlevel;\n  if (!setupVideo()) {\n    log.warn(String.format(\"Cannot find webcam\"));\n    return SceKernelErrors.ERROR_USBCAM_NOT_READY;\n  }\n  return 0;\n}\n", "docstring": "set ups the parameters for video capture ( with more options )", "partition": "test"}
{"idx": "2171", "code": "public static String checkIndexHeaderSuffix(DataInput in,String expectedSuffix) throws IOException {\n  int suffixLength=in.readByte() & 0xFF;\n  byte suffixBytes[]=new byte[suffixLength];\n  in.readBytes(suffixBytes,0,suffixBytes.length);\n  String suffix=new String(suffixBytes,0,suffixBytes.length,StandardCharsets.UTF_8);\n  if (!suffix.equals(expectedSuffix)) {\n    throw new CorruptIndexException(\"file mismatch, expected suffix=\" + expectedSuffix + \", got=\"+ suffix,in);\n  }\n  return suffix;\n}\n", "docstring": "expert : just reads and verifies the suffix of an index header", "partition": "test"}
{"idx": "1807", "code": "public JournalIndex(final IRawStore store,final Checkpoint checkpoint,final IndexMetadata metadata,final boolean readOnly){\n  super(store,checkpoint,metadata,readOnly);\n}\n", "docstring": "load from the store .", "partition": "test"}
{"idx": "3237", "code": "public void dumpIndex(boolean showBounds) throws IOException {\n  byte ixRecord[]=new byte[SPATIAL_INDEX_RECORD_LENGTH];\n  int recNum=0;\n  if (shpFileName == null) {\n    return;\n  }\n  BinaryBufferedFile ssx=new BinaryBufferedFile(ssx(shpFileName));\n  ssx.seek(100);\n  while (true) {\n    int result=ssx.read(ixRecord,0,SPATIAL_INDEX_RECORD_LENGTH);\n    if (result <= 0) {\n      logger.info(\"Processed \" + recNum + \" records\");\n      break;\n    }\n else {\n      recNum++;\n      int offset=readBEInt(ixRecord,0);\n      int length=readBEInt(ixRecord,4);\n      logger.info(\"Record \" + recNum + \": \"+ offset+ \", \"+ length+ (showBounds ? (\"; \" + readLEDouble(ixRecord,8) + \", \"+ readLEDouble(ixRecord,16)+ \", \"+ readLEDouble(ixRecord,24)+ \", \"+ readLEDouble(ixRecord,32)) : \"\"));\n    }\n  }\n  ssx.close();\n}\n", "docstring": "displays the contents of this index .", "partition": "test"}
{"idx": "130", "code": "public Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {\n  int i=name.lastIndexOf('.');\n  if (i != -1) {\n    SecurityManager sm=System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPackageAccess(name.substring(0,i));\n    }\n  }\n  if (ucp.knownToNotExist(name)) {\n    Class<?> c=findLoadedClass(name);\n    if (c != null) {\n      if (resolve) {\n        resolveClass(c);\n      }\n      return c;\n    }\n    throw new ClassNotFoundException(name);\n  }\n  return (super.loadClass(name,resolve));\n}\n", "docstring": "override loadclass so we can checkpackageaccess .", "partition": "test"}
{"idx": "1292", "code": "protected void handleOrDeferMessage(DistributionMessage msg){\nsynchronized (startupLock) {\n    if (beingSick || playingDead) {\n      if (msg.containsRegionContentChange() || msg instanceof PartitionMessageWithDirectReply) {\n        startupMessages.add(new StartupEvent(msg));\n        return;\n      }\n    }\n    if (!processingEvents) {\n      startupMessages.add(new StartupEvent(msg));\n      return;\n    }\n  }\n  dispatchMessage(msg);\n}\n", "docstring": "dispatch the distribution message , or place it on the startup queue .", "partition": "test"}
{"idx": "2971", "code": "public AsyncSelector() throws IOException {\n  this(Selector.open());\n}\n", "docstring": "construct asyncselector with brand new selector", "partition": "test"}
{"idx": "412", "code": "public SessionWrapper(Session ses){\n  this.ses=ses;\n  this.time=System.currentTimeMillis();\n}\n", "docstring": "creates instance of cassandra driver session wrapper .", "partition": "test"}
{"idx": "3349", "code": "private int calculateMenuMargin(){\n  WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);\n  Display display=wm.getDefaultDisplay();\n  Point size=new Point();\n  display.getSize(size);\n  int height=size.y;\n  return (int)Math.round(height * MENU_MARGIN_RELATIVE_MODIFIER);\n}\n", "docstring": "method that calculates space left for edittext when format text panel is visible", "partition": "test"}
{"idx": "2522", "code": "private void adjustBCIndex(Instruction barrier){\n  NormalMethod source=barrier.position().method;\n  if (source.isForOsrSpecialization()) {\n    barrier.adjustBytecodeIndex(-source.getOsrPrologueLength());\n  }\n}\n", "docstring": "the osrbarrier instruction is not in ir , so the bc index was not adjusted in osr_adjustbcindex .", "partition": "test"}
{"idx": "212", "code": "public Node(Coordinate pt){\n  this(pt,new DirectedEdgeStar());\n}\n", "docstring": "constructs a node with the given location .", "partition": "test"}
{"idx": "544", "code": "void replacePolicyInResourceTree(ServiceTypeManager svtm,SSOToken token,Policy oldPolicy,Policy newPolicy) throws PolicyException, SSOException {\n  removePolicyFromResourceTree(svtm,token,oldPolicy);\n  addPolicyToResourceTree(svtm,token,newPolicy);\n}\n", "docstring": "replaces a policy \"'\" s relevant content in the resource tree .", "partition": "test"}
{"idx": "2580", "code": "public void disable(BluetoothAdapter adapter){\n  int mask=(BluetoothReceiver.STATE_TURNING_OFF_FLAG | BluetoothReceiver.STATE_OFF_FLAG | BluetoothReceiver.SCAN_MODE_NONE_FLAG);\n  long start=-1;\n  BluetoothReceiver receiver=getBluetoothReceiver(mask);\n  int state=adapter.getState();\nswitch (state) {\ncase BluetoothAdapter.STATE_OFF:\n    assertFalse(adapter.isEnabled());\n  removeReceiver(receiver);\nreturn;\ncase BluetoothAdapter.STATE_TURNING_ON:\nassertFalse(adapter.isEnabled());\nstart=System.currentTimeMillis();\nbreak;\ncase BluetoothAdapter.STATE_ON:\nassertTrue(adapter.isEnabled());\nstart=System.currentTimeMillis();\nassertTrue(adapter.disable());\nbreak;\ncase BluetoothAdapter.STATE_TURNING_OFF:\nassertFalse(adapter.isEnabled());\nmask=0;\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"disable() invalid state: state=%d\",state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) {\nstate=adapter.getState();\nif (state == BluetoothAdapter.STATE_OFF && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.isEnabled());\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"disable() completed in %d ms\",(finish - start)));\n}\n else {\nwriteOutput(\"disable() completed\");\n}\nremoveReceiver(receiver);\nreturn;\n}\nsleep(POLL_TIME);\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",state,BluetoothAdapter.STATE_OFF,firedFlags,mask));\n}\n", "docstring": "disables bluetooth and checks to make sure that bluetooth was turned off and that the correct actions were broadcast .", "partition": "test"}
{"idx": "1174", "code": "public static void writeStringToWriter(String string,Writer writer) throws IOException {\n  BufferedWriter bw=new BufferedWriter(writer);\n  try {\n    bw.write(string);\n  }\n  finally {\n    bw.close();\n  }\n}\n", "docstring": "writes given string to given writer . close writer afterwards .", "partition": "test"}
{"idx": "3155", "code": "private static void expand2DigitNumber(String numberString,WordRelation wordRelation,Item tokenItem){\n  if (numberString.charAt(0) == '0') {\n    if (numberString.charAt(1) == '0') {\n    }\n else {\n      String number=digit2num[numberString.charAt(1) - '0'];\n      wordRelation.addWord(tokenItem,number);\n    }\n  }\n else   if (numberString.charAt(1) == '0') {\n    String number=digit2enty[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,number);\n  }\n else   if (numberString.charAt(0) == '1') {\n    String number=digit2teen[numberString.charAt(1) - '0'];\n    wordRelation.addWord(tokenItem,number);\n  }\n else {\n    String enty=digit2enty[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,enty);\n    expandDigits(numberString.substring(1,numberString.length()),wordRelation,tokenItem);\n  }\n}\n", "docstring": "expands a two - digit string into a list of english words .", "partition": "test"}
{"idx": "2414", "code": "public void push(){\n  state.cliprgn=g.getClipBounds();\n  stack.push(state);\n  state=(GraphicsState)state.clone();\n}\n", "docstring": "push the current graphics state onto the stack . continue working with the current object ; calling pop ( ) restores the state of this object to its state when push ( ) was called .", "partition": "test"}
{"idx": "1496", "code": "protected List<URI> load(final InputStream in) throws SAXException, IOException {\n  SAXParser saxParser;\n  final SAXParserFactory factory=SAXParserFactory.newInstance();\n  try {\n    saxParser=factory.newSAXParser();\n  }\n catch (  final ParserConfigurationException ex) {\n    throw new SAXException(ex);\n  }\n  groups=new LinkedList<URI>();\n  saxParser.parse(in,this);\n  return groups;\n}\n", "docstring": "load and returns the list of files .", "partition": "test"}
{"idx": "4258", "code": "public void add(double weight,double x,double y){\n  observations.add(new WeightedObservedPoint(weight,x,y));\n}\n", "docstring": "adds a point to the sample .", "partition": "test"}
{"idx": "2133", "code": "@Override public SoftwarePIDController withTolerance(double tolerance){\n  target=target.withTolerance(Math.abs(tolerance));\n  return this;\n}\n", "docstring": "sets the absolute tolerance for this controller .", "partition": "test"}
{"idx": "2521", "code": "@Override public void handleClick(int x,int y,PlotRenderingInfo info){\n}\n", "docstring": "handles a \"'\" click \"'\" on the plot by updating the anchor values . . .", "partition": "test"}
{"idx": "1609", "code": "public static void assertEqualsAnyOrder(EventBean[][] expected,EventBean[][] actual){\n  if (compareArraySize(expected,actual)) {\n    return;\n  }\n  int numMatches=0;\n  boolean[] foundReceived=new boolean[actual.length];\n  for (  EventBean[] expectedObject : expected) {\n    boolean found=false;\n    for (int i=0; i < actual.length; i++) {\n      if (foundReceived[i]) {\n        continue;\n      }\n      boolean match=compareEqualsExactOrder(actual[i],expectedObject);\n      if (match) {\n        found=true;\n        numMatches++;\n        foundReceived[i]=true;\n        break;\n      }\n    }\n    if (!found) {\n      log.error(\".assertEqualsAnyOrder Not found in received results is expected=\" + Arrays.toString(expectedObject));\n      log.error(\".assertEqualsAnyOrder received=\" + Arrays.toString(actual));\n    }\n    ScopeTestHelper.assertTrue(found);\n  }\n  ScopeTestHelper.assertEquals(numMatches,expected.length);\n}\n", "docstring": "compare two 2 - dimensional event arrays .", "partition": "test"}
{"idx": "1036", "code": "public static String fetchClusterName(String clusterCgName){\n  String clusterName=null;\n  if (clusterCgName != null && !clusterCgName.isEmpty()) {\n    String[] tmp=clusterCgName.split(SPLITTER);\n    clusterName=tmp[0];\n  }\n  return clusterName;\n}\n", "docstring": "parses out the cluster name from the combined cluster / cg name .", "partition": "test"}
{"idx": "1673", "code": "public boolean softSignin() throws IOException {\n  if (url == null) {\n    throw new IllegalStateException(\"Null host\");\n  }\n  checkResolveHost();\n  if (sessionId != null) {\n    if (checkAuthorized(getAuthCheckUrl(sessionId))) {\n      LOGGER.fine(\"Skipping soft init; session ID already exists - \" + sessionId);\n      return true;\n    }\n else {\n      sessionId=null;\n    }\n  }\n  long id=loadSessionId();\n  if (id == 0) {\n    return false;\n  }\n  boolean authorized=checkAuthorized(getAuthCheckUrl(id));\n  if (authorized) {\n    LOGGER.info(\"Authorized with session ID: \" + id);\n    this.sessionId=id;\n  }\n  return authorized;\n}\n", "docstring": "if the user can be authenticated due to an existing session id , do so", "partition": "test"}
{"idx": "1618", "code": "public int action(String fault,String action){\n  Integer current=get(fault);\n  if (current == null)   throw new IllegalArgumentException(fault);\n  boolean no=action.startsWith(\"no\");\n  if (no)   action=action.substring(2);\n  Integer bit=getAction(action);\n  if (bit == null)   throw new IllegalArgumentException(action);\n  int old=current.intValue();\n  int mask=bit.intValue();\n  int n=(old & (~mask));\n  n=(no) ? n : (n | mask);\n  put(fault,new Integer(n));\n  return n;\n}\n", "docstring": "sets the action bits as appropriate for the given fault and action", "partition": "test"}
{"idx": "192", "code": "public boolean isPronoun(){\n  return typeString.contains(SUFFIX_PRONOUN);\n}\n", "docstring": "determine if the expression is a pronoun .", "partition": "test"}
{"idx": "3444", "code": "protected void recursiveNestedJoin(EventBean lookupEvent,int nestingOrderIndex,EventBean[] currentPath,Collection<EventBean[]> result,ExprEvaluatorContext exprEvaluatorContext){\n  List<EventBean[]> nestedResult=new LinkedList<EventBean[]>();\n  ExecNode nestedExecNode=childNodes.get(nestingOrderIndex);\n  nestedExecNode.process(lookupEvent,currentPath,nestedResult,exprEvaluatorContext);\n  boolean isLastStream=(nestingOrderIndex == nestingOrderLength - 1);\n  if (!isLastStream) {\n    for (    EventBean[] row : nestedResult) {\n      EventBean lookup=row[nestedStreams[nestingOrderIndex]];\n      recursiveNestedJoin(lookup,nestingOrderIndex + 1,row,result,exprEvaluatorContext);\n    }\n    return;\n  }\n  for (  EventBean[] row : nestedResult) {\n    result.add(row);\n  }\n}\n", "docstring": "recursive method to run through all child nodes and , for each result set tuple returned by a child node , execute the inner child of the child node until there are no inner child nodes .", "partition": "test"}
{"idx": "1956", "code": "public BigDecimal calculateTotalCollectedAmt(final BillReceiptInfo bri,final List<EgBillDetails> billDetList) throws InvalidAccountHeadException {\n  return bri.getTotalAmount();\n}\n", "docstring": "called to calculate the total receipt amount i , e the amount which has been paid for the bill from the billreceiptinfo the amount will be calculated . if the glcode which exists in egbilldetails is not matching with the glcode the erpcollection send , then an exception will be raised ( invalidaccountheadexception ) .", "partition": "test"}
{"idx": "2322", "code": "public static LatLon[] greatCircleExtremeLocations(LatLon location,Angle azimuth){\n  if (location == null) {\n    throw new IllegalArgumentException(\"Location Is Null\");\n  }\n  if (azimuth == null) {\n    throw new IllegalArgumentException(\"Azimuth Is Null\");\n  }\n  double lat0=location.getLatitude().radians;\n  double az=azimuth.radians;\n  double tanDistance=-Math.tan(lat0) / Math.cos(az);\n  double distance=Math.atan(tanDistance);\n  Angle extremeDistance1=Angle.fromRadians(distance + (Math.PI / 2.0));\n  Angle extremeDistance2=Angle.fromRadians(distance - (Math.PI / 2.0));\n  return new LatLon[]{greatCircleEndPosition(location,azimuth,extremeDistance1),greatCircleEndPosition(location,azimuth,extremeDistance2)};\n}\n", "docstring": "returns two locations with the most extreme latitudes on the great circle with the given starting location and azimuth .", "partition": "test"}
{"idx": "1318", "code": "private void populateTaskList(Volume source,Map<BlockMirror,Volume> groupMirrorSourceMap,TaskList taskList,String taskId,ResourceOperationTypeEnum operationType){\n  Set<URI> groupSet=new HashSet<URI>();\n  addTask(taskList,source,taskId,operationType);\n  for (  Entry<BlockMirror,Volume> entry : groupMirrorSourceMap.entrySet()) {\n    BlockMirror mirror=entry.getKey();\n    Volume mirrorSource=entry.getValue();\n    if (source.isInCG() && null != taskList.getTaskList()) {\n      groupSet.add(mirrorSource.getConsistencyGroup());\n    }\n  }\n  List<BlockConsistencyGroup> groups=_dbClient.queryObject(BlockConsistencyGroup.class,groupSet);\n  for (  BlockConsistencyGroup group : groups) {\n    addTask(taskList,group,taskId,operationType);\n  }\n}\n", "docstring": "populate the given tasklist with tasks .", "partition": "test"}
{"idx": "1524", "code": "private static void initAdbSocketAddr(){\n  try {\n    sAdbServerPort=getAdbServerPort();\n    InetAddress hostAddr=InetAddress.getByName(DEFAULT_ADB_HOST);\n    sSocketAddr=new InetSocketAddress(hostAddr,sAdbServerPort);\n  }\n catch (  UnknownHostException e) {\n  }\n}\n", "docstring": "instantiates ssocketaddr with the address of the host \"'\" s adb process .", "partition": "test"}
{"idx": "2550", "code": "private void compileProlog(ObjectId prolog,File tempDir) throws IOException, CompileException {\n  File tempRules=copyToTempFile(prolog,tempDir);\n  try {\n    Compiler comp=new Compiler();\n    comp.prologToJavaSource(tempRules.getPath(),tempDir.getPath());\n  }\n  finally {\n    tempRules.delete();\n  }\n}\n", "docstring": "creates a copy of rules . pl and compiles it into java sources .", "partition": "test"}
{"idx": "2370", "code": "public void init(SocketChannel channel){\n  _channel=channel;\n  _readBuffer.clear();\n  _readBuffer.flip();\n  _needsFlush=false;\n}\n", "docstring": "initialize the socketstream with a new socket .", "partition": "test"}
{"idx": "2599", "code": "public static List<Window> windows(String words,int windowSize){\n  StringTokenizer tokenizer=new StringTokenizer(words);\n  List<String> list=new ArrayList<String>();\n  while (tokenizer.hasMoreTokens())   list.add(tokenizer.nextToken());\n  return windows(list,windowSize);\n}\n", "docstring": "constructs a list of window of size windowsize . note that padding for each window is created as well .", "partition": "test"}
{"idx": "210", "code": "private void bappend(char ch){\n  try {\n    mBuff[++mBuffIdx]=ch;\n  }\n catch (  Exception exp) {\n    char buff[]=new char[mBuff.length << 1];\n    System.arraycopy(mBuff,0,buff,0,mBuff.length);\n    mBuff=buff;\n    mBuff[mBuffIdx]=ch;\n  }\n}\n", "docstring": "appends a character to parser \"'\" s buffer .", "partition": "test"}
{"idx": "1816", "code": "static boolean isDate(Object obj){\n  return obj instanceof Date && obj.getClass() == Date.class;\n}\n", "docstring": "check whether this object is a date .", "partition": "test"}
{"idx": "469", "code": "public void sphericalToWorld(Vector3 vec){\n  if (pjUnprojected == null) {\n    String projStr=\"+proj=longlat +a=\" + projInfo.getSemiMajorAxis() + \" +b=\"+ projInfo.getSemiMinorAxis()+ \" +no_defs\";\n    pjUnprojected=Proj4.newInstance(projStr);\n  }\n  if (pjProjected == null) {\n    pjProjected=Proj4.newInstance(proj4String);\n  }\n  try {\n    vec.toArray(coord);\n    coord[0]=Math.toRadians(coord[0]);\n    coord[1]=Math.toRadians(coord[1]);\n    pjUnprojected.transform(pjProjected,coord);\n    vec.setX(coord[0]);\n    vec.setY(coord[1]);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "convert lon / lat ( degree ) coordinate to virtual world coordinates .", "partition": "test"}
{"idx": "68", "code": "@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern \\'\" + pattern.pattern() + \"\\' was not encountered in document: \"+ document);\n  }\n  return token;\n}\n", "docstring": "this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor . if failed to do so , the method will be expected to throw an exception or take corrective measures .", "partition": "test"}
{"idx": "3018", "code": "@SuppressWarnings(\"nullness\") @GwtIncompatible(\"java.io.ObjectOutputStream\") public static <K extends Object,V extends Object>void writeMap(Map<K,V> map,ObjectOutputStream stream) throws IOException {\n  stream.writeInt(map.size());\n  for (  Map.Entry<K,V> entry : map.entrySet()) {\n    stream.writeObject(entry.getKey());\n    stream.writeObject(entry.getValue());\n  }\n}\n", "docstring": "stores the contents of a map in an output stream , as part of serialization . it does not support concurrent maps whose content may change while the method is running . < p > the serialized output consists of the number of entries , first key , first value , second key , second value , and so on .", "partition": "test"}
{"idx": "315", "code": "@Override public int addAttribute(Attribute a){\n  if (a == null) {\n    throw new IllegalArgumentException(\"Attribute must not be null\");\n  }\n else {\n    int index=-1;\n    Attribute original=a;\n    a=(Attribute)a.clone();\n    if (unusedColumnList.size() > 0) {\nsynchronized (unusedColumnList) {\n        if (unusedColumnList.size() > 0) {\n          index=unusedColumnList.remove(0);\n          attributes.set(index,a);\n        }\n else {\n          index=attributes.size();\n          attributes.add(a);\n        }\n      }\n    }\n else {\n      index=attributes.size();\n      attributes.add(a);\n    }\n    a.setTableIndex(index);\n    original.setTableIndex(index);\n    return index;\n  }\n}\n", "docstring": "adds the attribute to the list of attributes assigning it a free column index . if the name is already in use , the attribute will be renamed .", "partition": "test"}
{"idx": "435", "code": "public boolean isVisited(Object element){\n  return myVisitedElements.containsKey(element);\n}\n", "docstring": "returns true if this element was already visited .", "partition": "test"}
{"idx": "2887", "code": "public boolean compare(Object expected,Object current){\n  if (current != null) {\n    equal=current.equals(expected);\n  }\n else   if (expected != null) {\n    equal=expected.equals(1.0);\n  }\n  return equal;\n}\n", "docstring": "this is used to compare the expected and current versions of the class . once compared the comparison result is cached within the revision class so that it can be used repeatedly .", "partition": "test"}
{"idx": "1757", "code": "void add(Object key){\n  table.put(key,key);\n}\n", "docstring": "adds an object to this set .", "partition": "test"}
{"idx": "842", "code": "static boolean pairSum(int ar[],int x){\n  Arrays.sort(ar);\n  int len=ar.length;\n  for (int i=0, j=len - 1; i < j; ) {\n    if (ar[i] + ar[j] == x) {\n      return true;\n    }\n else     if (ar[i] + ar[j] < x) {\n      i++;\n    }\n else {\n      j--;\n    }\n  }\n  return false;\n}\n", "docstring": "using sorting . if we use merge sort or heap sort then ( - ) ( nlogn ) in worst case . if we use quick sort then o ( n ^ 2 ) in worst case .", "partition": "test"}
{"idx": "2393", "code": "public static synchronized List<Proxy> noProxyList(){\n  if (noProxyList == null) {\n    ArrayList<Proxy> list=new ArrayList<Proxy>(1);\n    list.add(Proxy.NO_PROXY);\n    noProxyList=Collections.unmodifiableList(list);\n  }\n  return noProxyList;\n}\n", "docstring": "gets an unmodifiable proxy list that will have as it \"'\" s only entry an direct proxy .", "partition": "test"}
{"idx": "4116", "code": "@SuppressWarnings(\"unused\") public void handleButton3Request(RequestInvocationEvent event){\n  backTrail();\n  try {\n    String name=(String)getPageSessionAttribute(SAVE_VB_NAME);\n    ViewBean vb=getViewBean(Class.forName(name));\n    passPgSessionMap(vb);\n    vb.forwardTo(getRequestContext());\n  }\n catch (  ClassNotFoundException e) {\n    debug.warning(\"AbstractAuditViewBean.handleButton3Request:\",e);\n  }\n}\n", "docstring": "called on request from the ui to return to the previous page .", "partition": "test"}
{"idx": "768", "code": "private final String loadXmlDefinition(){\n  final Cache cache=CacheFactory.getAnyInstance();\n  final StringWriter stringWriter=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(stringWriter);\n  CacheXmlGenerator.generate(cache,printWriter,true,false,false);\n  printWriter.close();\n  return loadXmlDefinition(stringWriter.toString());\n}\n", "docstring": "use the cachexmlgenerator to create xml from the entity associated with the current cache .", "partition": "test"}
{"idx": "599", "code": "public void fireEventProgrammatically(Event event){\n  if (!event.isConsumed())   ripplerPane.fireEvent(event);\n}\n", "docstring": "fire event to the rippler pane manually", "partition": "test"}
{"idx": "1074", "code": "public String globalInfo(){\n  return \"A SplitEvaluator that produces results for a classification \" + \"scheme on a numeric class attribute.\";\n}\n", "docstring": "returns a string describing this split evaluator", "partition": "test"}
{"idx": "1877", "code": "public int executeUpdate(String sql) throws SQLException {\n  return Util.truncateAndConvertToInt(executeLargeUpdate(sql));\n}\n", "docstring": "execute a sql insert , update or delete statement . in addition sql statements that return nothing such as sql ddl statements can be executed .", "partition": "test"}
{"idx": "40", "code": "public void addRestrictedDomain(String domainName){\n  if (StringUtils.isEmpty(domainName)) {\n    return;\n  }\n  if (restrictedDomains == null) {\n    restrictedDomains=new ArrayList<>();\n  }\n  restrictedDomains.add(domainName);\n}\n", "docstring": "adds specified domain name to the list of restricted domains", "partition": "test"}
{"idx": "2055", "code": "@Override protected void onMessageOnProducerThread(T msg){\n  _lock.lock();\n  try {\n    if (_pending.isEmpty()) {\n      _queue.schedule(_flushRunnable,_interval,_timeUnit);\n    }\n    _pending.add(msg);\n  }\n  finally {\n    _lock.unlock();\n  }\n}\n", "docstring": "receives message and batches as needed .", "partition": "test"}
{"idx": "2733", "code": "public T findByCommitCounter(final long commitCounter){\n  if (commitCounter < 0L)   throw new IllegalArgumentException();\n  final Lock lock=readLock();\n  lock.lock();\n  try {\n    @SuppressWarnings(\"unchecked\") final ITupleIterator<T> itr=rangeIterator(null,null,0,IRangeQuery.DEFAULT | IRangeQuery.REVERSE,null);\n    while (itr.hasNext()) {\n      final ITuple<T> t=itr.next();\n      final T r=t.getObject();\n      final IRootBlockView rb=r.getRootBlock();\n      if (rb.getCommitCounter() <= commitCounter) {\n        return r;\n      }\n    }\n    return null;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "find the oldest entry whose commit counter is lte the specified commit counter .", "partition": "test"}
{"idx": "343", "code": "public static double dmod_d(double lhs,double rhs){\n  return rhs != 0 ? lhs - rhs * Math.floor(lhs / rhs) : Double.NaN;\n}\n", "docstring": "take modulo for double numbers according to lua math , and return a double result .", "partition": "test"}
{"idx": "433", "code": "public List<TypeId<?>> asList(){\n  return Collections.unmodifiableList(Arrays.asList(types));\n}\n", "docstring": "returns an immutable list .", "partition": "test"}
{"idx": "2004", "code": "public static void printThreadInfo(PrintWriter stream,String title){\n  final int STACK_DEPTH=20;\n  boolean contention=threadBean.isThreadContentionMonitoringEnabled();\n  long[] threadIds=threadBean.getAllThreadIds();\n  stream.println(\"Process Thread Dump: \" + title);\n  stream.println(threadIds.length + \" active threads\");\n  for (  long tid : threadIds) {\n    ThreadInfo info=threadBean.getThreadInfo(tid,STACK_DEPTH);\n    if (info == null) {\n      stream.println(\"  Inactive\");\n      continue;\n    }\n    stream.println(\"Thread \" + getTaskName(info.getThreadId(),info.getThreadName()) + \":\");\n    Thread.State state=info.getThreadState();\n    stream.println(\"  State: \" + state);\n    stream.println(\"  Blocked count: \" + info.getBlockedCount());\n    stream.println(\"  Waited count: \" + info.getWaitedCount());\n    if (contention) {\n      stream.println(\"  Blocked time: \" + info.getBlockedTime());\n      stream.println(\"  Waited time: \" + info.getWaitedTime());\n    }\n    if (state == Thread.State.WAITING) {\n      stream.println(\"  Waiting on \" + info.getLockName());\n    }\n else     if (state == Thread.State.BLOCKED) {\n      stream.println(\"  Blocked on \" + info.getLockName());\n      stream.println(\"  Blocked by \" + getTaskName(info.getLockOwnerId(),info.getLockOwnerName()));\n    }\n    stream.println(\"  Stack:\");\n    for (    StackTraceElement frame : info.getStackTrace()) {\n      stream.println(\"    \" + frame.toString());\n    }\n  }\n  stream.flush();\n}\n", "docstring": "print all of the thread \"'\" s information and stack traces .", "partition": "test"}
{"idx": "677", "code": "protected boolean readReceiveDelay(){\n  try {\n    receiveDelay=Integer.parseInt(receiveDelayField.getText());\n  }\n catch (  Exception e) {\n    statusText1.setText(rb.getString(\"Error7\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay < 0) {\n    statusText1.setText(rb.getString(\"Error8\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay > 65535) {\n    statusText1.setText(rb.getString(\"Error9\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  return true;\n}\n", "docstring": "read receive delay from window returns \"'\" true \"'\" if successful , \"'\" false \"'\" if an error was detected . if an error is detected , a suitable error message is placed in the notes area", "partition": "test"}
{"idx": "353", "code": "final void putLong(int offset,long value){\n  unsafe.putLong(offset + address,value);\n}\n", "docstring": "writes a long at the specified offset from this native object \"'\" s base address .", "partition": "test"}
{"idx": "4054", "code": "public String asString() throws IOException {\n  long len=getContentLength();\n  ByteArrayOutputStream buf;\n  if (0 < len) {\n    buf=new ByteArrayOutputStream((int)len);\n  }\n else {\n    buf=new ByteArrayOutputStream();\n  }\n  writeTo(buf);\n  return decode(buf.toByteArray(),getCharacterEncoding());\n}\n", "docstring": "return a copy of the result as a string . < p > the default version of this method copies the result into a temporary byte array and then tries to decode it using the configured encoding .", "partition": "test"}
{"idx": "2953", "code": "public void dump_stack(){\n  if (stack == null) {\n    debug_message(\"# Stack dump requested, but stack is null\");\n    return;\n  }\n  debug_message(\"============ Parse Stack Dump ============\");\n  for (int i=0; i < stack.size(); i++) {\n    debug_message(\"Symbol: \" + ((symbol)stack.elementAt(i)).sym + \" State: \"+ ((symbol)stack.elementAt(i)).parse_state);\n  }\n  debug_message(\"==========================================\");\n}\n", "docstring": "dump the parse stack for debugging purposes .", "partition": "test"}
{"idx": "2788", "code": "public String parseFile(File file){\n  log.config(file.getAbsolutePath());\n  String line=null;\n  try {\n    BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(file),Ini.getCharset()),10240);\n    String errMsg=\"\";\n    int lineNo=1;\n    while ((line=in.readLine()) != null && errMsg.length() == 0) {\n      errMsg=parseLine(line,lineNo);\n      lineNo++;\n    }\n    line=null;\n    in.close();\n    if (errMsg.length() != 0)     return errMsg;\n  }\n catch (  Exception ioe) {\n    String s=ioe.getLocalizedMessage();\n    if (s == null || s.length() == 0)     s=ioe.toString();\n    return \"Parse Error: Line=\" + line + \" - \"+ s;\n  }\n  return \"\";\n}\n", "docstring": "read and parse file", "partition": "test"}
{"idx": "84", "code": "private void loadText(InputStream is){\n  BufferedReader reader;\n  String line;\n  unitList=new ArrayList();\n  unitTypesList=new ArrayList();\n  if (is == null) {\n    throw new Error(\"Can\\'t load cluster db file.\");\n  }\n  reader=new BufferedReader(new InputStreamReader(is));\n  try {\n    line=reader.readLine();\n    lineCount++;\n    while (line != null) {\n      if (!line.startsWith(\"***\")) {\n        parseAndAdd(line,reader);\n      }\n      line=reader.readLine();\n    }\n    reader.close();\n    units=new DatabaseClusterUnit[unitList.size()];\n    units=(DatabaseClusterUnit[])unitList.toArray(units);\n    unitList=null;\n    unitTypes=new UnitType[unitTypesList.size()];\n    unitTypes=(UnitType[])unitTypesList.toArray(unitTypes);\n    unitTypesList=null;\n  }\n catch (  IOException e) {\n    throw new Error(e.getMessage() + \" at line \" + lineCount);\n  }\n finally {\n  }\n}\n", "docstring": "loads the database from the given input stream .", "partition": "test"}
{"idx": "3696", "code": "@Override public boolean wasSuccessful(){\n  return isFinished() && getCurrentPoints() >= successThreashold;\n}\n", "docstring": "the attack is only successful if the xsw message is accepted .", "partition": "test"}
{"idx": "2154", "code": "private void readBinary(final LittleEndianDataInputStream dis) throws IOException {\n  RajLog.i(\"StlPaser: Reading Binary\");\n  dis.skip(80);\n  int facetCount=dis.readInt();\n  float[] verticesArr=new float[facetCount * 9];\n  float[] normalsArr=new float[facetCount * 9];\n  int[] indicesArr=new int[facetCount * 3];\n  float[] tempNorms=new float[3];\n  int vertPos=0, normPos=0;\n  for (int i=0; i < indicesArr.length; i++)   indicesArr[i]=i;\n  while (dis.available() > 0) {\n    for (int j=0; j < 3; j++) {\n      tempNorms[j]=dis.readFloat();\n      if (Float.isNaN(tempNorms[j]) || Float.isInfinite(tempNorms[j])) {\n        RajLog.w(\"STL contains bad normals of NaN or Infinite!\");\n        tempNorms[0]=0;\n        tempNorms[1]=0;\n        tempNorms[2]=0;\n        break;\n      }\n    }\n    for (int j=0; j < 3; j++) {\n      normalsArr[normPos++]=tempNorms[0];\n      normalsArr[normPos++]=tempNorms[1];\n      normalsArr[normPos++]=tempNorms[2];\n    }\n    for (int j=0; j < 9; j++)     verticesArr[vertPos++]=dis.readFloat();\n    dis.skip(2);\n  }\n  mRootObject.setData(verticesArr,normalsArr,null,null,indicesArr,false);\n}\n", "docstring": "read stream as binary stl . this is significantly faster than ascii parsing . additionally binary files are much more compressed allowing smaller file sizes for larger models compared to ascii .", "partition": "test"}
{"idx": "980", "code": "public void addToExistingVolumesIfAbsent(Map<String,Integer> volumeWWNs){\n  if (_existingVolumes == null) {\n    _existingVolumes=new StringMap();\n  }\n  for (  String wwn : volumeWWNs.keySet()) {\n    String normalizedWWN=BlockObject.normalizeWWN(wwn);\n    if (!_existingVolumes.containsKey(normalizedWWN) && (_userAddedVolumes == null || !_userAddedVolumes.containsKey(normalizedWWN))) {\n      String hluStr=ExportGroup.LUN_UNASSIGNED_STR;\n      Integer hlu=volumeWWNs.get(normalizedWWN);\n      if (hlu != null) {\n        hluStr=hlu.toString();\n      }\n      _existingVolumes.put(normalizedWWN,hluStr);\n    }\n  }\n}\n", "docstring": "this method will add to the existing volumes list only those members that don \"'\" t already exist in either the existing or user - created volume list .", "partition": "test"}
{"idx": "3911", "code": "public Identity(final int dim){\n  this(dim,EnumSet.noneOf(Address.Flags.class));\n}\n", "docstring": "creates an identity matrix", "partition": "test"}
{"idx": "204", "code": "public static MosaicDefinition createMosaicDefinition(final Account creator){\n  return createMosaicDefinition(creator,Utils.createMosaicId(\"alice.vouchers\",\"alice\\'s gift vouchers\"),createMosaicProperties());\n}\n", "docstring": "creates a default mosaic definition .", "partition": "test"}
{"idx": "3442", "code": "@Override public void write(Buffer buffer,boolean isEnd) throws IOException {\n  if (_s == null) {\n    buffer.free();\n    return;\n  }\n  try {\n    _needsFlush=true;\n    if (buffer.isDirect()) {\n      _totalWriteBytes+=buffer.length();\n      _s.write(buffer.direct());\n      return;\n    }\n    _totalWriteBytes+=buffer.length();\n    while (buffer.length() > 0) {\n      _writeBuffer.clear();\n      buffer.read(_writeBuffer);\n      _writeBuffer.flip();\n      _s.write(_writeBuffer);\n    }\n  }\n catch (  IOException e) {\n    IOException exn=ClientDisconnectException.create(this + \":\" + e,e);\n    try {\n      close();\n    }\n catch (    IOException e1) {\n    }\n    throw exn;\n  }\n finally {\n    buffer.free();\n  }\n}\n", "docstring": "writes an nio buffer to the socket .", "partition": "test"}
{"idx": "591", "code": "private static void solve_l2r_l1l2_svr(Problem prob,double[] w,Parameter param){\n  int l=prob.l;\n  double C=param.C;\n  double p=param.p;\n  int w_size=prob.n;\n  double eps=param.eps;\n  int i, s, iter=0;\n  int max_iter=1000;\n  int active_size=l;\n  int[] index=new int[l];\n  double d, G, H;\n  double Gmax_old=Double.POSITIVE_INFINITY;\n  double Gmax_new, Gnorm1_new;\n  double Gnorm1_init=0;\n  double[] beta=new double[l];\n  double[] QD=new double[l];\n  double[] y=prob.y;\n  double[] lambda=new double[]{0.5 / C};\n  double[] upper_bound=new double[]{Double.POSITIVE_INFINITY};\n  if (param.solverType == SolverType.L2R_L1LOSS_SVR_DUAL) {\n    lambda[0]=0;\n    upper_bound[0]=C;\n  }\n  for (i=0; i < l; i++) {\n    beta[i]=0;\n  }\n  for (i=0; i < w_size; i++) {\n    w[i]=0;\n  }\n  for (i=0; i < l; i++) {\n    QD[i]=0;\n    for (    Feature xi : prob.x[i]) {\n      double val=xi.getValue();\n      QD[i]+=val * val;\n      w[xi.getIndex() - 1]+=beta[i] * val;\n    }\n    index[i]=i;\n  }\n  while (iter < max_iter) {\n    Gmax_new=0;\n    Gnorm1_new=0;\n    for (i=0; i < active_size; i++) {\n      int j=i + random.nextInt(active_size - i);\n      swap(index,i,j);\n    }\n    for (s=0; s < active_size; s++) {\n      i=index[s];\n      G=-y[i] + lambda[GETI_SVR(i)] * beta[i];\n      H=QD[i] + lambda[GETI_SVR(i)];\n      for (      Feature xi : prob.x[i]) {\n        int ind=xi.getIndex() - 1;\n        double val=xi.getValue();\n        G+=val * w[ind];\n      }\n      double Gp=G + p;\n      double Gn=G - p;\n      double violation=0;\n      if (beta[i] == 0) {\n        if (Gp < 0) {\n          violation=-Gp;\n        }\n else         if (Gn > 0) {\n          violation=Gn;\n        }\n else         if (Gp > Gmax_old && Gn < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] >= upper_bound[GETI_SVR(i)]) {\n        if (Gp > 0) {\n          violation=Gp;\n        }\n else         if (Gp < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] <= -upper_bound[GETI_SVR(i)]) {\n        if (Gn < 0) {\n          violation=-Gn;\n        }\n else         if (Gn > Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] > 0) {\n        violation=Math.abs(Gp);\n      }\n else {\n        violation=Math.abs(Gn);\n      }\n      Gmax_new=Math.max(Gmax_new,violation);\n      Gnorm1_new+=violation;\n      if (Gp < H * beta[i]) {\n        d=-Gp / H;\n      }\n else       if (Gn > H * beta[i]) {\n        d=-Gn / H;\n      }\n else {\n        d=-beta[i];\n      }\n      if (Math.abs(d) < 1.0e-12) {\n        continue;\n      }\n      double beta_old=beta[i];\n      beta[i]=Math.min(Math.max(beta[i] + d,-upper_bound[GETI_SVR(i)]),upper_bound[GETI_SVR(i)]);\n      d=beta[i] - beta_old;\n      if (d != 0) {\n        for (        Feature xi : prob.x[i]) {\n          w[xi.getIndex() - 1]+=d * xi.getValue();\n        }\n      }\n    }\n    if (iter == 0) {\n      Gnorm1_init=Gnorm1_new;\n    }\n    iter++;\n    if (iter % 10 == 0) {\n      info(\".\");\n    }\n    if (Gnorm1_new <= eps * Gnorm1_init) {\n      if (active_size == l) {\n        break;\n      }\n else {\n        active_size=l;\n        info(\"*\");\n        Gmax_old=Double.POSITIVE_INFINITY;\n        continue;\n      }\n    }\n    Gmax_old=Gmax_new;\n  }\n  info(\"%noptimization finished, #iter = %d%n\",iter);\n  if (iter >= max_iter) {\n    info(\"%nWARNING: reaching max number of iterations%nUsing -s 11 may be faster%n%n\");\n  }\n  double v=0;\n  int nSV=0;\n  for (i=0; i < w_size; i++) {\n    v+=w[i] * w[i];\n  }\n  v=0.5 * v;\n  for (i=0; i < l; i++) {\n    v+=p * Math.abs(beta[i]) - y[i] * beta[i] + 0.5 * lambda[GETI_SVR(i)] * beta[i]* beta[i];\n    if (beta[i] != 0) {\n      nSV++;\n    }\n  }\n  info(\"Objective value = %g%n\",v);\n  info(\"nSV = %d%n\",nSV);\n}\n", "docstring": "a coordinate descent algorithm for l1 - loss and l2 - loss epsilon - svr dual problem min_ \\\\ beta 0 . 5 \\\\ beta ^ t ( q + diag ( lambda ) ) \\\\ beta - p \\\\ sum_ { i = 1 } ^ l | \\\\ beta_i | + \\\\ sum_ { i = 1 } ^ l yi \\\\ beta_i , s . t . - upper_bound_i < = \\\\ beta_i < = upper_bound_i , where qij = xi ^ t xj and d is a diagonal matrix in l1 - svm case : upper_bound_i = c lambda_i = 0 in l2 - svm case : upper_bound_i = inf lambda_i = 1 / ( 2 * c ) given : x , y , p , c eps is the stopping tolerance solution will be put in w see algorithm 4 of ho and lin , 2012", "partition": "test"}
{"idx": "857", "code": "public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (obj instanceof ECFieldFp) {\n    return (p.equals(((ECFieldFp)obj).p));\n  }\n  return false;\n}\n", "docstring": "compares this prime finite field for equality with the specified object .", "partition": "test"}
{"idx": "948", "code": "public void interruptAll(){\nsynchronized (knownActorTasks) {\n    for (    Future<Void> ft : knownActorTasks) {\n      ft.cancel(true);\n    }\n    threadGuard.interruptAll();\n  }\n}\n", "docstring": "ensure that any guarded regions are interrupted .", "partition": "test"}
{"idx": "2310", "code": "private void updateLtp(SingleChannelElement sce){\n  IndividualChannelStream ics=sce.ics;\n  float saved[]=sce.saved;\n  float savedLtp[]=sce.coeffs;\n  final float lwindow[]=ics.useKbWindow[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n  final float swindow[]=ics.useKbWindow[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n  if (ics.windowSequence[0] == EIGHT_SHORT_SEQUENCE) {\n    System.arraycopy(saved,0,savedLtp,0,512);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else   if (ics.windowSequence[0] == LONG_START_SEQUENCE) {\n    System.arraycopy(ac.bufMdct,512,savedLtp,0,448);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else {\n    FloatDSP.vectorFmulReverse(savedLtp,0,ac.bufMdct,512,lwindow,512,512);\n    for (int i=0; i < 512; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * lwindow[511 - i];\n    }\n  }\n  System.arraycopy(sce.ltpState,1024,sce.ltpState,0,1024);\n  System.arraycopy(sce.ret,0,sce.ltpState,1024,1024);\n  System.arraycopy(savedLtp,0,sce.ltpState,2048,1024);\n}\n", "docstring": "update the ltp buffer for next frame", "partition": "test"}
{"idx": "2397", "code": "public void updatePresonInfo(){\n  this.leftPerson=person2LeavingPersonInfo.get(this.personId);\n  this.enteredPerson=person2EnteringPersonInfo.get(this.personId);\n}\n", "docstring": "a person may re - appear on the same link .", "partition": "test"}
{"idx": "2980", "code": "public static DMLConfig readConfigurationFile(String configPath) throws ParseException, FileNotFoundException {\n  DMLConfig config=new DMLConfig();\n  if (configPath != null) {\n    try {\n      config=new DMLConfig(configPath,false);\n    }\n catch (    FileNotFoundException fnfe) {\n      LOG.error(\"Custom config file \" + configPath + \" not found.\");\n      throw fnfe;\n    }\ncatch (    ParseException e) {\n      throw e;\n    }\n  }\n else {\n    try {\n      config=new DMLConfig(DEFAULT_SYSTEMML_CONFIG_FILEPATH,false);\n    }\n catch (    FileNotFoundException fnfe) {\n      LOG.info(\"Using internal default configuration settings.  If you wish to \" + \"customize any settings, please supply a `SystemML-config.xml` file.\");\n      config=new DMLConfig();\n    }\ncatch (    ParseException e) {\n      throw e;\n    }\n  }\n  return config;\n}\n", "docstring": "start with the internal default settings , then merge in the settings from any specified configuration file , if available . if it is not explicitly given , then merge in settings from the default configuration file location , if available .", "partition": "test"}
{"idx": "1865", "code": "public static void error(String msg,Throwable t){\n  debugInst.debug(IDebug.ERROR,msg,t);\n}\n", "docstring": "error level debug message", "partition": "test"}
{"idx": "3711", "code": "@Override public void incomingObject(IAnalyzedInterval analyzedInterval) throws AdeException {\n  if (!m_percentilesWithEmptyIntervals && analyzedInterval.getNumUniqueMessageIds() == 0) {\n    return;\n  }\n  final double rawScore=calcRawScore(analyzedInterval);\n  if (!SeenHugeLogProb(analyzedInterval)) {\n    m_rawScores.add(rawScore);\n    ++m_intervalCount;\n  }\n}\n", "docstring": "if we do not use empty intervals to compute percentiles and there are no unique messages for this interval then we simply return . otherwise , we calculate the log probability score and add it to the list of raw scores as long as the probability isn \"'\" t a large valued probability as determined by \" mainscorerimpl . \"", "partition": "test"}
{"idx": "1211", "code": "public static void sort(long[] a){\n  doSort(a,0,a.length - 1);\n}\n", "docstring": "sorts the specified array into ascending numerical order .", "partition": "test"}
{"idx": "1531", "code": "private void drawText(int x1,int y1,int s,boolean e_or_n,Graphics g){\n  Color oldColor=g.getColor();\n  g.setPaintMode();\n  if (m_FontColor == null) {\n    g.setColor(Color.black);\n  }\n else {\n    g.setColor(m_FontColor);\n  }\n  String st;\n  if (e_or_n) {\n    Edge e=m_edges[s].m_edge;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_edges[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n else {\n    Node e=m_nodes[s].m_node;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_nodes[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n  g.setColor(oldColor);\n}\n", "docstring": "draws the text for either an edge or a node .", "partition": "test"}
{"idx": "2217", "code": "public void testSignumPositive(){\n  String a=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=41;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  assertEquals(\"incorrect value\",1,aNumber.signum());\n}\n", "docstring": "signum ( ) for a positive bigdecimal", "partition": "test"}
{"idx": "2624", "code": "private static void cleanDirectory(File path){\n  if (path == null)   return;\n  if (path.exists()) {\n    for (    File f : path.listFiles()) {\n      if (f.isDirectory())       cleanDirectory(f);\n      f.delete();\n    }\n  }\n}\n", "docstring": "recursive remove all from directory", "partition": "test"}
{"idx": "2544", "code": "public static boolean isSameElementType(ASTNode node1,ASTNode node2){\n  return node1 != null && node2 != null && node1.getElementType() == node1.getElementType();\n}\n", "docstring": "checks if ielementtype of both nodes are the same . returns false if either are null .", "partition": "test"}
{"idx": "208", "code": "private void addInternalListeners(){\n  cbDistribution.addItemListener(cbItemListener);\n}\n", "docstring": "adds all internal listeners . currently this just consists of an item listener for the combo - box which switches to the correct \" card \" for the given probability distribution .", "partition": "test"}
{"idx": "2208", "code": "public OsmHandler(MapBuilder meConsumer){\n  osmElementProcessor=new OsmElementProcessor(null,meConsumer);\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "1576", "code": "ListBasedTokenStream(AttributeSource attributeSource,List<AttributeSource> tokens){\n  super(attributeSource.getAttributeFactory());\n  this.tokens=tokens;\n  addAttributes(attributeSource);\n}\n", "docstring": "creates a new listbasedtokenstream which uses the given tokens as its token source .", "partition": "test"}
{"idx": "2032", "code": "public void requestContactCapabilities(Set<ContactId> contacts) throws RcsServiceNotRegisteredException, RcsServiceNotAvailableException, RcsGenericException {\n  if (mApi == null) {\n    throw new RcsServiceNotAvailableException();\n  }\n  if (contacts == null || contacts.isEmpty()) {\n    throw new RcsIllegalArgumentException(\"contacts must not be null or empty!\");\n  }\n  try {\n    mApi.requestContactCapabilities2(new ArrayList<>(contacts));\n  }\n catch (  Exception e) {\n    RcsIllegalArgumentException.assertException(e);\n    RcsServiceNotRegisteredException.assertException(e);\n    throw new RcsGenericException(e);\n  }\n}\n", "docstring": "requests capabilities for a group of remote contacts . this method initiates in background new capability requests to the remote contact by sending a sip options . the result of the capability request is sent asynchronously via callback method of the capabilities listener . the parameter contacts supports the following formats : msisdn in national or international format , sip address , sip - uri or tel - uri . if the format of the contact is not supported an exception is thrown . the result of the capability refresh request is provided to all the clients that have registered the listener for this event .", "partition": "test"}
{"idx": "837", "code": "private void moveSingleNode(Object source,Point newPoint){\n  DisplayNode node=(DisplayNode)source;\n  int deltaX=newPoint.x - clickPoint.x;\n  int deltaY=newPoint.y - clickPoint.y;\n  int newX=node.getLocation().x + deltaX;\n  int newY=node.getLocation().y + deltaY;\n  node.setLocation(newX,newY);\n}\n", "docstring": "move a single , unselected node .", "partition": "test"}
{"idx": "2053", "code": "public final boolean isCancelled(){\n  if (cancelled) {\n    pass(\"cancelled\",cancelled);\n  }\n else {\n    fail(\"cancelled\");\n  }\n  return cancelled;\n}\n", "docstring": "returns true if this testsubscriber has been cancelled .", "partition": "test"}
{"idx": "291", "code": "public void init(GuiManualHerblore manual){\n  for (  ManualWidgetBase widget : widgets)   widget.init(manual);\n}\n", "docstring": "initializes the widgets in this page", "partition": "test"}
{"idx": "93", "code": "public IndexSegmentIndex(IRawStore store,Checkpoint checkpoint,IndexMetadata metadata,boolean readOnly){\n  super(store,checkpoint,metadata,readOnly);\n}\n", "docstring": "load from the store .", "partition": "test"}
{"idx": "1892", "code": "public NoDuplicateValueGlobalConstraint(AbstractParameter<?,?>... parameters){\n  this.parameters=Arrays.asList(parameters);\n}\n", "docstring": "constructs a not - equal - value global parameter constraint . that is , the elements of a list of number parameters are not allowed to have equal values .", "partition": "test"}
{"idx": "1931", "code": "public final void clear(){\n  if (GWT.isScript()) {\n    jsArray.clear();\n  }\n else {\n    javaArray.clear();\n  }\n}\n", "docstring": "remove all elements on this list", "partition": "test"}
{"idx": "3094", "code": "public static ConnectionFactory newFailoverConnectionPool(Set<LDAPURL> servers,String username,char[] password,int maxSize,int heartBeatInterval,String heartBeatTimeUnit,Options ldapOptions){\n  List<ConnectionFactory> factories=new ArrayList<ConnectionFactory>(servers.size());\n  for (  LDAPURL ldapurl : servers) {\n    ConnectionFactory cf=Connections.newFixedConnectionPool(newConnectionFactory(ldapurl,username,password,heartBeatInterval,heartBeatTimeUnit,ldapOptions),maxSize);\n    factories.add(cf);\n  }\n  return loadBalanceFactories(factories);\n}\n", "docstring": "creates a new connection pool that is capable to failover to the servers defined in case there is an error .", "partition": "test"}
{"idx": "3781", "code": "protected synchronized void request(String stream){\n  if (stream == null || stream.isEmpty()) {\n    return;\n  }\n  stream=stream.toLowerCase(Locale.ENGLISH);\n  FollowerInfo cachedInfo=cached.get(stream);\n  if (cachedInfo == null || checkTimePassed(cachedInfo)) {\n    if (type == Follower.Type.FOLLOWER) {\n      api.requestFollowers(stream);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      api.requestSubscribers(stream);\n    }\n  }\n else {\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(cachedInfo);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(cachedInfo);\n    }\n  }\n}\n", "docstring": "checks if there is info already cached and whether it is old enough to be updated , in which case it requests the data from the api .", "partition": "test"}
{"idx": "2086", "code": "public static List<String> expandWildcards(Iterable<File> dirs,List<String> names,Backend forBackend){\n  List<String> result=new ArrayList<String>(names.size());\n  for (  String name : names) {\n    expandWildcard(result,dirs,name,forBackend);\n  }\n  return result;\n}\n", "docstring": "given a list of source directories and a list of module names that possibly contain wildcards it returns a expanded list of module names of modules that were actually found in the given source directories . module names that didn \"'\" t contain wildcards are left alone ( it \"'\" s not checked if they exist or not ) . if a backend is passed expanded modules will be checked if they support it ( they either don \"'\" t have a native annotation or it is for the correct backend ) .", "partition": "test"}
{"idx": "1528", "code": "public boolean isExpanded(int row){\n  TreeUI tree=getUI();\n  if (tree != null) {\n    TreePath path=tree.getPathForRow(this,row);\n    if (path != null) {\n      Boolean value=expandedState.get(path);\n      return (value != null && value.booleanValue());\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the node at the specified display row is currently expanded .", "partition": "test"}
{"idx": "3306", "code": "@TCB static String stripBannedCodeunits(String s){\n  int safeLimit=longestPrefixOfGoodCodeunits(s);\n  if (safeLimit < 0) {\n    return s;\n  }\n  StringBuilder sb=new StringBuilder(s);\n  stripBannedCodeunits(sb,safeLimit);\n  return sb.toString();\n}\n", "docstring": "returns the portion of its input that consists of xml safe chars .", "partition": "test"}
{"idx": "779", "code": "public void addContentItem(ContentItem contentItem){\n  if (contentItems == null) {\n    contentItems=new ArrayList<ContentItem>();\n  }\n  contentItems.add(contentItem);\n}\n", "docstring": "adds a content item .", "partition": "test"}
{"idx": "3932", "code": "private boolean processAuthenticationResponse(final HttpMethod method){\n  LOG.trace(\"enter HttpMethodBase.processAuthenticationResponse(\" + \"HttpState, HttpConnection)\");\n  try {\nswitch (method.getStatusCode()) {\ncase HttpStatus.SC_UNAUTHORIZED:\n      return processWWWAuthChallenge(method);\ncase HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED:\n    return processProxyAuthChallenge(method);\ndefault :\n  return false;\n}\n}\n catch (Exception e) {\nif (LOG.isErrorEnabled()) {\nLOG.error(e.getMessage(),e);\n}\nreturn false;\n}\n}\n", "docstring": "processes a response that requires authentication", "partition": "test"}
{"idx": "2517", "code": "public void start(String json){\n  guidedTourSteps.clear();\n  GuidedTourConfiguration configuration=dtoFactory.createDtoFromJson(json,GuidedTourConfiguration.class);\n  log.setDebugMode(configuration.getDebugMode());\n  this.guidedTourSteps=configuration.getSteps();\n  this.tourName=configuration.getName();\n  if (this.tourName == null || tourName.isEmpty()) {\n    tourName=\"unamed\";\n  }\n  this.hasWelcomeStep=configuration.getHasWelcomeStep();\n  startTour();\n}\n", "docstring": "loads the given json data and start the tour", "partition": "test"}
{"idx": "3676", "code": "public static <T extends Throwable>T writeStackTraces(T throwable,StreamOutput out) throws IOException {\n  StackTraceElement[] stackTrace=throwable.getStackTrace();\n  out.writeVInt(stackTrace.length);\n  for (  StackTraceElement element : stackTrace) {\n    out.writeString(element.getClassName());\n    out.writeOptionalString(element.getFileName());\n    out.writeString(element.getMethodName());\n    out.writeVInt(element.getLineNumber());\n  }\n  Throwable[] suppressed=throwable.getSuppressed();\n  out.writeVInt(suppressed.length);\n  for (  Throwable t : suppressed) {\n    out.writeThrowable(t);\n  }\n  return throwable;\n}\n", "docstring": "serializes the given exceptions stacktrace elements as well as it \"'\" s suppressed exceptions to the given output stream .", "partition": "test"}
{"idx": "1119", "code": "public ThriftServiceMetadata(Class<?> serviceType){\n  requireNonNull(serviceType,\"serviceType\");\n  interfaces=init(null,Collections.singleton(serviceType));\n}\n", "docstring": "creates a new instance from a single thrift service interface .", "partition": "test"}
{"idx": "2905", "code": "public int next(){\n  return mix(gen.getAndIncrement());\n}\n", "docstring": "produce the next identifier .", "partition": "test"}
{"idx": "801", "code": "public static String plnoun(final int quantity,final String noun){\n  final String enoun=fullForm(noun);\n  if (quantity == 1) {\n    return singular(enoun);\n  }\n else {\n    return plural(noun);\n  }\n}\n", "docstring": "returns either the plural or singular form of the given noun , depending on the quantity .", "partition": "test"}
{"idx": "500", "code": "public boolean isPingDisabled(){\n  return (null != healthcheck && !healthcheck.exists());\n}\n", "docstring": "returns true if the healthcheck flag - file is enabled but does not exist , otherwise ( no file configured , or file configured and exists ) returns false .", "partition": "test"}
{"idx": "3068", "code": "public void notifyTasks(){\n  if (tracker.shouldInterruptTask()) {\n    for (    Thread t : threadMap.values()) {\n      t.interrupt();\n    }\n  }\n}\n", "docstring": "interrupts currently running tasks .", "partition": "test"}
{"idx": "3414", "code": "public ArgParser(String pName){\n  programName=pName;\n  args=new Vector();\n  args.add(new HelpArg());\n}\n", "docstring": "create a parser for the named program . automatically adds the - help option .", "partition": "test"}
{"idx": "717", "code": "public CipherParameters decrypt(byte[] in,int inOff,int inLen,int keyLen) throws IllegalArgumentException {\n  if (!key.isPrivate()) {\n    throw new IllegalArgumentException(\"Private key required for decryption\");\n  }\n  BigInteger n=key.getModulus();\n  BigInteger d=key.getExponent();\n  byte[] C=new byte[inLen];\n  System.arraycopy(in,inOff,C,0,C.length);\n  BigInteger c=new BigInteger(1,C);\n  BigInteger r=c.modPow(d,n);\n  return generateKey(n,r,keyLen);\n}\n", "docstring": "decrypt an encapsulated session key .", "partition": "test"}
{"idx": "3379", "code": "static private String calcThreshold(double scoreThreshold,double lambda){\n  final double logProbThreshold=Math.log(1 - scoreThreshold / 0.999);\n  int maxNum=1000000;\n  if (calcLogProb(maxNum,lambda) > logProbThreshold) {\n    return \">1e6\";\n  }\n  int minNum=1;\n  while (minNum < maxNum) {\n    final int midNum=(maxNum + minNum) / 2;\n    final boolean passThreshold=calcLogProb(midNum,lambda) <= logProbThreshold;\n    if (passThreshold) {\n      maxNum=midNum;\n    }\n else {\n      if (midNum == minNum) {\n        break;\n      }\n      minNum=midNum;\n    }\n  }\n  return Integer.toString(maxNum);\n}\n", "docstring": "calculates the minimal number of instances required to achieve a score as high as the given scorethreshold for the given lambda .", "partition": "test"}
{"idx": "493", "code": "public TreeMap<Float,List<List<Integer>>> packModifiedFirstFitDescending(){\n  throw new UnsupportedOperationException(\"Not implemented yet!\");\n}\n", "docstring": "note : upper bound is 71 / 60 opt + 6 / 9 ( ~ 1 . 18 opt )", "partition": "test"}
{"idx": "3765", "code": "public static String generateNativeGuid(String deviceType,String serialNumber){\n  return String.format(\"%s+%s\",_deviceTypeMap.get(deviceType),serialNumber);\n}\n", "docstring": "the format of this native guid using the given devicetype & serialnumber .", "partition": "test"}
{"idx": "1953", "code": "public void fillHeaderAndFooter(final HttpServletRequest request,final HttpServletResponse response,final Map<String,Object> dataModel) throws Exception {\n  fillHeader(request,response,dataModel);\n  fillFooter(dataModel);\n}\n", "docstring": "fills header and footer .", "partition": "test"}
{"idx": "2739", "code": "private void stopVideoFadingEdgesScreenTimer(){\n  if (null != mVideoFadingEdgesTimer) {\n    mVideoFadingEdgesTimer.cancel();\n    mVideoFadingEdgesTimer=null;\n    mVideoFadingEdgesTimerTask=null;\n  }\n}\n", "docstring": "stop the video fading timer .", "partition": "test"}
{"idx": "1988", "code": "final void copyIntoLocalState(Operand[] _localState){\n  localState=new Operand[_localState.length];\n  System.arraycopy(_localState,0,localState,0,_localState.length);\n  setLocalKnown();\n}\n", "docstring": "save a shallow copy of the given local variable state into this .", "partition": "test"}
{"idx": "2364", "code": "public Entry editEntry(User user,String id,String note,String quotation,boolean isPublic,Long modTime,boolean isAdmin,Errors errors){\n  if (modTime == null) {\n    Errors.add(errors,errorMessages.errorModTimeIsNull());\n    return null;\n  }\n  if (user == null) {\n    Errors.add(errors,errorMessages.errorUserIsNull());\n    return null;\n  }\n  if (id != null && !idGenerator.isIdWellFormed(id)) {\n    Errors.add(errors,errorMessages.errorIdIsInvalid());\n    return null;\n  }\n  final Entry entry=getEntryById(id);\n  if (entry == null) {\n    Errors.add(errors,errorMessages.errorTheEntryCouldNotBeFound());\n    return null;\n  }\n  if (!canUserModifyEntry(user,entry,isAdmin)) {\n    Errors.add(errors,errorMessages.errorTheUserIsNotEntitledToModifyTheEntry());\n    return null;\n  }\n  if (note != null) {\n    note=cleanUpText(note);\n  }\n  if (entry.isNotebook()) {\n    entry.setNotebookTitle(note);\n  }\n else   if (entry.isSource()) {\n    entry.setSourceTitle(note);\n  }\n else {\n    entry.setNote(note);\n  }\n  entry.setModTime(modTime);\n  entry.setIsPublic(isPublic);\n  if (entry.getCreateTime() > modTime.longValue()) {\n    modTime=entry.getCreateTime();\n  }\n  if (entry.isQuotation()) {\n    if (quotation != null) {\n      quotation=cleanUpText(quotation);\n      entry.setQuotation(quotation);\n    }\n  }\n  return entry;\n}\n", "docstring": "api method . change values for the entry entry .", "partition": "test"}
{"idx": "3620", "code": "private void tryShutdown(){\n  if (isClosing() && isOkToClose())   shutdown(closeFuture.get());\n}\n", "docstring": "close was signaled in closeasync ( ) but there were pending messages at that time . this method attempts the shutdown if the returned result cleared up the last pending message .", "partition": "test"}
{"idx": "25", "code": "public void waitForVolumesToBeVisible(CGRequestParams request){\n  scan(request.getCopies(),request.getRsets());\n}\n", "docstring": "scans all sites until all volumes involved in the recoverpoint protection are visible", "partition": "test"}
{"idx": "3583", "code": "public static Resource forPath(final String path) throws UnknownResourceException {\n  Resource resource;\n  if (path.startsWith(ClasspathResource.PREFIX + \":\")) {\n    resource=new ClasspathResource(path);\n  }\n else   if (path.startsWith(FileResource.PREFIX + \":\")) {\n    resource=new FileResource(path);\n  }\n else {\n    resource=forPath(FileResource.PREFIX + \":\" + path);\n  }\n  return resource;\n}\n", "docstring": "creates an instance for a path prefixed by either classpath : or file : .", "partition": "test"}
{"idx": "3951", "code": "@Override public ShapeTileSimplex to_Simplex(){\n  if (is_empty())   return ShapeTileSimplex.EMPTY;\n  ArrayList<PlaLineInt> line_arr=new ArrayList<PlaLineInt>(4);\n  line_arr.add(new PlaLineInt(box_ll,PlaDirection.RIGHT));\n  line_arr.add(new PlaLineInt(box_ur,PlaDirection.UP));\n  line_arr.add(new PlaLineInt(box_ur,PlaDirection.LEFT));\n  line_arr.add(new PlaLineInt(box_ll,PlaDirection.DOWN));\n  return new ShapeTileSimplex(line_arr);\n}\n", "docstring": "returns an object of class simplex defining the same shape", "partition": "test"}
{"idx": "587", "code": "boolean checkToken(ByteWrapper token,Key nodeId,InetAddress ip,int port,Key lookupKey){\n  updateTokenTimestamps();\n  boolean valid=checkToken(token,nodeId,ip,port,lookupKey,timestampCurrent.get()) || checkToken(token,nodeId,ip,port,lookupKey,timestampPrevious);\n  if (!valid)   DHT.logDebug(\"Received Invalid token from \" + ip.getHostAddress());\n  return valid;\n}\n", "docstring": "check if a received token is ok .", "partition": "test"}
{"idx": "602", "code": "public int writeAnnotation(Annotation annotation){\n  int off=data.position();\n  writeByte(annotation.visibility);\n  writeEncodedArray(annotation.encodedAnnotation);\n  return off;\n}\n", "docstring": "write annotation item into current section .", "partition": "test"}
{"idx": "266", "code": "private static void verifyWriteSetNotFound(final BTree btree){\n  log.info(\"\");\n  for (int i=0; i < 1000; i++) {\n    if (btree.contains(i)) {\n      throw new RuntimeException(\"Not expecting: key=\" + i);\n    }\n  }\n}\n", "docstring": "verify that the write set is not found ( no keys in [ 0 : 1000 ) ) .", "partition": "test"}
{"idx": "2225", "code": "public static StringBuffer replaceRegex(StringBuffer original,String regex,String replace,boolean CASE_INSENSITIVE){\n  int flags=0;\n  if (CASE_INSENSITIVE)   flags=Pattern.CASE_INSENSITIVE;\n  Pattern p=Pattern.compile(regex,flags);\n  Matcher m=p.matcher(original);\n  StringBuffer newSB=new StringBuffer();\n  boolean result=m.find();\n  while (result) {\n    m.appendReplacement(newSB,replace);\n    result=m.find();\n  }\n  m.appendTail(newSB);\n  return newSB;\n}\n", "docstring": "run regex expression against original string", "partition": "test"}
{"idx": "1580", "code": "public void addStates(State[] s){\n  for (int i=0; i < s.length; i++)   states.addElement(s[i]);\n}\n", "docstring": "append states to the state vector .", "partition": "test"}
{"idx": "3149", "code": "private byte[] convertBitmapToBytes(final Bitmap bitmap){\n  int size=bitmap.getRowBytes() * bitmap.getHeight();\n  ByteArrayOutputStream out=new ByteArrayOutputStream(size);\n  try {\n    if (bitmap.compress(Bitmap.CompressFormat.PNG,0,out)) {\n      return out.toByteArray();\n    }\n    if (sLogger.isActivated()) {\n      sLogger.debug(\"Unable to convert bitmap, compression failed\");\n    }\n    return null;\n  }\n  finally {\n    CloseableUtils.tryToClose(out);\n  }\n}\n", "docstring": "converts the specified bitmap to a byte array .", "partition": "test"}
{"idx": "2579", "code": "protected String form(ObjectMatrix1D matrix,int index,Former formatter){\n  Object value=matrix.get(index);\n  if (value == null)   return \"\";\n  return String.valueOf(value);\n}\n", "docstring": "converts a given cell to a string ; no alignment considered .", "partition": "test"}
{"idx": "532", "code": "public void calculateDerived(){\n  xStats.calculateDerived();\n  yStats.calculateDerived();\n  differencesStats.calculateDerived();\n  correlation=Double.NaN;\n  if (!Double.isNaN(xStats.stdDev) && !Double.isNaN(yStats.stdDev) && !Utils.eq(xStats.stdDev,0)) {\n    double slope=(xySum - xStats.sum * yStats.sum / count) / (xStats.sumSq - xStats.sum * xStats.mean);\n    if (!Utils.eq(yStats.stdDev,0)) {\n      correlation=slope * xStats.stdDev / yStats.stdDev;\n    }\n else {\n      correlation=1.0;\n    }\n  }\n  if (Utils.gr(differencesStats.stdDev,0)) {\n    double tval=differencesStats.mean * Math.sqrt(count) / differencesStats.stdDev;\n    if (m_degreesOfFreedom >= 1) {\n      differencesProbability=Statistics.FProbability(tval * tval,1,m_degreesOfFreedom);\n    }\n else {\n      if (count > 1) {\n        differencesProbability=Statistics.FProbability(tval * tval,1,(int)count - 1);\n      }\n else {\n        differencesProbability=1;\n      }\n    }\n  }\n else {\n    if (differencesStats.sumSq == 0) {\n      differencesProbability=1.0;\n    }\n else {\n      differencesProbability=0.0;\n    }\n  }\n  differencesSignificance=0;\n  if (differencesProbability <= sigLevel) {\n    if (xStats.mean > yStats.mean) {\n      differencesSignificance=1;\n    }\n else {\n      differencesSignificance=-1;\n    }\n  }\n}\n", "docstring": "calculates the derived statistics ( significance etc ) .", "partition": "test"}
{"idx": "3852", "code": "private void addDumpFile(){\n  addDumpFile(dumpFile);\n}\n", "docstring": "add the set dumpfilestream to the tree", "partition": "test"}
{"idx": "3529", "code": "public static String asString(URI value){\n  return value != null ? value.toString() : null;\n}\n", "docstring": "gets the value of the uri as a string , returns null if the uri is null .", "partition": "test"}
{"idx": "1809", "code": "private void closeFile(){\n  if (plogStream != null) {\n    try {\n      plogStream.close();\n      logger.info(\"File \" + plogFilename + \" closed.\");\n    }\n catch (    IOException e) {\n      logger.warn(\"Unable to close file cleanly: \" + plogFilename);\n    }\n finally {\n      plogStream=null;\n    }\n  }\n}\n", "docstring": "close plog file . this operation is idempotent to allow convenient cleanup at thread exit .", "partition": "test"}
{"idx": "4130", "code": "private static Bitmap transform(Matrix scaler,Bitmap source,int targetWidth,int targetHeight,int options){\n  Log.i(TAG,\"transform --1--\");\n  boolean scaleUp=(options & 0x1) != 0;\n  boolean recycle=(options & 0x2) != 0;\n  int deltaX=source.getWidth() - targetWidth;\n  int deltaY=source.getHeight() - targetHeight;\n  if (!scaleUp && (deltaX < 0 || deltaY < 0)) {\n    Log.i(TAG,\"transform --2--\");\n    Bitmap b2=Bitmap.createBitmap(targetWidth,targetHeight,Bitmap.Config.ARGB_8888);\n    Canvas c=new Canvas(b2);\n    int deltaXHalf=Math.max(0,deltaX / 2);\n    int deltaYHalf=Math.max(0,deltaY / 2);\n    Rect src=new Rect(deltaXHalf,deltaYHalf,deltaXHalf + Math.min(targetWidth,source.getWidth()),deltaYHalf + Math.min(targetHeight,source.getHeight()));\n    int dstX=(targetWidth - src.width()) / 2;\n    int dstY=(targetHeight - src.height()) / 2;\n    Rect dst=new Rect(dstX,dstY,targetWidth - dstX,targetHeight - dstY);\n    c.drawBitmap(source,src,dst,null);\n    if (recycle) {\n      source.recycle();\n    }\n    c.setBitmap(null);\n    Log.i(TAG,\"transform --3--\");\n    return b2;\n  }\n  float bitmapWidthF=source.getWidth();\n  float bitmapHeightF=source.getHeight();\n  Log.i(TAG,\"bitmapWidthF:\" + bitmapWidthF + \",bitmapHeightF:\"+ bitmapHeightF);\n  float bitmapAspect=bitmapWidthF / bitmapHeightF;\n  float viewAspect=(float)targetWidth / targetHeight;\n  Log.i(TAG,\"targetWidth:\" + targetWidth + \",targetHeight:\"+ targetHeight);\n  if (bitmapAspect > viewAspect) {\n    float scale=targetHeight / bitmapHeightF;\n    if (scale < .9F || scale > 1F) {\n      scaler.setScale(scale,scale);\n    }\n else {\n      scaler=null;\n    }\n  }\n else {\n    float scale=targetWidth / bitmapWidthF;\n    if (scale < .9F || scale > 1F) {\n      scaler.setScale(scale,scale);\n    }\n else {\n      scaler=null;\n    }\n  }\n  Bitmap b1;\n  if (scaler != null) {\n    Log.i(TAG,\"transform --3.1--\");\n    b1=Bitmap.createBitmap(source,0,0,source.getWidth(),source.getHeight(),scaler,true);\n  }\n else {\n    Log.i(TAG,\"transform --3.2--\");\n    b1=source;\n  }\n  if (recycle && b1 != source) {\n    Log.i(TAG,\"transform --4--\");\n    source.recycle();\n  }\n  int dx1=Math.max(0,b1.getWidth() - targetWidth);\n  int dy1=Math.max(0,b1.getHeight() - targetHeight);\n  Bitmap b2=Bitmap.createBitmap(b1,dx1 / 2,dy1 / 2,targetWidth,targetHeight);\n  if (b2 != b1) {\n    if (recycle || b1 != source) {\n      Log.i(TAG,\"transform --5--\");\n      b1.recycle();\n    }\n  }\n  Log.i(TAG,\"transform --6--\");\n  if (b2 == null) {\n    Log.i(TAG,\"transform --7--\");\n  }\n  return b2;\n}\n", "docstring": "transform source bitmap to targeted width and height", "partition": "test"}
{"idx": "127", "code": "private void evaluatePopup(MouseEvent e){\n  if (e.isPopupTrigger()) {\n    JPopupMenu menu=createBookmarkPopupMenu();\n    if (menu != null) {\n      menu.show(this,e.getX(),e.getY());\n    }\n  }\n}\n", "docstring": "checks if the given mouse event is a popup trigger and creates a new popup menu if necessary .", "partition": "test"}
{"idx": "2919", "code": "public String decrypt(String sCipherText){\n  int nLen=(sCipherText.length() >> 1) & ~7;\n  if (nLen < BlowfishECB.BLOCKSIZE)   return null;\n  byte[] cbciv=new byte[BlowfishECB.BLOCKSIZE];\n  int nNumOfBytes=BinConverter.binHexToBytes(sCipherText,cbciv,0,0,BlowfishECB.BLOCKSIZE);\n  if (nNumOfBytes < BlowfishECB.BLOCKSIZE)   return null;\n  m_bfish.setCBCIV(cbciv);\n  nLen-=BlowfishECB.BLOCKSIZE;\n  if (nLen == 0)   return \"\";\n  byte[] buf=new byte[nLen];\n  nNumOfBytes=BinConverter.binHexToBytes(sCipherText,buf,BlowfishECB.BLOCKSIZE * 2,0,nLen);\n  if (nNumOfBytes < nLen)   return null;\n  m_bfish.decrypt(buf);\n  int nPadByte=buf[buf.length - 1] & 0x0ff;\n  if ((nPadByte > 8) || (nPadByte < 0))   nPadByte=0;\n  nNumOfBytes-=nPadByte;\n  if (nNumOfBytes < 0)   return \"\";\n  return BinConverter.byteArrayToUNCString(buf,0,nNumOfBytes);\n}\n", "docstring": "decrypts a hexbin string ( handling is case sensitive )", "partition": "test"}
{"idx": "61", "code": "private static void fixGPSTimeStamp(XMPNode exifSchema) throws XMPException {\n  XMPNode gpsDateTime=XMPNodeUtils.findChildNode(exifSchema,\"exif:GPSTimeStamp\",false);\n  if (gpsDateTime == null) {\n    return;\n  }\n  try {\n    XMPDateTime binGPSStamp;\n    XMPDateTime binOtherDate;\n    binGPSStamp=XMPUtils.convertToDate(gpsDateTime.getValue());\n    if (binGPSStamp.getYear() != 0 || binGPSStamp.getMonth() != 0 || binGPSStamp.getDay() != 0) {\n      return;\n    }\n    XMPNode otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeOriginal\",false);\n    if (otherDate == null) {\n      otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeDigitized\",false);\n    }\n    binOtherDate=XMPUtils.convertToDate(otherDate.getValue());\n    Calendar cal=binGPSStamp.getCalendar();\n    cal.set(Calendar.YEAR,binOtherDate.getYear());\n    cal.set(Calendar.MONTH,binOtherDate.getMonth());\n    cal.set(Calendar.DAY_OF_MONTH,binOtherDate.getDay());\n    binGPSStamp=new XMPDateTimeImpl(cal);\n    gpsDateTime.setValue(XMPUtils.convertFromDate(binGPSStamp));\n  }\n catch (  XMPException e) {\n    return;\n  }\n}\n", "docstring": "fixes the gps timestamp in exif .", "partition": "test"}
{"idx": "3482", "code": "public String toString(){\n  return text();\n}\n", "docstring": "returns the text of this gpathresult .", "partition": "test"}
{"idx": "1266", "code": "public void createDatabaseEntitiesForStoragePolicyTesting(){\n  createDatabaseEntitiesForStoragePolicyTesting(AbstractServiceTest.STORAGE_POLICY_NAMESPACE_CD,Arrays.asList(AbstractServiceTest.STORAGE_POLICY_RULE_TYPE),AbstractServiceTest.BDEF_NAMESPACE,AbstractServiceTest.BDEF_NAME,Arrays.asList(AbstractServiceTest.FORMAT_FILE_TYPE_CODE),Arrays.asList(AbstractServiceTest.STORAGE_NAME),Arrays.asList(AbstractServiceTest.STORAGE_NAME_2));\n}\n", "docstring": "create and persist database entities required for storage policy service testing .", "partition": "test"}
{"idx": "1688", "code": "static long makeId(SnmpOid oid){\n  long id=0;\n  long[] arcs=oid.longValue(false);\n  id|=arcs[0] << 56;\n  id|=arcs[1] << 48;\n  id|=arcs[2] << 40;\n  id|=arcs[3] << 32;\n  id|=arcs[4] << 24;\n  id|=arcs[5] << 16;\n  id|=arcs[6] << 8;\n  id|=arcs[7];\n  return id;\n}\n", "docstring": "translate an oid to a thread id . arc follow the long big - endian order .", "partition": "test"}
{"idx": "2527", "code": "private boolean hasProxySettings(Properties settings){\n  String proxyHost=settings.getProperty(\"org.gnome.system.proxy.http host\",null);\n  return proxyHost != null && proxyHost.length() > 0;\n}\n", "docstring": "checks if we have proxy configuration settings in the properties .", "partition": "test"}
{"idx": "2635", "code": "private void parseMenu(XmlPullParser parser,AttributeSet attrs,SublimeMenu menu) throws XmlPullParserException, IOException {\n  MenuState menuState=new MenuState(menu);\n  int eventType=parser.getEventType();\n  String tagName;\n  boolean lookingForEndOfUnknownTag=false;\n  String unknownTagName=null;\n  do {\n    if (eventType == XmlPullParser.START_TAG) {\n      tagName=parser.getName();\n      if (tagName.equals(XML_MENU)) {\n        eventType=parser.next();\n        break;\n      }\n      throw new RuntimeException(\"Expecting menu, got \" + tagName);\n    }\n    eventType=parser.next();\n  }\n while (eventType != XmlPullParser.END_DOCUMENT);\n  boolean reachedEndOfMenu=false;\n  while (!reachedEndOfMenu) {\nswitch (eventType) {\ncase XmlPullParser.START_TAG:\n      if (lookingForEndOfUnknownTag) {\n        break;\n      }\n    tagName=parser.getName();\n  if (tagName.equals(XML_GROUP)) {\n    if (menuState.groupId != MenuState.defaultGroupId) {\n      throw new RuntimeException(\"A \\'Group\\' item cannot have \" + \"other \\'Group\\' items as children.\");\n    }\n    menuState.readGroup(attrs);\n    menuState.addGroup();\n  }\n else   if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_SEPARATOR)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_GROUP_HEADER)) {\n    if (menuState.groupId == MenuState.defaultGroupId) {\n      throw new RuntimeException(\"\\'GroupHeader\\' item should \" + \"be placed inside a Group element.\");\n    }\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_MENU)) {\n    throw new RuntimeException(\"Sub-menus are not supported. \" + \"Similar functionality can be afforded \" + \"using the \\'group\\' tag.\");\n  }\n else {\n    lookingForEndOfUnknownTag=true;\n    unknownTagName=tagName;\n  }\nbreak;\ncase XmlPullParser.END_TAG:\ntagName=parser.getName();\nif (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {\nlookingForEndOfUnknownTag=false;\nunknownTagName=null;\n}\n else if (tagName.equals(XML_GROUP)) {\nif (menuState.isGroupCollapsible() && menuState.groupHeadersAdded != 1) {\nif (menuState.groupHeadersAdded < 1) {\n  throw new RuntimeException(\"A \\'GroupHeader\\' is required \" + \"to create a \\'collapsible\\' Group.\");\n}\n else {\n  throw new RuntimeException(\"A \\'collapsible\\' Group can only \" + \"have ONE \\'GroupHeader\\'. You have provided: \" + menuState.groupHeadersAdded + \".\");\n}\n}\nmenuState.resetGroup();\n}\n else if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)|| tagName.equals(XML_GROUP_HEADER)|| tagName.equals(XML_SEPARATOR)) {\nif (!menuState.hasAddedItem()) {\nmenuState.addItem();\n}\n}\n else if (tagName.equals(XML_MENU)) {\nreachedEndOfMenu=true;\n}\nbreak;\ncase XmlPullParser.END_DOCUMENT:\nthrow new RuntimeException(\"Unexpected end of document\");\n}\neventType=parser.next();\n}\n}\n", "docstring": "called internally to fill the given menu .", "partition": "test"}
{"idx": "509", "code": "protected final File createDBFFDCDirectory(){\n  File dbffdcDir=new File(ffdcDirectoryName);\n  if (!dbffdcDir.exists()) {\n    final boolean isDBFFDcDirCreated=dbffdcDir.mkdirs();\n    if (isDBFFDcDirCreated) {\n      dbffdcDir=new File(ffdcDirectoryName);\n      return dbffdcDir;\n    }\n  }\n else   if (!dbffdcDir.isDirectory()) {\n    return null;\n  }\n  return dbffdcDir;\n}\n", "docstring": "creates the sub - directory where this particular back - up instance will be kept .", "partition": "test"}
{"idx": "2740", "code": "public void removeListener(final TimeoutEventListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "deregisters a timeout event listener for timeout notification .", "partition": "test"}
{"idx": "4146", "code": "private String fetchCharsetFromCache(Client client,Locale loc){\n  Map cCache=(Map)charsetCache.get(client.getClientType());\n  String val=null;\n  if (cCache != null) {\n    val=(String)cCache.get(loc);\n  }\n  return val;\n}\n", "docstring": "fetches the charset to be used for any given locale from cache", "partition": "test"}
{"idx": "2659", "code": "public EipModelWizardInitialObjectCreationPage(String pageId){\n  super(pageId);\n}\n", "docstring": "pass in the selection . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "574", "code": "public static boolean hasDeadStatesFromInitial(Automaton a){\n  BitSet reachableFromInitial=getLiveStatesFromInitial(a);\n  BitSet reachableFromAccept=getLiveStatesToAccept(a);\n  reachableFromInitial.andNot(reachableFromAccept);\n  return reachableFromInitial.isEmpty() == false;\n}\n", "docstring": "returns true if there are dead states reachable from an initial state .", "partition": "test"}
{"idx": "4040", "code": "public DNewKeyStoreType(JFrame parent){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  setTitle(res.getString(\"DNewKeyStoreType.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dnewkeystoretype dialog .", "partition": "test"}
{"idx": "1617", "code": "public void addListener(SpeedrunsLiveListener listener){\n  listeners.add(listener);\n}\n", "docstring": "adds a listener that receives the data and error messages .", "partition": "test"}
{"idx": "1900", "code": "@HLEFunction(nid=0x9AC2EEAC,version=150) public int sceNetAdhocPtpFlush(@CheckArgument(\"checkPtpId\") int id,int timeout,int nonblock){\n  return 0;\n}\n", "docstring": "wait for data in the buffer to be sent", "partition": "test"}
{"idx": "4223", "code": "public static TypedOperation createArrayCreation(ArrayType arrayType){\n  List<Type> typeList=new ArrayList<>();\n  typeList.add(JavaTypes.INT_TYPE);\n  TypeTuple inputTypes=new TypeTuple(typeList);\n  return new TypedTermOperation(new ArrayCreation(arrayType),inputTypes,arrayType);\n}\n", "docstring": "creates a simple array creation operation for the given type .", "partition": "test"}
{"idx": "1322", "code": "public double patience(int k,F f,int N){\n  double pf=p(f);\n  BinomialDistribution dist=new BinomialDistribution(null,N,pf);\n  double p0=Math.pow(1 - pf,N);\n  return 1 - (dist.cumulativeProbability(k - 1) - p0) / (1 - p0);\n}\n", "docstring": "return the patience , i . e . , the penalization of having a number of items with the same feature in a recommendation list of a given size .", "partition": "test"}
{"idx": "96", "code": "public Dimension minimumLayoutSize(Container target){\n  Dimension size;\nsynchronized (this) {\n    checkContainer(target);\n    checkRequests();\n    size=new Dimension(xTotal.minimum,yTotal.minimum);\n  }\n  Insets insets=target.getInsets();\n  size.width=(int)Math.min((long)size.width + (long)insets.left + (long)insets.right,Integer.MAX_VALUE);\n  size.height=(int)Math.min((long)size.height + (long)insets.top + (long)insets.bottom,Integer.MAX_VALUE);\n  return size;\n}\n", "docstring": "returns the minimum dimensions needed to lay out the components contained in the specified target container .", "partition": "test"}
{"idx": "2378", "code": "public static String toHumanReadableString(final String iso8601Duration){\n  String str=\"\";\n  if (iso8601Duration.matches(\"P\\\\\\\\d+[YMD].+\")) {\n    str=\"inf.\";\n  }\n else {\n    String hours=getHours(iso8601Duration), minutes=getMinutes(iso8601Duration), seconds=getSeconds(iso8601Duration);\n    if (hours != null) {\n      str=hours;\n      if (minutes != null && minutes.length() == 1) {\n        minutes=\"0\" + minutes;\n      }\n    }\n    if (str.isEmpty())     str=minutes;\n else     str+=\":\" + minutes;\n    if (str.isEmpty())     str=seconds;\n else     str+=\":\" + seconds;\n  }\n  return str;\n}\n", "docstring": "converts the supplies iso 8601 duration into a human readable string . if the supplied duration is greater than 1 day , then it will return \" inf . \" .", "partition": "test"}
{"idx": "1968", "code": "static BufferedImage convertImage(BufferedImage image){\nswitch (image.getType()) {\ncase BufferedImage.TYPE_INT_ARGB_PRE:\n    return image;\ncase BufferedImage.TYPE_4BYTE_ABGR:\n  image.coerceData(true);\nreturn image;\n}\nBufferedImage convertedImage=new BufferedImage(image.getWidth(),image.getHeight(),BufferedImage.TYPE_INT_ARGB_PRE);\nGraphics2D g=convertedImage.createGraphics();\ng.setColor(new java.awt.Color(0f,0f,0f,0f));\ng.fillRect(0,0,image.getWidth(),image.getHeight());\ng.drawImage(image,0,0,null);\ng.dispose();\nreturn convertedImage;\n}\n", "docstring": "converts the given image into a format for quick upload to the gpu .", "partition": "test"}
{"idx": "1589", "code": "@SuppressLint(\"DrawAllocation\") @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int maxWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int maxHeight=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.UNSPECIFIED)   maxWidth=Integer.MAX_VALUE;\n  if (heightMode == MeasureSpec.UNSPECIFIED)   maxHeight=Integer.MAX_VALUE;\n  int paddingLeft=getPaddingLeft();\n  int paddingTop=getPaddingTop();\n  int paddingRight=getPaddingRight();\n  int paddingBottom=getPaddingBottom();\n  int maxRightBound=maxWidth - paddingRight;\n  int maxBottomBound=maxHeight - paddingBottom;\n  int left;\n  int top;\n  int right;\n  int bottom;\n  int rightBound=paddingLeft;\n  int maxRightNoPadding=rightBound;\n  int bottomBound;\n  int lastMaxBottom=paddingTop;\n  int maxBottom=lastMaxBottom;\n  int childWidth;\n  int childHeight;\n  int lineStartIndex=0;\n  int lineEndIndex;\n  rectList.clear();\n  int childCount=getChildCount();\n  for (int index=0; index < childCount; index++) {\n    final View child=getChildAt(index);\n    child.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);\n    if (child.getVisibility() == View.GONE)     continue;\n    final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n    childWidth=child.getMeasuredWidth();\n    childHeight=child.getMeasuredHeight();\n    left=rightBound + lp.leftMargin;\n    right=left + childWidth;\n    rightBound=right + lp.rightMargin;\n    if (rightBound > maxRightBound) {\n      lineEndIndex=index;\n      adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,lineEndIndex);\n      if (maxBottom >= maxBottomBound)       break;\n      if (lineEndIndex == lineStartIndex) {\n        child.measure(MeasureSpec.makeMeasureSpec(maxWidth - paddingLeft - paddingRight- lp.leftMargin- lp.rightMargin,MeasureSpec.AT_MOST),MeasureSpec.UNSPECIFIED);\n        childWidth=child.getMeasuredWidth();\n        childHeight=child.getMeasuredHeight();\n      }\n      left=paddingLeft + lp.leftMargin;\n      right=left + childWidth;\n      rightBound=right + lp.rightMargin;\n      lastMaxBottom=maxBottom;\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n      lineStartIndex=index;\n    }\n else {\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n    }\n    if (rightBound > maxRightNoPadding)     maxRightNoPadding=rightBound;\n    if (bottomBound > maxBottom)     maxBottom=bottomBound;\n    Rect rect=new Rect();\n    rect.left=left;\n    rect.top=top;\n    rect.right=right;\n    rect.bottom=bottom;\n    rectList.add(rect);\n  }\n  adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,rectList.size());\n  int measuredWidth;\n  int measuredHeight;\n  if (widthMode == MeasureSpec.EXACTLY)   measuredWidth=maxWidth;\n else   measuredWidth=maxRightNoPadding + paddingRight;\n  if (heightMode == MeasureSpec.EXACTLY)   measuredHeight=maxHeight;\n else {\n    measuredHeight=maxBottom + paddingBottom;\n    if (heightMode == MeasureSpec.AT_MOST)     measuredHeight=measuredHeight > maxHeight ? maxHeight : measuredHeight;\n  }\n  setMeasuredDimension(measuredWidth,measuredHeight);\n}\n", "docstring": "each row or line at least show one child horizontal only show child can show or partly show in parent", "partition": "test"}
{"idx": "3525", "code": "protected void addAllForReplay(Collection<Participant> participants){\n  Iterator<Participant> it=participants.iterator();\n  while (it.hasNext()) {\n    Participant p=it.next();\n    replayCompletion(p);\n  }\n}\n", "docstring": "utility method for subclasses .", "partition": "test"}
{"idx": "3297", "code": "public void write(byte[] buf) throws IOException {\n  output.write(buf);\n  bytesWritten+=buf.length;\n}\n", "docstring": "counts the written bytes .", "partition": "test"}
{"idx": "1259", "code": "public static void onDatabase(MongoClient client,String dbName,Consumer<MongoDatabase> dbOperation){\n  if (contains(client.listDatabaseNames(),dbName)) {\n    dbOperation.accept(client.getDatabase(dbName));\n  }\n}\n", "docstring": "perform the given operation on the database with the given name , only if that database exists .", "partition": "test"}
{"idx": "1204", "code": "public E poll(long timeout,TimeUnit unit) throws InterruptedException {\n  long nanos=unit.toNanos(timeout);\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null) {\n        if (nanos <= 0)         return null;\n else         nanos=available.awaitNanos(nanos);\n      }\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n        if (nanos <= 0)         return null;\n        if (nanos < delay || leader != null)         nanos=available.awaitNanos(nanos);\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            long timeLeft=available.awaitNanos(delay);\n            nanos-=delay - timeLeft;\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}\n", "docstring": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue , or the specified wait time expires .", "partition": "test"}
{"idx": "886", "code": "void addXMLElementAfterTokenIndex(int lastTokenIndex,XMLElement element,boolean addAfterNewLine) throws Exception {\n  addXMLElementAfterTokenIndex(lastTokenIndex,element,addAfterNewLine,true);\n}\n", "docstring": "adds the given xmlelement after the token whoes index matches the given lasttokenindex value . if the flag addafternewline is true , a new line is added before the addition of the new element to this document .", "partition": "test"}
{"idx": "3117", "code": "public static int instanceOf(Object o,Class<?> c){\n  if (o == null)   return FALSE;\n  return c.isAssignableFrom(o.getClass()) ? TRUE : FALSE;\n}\n", "docstring": "replacement function for the java instanceof instruction , which returns a distance integer", "partition": "test"}
{"idx": "1096", "code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof BubbleXYItemLabelGenerator)) {\n    return false;\n  }\n  if (!super.equals(obj)) {\n    return false;\n  }\n  BubbleXYItemLabelGenerator that=(BubbleXYItemLabelGenerator)obj;\n  if (!ObjectUtilities.equal(this.zFormat,that.zFormat)) {\n    return false;\n  }\n  if (!ObjectUtilities.equal(this.zDateFormat,that.zDateFormat)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "tests this object for equality with an arbitrary object .", "partition": "test"}
{"idx": "2244", "code": "public static long bytesToLong(final byte[] bytes){\n  final ByteBuffer buffer=ByteBuffer.allocate(8);\n  buffer.put(bytes,0,8);\n  buffer.flip();\n  return buffer.getLong();\n}\n", "docstring": "converts an array of 8 bytes into a long .", "partition": "test"}
{"idx": "1600", "code": "public boolean isAborted(){\n  return isAborted.get();\n}\n", "docstring": "returns whether the printng was aborted using this printingstatus", "partition": "test"}
{"idx": "3398", "code": "public List<Properties> findAvailableProperties(String uri) throws IOException {\n  _resourcesNotLoaded.clear();\n  String fulluri=_path + uri;\n  List<Properties> properties=new ArrayList<>();\n  Enumeration<URL> resources=getResources(fulluri);\n  while (resources.hasMoreElements()) {\n    URL url=resources.nextElement();\n    try {\n      Properties props=loadProperties(url);\n      properties.add(props);\n    }\n catch (    Exception notAvailable) {\n      _resourcesNotLoaded.add(url.toExternalForm());\n    }\n  }\n  return properties;\n}\n", "docstring": "finds the corresponding resources and reads them in as a properties files < p / > any url that cannot be read in as a properties file will be added to the \"'\" resourcesnotloaded \"'\" collection . < p / > example classpath : < p / > meta - inf / app . properties meta - inf / app . properties meta - inf / app . properties < p / > resourcefinder finder = new resourcefinder ( \" meta - inf / \" ) ; list < properties > appprops = finder . findavailableproperties ( \" app . properties \" ) ;", "partition": "test"}
{"idx": "1429", "code": "@SuppressWarnings(\"unchecked\") public List<Boundary> populateArea(final Long wardId){\n  HierarchyType hType=heirarchyTypeService.getHierarchyTypeByName(hierarchyTypeName);\n  ;\n  List<Boundary> areaList=new LinkedList<Boundary>();\n  final BoundaryType childBoundaryType=boundaryTypeService.getBoundaryTypeByNameAndHierarchyType(\"Area\",hType);\n  final Boundary parentBoundary=boundaryService.getBoundaryById(wardId);\n  areaList=new LinkedList(crossHeirarchyService.getCrossHierarchyChildrens(parentBoundary,childBoundaryType));\n  LOGGER.info(\"***********Ajax AreaList: \" + areaList.toString());\n  return areaList;\n}\n", "docstring": "populate the area list by ward", "partition": "test"}
{"idx": "478", "code": "void fillEntryTree(Set<PageLeafEntry> entries,Row row){\n  int ptr=_rowHead;\n  byte[] buffer=_buffer;\n  while (ptr < BLOCK_SIZE) {\n    int code=buffer[ptr] & CODE_MASK;\n    int len=getLength(code,row);\n    if (code == INSERT || code == REMOVE) {\n      PageLeafEntry entry=new PageLeafEntry(this,row,ptr,len,code);\n      entries.add(entry);\n    }\n    ptr+=len;\n  }\n}\n", "docstring": "fills the entry tree map with entries from the block .", "partition": "test"}
{"idx": "2267", "code": "public static void main(String[] args){\n  new GeneratorTester(args);\n}\n", "docstring": "test the image generator .", "partition": "test"}
{"idx": "2741", "code": "protected static void processGenericPropertiesCreatorProps(File propsFile){\n  try {\n    Properties expProps=new Properties();\n    BufferedInputStream bi=new BufferedInputStream(new FileInputStream(propsFile));\n    expProps.load(bi);\n    bi.close();\n    bi=null;\n    Properties GPCInputProps=GenericPropertiesCreator.getGlobalInputProperties();\n    Set<Object> keys=expProps.keySet();\n    Iterator<Object> keysI=keys.iterator();\n    while (keysI.hasNext()) {\n      String key=(String)keysI.next();\n      String existingVal=GPCInputProps.getProperty(key,\"\");\n      if (existingVal.length() > 0) {\n        String newVal=expProps.getProperty(key);\n        if (existingVal.indexOf(newVal) < 0) {\n          newVal=existingVal + \",\" + newVal;\n          GPCInputProps.put(key,newVal);\n        }\n      }\n else {\n        String newVal=expProps.getProperty(key);\n        GPCInputProps.put(key,newVal);\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n}\n", "docstring": "process a package \"'\" s genericpropertiescreator . props file", "partition": "test"}
{"idx": "978", "code": "public void applyCamera(GL2 gl){\n  gl.glMatrixMode(GL2.GL_PROJECTION);\n  gl.glLoadIdentity();\n  glu.gluPerspective(45f,width / (float)height,0.f,10.f);\n  eye[0]=(float)Math.sin(theta) * 2.f;\n  eye[1]=.5f;\n  eye[2]=(float)Math.cos(theta) * 2.f;\n  glu.gluLookAt(eye[0],eye[1],eye[2],.0f,.0f,0.f,0.f,1.f,0.f);\n  gl.glMatrixMode(GL2.GL_MODELVIEW);\n  gl.glLoadIdentity();\n  gl.glViewport(0,0,width,height);\n}\n", "docstring": "apply the camera settings .", "partition": "test"}
{"idx": "3053", "code": "protected int encode(double value,double lower,double upper,int nbits){\n  if (value < lower)   return 0;\n  int maxval=(int)(Math.pow(2,nbits) - 1);\n  if (value >= upper)   return maxval;\n  return (int)((value - lower) * ((maxval - 0) / (upper - lower)));\n}\n", "docstring": "encode value as an nbits unsigned integer", "partition": "test"}
{"idx": "3581", "code": "public void sortPools(List<StoragePool> storagePools){\n  _portMetricsProcessor.computeStoragePoolsAvgPortMetrics(storagePools);\n  Collections.sort(storagePools,_storagePoolComparator);\n}\n", "docstring": "sort list of storage pools based on its storage system \"'\" s average usage port metrics usage . its secondary sorting components are free and subscribed capacity", "partition": "test"}
{"idx": "3324", "code": "public static void addAttributeDefaultValues(String serviceName,String subSchemaName,String schemaType,String attributeName,Set defaultValues) throws UpgradeException {\n  String classMethod=\"UpgradeUtils:addAttributeDefaultValues : \";\n  if (debug.messageEnabled()) {\n    debug.message(classMethod + \"Updating attribute default values\");\n    debug.message(\"in :\" + serviceName + \"for attribute: \"+ attributeName);\n  }\n  ServiceSchema ss=getServiceSchema(serviceName,subSchemaName,schemaType);\n  try {\n    Map attributeDefaults=ss.getAttributeDefaults();\n    Set oldAttrValues=(Set)attributeDefaults.get(attributeName);\n    Set newAttrValues=((oldAttrValues == null) || oldAttrValues.isEmpty()) ? new HashSet() : new HashSet(oldAttrValues);\n    newAttrValues.addAll(defaultValues);\n    ss.setAttributeDefaults(attributeName,newAttrValues);\n  }\n catch (  SSOException ssoe) {\n    throw new UpgradeException(\"Invalid SSOToken\");\n  }\ncatch (  SMSException sme) {\n    throw new UpgradeException(\"Failed to add attribute default \" + \"values\");\n  }\n}\n", "docstring": "adds default values to an existing attribute . the existing values in the attribute will be updated with new values .", "partition": "test"}
{"idx": "553", "code": "public CommonTurnoutOperationConfig(TurnoutOperation op){\n  super(op);\n  myOp=(CommonTurnoutOperation)op;\n  maxTriesSpinner=new JSpinner();\n  intervalSpinner=new JSpinner();\n  Box vbox=Box.createVerticalBox();\n  Box hbox1=Box.createHorizontalBox();\n  Box hbox2=Box.createHorizontalBox();\n  vbox.add(hbox2);\n  vbox.add(hbox1);\n  vbox.add(Box.createVerticalGlue());\n  hbox1.add(new JLabel(Bundle.getMessage(\"Interval\")));\n  hbox1.add(Box.createHorizontalGlue());\n  intervalSpinner.setMinimumSize(new Dimension(100,20));\n  intervalSpinner.setModel(new SpinnerNumberModel(myOp.getInterval(),CommonTurnoutOperation.minInterval,CommonTurnoutOperation.maxInterval,CommonTurnoutOperation.intervalStepSize));\n  hbox1.add(intervalSpinner);\n  hbox2.add(new JLabel(Bundle.getMessage(\"TimesToTry\")));\n  hbox2.add(Box.createHorizontalGlue());\n  maxTriesSpinner.setMinimumSize(new Dimension(100,20));\n  maxTriesSpinner.setModel(new SpinnerNumberModel(myOp.getMaxTries(),CommonTurnoutOperation.minMaxTries,CommonTurnoutOperation.maxMaxTries,1));\n  hbox2.add(maxTriesSpinner);\n  Box hbox3=Box.createHorizontalBox();\n  hbox3.add(Box.createHorizontalStrut(150));\n  vbox.add(hbox3);\n  add(vbox);\n}\n", "docstring": "create the config jpanel , if there is one , to configure this operation type", "partition": "test"}
{"idx": "3220", "code": "long readLong() throws IOException {\n  return (((long)_is.read() << 56) | ((long)_is.read() << 48) | ((long)_is.read() << 40)| ((long)_is.read() << 32)| ((long)_is.read() << 24)| ((long)_is.read() << 16)| ((long)_is.read() << 8)| ((long)_is.read()));\n}\n", "docstring": "parses a 64 - bit int .", "partition": "test"}
{"idx": "3937", "code": "private boolean lockOrder(Order order){\n  lock.lock();\n  try {\n    return activeOrders.add(order.getId());\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "attempts the lock the order . if the order is already active this returns false .", "partition": "test"}
{"idx": "2523", "code": "@Override public String toString(){\n  StringBuilder risul=new StringBuilder(1000);\n  risul.append(\"BoardPanel \");\n  risul.append(\"available object: itera_board\");\n  return risul.toString();\n}\n", "docstring": "used to have some meaningful info on this object mostly used for beanshell", "partition": "test"}
{"idx": "2847", "code": "private boolean toState(LifecycleState newState){\n  LifecycleState state;\nsynchronized (this) {\n    state=_state;\n    _state=newState;\n    _lastChangeTime=CurrentTime.currentTime();\n  }\n  if (_log != null && _log.isLoggable(_lowLevel)) {\n    _log.log(_lowLevel,newState + \" \" + _name);\n  }\n  notifyListeners(state,newState);\n  return true;\n}\n", "docstring": "changes to the next state .", "partition": "test"}
{"idx": "3573", "code": "protected double computeAzimuthLabelOffset(double radius,double maxRadius){\n  return Math.asin(AZIMUTH_LABEL_OFFSET * maxRadius / radius);\n}\n", "docstring": "compute an angular offset to apply to a azimuth label . this angle will be added to the azimuth of the label \"'\" s azimuth in order to place the label a little bit to the side of the line that it applies to .", "partition": "test"}
{"idx": "2982", "code": "private String[] combineResultsFromMultipleReads(String[] buffer,String[] lastRead){\n  String[] t=new String[buffer.length + lastRead.length];\n  System.arraycopy(buffer,0,t,0,buffer.length);\n  System.arraycopy(lastRead,0,t,buffer.length,lastRead.length);\n  return t;\n}\n", "docstring": "for multi line records this method combines the current result with the result from previous read ( s ) .", "partition": "test"}
{"idx": "4225", "code": "public PreferenceBuilder<PreferenceClass> prefType(Class<PreferenceClass> prefType){\n  if (!VALID_TYPES.contains(prefType)) {\n    throw new IllegalArgumentException(\"The specified type: \" + prefType + \" is not supported in preferences\");\n  }\n  this.prefType=prefType;\n  return this;\n}\n", "docstring": "the type of preference to retrieve", "partition": "test"}
{"idx": "3441", "code": "final private String syntaxDef2SyntaxDesc(Attributes attrs) throws NamingException {\n  StringBuffer syntaxDesc=new StringBuffer(\"( \");\n  Attribute attr=null;\n  int count=0;\n  attr=attrs.get(NUMERICOID_ID);\n  if (attr != null) {\n    syntaxDesc.append(writeNumericOID(attr));\n    count++;\n  }\n else {\n    throw new ConfigurationException(\"Attribute type doesn\\'t\" + \"have a numeric OID\");\n  }\n  attr=attrs.get(DESC_ID);\n  if (attr != null) {\n    syntaxDesc.append(writeQDString(attr));\n    count++;\n  }\n  if (count < attrs.size()) {\n    String attrId=null;\n    for (NamingEnumeration<? extends Attribute> ae=attrs.getAll(); ae.hasMoreElements(); ) {\n      attr=ae.next();\n      attrId=attr.getID();\n      if (attrId.equals(NUMERICOID_ID) || attrId.equals(DESC_ID)) {\n        continue;\n      }\n else {\n        syntaxDesc.append(writeQDStrings(attr));\n      }\n    }\n  }\n  syntaxDesc.append(\")\");\n  return syntaxDesc.toString();\n}\n", "docstring": "translate attributes that describe an attribute syntax definition into the string description as defined in rfc 2252 .", "partition": "test"}
{"idx": "1546", "code": "@Override public void trim(){\n  if (counter < x.length) {\n    int[] y=new int[counter];\n    System.arraycopy(x,0,y,0,counter);\n    x=y;\n    resizeValues(counter);\n  }\n}\n", "docstring": "trims the data row to the number of actually used elements .", "partition": "test"}
{"idx": "942", "code": "public void writeLEChars(String s) throws IOException {\n  int length=s.length();\n  for (int i=0; i < length; i++) {\n    int c=s.charAt(i);\n    out.write(c & 0xFF);\n    out.write((c >>> 8) & 0xFF);\n  }\n  written+=length * 2;\n}\n", "docstring": "writes a string in little endian", "partition": "test"}
{"idx": "2577", "code": "public Options put(String option,Integer value){\n  if (value == null) {\n    return remove(option);\n  }\n  options.put(option,value.toString());\n  return this;\n}\n", "docstring": "put an option integer value .", "partition": "test"}
{"idx": "3088", "code": "private void listDirectory(File directory,RelativeDirectory subdirectory,Set<JavaFileObject.Kind> fileKinds,boolean recurse,ListBuffer<JavaFileObject> resultList){\n  File d=subdirectory.getFile(directory);\n  if (!caseMapCheck(d,subdirectory))   return;\n  File[] files=d.listFiles();\n  if (files == null)   return;\n  if (sortFiles != null)   Arrays.sort(files,sortFiles);\n  for (  File f : files) {\n    String fname=f.getName();\n    if (f.isDirectory()) {\n      if (recurse && SourceVersion.isIdentifier(fname)) {\n        listDirectory(directory,new RelativeDirectory(subdirectory,fname),fileKinds,recurse,resultList);\n      }\n    }\n else {\n      if (isValidFile(fname,fileKinds)) {\n        JavaFileObject fe=new RegularFileObject(this,fname,new File(d,fname));\n        resultList.append(fe);\n      }\n    }\n  }\n}\n", "docstring": "insert all files in subdirectory subdirectory of directory directory which match filekinds into resultlist", "partition": "test"}
{"idx": "2548", "code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 1788) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "docstring": "unpacks the compressed character translation table .", "partition": "test"}
{"idx": "329", "code": "public void doHistory(KeyEvent e){\n  if (e.getSource() == m_Input) {\nswitch (e.getKeyCode()) {\ncase KeyEvent.VK_UP:\n      if (m_HistoryPos > 0) {\n        m_HistoryPos--;\n        String command=m_CommandHistory.elementAt(m_HistoryPos);\n        m_Input.setText(command);\n      }\n    break;\ncase KeyEvent.VK_DOWN:\n  if (m_HistoryPos < m_CommandHistory.size()) {\n    m_HistoryPos++;\n    String command=\"\";\n    if (m_HistoryPos < m_CommandHistory.size()) {\n      command=m_CommandHistory.elementAt(m_HistoryPos);\n    }\n    m_Input.setText(command);\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n}\n", "docstring": "changes the currently displayed command line when certain keys are pressed . the up arrow moves back through history entries and the down arrow moves forward through history entries .", "partition": "test"}
{"idx": "3049", "code": "public final boolean check_trace(Polyline p_polyline,int p_half_width,int p_layer,NetNosList p_net_no_arr,int p_clearance_class_no,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_max_spring_over_recursion_depth){\n  AwtreeShapeSearch search_tree=search_tree_manager.get_default_tree();\n  int compensated_half_width=p_half_width + search_tree.get_clearance_compensation(p_clearance_class_no,p_layer);\n  ArrayList<ShapeTile> trace_shapes=p_polyline.offset_shapes(compensated_half_width,0,p_polyline.corner_count());\n  for (int index=0; index < trace_shapes.size(); ++index) {\n    ShapeTile curr_trace_shape=trace_shapes.get(index);\n    BrdFromSide from_side=new BrdFromSide(p_polyline,index + 1,curr_trace_shape);\n    boolean check_shove_ok=shove_trace_algo.shove_trace_check(curr_trace_shape,from_side,null,p_layer,p_net_no_arr,p_clearance_class_no,p_max_recursion_depth,p_max_via_recursion_depth,p_max_spring_over_recursion_depth,null);\n    if (!check_shove_ok)     return false;\n  }\n  return true;\n}\n", "docstring": "checks , if a trace polyline with the input parameters can be inserted while shoving aside obstacle traces and vias .", "partition": "test"}
{"idx": "1747", "code": "private void markRemovedDefaultSessionToken(String site,String token){\n  if (removedDefaultTokens == null)   removedDefaultTokens=new HashMap<>(1);\n  HashSet<String> removedSet=removedDefaultTokens.get(site);\n  if (removedSet == null) {\n    removedSet=new HashSet<>(1);\n    removedDefaultTokens.put(site,removedSet);\n  }\n  removedSet.add(token);\n}\n", "docstring": "marks a default session token as removed for a particular site .", "partition": "test"}
{"idx": "982", "code": "static Map<TargetType,List<TypeCompound>> partitionByTargetType(Collection<TypeCompound> annos,List<TypeCompound> unmatched,TargetType... targetTypes){\n  final Map<TargetType,List<TypeCompound>> targetTypeToAnnos=new HashMap<>();\n  for (  TargetType targetType : targetTypes) {\n    targetTypeToAnnos.put(targetType,new ArrayList<TypeCompound>(10));\n  }\n  for (  final TypeCompound anno : annos) {\n    final List<TypeCompound> annoSet=targetTypeToAnnos.get(anno.getPosition().type);\n    if (annoSet != null) {\n      annoSet.add(anno);\n    }\n else     if (unmatched != null) {\n      unmatched.add(anno);\n    }\n  }\n  return targetTypeToAnnos;\n}\n", "docstring": "use a map to partition annotations with the given targettypes into lists , where each target type is a key in the output map . any annotation that does not have one of these target types will be added to unmatched", "partition": "test"}
{"idx": "1446", "code": "private MethodDescriptor[] sortMethodDescriptors(MethodDescriptor[] methodDescriptors){\n  return methodSorter != null ? methodSorter.sortMethodDescriptors(methodDescriptors) : methodDescriptors;\n}\n", "docstring": "as of this writing , this is only used for testing if method order really doesn \"'\" t mater .", "partition": "test"}
{"idx": "347", "code": "protected static Boolean lock(String serviceName,Object name){\n  DistributedLockService service=DistributedLockService.getServiceNamed(serviceName);\n  boolean locked=service.lock(name,1000,-1);\n  return Boolean.valueOf(locked);\n}\n", "docstring": "accessed via reflection . do not remove", "partition": "test"}
{"idx": "173", "code": "void pushInt(int i){\nswitch (i) {\ncase -1:\n    mv.visitInsn(ICONST_M1);\n  return;\ncase 0:\nmv.visitInsn(ICONST_0);\nreturn;\ncase 1:\nmv.visitInsn(ICONST_1);\nreturn;\ncase 2:\nmv.visitInsn(ICONST_2);\nreturn;\ncase 3:\nmv.visitInsn(ICONST_3);\nreturn;\ncase 4:\nmv.visitInsn(ICONST_4);\nreturn;\ncase 5:\nmv.visitInsn(ICONST_5);\nreturn;\n}\nif (i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {\nmv.visitIntInsn(BIPUSH,i);\nreturn;\n}\nif (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {\nmv.visitIntInsn(SIPUSH,i);\nreturn;\n}\nmv.visitLdcInsn(Integer.valueOf(i));\n}\n", "docstring": "push i onto our operand stack", "partition": "test"}
{"idx": "1484", "code": "protected int mapDragOperationFromModifiers(MouseEvent e){\n  int mods=e.getModifiersEx();\n  int btns=mods & ButtonMask;\n  if (!(btns == InputEvent.BUTTON1_DOWN_MASK || btns == InputEvent.BUTTON2_DOWN_MASK)) {\n    return DnDConstants.ACTION_NONE;\n  }\n  return SunDragSourceContextPeer.convertModifiersToDropAction(mods,getSourceActions());\n}\n", "docstring": "determine the drop action from the event", "partition": "test"}
{"idx": "3038", "code": "@Override public void panDomainAxes(double panRange,PlotRenderingInfo info,Point2D source){\n  XYPlot subplot=findSubplot(info,source);\n  if (subplot == null) {\n    return;\n  }\n  if (!subplot.isDomainPannable()) {\n    return;\n  }\n  PlotRenderingInfo subplotInfo=info.getSubplotInfo(info.getSubplotIndex(source));\n  if (subplotInfo == null) {\n    return;\n  }\n  for (int i=0; i < subplot.getDomainAxisCount(); i++) {\n    ValueAxis domainAxis=subplot.getDomainAxis(i);\n    if (domainAxis != null) {\n      domainAxis.pan(panRange);\n    }\n  }\n}\n", "docstring": "pans all domain axes by the specified percentage .", "partition": "test"}
{"idx": "1790", "code": "static Object instantiate(Class<?> sibling,String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n  ClassLoader cl=sibling.getClassLoader();\n  Class<?> cls=ClassFinder.findClass(className,cl);\n  return cls.newInstance();\n}\n", "docstring": "try to create an instance of a named class . first try the classloader of \" sibling \" , then try the system classloader then the class loader of the current thread .", "partition": "test"}
{"idx": "358", "code": "public static void checkFinite(final double[] val) throws MathIllegalArgumentException {\n  for (int i=0; i < val.length; i++) {\n    final double x=val[i];\n    if (Double.isInfinite(x) || Double.isNaN(x)) {\n      throw new MathIllegalArgumentException(LocalizedCoreFormats.NOT_FINITE_NUMBER,x);\n    }\n  }\n}\n", "docstring": "check that all the elements are real numbers .", "partition": "test"}
{"idx": "4134", "code": "public static void putLongVolatile(Object obj,long off,long val){\n  UNSAFE.putLongVolatile(obj,off,val);\n}\n", "docstring": "stores long value with volatile semantic .", "partition": "test"}
{"idx": "1888", "code": "public static boolean installNormal(Context context,String filePath){\n  Intent i=new Intent(Intent.ACTION_VIEW);\n  File file=new File(filePath);\n  if (!file.exists() || !file.isFile() || file.length() <= 0) {\n    return false;\n  }\n  i.setDataAndType(Uri.parse(\"file://\" + filePath),\"application/vnd.android.package-archive\");\n  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  context.startActivity(i);\n  return true;\n}\n", "docstring": "install package normal by system intent", "partition": "test"}
{"idx": "155", "code": "public boolean hasSingleElement(){\n  return mSelectedWidgets.size() == 1;\n}\n", "docstring": "check if the selection has a single element", "partition": "test"}
{"idx": "2243", "code": "public Photo(File d,File f) throws IOException, NumberFormatException {\n  ExtendedExifInterface exif=new ExtendedExifInterface(f.toString());\n  String lonStr=exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\n  if (lonStr == null) {\n    throw new IOException(\"No EXIF tag\");\n  }\n  float lonf=convertToDegree(lonStr);\n  String lonRef=exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF);\n  if (lonRef != null && !lonRef.equals(\"E\")) {\n    lonf=-lonf;\n  }\n  float latf=convertToDegree(exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE));\n  String latRef=exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE_REF);\n  if (latRef != null && !latRef.equals(\"N\")) {\n    latf=-latf;\n  }\n  lat=(int)(latf * 1E7d);\n  lon=(int)(lonf * 1E7d);\n  Log.d(\"Photo\",\"lat: \" + lat + \" lon: \"+ lon);\n  ref=d.getAbsolutePath() + \"/\" + f.getName();\n  String dir=exif.getAttribute(ExtendedExifInterface.TAG_GPS_IMG_DIRECTION);\n  if (dir != null) {\n    direction=(int)Double.parseDouble(dir);\n    directionRef=exif.getAttribute(ExtendedExifInterface.TAG_GPS_IMG_DIRECTION_REF);\n    Log.d(\"Photo\",\"dir \" + dir + \" direction \"+ direction+ \" ref \"+ directionRef);\n  }\n}\n", "docstring": "create a bug from an osb gpx xml wpt element .", "partition": "test"}
{"idx": "3203", "code": "private Config(){\n  throw new AssertionError(\"com.sun.jini.config.Config cannot be instantiated\");\n}\n", "docstring": "this class cannot be instantiated .", "partition": "test"}
{"idx": "3265", "code": "public Edge(S src,Symbol symbol,S dest){\n  this.src=src;\n  this.symbol=symbol;\n  this.dest=dest;\n  this.srcItem=src.getFirstItem();\n  this.hashCache=calcHashCode();\n}\n", "docstring": "edge which leads to another non - accepting state .", "partition": "test"}
{"idx": "2402", "code": "public static final void writeBooleanArrayXml(boolean[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"boolean-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  for (int i=0; i < N; i++) {\n    out.startTag(null,\"item\");\n    out.attribute(null,\"value\",Boolean.toString(val[i]));\n    out.endTag(null,\"item\");\n  }\n  out.endTag(null,\"boolean-array\");\n}\n", "docstring": "flatten a boolean [ ", "partition": "test"}
{"idx": "1063", "code": "public static void equals(Object object1,Object object2){\n  checkAssertion(object1.equals(object2),null);\n}\n", "docstring": "asserts that given object1 equals object2 .", "partition": "test"}
{"idx": "344", "code": "private synchronized void block(boolean tf){\n  if (tf) {\n    try {\n      if (m_ioThread.isAlive() && m_state != IDLE) {\n        wait();\n      }\n    }\n catch (    InterruptedException ex) {\n    }\n  }\n else {\n    notifyAll();\n  }\n}\n", "docstring": "function used to stop code that calls accepttrainingset . this is needed as classifier construction is performed inside a separate thread of execution .", "partition": "test"}
{"idx": "1178", "code": "public boolean isFlat(){\n  return TYPE_FLAT.equals(getType());\n}\n", "docstring": "flat background type ( default )", "partition": "test"}
{"idx": "2177", "code": "public static Number multiply(Character left,Character right){\n  return multiply(Integer.valueOf(left),right);\n}\n", "docstring": "multiply two characters . the ordinal values of the characters are used in the multiplication ( the ordinal value is the unicode value which for simple character sets is the ascii value ) .", "partition": "test"}
{"idx": "2083", "code": "public SeaGlassTitlePane(JRootPane rootPane,SeaGlassRootPaneUI ui){\n  this.rootPane=rootPane;\n  this.rootPaneUI=ui;\n  rootParent=(RootPaneContainer)rootPane.getParent();\n  installTitlePane();\n}\n", "docstring": "creates a new seaglasstitlepane object .", "partition": "test"}
{"idx": "2658", "code": "public List<FileStatus> browse(String filePath) throws Exception {\n  LOG.info(\"HDFS File Path   :  \" + filePath + \"   and EndPoint  : \"+ hdfsEndPoint);\n  FileSystem hdfsFileSystem=null;\n  FileStatus[] listStatus;\n  try {\n    Configuration config=createConfig();\n    hdfsFileSystem=getFileSystem(config);\n    Path path=new Path(filePath);\n    listStatus=hdfsFileSystem.listStatus(path);\n  }\n catch (  Exception ex) {\n    LOG.error(\" Exception when browsing files for the path \" + filePath,ex.getMessage());\n    throw new Exception(\" Exception When browsing Files in HDFS .. Message :  \" + ex.getMessage());\n  }\n finally {\n    if (hdfsFileSystem != null)     hdfsFileSystem.close();\n  }\n  return Arrays.asList(listStatus);\n}\n", "docstring": "brows the files for the specific path", "partition": "test"}
{"idx": "2649", "code": "@Override public void requestResources(SamzaResourceRequest resourceRequest){\n  final int DEFAULT_PRIORITY=0;\n  log.info(\"Requesting resources on  \" + resourceRequest.getPreferredHost() + \" for container \"+ resourceRequest.getContainerID());\n  int memoryMb=resourceRequest.getMemoryMB();\n  int cpuCores=resourceRequest.getNumCores();\n  String containerLabel=yarnConfig.getContainerLabel();\n  String preferredHost=resourceRequest.getPreferredHost();\n  Resource capability=Resource.newInstance(memoryMb,cpuCores);\n  Priority priority=Priority.newInstance(DEFAULT_PRIORITY);\n  AMRMClient.ContainerRequest issuedRequest;\n  if (preferredHost.equals(\"ANY_HOST\")) {\n    log.info(\"Making a request for ANY_HOST \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,null,null,priority,true,containerLabel);\n  }\n else {\n    log.info(\"Making a preferred host request on \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,new String[]{preferredHost},null,priority,true,containerLabel);\n  }\nsynchronized (lock) {\n    requestsMap.put(resourceRequest,issuedRequest);\n    amClient.addContainerRequest(issuedRequest);\n  }\n}\n", "docstring": "request resources for running container processes .", "partition": "test"}
{"idx": "3325", "code": "private String encodeProduct(){\n  StringBuffer tokens=new StringBuffer();\n  ListIterator it=productTokens.listIterator();\n  while (it.hasNext()) {\n    tokens.append((String)it.next());\n  }\n  return tokens.toString();\n}\n", "docstring": "return canonical form . pmusgrave - put a space between products ( preserves format of header )", "partition": "test"}
{"idx": "2611", "code": "protected static INaviRawModule findRawModule(final int rawModuleId,final List<INaviRawModule> rawModules){\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be positive integer\",rawModuleId);\n  Preconditions.checkNotNull(rawModules,\"IE02263: raw modules argument can not be null\");\n  for (  final INaviRawModule rawModule : rawModules) {\n    if (rawModule.getId() == rawModuleId) {\n      return rawModule;\n    }\n  }\n  throw new IllegalStateException(\"IE00160: Could not find raw module\");\n}\n", "docstring": "returns the raw module with the given id .", "partition": "test"}
{"idx": "1482", "code": "public int size(){\n  return m_sets.size();\n}\n", "docstring": "get the number of item sets .", "partition": "test"}
{"idx": "2292", "code": "private static Frame showInitialSplash(){\n  Frame splashFrame=null;\n  Image image=null;\n  URL imageURL=getChosenSplashURL();\n  if (imageURL != null) {\n    try {\n      image=ImageIO.read(imageURL);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n    if (image != null) {\n      splashFrame=AWTSplashWindow.splash(image);\n    }\n  }\n  return splashFrame;\n}\n", "docstring": "shows the initial splash window .", "partition": "test"}
{"idx": "921", "code": "private void drawBackground(final Graphics g){\n  g.setColor(m_bgColorOffset);\n  g.fillRect(-m_firstColumn * m_charWidth,0,m_offsetViewWidth,getHeight());\n}\n", "docstring": "draws the background of the view .", "partition": "test"}
{"idx": "2862", "code": "public boolean similarTo(Object o){\n  if (o == null) {\n    return false;\n  }\n  if (!(o instanceof SemanticConcept)) {\n    return false;\n  }\n  SemanticConcept otherConcept=(SemanticConcept)o;\n  HashSet<Integer> synset_intersection=new HashSet<Integer>(this.synsets);\n  synset_intersection.retainAll(otherConcept.synsets);\n  if (!synset_intersection.isEmpty()) {\n    return true;\n  }\n  HashSet<String> concept_intersection=new HashSet<String>(this.concepts);\n  concept_intersection.retainAll(otherConcept.concepts);\n  return !concept_intersection.isEmpty();\n}\n", "docstring": "semanticconcepts are similar if they share a synset or a concept", "partition": "test"}
{"idx": "2182", "code": "public List<T> asFlatList(){\n  List<T> list=new ArrayList<T>();\n  for (int i=0; i < getRowCount(); i++) {\n    for (int j=0; j < getColumnCount(); j++) {\n      list.add(getLogicalValueAt(i,j));\n    }\n  }\n  return list;\n}\n", "docstring": "returns the contents of the table as a flat list .", "partition": "test"}
{"idx": "2120", "code": "public void startObject(int numfields){\n  notNested();\n  if (vtable == null || vtable.length < numfields)   vtable=new int[numfields];\n  vtable_in_use=numfields;\n  Arrays.fill(vtable,0,vtable_in_use,0);\n  nested=true;\n  object_start=offset();\n}\n", "docstring": "start encoding a new object in the buffer . users will not usually need to call this directly . the ` flatbuffers ` compiler will generate helper methods that call this method internally . < p > for example , using the \" monster \" code found on the", "partition": "test"}
{"idx": "2436", "code": "public boolean overlaps(String sequence,int start,int end){\n  if (start == MISSING || end == MISSING || end < start) {\n    throw new IllegalArgumentException();\n  }\n  if (!mSequence.equals(sequence)) {\n    return false;\n  }\n  if ((mEnd != MISSING && start >= mEnd) || (end <= mStart)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "test whether the specified range overlaps the current region", "partition": "test"}
{"idx": "2796", "code": "public void addFakeView(View childView){\n  childView.layout(0,0,getWidth(),childView.getMeasuredHeight());\n  views.add(childView);\n}\n", "docstring": "add a view for the dummyview to draw .", "partition": "test"}
{"idx": "73", "code": "public PatternGuardExpr(String namespace,String name,Expression[] parameters,PatternExpr guarded){\n  this(namespace,name,Arrays.asList(parameters),guarded);\n}\n", "docstring": "ctor - for use to create a pattern expression tree , without pattern child expression .", "partition": "test"}
{"idx": "849", "code": "public static Operator generateBranchPlan(AkibanInformationSchema ais,Table table){\n  final Operator indexScan=generateIndexScan(ais,table);\n  final Schema schema=SchemaCache.globalSchema(ais);\n  PrimaryKey pkey=table.getPrimaryKeyIncludingInternal();\n  IndexRowType indexType=schema.indexRowType(pkey.getIndex());\n  return generateBranchPlan(table,indexScan,indexType);\n}\n", "docstring": "scan a group starting with primary key of a table , then get all of the children ( if any ) . primary key is set as parameters to the query context . generates a plan : branch lookup index scan ( table , pk - > ? [ , ? . . . ", "partition": "test"}
{"idx": "3945", "code": "public static String toKilobytes(long bytes){\n  if (bytes < 0)   return \"? \" + GENERAL_UNIT_KILOBYTES;\n  long kbytes=bytes / 1024;\n  if ((bytes & 512) != 0 || (bytes > 0 && bytes < 1024))   kbytes++;\n  return NUMBER_FORMAT0.format(kbytes) + GENERAL_UNIT_KILOBYTES;\n}\n", "docstring": "this static method converts the passed in number of bytes into a kilobyte string grouping digits with locale - dependant thousand separator and with \" kb \" locale - dependant unit at the end .", "partition": "test"}
{"idx": "3354", "code": "protected TupleExpr selectNextTupleExpr(List<TupleExpr> expressions,Map<TupleExpr,Double> cardinalityMap,Map<TupleExpr,List<Var>> varsMap,Map<Var,Integer> varFreqMap,Set<String> boundVars){\n  TupleExpr result=null;\n  if (expressions.size() > 1) {\n    double lowestCardinality=Double.POSITIVE_INFINITY;\n    for (    TupleExpr tupleExpr : expressions) {\n      double cardinality=getTupleExprCardinality(tupleExpr,cardinalityMap,varsMap,varFreqMap,boundVars);\n      if (cardinality < lowestCardinality || result == null) {\n        lowestCardinality=cardinality;\n        result=tupleExpr;\n      }\n    }\n  }\n else {\n    result=expressions.get(0);\n  }\n  return result;\n}\n", "docstring": "selects from a list of tuple expressions the next tuple expression that should be evaluated . this method selects the tuple expression with highest number of bound variables , preferring variables that have been bound in other tuple expressions over variables with a fixed value .", "partition": "test"}
{"idx": "3993", "code": "public static String encodeToString(byte[] src){\n  if (src == null) {\n    return null;\n  }\n  if (src.length == 0) {\n    return \"\";\n  }\n  String result;\n  try {\n    result=new String(delegate.encode(src),DEFAULT_CHARSET.displayName());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new IllegalStateException(e);\n  }\n  return result;\n}\n", "docstring": "base64 - encode the given byte array to a string .", "partition": "test"}
{"idx": "3498", "code": "public static terminal find(String with_name){\n  if (with_name == null)   return null;\n else   return (terminal)_all.get(with_name);\n}\n", "docstring": "lookup a terminal by name string .", "partition": "test"}
{"idx": "2215", "code": "public void configure(){\n  if (cmdPrefix != null) {\n    prefix=cmdPrefix.split(\" \");\n  }\n}\n", "docstring": "configure the helper . this must called before executing any commands .", "partition": "test"}
{"idx": "861", "code": "@Override public void handleMouseMoved(ChartCanvas canvas,MouseEvent e){\n  if (!canvas.isTooltipEnabled()) {\n    return;\n  }\n  String text=getTooltipText(canvas,e.getX(),e.getY());\n  canvas.setTooltip(text,e.getScreenX(),e.getScreenY());\n}\n", "docstring": "handles a mouse moved event by updating the tooltip .", "partition": "test"}
{"idx": "1565", "code": "public static HttpHeaders toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders){\n  if (inHeaders.isEmpty()) {\n    return HttpHeaders.EMPTY_HEADERS;\n  }\n  final HttpHeaders out=new DefaultHttpHeaders(true,inHeaders.size());\n  toArmeria(inHeaders,out);\n  return out;\n}\n", "docstring": "converts the specified netty http / 1 headers into armeria http / 2 headers .", "partition": "test"}
{"idx": "2540", "code": "public static boolean isWindowsMe(){\n  return osName.indexOf(\"Windows\") > -1 && osVersion.equals(\"4.9\");\n}\n", "docstring": "is operating system windows me ?", "partition": "test"}
{"idx": "3298", "code": "public static String urlEncode(@Nullable String s){\n  if (s == null) {\n    return \"\";\n  }\n  try {\n    return URLEncoder.encode(s,\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new AssertionError(\"UTF-8 should be supported in every JVM\");\n  }\n}\n", "docstring": "url - encodes a nullable string , catching the useless exception that never happens .", "partition": "test"}
{"idx": "2958", "code": "public static void unregisterMBean(Class<?> mbeanInterface){\n  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();\n  try {\n    ObjectName name=generateMBeanObjectName(mbeanInterface);\n    if (mbs.isRegistered(name)) {\n      logger.info(\"Unregistering mbean: \" + name.toString());\n      mbs.unregisterMBean(name);\n    }\n else {\n      logger.warn(\"Ignoring attempt to unregister unknown mbean: \" + name.toString());\n    }\n  }\n catch (  Exception e) {\n    throw new ServerRuntimeException(\"Unable to unregister mbean: interface=\" + mbeanInterface,e);\n  }\n}\n", "docstring": "server helper method to register a jmx mbean . mbeans are registered by a combination of their mbean interface and the custom mbeanname argument . the mbeanname permits multiple mbeans to be registered under the same name .", "partition": "test"}
{"idx": "2442", "code": "public void removeStorage() throws BackupException {\n  logger.debug(\"Removing contents of storage directory: \" + dataDirSpec.getAbsolutePath());\n  processHelper.exec(\"Removing contents of storage directory\",rmCmd);\n}\n", "docstring": "clears storage in preparation for restore operation .", "partition": "test"}
{"idx": "1851", "code": "@SuppressWarnings(\"unchecked\") public PropagationImp(Stack<CompositeTransaction> lineage,boolean serial,long timeout){\n  serial_=serial;\n  lineage_=(Stack<CompositeTransaction>)lineage.clone();\n  timeout_=timeout;\n}\n", "docstring": "construct a new instance .", "partition": "test"}
{"idx": "3591", "code": "public static CLContext createContextFromCurrentGL(){\n  RuntimeException first=null;\n  for (  CLPlatform platform : listPlatforms()) {\n    try {\n      CLContext ctx=platform.createContextFromCurrentGL();\n      if (ctx != null)       return ctx;\n    }\n catch (    RuntimeException ex) {\n      if (first == null)       first=ex;\n    }\n  }\n  throw new RuntimeException(\"Failed to create an OpenCL context based on the current OpenGL context\",first);\n}\n", "docstring": "creates an opencl context able to share entities with the current opengl context .", "partition": "test"}
{"idx": "3167", "code": "protected String generateSectionLabel(PieDataset dataset,Comparable key){\n  String result=null;\n  if (dataset != null) {\n    Object[] items=createItemArray(dataset,key);\n    result=MessageFormat.format(this.labelFormat,items);\n  }\n  return result;\n}\n", "docstring": "generates a label for a pie section .", "partition": "test"}
{"idx": "2289", "code": "public static double info(int counts[]){\n  int total=0;\n  double x=0;\n  for (  int count : counts) {\n    x-=xlogx(count);\n    total+=count;\n  }\n  return x + xlogx(total);\n}\n", "docstring": "computes entropy for an array of integers .", "partition": "test"}
{"idx": "4202", "code": "public void createNote(Note note){\n  SQLiteDatabase db=getWritableDatabase();\n  String spannableAsHtml=Html.toHtml(note.getSpannable());\n  String date=dt.format(new Date());\n  ContentValues values=new ContentValues();\n  values.put(KEY_SPANNABLE_NOTE,spannableAsHtml);\n  values.put(KEY_NOTE_TITLE,note.getTitle());\n  values.put(KEY_IMAGE,BitmapConverter.getBytes(note.getImage()));\n  values.put(KEY_DATE_UPDATED,date);\n  db.insert(TABLE_NOTES,null,values);\n  db.close();\n}\n", "docstring": "method used to put note object into database", "partition": "test"}
{"idx": "1963", "code": "public boolean renameFile(File oldFile,File newFile){\nsynchronized (fileCache) {\n    if (oldFile.renameTo(newFile)) {\n      validateFileCache();\n      return true;\n    }\n    return false;\n  }\n}\n", "docstring": "renames a file in the underlying file system .", "partition": "test"}
{"idx": "503", "code": "public static double angle(Coordinate p0,Coordinate p1){\n  double dx=p1.x - p0.x;\n  double dy=p1.y - p0.y;\n  return Math.atan2(dy,dx);\n}\n", "docstring": "returns the angle of the vector from p0 to p1 , relative to the positive x - axis . the angle is normalized to be in the range [ - pi , pi ", "partition": "test"}
{"idx": "3981", "code": "private static void writeFile(File file,List<String> lines) throws IOException {\n  if (!file.exists())   file.createNewFile();\n  FileWriter fw=new FileWriter(file);\n  BufferedWriter Bw=new BufferedWriter(fw);\n  PrintWriter pw=new PrintWriter(Bw);\n  for (  String line : lines)   pw.println(line);\n  Bw.close();\n  fw.close();\n  pw.close();\n}\n", "docstring": "writes the lines given in input in file .", "partition": "test"}
{"idx": "3741", "code": "private int composeComponent(int a,int b){\n  return Math.min(b + b * a / DIMMING_FACTOR,0xff);\n}\n", "docstring": "apply composition to an individual color component of a pixel .", "partition": "test"}
{"idx": "1217", "code": "boolean handleRemoteCanRebalance(long size){\n  return false;\n}\n", "docstring": "checks if this partitionedregiondatastore has the capacity to handle the rebalancing size .", "partition": "test"}
{"idx": "1091", "code": "protected MediaType selectMediaType(ServerWebExchange exchange,List<MediaType> producibleTypes){\n  List<MediaType> acceptableTypes=getAcceptableTypes(exchange);\n  producibleTypes=getProducibleTypes(exchange,producibleTypes);\n  Set<MediaType> compatibleMediaTypes=new LinkedHashSet<>();\n  for (  MediaType acceptable : acceptableTypes) {\n    for (    MediaType producible : producibleTypes) {\n      if (acceptable.isCompatibleWith(producible)) {\n        compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable,producible));\n      }\n    }\n  }\n  List<MediaType> result=new ArrayList<>(compatibleMediaTypes);\n  MediaType.sortBySpecificityAndQuality(result);\n  for (  MediaType mediaType : compatibleMediaTypes) {\n    if (mediaType.isConcrete()) {\n      return mediaType;\n    }\n else     if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n      return MediaType.APPLICATION_OCTET_STREAM;\n    }\n  }\n  return null;\n}\n", "docstring": "select the best media type for the current request through a content negotiation algorithm .", "partition": "test"}
{"idx": "1520", "code": "public static URL findResourceBase(String baseResource,ClassLoader loader){\n  URL url=loader.getResource(baseResource);\n  return findResourceBase(url,baseResource);\n}\n", "docstring": "find the classpath url for a specific classpath resource . the classpath url is extracted from loader . getresource ( ) using the baseresource .", "partition": "test"}
{"idx": "2297", "code": "private void selectAttributeSetInstance(){\n  int m_warehouse_id=getM_Warehouse_ID();\n  int m_product_id=getM_Product_ID();\n  if (m_product_id <= 0)   return;\n  MProduct product=MProduct.get(getCtx(),m_product_id);\n  MWarehouse wh=MWarehouse.get(getCtx(),m_warehouse_id);\n  String title=product.get_Translation(MProduct.COLUMNNAME_Name) + \" - \" + wh.get_Translation(MWarehouse.COLUMNNAME_Name);\n  PAttributeInstance pai=new PAttributeInstance(m_frame,title,m_warehouse_id,0,m_product_id,0);\n  if (pai.getM_AttributeSetInstance_ID() != -1) {\n    fAttrSetInstance_ID.setText(pai.getM_AttributeSetInstanceName());\n    fAttrSetInstance_ID.setValue(new Integer(pai.getM_AttributeSetInstance_ID()));\n  }\n else {\n    fAttrSetInstance_ID.setValue(Integer.valueOf(0));\n  }\n}\n", "docstring": "filter by attribute set instance", "partition": "test"}
{"idx": "1049", "code": "public final int first_common_layer(BrdItem p_other){\n  int max_first_layer=Math.max(first_layer(),p_other.first_layer());\n  int min_last_layer=Math.min(last_layer(),p_other.last_layer());\n  if (max_first_layer > min_last_layer) {\n    return -1;\n  }\n  return max_first_layer;\n}\n", "docstring": "returns the first layer , where both this item and p_other have a shape . returns - 1 , if such a layer does not exisr .", "partition": "test"}
{"idx": "3383", "code": "public void deleteQuota(String id) throws IsilonException {\n  delete(_baseUrl.resolve(URI_QUOTAS),id,\"quota\");\n}\n", "docstring": "delete a smart quota", "partition": "test"}
{"idx": "4197", "code": "public boolean loadLines(){\n  boolean result=false;\n  try {\n    m_parser.parse(new InputSource(m_reader),this);\n    result=true;\n    m_success=true;\n  }\n catch (  SAXException e) {\n    m_errorMessage=\"ErrorParsingData\";\n    m_errorDescription=e.getMessage();\n  }\ncatch (  IOException e) {\n    m_errorMessage=\"ErrorReadingData\";\n    m_errorDescription=e.getMessage();\n  }\n  return result;\n}\n", "docstring": "read statementlines from inputstream .", "partition": "test"}
{"idx": "1491", "code": "public void addCommand(Command cmd,int offset){\n  menuBar.addCommand(cmd,offset);\n}\n", "docstring": "adds a command to the menu bar softkeys or into the menu dialog , this version of add allows us to place a command in an arbitrary location . this allows us to force a command into the softkeys when order of command addition can \"'\" t be changed .", "partition": "test"}
{"idx": "2908", "code": "public String sel(){\n  return mSelection.toString();\n}\n", "docstring": "returns the selection produced by this object .", "partition": "test"}
{"idx": "2105", "code": "private void initXMLTree() throws Exception {\n  updateFilteredTokens();\n  ArrayList elements=getElements(getFilteredTokens());\n  if (elements.size() > 1) {\n    throw new Exception(\"More than one root elements encountered\");\n  }\n  setRootElement((XMLElement)elements.get(0));\n}\n", "docstring": "creats an in - memory xml tree based on the parsed tokens in this document .", "partition": "test"}
{"idx": "3180", "code": "static void incrementKeepAliveCount(){\nsynchronized (keepAliveLock) {\n    keepAliveCount++;\n    if (reaper == null) {\n      reaper=AccessController.doPrivileged(new NewThreadAction(new Reaper(),\"Reaper\",false));\n      reaper.start();\n    }\n    if (gcLatencyRequest == null) {\n      gcLatencyRequest=GC.requestLatency(gcInterval);\n    }\n  }\n}\n", "docstring": "increments the \" keep - alive count \" . the \" keep - alive count \" is the number of non - permanent remote objects that are either in the object table or still have calls in progress . therefore , this method should be invoked exactly once for every non - permanent remote object exported ( a remote object must be exported before it can have any calls in progress ) . the vm is \" kept alive \" while the keep - alive count is greater than zero ; this is accomplished by keeping a non - daemon thread running . because non - permanent objects are those that can be garbage collected while exported , and thus those for which the \" reaper \" thread operates , the reaper thread also serves as the non - daemon vm keep - alive thread ; a new reaper thread is created if necessary .", "partition": "test"}
{"idx": "994", "code": "public static String parseVolumeHostDirectory(String volume){\n  if (StringUtils.isEmpty(volume)) {\n    return volume;\n  }\n  if (!volume.contains(HOST_CONTAINER_DIR_DELIMITER)) {\n    return volume;\n  }\n  String[] hostContainerDir=volume.split(HOST_CONTAINER_DIR_DELIMITER);\n  if (hostContainerDir.length != 2) {\n    throw new IllegalArgumentException(\"Invalid volume directory.\");\n  }\n  String hostDir=hostContainerDir[0];\n  return hostDir;\n}\n", "docstring": "parses volume host directory only .", "partition": "test"}
{"idx": "2204", "code": "public void add(Character character){\n  elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n}\n", "docstring": "adds the specified character to self .", "partition": "test"}
{"idx": "2571", "code": "@Deprecated public void pointToData(Data o) throws FitsException {\n  o.fillHeader(this);\n}\n", "docstring": "create a header which points to the given data object .", "partition": "test"}
{"idx": "2307", "code": "public TraceGraph(Collection<Span> spans){\n  this.spansByParent=new SpansByParent(spans);\n  this.spansByTracerId=new SpansByTracerId(spans);\n}\n", "docstring": "create a new tracegraph", "partition": "test"}
{"idx": "2020", "code": "public static Sentence make(final Connective connective,final Sentence... children2){\n  return make(connective,Arrays.asList(children2));\n}\n", "docstring": "conjoin a list of sentences . for convenience , these are allowed to be null ( null sentences are ignored from the conjunction . ) there must be at least one non - null argument .", "partition": "test"}
{"idx": "4190", "code": "public boolean isMultipleAllowed(String frameID){\n  return multipleFrames.contains(frameID);\n}\n", "docstring": "are multiple occurrences of frame allowed", "partition": "test"}
{"idx": "2799", "code": "@SuppressWarnings(\"unchecked\") public Promise<Result,Progress> resolve(Result result){\n  List<DoneCallback<Result>> doneCallbacks;\n  List<AlwaysCallback> alwaysCallbacks;\nsynchronized (this) {\n    validateInPendingState();\n    mState=STATE_RESOLVED;\n    printStateChanged(\"RESOLVED\");\n    mResult=result;\n    doneCallbacks=mCallbacks.cloneDoneCallbacks();\n    alwaysCallbacks=mCallbacks.cloneAlwaysCallbacks();\n    clearCallbacks();\n  }\n  if (doneCallbacks.size() > 0 || alwaysCallbacks.size() > 0) {\n    triggerAllDones(doneCallbacks);\n    triggerAllAlways(alwaysCallbacks);\n  }\n  return this;\n}\n", "docstring": "resolves the promise , triggers any done / always callbacks", "partition": "test"}
{"idx": "2967", "code": "void decodeAttributeBody(byte[] attributeValue,char offset,char length) throws StunException {\n  realm=new byte[length];\n  System.arraycopy(attributeValue,offset,realm,0,length);\n}\n", "docstring": "copies the value of the realm attribute from the specified attributevalue .", "partition": "test"}
{"idx": "2673", "code": "private static void generateFiles(){\n  String[] classNames;\n  ResourceBundle rules, info;\n  info=ResourceBundle.getBundle(\"sun.text.resources.BreakIteratorInfo\",new Locale(language,country,valiant),BreakIteratorRBControl.INSTANCE);\n  classNames=info.getStringArray(\"BreakIteratorClasses\");\n  rules=ResourceBundle.getBundle(\"sun.text.resources.BreakIteratorRules\",new Locale(language,country,valiant),BreakIteratorRBControl.INSTANCE);\n  if (info.containsKey(\"CharacterData\")) {\n    generateDataFile(info.getString(\"CharacterData\"),rules.getString(\"CharacterBreakRules\"),classNames[0]);\n  }\n  if (info.containsKey(\"WordData\")) {\n    generateDataFile(info.getString(\"WordData\"),rules.getString(\"WordBreakRules\"),classNames[1]);\n  }\n  if (info.containsKey(\"LineData\")) {\n    generateDataFile(info.getString(\"LineData\"),rules.getString(\"LineBreakRules\"),classNames[2]);\n  }\n  if (info.containsKey(\"SentenceData\")) {\n    generateDataFile(info.getString(\"SentenceData\"),rules.getString(\"SentenceBreakRules\"),classNames[3]);\n  }\n}\n", "docstring": "generate data files whose names are included in sun . text . resources . breakiteratorinfo + < localename >", "partition": "test"}
{"idx": "2943", "code": "public static double length(double x,double y,double z){\n  return Math.sqrt(x * x + y * y + z * z);\n}\n", "docstring": "computes the length of a vector", "partition": "test"}
{"idx": "2194", "code": "public LayerGraphicWarehouseSupport(){\n  initDrawingAttributes();\n  graphics=new OMGraphicList();\n  graphics.setTraverseMode(OMGraphicList.LAST_ADDED_ON_TOP);\n}\n", "docstring": "construct an object , initializes graphiclist", "partition": "test"}
{"idx": "2819", "code": "private OpenReplicatorManagerMBean createInternalService(String serviceName) throws ReplicatorException {\n  logger.info(\"Starting replication service: name=\" + serviceName);\n  try {\n    OpenReplicatorManager orm=new OpenReplicatorManager(serviceName);\n    orm.setRmiHost(managerRMIHost);\n    orm.setRmiPort(managerRMIPort);\n    orm.setHostTimeZone(hostTimeZone);\n    orm.setReplicatorTimeZone(replicatorTimeZone);\n    orm.advertiseInternal();\n    orm.setSecurityInfo(this.securityInfo);\n    return (OpenReplicatorManagerMBean)orm;\n  }\n catch (  Exception e) {\n    throw new ReplicatorException(String.format(\"Unable to instantiate replication service \\'%s\\'\",serviceName),e);\n  }\n}\n", "docstring": "creates a replication service that will run as a thread internal to the replicationservicemanager .", "partition": "test"}
{"idx": "1705", "code": "@Override public synchronized void parse(Reader reader,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (reader == null) {\n    throw new IllegalArgumentException(\"Reader cannot be \\'null\\'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be \\'null\\'\");\n  }\n  InputSource inputSource=new InputSource(reader);\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}\n", "docstring": "parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .", "partition": "test"}
{"idx": "690", "code": "public SidedPlane(final Vector p,final boolean onSide,final Vector A,final Vector B){\n  super(A,B);\n  sigNum=onSide ? Math.signum(evaluate(p)) : -Math.signum(evaluate(p));\n  if (sigNum == 0.0)   throw new IllegalArgumentException(\"Cannot determine sidedness because check point is on plane.\");\n}\n", "docstring": "construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .", "partition": "test"}
{"idx": "518", "code": "protected void notifyPropertyChangeListener(String property,Object oldValue,Object newValue){\n  Set<PropertyChangeListener> v;\nsynchronized (this) {\n    v=new HashSet<>(listeners);\n  }\n  for (  PropertyChangeListener listener : v) {\n    listener.propertyChange(new PropertyChangeEvent(this,property,oldValue,newValue));\n  }\n}\n", "docstring": "trigger the notification of all propertychangelisteners", "partition": "test"}
{"idx": "2432", "code": "public SerialMessage(byte[] a){\n  super(String.valueOf(a));\n  setBinary(true);\n}\n", "docstring": "this ctor interprets the byte array as a sequence of characters to send .", "partition": "test"}
{"idx": "3630", "code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeObject(conservativeApproximation);\n}\n", "docstring": "calls the super method and writes the conservative approximation of the knn distances of this entry to the specified stream .", "partition": "test"}
{"idx": "2451", "code": "@RequiresPermission(Manifest.permission.CAMERA) public CameraSource start() throws IOException {\nsynchronized (mCameraLock) {\n    if (mCamera != null) {\n      return this;\n    }\n    mCamera=createCamera();\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n      mDummySurfaceTexture=new SurfaceTexture(DUMMY_TEXTURE_NAME);\n      mCamera.setPreviewTexture(mDummySurfaceTexture);\n    }\n else {\n      mDummySurfaceView=new SurfaceView(mContext);\n      mCamera.setPreviewDisplay(mDummySurfaceView.getHolder());\n    }\n    mCamera.startPreview();\n    isSafeToTakePicture=true;\n    mProcessingThread=new Thread(mFrameProcessor);\n    mFrameProcessor.setActive(true);\n    mProcessingThread.start();\n  }\n  return this;\n}\n", "docstring": "opens the camera and starts sending preview frames to the underlying detector . the preview frames are not displayed .", "partition": "test"}
{"idx": "3004", "code": "public static String decodeBCD(final short bcd){\n  return String.format(\"%x.%02x\",(bcd & 0xFF00) >> 8,bcd & 0x00FF);\n}\n", "docstring": "decodes a binary - coded decimal into a string and returns it .", "partition": "test"}
{"idx": "3136", "code": "public static void addActivityListener(ActivityListener listener){\n  if (listener != null) {\n    startTracking();\n    listeners.add(listener);\n  }\n}\n", "docstring": "adds a listener that will be informed one time about user activity , then removed .", "partition": "test"}
{"idx": "1489", "code": "private void validateDynamicAttribute(Set dynamicSet) throws PolicyException {\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"entering with dynamicSet=\" + dynamicSet);\n  }\n  responseAttrNames=new HashSet();\n  repoAttrNames=new HashSet();\n  responseAttrToRepoAttr=new HashMap();\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"valid dynamic attributes:\" + validDynamicAttrNames);\n  }\n  Set dynamicAttrs=((Set)properties.get(DYNAMIC_ATTRIBUTE));\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"selected dynamic attributes:\" + dynamicAttrs);\n  }\n  Iterator dynamicAttrsIter=dynamicAttrs.iterator();\n  while (dynamicAttrsIter.hasNext()) {\n    String attr=(String)dynamicAttrsIter.next();\n    if (!validDynamicAttrNames.contains(attr)) {\n      if (DEBUG.warningEnabled()) {\n        DEBUG.warning(\"IDReporesponseProvider.\" + \"validateDynamicAttribute():Invalid dynamic property \" + \"encountered:\"+ attr);\n      }\n      continue;\n    }\n    String[] attrNames=parseDynamicAttrName(attr);\n    String responseAttrName=attrNames[0];\n    String repoAttrName=attrNames[1];\n    responseAttrNames.add(responseAttrName);\n    repoAttrNames.add(repoAttrName);\n    addToResponseAttrToRepoAttrMap(responseAttrName,repoAttrName);\n    if (DEBUG.messageEnabled()) {\n      DEBUG.message(\"IDRepoResponseProvider.\" + \"validateDynamicAttribute():\" + \"responseAttrName=\" + responseAttrName + \", repoAttrName=\"+ repoAttrName);\n    }\n  }\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"responseAttrToRepoAttr=\" + responseAttrToRepoAttr);\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"returning\");\n  }\n}\n", "docstring": "this method validates the dynamic_attribute data for format and caches parsed responseattrnames , repoattrnames strings in the set need to be in \" responseattr = repoattr \" format else , throws policyexception", "partition": "test"}
{"idx": "323", "code": "private int skipFromPeekBuffer(int length){\n  int bytesSkipped=Math.min(peekBufferLength,length);\n  updatePeekBuffer(bytesSkipped);\n  return bytesSkipped;\n}\n", "docstring": "skips from the peek buffer .", "partition": "test"}
{"idx": "3014", "code": "@NotNull public static Map<RadComponent,List<RadComponent>> groupSiblings(@NotNull List<? extends RadComponent> components){\n  Map<RadComponent,List<RadComponent>> siblingLists=new HashMap<RadComponent,List<RadComponent>>();\n  if (components.isEmpty()) {\n    return siblingLists;\n  }\n  if (components.size() == 1) {\n    RadComponent component=components.get(0);\n    siblingLists.put(component.getParent(),Collections.singletonList(component));\n    return siblingLists;\n  }\n  for (  RadComponent component : components) {\n    RadComponent parent=component.getParent();\n    List<RadComponent> children=siblingLists.get(parent);\n    if (children == null) {\n      children=new ArrayList<RadComponent>();\n      siblingLists.put(parent,children);\n    }\n    children.add(component);\n  }\n  return siblingLists;\n}\n", "docstring": "partitions the given list of components into a map where each value is a list of siblings , in the same order as in the original list , and where the keys are the parents ( or null for the components that do not have a parent ) . < p / > the value lists will never be empty . the parent key will be null for components without parents .", "partition": "test"}
{"idx": "1916", "code": "private void deleteOldTemp(File fileCfg){\n  BufferedReader reader=null;\n  try {\n    int count=0;\n    reader=new BufferedReader(new FileReader(fileCfg));\n    String sLine;\n    while ((sLine=reader.readLine()) != null) {\n      File file=new File(sLine);\n      if (!file.exists()) {\n        continue;\n      }\n      if (file.delete()) {\n        count++;\n      }\n else {\n        hsDeleteOnExit.add(file);\n      }\n    }\n    logDebug(LogArea.CONFIG,\"Deleted %d old temp files listed in %s\",count,fileCfg.getAbsolutePath());\n  }\n catch (  IOException e) {\n  }\n finally {\n    if (reader != null) {\n      try {\n        reader.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n}\n", "docstring": "deletes temporary files listed in the file . the method is called on shutdown ( ) .", "partition": "test"}
{"idx": "1602", "code": "public IpcSharedMemorySpace(String tokFileName,int writerPid,int readerPid,int size,boolean reader,IgniteLogger parent) throws IgniteCheckedException {\n  assert size > 0 : \"Size cannot be less than 1 byte\";\n  log=parent.getLogger(IpcSharedMemorySpace.class);\n  opSize=size;\n  shmemPtr=IpcSharedMemoryUtils.allocateSystemResources(tokFileName,size,DEBUG && log.isDebugEnabled());\n  shmemId=IpcSharedMemoryUtils.sharedMemoryId(shmemPtr);\n  semId=IpcSharedMemoryUtils.semaphoreId(shmemPtr);\n  isReader=reader;\n  this.tokFileName=tokFileName;\n  this.readerPid=readerPid;\n  this.writerPid=writerPid;\n  if (DEBUG && log.isDebugEnabled())   log.debug(\"Shared memory space has been created: \" + this);\n}\n", "docstring": "this will allocate system resources for the space .", "partition": "test"}
{"idx": "1572", "code": "private synchronized void loadTrustManager(){\n  try {\n    TrustManagerFactory tmf=TrustManagerFactory.getInstance(X509_ALGORITHM);\n    tmf.init(keystore);\n    for (    TrustManager trustManager : tmf.getTrustManagers()) {\n      if (trustManager instanceof X509TrustManager) {\n        defaultViPRTrustManager=(X509TrustManager)trustManager;\n        log.debug(\"found a X509TrustManager instance\");\n        break;\n      }\n    }\n    log.info(\"renew trust manager. the # of certificates in trust store is {}\",defaultViPRTrustManager.getAcceptedIssuers().length);\n  }\n catch (  GeneralSecurityException e) {\n    log.error(e.getMessage(),e);\n  }\n}\n", "docstring": "loads the trust manager using the vipr keystore .", "partition": "test"}
{"idx": "2268", "code": "private String mosesize(String feature){\n  if (joshuaConfiguration.moses) {\n    if (feature.startsWith(\"tm_\") || feature.startsWith(\"lm_\"))     return feature.replace(\"_\",\"-\");\n  }\n  return feature;\n}\n", "docstring": "moses requires the pattern . * _ . * for sparse features , and prohibits underscores in dense features . this conforms to that pattern . we assume non - conforming dense features start with tm_ or lm_ , and the only sparse feature that needs converting is oovpenalty .", "partition": "test"}
{"idx": "3997", "code": "private static boolean isTwoSlotType(ClassNode type){\n  return type == ClassHelper.long_TYPE || type == ClassHelper.double_TYPE;\n}\n", "docstring": "returns true for long and double", "partition": "test"}
{"idx": "1553", "code": "private char[] fFormatDigits(final double x){\n  String sx;\n  int i, j, k;\n  final int n1In;\n  final int n2In;\n  int expon=0;\n  boolean minusSign=false;\n  if (x > 0.0) {\n    sx=Double.toString(x);\n  }\n else   if (x < 0.0) {\n    sx=Double.toString(-x);\n    minusSign=true;\n  }\n else {\n    sx=Double.toString(x);\n    if (sx.charAt(0) == '-') {\n      minusSign=true;\n      sx=sx.substring(1);\n    }\n  }\n  final int ePos=sx.indexOf('E');\n  final int rPos=sx.indexOf('.');\n  if (rPos != -1) {\n    n1In=rPos;\n  }\n else   if (ePos != -1) {\n    n1In=ePos;\n  }\n else {\n    n1In=sx.length();\n  }\n  if (rPos != -1) {\n    if (ePos != -1) {\n      n2In=ePos - rPos - 1;\n    }\n else {\n      n2In=sx.length() - rPos - 1;\n    }\n  }\n else {\n    n2In=0;\n  }\n  if (ePos != -1) {\n    int ie=ePos + 1;\n    expon=0;\n    if (sx.charAt(ie) == '-') {\n      for (++ie; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=-Integer.parseInt(sx.substring(ie));\n      }\n    }\n else {\n      if (sx.charAt(ie) == '+') {\n        ++ie;\n      }\n      for (; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=Integer.parseInt(sx.substring(ie));\n      }\n    }\n  }\n  final int p;\n  if (precisionSet) {\n    p=precision;\n  }\n else {\n    p=defaultDigits - 1;\n  }\n  final char[] ca1=sx.toCharArray();\n  final char[] ca2=new char[n1In + n2In];\n  final char[] ca3;\n  final char[] ca4;\n  final char[] ca5;\n  for (j=0; j < n1In; j++) {\n    ca2[j]=ca1[j];\n  }\n  i=j + 1;\n  for (k=0; k < n2In; j++, i++, k++) {\n    ca2[j]=ca1[i];\n  }\n  if (n1In + expon <= 0) {\n    ca3=new char[-expon + n2In];\n    for (j=0, k=0; k < (-n1In - expon); k++, j++) {\n      ca3[j]='0';\n    }\n    for (i=0; i < (n1In + n2In); i++, j++) {\n      ca3[j]=ca2[i];\n    }\n  }\n else {\n    ca3=ca2;\n  }\n  boolean carry=false;\n  if (p < -expon + n2In) {\n    if (expon < 0) {\n      i=p;\n    }\n else {\n      i=p + n1In;\n    }\n    carry=checkForCarry(ca3,i);\n    if (carry) {\n      carry=startSymbolicCarry(ca3,i - 1,0);\n    }\n  }\n  if (n1In + expon <= 0) {\n    ca4=new char[2 + p];\n    if (!carry) {\n      ca4[0]='0';\n    }\n else {\n      ca4[0]='1';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[1]='.';\n      for (i=0, j=2; i < Math.min(p,ca3.length); i++, j++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n else {\n    if (!carry) {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 1];\n      }\n else {\n        ca4=new char[n1In + expon];\n      }\n      j=0;\n    }\n else {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 2];\n      }\n else {\n        ca4=new char[n1In + expon + 1];\n      }\n      ca4[0]='1';\n      j=1;\n    }\n    for (i=0; i < Math.min(n1In + expon,ca3.length); i++, j++) {\n      ca4[j]=ca3[i];\n    }\n    for (; i < n1In + expon; i++, j++) {\n      ca4[j]='0';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[j]='.';\n      j++;\n      for (k=0; i < ca3.length && k < p; i++, j++, k++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n  int nZeros=0;\n  if (!leftJustify && leadingZeros) {\n    int xThousands=0;\n    if (thousands) {\n      int xlead=0;\n      if (ca4[0] == '+' || ca4[0] == '-' || ca4[0] == ' ') {\n        xlead=1;\n      }\n      int xdp=xlead;\n      for (; xdp < ca4.length; xdp++) {\n        if (ca4[xdp] == '.') {\n          break;\n        }\n      }\n      xThousands=(xdp - xlead) / 3;\n    }\n    if (fieldWidthSet) {\n      nZeros=fieldWidth - ca4.length;\n    }\n    if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n      nZeros--;\n    }\n    nZeros-=xThousands;\n    if (nZeros < 0) {\n      nZeros=0;\n    }\n  }\n  j=0;\n  if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n    ca5=new char[ca4.length + nZeros + 1];\n    j++;\n  }\n else {\n    ca5=new char[ca4.length + nZeros];\n  }\n  if (!minusSign) {\n    if (leadingSign) {\n      ca5[0]='+';\n    }\n    if (leadingSpace) {\n      ca5[0]=' ';\n    }\n  }\n else {\n    ca5[0]='-';\n  }\n  for (i=0; i < nZeros; i++, j++) {\n    ca5[j]='0';\n  }\n  for (i=0; i < ca4.length; i++, j++) {\n    ca5[j]=ca4[i];\n  }\n  int lead=0;\n  if (ca5[0] == '+' || ca5[0] == '-' || ca5[0] == ' ') {\n    lead=1;\n  }\n  int dp=lead;\n  for (; dp < ca5.length; dp++) {\n    if (ca5[dp] == '.') {\n      break;\n    }\n  }\n  final int nThousands=(dp - lead) / 3;\n  if (dp < ca5.length) {\n    ca5[dp]=dfs.getDecimalSeparator();\n  }\n  char[] ca6=ca5;\n  if (thousands && nThousands > 0) {\n    ca6=new char[ca5.length + nThousands + lead];\n    ca6[0]=ca5[0];\n    for (i=lead, k=lead; i < dp; i++) {\n      if (i > 0 && (dp - i) % 3 == 0) {\n        ca6[k]=dfs.getGroupingSeparator();\n        ca6[k + 1]=ca5[i];\n        k+=2;\n      }\n else {\n        ca6[k]=ca5[i];\n        k++;\n      }\n    }\n    for (; i < ca5.length; i++, k++) {\n      ca6[k]=ca5[i];\n    }\n  }\n  return ca6;\n}\n", "docstring": "for f format , the flag character \"'\" - \"'\" , means that the output should be left justified within the field . the default is to pad with blanks on the left . \"'\" + \"'\" character means that the conversion will always begin with a sign ( + or - ) . the blank flag character means that a non - negative input will be preceded with a blank . if both a \"'\" + \"'\" and a \"'\" \"'\" are specified , the blank flag is ignored . the \"'\" 0 \"'\" flag character implies that padding to the field width will be done with zeros instead of blanks . the field width is treated as the minimum number of characters to be printed . the default is to add no padding . padding is with blanks by default . the precision , if set , is the number of digits to appear after the radix character . padding is with trailing 0s .", "partition": "test"}
{"idx": "143", "code": "@Override public Generator<ICircle> construct(String[] args){\n  return new UniformGenerator(Double.valueOf(args[0]));\n}\n", "docstring": "provide reflective behavior to construct instance of generator given an array of string arguments .", "partition": "test"}
{"idx": "1445", "code": "public Z21Message(byte[] a,int l){\n  super(String.valueOf(a));\n  setBinary(true);\n}\n", "docstring": "this ctor interprets the byte array as a sequence of characters to send .", "partition": "test"}
{"idx": "870", "code": "@Override public void onDrawEye(Eye eye){\n  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);\n  Engine.checkGLError(\"mColorParam\");\n  if (!prefOrientationProviderString.equals(\"0\")) {\n    if (firstOnDrawEye > 0) {\n      firstOnDrawEye--;\n      float[] m=new float[16];\n      Matrix.invertM(m,0,mHeadViewSDK,0);\n      Matrix.multiplyMM(m,0,eye.getEyeView(),0,m,0);\n      if (eye.getType() == Eye.Type.RIGHT) {\n        mEyeRightView=m;\n      }\n else       if (eye.getType() == Eye.Type.LEFT) {\n        mEyeLeftView=m;\n      }\n      return;\n    }\n    float[] m=new float[16];\n    if (eye.getType() == Eye.Type.RIGHT) {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeRightView,0);\n    }\n else {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeLeftView,0);\n    }\n    Matrix.multiplyMM(mView,0,m,0,mCamera,0);\n  }\n else {\n    Matrix.multiplyMM(mView,0,eye.getEyeView(),0,mCamera,0);\n  }\n  float[] perspective=eye.getPerspective(Z_NEAR,Z_FAR);\n  GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n  GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA,GLES20.GL_ONE_MINUS_SRC_ALPHA);\n  GLES20.glEnable(GLES20.GL_BLEND);\n  if (prefShowEnv && bgEnv.isReady()) {\n    Matrix.multiplyMM(mModelView,0,mView,0,bgEnv.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    bgEnv.draw(eye.getType(),mModelViewProjection);\n  }\n  GLES20.glDisable(GLES20.GL_DEPTH_TEST);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,cameraPreview.model,0);\n  cameraPreview.draw(eye.getType(),mModelViewProjection);\n  Matrix.multiplyMM(mModelView,0,mView,0,screen.model,0);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n  screen.draw(eye.getType(),mModelViewProjection);\n  for (  ButtonThing button : buttonList) {\n    Matrix.multiplyMM(mModelView,0,mView,0,button.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    button.draw(eye.getType(),mModelViewProjection);\n  }\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,aimPoint.model,0);\n  aimPoint.draw(Eye.Type.MONOCULAR,mModelViewProjection);\n}\n", "docstring": "draws a frame for an eye .", "partition": "test"}
{"idx": "4132", "code": "private Long currentTime(){\n  return System.currentTimeMillis() / 1000;\n}\n", "docstring": "returns a current time seconds from epoch .", "partition": "test"}
{"idx": "3103", "code": "public PerformanceLogger(){\n  time1=System.currentTimeMillis();\n}\n", "docstring": "instantiates a new performance logger .", "partition": "test"}
{"idx": "403", "code": "public void addForeignKeyConstraint(String name,String sourceField,String targetField,String targetTable){\n  ForeignKeyConstraint foreignKey=new ForeignKeyConstraint(name,sourceField,targetField,targetTable);\n  addForeignKeyConstraint(foreignKey);\n}\n", "docstring": "public : add a foreign key constraint to the table . if there is a same name foreign key constraint already , nothing will happen .", "partition": "test"}
{"idx": "1577", "code": "@SuppressWarnings(\"rawtypes\") protected Class resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n  String cname=classDesc.getName();\n  return ClassFinder.resolveClass(cname,this.loader);\n}\n", "docstring": "use the given classloader rather than using the system class", "partition": "test"}
{"idx": "3274", "code": "public static String soapToString(SOAPElement element){\n  return domToString(element.getOwnerDocument());\n}\n", "docstring": "converts a javax . xml . soap . soapelement to a string can be used for soapui requests be carefull : to convert a soapmessage sm , you must use sm . getsoappart ( ) . getenvelope ( ) ;", "partition": "test"}
{"idx": "1097", "code": "public static boolean hasElementChild(Node node){\n  NodeList nl=node.getChildNodes();\n  Node child=null;\n  int length=nl.getLength();\n  for (int i=0; i < length; i++) {\n    child=nl.item(i);\n    if (child.getNodeType() == Node.ELEMENT_NODE) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if a node has a child of element type .", "partition": "test"}
{"idx": "4260", "code": "public void supportTlsIntolerantServer(SSLSocket socket){\n  socket.setEnabledProtocols(new String[]{\"SSLv3\"});\n}\n", "docstring": "attempt a secure connection with basic functionality to maximize compatibility . currently this uses ssl 3 . 0 .", "partition": "test"}
{"idx": "3900", "code": "protected boolean isAllTestComponentsInTarget(Geometry testGeom){\n  List coords=ComponentCoordinateExtracter.getCoordinates(testGeom);\n  for (Iterator i=coords.iterator(); i.hasNext(); ) {\n    Coordinate p=(Coordinate)i.next();\n    int loc=targetPointLocator.locate(p);\n    if (loc == Location.EXTERIOR)     return false;\n  }\n  return true;\n}\n", "docstring": "tests whether all components of the test geometry are contained in the target geometry . handles both linear and point components .", "partition": "test"}
{"idx": "1471", "code": "public static List<Double> mergeCoords(List<Double> x,List<Double> y){\n  if (x.size() != y.size())   throw new IllegalArgumentException(\"Sample sizes must be the same for each data applyTransformToDestination.\");\n  List<Double> ret=new ArrayList<>();\n  for (int i=0; i < x.size(); i++) {\n    ret.add(x.get(i));\n    ret.add(y.get(i));\n  }\n  return ret;\n}\n", "docstring": "this will merge the coordinates of the given coordinate system .", "partition": "test"}
{"idx": "3763", "code": "public void lockFlushing(){\n  flushLock.lock();\n}\n", "docstring": "lock the flushing mechanism in order to prevent a thread flushing this buffer while another thread is doing a physiological operation .", "partition": "test"}
{"idx": "3871", "code": "private void updateIndexColumnButtons(){\n  indexRemoveButton.setEnabled(false);\n  indexUpButton.setEnabled(false);\n  indexDownButton.setEnabled(false);\n  int index=selectedColumns.getSelectionIndex();\n  if (index >= 0) {\n    indexRemoveButton.setEnabled(true);\n    if (index > 0) {\n      indexUpButton.setEnabled(true);\n    }\n else     if (index < selectedColumns.getItemCount() - 1) {\n      indexDownButton.setEnabled(true);\n    }\n  }\n}\n", "docstring": "updates status of index column up / down buttons .", "partition": "test"}
{"idx": "2100", "code": "public void testNegateNegative(){\n  String a=\"-92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=41;\n  String c=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int cScale=41;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal cNumber=new BigDecimal(new BigInteger(c),cScale);\n  assertEquals(\"incorrect value\",cNumber,aNumber.negate());\n}\n", "docstring": "negate ( ) for a negative bigdecimal", "partition": "test"}
{"idx": "865", "code": "public Dimension maximumLayoutSize(Container target){\n  return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);\n}\n", "docstring": "returns the maximum dimensions for this layout given the components in the specified target container .", "partition": "test"}
{"idx": "1320", "code": "public void addListener(NavigatorListener listener){\n  listeners.add(listener);\n}\n", "docstring": "add listener to listener list", "partition": "test"}
{"idx": "2800", "code": "private void createSnapshot(BlockSnapshot snapshot,Snap unitySnap,StorageSystem storage,DbClient dbClient){\n  snapshot.setNativeId(unitySnap.getId());\n  snapshot.setNativeGuid(NativeGUIDGenerator.generateNativeGuid(storage,snapshot));\n  snapshot.setDeviceLabel(unitySnap.getName());\n  snapshot.setIsSyncActive(true);\n  snapshot.setInactive(false);\n  snapshot.setCreationTime(Calendar.getInstance());\n  snapshot.setWWN(unitySnap.getAttachedWWN());\n  snapshot.setAllocatedCapacity(unitySnap.getSize());\n  snapshot.setProvisionedCapacity(unitySnap.getSize());\n  dbClient.createObject(snapshot);\n}\n", "docstring": "create the blocksnapshot in db", "partition": "test"}
{"idx": "2791", "code": "public OMRaster(double lt,double ln,int offset_x1,int offset_y1,ImageIcon ii){\n  this(lt,ln,offset_x1,offset_y1,ii.getImage());\n}\n", "docstring": "create an omraster , lat / lon with x / y placement with an imageicon .", "partition": "test"}
{"idx": "686", "code": "static HeapBytesStore<byte[]> wrap(@NotNull byte[] bytes){\n  return HeapBytesStore.wrap(bytes);\n}\n", "docstring": "wraps a byte [ ", "partition": "test"}
{"idx": "3942", "code": "public SecureELFFormatter(){\n  String timestampGeneratorClass=lmanager.getProperty(LogConstants.SECURE_TIMESTAMP_GENERATOR);\n  try {\n    Class clz=Class.forName(timestampGeneratorClass);\n    secureTimestampGenerator=(ITimestampGenerator)clz.newInstance();\n  }\n catch (  ClassNotFoundException cnfe) {\n    Debug.error(\"SecureELFFormatter: TimeStamp Generator Class \" + \"not found\",cnfe);\n  }\ncatch (  InstantiationException ie) {\n    Debug.error(\"SecureELFFormatter: Timestamp Generator Could \" + \"not be Instantiated\",ie);\n  }\ncatch (  IllegalAccessException iae) {\n    Debug.error(\"SecureELFFormatter: Timestamp Generator Could \" + \"not be Instantiated\",iae);\n  }\n}\n", "docstring": "returns a elf formatter", "partition": "test"}
{"idx": "566", "code": "public final void readFully(byte[] b) throws java.io.IOException {\n  readFully(b,0,b.length);\n}\n", "docstring": "see the general contract of the readfully method of datainput . bytes for this operation are read from the contained input stream .", "partition": "test"}
{"idx": "3095", "code": "public PrintfFormat(final String fmtArg) throws IllegalArgumentException {\n  this(Locale.getDefault(),fmtArg);\n}\n", "docstring": "constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings . control strings begin with unpaired percent signs . a pair of successive percent signs designates a single percent sign in the format .", "partition": "test"}
{"idx": "2467", "code": "public static boolean isNextWindow(URI id){\n  return id == null || NEXT.equals(id);\n}\n", "docstring": "determines if this id corresponds to the \"'\" next \"'\" execution window .", "partition": "test"}
{"idx": "1583", "code": "private void initComputeProgram(){\n  glUseProgram(computeProgram);\n  IntBuffer workGroupSize=BufferUtils.createIntBuffer(3);\n  glGetProgramiv(computeProgram,GL_COMPUTE_WORK_GROUP_SIZE,workGroupSize);\n  workGroupSizeX=workGroupSize.get(0);\n  workGroupSizeY=workGroupSize.get(1);\n  timeUniform=glGetUniformLocation(computeProgram,\"time\");\n  blendFactorUniform=glGetUniformLocation(computeProgram,\"blendFactor\");\n  bounceCountUniform=glGetUniformLocation(computeProgram,\"bounceCount\");\n  IntBuffer params=BufferUtils.createIntBuffer(1);\n  int loc=glGetUniformLocation(computeProgram,\"framebufferImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  framebufferImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldPositionImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldPositionImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldNormalImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldNormalImageBinding=params.get(0);\n  glUseProgram(0);\n}\n", "docstring": "initialize the compute shader .", "partition": "test"}
{"idx": "1884", "code": "public int checksum(){\n  return calculateChecksum(compile_checksum.toString());\n}\n", "docstring": "this value is good for naming the cache file .", "partition": "test"}
{"idx": "3316", "code": "protected void startRecoarding(){\n  coordinates.clear();\n  enabled=true;\n}\n", "docstring": "start recording the gesture", "partition": "test"}
{"idx": "1264", "code": "static private String SHORT_Max_Plus(){\n  long tempValue=Short.MAX_VALUE + 1;\n  return String.valueOf(tempValue);\n}\n", "docstring": "get the max value plus one for a short", "partition": "test"}
{"idx": "4092", "code": "protected int[] readColorTable(final int ncolors){\n  final int nbytes=3 * ncolors;\n  int[] tab=null;\n  final byte[] c=new byte[nbytes];\n  try {\n    rawData.get(c);\n    tab=new int[256];\n    int i=0;\n    int j=0;\n    while (i < ncolors) {\n      final int r=(c[j++]) & 0xff;\n      final int g=(c[j++]) & 0xff;\n      final int b=(c[j++]) & 0xff;\n      tab[i++]=0xff000000 | (r << 16) | (g << 8)| b;\n    }\n  }\n catch (  final BufferUnderflowException e) {\n    Log.w(TAG,\"Format Error Reading Color Table\",e);\n    status=STATUS_FORMAT_ERROR;\n  }\n  return tab;\n}\n", "docstring": "reads color table as 256 rgb integer values", "partition": "test"}
{"idx": "1767", "code": "public static String extractIndentString(String line,int tabWidth,int indentWidth){\n  if (tabWidth < 0 || indentWidth < 0 || line == null) {\n    throw new IllegalArgumentException();\n  }\n  int size=line.length();\n  int end=0;\n  int spaceEquivs=0;\n  int characters=0;\n  for (int i=0; i < size; i++) {\n    char c=line.charAt(i);\n    if (c == '\\\\t') {\n      spaceEquivs=calculateSpaceEquivalents(tabWidth,spaceEquivs);\n      characters++;\n    }\n else     if (isIndentChar(c)) {\n      spaceEquivs++;\n      characters++;\n    }\n else {\n      break;\n    }\n    if (spaceEquivs >= indentWidth) {\n      end+=characters;\n      characters=0;\n      if (indentWidth == 0) {\n        spaceEquivs=0;\n      }\n else {\n        spaceEquivs=spaceEquivs % indentWidth;\n      }\n    }\n  }\n  if (end == 0) {\n    return Util.EMPTY_STRING;\n  }\n else   if (end == size) {\n    return line;\n  }\n else {\n    return line.substring(0,end);\n  }\n}\n", "docstring": "returns the leading indentation string of the given line . note that the returned string need not be equal to the leading whitespace as odd spaces are not considered part of the indentation .", "partition": "test"}
{"idx": "3205", "code": "public static void drawShadow(final Rectangle2D rect,final Graphics2D g2){\n  Graphics2D g2S=(Graphics2D)g2.create();\n  Rectangle2D shadow=new Rectangle2D.Double(rect.getX() + 5,rect.getY() + ProcessDrawer.HEADER_HEIGHT + 5,rect.getWidth(),rect.getHeight() - ProcessDrawer.HEADER_HEIGHT);\n  GeneralPath bottom=new GeneralPath();\n  bottom.moveTo(shadow.getX(),rect.getMaxY());\n  bottom.lineTo(rect.getMaxX(),rect.getMaxY());\n  bottom.lineTo(shadow.getMaxX(),shadow.getMaxY());\n  bottom.lineTo(shadow.getMinX(),shadow.getMaxY());\n  bottom.closePath();\n  g2S.setPaint(new GradientPaint((float)rect.getX(),(float)rect.getMaxY(),Color.gray,(float)rect.getX(),(float)shadow.getMaxY(),TRANSPARENT_GRAY));\n  g2S.fill(bottom);\n  GeneralPath right=new GeneralPath();\n  right.moveTo(rect.getMaxX(),shadow.getMinY());\n  right.lineTo(shadow.getMaxX(),shadow.getMinY());\n  right.lineTo(shadow.getMaxX(),shadow.getMaxY());\n  right.lineTo(rect.getMaxX(),rect.getMaxY());\n  right.closePath();\n  g2S.setPaint(new GradientPaint((float)rect.getMaxX(),(float)shadow.getY(),Color.gray,(float)shadow.getMaxX(),(float)shadow.getY(),TRANSPARENT_GRAY));\n  g2S.fill(right);\n  g2S.dispose();\n}\n", "docstring": "draws a shadow around the given rectangle .", "partition": "test"}
{"idx": "1196", "code": "public boolean hasUserPartitions(){\n  return !userOutput.isEmpty();\n}\n", "docstring": "retrieves if user partitions are present", "partition": "test"}
{"idx": "1693", "code": "private void loadFile(String filename,AbstractFileLoader... loaders){\n  ArffSortedTableModel model;\n  this.m_Filename=filename;\n  createTitle();\n  if (filename.equals(\"\")) {\n    model=null;\n  }\n else {\n    model=new ArffSortedTableModel(filename,loaders);\n    model.setShowAttributeIndex(getShowAttributeIndex());\n  }\n  m_TableArff.setModel(model);\n  setChanged(false);\n  createName();\n}\n", "docstring": "loads the specified file into the table", "partition": "test"}
{"idx": "653", "code": "public Name join(String identifier){\n  validateLowerUnderscore(identifier);\n  List<NamePiece> newPieceList=new ArrayList<>();\n  newPieceList.addAll(namePieces);\n  newPieceList.add(new NamePiece(identifier,CaseFormat.LOWER_UNDERSCORE));\n  return new Name(newPieceList);\n}\n", "docstring": "returns a new name containing the pieces from this name plus the given identifier added on the end .", "partition": "test"}
{"idx": "2118", "code": "public double distance(Vector o){\n  return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));\n}\n", "docstring": "get the distance between this vector and another . the value of this method is not cached and uses a costly square - root function , so do not repeatedly call this method to get the vector \"'\" s magnitude . nan will be returned if the inner result of the sqrt ( ) function overflows , which will be caused if the distance is too long .", "partition": "test"}
{"idx": "3868", "code": "private void adjustRowHeights(JTable table){\n  for (int row=0; row < table.getRowCount(); row++) {\n    int rowHeight=table.getRowHeight();\n    for (int column=0; column < table.getColumnCount(); column++) {\n      Component comp=table.prepareRenderer(table.getCellRenderer(row,column),row,column);\n      rowHeight=Math.max(rowHeight,comp.getPreferredSize().height);\n    }\n    table.setRowHeight(row,rowHeight);\n  }\n}\n", "docstring": "adjust the row heights of a table based on the table contents .", "partition": "test"}
{"idx": "1615", "code": "void flush(){\n  printStream.flush();\n}\n", "docstring": "flush any io to disk . for testing purposes .", "partition": "test"}
{"idx": "3040", "code": "private JLabel createIconLabel(JCheckBox checkBox){\n  checkBox.setOpaque(false);\n  checkBox.setSize(checkBox.getMinimumSize());\n  Image image=new BufferedImage(checkBox.getWidth(),checkBox.getHeight(),Transparency.TRANSLUCENT);\n  Graphics g=image.getGraphics();\n  checkBox.paint(g);\n  g.dispose();\n  return new JLabel(new ImageIcon(image));\n}\n", "docstring": "creates an image of the checkbox and puts it in a label .", "partition": "test"}
{"idx": "808", "code": "public double metersToPixels(){\n  double screenCenterLat=screenTopLeft.latitude - screenSize.latitude / 2;\n  double metersToLon=1 / (Util.LON_TO_METERS_AT_EQUATOR * Math.cos(screenCenterLat / 180 * Math.PI));\n  return screenSize.longitude / windowWidth * metersToLon;\n}\n", "docstring": "returns the ratio of meters to pixels at the center of the screen", "partition": "test"}
{"idx": "2607", "code": "@Override public Set<K> keySet(){\n  HashSet<K> set=new HashSet<K>();\n  for (  Segment<K,V> s : segments) {\n    set.addAll(s.keySet());\n  }\n  return set;\n}\n", "docstring": "get the set of keys for resident entries .", "partition": "test"}
{"idx": "2493", "code": "private static byte[] WindowsRegEnumValue1(int hKey,int valueIndex,int maxValueNameLength){\n  byte[] result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "retries regenumvalueex ( ) max_attempts times before giving up .", "partition": "test"}
{"idx": "1709", "code": "@Deprecated public void put(Collection<Integer> data){\n  for (  Integer value : data) {\n    final int val=value.intValue();\n    min=val < min ? val : min;\n    max=val > max ? val : max;\n  }\n}\n", "docstring": "process a whole collection of integer values . if any of the values is smaller than the current minimum , it will become the new minimum . if any of the values is larger than the current maximum , it will become the new maximum .", "partition": "test"}
{"idx": "1862", "code": "public static String generateTransportZoneNativeGuid(String transportType,String deviceType,String fabricId){\n  return String.format(\"%s+%s+%s\",transportType,_deviceTypeMap.get(deviceType),fabricId);\n}\n", "docstring": "the format of this native guid is transporttype + devicetype + fabricwwn . transporttype is fc , devicetype is mds or brocade and fabricwwn is the unique wwn assigned to the fabric .", "partition": "test"}
{"idx": "65", "code": "public long max(){\n  return deltaMax.get();\n}\n", "docstring": "get running - maximum time - delta , in nanoseconds .", "partition": "test"}
{"idx": "372", "code": "public static List<Integer> precomputeHashes(byte[] data,long tweak){\n  ArrayList<Integer> list=new ArrayList<>(MAX_HASH_FUNCS);\n  for (int i=0; i < MAX_HASH_FUNCS; ++i) {\n    list.add(murmurhash3bit(i,data,tweak));\n  }\n  return list;\n}\n", "docstring": "precompute hashes used to set mask bits for a data .", "partition": "test"}
{"idx": "1199", "code": "public Item(Drawable symbol,String labelText,Font font){\n  double fontSize=font.getSize2D();\n  setLayout(new EdgeLayout(fontSize,0.0));\n  this.symbol=symbol;\n  add(symbol,Location.WEST);\n  label=new Label(labelText);\n  label.setFont(font);\n  label.setAlignmentX(0.0);\n  label.setAlignmentY(0.5);\n  add(label,Location.CENTER);\n}\n", "docstring": "creates a new item object with the specified data source and text .", "partition": "test"}
{"idx": "916", "code": "public void writeOperationsCarFile(){\n  makeBackupFile(defaultOperationsFilename());\n  try {\n    if (!checkFile(defaultOperationsFilename())) {\n      java.io.File file=new java.io.File(defaultOperationsFilename());\n      java.io.File parentDir=file.getParentFile();\n      if (!parentDir.exists()) {\n        if (!parentDir.mkdir()) {\n          log.error(\"Directory wasn\\'t created\");\n        }\n      }\n      if (file.createNewFile()) {\n        log.debug(\"File created\");\n      }\n    }\n    writeFile(defaultOperationsFilename());\n  }\n catch (  Exception e) {\n    log.error(\"Exception while writing the new CSV operations file, may not be complete: \" + e);\n  }\n}\n", "docstring": "store the all of the operation car objects in the default place , including making a backup if needed", "partition": "test"}
{"idx": "2657", "code": "public synchronized void end(){\n  graphicsToBeDrawn.close();\n  if (currentGraphics != null) {\n    graphicsDrawn.append(currentGraphics);\n  }\n  graphicsDrawn.closeWhenEmpty();\n  if (printerJobThread != null && printerJobThread.isAlive()) {\n    try {\n      printerJobThread.join();\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}\n", "docstring": "ends the print job and does any necessary cleanup .", "partition": "test"}
{"idx": "2988", "code": "public final void addReference(Object ref){\n  refSet.add(ref);\n}\n", "docstring": "adds the given object to the set of hard references , which will prevent that object from being disposed until the queue has been flushed completely . this is useful in cases where some enqueued data could become invalid if the reference object were garbage collected before the queue could be processed . ( for example , keeping a hard reference to a fontstrike will prevent any enqueued glyph images associated with that strike from becoming invalid before the queue is flushed . ) the reference set will be cleared immediately after the queue is flushed each time .", "partition": "test"}
{"idx": "231", "code": "public static float r_distance(vec3 a,vec3 b){\n  float x=a.m[0] - b.m[0];\n  float y=a.m[1] - b.m[1];\n  float z=a.m[2] - b.m[2];\n  float result=(float)Math.sqrt(x * x + y * y + z * z);\n  return result;\n}\n", "docstring": "\\\\ brief distance ( vec3 a , vec3 b )", "partition": "test"}
{"idx": "494", "code": "public void addTextChangeListener(final FilterQueryChangeListener textChangeListener){\n  listeners.add(textChangeListener);\n}\n", "docstring": "adds the given listener", "partition": "test"}
{"idx": "1152", "code": "private static <T>void initializeKnownPlugins(final T pluginInterface,final IPluginRegistry<IPlugin<T>> registry,final List<PluginConfigItem> xmlPluginOrder,final List<Pair<IPlugin<T>,PluginStatus>> validatedPlugins,final List<Pair<IPlugin<T>,Exception>> initializedPlugins,final Set<Long> processedPlugins){\n  for (  final PluginConfigItem pt : xmlPluginOrder) {\n    processedPlugins.add(pt.getGUID());\n    final IPlugin<T> plugin=findPlugin(validatedPlugins,pt.getGUID());\n    if (plugin != null) {\n      if (pt.isLoad()) {\n        initializePlugin(plugin,pluginInterface,registry,initializedPlugins);\n      }\n else {\n        registry.addDisabledPlugin(plugin,DisabledPluginReason.NotLoaded);\n      }\n    }\n  }\n}\n", "docstring": "loads the plugins that are configured in the configuration file .", "partition": "test"}
{"idx": "338", "code": "public SVDMatrix(Matrix Arg){\n  this(Arg,true,true,true);\n}\n", "docstring": "construct the singular value decomposition", "partition": "test"}
{"idx": "993", "code": "public DSignCsr(JFrame parent,PKCS10CertificationRequest pkcs10Csr,File csrFile,PrivateKey signPrivateKey,KeyPairType signKeyPairType,X509Certificate verificationCertificate,Provider provider) throws CryptoException {\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  this.pkcs10Csr=pkcs10Csr;\n  this.csrFile=csrFile;\n  this.signPrivateKey=signPrivateKey;\n  this.signKeyPairType=signKeyPairType;\n  this.verificationCertificate=verificationCertificate;\n  this.provider=provider;\n  setTitle(res.getString(\"DSignCsr.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dsigncsr dialog for a pkcs # 10 formatted csr .", "partition": "test"}
{"idx": "1507", "code": "public void load(List<PolicyQualifierInfo> policyQualifierInfo){\n  PolicyQualifierInfo[] policyQualifierInfoArray=policyQualifierInfo.toArray(new PolicyQualifierInfo[policyQualifierInfo.size()]);\n  Arrays.sort(policyQualifierInfoArray,new PolicyQualifierInfoComparator());\n  data=new Object[policyQualifierInfoArray.length][1];\n  int i=0;\n  for (  PolicyQualifierInfo policyQualInfo : policyQualifierInfoArray) {\n    data[i][0]=policyQualInfo;\n    i++;\n  }\n  fireTableDataChanged();\n}\n", "docstring": "load the policyqualifierinfotablemodel with policy qualifier info .", "partition": "test"}
{"idx": "303", "code": "public static String arrayToDelimitedString(Object[] arr,String delim){\n  if (arr == null) {\n    return \"\";\n  }\n  StringBuffer sb=new StringBuffer();\n  for (int i=0; i < arr.length; i++) {\n    if (i > 0) {\n      sb.append(delim);\n    }\n    sb.append(arr[i]);\n  }\n  return sb.toString();\n}\n", "docstring": "convenience method to return a string array as a delimited ( e . g . csv ) string . e . g . useful for tostring ( ) implementations .", "partition": "test"}
{"idx": "4019", "code": "public void finished(long chainLength){\n  currentState=chainLength;\n  if (loggers != null) {\n    for (    Logger logger : loggers) {\n      logger.log(currentState);\n      logger.stopLogging();\n    }\n  }\n  if (showOperatorAnalysis) {\n    showOperatorAnalysis(System.out);\n  }\n  if (operatorAnalysisFile != null) {\n    try {\n      PrintStream out=new PrintStream(new FileOutputStream(operatorAnalysisFile));\n      showOperatorAnalysis(out);\n      out.flush();\n      out.close();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "cleans up when the chain finishes ( possibly early ) .", "partition": "test"}
{"idx": "1779", "code": "public static Automaton determinize(Automaton a,int maxDeterminizedStates){\n  if (a.isDeterministic()) {\n    return a;\n  }\n  if (a.getNumStates() <= 1) {\n    return a;\n  }\n  Automaton.Builder b=new Automaton.Builder();\n  SortedIntSet.FrozenIntSet initialset=new SortedIntSet.FrozenIntSet(0,0);\n  b.createState();\n  LinkedList<SortedIntSet.FrozenIntSet> worklist=new LinkedList<>();\n  Map<SortedIntSet.FrozenIntSet,Integer> newstate=new HashMap<>();\n  worklist.add(initialset);\n  b.setAccept(0,a.isAccept(0));\n  newstate.put(initialset,0);\n  final PointTransitionSet points=new PointTransitionSet();\n  final SortedIntSet statesSet=new SortedIntSet(5);\n  Transition t=new Transition();\n  while (worklist.size() > 0) {\n    SortedIntSet.FrozenIntSet s=worklist.removeFirst();\n    for (int i=0; i < s.values.length; i++) {\n      final int s0=s.values[i];\n      int numTransitions=a.getNumTransitions(s0);\n      a.initTransition(s0,t);\n      for (int j=0; j < numTransitions; j++) {\n        a.getNextTransition(t);\n        points.add(t);\n      }\n    }\n    if (points.count == 0) {\n      continue;\n    }\n    points.sort();\n    int lastPoint=-1;\n    int accCount=0;\n    final int r=s.state;\n    for (int i=0; i < points.count; i++) {\n      final int point=points.points[i].point;\n      if (statesSet.upto > 0) {\n        assert lastPoint != -1;\n        statesSet.computeHash();\n        Integer q=newstate.get(statesSet);\n        if (q == null) {\n          q=b.createState();\n          if (q >= maxDeterminizedStates) {\n            throw new TooComplexToDeterminizeException(a,maxDeterminizedStates);\n          }\n          final SortedIntSet.FrozenIntSet p=statesSet.freeze(q);\n          worklist.add(p);\n          b.setAccept(q,accCount > 0);\n          newstate.put(p,q);\n        }\n else {\n          assert (accCount > 0 ? true : false) == b.isAccept(q) : \"accCount=\" + accCount + \" vs existing accept=\"+ b.isAccept(q)+ \" states=\"+ statesSet;\n        }\n        b.addTransition(r,q,lastPoint,point - 1);\n      }\n      int[] transitions=points.points[i].ends.transitions;\n      int limit=points.points[i].ends.next;\n      for (int j=0; j < limit; j+=3) {\n        int dest=transitions[j];\n        statesSet.decr(dest);\n        accCount-=a.isAccept(dest) ? 1 : 0;\n      }\n      points.points[i].ends.next=0;\n      transitions=points.points[i].starts.transitions;\n      limit=points.points[i].starts.next;\n      for (int j=0; j < limit; j+=3) {\n        int dest=transitions[j];\n        statesSet.incr(dest);\n        accCount+=a.isAccept(dest) ? 1 : 0;\n      }\n      lastPoint=point;\n      points.points[i].starts.next=0;\n    }\n    points.reset();\n    assert statesSet.upto == 0 : \"upto=\" + statesSet.upto;\n  }\n  Automaton result=b.finish();\n  assert result.isDeterministic();\n  return result;\n}\n", "docstring": "determinizes the given automaton . < p > worst case complexity : exponential in number of states .", "partition": "test"}
{"idx": "2634", "code": "protected abstract int compareToLastMsg(Pair<K,V> tupleKeyValue,Pair<byte[],byte[]> lastReceivedKeyValue);\n", "docstring": "compare the incoming tuple with the last received message in kafka .", "partition": "test"}
{"idx": "855", "code": "protected List<VolumeDescriptor> createChangeVirtualPoolDescriptors(StorageSystem vplexSystem,Volume volume,VirtualPool newVpool,String taskId,List<Recommendation> recommendations,VirtualPoolCapabilityValuesWrapper capabilities,ControllerOperationValuesWrapper operationsWrapper) throws InternalException {\n  URI volumeVarrayURI=volume.getVirtualArray();\n  VirtualArray volumeVarray=_dbClient.queryObject(VirtualArray.class,volumeVarrayURI);\n  s_logger.info(\"Virtual volume varray is {}\",volumeVarrayURI);\n  URI volumeVpoolURI=volume.getVirtualPool();\n  VirtualPool currentVpool=_dbClient.queryObject(VirtualPool.class,volumeVpoolURI);\n  List<VolumeDescriptor> descriptors=new ArrayList<VolumeDescriptor>();\n  VolumeDescriptor vplexVirtualVolumeDesc=new VolumeDescriptor(VolumeDescriptor.Type.VPLEX_VIRT_VOLUME,volume.getStorageController(),volume.getId(),volume.getPool(),null);\n  Map<String,Object> volumeParams=new HashMap<String,Object>();\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_EXISTING_VOLUME_ID,volume.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_NEW_VPOOL_ID,newVpool.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_OLD_VPOOL_ID,volume.getVirtualPool());\n  if (operationsWrapper != null) {\n    if (operationsWrapper.getMigrationSuspendBeforeCommit() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_COMMIT,operationsWrapper.getMigrationSuspendBeforeCommit());\n    }\n    if (operationsWrapper.getMigrationSuspendBeforeDeleteSource() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_DELETE_SOURCE,operationsWrapper.getMigrationSuspendBeforeDeleteSource());\n    }\n  }\n  vplexVirtualVolumeDesc.setParameters(volumeParams);\n  descriptors.add(vplexVirtualVolumeDesc);\n  if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentVpool,newVpool)) {\n    Volume migSrcVolume=getAssociatedVolumeInVArray(volume,volumeVarrayURI);\n    descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,volumeVarray,newVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,false,capabilities));\n  }\n  URI haVarrayURI=VirtualPoolChangeAnalyzer.getHaVarrayURI(currentVpool);\n  if (haVarrayURI != null) {\n    VirtualArray haVarray=_dbClient.queryObject(VirtualArray.class,haVarrayURI);\n    VirtualPool currentHaVpool=VirtualPoolChangeAnalyzer.getHaVpool(currentVpool,_dbClient);\n    VirtualPool newHaVpool=VirtualPoolChangeAnalyzer.getNewHaVpool(currentVpool,newVpool,_dbClient);\n    if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentHaVpool,newHaVpool)) {\n      Volume migSrcVolume=getAssociatedVolumeInVArray(volume,haVarrayURI);\n      descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,haVarray,newHaVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,true,capabilities));\n    }\n  }\n  return descriptors;\n}\n", "docstring": "change the virtualpool for the passed virtual volume on the passed vplex storage system .", "partition": "test"}
{"idx": "1483", "code": "public static float approximateLength(float controlPoints[][]){\n  float length=0;\n  for (int i=0; i < controlPoints.length - 1; i++) {\n    float xDif=controlPoints[i + 1][0] - controlPoints[i][0];\n    float yDif=controlPoints[i + 1][1] - controlPoints[i][1];\n    float zDif=controlPoints[i + 1][2] - controlPoints[i][2];\n    length+=Math.sqrt(xDif * xDif + yDif * yDif + zDif * zDif);\n  }\n  return length;\n}\n", "docstring": "compute an approximate length of a bezier curve given the control points .", "partition": "test"}
{"idx": "1258", "code": "private static boolean containsChroot(String zkHost){\n  return zkHost.contains(\"/\");\n}\n", "docstring": "validates if zkhost contains a chroot . see http : / / zookeeper . apache . org / doc / r3 . 2 . 2 / zookeeperprogrammers . html # ch_zksessions", "partition": "test"}
{"idx": "3227", "code": "public static long addAndGet(AtomicLong current,long toAdd){\n  long u, r;\n  do {\n    r=current.get();\n    if (r == Long.MAX_VALUE) {\n      return Long.MAX_VALUE;\n    }\n    u=addCap(r,toAdd);\n  }\n while (!current.compareAndSet(r,u));\n  return u;\n}\n", "docstring": "concurrent addition bound to long . max_value . any concurrent write will \" happen \" before this operation .", "partition": "test"}
{"idx": "434", "code": "private static void deleteRules(List<String> batchList,List<Rule> rulesToDelete){\n  String deleteStatement=\"DELETE FROM \" + RULES_TABLE + \" WHERE RULE_INTERNAL_ID=%d\";\n  for (  Rule rule : rulesToDelete) {\n    batchList.add(String.format(deleteStatement,rule.getUid()));\n  }\n}\n", "docstring": "the sql commands to be added to the batchlist for deleting the rules in rulestodelete .", "partition": "test"}
{"idx": "3124", "code": "protected void fireClusterChange(long timestamp,String type,String message){\n  if (listeners != null && !listeners.isEmpty()) {\n    ClusterEvent event=new ClusterEvent(this,timestamp,type,message);\n    Vector targets;\nsynchronized (this) {\n      targets=(Vector)listeners.clone();\n    }\n    Enumeration e=targets.elements();\n    while (e.hasMoreElements()) {\n      ClusterEventListener l=(ClusterEventListener)e.nextElement();\n      l.changeCluster(event);\n    }\n  }\n}\n", "docstring": "fire a clusterchangeevent to all registered listeners", "partition": "test"}
{"idx": "1205", "code": "public int size(){\n  return patterns.size();\n}\n", "docstring": "size of the cluster .", "partition": "test"}
{"idx": "2201", "code": "public void removeAction(NetworkUpdateAction action){\n  actionList.remove(action);\n  for (  UpdateManagerListener listener : listeners) {\n    listener.actionRemoved(action);\n  }\n}\n", "docstring": "completely remove an action .", "partition": "test"}
{"idx": "2210", "code": "public RespokeDirectConnection directConnection(){\n  if (null != directConnectionReference) {\n    return directConnectionReference.get();\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "get the active direct connection with this endpoint ( if any )", "partition": "test"}
{"idx": "2520", "code": "public static MaildirMessageName createUniqueName(MaildirFolder parentFolder,long size){\n  String timestamp=String.valueOf(System.currentTimeMillis());\n  timestamp=timestamp.substring(0,timestamp.length() - 3);\n  StringBuilder uniquePart=new StringBuilder();\n  uniquePart.append(Integer.toHexString(random.nextInt()));\n  uniquePart.append(timestamp.substring(timestamp.length() - 3));\n  uniquePart.append(processName);\n  uniquePart.append(getNextDeliveryNumber());\n  String sizeString=\",S=\" + String.valueOf(size);\n  String fullName=timestamp + \".\" + uniquePart.toString()+ \".\"+ currentHostname+ sizeString;\n  MaildirMessageName uniqueName=new MaildirMessageName(parentFolder,fullName);\n  uniqueName.timestamp=timestamp;\n  uniqueName.uniqueString=uniquePart.toString();\n  uniqueName.hostname=currentHostname;\n  uniqueName.sizeString=sizeString;\n  uniqueName.isSplit=true;\n  uniqueName.size=size;\n  return uniqueName;\n}\n", "docstring": "create a name for a message according to < a href = \" http : / / cr . yp . to / proto / maildir . html \" / > < br / > the following elements are used : < br > < br / > \" a unique name has three pieces , separated by dots . on the left is the result of time ( ) or the second counter from gettimeofday ( ) . on the right is the result of gethostname ( ) . ( to deal with invalid host names , replace / with \\\\ 057 and : with \\\\ 072 . ) in the middle is a delivery identifier , discussed below . < br / > < br / > modern delivery identifiers are created by concatenating enough of the following strings to guarantee uniqueness : < br / > < br / > [ . . . ", "partition": "test"}
{"idx": "997", "code": "public synchronized boolean addAll(Collection<? extends E> c){\n  modCount++;\n  Object[] a=c.toArray();\n  int numNew=a.length;\n  ensureCapacityHelper(elementCount + numNew);\n  System.arraycopy(a,0,elementData,elementCount,numNew);\n  elementCount+=numNew;\n  return numNew != 0;\n}\n", "docstring": "appends all of the elements in the specified collection to the end of this vector , in the order that they are returned by the specified collection \"'\" s iterator . the behavior of this operation is undefined if the specified collection is modified while the operation is in progress . ( this implies that the behavior of this call is undefined if the specified collection is this vector , and this vector is nonempty . )", "partition": "test"}
{"idx": "3378", "code": "@Override public void removeEnvVar(EnvVar envVar){\n  if (envVar != null) {\n    envVarList.remove(envVar);\n  }\n}\n", "docstring": "removes the environment variable .", "partition": "test"}
{"idx": "481", "code": "public FieldFrameBodyIMG(Lyrics3Image image){\n  images.add(image);\n}\n", "docstring": "creates a new fieldbodyimg datatype .", "partition": "test"}
{"idx": "818", "code": "public boolean isInputColumnNameAllowed(String columnName){\n  if (columnName == null || columnName.length() == 0)   return false;\n  getInputColumnNames(false);\n  for (int i=0; i < m_inputcolumnnames.length; i++) {\n    if (columnName.equals(m_inputcolumnnames[i]))     return true;\n  }\n  return false;\n}\n", "docstring": "is input column name allowed", "partition": "test"}
{"idx": "2391", "code": "protected Set<FunctionInterface> findUnusedFunctions(Set<UnitInterface> units){\n  Set<FunctionInterface> allFunctions=new HashSet<FunctionInterface>();\n  Set<FunctionInterface> usedFunctions=new HashSet<FunctionInterface>();\n  for (  UnitInterface unit : units) {\n    List<FunctionInterface> unitFunctions=getUnitFunctions(unit);\n    allFunctions.addAll(unitFunctions);\n    for (    FunctionInterface unitFunction : unitFunctions) {\n      for (      FunctionInterface usedFunction : unitFunction.getCalledFunctions()) {\n        usedFunctions.add(usedFunction);\n      }\n    }\n  }\n  allFunctions.removeAll(usedFunctions);\n  return allFunctions;\n}\n", "docstring": "find unused functions in a unit", "partition": "test"}
{"idx": "2856", "code": "public synchronized void addServer(ServerLocation location,String[] groups,ServerLoad initialLoad,long loadPollInterval){\n  serverGroupMap.put(location,groups);\n  LoadHolder connectionLoad=new LoadHolder(location,initialLoad.getConnectionLoad(),initialLoad.getLoadPerConnection(),loadPollInterval);\n  addGroups(connectionLoadMap,groups,connectionLoad);\n  LoadHolder queueLoad=new LoadHolder(location,initialLoad.getSubscriptionConnectionLoad(),initialLoad.getLoadPerSubscriptionConnection(),loadPollInterval);\n  addGroups(queueLoadMap,groups,queueLoad);\n  updateLoad(location,initialLoad);\n}\n", "docstring": "add a new server to the load snapshot .", "partition": "test"}
{"idx": "2618", "code": "public void truckCamera(float size){\n  moveToPosition(-(float)(targetXoff + (size * Math.sin(Math.toRadians(zrot - 90)))),-(float)(targetYoff + (size * Math.cos(Math.toRadians(zrot - 90)))));\n}\n", "docstring": "change camera position horizontally ( left or right ) .", "partition": "test"}
{"idx": "2587", "code": "@SuppressWarnings(\"unchecked\") public DictionaryAdapter(Context context,File dbPath,String dbName,String defaultTable){\n  mContext=context;\n  mDbName=dbName;\n  mDefaultTable=defaultTable;\n  mDbPath=dbPath;\n  mDbFile=new File(dbPath,mDbName);\n  if (mDbFile.exists()) {\n    open();\n  }\n}\n", "docstring": "open the database if it exists or create it if it doesn \"'\" t . additionally checks if the table exists and creates it if it doesn \"'\" t .", "partition": "test"}
{"idx": "332", "code": "private static Collection<TCPTransport> allKnownTransports(){\n  Set<TCPTransport> s;\nsynchronized (localEndpoints) {\n    s=new HashSet<TCPTransport>(localEndpoints.size());\n    for (    LinkedList<TCPEndpoint> epList : localEndpoints.values()) {\n      TCPEndpoint ep=epList.getFirst();\n      s.add(ep.transport);\n    }\n  }\n  return s;\n}\n", "docstring": "returns the current list of known transports . the returned list is an unshared collection of transports , including all transports which may have channels to remote endpoints .", "partition": "test"}
{"idx": "2811", "code": "protected void appendLine(JComponent c){\n  c.setAlignmentX(0.f);\n  contents.add(c);\n}\n", "docstring": "handle gui layout details during construction .", "partition": "test"}
{"idx": "1834", "code": "public double[] skipTo(final int index) throws MathIllegalArgumentException {\n  if (index == 0) {\n    Arrays.fill(x,0);\n  }\n else {\n    final int i=index - 1;\n    final long grayCode=i ^ (i >> 1);\n    for (int j=0; j < dimension; j++) {\n      long result=0;\n      for (int k=1; k <= BITS; k++) {\n        final long shift=grayCode >> (k - 1);\n        if (shift == 0) {\n          break;\n        }\n        final long ik=shift & 1;\n        result^=ik * direction[j][k];\n      }\n      x[j]=result;\n    }\n  }\n  count=index;\n  return nextVector();\n}\n", "docstring": "skip to the i - th point in the sobol sequence . < p > this operation can be performed in o ( 1 ) .", "partition": "test"}
{"idx": "237", "code": "public final Iterator<KnowledgeEdge> requiredEdgesIterator(){\n  Set<KnowledgeEdge> edges=new HashSet<>();\n  for (  OrderedPair<Set<MyNode>> o : requiredRulesSpecs) {\n    final Set<MyNode> first=o.getFirst();\n    for (    MyNode s1 : first) {\n      final Set<MyNode> second=o.getSecond();\n      for (      MyNode s2 : second) {\n        if (!s1.equals(s2)) {\n          edges.add(new KnowledgeEdge(s1.getName(),s2.getName()));\n        }\n      }\n    }\n  }\n  return edges.iterator();\n}\n", "docstring": "iterator over the knowledgeedge \"'\" s representing required edges .", "partition": "test"}
{"idx": "787", "code": "public synchronized void init(){\n  channelFactory=new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());\n  datagramChannelFactory=new NioDatagramChannelFactory(Executors.newCachedThreadPool());\n  timer=new HashedWheelTimer();\n}\n", "docstring": "initialize ; cached threadpool is safe as it is releasing resources automatically if idle", "partition": "test"}
{"idx": "764", "code": "private QuadEdge[] fetchTriangleToVisit(QuadEdge edge,Stack edgeStack,boolean includeFrame,Set visitedEdges){\n  QuadEdge curr=edge;\n  int edgeCount=0;\n  boolean isFrame=false;\n  do {\n    triEdges[edgeCount]=curr;\n    if (isFrameEdge(curr))     isFrame=true;\n    QuadEdge sym=curr.sym();\n    if (!visitedEdges.contains(sym))     edgeStack.push(sym);\n    visitedEdges.add(curr);\n    edgeCount++;\n    curr=curr.lNext();\n  }\n while (curr != edge);\n  if (isFrame && !includeFrame)   return null;\n  return triEdges;\n}\n", "docstring": "stores the edges for a visited triangle . also pushes sym ( neighbour ) edges on stack to visit later .", "partition": "test"}
{"idx": "2275", "code": "public static String toLocalizedInteger(long value){\n  return NUMBER_FORMAT0.format(value);\n}\n", "docstring": "this static method converts the passed in number into a localizable representation of an integer , with digit grouping using locale dependant separators .", "partition": "test"}
{"idx": "2955", "code": "public void upload(File file,long restartAt,FTPDataTransferListener listener) throws IllegalStateException, FileNotFoundException, IOException, FTPIllegalReplyException, FTPException, FTPDataTransferException, FTPAbortedException {\n  if (!file.exists()) {\n    throw new FileNotFoundException(file.getAbsolutePath());\n  }\n  InputStream inputStream=null;\n  try {\n    inputStream=new FileInputStream(file);\n  }\n catch (  IOException e) {\n    throw new FTPDataTransferException(e);\n  }\n  try {\n    upload(file.getName(),inputStream,restartAt,restartAt,listener);\n  }\n catch (  IllegalStateException e) {\n    throw e;\n  }\ncatch (  IOException e) {\n    throw e;\n  }\ncatch (  FTPIllegalReplyException e) {\n    throw e;\n  }\ncatch (  FTPException e) {\n    throw e;\n  }\ncatch (  FTPDataTransferException e) {\n    throw e;\n  }\ncatch (  FTPAbortedException e) {\n    throw e;\n  }\n finally {\n    if (inputStream != null) {\n      try {\n        inputStream.close();\n      }\n catch (      Throwable t) {\n        ;\n      }\n    }\n  }\n}\n", "docstring": "this method uploads a file to the remote server . calling this method blocks the current thread until the operation is completed . the operation could be interrupted by another thread calling abortcurrentdatatransfer ( ) . the method will break with a ftpabortedexception .", "partition": "test"}
{"idx": "3735", "code": "public void execute(AbortableTask task){\n  AbortingRunnable ar=new AbortingRunnable(task);\n  tasks.add(ar);\n  try {\n    exec.execute(ar);\n  }\n catch (  RejectedExecutionException e) {\n    tasks.remove(ar);\n    throw e;\n  }\n}\n", "docstring": "executes the task using the embedded executor .", "partition": "test"}
{"idx": "2417", "code": "public ScriptBuilder data(int index,byte[] data){\n  byte[] copy=Arrays.copyOf(data,data.length);\n  int opcode;\n  if (data.length == 0) {\n    opcode=OP_0;\n  }\n else   if (data.length == 1) {\n    byte b=data[0];\n    if (b >= 1 && b <= 16)     opcode=Script.encodeToOpN(b);\n else     opcode=1;\n  }\n else   if (data.length < OP_PUSHDATA1) {\n    opcode=data.length;\n  }\n else   if (data.length < 256) {\n    opcode=OP_PUSHDATA1;\n  }\n else   if (data.length < 65536) {\n    opcode=OP_PUSHDATA2;\n  }\n else {\n    throw new RuntimeException(\"Unimplemented\");\n  }\n  return addChunk(index,new ScriptChunk(opcode,copy));\n}\n", "docstring": "adds a copy of the given byte array as a data element ( i . e . pushdata ) at the given index in the program .", "partition": "test"}
{"idx": "3452", "code": "protected boolean isLockedLocally(UUID newOwnerID){\n  return thisNode.equals(getOwnerNode()) || thisNode.equals(newOwnerID);\n}\n", "docstring": "checks if latest call to acquire / release was called on this node . should only be called from update method .", "partition": "test"}
{"idx": "879", "code": "public void dup2(){\n  mv.visitInsn(Opcodes.DUP2);\n}\n", "docstring": "generates a dup2 instruction .", "partition": "test"}
{"idx": "2850", "code": "private void addTest(Test newTest){\n  if (m_RuleList == null) {\n    m_RuleList=new ArrayList<Test>();\n  }\n  m_RuleList.add(newTest);\n}\n", "docstring": "adds the given test to the list", "partition": "test"}
{"idx": "1499", "code": "protected void removeAllPremoveDrops(){\n  for (  PremoveInfo info : premoves.toArray(new PremoveInfo[0])) {\n    if (info.isPremoveDrop) {\n      premoves.remove(info);\n    }\n  }\n}\n", "docstring": "removes all of the premove drops from premoves .", "partition": "test"}
{"idx": "3862", "code": "public static int hash2(int hash,Object x,Object y){\n  return 0x20000000 | (hash + 7 * System.identityHashCode(x) + 11 * System.identityHashCode(y));\n}\n", "docstring": "utility method to combine a base hash with the identity hash of one or more objects .", "partition": "test"}
{"idx": "3523", "code": "private long downloadTlogFiles(File tmpTlogDir,long latestGeneration) throws Exception {\n  LOG.info(\"Starting download of tlog files from master: \" + tlogFilesToDownload);\n  tlogFilesDownloaded=Collections.synchronizedList(new ArrayList<>());\n  long bytesDownloaded=0;\n  boolean status=tmpTlogDir.mkdirs();\n  if (!status) {\n    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\"Failed to create temporary tlog folder: \" + tmpTlogDir.getName());\n  }\n  for (  Map<String,Object> file : tlogFilesToDownload) {\n    String saveAs=(String)(file.get(ALIAS) == null ? file.get(NAME) : file.get(ALIAS));\n    localFileFetcher=new LocalFsFileFetcher(tmpTlogDir,file,saveAs,TLOG_FILE,latestGeneration);\n    currentFile=file;\n    localFileFetcher.fetchFile();\n    bytesDownloaded+=localFileFetcher.getBytesDownloaded();\n    tlogFilesDownloaded.add(new HashMap<>(file));\n  }\n  return bytesDownloaded;\n}\n", "docstring": "download all the tlog files to the temp tlog directory .", "partition": "test"}
{"idx": "3003", "code": "private SublimeBaseMenuItem addInternal(int group,int id,CharSequence title,CharSequence hint,SublimeBaseMenuItem.ItemType itemType,boolean valueProvidedAsync,CharSequence badgeText,boolean showsIconSpace,boolean addedByUser){\n  SublimeBaseMenuItem item;\n  boolean isGroupHeader=false;\nswitch (itemType) {\ncase SEPARATOR:\n    item=new SublimeSeparatorMenuItem(this,group,id);\n  break;\ncase BADGE:\nitem=new SublimeTextWithBadgeMenuItem(this,group,id,title,hint,valueProvidedAsync,badgeText,showsIconSpace);\nbreak;\ncase SWITCH:\nitem=new SublimeSwitchMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\ncase CHECKBOX:\nitem=new SublimeCheckboxMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\ncase GROUP_HEADER:\nisGroupHeader=true;\nitem=new SublimeGroupHeaderMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\ndefault :\nitem=new SublimeTextMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\n}\ncheckExistenceOfGroup(group);\nif (isGroupHeader) {\ncheckIfGroupHeaderAlreadyExistsForGroup(group);\nint index=findGroupIndex(group);\nif (index >= 0) {\nmItems.add(index,item);\n}\n else {\nmItems.add(item);\n}\n}\n else if (addedByUser) {\nif (group != NO_GROUP_ID) {\nint lastGroupIndex=findLastGroupIndex(group);\nmItems.add(lastGroupIndex == mItems.size() ? lastGroupIndex : lastGroupIndex + 1,item);\n}\n else {\nmItems.add(item);\n}\n}\n else {\nmItems.add(item);\n}\nonItemsChanged();\nreturn item;\n}\n", "docstring": "adds an item to the menu . the other add methods funnel to this .", "partition": "test"}
{"idx": "1284", "code": "public static <T>List<T> select(Connection connection,String rawSqlQuery,RowProcessor<T> rowProcessor,Object... parameters) throws IOException, SQLException {\n  PreparedStatement stmt=null;\n  ResultSet rs=null;\n  try {\n    stmt=connection.prepareStatement(rawSqlQuery);\n    for (int index=0; index < parameters.length; index++) {\n      JdbcUtils.bindParameter(stmt,index + 1,parameters[index]);\n    }\n    rs=stmt.executeQuery();\n    List<T> result=Lists.newLinkedList();\n    while (rs.next()) {\n      result.add(rowProcessor.process(rs));\n    }\n    return result;\n  }\n  finally {\n    JdbcUtils.closeResultSet(rs);\n    JdbcUtils.closeStatement(stmt);\n  }\n}\n", "docstring": "retrieve all the rows satisfying the given sql query .", "partition": "test"}
{"idx": "520", "code": "protected void applyAttributesToSymbol(TacticalGraphicAttributes graphicAttributes,TacticalSymbolAttributes symbolAttributes){\n  Double value=graphicAttributes.getInteriorOpacity();\n  if (value != null) {\n    symbolAttributes.setOpacity(value);\n  }\n  value=graphicAttributes.getScale();\n  if (value != null) {\n    symbolAttributes.setScale(value);\n  }\n  Material material=graphicAttributes.getInteriorMaterial();\n  symbolAttributes.setInteriorMaterial(material);\n  Font font=graphicAttributes.getTextModifierFont();\n  if (font != null) {\n    symbolAttributes.setTextModifierFont(font);\n  }\n  material=graphicAttributes.getTextModifierMaterial();\n  if (material != null) {\n    symbolAttributes.setTextModifierMaterial(material);\n  }\n}\n", "docstring": "apply graphic attributes to the symbol .", "partition": "test"}
{"idx": "3450", "code": "private void refreshIndexForDimensionFields(String rowId,DimensionRow dimensionRow,DimensionRow dimensionRowOld){\n  try {\n    for (    DimensionField field : dimension.getDimensionFields()) {\n      if (field == dimension.getKey()) {\n        continue;\n      }\n      if (dimensionRowOld != null) {\n        String oldRowValue=dimensionRowOld.get(field);\n        String oldRowValueKey=DimensionStoreKeyUtils.getRowKey(field.getName(),oldRowValue);\n        String oldRowValuesKeysJson=keyValueStore.get(oldRowValueKey);\n        String[] oldRowValueSKeys=objectMapper.readValue(oldRowValuesKeysJson,String[].class);\n        Set<String> oldRowValuesKeySet=new LinkedHashSet<>(Arrays.asList(oldRowValueSKeys));\n        oldRowValuesKeySet.remove(rowId);\n        if (oldRowValuesKeySet.isEmpty()) {\n          keyValueStore.remove(oldRowValueKey);\n        }\n else {\n          String updatedOldRowValueSKeys=objectMapper.writeValueAsString(oldRowValuesKeySet);\n          keyValueStore.put(oldRowValueKey,updatedOldRowValueSKeys);\n        }\n      }\n      String rowValue=dimensionRow.get(field);\n      String rowValueKey=DimensionStoreKeyUtils.getRowKey(field.getName(),rowValue);\n      String rowValueSKeys=keyValueStore.get(rowValueKey);\n      Set<String> rowValueSKeySet=new LinkedHashSet<>();\n      if (rowValueSKeys != null) {\n        rowValueSKeySet.addAll(Arrays.asList(objectMapper.readValue(rowValueSKeys,String[].class)));\n      }\n      rowValueSKeySet.add(rowId);\n      String updatedRowValueSKeys=objectMapper.writeValueAsString(rowValueSKeySet);\n      keyValueStore.put(rowValueKey,updatedRowValueSKeys);\n    }\n  }\n catch (  IOException e) {\n    LOG.error(\"Exception while adding dimension description entry in key value store : {}\",e);\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "this method updates the store to allow point lookups using the non - key field ( s ) . it loops through all the fields for a dimension ( ignores the key field ) < p > for a new dimensionrow say id v1 and desc value1 a new entry is added in store < p > desc_value1_row_key - > [ id_v1_row_key ", "partition": "test"}
{"idx": "882", "code": "public CustomEditor(){\n  setLayout(new BorderLayout());\n  add(m_Label,BorderLayout.CENTER);\n  m_DeleteBut.addActionListener(m_InnerActionListener);\n  m_EditBut.addActionListener(m_InnerActionListener);\n  m_UpBut.addActionListener(m_InnerActionListener);\n  m_DownBut.addActionListener(m_InnerActionListener);\n  m_AddBut.addActionListener(m_InnerActionListener);\n  m_ElementList.addListSelectionListener(m_InnerSelectionListener);\n  m_ElementList.addMouseListener(m_InnerMouseListener);\n  m_AddBut.setToolTipText(\"Add the current item to the list\");\n  m_DeleteBut.setToolTipText(\"Delete the selected list item\");\n  m_EditBut.setToolTipText(\"Edit the selected list item\");\n  m_UpBut.setToolTipText(\"Move the selected item(s) one up\");\n  m_DownBut.setToolTipText(\"Move the selected item(s) one down\");\n}\n", "docstring": "sets up the array editor .", "partition": "test"}
{"idx": "2729", "code": "public Sorter(){\n  useDefaultVisual();\n  setLayout(new BorderLayout());\n  add(m_visual,BorderLayout.CENTER);\n  m_env=Environment.getSystemWide();\n  m_stopRequested=new AtomicBoolean(false);\n}\n", "docstring": "constructs a new sorter", "partition": "test"}
{"idx": "3747", "code": "public ZoneRules toRules(String zoneId){\n  Objects.requireNonNull(zoneId,\"zoneId\");\n  if (windowList.isEmpty()) {\n    throw new IllegalStateException(\"No windows have been added to the builder\");\n  }\n  final List<ZoneOffsetTransition> standardTransitionList=new ArrayList<>(4);\n  final List<ZoneOffsetTransition> transitionList=new ArrayList<>(256);\n  final List<ZoneOffsetTransitionRule> lastTransitionRuleList=new ArrayList<>(2);\n  final TZWindow firstWindow=windowList.get(0);\n  ZoneOffset loopStandardOffset=firstWindow.standardOffset;\n  int loopSavings=0;\n  if (firstWindow.fixedSavingAmountSecs != null) {\n    loopSavings=firstWindow.fixedSavingAmountSecs;\n  }\n  final ZoneOffset firstWallOffset=ZoneOffset.ofTotalSeconds(loopStandardOffset.getTotalSeconds() + loopSavings);\n  LocalDateTime loopWindowStart=LocalDateTime.of(YEAR_MIN_VALUE,1,1,0,0);\n  ZoneOffset loopWindowOffset=firstWallOffset;\n  for (  TZWindow window : windowList) {\n    window.tidy(loopWindowStart.getYear());\n    Integer effectiveSavings=window.fixedSavingAmountSecs;\n    if (effectiveSavings == null) {\n      effectiveSavings=0;\n      for (      TZRule rule : window.ruleList) {\n        if (rule.toEpochSecond(loopStandardOffset,loopSavings) > loopWindowStart.toEpochSecond(loopWindowOffset)) {\n          break;\n        }\n        effectiveSavings=rule.savingAmountSecs;\n      }\n    }\n    if (loopStandardOffset.equals(window.standardOffset) == false) {\n      standardTransitionList.add(new ZoneOffsetTransition(LocalDateTime.ofEpochSecond(loopWindowStart.toEpochSecond(loopWindowOffset),0,loopStandardOffset),loopStandardOffset,window.standardOffset));\n      loopStandardOffset=window.standardOffset;\n    }\n    ZoneOffset effectiveWallOffset=ZoneOffset.ofTotalSeconds(loopStandardOffset.getTotalSeconds() + effectiveSavings);\n    if (loopWindowOffset.equals(effectiveWallOffset) == false) {\n      transitionList.add(new ZoneOffsetTransition(loopWindowStart,loopWindowOffset,effectiveWallOffset));\n    }\n    loopSavings=effectiveSavings;\n    for (    TZRule rule : window.ruleList) {\n      if (rule.isTransition(loopSavings)) {\n        ZoneOffsetTransition trans=rule.toTransition(loopStandardOffset,loopSavings);\n        if (trans.toEpochSecond() < loopWindowStart.toEpochSecond(loopWindowOffset) == false && trans.toEpochSecond() < window.createDateTimeEpochSecond(loopSavings)) {\n          transitionList.add(trans);\n          loopSavings=rule.savingAmountSecs;\n        }\n      }\n    }\n    for (    TZRule lastRule : window.lastRuleList) {\n      lastTransitionRuleList.add(lastRule.toTransitionRule(loopStandardOffset,loopSavings));\n      loopSavings=lastRule.savingAmountSecs;\n    }\n    loopWindowOffset=window.createWallOffset(loopSavings);\n    loopWindowStart=LocalDateTime.ofEpochSecond(window.createDateTimeEpochSecond(loopSavings),0,loopWindowOffset);\n  }\n  return new ZoneRules(firstWindow.standardOffset,firstWallOffset,standardTransitionList,transitionList,lastTransitionRuleList);\n}\n", "docstring": "completes the build converting the builder to a set of time - zone rules . < p > calling this method alters the state of the builder . further rules should not be added to this builder once this method is called .", "partition": "test"}
{"idx": "2482", "code": "@Modifying @Transactional public void deleteCheque(@PathVariable Long chequeID){\n  chequeRepository.delete(chequeID);\n  photoRepository.deleteByChequeId(chequeID.toString());\n}\n", "docstring": "method deletecheque remove cheque from db by id", "partition": "test"}
{"idx": "1059", "code": "public static void writeUnsafe(PacketOutputStream out,String value,boolean noBackslashEscapes) throws IOException {\n  byte[] bytes=value.getBytes(\"UTF-8\");\n  out.writeUnsafe(QUOTE);\n  writeBytesEscapedUnsafe(out,bytes,bytes.length,noBackslashEscapes);\n  out.writeUnsafe(QUOTE);\n}\n", "docstring": "write string in text format without checking buffer size .", "partition": "test"}
{"idx": "2616", "code": "public Wiser(){\n  this.server=new SMTPServer(new SimpleMessageListenerAdapter(this));\n}\n", "docstring": "create a new smtp server with this class as the listener . the default port is 25 . call setport ( ) / sethostname ( ) before calling start ( ) .", "partition": "test"}
{"idx": "1060", "code": "public void add(final SAMRecord read,final int position){\n  recordAndOffsets.add(new RecordAndOffset(read,position));\n}\n", "docstring": "accumulate info for one read at the locus .", "partition": "test"}
{"idx": "3830", "code": "public ArrayList<MechSummary> generateUnits(int num,UnitFilter filter){\n  ArrayList<MechSummary> retVal=new ArrayList<>();\n  for (int i=0; i < num; i++) {\n    MechSummary ms=generateUnit(filter);\n    if (ms != null) {\n      retVal.add(ms);\n    }\n  }\n  return retVal;\n}\n", "docstring": "selects a number of units from the table with a filter .", "partition": "test"}
{"idx": "3565", "code": "private void drawSelectionRectangle(Graphics2D g2){\n  if (this.selectionRectangle != null) {\n    if (this.fillSelectionRectangle) {\n      g2.setPaint(this.selectionFillPaint);\n      g2.fill(selectionRectangle);\n    }\n else {\n      g2.setPaint(this.selectionOutlinePaint);\n      g2.draw(selectionRectangle);\n    }\n  }\n}\n", "docstring": "draws zoom rectangle ( if present ) . the drawing is performed in xor mode , therefore when this method is called twice in a row , the second call will completely restore the state of the canvas .", "partition": "test"}
{"idx": "913", "code": "public static void loadAll(final JFrame parent,final IDebugger debugger,final IAddress offset,final int size){\n  checkArguments(parent,debugger,offset);\n  final CDumpAllWaiter waiter=new CDumpAllWaiter(debugger,offset,size);\n  CProgressDialog.showEndless(parent,\"Loading memory\" + \" ...\",waiter);\n  if (waiter.getException() != null) {\n    CUtilityFunctions.logException(waiter.getException());\n    final String innerMessage=\"E00078: \" + \"Could not load memory section\";\n    final String innerDescription=CUtilityFunctions.createDescription(String.format(\"The memory section starting at address \\'%s\\' could not loaded.\",offset.toHexString()),new String[]{\"There was a problem with the connection to the debug client.\"},new String[]{\"The memory data was not loaded.\"});\n    NaviErrorDialog.show(parent,innerMessage,innerDescription,waiter.getException());\n  }\n}\n", "docstring": "loads all data of a memory section .", "partition": "test"}
{"idx": "1379", "code": "private static Map<String,SnmpOid> buildPoolIndexMap(SnmpCachedData cached){\n  if (cached == null)   return Collections.emptyMap();\n  final SnmpOid[] indexes=cached.indexes;\n  final Object[] datas=cached.datas;\n  final int len=indexes.length;\n  final Map<String,SnmpOid> m=new HashMap<>(len);\n  for (int i=0; i < len; i++) {\n    final SnmpOid index=indexes[i];\n    if (index == null)     continue;\n    final MemoryPoolMXBean mpm=(MemoryPoolMXBean)datas[i];\n    if (mpm == null)     continue;\n    final String name=mpm.getName();\n    if (name == null)     continue;\n    m.put(name,index);\n  }\n  return m;\n}\n", "docstring": "builds a map pool - name = > pool - index from the snmptablehandler of the jvmmempooltable . optimized algorithm .", "partition": "test"}
{"idx": "1492", "code": "public boolean connect(final String address){\n  if (mBluetoothAdapter == null || address == null) {\n    Log.w(TAG,\"BluetoothAdapter not initialized or unspecified address.\");\n    return false;\n  }\n  if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress) && mBluetoothGatt != null) {\n    Log.d(TAG,\"Trying to use an existing mBluetoothGatt for connection.\");\n    if (mBluetoothGatt.connect()) {\n      mConnectionState=STATE_CONNECTING;\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n  final BluetoothDevice device=mBluetoothAdapter.getRemoteDevice(address);\n  if (device == null) {\n    Log.w(TAG,\"Device not found.  Unable to connect.\");\n    return false;\n  }\n  mBluetoothGatt=device.connectGatt(this,false,mGattCallback);\n  Log.d(TAG,\"Trying to create a new connection.\");\n  mBluetoothDeviceAddress=address;\n  mConnectionState=STATE_CONNECTING;\n  return true;\n}\n", "docstring": "connects to the gatt server hosted on the bluetooth le device .", "partition": "test"}
{"idx": "2375", "code": "public void delete() throws IOException {\n  close();\n  Utils.deleteContents(directory);\n}\n", "docstring": "closes the cache and deletes all of its stored values . this will delete all files in the cache directory including files that weren \"'\" t created by the cache .", "partition": "test"}
{"idx": "2902", "code": "public boolean isExpired(){\n  return (cookieExpiryDate != null && cookieExpiryDate.getTime() <= System.currentTimeMillis());\n}\n", "docstring": "returns true if this cookie has expired .", "partition": "test"}
{"idx": "3368", "code": "public void resetTextBoxIndexesExcept(Set<Integer> excludedList){\n  Set<Integer> unusedTextBoxIndexes=new HashSet<Integer>(points.getTextBoxIndexes());\n  unusedTextBoxIndexes.removeAll(excludedList);\n  for (  Integer index : unusedTextBoxIndexes) {\n    points.removeTextBox(index);\n  }\n}\n", "docstring": "resets all textbox indexes except those which are contained in the excludedlist", "partition": "test"}
{"idx": "824", "code": "public int hashCode(){\n  return _lowerNick.hashCode();\n}\n", "docstring": "returns the hash code of this user object .", "partition": "test"}
{"idx": "984", "code": "private void onHPChange(final int amount){\n  if (User.squaredDistanceTo(x,y) < HEARING_DISTANCE_SQ) {\n    if (amount > 0) {\n      addTextIndicator(\"+\" + amount,NotificationType.POSITIVE);\n    }\n else {\n      addTextIndicator(String.valueOf(amount),NotificationType.NEGATIVE);\n    }\n  }\n}\n", "docstring": "called when entity adjusts hp .", "partition": "test"}
{"idx": "3628", "code": "public static Date daysBefore(Date dateInst,int numDays){\n  if ((numDays <= 0) || (dateInst == null)) {\n    throw new IllegalArgumentException();\n  }\n  final Calendar cal=new GregorianCalendar();\n  cal.setTime(dateInst);\n  cal.add(Calendar.DAY_OF_YEAR,-numDays);\n  return cal.getTime();\n}\n", "docstring": "method to return a date instance which is exactly numdays days before the point in time designated by the input date .", "partition": "test"}
{"idx": "196", "code": "public void update(){\n  if (lastTime != -1L) {\n    long delta=System.nanoTime() - lastTime;\n    rollingAverage.addValue(delta);\n  }\n  lastTime=System.nanoTime();\n}\n", "docstring": "update the fps counter . < p / > call this method every frame !", "partition": "test"}
{"idx": "2221", "code": "private void queueUpSyncs(final Cursor contactsCursor){\n  ContactSyncEntry syncEntry=null;\n  while (contactsCursor.moveToNext()) {\n    if (syncEntry == null) {\n      syncEntry=new ContactSyncEntry(UPLOAD_BATCH_SIZE);\n    }\n    final String number=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\n    final String name=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\n    if (!TextUtils.isEmpty(number)) {\n      syncEntry.addNumber(numberToNational(number));\n      syncEntry.addName(name);\n      if (syncEntry.isFull()) {\n        Logger.d(TAG,\"Adding sync entry to queue\");\n        mSyncQueue.add(syncEntry);\n        syncEntry=null;\n      }\n    }\n  }\n}\n", "docstring": "method that hashes contacts and syncs them to server", "partition": "test"}
{"idx": "4001", "code": "public boolean equals(Object o){\n  if (o instanceof CoverageIntVdt) {\n    CoverageIntVdt civ=(CoverageIntVdt)o;\n    return ((attribute == civ.attribute) && (value == civ.value));\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "override the equals method . two coverageintvdts are equal if and only iff their respective attribute and value members are equal .", "partition": "test"}
{"idx": "2011", "code": "public int hashCode(){\n  long bits=Double.doubleToLongBits(m00);\n  bits=bits * 31 + Double.doubleToLongBits(m01);\n  bits=bits * 31 + Double.doubleToLongBits(m02);\n  bits=bits * 31 + Double.doubleToLongBits(m10);\n  bits=bits * 31 + Double.doubleToLongBits(m11);\n  bits=bits * 31 + Double.doubleToLongBits(m12);\n  return (((int)bits) ^ ((int)(bits >> 32)));\n}\n", "docstring": "returns the hashcode for this transform .", "partition": "test"}
{"idx": "3623", "code": "public void testSignerStringIdentityScope() throws Exception {\n  Signer s=new SignerStub(\"sss4\",IdentityScope.getSystemScope());\n  assertNotNull(s);\n  assertEquals(\"sss4\",s.getName());\n  assertSame(IdentityScope.getSystemScope(),s.getScope());\n  assertNull(s.getPrivateKey());\n  try {\n    Signer s2=new SignerStub(\"sss4\",IdentityScope.getSystemScope());\n    fail(\"expected KeyManagementException not thrown\");\n  }\n catch (  KeyManagementException e) {\n  }\n  Signer s2=new SignerStub(null);\n  assertNull(s2.getName());\n}\n", "docstring": "verify signer ( string , identityscope ) creates instance", "partition": "test"}
{"idx": "299", "code": "protected void removeMessageProcessor(MessageProcessor oldMessageProcessor){\nsynchronized (messageProcessors) {\n    if (messageProcessors.remove(oldMessageProcessor)) {\n      oldMessageProcessor.stop();\n    }\n  }\n}\n", "docstring": "removes a messageprocessor from this sipstack .", "partition": "test"}
{"idx": "251", "code": "public MessageTokenizer(IDiscordClient client,String content){\n  if (content == null)   throw new IllegalArgumentException(\"Content cannot be null!\");\n  if (content.length() == 0)   throw new IllegalArgumentException(\"Content must have length!\");\n  if (client == null)   throw new IllegalArgumentException(\"Client cannot be null!\");\n  this.content=content;\n  this.client=client;\n  stepForward(0);\n}\n", "docstring": "initializes with the string contents .", "partition": "test"}
{"idx": "2089", "code": "public static void dump(String message,StackTraceElement[] stackTrace){\n  dump(message,Arrays.asList(stackTrace));\n}\n", "docstring": "dumps the given message and stack to the system error console .", "partition": "test"}
{"idx": "3611", "code": "private void computeDoublesForAllZoomLevels(){\n  int numFrames=mSoundFile.getNumFrames();\n  int[] frameGains=mSoundFile.getFrameGains();\n  double[] smoothedGains=new double[numFrames];\n  if (numFrames == 1) {\n    smoothedGains[0]=frameGains[0];\n  }\n else   if (numFrames == 2) {\n    smoothedGains[0]=frameGains[0];\n    smoothedGains[1]=frameGains[1];\n  }\n else   if (numFrames > 2) {\n    smoothedGains[0]=(double)((frameGains[0] / 2.0) + (frameGains[1] / 2.0));\n    for (int i=1; i < numFrames - 1; i++) {\n      smoothedGains[i]=(double)((frameGains[i - 1] / 3.0) + (frameGains[i] / 3.0) + (frameGains[i + 1] / 3.0));\n    }\n    smoothedGains[numFrames - 1]=(double)((frameGains[numFrames - 2] / 2.0) + (frameGains[numFrames - 1] / 2.0));\n  }\n  double maxGain=1.0;\n  for (int i=0; i < numFrames; i++) {\n    if (smoothedGains[i] > maxGain) {\n      maxGain=smoothedGains[i];\n    }\n  }\n  double scaleFactor=1.0;\n  if (maxGain > 255.0) {\n    scaleFactor=255 / maxGain;\n  }\n  maxGain=0;\n  int gainHist[]=new int[256];\n  for (int i=0; i < numFrames; i++) {\n    int smoothedGain=(int)(smoothedGains[i] * scaleFactor);\n    if (smoothedGain < 0)     smoothedGain=0;\n    if (smoothedGain > 255)     smoothedGain=255;\n    if (smoothedGain > maxGain)     maxGain=smoothedGain;\n    gainHist[smoothedGain]++;\n  }\n  double minGain=0;\n  int sum=0;\n  while (minGain < 255 && sum < numFrames / 20) {\n    sum+=gainHist[(int)minGain];\n    minGain++;\n  }\n  sum=0;\n  while (maxGain > 2 && sum < numFrames / 100) {\n    sum+=gainHist[(int)maxGain];\n    maxGain--;\n  }\n  double[] heights=new double[numFrames];\n  double range=maxGain - minGain;\n  for (int i=0; i < numFrames; i++) {\n    double value=(smoothedGains[i] * scaleFactor - minGain) / range;\n    if (value < 0.0)     value=0.0;\n    if (value > 1.0)     value=1.0;\n    heights[i]=value * value;\n  }\n  algo(mSoundFile.getNumFrames());\n  totalZooms=algoValues.size() + 2;\n  mNumZoomLevels=totalZooms;\n  mLenByZoomLevel=new int[totalZooms];\n  mZoomFactorByZoomLevel=new double[totalZooms];\n  mValuesByZoomLevel=new double[totalZooms][];\n  mLenByZoomLevel[0]=numFrames * 2;\n  mZoomFactorByZoomLevel[0]=2.0;\n  mValuesByZoomLevel[0]=new double[mLenByZoomLevel[0]];\n  if (numFrames > 0) {\n    mValuesByZoomLevel[0][0]=0.5 * heights[0];\n    mValuesByZoomLevel[0][1]=heights[0];\n  }\n  for (int i=1; i < numFrames; i++) {\n    mValuesByZoomLevel[0][2 * i]=0.5 * (heights[i - 1] + heights[i]);\n    mValuesByZoomLevel[0][2 * i + 1]=heights[i];\n  }\n  mLenByZoomLevel[1]=numFrames;\n  mValuesByZoomLevel[1]=new double[mLenByZoomLevel[1]];\n  mZoomFactorByZoomLevel[1]=1.0;\n  for (int i=0; i < mLenByZoomLevel[1]; i++) {\n    mValuesByZoomLevel[1][i]=heights[i];\n  }\n  int location=0;\n  for (int j=2; j < totalZooms; j++) {\n    mLenByZoomLevel[j]=algoValues.get(location);\n    mValuesByZoomLevel[j]=new double[mLenByZoomLevel[j]];\n    mZoomFactorByZoomLevel[j]=mZoomFactorByZoomLevel[j - 1] / 1.5;\n    for (int i=0; i < mLenByZoomLevel[j]; i++) {\n      mValuesByZoomLevel[j][i]=0.5 * (mValuesByZoomLevel[j - 1][(int)(divisorValues.get(location) * i)] + mValuesByZoomLevel[j - 1][(int)(divisorValues.get(location) * i) + 1]);\n    }\n    location++;\n  }\n  Log.i(\"Scope\",\"Squeezed..!!\");\n  mInitialized=true;\n}\n", "docstring": "called once when a new sound file is added", "partition": "test"}
{"idx": "1498", "code": "public static byte[] decodeBase64(String base64Str){\n  return DatatypeConverter.parseBase64Binary(base64Str);\n}\n", "docstring": "decodes a base 64 encoded string into byte array .", "partition": "test"}
{"idx": "1452", "code": "@Override protected int lookForSelectablePosition(int position,boolean lookDown){\n  final ListAdapter adapter=mAdapter;\n  if (adapter == null || isInTouchMode()) {\n    return INVALID_POSITION;\n  }\n  final int count=adapter.getCount();\n  if (!mAreAllItemsSelectable) {\n    if (lookDown) {\n      position=Math.max(0,position);\n      while (position < count && !adapter.isEnabled(position)) {\n        position++;\n      }\n    }\n else {\n      position=Math.min(position,count - 1);\n      while (position >= 0 && !adapter.isEnabled(position)) {\n        position--;\n      }\n    }\n    if (position < 0 || position >= count) {\n      return INVALID_POSITION;\n    }\n    return position;\n  }\n else {\n    if (position < 0 || position >= count) {\n      return INVALID_POSITION;\n    }\n    return position;\n  }\n}\n", "docstring": "find a position that can be selected ( i . e . , is not a separator ) .", "partition": "test"}
{"idx": "3697", "code": "void startLocatingPhone(){\n  Intent intent=new Intent(sContext,LocationService.class);\n  intent.setAction(LocationService.START_SERVICE);\n  intent.putExtra(\"to\",this.mAnswerTo);\n  sContext.startService(intent);\n}\n", "docstring": "starts the geolocation service", "partition": "test"}
{"idx": "1132", "code": "public static void endTransaction(final CConnection connection) throws SQLException {\n  endTransaction(connection.getConnection());\n}\n", "docstring": "commits and finishes a formerly started transaction .", "partition": "test"}
{"idx": "2648", "code": "public static RequestSecurityTokenResponse parseXML(String xml) throws WSFederationException {\n  Document doc=XMLUtils.toDOMDocument(xml,debug);\n  Element root=doc.getDocumentElement();\n  return new RequestSecurityTokenResponse(root);\n}\n", "docstring": "returns requestsecuritytokenresponse object based on the xml document received from server . this method is used primarily at the client side . the schema of the xml document is defined in ws - trust .", "partition": "test"}
{"idx": "2169", "code": "void cancelIncludedOnly(){\n  if (!_showAllInput) {\n    _inputAllButton.doClick();\n  }\n  if (!_showAllOutput) {\n    _outputAllButton.doClick();\n  }\n  if (!_showAllAlign) {\n    _alignAllButton.doClick();\n  }\n}\n", "docstring": "cancels included only option", "partition": "test"}
{"idx": "848", "code": "public void build(String code,String customStatus){\n  try {\n    if (customStatus != null) {\n      result.put(resources.getString(R.string.intent_extra_status),customStatus);\n    }\n else {\n      result.put(resources.getString(R.string.intent_extra_status),resources.getString(R.string.shared_pref_default_status));\n    }\n    result.put(resources.getString(R.string.intent_extra_code),code);\n    operationListResult.put(result);\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON format.\" + e.toString());\n  }\n}\n", "docstring": "add operation results to the array to be returned .", "partition": "test"}
{"idx": "1326", "code": "@Override public void run(){\n  MultipleObjectsBundle data=generator.loadData();\n  if (LOG.isVerbose()) {\n    LOG.verbose(\"Writing output ...\");\n  }\n  try {\n    if (outputFile.exists() && LOG.isVerbose()) {\n      LOG.verbose(\"The file \" + outputFile + \" already exists, \"+ \"the generator result will be APPENDED.\");\n    }\n    try (OutputStreamWriter outStream=new FileWriter(outputFile,true)){\n      writeClusters(outStream,data);\n    }\n   }\n catch (  IOException e) {\n    throw new AbortException(\"IO Error in data generator.\",e);\n  }\n  if (LOG.isVerbose()) {\n    LOG.verbose(\"Done.\");\n  }\n}\n", "docstring": "runs the wrapper with the specified arguments .", "partition": "test"}
{"idx": "102", "code": "private Solution largestObjectiveValue(int objective,Population population){\n  Solution largest=null;\n  double value=Double.NEGATIVE_INFINITY;\n  for (  Solution solution : population) {\n    if (solution.getObjective(objective) > value) {\n      largest=solution;\n      value=solution.getObjective(objective);\n    }\n  }\n  return largest;\n}\n", "docstring": "returns the solution with the largest objective value for the given objective .", "partition": "test"}
{"idx": "3594", "code": "public void removeVetoableChangeListener(VetoableChangeListener listener){\n  if (listener != null) {\nsynchronized (this) {\n      if (vetoableSupport != null) {\n        vetoableSupport.removeVetoableChangeListener(listener);\n      }\n    }\n  }\n}\n", "docstring": "removes a vetoablechangelistener from the listener list . this method should be used to remove the vetoablechangelisteners that were registered for all vetoable properties of this class . < p > if listener is null , no exception is thrown and no action is performed .", "partition": "test"}
{"idx": "2873", "code": "private static void checkArgReferences(String typeSnippet,int numberOfArgs){\n  Matcher argRefMatcher=ARG_REF_PATTERN.matcher(typeSnippet);\n  while (argRefMatcher.find()) {\n    int index=Integer.parseInt(argRefMatcher.group(1),10) - 1;\n    Preconditions.checkArgument(index >= 0,\"%s not allowed, indices start at 1\",argRefMatcher.group(0));\n    Preconditions.checkArgument(index < numberOfArgs,\"%s too large for number of provided type mirrors\",argRefMatcher.group(0));\n  }\n}\n", "docstring": "check that all % d references in the given type snippet are within bounds .", "partition": "test"}
{"idx": "3762", "code": "@Override public Cursor swapCursor(Cursor newCursor){\n  mAlphabetIndexer.setCursor(newCursor);\n  return super.swapCursor(newCursor);\n}\n", "docstring": "overrides swapcursor to move the new cursor into the alphabetindex as well as the cursoradapter .", "partition": "test"}
{"idx": "3572", "code": "public Builder withTokenizer(Class<? extends TokenizerFactory> factory,Map<String,String> params) throws IOException {\n  Objects.requireNonNull(factory,\"Tokenizer factory may not be null\");\n  tokenizer.set(applyResourceLoader(newFactoryClassInstance(factory,applyDefaultParams(params))));\n  componentsAdded=true;\n  return this;\n}\n", "docstring": "uses the given tokenizer .", "partition": "test"}
{"idx": "4107", "code": "public static String[] unionArrays(String[] array1,String[] array2){\n  if (array1 == null) {\n    return array2;\n  }\n  if (array2 == null) {\n    return array1;\n  }\n  Set<String> set=new LinkedHashSet<>();\n  set.addAll(Arrays.asList(array1));\n  set.addAll(Arrays.asList(array2));\n  return set.toArray(new String[set.size()]);\n}\n", "docstring": "returns a union of 2 arrays , ensuring that each string exists only once .", "partition": "test"}
{"idx": "138", "code": "private void populateProfiles(final ProfileList profiles){\n  profilesComboBox.removeAllItems();\n  for (  Profile p : profiles) {\n    profilesComboBox.addItem(p);\n  }\n  final int count=profilesComboBox.getItemCount();\n  if (count != 0) {\n    profilesComboBox.setSelectedIndex(count - 1);\n  }\n}\n", "docstring": "populate the profiles combobox and select the default .", "partition": "test"}
{"idx": "4121", "code": "private void verifyTimestamp(X509Certificate cert) throws CertPathValidatorException {\n  String msg=\"timestamp\";\n  if (debug != null)   debug.println(\"---checking \" + msg + \":\"+ date.toString()+ \"...\");\n  try {\n    cert.checkValidity(date);\n  }\n catch (  CertificateExpiredException e) {\n    throw new CertPathValidatorException(msg + \" check failed\",e,null,-1,BasicReason.EXPIRED);\n  }\ncatch (  CertificateNotYetValidException e) {\n    throw new CertPathValidatorException(msg + \" check failed\",e,null,-1,BasicReason.NOT_YET_VALID);\n  }\n  if (debug != null)   debug.println(msg + \" verified.\");\n}\n", "docstring": "internal method to verify the timestamp on a certificate", "partition": "test"}
{"idx": "1742", "code": "@Override public void render(final int type,final Graphics2D g2,final float scaling,final boolean isFormGlyph){\n  glyphDisplay.setScalingValues(0,0,scaling);\n  final float OLDglyphScale=glyphScale;\n  if (isFormGlyph) {\n    glyphScale=scaling * glyphScale;\n  }\n  AffineTransform aff=null;\n  if (glyphScale != 1f) {\n    aff=g2.getTransform();\n    g2.scale(glyphScale,glyphScale);\n  }\n  glyphDisplay.setG2(g2);\n  glyphDisplay.paint(null,null,null);\n  if (aff != null) {\n    g2.setTransform(aff);\n  }\n  glyphScale=OLDglyphScale;\n}\n", "docstring": "draw the t3 glyph", "partition": "test"}
{"idx": "3733", "code": "protected void processFocusEvent(FocusEvent evt){\n  super.processFocusEvent(evt);\n  if (evt.getID() == FocusEvent.FOCUS_LOST) {\n    if (popup != null)     hidePopup();\n  }\n}\n", "docstring": "ensures that if we lose focus , the popup goes away .", "partition": "test"}
{"idx": "714", "code": "public boolean hasNext() throws IOException {\n  dataInputStream.mark(1);\n  int val=dataInputStream.read();\n  dataInputStream.reset();\n  return val != -1;\n}\n", "docstring": "checks if another objects is available by attempting to read another byte from the stream .", "partition": "test"}
{"idx": "2946", "code": "public AttributeListPanel(){\n  m_Table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  m_Table.setColumnSelectionAllowed(false);\n  m_Table.setPreferredScrollableViewportSize(new Dimension(250,150));\n  setLayout(new BorderLayout());\n  add(new JScrollPane(m_Table),BorderLayout.CENTER);\n}\n", "docstring": "creates the attribute selection panel with no initial instances .", "partition": "test"}
{"idx": "2027", "code": "private final void _writeUTF8Segments(byte[] utf8,int offset,int totalLen) throws IOException, JsonGenerationException {\n  do {\n    int len=Math.min(_outputMaxContiguous,totalLen);\n    _writeUTF8Segment(utf8,offset,len);\n    offset+=len;\n    totalLen-=len;\n  }\n while (totalLen > 0);\n}\n", "docstring": "method called when utf - 8 encoded ( but not yet escaped ! ) content is not guaranteed to fit in the output buffer after escaping ; as such , we just need to chunk writes .", "partition": "test"}
{"idx": "3867", "code": "@Override public char next(){\n  ++docPos;\n  if (docPos < segmentEnd || segmentEnd >= doc.getLength()) {\n    return text.next();\n  }\n  try {\n    doc.getText(segmentEnd,doc.getLength() - segmentEnd,text);\n  }\n catch (  BadLocationException e) {\n    throw new RuntimeException(e);\n  }\n  segmentEnd+=text.count;\n  return text.current();\n}\n", "docstring": "increments the iterator \"'\" s index by one and returns the character at the new index .", "partition": "test"}
{"idx": "1401", "code": "public boolean coordinateInZone(Id<ActivityFacility> zoneID,Coord coordinate){\n  Point point=MGC.xy2Point(coordinate.getX(),coordinate.getY());\n  return pointInZone(zoneID,point);\n}\n", "docstring": "determines if a given coordinate lies within a selected zone . the shape of the zone is defined by the respective zone geometry in the shape file", "partition": "test"}
{"idx": "1216", "code": "ManagedWindowDecorator(Window window,String windowId){\n  this.window=window;\n  name=\"system.\" + windowId;\n}\n", "docstring": "create a managed window decorator with an identity for a window .", "partition": "test"}
{"idx": "3518", "code": "public int position(){\n  return lineBuffer == null ? 0 : lineBuffer.length();\n}\n", "docstring": "gets the current column position of this log stream .", "partition": "test"}
{"idx": "3138", "code": "private Response<Bitmap> doParse(NetworkResponse response){\n  byte[] data=response.data;\n  Log.d(\"Checksum\",\"Decode\");\n  BitmapFactory.Options decodeOptions=new BitmapFactory.Options();\n  Bitmap bitmap=null;\n  Log.d(\"Checksum\",\"Decodess\");\n  decodeOptions.inJustDecodeBounds=true;\n  BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  int actualWidth=decodeOptions.outWidth;\n  int actualHeight=decodeOptions.outHeight;\n  int desiredWidth=getResizedDimension(mMaxWidth,mMaxHeight,actualWidth,actualHeight,mScaleType);\n  int desiredHeight=getResizedDimension(mMaxHeight,mMaxWidth,actualHeight,actualWidth,mScaleType);\n  decodeOptions.inJustDecodeBounds=false;\n  decodeOptions.inSampleSize=findBestSampleSize(actualWidth,actualHeight,desiredWidth,desiredHeight);\n  Bitmap tempBitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() > desiredHeight)) {\n    bitmap=Bitmap.createScaledBitmap(tempBitmap,desiredWidth,desiredHeight,true);\n    tempBitmap.recycle();\n  }\n else {\n    bitmap=tempBitmap;\n  }\n  if (bitmap == null) {\n    return Response.error(new ParseError(response));\n  }\n else {\n    return Response.success(bitmap,HttpHeaderParser.parseCacheHeaders(response));\n  }\n}\n", "docstring": "the real guts of parsenetworkresponse . broken out for readability .", "partition": "test"}
{"idx": "733", "code": "private void bulkLoad(double[] lmin,double[] lmax,List<Node> children,ArrayModifiableDBIDs ids,int start,int end,int dim,int level,int code){\n  if (dim == 0) {\n    DBIDArrayIter iter=ids.iter();\n    iter.seek(start);\n    NumberVector first=relation.get(iter);\n    iter.advance();\n    boolean degenerate=true;\n    loop:     for (; iter.getOffset() < end; iter.advance()) {\n      NumberVector other=relation.get(iter);\n      for (int d=0; d < lmin.length; d++) {\n        if (Math.abs(first.doubleValue(d) - other.doubleValue(d)) > 1E-15) {\n          degenerate=false;\n          break loop;\n        }\n      }\n    }\n    if (degenerate) {\n      double[] center=new double[lmin.length];\n      for (int d=0; d < lmin.length; d++) {\n        center[d]=lmin[d] * .5 + lmax[d] * .5 + shift[d];\n        if (center[d] > min[d] + width[d]) {\n          center[d]-=width[d];\n        }\n      }\n      children.add(new Node(code,center,end - start,level,null));\n      return;\n    }\n  }\n  if (dim == lmin.length) {\n    double[] center=new double[lmin.length];\n    for (int d=0; d < lmin.length; d++) {\n      center[d]=lmin[d] * .5 + lmax[d] * .5 + shift[d];\n      if (center[d] > min[d] + width[d]) {\n        center[d]-=width[d];\n      }\n    }\n    if (end - start < nmin) {\n      children.add(new Node(code,center,end - start,level,null));\n      return;\n    }\n else {\n      List<Node> newchildren=new ArrayList<>();\n      bulkLoad(lmin,lmax,newchildren,ids,start,end,0,level + 1,0);\n      children.add(new Node(code,center,end - start,level,newchildren));\n      return;\n    }\n  }\n else {\n    DBIDArrayIter siter=ids.iter(), eiter=ids.iter();\n    siter.seek(start);\n    eiter.seek(end - 1);\n    while (siter.getOffset() < eiter.getOffset()) {\n      if (getShiftedDim(relation.get(siter),dim,level) <= .5) {\n        siter.advance();\n        continue;\n      }\n      if (getShiftedDim(relation.get(eiter),dim,level) > 0.5) {\n        eiter.retract();\n        continue;\n      }\n      ids.swap(siter.getOffset(),eiter.getOffset() - 1);\n      siter.advance();\n      eiter.retract();\n    }\n    final int spos=siter.getOffset();\n    if (start < spos) {\n      final double tmp=lmax[dim];\n      lmax[dim]=lmax[dim] * .5 + lmin[dim] * .5;\n      bulkLoad(lmin,lmax,children,ids,start,spos,dim + 1,level,code);\n      lmax[dim]=tmp;\n    }\n    if (spos < end) {\n      final double tmp=lmin[dim];\n      lmin[dim]=lmax[dim] * .5 + lmin[dim] * .5;\n      bulkLoad(lmin,lmax,children,ids,spos,end,dim + 1,level,code | (1 << dim));\n      lmin[dim]=tmp;\n    }\n  }\n}\n", "docstring": "bulk load the tree", "partition": "test"}
{"idx": "462", "code": "public static Date parseDate(String dateValue,Collection dateFormats) throws DateParseException {\n  if (dateValue == null) {\n    throw new IllegalArgumentException(\"dateValue is null\");\n  }\n  if (dateFormats == null) {\n    dateFormats=DEFAULT_PATTERNS;\n  }\n  if (dateValue.length() > 1 && dateValue.startsWith(\"\\'\") && dateValue.endsWith(\"\\'\")) {\n    dateValue=dateValue.substring(1,dateValue.length() - 1);\n  }\n  SimpleDateFormat dateParser=null;\n  final Iterator formatIter=dateFormats.iterator();\n  while (formatIter.hasNext()) {\n    final String format=(String)formatIter.next();\n    if (dateParser == null) {\n      dateParser=new SimpleDateFormat(format,Locale.US);\n      dateParser.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n else {\n      dateParser.applyPattern(format);\n    }\n    try {\n      return dateParser.parse(dateValue);\n    }\n catch (    final ParseException pe) {\n    }\n  }\n  throw new DateParseException(\"Unable to parse the date \" + dateValue);\n}\n", "docstring": "parses the date value using the given date formats .", "partition": "test"}
{"idx": "4139", "code": "public void addButtonPressedListener(FieldConfigStringButtonInterface listener){\n  if (buttonPressedListenerList == null) {\n    buttonPressedListenerList=new ArrayList<FieldConfigStringButtonInterface>();\n  }\n  buttonPressedListenerList.add(listener);\n}\n", "docstring": "adds the button pressed listener .", "partition": "test"}
{"idx": "534", "code": "public AmqpMessage receiveNoWait() throws Exception {\n  checkClosed();\n  return prefetch.poll();\n}\n", "docstring": "if a message is already available in this receiver \"'\" s prefetch buffer then it is returned immediately otherwise this methods return null without waiting .", "partition": "test"}
{"idx": "286", "code": "protected Date compute(double value){\n  if (Double.isNaN(value)) {\n    return null;\n  }\n  long dateLong=(long)value;\n  Date date=new Date(dateLong);\n  Calendar cal=Calendar.getInstance();\n  cal.setTime(date);\n  return cal.getTime();\n}\n", "docstring": "computes the result for one input double value .", "partition": "test"}
{"idx": "1263", "code": "@Override public boolean exclude(String identifier){\n  return blacklist.contains(identifier);\n}\n", "docstring": "checks if the given identifier should be excluded .", "partition": "test"}
{"idx": "867", "code": "private void logExpiration(Entry e){\n  if (e.renewalsDone()) {\n    logger.log(Level.FINE,\"Reached desired expiration for lease {0}\",e.lease);\n  }\n else {\n    logger.log(Levels.FAILED,\"Lease {0} expired before reaching desired expiration\",e.lease);\n  }\n}\n", "docstring": "logs a lease expiration , distinguishing between expected and premature expirations .", "partition": "test"}
{"idx": "3845", "code": "@Override public Document newDocument(){\n  return new mf.org.apache.xerces.dom.DocumentImpl();\n}\n", "docstring": "non - preferred : use the getdomimplementation ( ) method instead of this one to get a dom level 2 domimplementation object and then use dom level 2 methods to create a dom document object .", "partition": "test"}
{"idx": "1037", "code": "private void fetchMyServiceCardsFromServer(){\n  RetroCallback retroCallback;\n  retroCallback=new RetroCallback(this);\n  retroCallback.setRequestId(HttpConstants.ApiResponseCodes.GET_MY_SERVICES);\n  retroCallbackList.add(retroCallback);\n  mYeloApi.getMyServiceCards(retroCallback);\n}\n", "docstring": "helper http function to get list of my service cards .", "partition": "test"}
{"idx": "3093", "code": "public ObjIdMap(){\n  this(11,0.75f);\n}\n", "docstring": "creates a new , empty map with the default initial capacity ( 11 buckets ) and load factor ( 0 . 75 ) .", "partition": "test"}
{"idx": "2256", "code": "public RelNode convertSelect(SqlSelect select,boolean top){\n  final SqlValidatorScope selectScope=validator.getWhereScope(select);\n  final Blackboard bb=createBlackboard(selectScope,null,top);\n  convertSelectImpl(bb,select);\n  return bb.root;\n}\n", "docstring": "converts a select statement \"'\" s parse tree into a relational expression .", "partition": "test"}
{"idx": "1479", "code": "public static boolean isZTE(){\n  return sBuildModel.startsWith(\"zte\");\n}\n", "docstring": "whether the stack is running on a zte device", "partition": "test"}
{"idx": "3642", "code": "public AMPrimaryMastHeadViewBean(String name){\n  super(name);\n}\n", "docstring": "creates an instance of base view bean object .", "partition": "test"}
{"idx": "1347", "code": "private Node deleteMax(Node x){\n  if (x.right == null)   return x.left;\n  x.right=deleteMax(x.right);\n  x.size=1 + size(x.left) + size(x.right);\n  x.height=1 + Math.max(height(x.left),height(x.right));\n  return balance(x);\n}\n", "docstring": "removes the largest key and associated value from the given subtree .", "partition": "test"}
{"idx": "3439", "code": "public void addPriorityHandler(WarningHandler handler){\n  _priorityHandlers.add(handler);\n}\n", "docstring": "add a warning event handler . high priority handlers only get high priority warnings , and they are notified first . other handlers gets all warnings after high priority handlers are notified .", "partition": "test"}
{"idx": "201", "code": "public static String[] parseDelimitedList(String list,char delimiter){\n  String delim=\"\" + delimiter;\n  StringTokenizer st=new StringTokenizer(list + delim + \" \",delim,true);\n  ArrayList<String> v=new ArrayList<String>();\n  String lastToken=\"\";\n  String word=\"\";\n  while (st.hasMoreTokens()) {\n    String tok=st.nextToken();\n    if (lastToken != null) {\n      if (tok.equals(delim)) {\n        word=word + lastToken;\n        if (lastToken.equals(delim))         tok=null;\n      }\n else {\n        if (!word.equals(\"\"))         v.add(word);\n        word=\"\";\n      }\n    }\n    lastToken=tok;\n  }\n  return v.toArray(new String[0]);\n}\n", "docstring": "parse a list of substrings separated by a given delimiter . the delimiter can also appear in substrings ( just double them ) : parsedelimitedstring ( \" this | is \" , \"'\" | \"'\" ) returns [ \" this \" , \" is \" ", "partition": "test"}
{"idx": "1371", "code": "public Object putResource(Object key,Object value){\n  return (objectCache.put(key,value));\n}\n", "docstring": "return the resource for the specified key", "partition": "test"}
{"idx": "1826", "code": "private void validateClassName(String className){\n  String nvalue=className.trim();\n  if (!nvalue.matches(CLASS_RE)) {\n    throw PropertyException.illegalPropertyValueException(this,className);\n  }\n}\n", "docstring": "do some basic checks to make sure the string representation is valid .", "partition": "test"}
{"idx": "1462", "code": "@SuppressWarnings(\"unchecked\") protected Object fromReflectionType(final Object value){\n  FieldDescriptor descriptor=getDescriptor();\n  if (descriptor.isRepeated()) {\n    if (descriptor.getJavaType() == FieldDescriptor.JavaType.MESSAGE || descriptor.getJavaType() == FieldDescriptor.JavaType.ENUM) {\n      final List result=new ArrayList();\n      for (      final Object element : (List)value) {\n        result.add(singularFromReflectionType(element));\n      }\n      return result;\n    }\n else {\n      return value;\n    }\n  }\n else {\n    return singularFromReflectionType(value);\n  }\n}\n", "docstring": "convert from the type used by the reflection accessors to the type used by native accessors . e . g . , for enums , the reflection accessors use enumvaluedescriptors but the native accessors use the generated enum type .", "partition": "test"}
{"idx": "148", "code": "private void updateLineList(){\n  if (horizontalLineRadiobutton.isSelected()) {\n    setHorizontalLineSelected();\n  }\n else {\n    setVerticalLineSelected();\n  }\n  updateButtonStates();\n}\n", "docstring": "updates the displayed list of lines .", "partition": "test"}
{"idx": "3794", "code": "private void remeasure(int width,int height){\n  MAX_UNEXPANDED_ALLDAY_HEIGHT=(int)(MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT * 4);\n  MAX_UNEXPANDED_ALLDAY_HEIGHT=Math.min(MAX_UNEXPANDED_ALLDAY_HEIGHT,height / 6);\n  MAX_UNEXPANDED_ALLDAY_HEIGHT=Math.max(MAX_UNEXPANDED_ALLDAY_HEIGHT,(int)MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT * 2);\n  mMaxUnexpandedAlldayEventCount=(int)(MAX_UNEXPANDED_ALLDAY_HEIGHT / MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT);\n  for (int day=0; day < mNumDays; day++) {\n    mEarliestStartHour[day]=25;\n    mHasAllDayEvent[day]=false;\n  }\n  int maxAllDayEvents=mMaxAlldayEvents;\n  mMinCellHeight=Math.max((height - DAY_HEADER_HEIGHT) / 24,(int)MIN_EVENT_HEIGHT);\n  if (mCellHeight < mMinCellHeight) {\n    mCellHeight=mMinCellHeight;\n  }\n  mFirstCell=DAY_HEADER_HEIGHT;\n  int allDayHeight=0;\n  if (maxAllDayEvents > 0) {\n    int maxAllAllDayHeight=height - DAY_HEADER_HEIGHT - MIN_HOURS_HEIGHT;\n    if (maxAllDayEvents == 1) {\n      allDayHeight=SINGLE_ALLDAY_HEIGHT;\n    }\n else     if (maxAllDayEvents <= mMaxUnexpandedAlldayEventCount) {\n      allDayHeight=maxAllDayEvents * MAX_HEIGHT_OF_ONE_ALLDAY_EVENT;\n      if (allDayHeight > MAX_UNEXPANDED_ALLDAY_HEIGHT) {\n        allDayHeight=MAX_UNEXPANDED_ALLDAY_HEIGHT;\n      }\n    }\n else {\n      if (mAnimateDayHeight != 0) {\n        allDayHeight=Math.max(mAnimateDayHeight,MAX_UNEXPANDED_ALLDAY_HEIGHT);\n      }\n else {\n        allDayHeight=(int)(maxAllDayEvents * MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT);\n        if (!mShowAllAllDayEvents && allDayHeight > MAX_UNEXPANDED_ALLDAY_HEIGHT) {\n          allDayHeight=(int)(mMaxUnexpandedAlldayEventCount * MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT);\n        }\n else         if (allDayHeight > maxAllAllDayHeight) {\n          allDayHeight=maxAllAllDayHeight;\n        }\n      }\n    }\n    mFirstCell=DAY_HEADER_HEIGHT + allDayHeight + ALLDAY_TOP_MARGIN;\n  }\n else {\n    mSelectionAllday=false;\n  }\n  mAlldayHeight=allDayHeight;\n  mGridAreaHeight=height - mFirstCell;\n  int allDayIconWidth=mExpandAlldayDrawable.getIntrinsicWidth();\n  mExpandAllDayRect.left=Math.max((mHoursWidth - allDayIconWidth) / 2,EVENT_ALL_DAY_TEXT_LEFT_MARGIN);\n  mExpandAllDayRect.right=Math.min(mExpandAllDayRect.left + allDayIconWidth,mHoursWidth - EVENT_ALL_DAY_TEXT_RIGHT_MARGIN);\n  mExpandAllDayRect.bottom=mFirstCell - EXPAND_ALL_DAY_BOTTOM_MARGIN;\n  mExpandAllDayRect.top=mExpandAllDayRect.bottom - mExpandAlldayDrawable.getIntrinsicHeight();\n  mNumHours=mGridAreaHeight / (mCellHeight + HOUR_GAP);\n  mEventGeometry.setHourHeight(mCellHeight);\n  final long minimumDurationMillis=(long)(MIN_EVENT_HEIGHT * DateUtils.MINUTE_IN_MILLIS / (mCellHeight / 60.0f));\n  Event.computePositions(mEvents,minimumDurationMillis);\n  mMaxViewStartY=HOUR_GAP + 24 * (mCellHeight + HOUR_GAP) - mGridAreaHeight;\n  if (DEBUG) {\n    Log.e(TAG,\"mViewStartY: \" + mViewStartY);\n    Log.e(TAG,\"mMaxViewStartY: \" + mMaxViewStartY);\n  }\n  if (mViewStartY > mMaxViewStartY) {\n    mViewStartY=mMaxViewStartY;\n    computeFirstHour();\n  }\n  if (mFirstHour == -1) {\n    initFirstHour();\n    mFirstHourOffset=0;\n  }\n  if (mFirstHourOffset >= mCellHeight + HOUR_GAP) {\n    mFirstHourOffset=mCellHeight + HOUR_GAP - 1;\n  }\n  mViewStartY=mFirstHour * (mCellHeight + HOUR_GAP) - mFirstHourOffset;\n  final int eventAreaWidth=mNumDays * (mCellWidth + DAY_GAP);\n  if (mSelectedEvent != null && mLastPopupEventID != mSelectedEvent.id) {\n    mPopup.dismiss();\n  }\n  mPopup.setWidth(eventAreaWidth - 20);\n  mPopup.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);\n}\n", "docstring": "measures the space needed for various parts of the view after loading new events . this can change if there are all - day events .", "partition": "test"}
{"idx": "1030", "code": "@SuppressWarnings({\"unchecked\"}) @Override default LazyFutureStream<U> concat(final Stream<? extends U> other){\n  return fromStream(Stream.concat(StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(),Spliterator.ORDERED),false),StreamSupport.stream(Spliterators.spliteratorUnknownSize(other.iterator(),Spliterator.ORDERED),false)));\n}\n", "docstring": "concatenate two streams . / / ( 1 , 2 , 3 , 4 , 5 , 6 ) lazyfuturestream . of ( 1 , 2 , 3 ) . concat ( lazyfuturestream . of ( 4 , 5 , 6 ) )", "partition": "test"}
{"idx": "1183", "code": "public AABB merge(AABB other){\n  minX=Math.min(minX,other.minX);\n  maxX=Math.max(maxX,other.maxX);\n  minY=Math.min(minY,other.minY);\n  maxY=Math.max(maxY,other.maxY);\n  minZ=Math.min(minZ,other.minZ);\n  maxZ=Math.max(maxZ,other.maxZ);\n  return this;\n}\n", "docstring": "computes an aabb that contains both this and other and stores it in this .", "partition": "test"}
{"idx": "1771", "code": "public void slide(SLIDE slide){\n  if (slide == SLIDE.UP) {\n    if (!isPanelShown()) {\n      int position=0;\n      if (items != null) {\n        position=items.size() / 2;\n      }\n      slideUp(position);\n    }\n  }\n else {\n    hidePanelPickerUI();\n  }\n}\n", "docstring": "slide the panel to the desired direction .", "partition": "test"}
{"idx": "3685", "code": "@Override public final void sample(){\n  _value=_acquireCount.get() - _releaseCount.get();\n}\n", "docstring": "return the probe \"'\" s next average .", "partition": "test"}
{"idx": "629", "code": "public java.lang.Object newInstance() throws java.lang.InstantiationException, java.lang.IllegalAccessException {\n  Object o=newInstanceImpl();\n  if (o == null) {\n    throw new InstantiationException();\n  }\n  return o;\n}\n", "docstring": "creates a new instance of a class .", "partition": "test"}
{"idx": "504", "code": "public InMemoryCursor(String[] columnNames){\n  mCurrentPosition=-1;\n  mColumnNames=columnNames;\n}\n", "docstring": "creates a new cursor setting the columns names that will be used by this cursor . the length of this array determines the number of columns that the cursor can handle . filling that below this number will set the rest of the values to null , and all items above it will be ignored .", "partition": "test"}
{"idx": "3683", "code": "public void removeScanningCallback(OneSheeldScanningCallback scanningCallback){\n  if (scanningCallback != null && scanningCallbacks.contains(scanningCallback))   scanningCallbacks.remove(scanningCallback);\n}\n", "docstring": "remove a scanning callback .", "partition": "test"}
{"idx": "1336", "code": "public void testScreenshot() throws Exception {\n  Log.d(LOG_TAG,\"starting testScreenshot\");\n  ScreenshotStubActivity activity=getActivity();\n  assertNotNull(activity);\n  File screenshotDir=getScreenshotDir();\n  NewScreenshotObserver observer=new NewScreenshotObserver(screenshotDir.getAbsolutePath());\n  observer.startWatching();\n  takeScreenshot();\n  if (observer.getCreatedPath() == null) {\nsynchronized (observer) {\n      observer.wait(SCREEN_WAIT_TIME_SEC * 1000);\n    }\n  }\n  assertNotNull(String.format(\"Could not find screenshot after %d seconds\",SCREEN_WAIT_TIME_SEC),observer.getCreatedPath());\n  File screenshotFile=new File(screenshotDir,observer.getCreatedPath());\n  try {\n    assertTrue(String.format(\"Detected new screenshot %s but its not a file\",screenshotFile.getName()),screenshotFile.isFile());\n    assertTrue(String.format(\"Detected new screenshot %s but its not an image\",screenshotFile.getName()),isValidImage(screenshotFile));\n  }\n  finally {\n    screenshotFile.delete();\n  }\n}\n", "docstring": "a simple test for screenshots that launches an activity , injects the key event combo to trigger the screenshot , and verifies the screenshot was taken successfully .", "partition": "test"}
{"idx": "734", "code": "protected ArrayList<float[]> _forwardPoly(float[] rawllpts,int ltype,int nsegs,boolean isFilled){\n  boolean DEBUG=Debug.debugging(\"proj\");\n  int len=rawllpts.length >>> 1;\n  if (len < 2)   return new ArrayList<float[]>(0);\n  if (isComplicatedLineType(ltype))   return doPolyDispatch(rawllpts,ltype,nsegs,isFilled);\n  int invalid_count=0;\n  boolean curr_invalid, prev_invalid=false;\n  Point temp=new Point();\n  AzimuthVar az_first=null, az_save=null, azVar=new AzimuthVar();\n  ArrayList<AzimuthVar> sections=new ArrayList<AzimuthVar>(128);\n  float[] x_, xs=new float[len];\n  float[] y_, ys=new float[len];\n  _forward(rawllpts[0],rawllpts[1],temp,azVar);\n  xs[0]=temp.x;\n  ys[0]=temp.y;\n  prev_invalid=azVar.invalid_forward;\n  if (prev_invalid) {\n    ++invalid_count;\n  }\n else {\n    azVar.index=0;\n    azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[0],rawllpts[1]);\n    if (!isFilled) {\n      sections.add(azVar);\n    }\n else {\n      az_first=azVar;\n    }\n    azVar=new AzimuthVar();\n  }\n  int i=0, j=0;\n  for (i=1, j=2; i < len; i++, j+=2) {\n    azVar.invalid_forward=false;\n    _forward(rawllpts[j],rawllpts[j + 1],temp,azVar);\n    curr_invalid=azVar.invalid_forward;\n    xs[i]=temp.x;\n    ys[i]=temp.y;\n    if (!curr_invalid && prev_invalid) {\n      azVar.index=i - 1;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n      azVar=new AzimuthVar();\n    }\n else     if (curr_invalid) {\n      if (!prev_invalid) {\n        azVar.index=i;\n        if (isFilled && (invalid_count == 0)) {\n          az_save=azVar;\n        }\n else {\n          sections.add(azVar);\n        }\n        azVar=new AzimuthVar();\n      }\n      ++invalid_count;\n    }\n    prev_invalid=curr_invalid;\n  }\n  if (invalid_count == 0) {\n    ArrayList<float[]> ret_val=new ArrayList<float[]>(2);\n    ret_val.add(xs);\n    ret_val.add(ys);\n    return ret_val;\n  }\n  if (invalid_count == len) {\n    return new ArrayList<float[]>(0);\n  }\n  if (!prev_invalid) {\n    if (isFilled && (az_save != null)) {\n      int l=az_save.index;\n      x_=new float[len + l];\n      y_=new float[len + l];\n      System.arraycopy(xs,0,x_,0,len);\n      System.arraycopy(ys,0,y_,0,len);\n      System.arraycopy(xs,0,x_,len,l);\n      System.arraycopy(ys,0,y_,len,l);\n      az_save.index=len + l;\n      sections.add(az_save);\n      xs=x_;\n      ys=y_;\n    }\n else {\n      if (DEBUG && isFilled && (az_save == null)) {\n        Debug.output(\"AA, filled, no-wrap!\");\n      }\n      azVar.index=i;\n      j=rawllpts.length;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n    }\n  }\n else   if (az_save != null) {\n    if (DEBUG)     Debug.output(\"DD, filled!\");\n    sections.add(az_first);\n    sections.add(az_save);\n  }\n  int size=sections.size();\n  ArrayList<float[]> ret_val=new ArrayList<float[]>(size);\n  if (isFilled && (len > 2)) {\n    generateFilledPoly(xs,ys,sections,ret_val);\n    return ret_val;\n  }\n  for (j=0; j < size; j+=2) {\n    AzimuthVar az1=(AzimuthVar)sections.get(j);\n    AzimuthVar az2=(AzimuthVar)sections.get(j + 1);\n    int off1=az1.index;\n    int off2=az2.index;\n    int l=off2 - off1;\n    x_=new float[l];\n    y_=new float[l];\n    System.arraycopy(xs,off1,x_,0,l);\n    System.arraycopy(ys,off1,y_,0,l);\n    ret_val.add(x_);\n    ret_val.add(y_);\n  }\n  return ret_val;\n}\n", "docstring": "forward project a lat / lon poly . this is a complex method . please read the in - code documentation for an explanation of the algorithm .", "partition": "test"}
{"idx": "655", "code": "public String toString(){\n  String string=caller;\n  if (level > 0 || thread != -1) {\n    string+=\"[\";\n  }\n  if (level > 0) {\n    string+=level;\n  }\n  if (thread != -1) {\n    string+=\",\" + thread;\n  }\n  if (level > 0 || thread != -1) {\n    string+=\"]\";\n  }\n  string+=\":\";\n  if (spawnMessage) {\n    string+=\">\";\n  }\n  if (answer.length() > 0) {\n    string+=answer + \"=\";\n  }\n  if (callee.length() > 0) {\n    string+=callee + \".\";\n  }\n  string+=message;\n  if (returnsInstantly) {\n    string+=\"&\";\n  }\n  return string;\n}\n", "docstring": "returns a string representation of the message data . todo : broadcasts , ( answer ) note number , escaping", "partition": "test"}
{"idx": "864", "code": "public static LatLon rhumbEndPosition(LatLon p,double rhumbAzimuthRadians,double pathLengthRadians){\n  if (p == null) {\n    throw new IllegalArgumentException(\"LatLon Is Null\");\n  }\n  return rhumbEndPosition(p,Angle.fromRadians(rhumbAzimuthRadians),Angle.fromRadians(pathLengthRadians));\n}\n", "docstring": "computes the location on a rhumb line with the given starting location , rhumb azimuth , and arc distance along the line .", "partition": "test"}
{"idx": "4017", "code": "public static double sampleSkew(int size,double moment3,double sampleVariance){\n  int n=size;\n  double s=Math.sqrt(sampleVariance);\n  double m3=moment3 * n;\n  return n * m3 / ((n - 1) * (n - 2) * s* s* s);\n}\n", "docstring": "returns the sample skew of a data sequence . ref : r . r . sokal , f . j . rohlf , biometry : the principles and practice of statistics in biological research ( w . h . freeman and company , new york , 1998 , 3rd edition ) p . 114 - 115 .", "partition": "test"}
{"idx": "2389", "code": "public static Path createDirectory(final Path parent,final String folderName){\n  final File file=new File(parent.toFile(),folderName);\n  if (!file.exists()) {\n    if (!file.mkdir()) {\n      throw new RuntimeException(\"Error while trying to create folder at \" + parent + \" with \"+ folderName+ \".\");\n    }\n  }\n  file.deleteOnExit();\n  return file.toPath();\n}\n", "docstring": "creates a new directory with the given parent folder and folder name . the newly created folder will be deleted on graceful vm shutdown .", "partition": "test"}
{"idx": "2241", "code": "public void generate(BatchEnvironment env,ClassDefinition cdef,File destDir){\n  RemoteClass remoteClass=RemoteClass.forClass(env,cdef);\n  if (remoteClass == null)   return;\n  RMIGenerator gen;\n  try {\n    gen=new RMIGenerator(env,cdef,destDir,remoteClass,version);\n  }\n catch (  ClassNotFound e) {\n    env.error(0,\"rmic.class.not.found\",e.name);\n    return;\n  }\n  gen.generate();\n}\n", "docstring": "generate the source files for the stub and / or skeleton classes needed by rmi for the given remote implementation class .", "partition": "test"}
{"idx": "2317", "code": "public void testSendReceive() throws Exception {\n  messages.clear();\n  for (int i=0; i < data.length; i++) {\n    Message message=session.createTextMessage(data[i]);\n    message.setStringProperty(\"stringProperty\",data[i]);\n    message.setIntProperty(\"intProperty\",i);\n    if (verbose) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"About to send a message: \" + message + \" with text: \"+ data[i]);\n      }\n    }\n    sendToProducer(producer,producerDestination,message);\n    messageSent();\n  }\n  assertMessagesAreReceived();\n  LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n}\n", "docstring": "sends and consumes the messages .", "partition": "test"}
{"idx": "678", "code": "private void writeIndent(int times) throws IOException {\n  for (int i=options.getBaseIndent() + times; i > 0; i--) {\n    writer.write(options.getIndent());\n  }\n}\n", "docstring": "writes indents and automatically includes the baseindend from the options .", "partition": "test"}
{"idx": "3598", "code": "public static String convertFromUtf32(int[] text,int startPos,int endPos){\n  StringBuilder sb=new StringBuilder();\n  for (int i=startPos; i < endPos; i++) {\n    sb.append(convertFromUtf32ToCharArray(text[i]));\n  }\n  return sb.toString();\n}\n", "docstring": "/ converts a utf32 code point sequence to a string with the corresponding character ( s ) .", "partition": "test"}
{"idx": "7", "code": "public boolean onScheduleAsLibrary(Config config,Config runtime,IScheduler scheduler,PackingPlan packing){\n  boolean ret=false;\n  try {\n    scheduler.initialize(config,runtime);\n    ret=scheduler.onSchedule(packing);\n    if (ret) {\n      ret=SchedulerUtils.setLibSchedulerLocation(runtime,scheduler,false);\n    }\n else {\n      LOG.severe(\"Failed to invoke IScheduler as library\");\n    }\n  }\n  finally {\n    scheduler.close();\n  }\n  return ret;\n}\n", "docstring": "invoke the onscheduler ( ) in ischeduler directly as a library", "partition": "test"}
{"idx": "3953", "code": "private static boolean createBooleanSetting(final Map<String,String> rawSettings,final String settingName,final boolean defaultValue){\n  final String settingString=rawSettings.get(settingName);\n  if (settingString == null) {\n    return defaultValue;\n  }\n else {\n    try {\n      return Boolean.parseBoolean(settingString);\n    }\n catch (    final NumberFormatException exception) {\n      CUtilityFunctions.logException(exception);\n      return defaultValue;\n    }\n  }\n}\n", "docstring": "turns a settings string value into a boolean value .", "partition": "test"}
{"idx": "3667", "code": "public String syllabify(String phoneString){\n  LinkedList<String> phoneList=splitIntoAllophones(phoneString);\n  syllabify(phoneList);\n  StringBuilder sb=new StringBuilder();\n  for (  String p : phoneList) {\n    if (sb.length() > 0)     sb.append(\" \");\n    sb.append(p);\n  }\n  return sb.toString();\n}\n", "docstring": "syllabify a phonetic string , marking syllable boundaries with dash characters in the output . if the input marks stressed vowels with a suffix \" 1 \" , these marks are removed , and single quotes ( \"'\" ) are inserted at the beginning of the corresponding syllable .", "partition": "test"}
{"idx": "1967", "code": "protected JsonEncoding findEncoding(MediaType mediaType,MultivaluedMap<String,Object> httpHeaders){\n  return JsonEncoding.UTF8;\n}\n", "docstring": "helper method to use for determining desired output encoding . for now , will always just use utf - 8 . . .", "partition": "test"}
{"idx": "3766", "code": "public WritableRaster createWritableChild(int x,int y,int width,int height,int x0,int y0,int bandList[]){\n  if (x < this.minX) {\n    throw new RasterFormatException(\"x lies outside raster\");\n  }\n  if (y < this.minY) {\n    throw new RasterFormatException(\"y lies outside raster\");\n  }\n  if ((x + width < x) || (x + width > this.minX + this.width)) {\n    throw new RasterFormatException(\"(x + width) is outside of Raster\");\n  }\n  if ((y + height < y) || (y + height > this.minY + this.height)) {\n    throw new RasterFormatException(\"(y + height) is outside of Raster\");\n  }\n  SampleModel sm;\n  if (bandList != null)   sm=sampleModel.createSubsetSampleModel(bandList);\n else   sm=sampleModel;\n  int deltaX=x0 - x;\n  int deltaY=y0 - y;\n  return new ShortBandedRaster(sm,dataBuffer,new Rectangle(x0,y0,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),this);\n}\n", "docstring": "creates a writable subraster given a region of the raster . the x and y coordinates specify the horizontal and vertical offsets from the upper - left corner of this raster to the upper - left corner of the subraster . a subset of the bands of the parent raster may be specified . if this is null , then all the bands are present in the subraster . a translation to the subraster may also be specified . note that the subraster will reference the same databuffers as the parent raster , but using different offsets .", "partition": "test"}
{"idx": "905", "code": "public ZoneRulesBuilder addWindow(ZoneOffset standardOffset,LocalDateTime until,TimeDefinition untilDefinition){\n  Objects.requireNonNull(standardOffset,\"standardOffset\");\n  Objects.requireNonNull(until,\"until\");\n  Objects.requireNonNull(untilDefinition,\"untilDefinition\");\n  TZWindow window=new TZWindow(standardOffset,until,untilDefinition);\n  if (windowList.size() > 0) {\n    TZWindow previous=windowList.get(windowList.size() - 1);\n    window.validateWindowOrder(previous);\n  }\n  windowList.add(window);\n  return this;\n}\n", "docstring": "adds a window to the builder that can be used to filter a set of rules . < p > this method defines and adds a window to the zone where the standard offset is specified . the window limits the effect of subsequent additions of transition rules or fixed savings . if neither rules or fixed savings are added to the window then the window will default to no savings . < p > each window must be added sequentially , as the start instant of the window is derived from the until instant of the previous window .", "partition": "test"}
{"idx": "970", "code": "public static LocalGitRepo fromCurrentDir(String remoteUrl) throws ValidationException {\n  Git git;\n  File gitDir=new File(\".\");\n  try {\n    git=Git.open(gitDir);\n  }\n catch (  RepositoryNotFoundException rnfe) {\n    String fullPathOfCurrentDir=pathOf(gitDir);\n    File gitRoot=getGitRootIfItExistsInOneOfTheParentDirectories(new File(fullPathOfCurrentDir));\n    String summary;\n    List<String> messages=new ArrayList<String>();\n    if (gitRoot == null) {\n      summary=\"Releases can only be performed from Git repositories.\";\n      messages.add(summary);\n      messages.add(fullPathOfCurrentDir + \" is not a Git repository.\");\n    }\n else {\n      summary=\"The release plugin can only be run from the root folder of your Git repository\";\n      messages.add(summary);\n      messages.add(fullPathOfCurrentDir + \" is not the root of a Gir repository\");\n      messages.add(\"Try running the release plugin from \" + pathOf(gitRoot));\n    }\n    throw new ValidationException(summary,messages);\n  }\ncatch (  Exception e) {\n    throw new ValidationException(\"Could not open git repository. Is \" + pathOf(gitDir) + \" a git repository?\",Arrays.asList(\"Exception returned when accessing the git repo:\",e.toString()));\n  }\n  return new LocalGitRepo(git,remoteUrl);\n}\n", "docstring": "uses the current working dir to open the git repository .", "partition": "test"}
{"idx": "2253", "code": "void eventPreModify(ActionType type,long position,boolean isSingle){\n  if (type != currentActionType || !isSingle || System.currentTimeMillis() - previousTime > MERGE_TIME || (type == ActionType.INSERT || type == ActionType.OVERWRITE) && actionExclusiveEnd() != position || type == ActionType.DELETE && actionPosition() != position && actionPosition() - 1L != position) {\n    startAction(type,isSingle);\n  }\n else {\n    isBackspace=actionPosition() > position;\n  }\n  if (isSingle && type == ActionType.INSERT) {\n    updateNewRange(position);\n    previousTime=System.currentTimeMillis();\n  }\n}\n", "docstring": "user event : single / block delete / insert / overwrite . called before any change has been done", "partition": "test"}
{"idx": "3890", "code": "public int read(char cbuf[],int offset,int length) throws IOException {\n  return sd.read(cbuf,offset,length);\n}\n", "docstring": "reads characters into a portion of an array .", "partition": "test"}
{"idx": "1477", "code": "String decodeTextValue(byte[] data) throws IOException {\n  boolean isCompressed=((data.length > 1) && (data[0] == TEXT_COMPRESSION_HEADER[0]) && (data[1] == TEXT_COMPRESSION_HEADER[1]));\n  if (isCompressed) {\n    StringBuilder textBuf=new StringBuilder(data.length);\n    int dataStart=TEXT_COMPRESSION_HEADER.length;\n    int dataEnd=dataStart;\n    boolean inCompressedMode=true;\n    while (dataEnd < data.length) {\n      if (data[dataEnd] == (byte)0x00) {\n        decodeTextSegment(data,dataStart,dataEnd,inCompressedMode,textBuf);\n        inCompressedMode=!inCompressedMode;\n        ++dataEnd;\n        dataStart=dataEnd;\n      }\n else {\n        ++dataEnd;\n      }\n    }\n    decodeTextSegment(data,dataStart,dataEnd,inCompressedMode,textBuf);\n    return textBuf.toString();\n  }\n  return decodeUncompressedText(data,getCharset());\n}\n", "docstring": "decodes a compressed or uncompressed text value .", "partition": "test"}
{"idx": "359", "code": "private void initKeyboardButtons(KeyboardView view){\n  mButtons=new ArrayList<>();\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_0));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_1));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_2));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_3));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_4));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_5));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_6));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_7));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_8));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_9));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_clear));\n  for (  View button : mButtons) {\n    button.setOnClickListener(this);\n  }\n}\n", "docstring": "init the keyboard buttons ( onclicklistener )", "partition": "test"}
{"idx": "3959", "code": "private void initPattern(){\n  StringBuffer patternTemplateRegex=new StringBuffer();\n  logger.debug(\"Get placeholder matcher\");\n  Matcher placeholderMatcher=getPlaceholderMatcher();\n  logger.debug(\"Replace all placeholder with regex group capture\");\n  while (placeholderMatcher.find()) {\n    String group=placeholderMatcher.group(1);\n    if (!groups.contains(group)) {\n      logger.trace(\"New group found, add it, replace with a capture group\");\n      groups.add(group);\n      String groupRegex=getGroupRegex(group);\n      placeholderMatcher.appendReplacement(patternTemplateRegex,Matcher.quoteReplacement(\"(?<\" + group + \">\"+ groupRegex+ \")\"));\n    }\n else {\n      logger.trace(\"Existing group found, replace with a back reference\");\n      placeholderMatcher.appendReplacement(patternTemplateRegex,Matcher.quoteReplacement(\"\\\\\\\\k<\" + group + \">\"));\n    }\n  }\n  placeholderMatcher.appendTail(patternTemplateRegex);\n  String patternRegex=patternTemplateRegex.toString();\n  logger.debug(\"pattern:\" + patternRegex);\n  pattern=Pattern.compile(patternRegex);\n}\n", "docstring": "initialize the pattern to match files .", "partition": "test"}
{"idx": "4126", "code": "public double reduceTo(int width,int height,double limit){\n  int w=getIconWidth();\n  int h=getIconHeight();\n  double scale=1.0;\n  if (w > width) {\n    scale=((double)width) / w;\n  }\n  if (h > height) {\n    scale=Math.min(scale,((double)height) / h);\n  }\n  if (scale < 1) {\n    if (limit > 0.0) {\n      scale=Math.max(scale,limit);\n    }\n    AffineTransform t=AffineTransform.getScaleInstance(scale,scale);\n    transformImage((int)Math.ceil(scale * w),(int)Math.ceil(scale * h),t,null);\n  }\n  return scale;\n}\n", "docstring": "if necessary , reduce this image to within \"'\" width \"'\" x \"'\" height \"'\" dimensions . limit the reduction by \"'\" limit \"'\"", "partition": "test"}
{"idx": "2804", "code": "void renderNormal(){\n  glEnable(GL_DEPTH_TEST);\n  glUseProgram(this.normalProgram);\n  glUniformMatrix4fv(viewMatrixUniform,false,viewMatrix.get(matrixBuffer));\n  glUniformMatrix4fv(projMatrixUniform,false,projMatrix.get(matrixBuffer));\n  glUniformMatrix3fv(normalMatrixUniform,false,normalMatrix.get(matrixBuffer));\n  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,fbo);\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  glBindBuffer(GL_ARRAY_BUFFER,this.cubeVbo);\n  glEnableVertexAttribArray(0);\n  glVertexAttribPointer(0,3,GL_FLOAT,false,0,0L);\n  glEnableVertexAttribArray(1);\n  glVertexAttribPointer(1,3,GL_FLOAT,false,0,normalsOffset);\n  glDrawArrays(GL_TRIANGLES,0,numVertices);\n  glDisableVertexAttribArray(0);\n  glDisableVertexAttribArray(1);\n  glBindBuffer(GL_ARRAY_BUFFER,0);\n  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,0);\n  glUseProgram(0);\n}\n", "docstring": "render the normals into a texture .", "partition": "test"}
{"idx": "3396", "code": "private void updateRadioLinks(){\n  m_advanceDataSetFirst.setEnabled(m_GeneratorPropertyPanel.getEditorActive());\n  m_advanceIteratorFirst.setEnabled(m_GeneratorPropertyPanel.getEditorActive());\n  if (m_Exp != null) {\n    if (!m_GeneratorPropertyPanel.getEditorActive()) {\n      m_Exp.setAdvanceDataSetFirst(true);\n    }\n else {\n      m_Exp.setAdvanceDataSetFirst(m_advanceDataSetFirst.isSelected());\n    }\n  }\n}\n", "docstring": "updates the primary loop iteration control of the experiment", "partition": "test"}
{"idx": "423", "code": "@Override public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (!(obj instanceof PrincipalEntry))   return false;\n  PrincipalEntry that=(PrincipalEntry)obj;\n  return (principalClass.equals(that.principalClass) && principalName.equals(that.principalName));\n}\n", "docstring": "test for equality between the specified object and this object . two principalentries are equal if their class and name values are equal .", "partition": "test"}
{"idx": "1682", "code": "public DGeneralNameChooser(JFrame parent,String title,GeneralName generalName){\n  super(parent,title,ModalityType.DOCUMENT_MODAL);\n  initComponents(generalName);\n}\n", "docstring": "constructs a new dgeneralnamechooser dialog .", "partition": "test"}
{"idx": "4085", "code": "public static void describeShapeDetail(Shape shape,double flattening){\n  PathIterator pi2=shape.getPathIterator(null);\n  FlatteningPathIterator pi=new FlatteningPathIterator(pi2,flattening);\n  double[] coords=new double[6];\n  int pointCount=0;\n  Debug.output(\" -- start describeShapeDetail with flattening[\" + flattening + \"]\");\n  while (!pi.isDone()) {\n    int type=pi.currentSegment(coords);\n    Debug.output(\" Shape point [\" + type + \"] (\"+ (pointCount++)+ \") \"+ coords[0]+ \", \"+ coords[1]);\n    pi.next();\n  }\n  Debug.output(\" -- end (\" + pointCount + \")\");\n}\n", "docstring": "utility method that iterates over a shape object and prints out the points . the flattening is used for a flatteningpathiterator , controlling the scope of the path traversal .", "partition": "test"}
{"idx": "3034", "code": "public void rewind(){\nsynchronized (used) {\n    for (    ParameterPair pair : used) {\n      current.addParameter(pair.option,pair.value);\n    }\n    used.clear();\n  }\n}\n", "docstring": "rewind the configuration to the initial situation", "partition": "test"}
{"idx": "2070", "code": "public void fill_shape(PlaPointFloat[] p_points,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  Graphics2D g2=(Graphics2D)p_g;\n  Polygon draw_polygon=new Polygon();\n  for (int index=0; index < p_points.length; index++) {\n    Point2D curr_corner=coordinate_transform.board_to_screen(p_points[index]);\n    draw_polygon.addPoint((int)Math.round(curr_corner.getX()),(int)Math.round(curr_corner.getY()));\n  }\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_polygon);\n}\n", "docstring": "fill the interior of the polygon shape represented by p_points .", "partition": "test"}
{"idx": "2777", "code": "@Override public boolean start() throws IOException {\n  LOG.info(\"Starting reader using {}\",initialCheckpointGenerator);\n  try {\n    KinesisReaderCheckpoint initialCheckpoint=initialCheckpointGenerator.generate(kinesis);\n    List<ShardRecordsIterator> iterators=newArrayList();\n    for (    ShardCheckpoint checkpoint : initialCheckpoint) {\n      iterators.add(checkpoint.getShardRecordsIterator(kinesis));\n    }\n    shardIterators=new RoundRobin<>(iterators);\n  }\n catch (  TransientKinesisException e) {\n    throw new IOException(e);\n  }\n  return advance();\n}\n", "docstring": "generates initial checkpoint and instantiates iterators for shards .", "partition": "test"}
{"idx": "2176", "code": "private void connectEqualized(SynapseGroup synapseGroup){\n  currentOrderingIndices=new int[sourceNeurons.length];\n  int numConnectsPerSrc;\n  int expectedNumSyns;\n  if (synapseGroup.isRecurrent() && !selfConnectionAllowed) {\n    numConnectsPerSrc=(int)(connectionDensity * (sourceNeurons.length - 1));\n  }\n else {\n    numConnectsPerSrc=(int)(connectionDensity * targetNeurons.length);\n  }\n  expectedNumSyns=numConnectsPerSrc * sourceNeurons.length;\n  synapseGroup.preAllocateSynapses(expectedNumSyns);\n  for (int i=0, n=sourceNeurons.length; i < n; i++) {\n    currentOrderingIndices[i]=numConnectsPerSrc;\n    Neuron src=sourceNeurons[i];\n    Neuron tar;\n    for (int j=0; j < numConnectsPerSrc; j++) {\n      tar=targetNeurons[sparseOrdering[i][j]];\n      Synapse s=new Synapse(src,tar);\n      synapseGroup.addNewSynapse(s);\n    }\n  }\n}\n", "docstring": "populates the synapse group with synapses by making individual synaptic connections between the neurons in the synapse group \"'\" s source and target groups . these synapses are initialized with default attributes and zero strength . each source neuron will have exactly the same number of efferent synapses . this number being whichever satisfies the constraints given by the sparsity and whether or not the synapse group is recurrent and self connections are allowed .", "partition": "test"}
{"idx": "2591", "code": "public short readShort() throws IOException {\n  return primitiveTypes.readShort();\n}\n", "docstring": "reads a short ( 16 bit ) from the source stream .", "partition": "test"}
{"idx": "1116", "code": "private DBID stringToDBID(String query){\n  return DBIDUtil.importInteger(Integer.valueOf(query));\n}\n", "docstring": "parse a string into a dbid .", "partition": "test"}
{"idx": "3650", "code": "public static String format(final String value,String... params){\n  validate(value,NULL_STRING_PREDICATE,NULL_STRING_MSG_SUPPLIER);\n  Pattern p=Pattern.compile(\"\\\\\\\\{(\\\\\\\\w+)\\\\\\\\}\");\n  Matcher m=p.matcher(value);\n  String result=value;\n  while (m.find()) {\n    int paramNumber=Integer.parseInt(m.group(1));\n    if (params == null || paramNumber >= params.length) {\n      throw new IllegalArgumentException(\"params does not have value for \" + m.group());\n    }\n    result=result.replace(m.group(),params[paramNumber]);\n  }\n  return result;\n}\n", "docstring": "formats a string using parameters", "partition": "test"}
{"idx": "957", "code": "protected void responseSent(StreamResponseMessage responseMessage){\n  if (syncProtocol != null)   syncProtocol.responseSent(responseMessage);\n}\n", "docstring": "must be called by a subclass after the response has been successfully sent to the client .", "partition": "test"}
{"idx": "3099", "code": "private static synchronized boolean isSupportedImpl(HttpCallerInfo hci){\n  if (supported == null) {\n    supported=new HashMap<String,Boolean>();\n    cache=new HashMap<String,Negotiator>();\n  }\n  String hostname=hci.host;\n  hostname=hostname.toLowerCase();\n  if (supported.containsKey(hostname)) {\n    return supported.get(hostname);\n  }\n  Negotiator neg=Negotiator.getNegotiator(hci);\n  if (neg != null) {\n    supported.put(hostname,true);\n    cache.put(hostname,neg);\n    return true;\n  }\n else {\n    supported.put(hostname,false);\n    return false;\n  }\n}\n", "docstring": "find out if the httpcallerinfo supports negotiate protocol . in order to find out yes or no , an initialization of a negotiator object against it is tried . the generated object will be cached under the name of ths hostname at a success try . < br > if this method is called for the second time on an httpcallerinfo with the same hostname , the answer is retrieved from cache .", "partition": "test"}
{"idx": "2406", "code": "public static String matchCertificate(KeyStore keyStore,X509Certificate cert) throws CryptoException {\n  try {\n    for (Enumeration aliases=keyStore.aliases(); aliases.hasMoreElements(); ) {\n      String alias=(String)aliases.nextElement();\n      if (keyStore.isCertificateEntry(alias)) {\n        X509Certificate compCert=X509CertUtil.convertCertificate(keyStore.getCertificate(alias));\n        if (cert.equals(compCert)) {\n          return alias;\n        }\n      }\n    }\n    return null;\n  }\n catch (  KeyStoreException ex) {\n    throw new CryptoException(res.getString(\"NoMatchCertificate.exception.message\"),ex);\n  }\n}\n", "docstring": "check whether or not a trusted certificate in the supplied keystore matches the supplied x . 509 certificate .", "partition": "test"}
{"idx": "2983", "code": "private static boolean isRetina(){\n  if (SystemInfo.isAppleJvm) {\n    return hasAppleRetinaDevice();\n  }\n  if (SystemInfo.isMac) {\n    GraphicsEnvironment e=GraphicsEnvironment.getLocalGraphicsEnvironment();\n    GraphicsDevice[] devices=e.getScreenDevices();\n    for (    GraphicsDevice device : devices) {\n      if (isOracleMacRetinaDevice(device)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "checks that at least one retina device is present . do not use this method if your are going to make decision for a particular screen . isretina ( graphics2d ) is more preferable", "partition": "test"}
{"idx": "960", "code": "public boolean isArmed(){\n  return other.isArmed();\n}\n", "docstring": "all these methods simply delegate to the \" other \" model that is being decorated .", "partition": "test"}
{"idx": "571", "code": "public boolean validate(){\n  outputFile=new File(outputPath);\n  if (outputFile.exists() || outputFile.isDirectory()) {\n    invalidMessage=\"Output file already exists.\";\n    return valid=false;\n  }\n  if (!signMode) {\n    keyFile=new File(keyFilePath);\n    if (!keyFile.exists() || keyFile.isDirectory()) {\n      invalidMessage=\"Key file not found.\";\n      return valid=false;\n    }\n  }\n  return valid=true;\n}\n", "docstring": "initialises and checks validity of files . this objects tostring ( ) method changes to reflect failures in validation in order for the user to be informed .", "partition": "test"}
{"idx": "424", "code": "public boolean isValidLockdownProfile(){\n  try {\n    return true;\n  }\n catch (  IllegalArgumentException e) {\n    Log.w(TAG,\"Invalid address\",e);\n    return false;\n  }\n}\n", "docstring": "test if profile is valid for lockdown , which requires ipv4 address for both server and dns . server hostnames would require using dns before connection .", "partition": "test"}
{"idx": "2413", "code": "private JCheckBox addCheckbox(String text,Container container){\n  JCheckBox checkbox=new JCheckBox(text);\n  checkbox.setAlignmentX(Component.LEFT_ALIGNMENT);\n  checkbox.setBorder(BorderFactory.createEmptyBorder(0,0,10,5));\n  container.add(checkbox);\n  return checkbox;\n}\n", "docstring": "adds a preconfigured jcheckbox to the specified container , setting its alignment constraint to left and adding an empty padding border .", "partition": "test"}
{"idx": "1466", "code": "private static float computeSimilarity(Lane a,Lane b){\n  int same=0;\n  int diff=0;\n  int firstCoordinate=Math.max(a.getFirstNonGapPosition(),b.getFirstNonGapPosition());\n  int lastCoordinate=Math.min(a.getLastNonGapPosition(),b.getLastNonGapPosition());\n  for (int i=firstCoordinate; i <= lastCoordinate; i++) {\n    char cha=a.charAt(i);\n    char chb=b.charAt(i);\n    if (Character.isLetter(cha) && Character.isLetter(chb)) {\n      if (Character.toLowerCase(cha) == Character.toLowerCase((chb)))       same++;\n else       diff++;\n    }\n  }\n  return Math.max(same > 0 ? 1 : 0,same - 3 * diff);\n}\n", "docstring": "computes the similarity of two sequences", "partition": "test"}
{"idx": "3395", "code": "private HashMap<String,Object> createAccDetailmap(String glcode,BigDecimal debitAmount,BigDecimal creditAmount){\n  HashMap<String,Object> accountdetailmap=new HashMap<String,Object>();\n  accountdetailmap.put(VoucherConstant.GLCODE,glcode);\n  accountdetailmap.put(VoucherConstant.DEBITAMOUNT,debitAmount);\n  accountdetailmap.put(VoucherConstant.CREDITAMOUNT,creditAmount);\n  accountdetailmap.put(VoucherConstant.FUNCTIONCODE,getFunctionaryCode());\n  return accountdetailmap;\n}\n", "docstring": "creates account details map", "partition": "test"}
{"idx": "3752", "code": "static String matchStringOrThrow(Pattern p,ToDateParser params,Enum<?> aEnum){\n  String s=params.getInputStr();\n  Matcher matcher=p.matcher(s);\n  if (!matcher.find()) {\n    throwException(params,format(\"Issue happened when parsing token \\'%s\\'\",aEnum.name()));\n  }\n  return matcher.group(1);\n}\n", "docstring": "match the pattern , or if not possible throw an exception .", "partition": "test"}
{"idx": "334", "code": "@RequestMapping(value=\"/hive\",method={RequestMethod.GET}) @ResponseBody private static List<String> showHiveDatabases() throws IOException {\n  IHiveClient hiveClient=HiveClientFactory.getHiveClient();\n  List<String> results=null;\n  try {\n    results=hiveClient.getHiveDbNames();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new IOException(e);\n  }\n  return results;\n}\n", "docstring": "show all databases in hive", "partition": "test"}
{"idx": "3054", "code": "public long skipBytes(long n) throws IOException {\n  long count=0;\n  long gotsofar=0;\n  if (inputStream == null) {\n    reopen();\n    if (inputStream == null) {\n      reopen();\n      throw new IOException(\"Stream closed, can\\'t be reopened\");\n    }\n  }\n  while (count < n) {\n    gotsofar=inputStream.skip(n - count);\n    if (gotsofar == 0) {\n      Debug.error(\"StreamInputReader can\\'t skip \" + n + \" bytes as instructed\");\n      break;\n    }\n    count+=gotsofar;\n  }\n  count((int)count);\n  return count;\n}\n", "docstring": "skip over n bytes in the input file", "partition": "test"}
{"idx": "1406", "code": "public void print(char c){\n  writer.print(c);\n}\n", "docstring": "prints the given char . use println ( ) to print a \"'\" \\\\ n \"'\" .", "partition": "test"}
{"idx": "3797", "code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeBoolean(isLeaf);\n  out.writeInt(numEntries);\n}\n", "docstring": "calls the super method and writes the id of this node , the numentries and the entries array to the specified stream .", "partition": "test"}
{"idx": "3491", "code": "public void sortMovies(){\nsynchronized (movies) {\n    Utils.sortList(movies,MOVIE_SET_COMPARATOR);\n    movieIds.clear();\n    for (    Movie movie : movies) {\n      movieIds.add(movie.getDbId());\n    }\n  }\n  firePropertyChange(\"movies\",null,movies);\n}\n", "docstring": "sort movies inside this movie set by using either the sort title , release date or year .", "partition": "test"}
{"idx": "1879", "code": "public static Entry makeEntry(List<String> ldifLines){\n  return makeEntry(ldifLines.toArray(new String[ldifLines.size()]));\n}\n", "docstring": "builds an entry from the provided lines of ldif .", "partition": "test"}
{"idx": "304", "code": "public static CompiereColor parse(String attributes){\n  CompiereColor cc=new CompiereColor();\n  try {\n    if (attributes != null && attributes.length() > 0)     cc.parseAttributres(attributes);\n  }\n catch (  Exception e) {\n    log.severe(\"(\" + attributes + \") - \"+ e.toString());\n  }\n  return cc;\n}\n", "docstring": "parse attributes and return adempierecolor", "partition": "test"}
{"idx": "427", "code": "public static KdbDatabase createKdbDatabase(Credentials credentials,KdbHeader kdbHeader,InputStream inputStream) throws IOException {\n  DataInput dataInput=new LittleEndianDataInputStream(inputStream);\n  checkSignature(dataInput);\n  deserializeHeader(kdbHeader,dataInput);\n  InputStream decryptedInputStream=kdbHeader.createDecryptedInputStream(credentials.getKey(),inputStream);\n  MessageDigest digest=Encryption.getMessageDigestInstance();\n  DigestInputStream digestInputStream=new DigestInputStream(decryptedInputStream,digest);\n  dataInput=new LittleEndianDataInputStream(digestInputStream);\n  KdbDatabase kdbDatabase=new KdbDatabase();\n  KdbGroup lastGroup=(KdbGroup)kdbDatabase.getRootGroup();\n  for (long group=0; group < kdbHeader.getGroupCount(); group++) {\n    lastGroup=deserializeGroup(lastGroup,dataInput);\n  }\n  for (long entry=0; entry < kdbHeader.getEntryCount(); entry++) {\n    deserializeEntry(kdbDatabase,dataInput);\n  }\n  if (!Arrays.equals(digest.digest(),kdbHeader.getContentHash())) {\n    throw new IllegalStateException(\"Hash values did not match\");\n  }\n  digestInputStream.close();\n  return kdbDatabase;\n}\n", "docstring": "construct a kdb database from the supplied inputstream .", "partition": "test"}
{"idx": "2822", "code": "private void startHideAnimations(){\n  animationPlaying=true;\n  lightAnimationLayout();\n  if (buttonType.equals(ButtonType.CIRCLE)) {\n    if (hideOrderType.equals(OrderType.DEFAULT)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(dots[i],circleButtons[i],endLocations[i],startLocations[i],i);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.REVERSE)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(dots[i],circleButtons[i],endLocations[i],startLocations[i],buttonNum - i - 1);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.RANDOM)) {\n      Random random=new Random();\n      boolean[] used=new boolean[buttonNum];\n      for (int i=0; i < buttonNum; i++)       used[i]=false;\n      int count=0;\n      while (true) {\n        int i=random.nextInt(buttonNum);\n        if (!used[i]) {\n          used[i]=true;\n          setHideAnimation(dots[count],circleButtons[count],endLocations[count],startLocations[count],i);\n          count++;\n          if (count == buttonNum)           break;\n        }\n      }\n    }\n  }\n else   if (buttonType.equals(ButtonType.HAM)) {\n    if (hideOrderType.equals(OrderType.DEFAULT)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(bars[i],hamButtons[i],endLocations[i],startLocations[i],i);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.REVERSE)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(bars[i],hamButtons[i],endLocations[i],startLocations[i],buttonNum - i - 1);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.RANDOM)) {\n      Random random=new Random();\n      boolean[] used=new boolean[buttonNum];\n      for (int i=0; i < buttonNum; i++)       used[i]=false;\n      int count=0;\n      while (true) {\n        int i=random.nextInt(buttonNum);\n        if (!used[i]) {\n          used[i]=true;\n          setHideAnimation(bars[count],hamButtons[count],endLocations[count],startLocations[count],i);\n          count++;\n          if (count == buttonNum)           break;\n        }\n      }\n    }\n  }\n}\n", "docstring": "start all animations about dismissing .", "partition": "test"}
{"idx": "1634", "code": "protected void drawMark(Graphics2D g2,float x,float y,Color color){\n  Rectangle2D bounds=mark.getBounds2D();\n  float w=(float)bounds.getWidth();\n  float h=(float)bounds.getHeight();\n  x=x - (w / 2);\n  y=y - (h / 2);\n  g2.translate(x,y);\n  if (color == null) {\n    if (markFillPaint != null) {\n      g2.setPaint(markFillPaint);\n      g2.fill(mark);\n    }\n  }\n else {\n    g2.setPaint(color);\n    g2.fill(mark);\n  }\n  g2.setPaint(markPaint);\n  g2.setStroke(markStroke);\n  g2.draw(mark);\n  g2.translate(-x,-y);\n  Rectangle2D rect=new Rectangle2D.Float(x,y,w,h);\n  markBounds.add(rect);\n}\n", "docstring": "draw a mark transforming co - ordinates to each axis", "partition": "test"}
{"idx": "1691", "code": "protected void injectIntoVolumeInformationContainer(Map<String,StringSet> volumeInformation,String infoKey,String altKey,CIMInstance volumeInstance){\n  Object value=getCIMPropertyValue(volumeInstance,infoKey);\n  if (null == value) {\n    value=getCIMPropertyValue(volumeInstance,altKey);\n  }\n  String charactersticName=SupportedVolumeInformation.getVolumeInformation(infoKey);\n  if (null != value && null != charactersticName) {\n    StringSet valueSet=new StringSet();\n    if (value instanceof String) {\n      valueSet.add(value.toString());\n    }\n else     if (value instanceof String[]) {\n      valueSet.addAll(Arrays.asList((String[])value));\n    }\n    volumeInformation.put(charactersticName,valueSet);\n  }\n}\n", "docstring": "extract value from provider for given volume info key , and then get its name and use that to inject to map .", "partition": "test"}
{"idx": "1586", "code": "public String generateGroupName(String policyName,Set<String> existingGroupNames,String parentGroupName){\n  int count=0;\n  String format=null;\n  while (count <= existingGroupNames.size()) {\n    if (0 == count) {\n      format=String.format(\"SG_%s\",policyName);\n    }\n else {\n      format=String.format(\"SG_%s_%d\",policyName,count);\n    }\n    String generatedGroupName=generate(parentGroupName,format,SmisConstants.MASK_NAME_DELIMITER,SmisConstants.MAX_STORAGE_GROUP_NAME_LENGTH);\n    if (!existingGroupNames.contains(generatedGroupName)) {\n      return generatedGroupName;\n    }\n    count++;\n  }\n  return generate(parentGroupName,String.format(\"SG1_%s\",policyName),SmisConstants.MASK_NAME_DELIMITER,SmisConstants.MAX_STORAGE_GROUP_NAME_LENGTH);\n}\n", "docstring": "todo : vmax3 customized names generate group names which doesn \"'\" t exist in array already .", "partition": "test"}
{"idx": "1545", "code": "public void printText(String text){\n  view.print(text,text.endsWith(\"\\\\r\"));\n  for (  ActionDelegate actionDelegate : actionDelegates) {\n    actionDelegate.onConsoleOutput(this);\n  }\n}\n", "docstring": "print text in the console .", "partition": "test"}
{"idx": "3787", "code": "@Override protected final synchronized boolean writeData(ByteBuffer data){\n  AionServerPacket packet=sendMsgQueue.pollFirst();\n  if (packet == null) {\n    return false;\n  }\n  packet.setBuf(data);\n  packet.write(this);\n  return true;\n}\n", "docstring": "this method will be called by dispatcher , and will be repeated till return false .", "partition": "test"}
{"idx": "3367", "code": "public static Variation attemptToGetAsVariant(String part){\n  try {\n    StoneTypes var=StoneTypes.valueOf(part.toUpperCase());\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    WoodTypes var=WoodTypes.valueOf(part.toUpperCase());\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    FlowerTypes var=FlowerTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    EntityTypes var=EntityTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    MonsterEggTypes var=MonsterEggTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    ShapeTypes var=ShapeTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    HalfTypes var=HalfTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  return null;\n}\n", "docstring": "attempt to parse string as a variation", "partition": "test"}
{"idx": "85", "code": "private int measureWidth(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)mTextPaint.measureText(mText) + getPaddingLeft() + getPaddingRight();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "docstring": "determines the width of this view", "partition": "test"}
{"idx": "922", "code": "public void addUniqueAttribute(final String elementName,final String attrName){\n  if ((elementName != null) && (attrName != null)) {\n    _uniqueElementAttrMap.put(elementName,attrName);\n  }\n}\n", "docstring": "add unique attribute to the element which will force elements to be identical .", "partition": "test"}
{"idx": "845", "code": "public boolean remove(final int position){\n  final AdapterTransaction removeTransaction=new RemoveTransaction<>(this,position);\n  final boolean success=removeTransaction.perform();\n  mTransactions.offer(removeTransaction);\n  return success;\n}\n", "docstring": "removes item from the given position .", "partition": "test"}
{"idx": "2576", "code": "public void show(@IdRes final int itemId){\n  map.add(itemId);\n  navigation.invalidateBadge(itemId);\n}\n", "docstring": "request to display a new badge over the passed menu item id", "partition": "test"}
{"idx": "1803", "code": "public Format(String pFormatString){\n  String formatVars[]=pFormatString.split(\"/\");\n  mId=Integer.parseInt(formatVars[0]);\n}\n", "docstring": "construct this object from one of the strings in the \" fmt_list \" parameter", "partition": "test"}
{"idx": "1685", "code": "public static String formatSimpleDecimal(double d){\n  return simpleFormat.format(d);\n}\n", "docstring": "returns string from double formatted to decimalformat ( \" # # # . # # \" )", "partition": "test"}
{"idx": "920", "code": "public static void sortFields(FieldBinding[] sortedFields,int left,int right){\n  Arrays.sort(sortedFields,left,right,FIELD_COMPARATOR);\n}\n", "docstring": "sort the field array using a quicksort", "partition": "test"}
{"idx": "2214", "code": "public synchronized void release(){\n  index.clear();\n}\n", "docstring": "releases resources in the index .", "partition": "test"}
{"idx": "2218", "code": "public PainterChain prependPainter(Painter p){\n  Painter[] newChain=new Painter[chain.length + 1];\n  System.arraycopy(chain,1,newChain,0,chain.length);\n  newChain[0]=p;\n  return new PainterChain(newChain);\n}\n", "docstring": "creates a new chain based on the existing chain with the new element added at the beginning", "partition": "test"}
{"idx": "1662", "code": "public static long[] values(Long[] array){\n  long[] dest=new long[array.length];\n  for (int i=0; i < array.length; i++) {\n    Long v=array[i];\n    if (v != null) {\n      dest[i]=v.longValue();\n    }\n  }\n  return dest;\n}\n", "docstring": "converts to primitive array .", "partition": "test"}
{"idx": "1919", "code": "@Override public BufferedImage JPEGToRGBImage(final byte[] data,final int ww,final int hh,final int pX,final int pY){\n  BufferedImage image=null;\n  Raster ras=JPEGDecoder.getRasterFromJPEG(data,\"JPEG\");\n  if (ras != null) {\n    ras=cleanupRaster(ras,pX,pY,componentCount);\n    final int w=ras.getWidth();\n    final int h=ras.getHeight();\n    final DataBufferByte rgb=(DataBufferByte)ras.getDataBuffer();\n    image=createImage(w,h,rgb.getData());\n  }\n  return image;\n}\n", "docstring": "convert data stream to srgb image", "partition": "test"}
{"idx": "3028", "code": "public boolean hasMyomerBooster(){\n  for (  Mounted mEquip : getMisc()) {\n    MiscType mtype=(MiscType)mEquip.getType();\n    if (mtype.hasFlag(MiscType.F_MASC) && !mEquip.isInoperable()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "does this ba mount a myomer booster ?", "partition": "test"}
{"idx": "3242", "code": "public boolean equivalent(IMFMarkerType other){\n  if (other == null) {\n    return false;\n  }\n  boolean result=true;\n  result&=offset.equals(other.getOffset());\n  result&=label.equivalent(other.getLabel());\n  return result;\n}\n", "docstring": "a method to determine the equivalence of any two markers .", "partition": "test"}
{"idx": "2468", "code": "public byte[] remove(QueueEvent event) throws KeeperException, InterruptedException {\n  TimerContext time=stats.time(dir + \"_remove_event\");\n  try {\n    String path=event.getId();\n    String responsePath=dir + \"/\" + response_prefix+ path.substring(path.lastIndexOf(\"-\") + 1);\n    if (zookeeper.exists(responsePath,true)) {\n      zookeeper.setData(responsePath,event.getBytes(),true);\n    }\n    byte[] data=zookeeper.getData(path,null,null,true);\n    zookeeper.delete(path,-1,true);\n    return data;\n  }\n  finally {\n    time.stop();\n  }\n}\n", "docstring": "remove the event and save the response into the other path .", "partition": "test"}
{"idx": "1716", "code": "protected static void printErrorMessage(Exception e){\n  if (e instanceof AbortException) {\n    LoggingConfiguration.setVerbose(Level.VERBOSE);\n    LOG.verbose(e.getMessage());\n  }\n else   if (e instanceof UnspecifiedParameterException) {\n    LOG.error(e.getMessage());\n  }\n else   if (e instanceof ParameterException) {\n    LOG.error(e.getMessage());\n  }\n else {\n    LOG.exception(e);\n  }\n}\n", "docstring": "print an error message for the given error .", "partition": "test"}
{"idx": "3631", "code": "int putData(Object data) throws FitsException {\n  long lsize=ArrayFuncs.computeLSize(data);\n  if (lsize > Integer.MAX_VALUE) {\n    throw new FitsException(\"FITS Heap > 2 G\");\n  }\n  int size=(int)lsize;\n  expandHeap(size);\n  ByteArrayOutputStream bo=new ByteArrayOutputStream(size);\n  try {\n    BufferedDataOutputStream o=new BufferedDataOutputStream(bo);\n    o.writeArray(data);\n    o.flush();\n    o.close();\n  }\n catch (  IOException e) {\n    throw new FitsException(\"Unable to write variable column length data\",e);\n  }\n  System.arraycopy(bo.toByteArray(),0,this.heap,this.heapSize,size);\n  int oldOffset=this.heapSize;\n  this.heapSize+=size;\n  return oldOffset;\n}\n", "docstring": "add some data to the heap .", "partition": "test"}
{"idx": "2500", "code": "public int findEventPositionNearestTime(Time time,long id){\n  if (mRowInfo == null) {\n    return 0;\n  }\n  long millis=time.toMillis(false);\n  long minDistance=Integer.MAX_VALUE;\n  long idFoundMinDistance=Integer.MAX_VALUE;\n  int minIndex=0;\n  int idFoundMinIndex=0;\n  int eventInTimeIndex=-1;\n  int allDayEventInTimeIndex=-1;\n  int allDayEventDay=0;\n  int minDay=0;\n  boolean idFound=false;\n  int len=mRowInfo.size();\n  for (int index=0; index < len; index++) {\n    RowInfo row=mRowInfo.get(index);\n    if (row.mType == TYPE_DAY) {\n      continue;\n    }\n    if (row.mEventId == id) {\n      if (row.mEventStartTimeMilli == millis) {\n        return index;\n      }\n      long distance=Math.abs(millis - row.mEventStartTimeMilli);\n      if (distance < idFoundMinDistance) {\n        idFoundMinDistance=distance;\n        idFoundMinIndex=index;\n      }\n      idFound=true;\n    }\n    if (!idFound) {\n      if (millis >= row.mEventStartTimeMilli && millis <= row.mEventEndTimeMilli) {\n        if (row.mAllDay) {\n          if (allDayEventInTimeIndex == -1) {\n            allDayEventInTimeIndex=index;\n            allDayEventDay=row.mDay;\n          }\n        }\n else         if (eventInTimeIndex == -1) {\n          eventInTimeIndex=index;\n        }\n      }\n else       if (eventInTimeIndex == -1) {\n        long distance=Math.abs(millis - row.mEventStartTimeMilli);\n        if (distance < minDistance) {\n          minDistance=distance;\n          minIndex=index;\n          minDay=row.mDay;\n        }\n      }\n    }\n  }\n  if (idFound) {\n    return idFoundMinIndex;\n  }\n  if (eventInTimeIndex != -1) {\n    return eventInTimeIndex;\n  }\n else   if (allDayEventInTimeIndex != -1 && minDay != allDayEventDay) {\n    return allDayEventInTimeIndex;\n  }\n  return minIndex;\n}\n", "docstring": "finds the position in the cursor of the event that best matches the time and id . it will try to find the event that has the specified id and start time , if such event doesn \"'\" t exist , it will return the event with a matching id that is closest to the start time . if the id doesn \"'\" t exist , it will return the event with start time closest to the specified time .", "partition": "test"}
{"idx": "598", "code": "public static final void writeMapXml(Map val,XmlSerializer out,WriteMapCallback callback) throws XmlPullParserException, IOException {\n  if (val == null) {\n    return;\n  }\n  Set s=val.entrySet();\n  Iterator i=s.iterator();\n  while (i.hasNext()) {\n    Map.Entry e=(Map.Entry)i.next();\n    writeValueXml(e.getValue(),(String)e.getKey(),out,callback);\n  }\n}\n", "docstring": "flatten a map into an xmlserializer . the map can later be read back with readthismapxml ( ) . this method presumes that the start tag and name attribute have already been written and does not write an end tag .", "partition": "test"}
{"idx": "3321", "code": "protected void writeColumnAutoIncrementStmt(Table table,Column column,StringBuilder ddl){\n  ddl.append(\"IDENTITY\");\n}\n", "docstring": "prints that the column is an auto increment column .", "partition": "test"}
{"idx": "3489", "code": "@RequestMapping(value=\"/SAML2/Metadata/{tenant:.*}\") public void metadataError(Locale locale,@PathVariable(value=\"tenant\") String tenant,HttpServletResponse response) throws IOException {\n  logger.info(\"Metadata binding error! The client locale is {}, tenant is {}\",locale.toString(),tenant);\n  metadataDefaultTenantBindingError(locale,response);\n}\n", "docstring": "handle request sent with a wrong binding", "partition": "test"}
{"idx": "2973", "code": "private void paint(Painter p,SynthContext ctx,Graphics g,int x,int y,int w,int h,AffineTransform transform){\n  if (p != null) {\n    if (g instanceof Graphics2D) {\n      Graphics2D gfx=(Graphics2D)g;\n      if (transform != null) {\n        gfx.transform(transform);\n      }\n      gfx.translate(x,y);\n      p.paint(gfx,ctx.getComponent(),w,h);\n      gfx.translate(-x,-y);\n      if (transform != null) {\n        try {\n          gfx.transform(transform.createInverse());\n        }\n catch (        NoninvertibleTransformException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n else {\n      BufferedImage img=new BufferedImage(w,h,BufferedImage.TYPE_INT_ARGB);\n      Graphics2D gfx=img.createGraphics();\n      if (transform != null) {\n        gfx.transform(transform);\n      }\n      p.paint(gfx,ctx.getComponent(),w,h);\n      gfx.dispose();\n      g.drawImage(img,x,y,null);\n      img=null;\n    }\n  }\n}\n", "docstring": "paint the provided painter using the provided transform at the specified position and size . handles if g is a non 2d graphics by painting via a bufferedimage .", "partition": "test"}
{"idx": "4255", "code": "public void put(int fieldNumber,FieldData data){\n  int i=binarySearch(fieldNumber);\n  if (i >= 0) {\n    mData[i]=data;\n  }\n else {\n    i=~i;\n    if (i < mSize && mData[i] == DELETED) {\n      mFieldNumbers[i]=fieldNumber;\n      mData[i]=data;\n      return;\n    }\n    if (mGarbage && mSize >= mFieldNumbers.length) {\n      gc();\n      i=~binarySearch(fieldNumber);\n    }\n    if (mSize >= mFieldNumbers.length) {\n      int n=idealIntArraySize(mSize + 1);\n      int[] nkeys=new int[n];\n      FieldData[] nvalues=new FieldData[n];\n      System.arraycopy(mFieldNumbers,0,nkeys,0,mFieldNumbers.length);\n      System.arraycopy(mData,0,nvalues,0,mData.length);\n      mFieldNumbers=nkeys;\n      mData=nvalues;\n    }\n    if (mSize - i != 0) {\n      System.arraycopy(mFieldNumbers,i,mFieldNumbers,i + 1,mSize - i);\n      System.arraycopy(mData,i,mData,i + 1,mSize - i);\n    }\n    mFieldNumbers[i]=fieldNumber;\n    mData[i]=data;\n    mSize++;\n  }\n}\n", "docstring": "adds a mapping from the specified fieldnumber to the specified data , replacing the previous mapping if there was one .", "partition": "test"}
{"idx": "3840", "code": "public boolean isPropertyAllowed(Name name){\n  return propertiesAllowed.contains(name);\n}\n", "docstring": "is the given word the name of an allowed css property ?", "partition": "test"}
{"idx": "1540", "code": "private void sendBlob(String index,byte[] blob){\n  sendInstruction(new GuacamoleInstruction(\"blob\",index,DatatypeConverter.printBase64Binary(blob)));\n}\n", "docstring": "injects a \" blob \" instruction into the outbound guacamole protocol stream , as if sent by the connected client . \" blob \" instructions are used to send chunks of data along a stream .", "partition": "test"}
{"idx": "1651", "code": "private void initComputeProgram(){\n  glUseProgram(computeProgram);\n  IntBuffer workGroupSize=BufferUtils.createIntBuffer(3);\n  glGetProgramiv(computeProgram,GL_COMPUTE_WORK_GROUP_SIZE,workGroupSize);\n  workGroupSizeX=workGroupSize.get(0);\n  workGroupSizeY=workGroupSize.get(1);\n  timeUniform=glGetUniformLocation(computeProgram,\"time\");\n  blendFactorUniform=glGetUniformLocation(computeProgram,\"blendFactor\");\n  lightRadiusUniform=glGetUniformLocation(computeProgram,\"lightRadius\");\n  IntBuffer props=BufferUtils.createIntBuffer(1);\n  IntBuffer params=BufferUtils.createIntBuffer(1);\n  props.put(0,GL_BUFFER_BINDING);\n  int objectsResourceIndex=glGetProgramResourceIndex(computeProgram,GL_SHADER_STORAGE_BLOCK,\"Objects\");\n  glGetProgramResourceiv(computeProgram,GL_SHADER_STORAGE_BLOCK,objectsResourceIndex,props,null,params);\n  objectsSsboBinding=params.get(0);\n  int trianglesResourceIndex=glGetProgramResourceIndex(computeProgram,GL_SHADER_STORAGE_BLOCK,\"Triangles\");\n  glGetProgramResourceiv(computeProgram,GL_SHADER_STORAGE_BLOCK,trianglesResourceIndex,props,null,params);\n  trianglesSsboBinding=params.get(0);\n  int loc=glGetUniformLocation(computeProgram,\"framebufferImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  framebufferImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldPositionImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldPositionImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldNormalImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldNormalImageBinding=params.get(0);\n  glUseProgram(0);\n}\n", "docstring": "initialize the compute shader .", "partition": "test"}
{"idx": "4195", "code": "private void processBmpImage(BufferedImage image){\n  if (!isError) {\n    File outputFile=new File(path,prefix + (numPage + 1) + \".bmp\");\n    try {\n      ImageIO.write(image,\"bmp\",outputFile);\n      addTempFile(outputFile);\n      addScanFile(outputFile);\n      numPage++;\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n      endProcess(true,false);\n    }\n  }\n}\n", "docstring": "procesa el escaneo de una imagen en modo nativo", "partition": "test"}
{"idx": "3506", "code": "private void finishCommon(){\n  if (!unknownSubjects.isEmpty()) {\n    if (statements.isEmpty() && restoredStatements.isEmpty()) {\n      throw new BadSubjectException(unknownSubjects.keySet(),uris);\n    }\n else {\n      log.info(\"Unrecognized subjects: {}.  Expected only sitelinks and subjects starting with {} and {}\",unknownSubjects.keySet(),uris.entityData(),uris.entity());\n    }\n  }\n  if (revisionId == null) {\n    throw new ContainedException(\"Didn\\'t get a revision id for \" + statements);\n  }\n  if (lastModified == null) {\n    throw new ContainedException(\"Didn\\'t get a last modified date for \" + statements);\n  }\n  for (  Pair<URI,Literal> dataStatement : dataStatements) {\n    statements.add(new StatementImpl(entityUriImpl,dataStatement.getLeft(),dataStatement.getRight()));\n  }\n  statements.addAll(restoredStatements);\n}\n", "docstring": "perform all munge completion tasks that are required no matter the configuration . its important that finishcommon be the last finish method called because it is the one that restores restoredstatments into the original statements collection .", "partition": "test"}
{"idx": "1979", "code": "@Override public void close(){\n  try {\n    flush();\n  }\n catch (  AMLogException ale) {\n    Debug.error(tableName + \":DBHandler:close/flush error: \" + ale.getMessage());\n  }\n  if (conn != null) {\n    try {\n      conn.close();\n    }\n catch (    SQLException ce) {\n      Debug.error(tableName + \":DBHandler: Unable To Close Connection\",ce);\n    }\n  }\n  stopBufferTimer();\n}\n", "docstring": "flush any buffered messages and close the current output stream .", "partition": "test"}
{"idx": "2365", "code": "public FileSaverDescriptor(@NotNull String title,@NotNull String description,String... extensions){\n  super(true,true,true,true,false,false);\n  setTitle(title);\n  setDescription(description);\n  this.extensions=Arrays.asList(extensions);\n}\n", "docstring": "constructs save dialog properties", "partition": "test"}
{"idx": "2802", "code": "public static int len(String list,String delimiter,boolean ignoreEmpty){\n  if (delimiter.length() == 1)   return len(list,delimiter.charAt(0),ignoreEmpty);\n  char[] del=delimiter.toCharArray();\n  int len=StringUtil.length(list);\n  if (len == 0)   return 0;\n  int count=0;\n  int last=0;\n  char c;\n  for (int i=0; i < len; i++) {\n    c=list.charAt(i);\n    for (int y=0; y < del.length; y++) {\n      if (c == del[y]) {\n        if (!ignoreEmpty || last < i)         count++;\n        last=i + 1;\n        break;\n      }\n    }\n  }\n  if (!ignoreEmpty || last < len)   count++;\n  return count;\n}\n", "docstring": "returns count of items in the list", "partition": "test"}
{"idx": "3807", "code": "private void prepareTransfers() throws LibUsbException {\n  if (mAvailableTransfers == null) {\n    mAvailableTransfers=new LinkedTransferQueue<>();\n    for (int x=0; x < TRANSFER_BUFFER_POOL_SIZE; x++) {\n      Transfer transfer=LibUsb.allocTransfer();\n      if (transfer == null) {\n        throw new LibUsbException(\"couldn\\'t allocate transfer\",LibUsb.ERROR_NO_MEM);\n      }\n      final ByteBuffer buffer=ByteBuffer.allocateDirect(mBufferSize);\n      LibUsb.fillBulkTransfer(transfer,mDeviceHandle,USB_ENDPOINT,buffer,BufferProcessor.this,\"Buffer\",USB_TIMEOUT_US);\n      mAvailableTransfers.add(transfer);\n    }\n  }\n}\n", "docstring": "prepares ( allocates ) a set of transfer buffers for use in transferring data from the tuner via the bulk interface", "partition": "test"}
{"idx": "185", "code": "public static Map<Object,Long> valueHistogram(GeoTimeSerie gts){\n  Map<Object,Long> occurrences=new HashMap<Object,Long>();\n  for (int i=0; i < gts.values; i++) {\n    Object value=GTSHelper.valueAtIndex(gts,i);\n    if (!occurrences.containsKey(value)) {\n      occurrences.put(value,1L);\n    }\n else {\n      occurrences.put(value,1L + occurrences.get(value));\n    }\n  }\n  if (GTSHelper.isBucketized(gts) && gts.bucketcount != gts.values) {\n    occurrences.put(null,(long)(gts.bucketcount - gts.values));\n  }\n  return occurrences;\n}\n", "docstring": "build an occurrence count by value for the given time serie .", "partition": "test"}
{"idx": "2831", "code": "public static boolean isEmpty(CharSequence text){\n  return text == null || text.length() == 0;\n}\n", "docstring": "returns true if the string is null or 0 - length .", "partition": "test"}
{"idx": "1268", "code": "static Map addElementToMap(String key,Set values,Map toMap){\n  if ((key != null) && (toMap != null)) {\n    toMap.put(key,values);\n  }\n  return toMap;\n}\n", "docstring": "adds a key / value pair to a map", "partition": "test"}
{"idx": "2240", "code": "public VacuumEnvironment(){\n  Random r=new Random();\n  envState=new VacuumEnvironmentState(0 == r.nextInt(2) ? LocationState.Clean : LocationState.Dirty,0 == r.nextInt(2) ? LocationState.Clean : LocationState.Dirty);\n}\n", "docstring": "constructs a vacuum environment with two locations , in which dirt is placed at random .", "partition": "test"}
{"idx": "3369", "code": "public IDevice learnEntity(long macAddress,Short vlan,Integer ipv4Address,Long switchDPID,Integer switchPort,boolean processUpdates){\n  List<IDeviceListener> listeners=deviceListeners.getOrderedListeners();\n  if (!processUpdates) {\n    deviceListeners.clearListeners();\n  }\n  if (vlan != null && vlan.shortValue() <= 0)   vlan=null;\n  if (ipv4Address != null && ipv4Address == 0)   ipv4Address=null;\n  IDevice res=learnDeviceByEntity(new Entity(macAddress,vlan,ipv4Address,switchDPID,switchPort,new Date()));\n  if (listeners != null) {\n    for (    IDeviceListener listener : listeners) {\n      deviceListeners.addListener(\"device\",listener);\n    }\n  }\n  return res;\n}\n", "docstring": "learn a device using the given characteristics .", "partition": "test"}
{"idx": "4030", "code": "@GenIgnore static Record createRecord(String name,String address,Class itf,JsonObject metadata){\n  return createRecord(name,address,itf.getName(),metadata);\n}\n", "docstring": "sugar method to creates a record for this type . < p > the java interface is added to the metadata in the ` service . interface ` key .", "partition": "test"}
{"idx": "3332", "code": "public static EventBean[] addToArray(EventBean[] array,Collection<EventBean> eventsToAdd){\n  EventBean[] newArray=new EventBean[array.length + eventsToAdd.size()];\n  System.arraycopy(array,0,newArray,0,array.length);\n  int counter=array.length;\n  for (  EventBean eventToAdd : eventsToAdd) {\n    newArray[counter++]=eventToAdd;\n  }\n  return newArray;\n}\n", "docstring": "expand the array passed in by the multiple elements to add .", "partition": "test"}
{"idx": "3346", "code": "private String toString(Matcher m,int group){\n  return (group == 0) ? \"\" : m.group(group);\n}\n", "docstring": "captures the group passed in by matching against a pattern .", "partition": "test"}
{"idx": "3577", "code": "@Override public void updateServerAddress(Application application,String dockerManagerIP,String serverPort,String serverManagerPort){\n  String suffixCloudUnit=application.getSuffixCloudUnitIO();\n  JedisPool pool=null;\n  Jedis jedis=null;\n  try {\n    pool=new JedisPool(new JedisPoolConfig(),redisIp,Integer.parseInt(redisPort),3000);\n    jedis=pool.getResource();\n    String subNameSpace=concatSubNameSpace(application);\n    String key=subNameSpace + suffixCloudUnit;\n    String frontend=\"frontend:\" + key.toLowerCase();\n    jedis.lset(frontend,1,\"http://\" + dockerManagerIP + \":\"+ serverPort);\n    String frontendServerManager=\"frontend:manager-\" + key.toLowerCase();\n    jedis.lset(frontendServerManager,1,\"http://\" + dockerManagerIP + \":\"+ serverManagerPort);\n  }\n catch (  JedisConnectionException|UnsupportedEncodingException e) {\n    logger.error(\"HipacheRedisUtils Exception\",e);\n  }\n finally {\n    if (jedis != null) {\n      pool.destroy();\n    }\n  }\n}\n", "docstring": "update the server address", "partition": "test"}
{"idx": "803", "code": "public void readTransportSystems(final int[] columnsIndices,final BufferedReader reader) throws IOException {\n  String line=reader.readLine();\n  while (line != null && line.length() > 0) {\n    line=reader.readLine();\n  }\n}\n", "docstring": "reads the transport systems of the visum file", "partition": "test"}
{"idx": "2499", "code": "private void checkAndCreateDirectory(final String directoryName){\n  try {\n    final File dir=new File(directoryName);\n    if (!dir.exists() && dir.mkdirs()) {\n      _logger.debug(\"Debug dump directory created successfully.\");\n    }\n  }\n catch (  Exception ex) {\n    _logger.error(\"Debug dump directory creation failed due to {}\",ex.getMessage());\n  }\n}\n", "docstring": "verify whether directory already exists or not . if it is not there create one .", "partition": "test"}
{"idx": "3423", "code": "public LoginConfiguration forceAuth(String forceAuthReqParam){\n  forceAuth=Boolean.parseBoolean(forceAuthReqParam);\n  return this;\n}\n", "docstring": "sets the request \"'\" s forceauth parameter .", "partition": "test"}
{"idx": "311", "code": "void calculateCounters(){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  int total=0;\n  write.lock();\n  try {\n    countResetFeedsAndCategories();\n    total+=countFeedsWithUnread();\n    countCategoriesWithUnread();\n    countSpecialCategories(total);\n  }\n  finally {\n    write.unlock();\n  }\n  Log.i(TAG,String.format(\"Recalculated counters, total unread: %s (took %sms)\",total,(System.currentTimeMillis() - time)));\n}\n", "docstring": "set unread counters for feeds and categories according to real amount of unread articles . split up the tasks in single transactions so we can do other work in between .", "partition": "test"}
{"idx": "4211", "code": "public void addSection(final Section SECTION){\n  if (null == SECTION)   return;\n  sections.add(SECTION);\n  Collections.sort(sections,new SectionComparator());\n  fireUpdateEvent(SECTION_EVENT);\n}\n", "docstring": "adds the given section to the list of sections . sections in the medusa library usually are less eye - catching than areas .", "partition": "test"}
{"idx": "294", "code": "public void testMissionNameConstruction(){\n  String xml=\"\";\n  xml+=createStartMissionXml(\"\",\"Name\");\n  xml+=createEndMissionXml();\n  InputStream missionInputStream=new ByteArrayInputStream(xml.getBytes());\n  String missionName=null;\n  try {\n    missionName=MissionParser.getMissionName(missionInputStream);\n  }\n catch (  MissionParseException e) {\n    e.printStackTrace();\n  }\n  Assert.assertEquals(\"Name\",missionName);\n}\n", "docstring": "test for correct reading of a mission name .", "partition": "test"}
{"idx": "3605", "code": "private void loadOrgAccessRole(ArrayList<OrgAccess> list){\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  String sql=\"SELECT * FROM AD_Role_OrgAccess \" + \"WHERE AD_Role_ID=? AND IsActive=\\'Y\\'\";\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getAD_Role_ID());\n    rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRoleOrgAccess oa=new MRoleOrgAccess(getCtx(),rs,get_TrxName());\n      loadOrgAccessAdd(list,new OrgAccess(oa.getAD_Client_ID(),oa.getAD_Org_ID(),oa.isReadOnly()));\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n finally {\n    DB.close(rs,pstmt);\n  }\n}\n", "docstring": "load org access role", "partition": "test"}
{"idx": "1895", "code": "protected void flip(BufferCapabilities.FlipContents flipAction){\n  if (peer != null) {\n    Image backBuffer=getBackBuffer();\n    if (backBuffer != null) {\n      peer.flip(0,0,backBuffer.getWidth(null),backBuffer.getHeight(null),flipAction);\n    }\n  }\n else {\n    throw new IllegalStateException(\"Component must have a valid peer\");\n  }\n}\n", "docstring": "flipping moves the contents of the back buffer to the front buffer , either by copying or by moving the video pointer .", "partition": "test"}
{"idx": "166", "code": "private <T>UnaryOperator<T> compose(UnaryOperator<T> before,UnaryOperator<T> after){\n  return null;\n}\n", "docstring": "compose two functions together into a single function", "partition": "test"}
{"idx": "2614", "code": "private Pair<Entry,char[]> recoverEntry(KeyStore ks,String alias,char[] pstore,char[] pkey) throws Exception {\n  if (ks.containsAlias(alias) == false) {\n    MessageFormat form=new MessageFormat(rb.getString(\"Alias.alias.does.not.exist\"));\n    Object[] source={alias};\n    throw new Exception(form.format(source));\n  }\n  PasswordProtection pp=null;\n  Entry entry;\n  try {\n    entry=ks.getEntry(alias,pp);\n    pkey=null;\n  }\n catch (  UnrecoverableEntryException une) {\n    if (P11KEYSTORE.equalsIgnoreCase(ks.getType()) || KeyStoreUtil.isWindowsKeyStore(ks.getType())) {\n      throw une;\n    }\n    if (pkey != null) {\n      pp=new PasswordProtection(pkey);\n      entry=ks.getEntry(alias,pp);\n    }\n else {\n      try {\n        pp=new PasswordProtection(pstore);\n        entry=ks.getEntry(alias,pp);\n        pkey=pstore;\n      }\n catch (      UnrecoverableEntryException une2) {\n        if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {\n          throw une2;\n        }\n else {\n          pkey=getKeyPasswd(alias,null,null);\n          pp=new PasswordProtection(pkey);\n          entry=ks.getEntry(alias,pp);\n        }\n      }\n    }\n  }\n  return Pair.of(entry,pkey);\n}\n", "docstring": "recovers entry associated with given alias .", "partition": "test"}
{"idx": "1438", "code": "public void translate(double x,double y){\n  currentTransform.translate(x,y);\n  try {\n    writeTransform(new AffineTransform(1,0,0,1,x,y));\n  }\n catch (  IOException e) {\n    handleException(e);\n  }\n}\n", "docstring": "translates the current transform . calls writetransform ( transform )", "partition": "test"}
{"idx": "1243", "code": "private native byte[] imageDataToPlatformImageBytes(byte[] imageData,int width,int height,long format);\n", "docstring": "returns a byte array which contains data special for the given format and for the given image data .", "partition": "test"}
{"idx": "2807", "code": "int listSize(){\n  int result=memSize();\n  for (Iterator it=iterator(); it.hasNext(); ) {\n    ASTNode child=(ASTNode)it.next();\n    result+=child.treeSize();\n  }\n  return result;\n}\n", "docstring": "returns an estimate of the memory footprint in bytes of this node list and all its subtrees .", "partition": "test"}
{"idx": "2507", "code": "private Map<TestCase,Set<TestFitnessFunction>> initializeCoverageMapFromTests(List<TestCase> tests){\n  Map<TestCase,Set<TestFitnessFunction>> testToGoals=new LinkedHashMap<>();\n  for (  TestCase test : tests) {\n    testToGoals.put(test,filterSupportedGoals(new LinkedHashSet<>(test.getCoveredGoals())));\n  }\n  return testToGoals;\n}\n", "docstring": "builds the name map based on coverage goal stored as covered in each of the tests", "partition": "test"}
{"idx": "3146", "code": "void putFile(String relativePath,Codebase codebase){\n  try {\n    File dest=new File(rootDirectory.getAbsolutePath(),relativePath);\n    File src=codebase.getFile(relativePath);\n    boolean srcExists=filesystem.exists(src);\n    boolean destExists=filesystem.exists(dest);\n    boolean srcExecutable=filesystem.isExecutable(src);\n    boolean destExecutable=filesystem.isExecutable(dest);\n    if (!srcExists && !destExists) {\n      throw new MoeProblem(\"Neither src nor dests exists. Unreachable code:%n%s%n%s%n%s\",relativePath,src,dest);\n    }\n    if (!srcExists) {\n      util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"rm\",relativePath);\n      return;\n    }\n    try {\n      filesystem.makeDirsForFile(dest);\n      filesystem.copyFile(src,dest);\n    }\n catch (    IOException e) {\n      throw new MoeProblem(e.getMessage());\n    }\n    if (!destExists) {\n      util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"add\",\"--parents\",relativePath);\n    }\n    String mimeType=guessMimeType(relativePath);\n    if (mimeType != null) {\n      try {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propset\",\"svn:mime-type\",mimeType,relativePath);\n      }\n catch (      CommandRunner.CommandException e) {\n        ui.message(\"Error setting mime-type for %s\",relativePath);\n      }\n    }\n    if (destExecutable != srcExecutable) {\n      if (srcExecutable) {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propset\",\"svn:executable\",\"*\",relativePath);\n      }\n else {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propdel\",\"svn:executable\",relativePath);\n      }\n    }\n  }\n catch (  CommandRunner.CommandException e) {\n    throw new MoeProblem(\"problem occurred while running svn: \" + e.stderr);\n  }\n}\n", "docstring": "put file from c into this writer . ( helper function . )", "partition": "test"}
{"idx": "1193", "code": "@Override public int hashCode(){\n  return subconditions.hashCode() - operator.hashCode();\n}\n", "docstring": "returns the hashcode for the condition", "partition": "test"}
{"idx": "1361", "code": "public EventsIntegrationTest(){\n  setResponseLogLengthLimit(1000);\n  dateFormat=new SimpleDateFormat(\"yyyy-MM-dd\");\n  Calendar cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,-1);\n  yesterday=dateFormat.format(cal.getTime());\n  yesterday+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,0);\n  today=dateFormat.format(cal.getTime());\n  today+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,1);\n  tomorrow=dateFormat.format(cal.getTime());\n  tomorrow+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,3);\n  tomorrowPlus3=dateFormat.format(cal.getTime());\n  tomorrowPlus3+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,-3);\n  yesterdayMinus3=dateFormat.format(cal.getTime());\n  yesterdayMinus3+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,5);\n  tomorrowPlus5=dateFormat.format(cal.getTime());\n  tomorrowPlus5+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,-5);\n  yesterdayMinus5=dateFormat.format(cal.getTime());\n  yesterdayMinus5+=\"T00:00:00+0000\";\n  experiment=ExperimentFactory.createExperiment();\n  experiment.startTime=yesterdayMinus3;\n  experiment.endTime=tomorrowPlus3;\n  experiment.samplingPercent=1.0;\n  experiment.label=\"experiment\";\n  experiment.applicationName=QBO + UUID.randomUUID();\n  DefaultNameExclusionStrategy experimentComparisonStrategy=new DefaultNameExclusionStrategy(\"creationTime\",\"modificationTime\",\"ruleJson\");\n  experiment.setSerializationStrategy(experimentComparisonStrategy);\n}\n", "docstring": "initializes a default experiment .", "partition": "test"}
{"idx": "59", "code": "@Override public void draw(Canvas canvas){\n  super.draw(canvas);\n  if (mEdgeGlowTop != null) {\n    final int scrollX=getScrollX();\n    if (!mEdgeGlowTop.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.top + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.bottom + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      int edgeX=Math.min(0,scrollX + mFirstPositionDistanceGuess);\n      canvas.rotate(-90);\n      canvas.translate(-getHeight() + topPadding,edgeX);\n      mEdgeGlowTop.setSize(height,height);\n      if (mEdgeGlowTop.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n    if (!mEdgeGlowBottom.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.left + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.right + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      final int width=getWidth();\n      int edgeX=Math.max(width,scrollX + mLastPositionDistanceGuess);\n      canvas.rotate(90);\n      canvas.translate(-topPadding,-edgeX);\n      mEdgeGlowBottom.setSize(height,height);\n      if (mEdgeGlowBottom.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n  }\n}\n", "docstring": "todo : to be implemented", "partition": "test"}
{"idx": "1348", "code": "protected void onProgress(int itemcount,int size){\n}\n", "docstring": "called every time when command makes some little progress . can be mapped to async progress - bar", "partition": "test"}
{"idx": "8", "code": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}\n", "docstring": "returns true if specified type is java . lang . string", "partition": "test"}
{"idx": "3114", "code": "public void init(RemoteAuthenticatedUser currentUser){\n  this.currentUser=currentUser;\n}\n", "docstring": "creates a new sharedconnectiondirectory which exposes share keys as connections . only explicitly - registered and valid share keys will be accessible .", "partition": "test"}
{"idx": "3389", "code": "protected void execute(Runnable evt){\n  executor.execute(evt);\n}\n", "docstring": "fires a event on the executor thread", "partition": "test"}
{"idx": "3624", "code": "public static Object invokeStaticMethod(BshClassManager bcm,Class clas,String methodName,Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {\n  Interpreter.debug(\"invoke static Method\");\n  Method method=resolveExpectedJavaMethod(bcm,clas,null,methodName,args,true);\n  return invokeMethod(method,null,args);\n}\n", "docstring": "invoke a method known to be static . no object instance is needed and there is no possibility of the method being a bsh scripted method .", "partition": "test"}
{"idx": "1961", "code": "private void clearDictionaryCache(){\n  Map<String,Dictionary> dictionaryCaches=surrogateKeyGen.getDictionaryCaches();\n  List<Dictionary> reverseDictionaries=new ArrayList<>(dictionaryCaches.values());\n  for (int i=0; i < reverseDictionaries.size(); i++) {\n    Dictionary dictionary=reverseDictionaries.get(i);\n    dictionary.clear();\n  }\n}\n", "docstring": "this method will clear the dictionary access count so that any unused column can be removed from the cache", "partition": "test"}
{"idx": "3567", "code": "private boolean hasConnectivityToAllSystems(Initiator initiator,Collection<URI> storageSystems,ExportGroup exportGroup){\n  return hasConnectivityToAllSystems(initiator,storageSystems,null,exportGroup);\n}\n", "docstring": "checks if an initiator has connectivity to a storage system in a varray .", "partition": "test"}
{"idx": "3337", "code": "private static boolean isWritable(@NonNull final File file){\n  boolean isExisting=file.exists();\n  try {\n    FileOutputStream output=new FileOutputStream(file,true);\n    try {\n      output.close();\n    }\n catch (    IOException e) {\n    }\n  }\n catch (  java.io.FileNotFoundException e) {\n    return false;\n  }\n  boolean result=file.canWrite();\n  if (!isExisting) {\n    file.delete();\n  }\n  return result;\n}\n", "docstring": "check is a file is writable . detects write issues on external sd card .", "partition": "test"}
{"idx": "2865", "code": "@NotNull public PsiQuery childrenNamed(@NotNull final Class<? extends PsiNamedElement> clazz,@NotNull final String name){\n  final List<PsiElement> result=new ArrayList<PsiElement>();\n  for (  final PsiElement element : myPsiElements) {\n    for (    final PsiNamedElement child : PsiTreeUtil.findChildrenOfType(element,clazz)) {\n      if (name.equals(child.getName())) {\n        result.add(child);\n      }\n    }\n  }\n  return new PsiQuery(result.toArray(new PsiElement[result.size()]));\n}\n", "docstring": "filter children by name and class", "partition": "test"}
{"idx": "1857", "code": "public static String trimOrPad(String str,int length,char padChar){\n  String result;\n  if (str == null) {\n    result=\"\";\n  }\n else {\n    result=str;\n  }\n  if (result.length() > length) {\n    return result.substring(0,length);\n  }\n  while (result.length() < length) {\n    result+=padChar;\n  }\n  return result;\n}\n", "docstring": "trims or pads this string , so it has this exact length .", "partition": "test"}
{"idx": "3024", "code": "private List<EndIsland> findSurroundingIslands(int chunkX,int chunkY,int chunksPerFragmentX,int chunksPerFragmentY){\n  List<EndIsland> result=new LinkedList<EndIsland>();\n  for (int y=-SURROUNDING_CHUNKS; y <= chunksPerFragmentY + SURROUNDING_CHUNKS; y++) {\n    for (int x=-SURROUNDING_CHUNKS; x <= chunksPerFragmentX + SURROUNDING_CHUNKS; x++) {\n      EndIsland island=tryCreateEndIsland(chunkX + x,chunkY + y);\n      if (island != null) {\n        result.add(island);\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "returns a list of all islands that might be touching a chunk - area .", "partition": "test"}
{"idx": "3459", "code": "protected boolean arePathsContiguous(TreePath[] paths){\n  if (rowMapper == null || paths.length < 2)   return true;\n else {\n    BitSet bitSet=new BitSet(32);\n    int anIndex, counter, min;\n    int pathCount=paths.length;\n    int validCount=0;\n    TreePath[] tempPath=new TreePath[1];\n    tempPath[0]=paths[0];\n    min=rowMapper.getRowsForPaths(tempPath)[0];\n    for (counter=0; counter < pathCount; counter++) {\n      if (paths[counter] != null) {\n        tempPath[0]=paths[counter];\n        int[] rows=rowMapper.getRowsForPaths(tempPath);\n        if (rows == null) {\n          return false;\n        }\n        anIndex=rows[0];\n        if (anIndex == -1 || anIndex < (min - pathCount) || anIndex > (min + pathCount))         return false;\n        if (anIndex < min)         min=anIndex;\n        if (!bitSet.get(anIndex)) {\n          bitSet.set(anIndex);\n          validCount++;\n        }\n      }\n    }\n    int maxCounter=validCount + min;\n    for (counter=min; counter < maxCounter; counter++)     if (!bitSet.get(counter))     return false;\n  }\n  return true;\n}\n", "docstring": "returns true if the paths are contiguous , or this object has no rowmapper .", "partition": "test"}
{"idx": "1990", "code": "protected Object attemptReadResponse(Connection cnx) throws Exception {\n  Message msg=createResponseMessage();\n  if (msg != null) {\n    msg.setComms(cnx.getSocket(),cnx.getInputStream(),cnx.getOutputStream(),cnx.getCommBuffer(),cnx.getStats());\n    if (msg instanceof ChunkedMessage) {\n      try {\n        return processResponse(msg,cnx);\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n    }\n else {\n      try {\n        msg.recv();\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n      return processResponse(msg,cnx);\n    }\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "attempts to read a response to this operation by reading it from the given connection , and returning it .", "partition": "test"}
{"idx": "781", "code": "public static final void pause(final int milliseconds){\n  if (milliseconds >= 1000 || logger.isDebugEnabled()) {\n    logger.info(\"Pausing for {} ms...\",milliseconds);\n  }\n  final long target=System.currentTimeMillis() + milliseconds;\n  try {\n    for (; ; ) {\n      long msLeft=target - System.currentTimeMillis();\n      if (msLeft <= 0) {\n        break;\n      }\n      Thread.sleep(msLeft);\n    }\n  }\n catch (  InterruptedException e) {\n    Assert.fail(\"interrupted\",e);\n  }\n}\n", "docstring": "pause for the specified milliseconds . make sure system clock has advanced by the specified number of millis before returning .", "partition": "test"}
{"idx": "1416", "code": "public boolean isPronounceable(String word){\n  String lowerCaseWord=word.toLowerCase();\n  return (prefixFSM.accept(lowerCaseWord) && suffixFSM.accept(lowerCaseWord));\n}\n", "docstring": "returns true if the given word is pronounceable . this method is originally called us_aswd ( ) in flite 1 . 1 .", "partition": "test"}
{"idx": "1708", "code": "@SafeVarargs public final void insert(int rowIndex,T... newItems){\n  insert(rowIndex,Arrays.asList(newItems));\n}\n", "docstring": "insert new records at a specified index .", "partition": "test"}
{"idx": "3236", "code": "private SortedMap<MessageUid,MaildirMessageName> truncateMap(Map<MessageUid,MaildirMessageName> map,MessageUid from,MessageUid to){\n  TreeMap<MessageUid,MaildirMessageName> sortedMap;\n  if (map instanceof TreeMap<?,?>)   sortedMap=(TreeMap<MessageUid,MaildirMessageName>)map;\n else   sortedMap=new TreeMap<MessageUid,MaildirMessageName>(map);\n  if (to != null)   return sortedMap.subMap(from,to.next());\n  return sortedMap.tailMap(from);\n}\n", "docstring": "sorts the given map and returns a subset which is constricted by a lower and an upper limit .", "partition": "test"}
{"idx": "777", "code": "private static final String decodeFieldName(final String pXmlFieldName){\n  StringBuilder str=new StringBuilder();\n  int fieldNameLength=pXmlFieldName.length();\n  char currentChar;\n  for (int i=0; i < fieldNameLength; i++) {\n    currentChar=pXmlFieldName.charAt(i);\n    if (currentChar == '-') {\n      str.append(Character.toUpperCase(pXmlFieldName.charAt(++i)));\n    }\n else {\n      str.append(currentChar);\n    }\n  }\n  return str.toString();\n}\n", "docstring": "decodes a field name from xml notation ( e . g . my - field - name ) to a valid java field name ( e . g . myfieldname )", "partition": "test"}
{"idx": "1130", "code": "void queryReadResult(PreparedStatement prep) throws SQLException {\n  ResultSet rs=prep.executeQuery();\n  ResultSetMetaData meta=rs.getMetaData();\n  int columnCount=meta.getColumnCount();\n  while (rs.next()) {\n    for (int i=0; i < columnCount; i++) {\n      rs.getString(i + 1);\n    }\n  }\n}\n", "docstring": "execute a query and read all rows .", "partition": "test"}
{"idx": "4129", "code": "public static int findName(String name,int[] table){\n  for (int i=0; i < table.length; i++) {\n    if (name.equals(getName(table[i]))) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "docstring": "get the encoding value of a glyph given its name and a charset .", "partition": "test"}
{"idx": "3984", "code": "private Document parseRouteFile() throws Exception {\n  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n  factory.setNamespaceAware(true);\n  DocumentBuilder builder=factory.newDocumentBuilder();\n  return builder.parse(routeFile);\n}\n", "docstring": "parse the spring integration route file and return dom document .", "partition": "test"}
{"idx": "203", "code": "@Override public boolean isRunning(){\n  return (frame != null && frame.isVisible());\n}\n", "docstring": "returns true if the gui is started and not paused , and false otherwise .", "partition": "test"}
{"idx": "2200", "code": "private void removeObsoleteElements(List<String> names,Map<String,View> sharedElements,List<String> elementsToRemove){\n  if (elementsToRemove.size() > 0) {\n    names.removeAll(elementsToRemove);\n    for (    String elementToRemove : elementsToRemove) {\n      sharedElements.remove(elementToRemove);\n    }\n  }\n}\n", "docstring": "removes obsolete elements from names and shared elements .", "partition": "test"}
{"idx": "142", "code": "public static String map2OID(String algName){\n  return alg2OidMap.get(algName.toUpperCase(Locale.US));\n}\n", "docstring": "returns oid for algname", "partition": "test"}
{"idx": "2914", "code": "public AbstractDMLQuery parseSqlQuery(SQLQuery sqlQuery,ISpaceProxy space) throws SQLException {\n  AbstractDMLQuery query=(AbstractDMLQuery)getQueryFromCache(getUniqueKey(sqlQuery));\n  try {\n    if (query == null) {\n      if (_logger.isLoggable(Level.FINE)) {\n        _logger.fine(\"Query wasn\\'t in cache, will be parsed\");\n      }\n      SqlParser parser=initParser(sqlQuery.getQuery());\n      query=parse(parser);\n      query.setTableName(sqlQuery.getTypeName());\n      query.validateQuery(space);\n      if (!query.isPrepared() && !query.containsSubQueries())       query.build();\n      addQueryToCache(getUniqueKey(sqlQuery),query);\n      if (!query.isPrepared())       return query;\n    }\n    query=query.clone();\n    return query;\n  }\n catch (  SQLException sqlEx) {\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.log(Level.FINE,\"Error executing statement [\" + sqlQuery.getQuery() + \"]\",sqlEx);\n    }\n    throw sqlEx;\n  }\ncatch (  Throwable t) {\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.log(Level.FINE,\"Couldn\\'t parse given statement [\" + sqlQuery.getQuery() + \"]\",t);\n    }\n    SQLException sqlEx=new SQLException(\"Error in statement [\" + sqlQuery.getQuery() + \"]; Cause: \"+ t,\"GSP\",-201);\n    sqlEx.initCause(t);\n    throw sqlEx;\n  }\n}\n", "docstring": "the main method to handle the query . first it will try to retrieve the query from the cache , if its not there , it will build a parser to parse the statement and then put it in the cache .", "partition": "test"}
{"idx": "3528", "code": "public static double assignProbabilitiesToInstances(Relation<? extends NumberVector> relation,List<? extends EMClusterModel<?>> models,WritableDataStore<double[]> probClusterIGivenX){\n  final int k=models.size();\n  double emSum=0.;\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    NumberVector vec=relation.get(iditer);\n    double[] probabilities=new double[k];\n{\n      int i=0;\n      for (      EMClusterModel<?> m : models) {\n        probabilities[i]=m.estimateDensity(vec);\n        ++i;\n      }\n    }\n    double priorProbability=0.;\n    for (int i=0; i < k; i++) {\n      priorProbability+=probabilities[i];\n    }\n    double logP=Math.max(Math.log(priorProbability),MIN_LOGLIKELIHOOD);\n    emSum+=(logP == logP) ? logP : 0.;\n    double[] clusterProbabilities=new double[k];\n    if (priorProbability > 0.) {\n      for (int i=0; i < k; i++) {\n        clusterProbabilities[i]=probabilities[i] / priorProbability;\n      }\n    }\n    probClusterIGivenX.put(iditer,clusterProbabilities);\n  }\n  return emSum / relation.size();\n}\n", "docstring": "assigns the current probability values to the instances in the database and compute the expectation value of the current mixture of distributions . computed as the sum of the logarithms of the prior probability of each instance .", "partition": "test"}
{"idx": "3940", "code": "private void unifyUsernameByName(Map<String,List<LogCommitInfo>> devNameMap){\n  for (  Entry<String,List<LogCommitInfo>> entry : devNameMap.entrySet()) {\n    List<String> userNames=getUserNamesList(entry.getValue());\n    if (userNames.size() > 1) {\n      String newUserName=getNewUserName(userNames);\n      for (      LogCommitInfo commit : entry.getValue()) {\n        commit.setUserName(newUserName);\n      }\n    }\n  }\n}\n", "docstring": "treat similar name aliases", "partition": "test"}
{"idx": "128", "code": "private boolean removeTask(Task t,int min){\n  for (int i=tasks.size(); --i >= min; ) {\n    if (tasks.get(i) == t) {\n      tasks.remove(i);\n      if (i < firstPending) {\n        firstPending--;\n        for (int j=threads.size(); --j >= 0; ) {\n          TaskThread thread=threads.get(j);\n          if (thread.task == t) {\n            if (thread != Thread.currentThread())             thread.interrupt();\n            break;\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "remove a task if it has index > = min . if it is active and not being executed by the calling thread , interrupt the thread executing the task .", "partition": "test"}
{"idx": "220", "code": "private void clearRegisters(Instruction start,Instruction end){\n  for (Instruction p=start; ; p=p.nextInstructionInCodeOrder()) {\n    for (Enumeration<Operand> ops=p.getOperands(); ops.hasMoreElements(); ) {\n      Operand op=ops.nextElement();\n      if (op instanceof RegisterOperand) {\n        RegisterOperand rOp=(RegisterOperand)op;\n        clearDepGraphNodeForRegister(rOp.getRegister());\n      }\n    }\n    if (p == end)     break;\n  }\n  for (Enumeration<Register> e=GenericPhysicalDefUse.enumerateAllImplicitDefUses(ir); e.hasMoreElements(); ) {\n    Register r=e.nextElement();\n    clearDepGraphNodeForRegister(r);\n  }\n}\n", "docstring": "initialize ( clear ) the dnode field in register for all registers in this basic block by setting them to null . handles both explicit and implict use / defs .", "partition": "test"}
{"idx": "3007", "code": "@POST @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @CheckPermission(roles={Role.TENANT_ADMIN}) @Path(\"/{id}/ip-interfaces\") public IpInterfaceRestRep createIpInterface(@PathParam(\"id\") URI id,IpInterfaceCreateParam createParam) throws DatabaseException {\n  Host host=queryObject(Host.class,id,true);\n  validateIpInterfaceData(createParam,null);\n  IpInterface ipInterface=new IpInterface();\n  ipInterface.setHost(host.getId());\n  ipInterface.setId(URIUtil.createId(IpInterface.class));\n  populateIpInterface(createParam,ipInterface);\n  _dbClient.createObject(ipInterface);\n  auditOp(OperationTypeEnum.CREATE_HOST_IPINTERFACE,true,null,ipInterface.auditParameters());\n  return map(ipInterface);\n}\n", "docstring": "creates a new ip interface for a host .", "partition": "test"}
{"idx": "2450", "code": "protected void calculateItemWidth(CategoryPlot plot,Rectangle2D dataArea,int rendererIndex,CategoryItemRendererState state){\n  CategoryAxis domainAxis=getDomainAxis(plot,rendererIndex);\n  CategoryDataset dataset=plot.getDataset(rendererIndex);\n  if (dataset != null) {\n    int columns=dataset.getColumnCount();\n    int rows=state.getVisibleSeriesCount() >= 0 ? state.getVisibleSeriesCount() : dataset.getRowCount();\n    double space=0.0;\n    PlotOrientation orientation=plot.getOrientation();\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      space=dataArea.getHeight();\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      space=dataArea.getWidth();\n    }\n    double maxWidth=space * getMaximumItemWidth();\n    double categoryMargin=0.0;\n    double currentItemMargin=0.0;\n    if (columns > 1) {\n      categoryMargin=domainAxis.getCategoryMargin();\n    }\n    if (rows > 1) {\n      currentItemMargin=getItemMargin();\n    }\n    double used=space * (1 - domainAxis.getLowerMargin() - domainAxis.getUpperMargin()- categoryMargin- currentItemMargin);\n    if ((rows * columns) > 0) {\n      state.setBarWidth(Math.min(used / (rows * columns),maxWidth));\n    }\n else {\n      state.setBarWidth(Math.min(used,maxWidth));\n    }\n  }\n}\n", "docstring": "calculates the bar width and stores it in the renderer state .", "partition": "test"}
{"idx": "272", "code": "@Override protected void ensureNumberOfColumns(int numberOfColumns){\n  if (data.length >= numberOfColumns) {\n    return;\n  }\n  double[] newData=new double[numberOfColumns];\n  System.arraycopy(data,0,newData,0,data.length);\n  data=newData;\n}\n", "docstring": "creates a new array of the given size if necessary and copies the data into the new array .", "partition": "test"}
{"idx": "66", "code": "public void print(File file) throws IOException {\n  checkExec();\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPrintJobAccess();\n  }\n  checkActionSupport(Action.PRINT);\n  checkFileValidation(file);\n  peer.print(file);\n}\n", "docstring": "prints a file with the native desktop printing facility , using the associated application \"'\" s print command .", "partition": "test"}
{"idx": "4175", "code": "private void scrollCurrentItemToCenter(){\n  final ViewItem currItem=mViewItems[BUFFER_CENTER];\n  if (currItem == null) {\n    return;\n  }\n  final int currentViewCenter=currItem.getCenterX();\n  if (mController.isScrolling() || mIsUserScrolling || isCurrentItemCentered()) {\n    Log.d(TAG,\"[fling] mController.isScrolling() - \" + mController.isScrolling());\n    return;\n  }\n  int snapInTime=(int)(SNAP_IN_CENTER_TIME_MS * ((float)Math.abs(mCenterX - currentViewCenter)) / mDrawArea.width());\n  Log.d(TAG,\"[fling] Scroll to center.\");\n  mController.scrollToPosition(currentViewCenter,snapInTime,false);\n}\n", "docstring": "keep the current item in the center . this functions does not check if the current item is null .", "partition": "test"}
{"idx": "2304", "code": "public void createEntityConfig(String realm,FederationConfigElement config) throws WSFederationMetaException {\n  String federationId=config.getFederationID();\n  if (federationId == null) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig: \" + \"entity ID is null\");\n    String[] data={realm};\n    LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_ID_CREATE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(\"empty_entityid\",null);\n  }\n  if (realm == null) {\n    realm=\"/\";\n  }\n  String[] objs={federationId,realm};\n  try {\n    Map attrs=WSFederationMetaUtils.convertJAXBToAttrMap(ATTR_ENTITY_CONFIG,config);\n    Map oldAttrs=configInst.getConfiguration(realm,federationId);\n    if (oldAttrs == null) {\n      LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_DESCRIPTOR_CREATE_ENTITY_CONFIG,objs,null);\n      throw new WSFederationMetaException(\"entity_descriptor_not_exist\",objs);\n    }\n    Set oldValues=(Set)oldAttrs.get(ATTR_ENTITY_CONFIG);\n    if (oldValues != null && !oldValues.isEmpty()) {\n      LogUtil.error(Level.INFO,LogUtil.ENTITY_CONFIG_EXISTS,objs,null);\n      throw new WSFederationMetaException(\"entity_config_exists\",objs);\n    }\n    configInst.setConfiguration(realm,federationId,attrs);\n    LogUtil.access(Level.INFO,LogUtil.ENTITY_CONFIG_CREATED,objs,null);\n    SPSSOConfigElement spconfig=getSPSSOConfig(realm,federationId);\n    if (spconfig != null) {\n      addToCircleOfTrust(spconfig,realm,federationId);\n    }\n    IDPSSOConfigElement idpconfig=getIDPSSOConfig(realm,federationId);\n    if (idpconfig != null) {\n      addToCircleOfTrust(idpconfig,realm,federationId);\n    }\n  }\n catch (  ConfigurationException e) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig:\",e);\n    String[] data={e.getMessage(),federationId,realm};\n    LogUtil.error(Level.INFO,LogUtil.CONFIG_ERROR_CREATE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(e);\n  }\ncatch (  JAXBException jaxbe) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig:\",jaxbe);\n    LogUtil.error(Level.INFO,LogUtil.CREATE_INVALID_ENTITY_CONFIG,objs,null);\n    throw new WSFederationMetaException(\"invalid_config\",objs);\n  }\n}\n", "docstring": "creates the extended entity configuration under the realm .", "partition": "test"}
{"idx": "600", "code": "private boolean hasFullEntry(JsonValue entry,QuerySide querySide){\n  if (querySide == QuerySide.SOURCE && sourceQueryFullEntry != null) {\n    return sourceQueryFullEntry;\n  }\n else   if (querySide == QuerySide.TARGET && targetQueryFullEntry != null) {\n    return targetQueryFullEntry;\n  }\n  if (entry != null) {\n    short ignoreFields=0;\n    if (entry.isDefined(\"_id\")) {\n      ignoreFields++;\n    }\n    if (entry.isDefined(\"_rev\")) {\n      ignoreFields++;\n    }\n    ignoreFields+=2;\n    return entry.size() > ignoreFields;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "whether the query ( source or target side query of a reconciliation ) returns full entry data , or just ids if explicitly configured , returns that setting . if not , tries to auto - detect if a given entry contains just id info , or contains full data the detection has limitations , such as requiring at least three data fields aside from fields it expects in id queries . this may not be case for all custom connectors , in which case explicit config is required instead of using auto detect .", "partition": "test"}
{"idx": "1302", "code": "public byte[] createJarFromFileContent(final String fileName,final String content) throws IOException {\n  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\n  JarOutputStream jarOutputStream=new JarOutputStream(byteArrayOutputStream);\n  JarEntry entry=new JarEntry(fileName);\n  entry.setTime(System.currentTimeMillis());\n  jarOutputStream.putNextEntry(entry);\n  jarOutputStream.write(content.getBytes());\n  jarOutputStream.closeEntry();\n  jarOutputStream.close();\n  return byteArrayOutputStream.toByteArray();\n}\n", "docstring": "create a jar using the given file contents and with the given file name .", "partition": "test"}
{"idx": "77", "code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 112) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "docstring": "unpacks the compressed character translation table .", "partition": "test"}
{"idx": "4241", "code": "protected PrintWriter lineFileOut(Document doc){\n  return lineFileOut;\n}\n", "docstring": "selects output line file by written doc . default : original output line file .", "partition": "test"}
{"idx": "2851", "code": "public double nextDouble(double alpha,double lambda){\n  double a=alpha;\n  double aa=-1.0, aaa=-1.0, b=0.0, c=0.0, d=0.0, e, r, s=0.0, si=0.0, ss=0.0, q0=0.0, q1=0.0416666664, q2=0.0208333723, q3=0.0079849875, q4=0.0015746717, q5=-0.0003349403, q6=0.0003340332, q7=0.0006053049, q8=-0.0004701849, q9=0.0001710320, a1=0.333333333, a2=-0.249999949, a3=0.199999867, a4=-0.166677482, a5=0.142873973, a6=-0.124385581, a7=0.110368310, a8=-0.112750886, a9=0.104089866, e1=1.000000000, e2=0.499999994, e3=0.166666848, e4=0.041664508, e5=0.008345522, e6=0.001353826, e7=0.000247453;\n  double gds, p, q, t, sign_u, u, v, w, x;\n  double v1, v2, v12;\n  if (a <= 0.0)   throw new IllegalArgumentException();\n  if (lambda <= 0.0)   new IllegalArgumentException();\n  if (a < 1.0) {\n    b=1.0 + 0.36788794412 * a;\n    for (; ; ) {\n      p=b * randomGenerator.raw();\n      if (p <= 1.0) {\n        gds=Math.exp(Math.log(p) / a);\n        if (Math.log(randomGenerator.raw()) <= -gds)         return (gds / lambda);\n      }\n else {\n        gds=-Math.log((b - p) / a);\n        if (Math.log(randomGenerator.raw()) <= ((a - 1.0) * Math.log(gds)))         return (gds / lambda);\n      }\n    }\n  }\n else {\n    if (a != aa) {\n      aa=a;\n      ss=a - 0.5;\n      s=Math.sqrt(ss);\n      d=5.656854249 - 12.0 * s;\n    }\n    do {\n      v1=2.0 * randomGenerator.raw() - 1.0;\n      v2=2.0 * randomGenerator.raw() - 1.0;\n      v12=v1 * v1 + v2 * v2;\n    }\n while (v12 > 1.0);\n    t=v1 * Math.sqrt(-2.0 * Math.log(v12) / v12);\n    x=s + 0.5 * t;\n    gds=x * x;\n    if (t >= 0.0)     return (gds / lambda);\n    u=randomGenerator.raw();\n    if (d * u <= t * t * t)     return (gds / lambda);\n    if (a != aaa) {\n      aaa=a;\n      r=1.0 / a;\n      q0=((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;\n      if (a > 3.686) {\n        if (a > 13.022) {\n          b=1.77;\n          si=0.75;\n          c=0.1515 / s;\n        }\n else {\n          b=1.654 + 0.0076 * ss;\n          si=1.68 / s + 0.275;\n          c=0.062 / s + 0.024;\n        }\n      }\n else {\n        b=0.463 + s - 0.178 * ss;\n        si=1.235;\n        c=0.195 / s - 0.079 + 0.016 * s;\n      }\n    }\n    if (x > 0.0) {\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (Math.log(1.0 - u) <= q)       return (gds / lambda);\n    }\n    for (; ; ) {\n      do {\n        e=-Math.log(randomGenerator.raw());\n        u=randomGenerator.raw();\n        u=u + u - 1.0;\n        sign_u=(u > 0) ? 1.0 : -1.0;\n        t=b + (e * si) * sign_u;\n      }\n while (t <= -0.71874483771719);\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (q <= 0.0)       continue;\n      if (q > 0.5) {\n        w=Math.exp(q) - 1.0;\n      }\n else {\n        w=((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;\n      }\n      if (c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {\n        x=s + 0.5 * t;\n        return (x * x / lambda);\n      }\n    }\n  }\n}\n", "docstring": "returns a random number from the distribution ; bypasses the internal state .", "partition": "test"}
{"idx": "366", "code": "private ExchangeRateManager(){\n  if (System.getProperty(\"EXPERIMENTAL\") == null)   throw new UnsupportedOperationException(\"Work in progress\");\n  addKnownRates();\n}\n", "docstring": "constructs a new exchangeratemanager and initialises the most used rates . note : private ; should only be accessed by getinstance ( ) .", "partition": "test"}
{"idx": "496", "code": "private boolean startsWithSpace(String str){\n  return str.length() != 0 && str.charAt(0) == ' ';\n}\n", "docstring": "checks if the string starts with a space character , false if the string is empty or starts with a non - space character .", "partition": "test"}
{"idx": "371", "code": "public void addPutTimeNanos(long duration){\n  putTimeNanos.addAndGet(duration);\n  if (delegate != null)   delegate.addPutTimeNanos(duration);\n}\n", "docstring": "increments the put time accumulator .", "partition": "test"}
{"idx": "3010", "code": "private void ensureNamespaceExists(Result result){\n  DockerImage image=DockerImage.fromImageName(result.name);\n  if (image.getNamespace() == null) {\n    result.name=String.format(\"%s/%s\",DEFAULT_NAMESPACE,image.getRepository());\n  }\n}\n", "docstring": "ensures that an image name has a namespace prefix . an image pushed to a v1 registry without namespace prefix is processed in the following way : < registry_name > / < repository_name > - > < registry_name > / library / < repository_name > results from v1 queries , however , do not contain the default prefix . this could be a problem later when we instantiate containers based on these images . an image pushed to a v2 registry does not get the default prefix .", "partition": "test"}
{"idx": "1835", "code": "public void removeOrganizationConfiguration(String orgName,String groupName,boolean checkLegacyMode) throws SMSException, SSOException {\n  if ((groupName == null) || groupName.length() == 0) {\n    groupName=SMSUtils.DEFAULT;\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  validateSCM();\n  String odn=scm.constructServiceConfigDN(groupName,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,odn);\n  if (cEntry.isNewEntry()) {\n    return;\n  }\n  if (checkLegacyMode && ServiceManager.isCoexistenceMode() && groupName.equalsIgnoreCase(SMSUtils.DEFAULT)) {\n    OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(orgdn),orgdn);\n    amsdk.unassignService(serviceName);\n  }\n  if (!cEntry.isNewEntry()) {\n    SMSEntry entry=cEntry.getClonedSMSEntry();\n    entry.delete(token);\n    cEntry.refresh(entry);\n  }\n}\n", "docstring": "deletes the organization \"'\" s group configuration data .", "partition": "test"}
{"idx": "3607", "code": "public String toString(Object value){\n  return toPrettyString(value);\n}\n", "docstring": "returns pretty string representation of the object .", "partition": "test"}
{"idx": "2044", "code": "public void addImport(@NotNull PsiElement importable,@NotNull PsiFile file,@Nullable PyImportElement importElement){\n  myImports.add(new ImportCandidateHolder(importable,file,importElement,null));\n}\n", "docstring": "adds another import source .", "partition": "test"}
{"idx": "3609", "code": "@SuppressWarnings(\"unchecked\") public synchronized T findCounter(Enum<?> counterKey) throws IllegalAccessException, InstantiationException {\n  T counter=cache.get(counterKey);\n  if (counter == null) {\n    counter=counterType.newInstance();\n    cache.put(counterKey,counter);\n  }\n  return counter;\n}\n", "docstring": "returns the counter associated with the key . creates it if it doesn \"'\" t exist .", "partition": "test"}
{"idx": "2063", "code": "public ExpandRoomFreespaceIncomplete add_incomplete_expansion_room(ShapeTile p_shape,int p_layer,ShapeTile p_contained_shape){\n  ExpandRoomFreespaceIncomplete new_room=new ExpandRoomFreespaceIncomplete(p_shape,p_layer,p_contained_shape);\n  incomplete_expansion_rooms.add(new_room);\n  return new_room;\n}\n", "docstring": "creates a new freespaceexpansionroom and adds it to the room list . its shape is normally unbounded at construction time of the room . the final ( completed ) shape will be a subshape of the start shape , which does not overlap with any obstacle , and it is as big as possible . p_contained_points will remain contained in the shape , after it is completed .", "partition": "test"}
{"idx": "105", "code": "protected double currentScoreFunction(){\n  double score=0.;\n  for (int i=0; i < this.values[this.currentVar1].length; i++) {\n    for (int j=0; j < this.values[this.currentVar2].length; j++) {\n      score-=this.currentCounts[this.currentVar1][this.currentVar2][i][j] * Math.log(this.currentPi[i][j]);\n    }\n  }\n  return score;\n}\n", "docstring": "function to be minimized : - loglikelihood . it * is * assumed that computefibuffer and computecurrentpi were called before this method .", "partition": "test"}
{"idx": "3921", "code": "Attributes parseAttributes() throws JasperException {\n  AttributesImpl attrs=new AttributesImpl();\n  reader.skipSpaces();\n  while (parseAttribute(attrs))   reader.skipSpaces();\n  return attrs;\n}\n", "docstring": "attributes : : = ( s attribute ) * s ?", "partition": "test"}
{"idx": "3370", "code": "public double[] levelZeroData(){\n  List<Buffer> levelZeroBuffers=bufferMap.get(0);\n  int length=0;\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      length+=buffer.size;\n    }\n else {\n      length+=buffer.next;\n    }\n  }\n  int pos=0;\n  int currLen;\n  final double[] out=new double[length];\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      currLen=buffer.size;\n    }\n else {\n      currLen=buffer.next;\n    }\n    System.arraycopy(buffer.data,0,out,pos,currLen);\n    pos+=currLen;\n  }\n  return out;\n}\n", "docstring": "returns a fresh copy of all data from level 0 buffers .", "partition": "test"}
{"idx": "2069", "code": "private double[] max(double[] distances1,double[] distances2){\n  if (distances1.length != distances2.length) {\n    throw new RuntimeException(\"different lengths!\");\n  }\n  double[] result=new double[distances1.length];\n  for (int i=0; i < distances1.length; i++) {\n    result[i]=Math.max(distances1[i],distances2[i]);\n  }\n  return result;\n}\n", "docstring": "returns an array that holds the maximum values of the both specified arrays in each index .", "partition": "test"}
{"idx": "1447", "code": "public static Properties parsePropertyList(String list) throws PropertyStringFormatException {\n  return parsePropertyList(list,propertySeparators,keyValueSeparators);\n}\n", "docstring": "take a property list , defined in a single string , and return a properties object . the properties , as key - value pairs , are separated by another type of symbol . in this method , the key - values are assumed to be separated from other key - value pairs by proputils . propertyseparators string characters , and each key is separated from its value by any character in the proputils . keyvalueseparators list .", "partition": "test"}
{"idx": "3257", "code": "public static boolean isOrgLevelOnly(int AD_Client_ID,int AD_Table_ID){\n  Boolean share=isShared(AD_Client_ID,AD_Table_ID);\n  if (share != null)   return !share.booleanValue();\n  return false;\n}\n", "docstring": "is table org level only", "partition": "test"}
{"idx": "2693", "code": "protected void paintContentBorderBottomEdge(Graphics g,int x,int y,int w,int h,boolean drawBroken,Rectangle selRect,boolean isContentBorderPainted){\n  if (isContentBorderPainted) {\n    g.setColor(darkShadow);\n    g.fillRect(x,y + h - 1,w - 1,1);\n  }\n}\n", "docstring": "draws the bottom edge of the border around the content area . draw broken line if selected tab is visible and adjacent to content and tabplacement is same as painted edge .", "partition": "test"}
{"idx": "2409", "code": "ProxyVerifier(TxnManager serverProxy,Uuid proxyID){\n  if (!(serverProxy instanceof RemoteMethodControl)) {\n    throw new UnsupportedOperationException(\"No verifier available for non-constrainable service\");\n  }\n else   if (!(serverProxy instanceof TrustEquivalence)) {\n    throw new UnsupportedOperationException(\"Verifier requires service proxy to implement \" + \"TrustEquivalence\");\n  }\n else   if (proxyID == null) {\n    throw new IllegalArgumentException(\"Proxy id cannot be null\");\n  }\n  this.serverProxy=(RemoteMethodControl)serverProxy;\n  this.proxyID=proxyID;\n}\n", "docstring": "returns a verifier for the smart proxies of the specified mahalo server proxy .", "partition": "test"}
{"idx": "1950", "code": "public ByteBandedRaster(SampleModel sampleModel,Point origin){\n  this(sampleModel,sampleModel.createDataBuffer(),new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}\n", "docstring": "constructs a bytebandedraster with the given samplemodel . the raster \"'\" s upper left corner is origin and it is the same size as the samplemodel . a databuffer large enough to describe the raster is automatically created . samplemodel must be of type bandedsamplemodel .", "partition": "test"}
{"idx": "1737", "code": "public static boolean isPostJDK7(String bytecodeVersion){\n  return JDK7.equals(bytecodeVersion) || JDK8.equals(bytecodeVersion);\n}\n", "docstring": "checks if the specified bytecode version string represents a jdk 1 . 7 + compatible bytecode version .", "partition": "test"}
{"idx": "1450", "code": "public void makeGraph(File linkGraph) throws Exception {\n  String temp212;\n  int rowNum=0;\n  BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(linkGraph)));\n  while ((temp212=br.readLine()) != null) {\n    String[] strs=temp212.split(\" \");\n    for (int i=0; i < strs.length; i++) {\n      graph[rowNum][i]=Double.parseDouble(strs[i]);\n    }\n    rowNum++;\n  }\n  for (int i=0; i < dataNum; i++) {\n    for (int j=0; j < dimension; j++) {\n      W[i][j]=r.nextDouble();\n      H[j][i]=r.nextDouble();\n    }\n  }\n  for (int i=0; i < dataNum; i++) {\n    double sumW=0;\n    double sumH=0;\n    for (int j=0; j < dimension; j++) {\n      sumW+=W[i][j] * W[i][j];\n      sumH+=H[j][i] * H[j][i];\n    }\n    sumW=Math.sqrt(sumW);\n    sumH=Math.sqrt(sumH);\n    for (int j=0; j < dimension; j++) {\n      W[i][j]/=sumW;\n      H[j][i]/=sumH;\n    }\n  }\n  trainW();\n  init=false;\n}\n", "docstring": "read in the normalized category file .", "partition": "test"}
{"idx": "18", "code": "public void deleteLeaves(String name){\n  for (int i=0; i < _leaves.size(); i++) {\n    CatalogTreeLeaf leaf=_leaves.get(i);\n    if (name.equals(leaf.getName())) {\n      _leaves.remove(i);\n    }\n  }\n}\n", "docstring": "leaves can be used for many - to - many relations", "partition": "test"}
{"idx": "3090", "code": "private void testScenario(String aConfiguration,boolean anExpectingAnException,List<Method> aMethodsToCall) throws Exception {\n  if (aMethodsToCall.isEmpty()) {\n    testScenario(aConfiguration,anExpectingAnException,(Method)null);\n  }\n else {\n    for (    Method myMethod : aMethodsToCall) {\n      testScenario(aConfiguration,anExpectingAnException,myMethod);\n    }\n  }\n}\n", "docstring": "load an element with default configuration and call tostring . expect that the tostring triggers lazy loading which loads the nested element is available after closing the session .", "partition": "test"}
{"idx": "4046", "code": "void appendProgramDescription(final WrappingStringBuilder wb){\n  if (!mProgramDescription.equals(\"\")) {\n    wb.append(LS);\n    wb.setWrapIndent(0);\n    wb.wrapTextWithNewLines(mProgramDescription);\n  }\n}\n", "docstring": "append the description text for this program , if one exists .", "partition": "test"}
{"idx": "1386", "code": "public static int round(final float value){\n  final int bits=Float.floatToRawIntBits(value);\n  final int biasedExp=bits >> 23 & 0xFF;\n  final int shift=23 - 1 + MAX_FLOAT_EXPONENT - biasedExp;\n  if ((shift & -32) == 0) {\n    int extendedMantissa=0x00800000 | bits & 0x007FFFFF;\n    if (bits < 0) {\n      extendedMantissa=-extendedMantissa;\n    }\n    return (extendedMantissa >> shift) + 1 >> 1;\n  }\n else {\n    return (int)value;\n  }\n}\n", "docstring": "might have different semantics than math . round ( float ) , see bugs 6430675 and 8010430 .", "partition": "test"}
{"idx": "2411", "code": "private static long addAndCheck(long a,long b,Localizable pattern) throws MathRuntimeException {\n  final long result=a + b;\n  if (!((a ^ b) < 0 || (a ^ result) >= 0)) {\n    throw new MathRuntimeException(pattern,a,b);\n  }\n  return result;\n}\n", "docstring": "add two long integers , checking for overflow .", "partition": "test"}
{"idx": "3870", "code": "private FormatString[] parse(String s){\n  ArrayList<FormatString> al=new ArrayList<>();\n  Matcher m=fsPattern.matcher(s);\n  for (int i=0, len=s.length(); i < len; ) {\n    if (m.find(i)) {\n      if (m.start() != i) {\n        checkText(s,i,m.start());\n        al.add(new FixedString(s.substring(i,m.start())));\n      }\n      al.add(new FormatSpecifier(m));\n      i=m.end();\n    }\n else {\n      checkText(s,i,len);\n      al.add(new FixedString(s.substring(i)));\n      break;\n    }\n  }\n  return al.toArray(new FormatString[al.size()]);\n}\n", "docstring": "finds format specifiers in the format string .", "partition": "test"}
{"idx": "2960", "code": "public JsonArray add(String value){\n  values.add(Json.value(value));\n  return this;\n}\n", "docstring": "appends the json representation of the specified string to the end of this array .", "partition": "test"}
{"idx": "1244", "code": "public static String cleanFolderStackingMarkers(String filename){\n  if (!StringUtils.isEmpty(filename)) {\n    Matcher m=folderStackingPattern.matcher(filename);\n    if (m.matches()) {\n      return m.group(1) + m.group(3);\n    }\n  }\n  return filename;\n}\n", "docstring": "clean stacking markers . < br > same logic as detection , but just returning string w / o", "partition": "test"}
{"idx": "3996", "code": "private void loadBinary(InputStream is) throws IOException {\n  if (is instanceof FileInputStream) {\n    FileInputStream fis=(FileInputStream)is;\n    FileChannel fc=fis.getChannel();\n    MappedByteBuffer bb=fc.map(FileChannel.MapMode.READ_ONLY,0,(int)fc.size());\n    bb.load();\n    loadBinary(bb);\n    is.close();\n  }\n else {\n    loadBinary(new DataInputStream(is));\n  }\n}\n", "docstring": "loads a binary file from the input stream .", "partition": "test"}
{"idx": "2510", "code": "public static double quantile(double p,double k,double theta,double shift){\n  return Math.exp(GammaDistribution.quantile(p,k,theta)) + shift;\n}\n", "docstring": "compute probit ( inverse cdf ) for loggamma distributions .", "partition": "test"}
{"idx": "3005", "code": "public void addLayoutEditor(LayoutEditor panel){\n  if (panels.size() > 0) {\n    for (int i=0; i < panels.size(); i++) {\n      LayoutEditor ed=panels.get(i);\n      if (ed == panel) {\n        return;\n      }\n    }\n  }\n  panels.add(panel);\n}\n", "docstring": "keeps track of layouteditor panels that are using this layoutblock", "partition": "test"}
{"idx": "3292", "code": "public void testGetTables() throws Exception {\n  DatabaseMetaData dmd=con.getMetaData();\n  ResultSet rs=dmd.getTables(null,null,null,null);\n  assertNotNull(rs);\n  rs.close();\n}\n", "docstring": "test for bug [ 998765 ", "partition": "test"}
{"idx": "3555", "code": "public void test_copyStream_fullBlock() throws IOException {\n  final String id=\"test\";\n  final int version=0;\n  Random r=new Random();\n  final byte[] expected=new byte[BLOCK_SIZE];\n  r.nextBytes(expected);\n  assertEquals(\"nbytes\",expected.length,repo.copyStream(id,version,new ByteArrayInputStream(expected)));\n  assertEquals(\"blockCount\",1,repo.getBlockCount(id,version));\n  assertSameIterator(\"block identifiers\",new Long[]{0L},repo.blocks(id,version));\n  assertEquals(\"data\",expected,read(repo.inputStream(id,version)));\n}\n", "docstring": "test copy of an stream containing exactly one block \"'\" s data .", "partition": "test"}
{"idx": "4075", "code": "public String(StringBuffer stringbuffer){\n  offset=0;\nsynchronized (stringbuffer) {\n    value=stringbuffer.shareValue();\n    count=stringbuffer.length();\n  }\n}\n", "docstring": "creates a string from the contents of a stringbuffer .", "partition": "test"}
{"idx": "14", "code": "public TcpMatcher(final NetworkConfig config){\n  super(config);\n}\n", "docstring": "creates a new matcher for running coap over tcp .", "partition": "test"}
{"idx": "1656", "code": "public Hour(int hour,Day day){\n  ParamChecks.nullNotPermitted(day,\"day\");\n  this.hour=(byte)hour;\n  this.day=day;\n  peg(Calendar.getInstance());\n}\n", "docstring": "constructs a new hour .", "partition": "test"}
{"idx": "1746", "code": "public PetCategory findOne(String id){\n  log.debug(\"Request to get PetCategory : {}\",id);\n  PetCategory petCategory=petCategoryRepository.findOne(UUID.fromString(id));\n  return petCategory;\n}\n", "docstring": "get one petcategory by id .", "partition": "test"}
{"idx": "4199", "code": "public boolean removeArg(final BOp arg){\n  if (arg == null)   throw new IllegalArgumentException();\n  if (arg == this)   throw new IllegalArgumentException();\n  if (args.remove(arg)) {\n    mutation();\n    return true;\n  }\n  return false;\n}\n", "docstring": "remove the 1st occurrence of the argument ( core mutation method ) .", "partition": "test"}
{"idx": "1080", "code": "public static String quoteIfJavaKeyword(String name){\n  return JVMModuleUtil.quoteIfJavaKeyword(name);\n}\n", "docstring": "prefixes the given name with a dollar ( $ ) if it is a java keyword", "partition": "test"}
{"idx": "3490", "code": "public synchronized void checkState(State... requiredStates) throws IllegalStateException {\n  for (  State requiredState : requiredStates) {\n    if (requiredState.equals(currentState)) {\n      return;\n    }\n  }\n  throw new IllegalStateException(String.format(Locale.US,\"Expected states %s, but in state %s\",Lists.newArrayList(requiredStates),currentState));\n}\n", "docstring": "checks that the machine is in one of the given states . throws if it isn \"'\" t .", "partition": "test"}
{"idx": "2183", "code": "public void recordTimestamp(){\n  long curTimestamp=System.currentTimeMillis();\n  if (usedFields > 0) {\n    long diff=curTimestamp - lastValue;\n    if (usedFields == diffs.length) {\n      long removedValue=diffs[curPosition];\n      diffs[curPosition]=diff;\n      calculateNewAverage(removedValue,diff,false);\n      shiftEnd();\n    }\n else {\n      calculateNewAverage(0,diff,true);\n      diffs[curPosition]=diff;\n      shiftEnd();\n    }\n  }\n else   if (lastValue != -1) {\n    long diff=curTimestamp - lastValue;\n    currentAverage=0;\n    diffs[curPosition]=diff;\n    calculateNewAverage(0,diff,true);\n    shiftEnd();\n  }\n  lastValue=curTimestamp;\n}\n", "docstring": "adds a value and calculates the new average of differences between the values within the window size provided at creation .", "partition": "test"}
{"idx": "213", "code": "public synchronized void increase(){\n  if (accuracy > 0) {\n    long timePassed=System.currentTimeMillis() - lastAdded;\n    if (timePassed > accuracy) {\n      clearUp();\n      if (count > 0) {\n        data.addFirst(lastAdded + accuracy);\n      }\n      lastAdded=System.currentTimeMillis();\n      count=0;\n    }\n    count++;\n  }\n else {\n    clearUp();\n    data.addFirst(System.currentTimeMillis());\n  }\n}\n", "docstring": "adds an element to the counter or caches it to be added .", "partition": "test"}
{"idx": "3520", "code": "public static List<Interval> sliceIntervals(Interval interval,TimeGrain timeGrain){\n  DateTime intervalEnd=interval.getEnd();\n  DateTime sliceStart=interval.getStart();\n  DateTime periodStart=timeGrain.roundFloor(sliceStart);\n  if (!sliceStart.equals(periodStart)) {\n    LOG.info(\"Interval {} is not aligned to TimeGrain {} starting {}\",interval,timeGrain,periodStart);\n    throw new IllegalArgumentException(\"Interval must be aligned to the TimeGrain starting \" + periodStart);\n  }\n  List<Interval> intervalSlices=new ArrayList<>();\n  while (sliceStart.isBefore(intervalEnd)) {\n    DateTime sliceEnd=DateTimeUtils.addTimeGrain(sliceStart,timeGrain);\n    Interval slicedInterval=new Interval(sliceStart,sliceEnd);\n    if (!interval.contains(slicedInterval)) {\n      LOG.info(\"Interval {} is not a multiple of TimeGrain {}\",interval,timeGrain);\n      throw new IllegalArgumentException(\"Interval must be a multiple of the TimeGrain\");\n    }\n    intervalSlices.add(slicedInterval);\n    sliceStart=sliceEnd;\n  }\n  LOG.debug(\"Sliced interval {} into {} slices of {} grain\",interval,intervalSlices.size(),timeGrain);\n  return intervalSlices;\n}\n", "docstring": "slices the intervals into smaller intervals of the timegrain duration .", "partition": "test"}
{"idx": "3796", "code": "public boolean showPreviousNotification(){\n  int i=getSelectedIndex();\n  if (i != -1 && i > 0) {\n    model.setSelectedItem(model.getElementAt(i - 1));\n    return true;\n  }\n  return false;\n}\n", "docstring": "scrolls to the previous notification .", "partition": "test"}
{"idx": "1354", "code": "public void testZeroOne(){\n  byte aBytes[]={0};\n  byte bBytes[]={1};\n  int aSign=0;\n  int bSign=1;\n  byte rBytes[]={1};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.or(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "or for zero and one", "partition": "test"}
{"idx": "3672", "code": "public BasicCondition(String variable,Value value,Relation relation){\n  this.variable=Template.create(variable);\n  this.templateValue=Template.create(value.toString());\n  this.groundValue=value;\n  this.relation=relation;\n}\n", "docstring": "creates a new basic condition , given a variable label , an expected value , and a relation to hold between the variable and its value", "partition": "test"}
{"idx": "4216", "code": "public void sendMessageUntilStopCount(int stopCount){\n  for (int i=processedWorkerCount; i < workers.size(); ++i) {\n    ActorRef worker=workers.get(i);\n    try {\n      Thread.sleep(1L);\n    }\n catch (    InterruptedException e) {\n      logger.error(\"sleep exception \" + e + \" details: \",e);\n    }\n    worker.tell(OperationWorkerMsgType.PROCESS_REQUEST,originalManager);\n    processedWorkerCount++;\n    if (processedWorkerCount > stopCount) {\n      return;\n    }\n    logger.debug(\"REQ_SENT: {} / {} taskId {}\",processedWorkerCount,requestTotalCount,taskIdTrim);\n  }\n}\n", "docstring": "note that if there is sleep in this method .", "partition": "test"}
{"idx": "693", "code": "public static void assertExpectedOutputContains(String expectedString,String x){\n  if (!x.contains(expectedString)) {\n    fail(\"expected \\'\" + expectedString + \"\\' not found in \\'\"+ x+ \"\\'\");\n  }\n}\n", "docstring": "fails if expectedstring is not found in x", "partition": "test"}
{"idx": "2151", "code": "public void addSuccessMessage(final String successMessage){\n  successMessageList.add(successMessage);\n}\n", "docstring": "adds a success message into the list .", "partition": "test"}
{"idx": "313", "code": "private Collection<Var> migrateColumns(SQLTable currentTable){\n  List<Var> vars=new ArrayList<>();\n  String tableType=currentTable.getEntityType();\n  Map<String,ResourceType.DataType> columns=currentTable.getColumns();\n  Map<String,String> foreignColumns=currentTable.getForeignKeyColumns();\n  for (  String column : columns.keySet()) {\n    ResourceType.DataType columnType=columns.get(column);\n    if (foreignColumns.containsKey(column)) {\n      vars.addAll(migrateAsRelation(tableType,column,foreignColumns.get(column)));\n    }\n else {\n      vars.addAll(migrateAsResource(tableType,columnType,column));\n    }\n  }\n  return vars;\n}\n", "docstring": "loop through each of the columns in the given table , migrating each as a resource or relation .", "partition": "test"}
{"idx": "1804", "code": "public boolean equals(Object interval){\n  if (intervals == null) {\n    return false;\n  }\n  return intervals.contains(interval);\n}\n", "docstring": "determine the matching test . defaults to equality of the node based upon the interval . subclasses can override , for example , to determine if the interval is contained within the node \"'\" s information .", "partition": "test"}
{"idx": "1560", "code": "public static Set<String> toStringSet(TemplateSequenceModel seqModel) throws TemplateModelException {\n  Set<String> set=new HashSet<String>();\n  for (int i=0; i < seqModel.size(); i++) {\n    set.add(getAsStringNonEscaping((TemplateScalarModel)seqModel.get(i)));\n  }\n  return set;\n}\n", "docstring": "to string set . < p > warn : bypasses auto - escaping , caller handles . ( e . g . the object wrapper used to rewrap the result ) .", "partition": "test"}
{"idx": "244", "code": "@SuppressWarnings(\"unchecked\") static public void assertSameIteratorAnyOrder(final Object[] expected,final Iterator actual){\n  assertSameIteratorAnyOrder(\"\",expected,actual);\n}\n", "docstring": "verifies that the iterator visits the specified objects in some arbitrary ordering and that the iterator is exhausted once all expected objects have been visited . the implementation uses a selection without replacement \" pattern \" .", "partition": "test"}
{"idx": "3983", "code": "public <AnnotationType extends Annotation>void register(MethodBinder<AnnotationType> methodBinder){\n  Set<AnnotatedMethod<AnnotationType>> annotatedMethods=AnnotatedMethods.get(methodBinder.getAnnotationClass(),annotatedType);\n  if (!annotatedMethods.isEmpty()) {\n    objectBinders.add(new AnnotatedMethodBinder<>(methodBinder,annotatedMethods));\n  }\n}\n", "docstring": "update the cache with this binder", "partition": "test"}
{"idx": "3859", "code": "public void removeListener(@NotNull ConfigurationListener listener){\n  if (myListeners != null) {\n    myListeners.remove(listener);\n    if (myListeners.isEmpty()) {\n      myListeners=null;\n    }\n  }\n}\n", "docstring": "removes a listener such that it is no longer notified of changes", "partition": "test"}
{"idx": "3783", "code": "@Ignore(\"TODO: test is disabled\") @Test public void testPopulate1kbwrites(){\n  final byte[] value=new byte[ENTRY_SIZE];\n  Arrays.fill(value,(byte)77);\n  for (int i=0; i < OP_COUNT; i++) {\n    region.put(new Integer(i),value);\n  }\n  closeDown();\n}\n", "docstring": "currently not being executed for congo but after transition to jdk 1 . 5 , this test should be executed .", "partition": "test"}
{"idx": "680", "code": "void doHandleJavaMouseEvent(MouseEvent mouseEvent){\n  if (!XToolkit.isLeftMouseButton(mouseEvent) && !XToolkit.isRightMouseButton(mouseEvent)) {\n    return;\n  }\n  XBaseWindow grabWindow=XAwtState.getGrabWindow();\n  Point ptGlobal=mouseEvent.getLocationOnScreen();\n  if (!hasPointerMoved) {\n    if (grabInputPoint == null || (Math.abs(ptGlobal.x - grabInputPoint.x) > getMouseMovementSmudge()) || (Math.abs(ptGlobal.y - grabInputPoint.y) > getMouseMovementSmudge())) {\n      hasPointerMoved=true;\n    }\n  }\n  XBaseMenuWindow wnd=getMenuWindowFromPoint(ptGlobal);\n  XMenuItemPeer item=(wnd != null) ? wnd.getItemFromPoint(wnd.toLocal(ptGlobal)) : null;\n  XBaseMenuWindow cwnd=getShowingLeaf();\nswitch (mouseEvent.getID()) {\ncase MouseEvent.MOUSE_PRESSED:\n    showingMousePressedSubmenu=null;\n  if ((grabWindow == this) && (wnd == null)) {\n    ungrabInput();\n  }\n else {\n    grabInput();\n    if (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\n      if (wnd.getShowingSubmenu() == item) {\n        showingMousePressedSubmenu=(XMenuPeer)item;\n      }\n      wnd.selectItem(item,true);\n    }\n else {\n      if (wnd != null) {\n        wnd.selectItem(null,false);\n      }\n    }\n  }\nbreak;\ncase MouseEvent.MOUSE_RELEASED:\nif (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\nif (item instanceof XMenuPeer) {\n  if (showingMousePressedSubmenu == item) {\n    if (wnd instanceof XMenuBarPeer) {\n      ungrabInput();\n    }\n else {\n      wnd.selectItem(item,false);\n    }\n  }\n}\n else {\n  item.action(mouseEvent.getWhen());\n  ungrabInput();\n}\n}\n else {\nif (hasPointerMoved || (wnd instanceof XMenuBarPeer)) {\n  ungrabInput();\n}\n}\nshowingMousePressedSubmenu=null;\nbreak;\ncase MouseEvent.MOUSE_DRAGGED:\nif (wnd != null) {\nif (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\nif (grabWindow == this) {\nwnd.selectItem(item,true);\n}\n}\n else {\nwnd.selectItem(null,false);\n}\n}\n else {\nif (cwnd != null) {\ncwnd.selectItem(null,false);\n}\n}\nbreak;\n}\n}\n", "docstring": "performs handling of java mouse event note that this function should be invoked only from root of menu window \"'\" s hierarchy that grabs input focus", "partition": "test"}
{"idx": "1001", "code": "public void show(char initialChar){\n  initialString=initialString.append(initialChar);\n  show();\n  if (SWT.getPlatform() != \"carbon\") {\n    setEditText(initialString.toString());\n  }\n}\n", "docstring": "performs show and sets the edit string to be the initial character or string", "partition": "test"}
{"idx": "2956", "code": "public SSLSocket createSSLSocket(Socket socket) throws IOException {\n  SSLSocketFactory sf=((SSLSocketFactory)SSLSocketFactory.getDefault());\n  InetSocketAddress remoteAddress=(InetSocketAddress)socket.getRemoteSocketAddress();\n  SSLSocket s=(SSLSocket)(sf.createSocket(socket,remoteAddress.getHostName(),socket.getPort(),true));\n  s.setUseClientMode(false);\n  s.setEnabledCipherSuites(s.getSupportedCipherSuites());\n  return s;\n}\n", "docstring": "create a ssl socket that wraps the existing socket . this method is called after the client issued the starttls command . < p > subclasses may override this method to configure the key stores , enabled protocols / cipher suites , enforce client authentication , etc .", "partition": "test"}
{"idx": "767", "code": "public String tag(String inner,String c1,String c2){\n  boolean color=((attr & ATTR_COLOR) == ATTR_COLOR) && ToastBootstrap.color;\n  String s=\"[\";\n  if (color)   s+=\"<\" + c1 + \">\";\n  s+=inner;\n  if (color)   s+=\"<\" + c2 + \">\";\n  s+=\"] \";\n  if (color)   s+=\"<\" + c1 + \">\";\n  return color ? Pretty.format(s) : s;\n}\n", "docstring": "return a tag , maybe formatted with color", "partition": "test"}
{"idx": "2787", "code": "protected OkHttpClient configureHttpClient(){\n  final OkHttpClient.Builder builder=new OkHttpClient.Builder();\n  final CookieManager cookieManager=new CookieManager();\n  cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ALL);\n  builder.cookieJar(new JavaNetCookieJar(cookieManager));\n  builder.connectTimeout(60,TimeUnit.SECONDS);\n  builder.writeTimeout(60,TimeUnit.SECONDS);\n  builder.readTimeout(90,TimeUnit.SECONDS);\n  return builder.build();\n}\n", "docstring": "configures the http client .", "partition": "test"}
{"idx": "283", "code": "public double readDouble() throws IOException {\n  return primitiveTypes.readDouble();\n}\n", "docstring": "reads a double ( 64 bit ) from the source stream .", "partition": "test"}
{"idx": "2152", "code": "private void startStoppedChanged(){\n  clock.setStartStopped(startStoppedCheckBox.isSelected());\n  changed=true;\n}\n", "docstring": "method to handle start stopped check box change", "partition": "test"}
{"idx": "2357", "code": "protected void updateStatsForConditionalDensityEstimator(ConditionalDensityEstimator classifier,Instance classMissing,double classValue) throws Exception {\n  if (m_PriorEstimator == null) {\n    setNumericPriorsFromBuffer();\n  }\n  m_SumSchemeEntropy-=classifier.logDensity(classMissing,classValue) * classMissing.weight() / Utils.log2;\n  m_SumPriorEntropy-=m_PriorEstimator.logDensity(classValue) * classMissing.weight() / Utils.log2;\n}\n", "docstring": "updates stats for conditional density estimator based on current test instance .", "partition": "test"}
{"idx": "2519", "code": "private static void runRandomTest(final int wordLength,final int bytePadding,final int wordCount){\n  final long seed=randomLong();\n  final Random random=new Random(seed);\n  final Random verificationRandom=new Random(seed);\n  final long wordMask;\n  if (wordLength == 64) {\n    wordMask=~0L;\n  }\n else {\n    wordMask=(1L << wordLength) - 1L;\n  }\n  final BigEndianAscendingWordSerializer serializer=new BigEndianAscendingWordSerializer(wordLength,wordCount,bytePadding);\n  for (int i=0; i < wordCount; i++) {\n    final long value=random.nextLong() & wordMask;\n    serializer.writeWord(value);\n  }\n  final byte[] bytes=serializer.getBytes();\n  final BigEndianAscendingWordDeserializer deserializer=new BigEndianAscendingWordDeserializer(wordLength,bytePadding,bytes);\n  assertEquals(deserializer.totalWordCount(),wordCount);\n  for (int i=0; i < wordCount; i++) {\n    assertEquals(deserializer.readWord(),(verificationRandom.nextLong() & wordMask));\n  }\n}\n", "docstring": "runs a test which serializes and deserializes random word values .", "partition": "test"}
{"idx": "3836", "code": "private String convertUserInputIntoAFullyQualifiedPath(final String userInput){\n  if (FileUtils.denotesAbsolutePath(userInput)) {\n    return userInput;\n  }\n  if (userInput.startsWith(HOME_DIRECTORY_SYMBOL)) {\n    Assert.notNull(home,\"Home directory could not be determined from system properties\");\n    if (userInput.length() > 1) {\n      return home + userInput.substring(1);\n    }\n  }\n  String fullPath=getWorkingDirectoryAsString() + userInput;\n  return fullPath;\n}\n", "docstring": "if the user input starts with a tilde character ( ~ ) , replace the tilde character with the user \"'\" s home directory . if the user input does not start with a tilde , simply return the original user input without any changes if the input specifies an absolute path , or return an absolute path based on the working directory if the input specifies a relative path .", "partition": "test"}
{"idx": "817", "code": "public double wide(Prior prior,Likelihood likelihood) throws OperatorFailedException {\n  final int nodeCount=tree.getNodeCount();\n  final NodeRef root=tree.getRoot();\n  NodeRef i;\n  int indexI;\n  do {\n    indexI=MathUtils.nextInt(nodeCount);\n    i=tree.getNode(indexI);\n  }\n while (root == i || (tree.getParent(i) == root && tree.getNodeHeight(i) > tree.getNodeHeight(getOtherChild(tree,tree.getParent(i),i))));\n  List<Integer> secondNodeIndices=new ArrayList<Integer>();\n  List<Double> probabilities=new ArrayList<Double>();\n  NodeRef j, jP;\n  NodeRef iP=tree.getParent(i);\n  double heightIP=tree.getNodeHeight(iP);\n  double heightI=tree.getNodeHeight(i);\n  double sum=0.0;\n  double backward=calculateTreeLikelihood(prior,likelihood,tree);\n  int offset=(int)-backward;\n  backward=Math.exp(backward + offset);\n  for (int n=0; n < nodeCount; n++) {\n    j=tree.getNode(n);\n    if (j != root) {\n      jP=tree.getParent(j);\n      if ((iP != jP) && (tree.getNodeHeight(j) < heightIP) && (heightI < tree.getNodeHeight(jP))) {\n        secondNodeIndices.add(n);\n        swap(tree,i,j,iP,jP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        probabilities.add(prob);\n        swap(tree,i,j,jP,iP);\n        sum+=prob;\n      }\n    }\n  }\n  if (sum <= 1E-100) {\n    throw new OperatorFailedException(\"Couldn\\'t find another proposal with a decent likelihood.\");\n  }\n  double ran=Math.random() * sum;\n  int index=0;\n  while (ran > 0.0) {\n    ran-=probabilities.get(index);\n    index++;\n  }\n  index--;\n  j=tree.getNode(secondNodeIndices.get(index));\n  jP=tree.getParent(j);\n  double heightJP=tree.getNodeHeight(jP);\n  double heightJ=tree.getNodeHeight(j);\n  double sumForward2=0.0;\n  NodeRef k, kP;\n  for (int n=0; n < nodeCount; n++) {\n    k=tree.getNode(n);\n    if (k != root) {\n      kP=tree.getParent(k);\n      if ((jP != kP) && (tree.getNodeHeight(k) < heightJP) && (heightJ < tree.getNodeHeight(kP))) {\n        swap(tree,j,k,jP,kP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        sumForward2+=prob;\n        swap(tree,j,k,kP,jP);\n      }\n    }\n  }\n  swap(tree,i,j,iP,jP);\n  double forward=probabilities.get(index);\n  iP=jP;\n  heightIP=heightJP;\n  double sumBackward=0.0;\n  for (int n=0; n < nodeCount; n++) {\n    j=tree.getNode(n);\n    if (j != root) {\n      jP=tree.getParent(j);\n      if ((iP != jP) && (tree.getNodeHeight(j) < heightIP) && (heightI < tree.getNodeHeight(jP))) {\n        swap(tree,i,j,iP,jP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        sumBackward+=prob;\n        swap(tree,i,j,jP,iP);\n      }\n    }\n  }\n  double sumBackward2=0.0;\n  j=tree.getNode(secondNodeIndices.get(index));\n  jP=tree.getParent(j);\n  heightJP=tree.getNodeHeight(jP);\n  heightJ=tree.getNodeHeight(j);\n  for (int n=0; n < nodeCount; n++) {\n    k=tree.getNode(n);\n    if (k != root) {\n      kP=tree.getParent(k);\n      if ((jP != kP) && (tree.getNodeHeight(k) < heightJP) && (heightJ < tree.getNodeHeight(kP))) {\n        swap(tree,j,k,jP,kP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        sumBackward2+=prob;\n        swap(tree,j,k,kP,jP);\n      }\n    }\n  }\n  double forwardProb=(forward / sum) + (forward / sumForward2);\n  double backwardProb=(backward / sumBackward) + (backward / sumBackward2);\n  double hastingsRatio=Math.log(backwardProb / forwardProb);\n  return hastingsRatio;\n}\n", "docstring": "warning : assumes strictly bifurcating tree .", "partition": "test"}
{"idx": "3530", "code": "public Kernel(int offset,double[] values){\n  this.values=Arrays.copyOf(values,values.length);\n  this.offset=offset;\n}\n", "docstring": "creates a new kernel object with the specified offset and values .", "partition": "test"}
{"idx": "558", "code": "int put(T segment,List<? super T> recycleBin){\n  int count;\n  if (lastCount == 0) {\n    count=0;\n    lastCount=1;\n    last=segment;\n  }\n else   if (Objects.deepEquals(last,segment)) {\n    ++lastCount;\n    count=0;\n    recycleBin.add(segment);\n  }\n else {\n    count=lastCount;\n    lastCount=1;\n    last=segment;\n  }\n  return count;\n}\n", "docstring": "adds an element to the stream . if that element is the same as the last element this buffer saw , it won \"'\" t be added to the stream , but will instead be recycled . if this element is different than the one before , this class will return the number of times that other element had been seen . the caller is responsible for having retrieved that element before calling this method .", "partition": "test"}
{"idx": "2290", "code": "public void addMethod(SootMethod m){\n  checkLevel(SIGNATURES);\n  if (m.isDeclared())   throw new RuntimeException(\"already declared: \" + m.getName());\n  if (subSigToMethods.get(m.getNumberedSubSignature()) != null) {\n    throw new RuntimeException(\"Attempting to add method \" + m.getSubSignature() + \" to class \"+ this+ \", but the class already has a method with that signature.\");\n  }\n  subSigToMethods.put(m.getNumberedSubSignature(),m);\n  methodList.add(m);\n  m.setDeclared(true);\n  m.setDeclaringClass(this);\n}\n", "docstring": "adds the given method to this class .", "partition": "test"}
{"idx": "3770", "code": "public boolean isBuiltinSoundAvailable(String soundIdentifier){\n  return builtinSounds.containsKey(soundIdentifier);\n}\n", "docstring": "indicates whether a user installed or system sound is available", "partition": "test"}
{"idx": "4071", "code": "protected JsOutput newJsOutput(Module m) throws IOException {\n  return new JsOutput(m,isCompilingLanguageModule());\n}\n", "docstring": "this exists solely so that the web ide can override it and use a different jsoutput", "partition": "test"}
{"idx": "1876", "code": "public void analyzeAllItAndWriteResults(){\n  RunResultsLoader runDir=new RunResultsLoader(runDirectory,null);\n  PrintStream stream;\n  try {\n    stream=new PrintStream(new File(outputDir + \"routesAndTTs.txt\"));\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n    return;\n  }\n  String header=\"it\\\\ttotal tt[s]\\\\t#users up\\\\t#users mid\\\\t#users low\\\\tavg tt[s] up\\\\tavg tt[s] mid\\\\tavg tt[s] low\";\n  stream.println(header);\n  double totalTTIt;\n  double[] avgRouteTTsIt;\n  int[] routeUsersIt;\n  for (int i=0; i <= lastIteration; i++) {\n    log.info(\"Starting to analyze iteration \" + i + \" of \"+ lastIteration+ \" iterations.\");\n    String eventsFilename=runDir.getEventsFilename(i);\n    EventsManager eventsManager=new EventsManagerImpl();\n    TtAnalyzeBraess handler=new TtAnalyzeBraess();\n    eventsManager.addHandler(handler);\n    MatsimEventsReader reader=new MatsimEventsReader(eventsManager);\n    reader.readFile(eventsFilename);\n    totalTTIt=handler.getTotalTT();\n    avgRouteTTsIt=handler.calculateAvgRouteTTs();\n    routeUsersIt=handler.getRouteUsers();\n    StringBuffer line=new StringBuffer();\n    line.append(i + \"\\\\t\" + totalTTIt);\n    for (int j=0; j < 3; j++) {\n      line.append(\"\\\\t\" + routeUsersIt[j]);\n    }\n    for (int j=0; j < 3; j++) {\n      line.append(\"\\\\t\" + avgRouteTTsIt[j]);\n    }\n    stream.println(line.toString());\n  }\n  stream.close();\n  log.info(lastIteration + \" Iterations analyzed.\");\n}\n", "docstring": "analyzes all iterations in terms of route choice and travel time", "partition": "test"}
{"idx": "3472", "code": "@Override public String toString(){\n  String result=\"RandomSplitResultProducer: \";\n  result+=getCompatibilityState();\n  if (m_Instances == null) {\n    result+=\": <null Instances>\";\n  }\n else {\n    result+=\": \" + Utils.backQuoteChars(m_Instances.relationName());\n  }\n  return result;\n}\n", "docstring": "gets a text descrption of the result producer .", "partition": "test"}
{"idx": "67", "code": "public void extend(RuleGrounding other){\n  if (other.isFailed()) {\n    groundings.clear();\n    return;\n  }\n  extend(other.getAlternatives());\n}\n", "docstring": "extends the existing groundings with the alternative groundings", "partition": "test"}
{"idx": "1072", "code": "protected boolean read(){\n  if (!nReuseHeader) {\n    Debug.message(\"iso8211\",\"DDFRecord reusing header, calling readHeader()\");\n    return readHeader();\n  }\n  byte[] tempData=new byte[nDataSize - nFieldOffset];\n  int nReadBytes=poModule.read(tempData,0,tempData.length);\n  System.arraycopy(pachData,nFieldOffset,tempData,0,tempData.length);\n  if (nReadBytes != (int)(nDataSize - nFieldOffset) && nReadBytes == -1) {\n    return false;\n  }\n else   if (nReadBytes != (int)(nDataSize - nFieldOffset)) {\n    Debug.error(\"DDFRecord: Data record is short on DDF file.\");\n    return false;\n  }\n  return true;\n}\n", "docstring": "read a record of data from the file , and parse the header to build a field list for the record ( or reuse the existing one if reusing headers ) . it is expected that the file pointer will be positioned at the beginning of a data record . it is the ddfmodule \"'\" s responsibility to do so . this method should only be called by the ddfmodule class .", "partition": "test"}
{"idx": "769", "code": "private Long id(HttpServletRequest request){\n  Long id=null;\n  String pathInfo=request.getPathInfo();\n  if (pathInfo != null && pathInfo.length() > 1) {\n    String idString=pathInfo.substring(1);\n    id=Long.valueOf(idString);\n  }\n  return id;\n}\n", "docstring": "extract id from the http request .", "partition": "test"}
{"idx": "1050", "code": "public ItemStack removeItems(ItemStack drive,ItemStack stack,int amountWanted){\n  if (getMaxKilobits(drive) == -1)   return null;\n  int stored=getAmountStored(drive,stack);\n  int amountGiven=Math.min(amountWanted,stored);\n  if (amountGiven > 0) {\n    setAmountStored(drive,stack,stored - amountGiven);\n    stack.stackSize+=amountGiven;\n    markDirty(drive);\n  }\n  return stack;\n}\n", "docstring": "take as many items as possible , up to the passed limit , from a drive into the given stack . < p > the stacksize of the passed stack will be affected . return value is for convenience .", "partition": "test"}
{"idx": "1304", "code": "public boolean search(V v){\n  int h=hashMethod.hash(v);\n  LinkedList<V> list=(LinkedList<V>)table[h];\n  if (list == null) {\n    return false;\n  }\n  return list.contains(v);\n}\n", "docstring": "search for the desired value in the hashtable . < p > only succeeds if v overrides the equals ( object o ) method", "partition": "test"}
{"idx": "894", "code": "public void addUndoableAction(UndoableAction action){\n  undoStack.push(action);\n  redoStack.removeAllElements();\n}\n", "docstring": "add a new undoable action .", "partition": "test"}
{"idx": "3776", "code": "protected MessageDigest(String algorithm){\n  this.algorithm=algorithm;\n}\n", "docstring": "creates a message digest with the specified algorithm name .", "partition": "test"}
{"idx": "3850", "code": "private int[] parseMetaDataInformation() throws UserError {\n  int[] selectedColumns=new int[metaData.size()];\n  Set<String> usedColumnNames=new HashSet<>();\n  int columnIndex=0;\n  int usedColumnIndex=0;\n  for (  ColumnMetaData column : metaData) {\n    if (!column.isRemoved()) {\n      selectedColumns[usedColumnIndex]=columnIndex;\n      usedColumnIndex++;\n      String columnName=column.getName();\n      if (!usedColumnNames.contains(columnName)) {\n        usedColumnNames.add(columnName);\n      }\n else {\n        throw new UserError(null,\"data_import.non_unique_column_name\",columnName);\n      }\n    }\n    columnIndex++;\n  }\n  int[] attributeColumns=Arrays.copyOf(selectedColumns,usedColumnIndex);\n  return attributeColumns;\n}\n", "docstring": "goes once through the metadata , checks which columns are removed and checks that the remaining columns have unique names .", "partition": "test"}
{"idx": "3074", "code": "public void assureProxyOk(){\n  if (socket.isClosed()) {\n    restart();\n  }\n}\n", "docstring": "assure that proxy is in a stable status .", "partition": "test"}
{"idx": "2598", "code": "public int swap(){\n  if (!egl.eglSwapBuffers(eglDisplay,eglSurface)) {\n    return egl.eglGetError();\n  }\n  return EGL10.EGL_SUCCESS;\n}\n", "docstring": "display the current render surface .", "partition": "test"}
{"idx": "618", "code": "@Override public void close(){\n  closing=true;\n  if (reservations == null || reservations.compareAndSet(0,-1))   doClose();\n}\n", "docstring": "closes tree map and reclaims memory .", "partition": "test"}
{"idx": "645", "code": "@Override public List<WorkOrder> searchWOForBilling(final Map<String,Object> criteriaMap){\n  logger.debug(\"-------------------------Inside searchWOForBilling-----------------------\");\n  final List<WorkOrder> filteredList=new ArrayList<WorkOrder>();\n  criteriaMap.put(ACTION_FLAG,\"searchWOForBilling\");\n  for (  final WorkOrder workorder : searchWO(criteriaMap))   if (!isWOValidforBill(workorder.getId()))   filteredList.add(workorder);\n  return filteredList;\n}\n", "docstring": "this method will search list of wo \"'\" s for the given criteria and eligible for mb . criteriamap will have : contractor_id , create_date , tender_no , workorder_no , project_code filter : 1 ) an existing bill with status in \" new \" or \" approval pending \" or \" rejected will not be retrieved 2 ) work orders for which the final bill is generated will not be retrieved for selection in the search result set . 2 ) work orders with existing bill with status \" approved \" with no existing bill can be retrieved for selection", "partition": "test"}
{"idx": "169", "code": "protected void execute(String[] sqls,SQLiteDatabase db){\n  String throwSQL=\"\";\n  try {\n    if (sqls != null) {\n      for (      String sql : sqls) {\n        throwSQL=sql;\n        db.execSQL(BaseUtility.changeCase(sql));\n      }\n    }\n  }\n catch (  SQLException e) {\n    throw new DatabaseGenerateException(DatabaseGenerateException.SQL_ERROR + throwSQL);\n  }\n}\n", "docstring": "use the parameter sqlitedatabase to execute the passing sqls . subclasses can add their own logic when do the executing job by overriding this method .", "partition": "test"}
{"idx": "1805", "code": "public static String relativeToAbsolute(String baseURL,String relativeURL){\n  if (relativeURL.startsWith(\"/\")) {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ relativeURL;\n  }\n else {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ getURLBasePath(baseURL)+ relativeURL;\n  }\n}\n", "docstring": "converts a relative url e . g . : / myfile . html to an absolute url", "partition": "test"}
{"idx": "4147", "code": "public void addControlRoll(PilotingRollData control){\n  controlRolls.addElement(control);\n}\n", "docstring": "adds a pending control roll to the list for this phase .", "partition": "test"}
{"idx": "4011", "code": "private boolean nextItemIs(String match) throws IOException {\n  int c;\n  while (isWhiteSpace(c=buf.get())) {\n  }\n  for (int i=0; i < match.length(); i++) {\n    if (i > 0) {\n      c=buf.get();\n    }\n    if (c != match.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "requires the next few characters ( after whitespace ) to match the argument .", "partition": "test"}
{"idx": "538", "code": "public void releaseSelections(Set<Entity> items){\n  for (  Entity item : items) {\n    releaseSelection(item);\n  }\n}\n", "docstring": "remove selection to a list of items", "partition": "test"}
{"idx": "1800", "code": "public Cell(int rowspan,int colspan){\n  this.rowspan=Math.max(rowspan,1);\n  this.colspan=Math.max(colspan,1);\n}\n", "docstring": "creates a cell which takes a custom amount of cell spaces in the table .", "partition": "test"}
{"idx": "3437", "code": "public static byte[] bitmapToBytes(Bitmap bm){\n  byte[] bytes=null;\n  if (bm != null) {\n    ByteArrayOutputStream baos=new ByteArrayOutputStream();\n    bm.compress(Bitmap.CompressFormat.PNG,100,baos);\n    bytes=baos.toByteArray();\n  }\n  return bytes;\n}\n", "docstring": "bitmap transfer to bytes", "partition": "test"}
{"idx": "47", "code": "public void addNodesInDocOrder(DTMIterator iterator,XPathContext support){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  int node;\n  while (DTM.NULL != (node=iterator.nextNode())) {\n    addNodeInDocOrder(node,support);\n  }\n}\n", "docstring": "copy nodelist members into this nodelist , adding in document order . if a node is null , don \"'\" t add it .", "partition": "test"}
{"idx": "822", "code": "public void waitForData(){\n  if (this.initialized) {\n    return;\n  }\n  waitOnInitialization(this.initializationLatchAfterGetInitialImage);\n}\n", "docstring": "wait until data is ready in this region", "partition": "test"}
{"idx": "2206", "code": "protected StoragePort checkPortExistsInDB(String nativeGuid) throws IOException {\n  StoragePort port=null;\n  List<StoragePort> portInDB=CustomQueryUtility.getActiveStoragePortByNativeGuid(_dbClient,nativeGuid);\n  if (portInDB != null && !portInDB.isEmpty()) {\n    port=portInDB.get(0);\n  }\n  return port;\n}\n", "docstring": "check if port exists in db .", "partition": "test"}
{"idx": "34", "code": "public CharSeq concat(CharSeq another){\n  return new CharSeq(str + another.str);\n}\n", "docstring": "append string of the given charseq to this charseq", "partition": "test"}
{"idx": "2709", "code": "public void testRandom(){\n  ExtremityMonitor monitor=new ExtremityMonitor();\n  Random random=new Random(42);\n  for (int i=0; i < 1000; i++) {\n    monitor.update(random.nextDouble());\n  }\n  assertTrue(monitor.getMin() < 0.1);\n  assertTrue(monitor.getMax() < 1.0);\n  assertTrue(monitor.getMin() >= 0.0);\n  assertTrue(monitor.getMax() > 0.9);\n}\n", "docstring": "throws a bunch of random numbers between [ 0 , 1 ", "partition": "test"}
{"idx": "3195", "code": "public static double igamma(double a,double x){\n  double coef=(Math.exp(-x) * Math.pow(x,a)) / gamma(a);\n  double sum=0.0;\n  for (int i=0; i < 100; i++) {\n    sum+=(gamma(a) / gamma(a + 1.0 + (double)i)) * Math.pow(x,(double)i);\n  }\n  return (coef * sum);\n}\n", "docstring": "calculates the incomplete gamma function for two doubles", "partition": "test"}
{"idx": "1859", "code": "public CipherParameters decrypt(byte[] in,int keyLen){\n  return decrypt(in,0,in.length,keyLen);\n}\n", "docstring": "decrypt an encapsulated session key .", "partition": "test"}
{"idx": "620", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (eventName.equals(\"trainingSet\") && m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection with respect to the named event", "partition": "test"}
{"idx": "367", "code": "public void removeAttribute(String name){\n  if (name != null)   if (attributesList != null) {\n    for (int i=0; i < attributesList.size(); i++) {\n      Object o=attributesList.elementAt(i);\n      if (o instanceof AttributeField) {\n        AttributeField a=(AttributeField)o;\n        try {\n          String n=a.getName();\n          if (n != null) {\n            if (name.equals(n)) {\n              attributesList.remove(a);\n            }\n          }\n        }\n catch (        SdpParseException e) {\n        }\n      }\n    }\n  }\n}\n", "docstring": "removes the attribute specified by the value parameter .", "partition": "test"}
{"idx": "1005", "code": "private PdfObject readCompressedStream(PdfObject rootObj,int pointer,final PdfFileReader currentPdfFile,final ObjectReader objectReader,final PdfObject linearObj) throws PdfException {\n  while (pointer != -1) {\n    movePointer(pointer);\n    final byte[] raw=objectReader.readObjectData(-1,null);\n    final StringBuilder objectName=new StringBuilder();\n    char current1, last=' ';\n    int matched=0, i1=0;\n    while (i1 < raw.length) {\n      current1=(char)raw[i1];\n      if (current1 == 10 || current1 == 13) {\n        current1=' ';\n      }\n      if (current1 == ' ' && last == ' ') {\n        matched=0;\n      }\n else       if (current1 == pattern.charAt(matched)) {\n        matched++;\n      }\n else {\n        matched=0;\n        objectName.append(current1);\n      }\n      if (matched == 3) {\n        break;\n      }\n      last=current1;\n      i1++;\n    }\n    objectName.append('R');\n    final PdfObject pdfObject=new CompressedObject(objectName.toString());\n    pdfObject.setCompressedStream(true);\n    final ObjectDecoder objectDecoder=new ObjectDecoder(currentPdfFile);\n    objectDecoder.readDictionaryAsObject(pdfObject,0,raw);\n    final int[] fieldSizes=pdfObject.getIntArray(PdfDictionary.W);\n    byte[] xrefs=pdfObject.getDecodedStream();\n    if (xrefs == null) {\n      xrefs=currentPdfFile.readStream(pdfObject,true,true,false,false,true,null);\n    }\n    final int[] Index=pdfObject.getIntArray(PdfDictionary.Index);\n    if (Index == null) {\n      CompressedObjects.readCompressedOffsets(0,0,pdfObject.getInt(PdfDictionary.Size),fieldSizes,xrefs,offset,pdf_datafile);\n    }\n else {\n      final int count=Index.length;\n      int pntr=0;\n      for (int aa=0; aa < count; aa+=2) {\n        pntr=CompressedObjects.readCompressedOffsets(pntr,Index[aa],Index[aa + 1],fieldSizes,xrefs,offset,pdf_datafile);\n      }\n    }\n    if (rootObj == null) {\n      rootObj=pdfObject.getDictionary(PdfDictionary.Root);\n      encryptObj=pdfObject.getDictionary(PdfDictionary.Encrypt);\n      if (encryptObj != null) {\n        final byte[][] IDs=pdfObject.getStringArray(PdfDictionary.ID);\n        if (IDs != null && this.ID == null) {\n          this.ID=IDs[0];\n        }\n      }\n      infoObject=pdfObject.getDictionary(PdfDictionary.Info);\n    }\n    if (linearObj != null) {\n      pointer=-1;\n    }\n else {\n      pointer=pdfObject.getInt(PdfDictionary.Prev);\n      if (pointer != -1 && !isCompressedStream(pointer,(int)eof)) {\n        return readLegacyReferenceTable(rootObj,pointer,(int)eof,currentPdfFile);\n      }\n    }\n  }\n  return rootObj;\n}\n", "docstring": "read 1 . 5 compression stream ref table", "partition": "test"}
{"idx": "4109", "code": "@Override public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException {\n  Node xpathOwnerNode=(Node)xctxt.getOwnerObject();\n  if (xpathOwnerNode == null) {\n    return null;\n  }\n  int xpathOwnerNodeDTM=xctxt.getDTMHandleFromNode(xpathOwnerNode);\n  int currentNode=xctxt.getCurrentNode();\n  DTM dtm=xctxt.getDTM(currentNode);\n  int docContext=dtm.getDocument();\n  if (DTM.NULL == docContext) {\n    error(xctxt,XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOC,null);\n  }\n{\n    Document currentDoc=XMLUtils.getOwnerDocument(dtm.getNode(currentNode));\n    Document xpathOwnerDoc=XMLUtils.getOwnerDocument(xpathOwnerNode);\n    if (currentDoc != xpathOwnerDoc) {\n      throw new TransformerException(I18n.translate(\"xpath.funcHere.documentsDiffer\"));\n    }\n  }\n  XNodeSet nodes=new XNodeSet(xctxt.getDTMManager());\n  NodeSetDTM nodeSet=nodes.mutableNodeset();\n{\n    int hereNode=DTM.NULL;\nswitch (dtm.getNodeType(xpathOwnerNodeDTM)) {\ncase Node.ATTRIBUTE_NODE:\ncase Node.PROCESSING_INSTRUCTION_NODE:\n{\n        hereNode=xpathOwnerNodeDTM;\n        nodeSet.addNode(hereNode);\n        break;\n      }\ncase Node.TEXT_NODE:\n{\n      hereNode=dtm.getParent(xpathOwnerNodeDTM);\n      nodeSet.addNode(hereNode);\n      break;\n    }\ndefault :\n  break;\n}\n}\nnodeSet.detach();\nreturn nodes;\n}\n", "docstring": "the here function returns a node - set containing the attribute or processing instruction node or the parent element of the text node that directly bears the xpath expression . this expression results in an error if the containing xpath expression does not appear in the same xml document against which the xpath expression is being evaluated .", "partition": "test"}
{"idx": "1003", "code": "public E remove(int index){\n  hashCodeUpToDate=false;\n  modCount++;\n  E oldValue=elementData(index);\n  int numMoved=size - index - 1;\n  if (numMoved > 0)   System.arraycopy(elementData,index + 1,elementData,index,numMoved);\n  elementData[--size]=null;\n  return oldValue;\n}\n", "docstring": "removes the element at the specified position in this list . shifts any subsequent elements to the left ( subtracts one from their indices ) .", "partition": "test"}
{"idx": "939", "code": "public void globalConfigChanged(String serviceName,String version,String groupName,String serviceComponent,int changeType){\n}\n", "docstring": "this method will be invoked when a service \"'\" s global configuation data has been changed . the parameter groupname denote the name of the configuration grouping ( e . g . default ) and servicecomponent denotes the service \"'\" s sub - component that changed", "partition": "test"}
{"idx": "971", "code": "public static Vector2 min(Vector2 o1,Vector2 o2){\n  return new Vector2(Math.min(o1.x,o2.x),Math.min(o1.z,o2.z));\n}\n", "docstring": "returns a vector2 containing the smallest x and y values .", "partition": "test"}
{"idx": "1868", "code": "public static boolean isCommand(IElementType type){\n  return type == SQFTypes.COMMAND_TOKEN || type == SQFTypes.COMMAND || type == SQFTypes.CASE || type == SQFTypes.CASE_COMMAND;\n}\n", "docstring": "return true if the given type refers to a command , false otherwise", "partition": "test"}
{"idx": "2613", "code": "@Override public JapaneseDate dateYearDay(int prolepticYear,int dayOfYear){\n  return new JapaneseDate(LocalDate.ofYearDay(prolepticYear,dayOfYear));\n}\n", "docstring": "obtains a local date in japanese calendar system from the proleptic - year and day - of - year fields . < p > the day - of - year in this factory is expressed relative to the start of the proleptic year . the japanese proleptic year and day - of - year are the same as those in the iso calendar system . they are not reset when the era changes .", "partition": "test"}
{"idx": "1208", "code": "@Override public void addHeader(final String header,final String value){\n  mHeadersOptions.add(new HeaderOption(header,value));\n}\n", "docstring": "adds a header to this request .", "partition": "test"}
{"idx": "278", "code": "public void resetPSRs(){\n  pilotRolls.removeAllElements();\n}\n", "docstring": "resets the psr list .", "partition": "test"}
{"idx": "3273", "code": "public static Map<String,Object> performFindList(DispatchContext dctx,Map<String,Object> context){\n  Integer viewSize=(Integer)context.get(\"viewSize\");\n  if (viewSize == null)   viewSize=Integer.valueOf(20);\n  context.put(\"viewSize\",viewSize);\n  Integer viewIndex=(Integer)context.get(\"viewIndex\");\n  if (viewIndex == null)   viewIndex=Integer.valueOf(0);\n  context.put(\"viewIndex\",viewIndex);\n  Map<String,Object> result=performFind(dctx,context);\n  int start=viewIndex.intValue() * viewSize.intValue();\n  List<GenericValue> list=null;\n  Integer listSize=0;\n  try {\n    EntityListIterator it=(EntityListIterator)result.get(\"listIt\");\n    list=it.getPartialList(start + 1,viewSize);\n    listSize=it.getResultsSizeAfterPartialList();\n    it.close();\n  }\n catch (  Exception e) {\n    Debug.logInfo(\"Problem getting partial list\" + e,module);\n  }\n  result.put(\"listSize\",listSize);\n  result.put(\"list\",list);\n  result.remove(\"listIt\");\n  return result;\n}\n", "docstring": "same as performfind but now returning a list instead of an iterator extra parameters viewindex : startpage of the partial list ( 0 = first page ) viewsize : the length of the page ( number of records ) extra output parameter : listsize : size of the totallist list : the list itself .", "partition": "test"}
{"idx": "116", "code": "@Override public boolean equals(Object o){\n  if (o instanceof Graph) {\n    return string.equals(o.toString());\n  }\n  return false;\n}\n", "docstring": "returns true if the object is a graph with the same content .", "partition": "test"}
{"idx": "1044", "code": "private static Intent createShareIntent(Context context,final String shareText){\n  final Intent shareIntent=new Intent(Intent.ACTION_SEND);\n  shareIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,context.getString(R.string.share_subject));\n  shareIntent.putExtra(android.content.Intent.EXTRA_TEXT,shareText);\n  shareIntent.setType(\"text/plain\");\n  return shareIntent;\n}\n", "docstring": "creates a share intent", "partition": "test"}
{"idx": "300", "code": "X509IssuerSerial(X509Certificate cert){\n  this(cert.getIssuerX500Principal(),cert.getSerialNumber());\n}\n", "docstring": "construct an x509issuerserial from an x509certificate .", "partition": "test"}
{"idx": "4114", "code": "private ByteString escapeBytes(final ByteString value){\n  if (!needEscaping(value)) {\n    return value;\n  }\n  final ByteStringBuilder builder=new ByteStringBuilder();\n  for (int i=0; i < value.length(); i++) {\n    final byte b=value.byteAt(i);\n    if (isByteToEscape(b)) {\n      builder.appendByte(DN.NORMALIZED_ESC_BYTE);\n    }\n    builder.appendByte(b);\n  }\n  return builder.toByteString();\n}\n", "docstring": "return a new byte string with bytes 0x00 , 0x01 and 0x02 escaped . < p > these bytes are reserved to represent respectively the rdn separator , the ava separator and the escape byte in a normalized byte string .", "partition": "test"}
{"idx": "4084", "code": "public static PublicKeySelector fromString(String type){\n  if (type != null) {\n    for (    PublicKeySelector keySelector : PublicKeySelector.values()) {\n      if (type.equalsIgnoreCase(keySelector.type)) {\n        return keySelector;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "translates a string into a token endpoint auth method type .", "partition": "test"}
{"idx": "2316", "code": "public static String valueOf(Boolean value){\n  return value != null ? String.valueOf(value) : null;\n}\n", "docstring": "returns the string value of the given boolean . returns null if argument is null .", "partition": "test"}
{"idx": "2470", "code": "public boolean is(String arg,boolean allowAbbr){\n  if (name.equalsIgnoreCase(arg)) {\n    return true;\n  }\n  if (allowAbbr && arg.length() == 1) {\n    if (arg.charAt(0) == c) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the atg string matches the name of the arg , or , if allowabbr is true , returns true if the arg length is one and it matches the first letter of the arg name .", "partition": "test"}
{"idx": "3323", "code": "private void paintBackgroundSolid(Graphics2D g,JComponent c,int x,int y,int width,int height){\n  Color color=c.getBackground();\n  if (type == CommonControlState.DISABLED) {\n    color=new Color(color.getRed(),color.getGreen(),color.getBlue(),0x80);\n  }\n  Shape s=shapeGenerator.createRoundRectangle(x - 2,y - 2,width + 4,height + 4,CornerSize.BORDER);\n  g.setPaint(color);\n  g.fill(s);\n  if (isPaintLineSeperators(c)) {\n    paintLineSeparator(g,c,width,height);\n  }\n}\n", "docstring": "paint the background of an uneditable control , e . g . a jlabel .", "partition": "test"}
{"idx": "561", "code": "int insert(Row row,byte[] sourceBuffer,int sourceOffset,BlobOutputStream[] blobs){\n  int rowHead=_rowHead;\n  int blobTail=_blobTail;\n  int rowLength=row.length();\n  rowHead-=rowLength;\n  if (rowHead < blobTail) {\n    return -1;\n  }\n  byte[] buffer=_buffer;\n  System.arraycopy(sourceBuffer,sourceOffset,buffer,rowHead,rowLength);\n  buffer[rowHead]=(byte)((buffer[rowHead] & ~CODE_MASK) | INSERT);\n  blobTail=row.insertBlobs(buffer,rowHead,blobTail,blobs);\n  if (blobTail < 0) {\n    return -1;\n  }\n  setBlobTail(blobTail);\n  rowHead(rowHead);\n  validateBlock(row);\n  return rowHead;\n}\n", "docstring": "inserts a new row into the block .", "partition": "test"}
{"idx": "2418", "code": "public void initialize(Map configParams){\n  String delimiterConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_DELIMITER);\n  if (delimiterConfig != null) {\n    this.delimiter=delimiterConfig;\n  }\n  String caseConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_CASE_SENSITIVE);\n  if (caseConfig != null) {\n    if (caseConfig.equals(\"true\")) {\n      this.caseSensitive=true;\n    }\n else     if (caseConfig.equals(\"false\")) {\n      this.caseSensitive=false;\n    }\n else {\n      this.caseSensitive=true;\n    }\n  }\n  String wildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_WILDCARD);\n  if (wildcardConfig != null) {\n    this.wildcard=wildcardConfig;\n  }\n  String oneLevelWildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_ONE_LEVEL_WILDCARD);\n  if (oneLevelWildcardConfig != null) {\n    this.oneLevelWildcard=oneLevelWildcardConfig;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"PrefixResourceName:initialize():\" + \" delimiter = \" + delimiter + \" wildcard = \"+ wildcard+ \" oneLevelWildcard = \"+ oneLevelWildcard+ \" case = \"+ caseConfig);\n  }\n  oneLevelWildcardLength=oneLevelWildcard.length();\n  wildcardLength=wildcard.length();\n  if (oneLevelWildcard.indexOf(wildcard) != -1) {\n    wildcardEmbedded=true;\n  }\n else {\n    wildcardEmbedded=false;\n  }\n  if (wildcard.indexOf(oneLevelWildcard) != -1) {\n    oneLevelWildcardEmbedded=true;\n  }\n else {\n    oneLevelWildcardEmbedded=false;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"wildcardEmbedded,oneLevelWildcardEmbedded\" + wildcardEmbedded + \",\"+ oneLevelWildcardEmbedded);\n  }\n  return;\n}\n", "docstring": "initializes the resource name with configuration information , usally set by the administrators . the main configration information retrived is mainly like wild card pattern used , one level wild card pattern used , case sensitivity etc .", "partition": "test"}
{"idx": "1921", "code": "@SuppressWarnings(\"rawtypes\") public static void createProjectConstraint(ZipFile zip,Project aProject,RepositoryService aRepository) throws IOException {\n  for (Enumeration zipEnumerate=zip.entries(); zipEnumerate.hasMoreElements(); ) {\n    ZipEntry entry=(ZipEntry)zipEnumerate.nextElement();\n    String entryName=normalizeEntryName(entry);\n    if (entryName.startsWith(CONSTRAINTS)) {\n      String filename=FilenameUtils.getName(entry.getName());\n      ConstraintSet constraintSet=new ConstraintSet();\n      constraintSet.setProject(aProject);\n      constraintSet.setName(filename);\n      aRepository.createConstraintSet(constraintSet);\n      aRepository.writeConstraintSet(constraintSet,zip.getInputStream(entry));\n      LOG.info(\"Imported constraint [\" + filename + \"] for project [\"+ aProject.getName()+ \"] with id [\"+ aProject.getId()+ \"]\");\n    }\n  }\n}\n", "docstring": "copy constraints from the exported project", "partition": "test"}
{"idx": "3708", "code": "@Ignore(\"Disabling due to bug #52347\") @Test public void testConcurrentEventsOnEmptyRegion(){\n  versionTestConcurrentEventsOnEmptyRegion();\n}\n", "docstring": "this tests the concurrency versioning system to ensure that event conflation happens correctly and that the statistic is being updated properly", "partition": "test"}
{"idx": "2646", "code": "public final void registerFileType(@NotNull FileType type,@NonNls @Nullable String... defaultAssociatedExtensions){\n  List<FileNameMatcher> matchers=new ArrayList<FileNameMatcher>();\n  if (defaultAssociatedExtensions != null) {\n    for (    String extension : defaultAssociatedExtensions) {\n      matchers.add(new ExtensionFileNameMatcher(extension));\n    }\n  }\n  registerFileType(type,matchers);\n}\n", "docstring": "registers a file type .", "partition": "test"}
{"idx": "884", "code": "public static EPType singleValue(Class singleValueType){\n  if (singleValueType != null && singleValueType.isArray()) {\n    return new ClassMultiValuedEPType(singleValueType,singleValueType.getComponentType());\n  }\n  return new ClassEPType(singleValueType);\n}\n", "docstring": "indicate that the expression return type is a single ( non - enumerable ) value of the given type . the expression can still return an array or collection or events however since the engine would not know the type of such objects and may not use runtime reflection it may not allow certain operations on expression results .", "partition": "test"}
{"idx": "3460", "code": "public FastStringReader(String s){\n  this.str=s;\n  this.length=s.length();\n}\n", "docstring": "creates a new string reader .", "partition": "test"}
{"idx": "2610", "code": "public static Result verify(String sid,String code){\n  String id=\"//captcha/\" + sid;\n  Code c=(Code)Cache.get(id);\n  if (c == null) {\n    log.warn(\"no code in cache, sid=\" + sid);\n    return Result.badcode;\n  }\n else   if (!X.isSame(code,c.code)) {\n    log.warn(\"is not same, code.server=\" + c.code + \", code.client=\"+ code);\n    return Result.badcode;\n  }\n else   if (c.expired < System.currentTimeMillis()) {\n    log.warn(\"expired, expired=\" + c.expired);\n    return Result.expired;\n  }\n  return Result.ok;\n}\n", "docstring": "verify the code associated", "partition": "test"}
{"idx": "3789", "code": "public synchronized int lastIndexOf(Object object,int location){\n  if (location < elementCount) {\n    if (object != null) {\n      for (int i=location; i >= 0; i--) {\n        if (object.equals(elementData[i])) {\n          return i;\n        }\n      }\n    }\n else {\n      for (int i=location; i >= 0; i--) {\n        if (elementData[i] == null) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  throw arrayIndexOutOfBoundsException(location,elementCount);\n}\n", "docstring": "searches in this vector for the index of the specified object . the search for the object starts at the specified location and moves towards the start of this vector .", "partition": "test"}
{"idx": "2328", "code": "protected void addContentSpecToElement(XMLElementDecl elementDecl){\n  if ((fDepth == 0 || (fDepth == 1 && elementDecl.type == XMLElementDecl.TYPE_MIXED)) && fNodeIndexStack != null) {\n    if (elementDecl.type == XMLElementDecl.TYPE_MIXED) {\n      int pcdata=addUniqueLeafNode(null);\n      if (fNodeIndexStack[0] == -1) {\n        fNodeIndexStack[0]=pcdata;\n      }\n else {\n        fNodeIndexStack[0]=addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_CHOICE,pcdata,fNodeIndexStack[0]);\n      }\n    }\n    setContentSpecIndex(fCurrentElementIndex,fNodeIndexStack[fDepth]);\n  }\n}\n", "docstring": "adds the content spec to the given element declaration .", "partition": "test"}
{"idx": "669", "code": "private void restoreSortingSelection(int[] selection,int lead,ModelChange change){\n  for (int i=selection.length - 1; i >= 0; i--) {\n    selection[i]=convertRowIndexToView(selection[i],change);\n  }\n  lead=convertRowIndexToView(lead,change);\n  if (selection.length == 0 || (selection.length == 1 && selection[0] == getSelectedRow())) {\n    return;\n  }\n  selectionModel.setValueIsAdjusting(true);\n  selectionModel.clearSelection();\n  for (int i=selection.length - 1; i >= 0; i--) {\n    if (selection[i] != -1) {\n      selectionModel.addSelectionInterval(selection[i],selection[i]);\n    }\n  }\n  SwingUtilities2.setLeadAnchorWithoutSelection(selectionModel,lead,lead);\n  selectionModel.setValueIsAdjusting(false);\n}\n", "docstring": "restores the selection after a model event / sort order changes . all coordinates are in terms of the model .", "partition": "test"}
{"idx": "3464", "code": "public QueryStringQueryBuilder field(String field,float boost){\n  if (fields == null) {\n    fields=new ArrayList<>();\n  }\n  fields.add(field);\n  if (fieldsBoosts == null) {\n    fieldsBoosts=new ObjectFloatHashMap<>();\n  }\n  fieldsBoosts.put(field,boost);\n  return this;\n}\n", "docstring": "adds a field to run the query string against with a specific boost .", "partition": "test"}
{"idx": "3214", "code": "public static boolean isSQL99NonReservedKeyword(String identifier){\n  if (identifier == null) {\n    throw new NullPointerException(\"The identifier cannot be null\");\n  }\n  return Arrays.binarySearch(SQL99_NON_RESERVED,identifier.toUpperCase()) >= 0;\n}\n", "docstring": "returns true if the given identifier is a sql - 99 non - reserved keyword .", "partition": "test"}
{"idx": "1148", "code": "protected Logger(String name,String resourceBundleName){\n  super(name,resourceBundleName);\n}\n", "docstring": "protected method to construct a logger for a named subsystem . < p > the logger will be initially configured with a null level and with useparenthandlers true .", "partition": "test"}
{"idx": "3120", "code": "public VdcConfig toConfigParam(Properties vdcInfo){\n  log.info(\"copy {} to the sync config param\",vdcInfo.getProperty(GeoServiceJob.VDC_SHORT_ID));\n  VdcConfig vdcConfig=new VdcConfig();\n  vdcConfig.setId(URIUtil.uri(vdcInfo.getProperty(GeoServiceJob.OPERATED_VDC_ID)));\n  vdcConfig.setShortId(vdcInfo.getProperty(GeoServiceJob.VDC_SHORT_ID));\n  vdcConfig.setSecretKey(vdcInfo.getProperty(GeoServiceJob.VDC_SECRETE_KEY));\n  String name=vdcInfo.getProperty(GeoServiceJob.VDC_NAME);\n  if ((name != null) && (!name.isEmpty())) {\n    vdcConfig.setName(name);\n  }\n  String description=vdcInfo.getProperty(GeoServiceJob.VDC_DESCRIPTION);\n  if ((description != null) && (!description.isEmpty())) {\n    vdcConfig.setDescription(description);\n  }\n  String endPnt=vdcInfo.getProperty(GeoServiceJob.VDC_API_ENDPOINT);\n  if (endPnt != null) {\n    vdcConfig.setApiEndpoint(endPnt);\n  }\n  vdcConfig.setGeoCommandEndpoint(vdcInfo.getProperty(GeoServiceJob.VDC_GEOCOMMAND_ENDPOINT));\n  vdcConfig.setGeoDataEndpoint(vdcInfo.getProperty(GeoServiceJob.VDC_GEODATA_ENDPOINT));\n  return vdcConfig;\n}\n", "docstring": "build vdcconfig for a vdc for syncvdcconfig call", "partition": "test"}
{"idx": "4048", "code": "@SuppressWarnings(\"deprecation\") private static final URL toURL(String location,boolean file){\n  if (file) {\n    File f=new File(location);\n    if (f.exists()) {\n      try {\n        return f.toURL();\n      }\n catch (      MalformedURLException murl) {\n        return null;\n      }\n    }\n else {\n      return null;\n    }\n  }\n else {\n    return getURL(location);\n  }\n}\n", "docstring": "makes a url out of a location , as either a file or a resource .", "partition": "test"}
{"idx": "1163", "code": "public AppraiseGitReviewClient(Repository repo){\n  this.repo=repo;\n  this.author=new PersonIdent(repo);\n}\n", "docstring": "creates a new client for the given git repository .", "partition": "test"}
{"idx": "3690", "code": "public int search(String txt){\n  int M=pat.length();\n  int N=txt.length();\n  int skip;\n  for (int i=0; i <= N - M; i+=skip) {\n    skip=0;\n    for (int j=M - 1; j >= 0; j--) {\n      if (pat.charAt(j) != txt.charAt(i + j)) {\n        skip=Math.max(1,j - right[txt.charAt(i + j)]);\n        break;\n      }\n    }\n    if (skip == 0)     return i;\n  }\n  return N;\n}\n", "docstring": "returns the index of the first occurrence of the pattern string in the text string .", "partition": "test"}
{"idx": "725", "code": "public void addVertex(Object id) throws IllegalArgumentException {\n  if (initialized) {\n    throw new IllegalArgumentException();\n  }\n  Vertex vertex=new Vertex(id);\n  Object existing=vertexMap.put(id,vertex);\n  if (existing != null) {\n    throw new IllegalArgumentException();\n  }\n  vertexList.add(vertex);\n}\n", "docstring": "defines a new vertex with the given id . the depth - first search is performed in the relative order in which vertexes were added to the graph .", "partition": "test"}
{"idx": "2553", "code": "public byte[] toByteArray(){\n  return Arrays.copyOf(buf,cnt);\n}\n", "docstring": "creates a newly allocated byte array . its size is the current size of this output stream and the valid contents of the buffer have been copied into it .", "partition": "test"}
{"idx": "995", "code": "private String fmtTime(double time){\n  return Utilities.pad(timeFormatter.format(time) + \"s\",10);\n}\n", "docstring": "formats times into a standard format .", "partition": "test"}
{"idx": "888", "code": "public Dictionary(Directory tempDir,String tempFileNamePrefix,InputStream affix,List<InputStream> dictionaries,boolean ignoreCase) throws IOException, ParseException {\n  this.ignoreCase=ignoreCase;\n  this.needsInputCleaning=ignoreCase;\n  this.needsOutputCleaning=false;\n  flagLookup.add(new BytesRef());\n  Path aff=Files.createTempFile(tempPath,\"affix\",\"aff\");\n  OutputStream out=new BufferedOutputStream(Files.newOutputStream(aff));\n  InputStream aff1=null;\n  InputStream aff2=null;\n  boolean success=false;\n  try {\n    final byte[] buffer=new byte[1024 * 8];\n    int len;\n    while ((len=affix.read(buffer)) > 0) {\n      out.write(buffer,0,len);\n    }\n    out.close();\n    aff1=new BufferedInputStream(Files.newInputStream(aff));\n    String encoding=getDictionaryEncoding(aff1);\n    CharsetDecoder decoder=getJavaEncoding(encoding);\n    aff2=new BufferedInputStream(Files.newInputStream(aff));\n    readAffixFile(aff2,decoder);\n    IntSequenceOutputs o=IntSequenceOutputs.getSingleton();\n    Builder<IntsRef> b=new Builder<>(FST.INPUT_TYPE.BYTE4,o);\n    readDictionaryFiles(tempDir,tempFileNamePrefix,dictionaries,decoder,b);\n    words=b.finish();\n    aliases=null;\n    morphAliases=null;\n    success=true;\n  }\n  finally {\n    IOUtils.closeWhileHandlingException(out,aff1,aff2);\n    if (success) {\n      Files.delete(aff);\n    }\n else {\n      IOUtils.deleteFilesIgnoringExceptions(aff);\n    }\n  }\n}\n", "docstring": "creates a new dictionary containing the information read from the provided inputstreams to hunspell affix and dictionary files . you have to close the provided inputstreams yourself .", "partition": "test"}
{"idx": "2288", "code": "protected final void init() throws NoGlyphException {\n  char[] codes=chars.toCharArray();\n  indices=new int[codes.length];\n  advances=new int[codes.length];\n  double maxAscent=0.0;\n  double maxDescent=0.0;\n  double scale=size * SWFConstants.TWIPS / 1024.0;\n  for (int i=0; i < codes.length; i++) {\n    int code=(int)codes[i];\n    int[] index=new int[1];\n    FontDefinition.Glyph glyph=getGlyph(code,index);\n    indices[i]=index[0];\n    if (glyph != null) {\n      Shape shape=glyph.getShape();\n      double[] outline=shape.getBoundingRectangle();\n      double x1=outline[0] * scale;\n      double y1=outline[1] * scale;\n      double x2=outline[2] * scale;\n      double y2=outline[3] * scale;\n      if (maxAscent < -y1) {\n        maxAscent=-y1;\n      }\n      if (maxDescent < y2) {\n        maxDescent=y2;\n      }\n      double advance=glyph.getAdvance() * scale;\n      if (advance == 0) {\n        advance=x2 - x1;\n      }\n      if (i < codes.length - 1) {\n        advance+=(fontDef.getKerningOffset(code,(int)codes[i + 1]) * scale);\n      }\n      totalAdvance+=advance;\n      advances[i]=(int)(advance * SWFConstants.TWIPS);\n      if (i == 0) {\n        leftMargin=-y1;\n      }\n      if (i == codes.length - 1) {\n        rightMargin=x2 - advance;\n      }\n    }\n  }\n  ascent=fontDef.getAscent() * scale;\n  if (ascent == 0.0) {\n    ascent=maxAscent;\n  }\n  descent=fontDef.getDescent() * scale;\n  if (descent == 0.0) {\n    descent=maxDescent;\n  }\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "909", "code": "protected void populateStreamBlob(int testId,byte[] baseContent,int requiredSize) throws SQLException {\n  final byte[] testBytes=generateBlobContent(baseContent,requiredSize);\n  try (FbDatabase db=createDatabaseConnection()){\n    listener=new SimpleStatementListener();\n    transaction=getTransaction(db);\n    try {\n      statement=db.createStatement(transaction);\n      statement.addStatementListener(listener);\n      final BlobParameterBuffer blobParameterBuffer=db.createBlobParameterBuffer();\n      blobParameterBuffer.addArgument(BlobParameterBuffer.TYPE,BlobParameterBuffer.TYPE_STREAM);\n      final FbBlob blob=db.createBlobForOutput(transaction,blobParameterBuffer);\n      blob.open();\n      int bytesWritten=0;\n      while (bytesWritten < testBytes.length) {\n        byte[] buffer=new byte[Math.min(blob.getMaximumSegmentSize(),testBytes.length - bytesWritten)];\n        System.arraycopy(testBytes,bytesWritten,buffer,0,buffer.length);\n        blob.putSegment(buffer);\n        bytesWritten+=buffer.length;\n      }\n      blob.close();\n      statement.prepare(INSERT_BLOB_TABLE);\n      final DatatypeCoder datatypeCoder=db.getDatatypeCoder();\n      FieldValue param1=new FieldValue(datatypeCoder.encodeInt(testId));\n      FieldValue param2=new FieldValue(datatypeCoder.encodeLong(blob.getBlobId()));\n      statement.execute(RowValue.of(param1,param2));\n      statement.close();\n    }\n  finally {\n      transaction.commit();\n    }\n  }\n }\n", "docstring": "populates a stream blob for testing .", "partition": "test"}
{"idx": "1327", "code": "private boolean usedAllRule17Directors(Set<String> allocatedDirectors,PortAllocationContext context){\n  Set<String> rule17Directors=getRule17Directors(context);\n  for (  String director : allocatedDirectors) {\n    rule17Directors.remove(director);\n  }\n  return rule17Directors.isEmpty();\n}\n", "docstring": "returns true if already used all the rule17 directors .", "partition": "test"}
{"idx": "3091", "code": "public boolean hasBeenCalled(String resourceName){\n  return uris.contains(resourceName);\n}\n", "docstring": "checks if a resource has been requested using the short name of the resource .", "partition": "test"}
{"idx": "610", "code": "public static String classNamePath(String className){\n  String filename=className.replace(\".\",File.separator);\n  filename=filename.replaceFirst(\"[$][0-9]+\",\"\");\n  if (filename.indexOf(\"$\") > 0) {\n    filename=filename.substring(0,filename.indexOf(\"$\"));\n  }\n  return \"src\" + File.separator + filename+ \".java\";\n}\n", "docstring": "returns the relative path for a fully qualified classname . adds \" src / \" before the pathname for the class . strips away internal class names .", "partition": "test"}
{"idx": "1133", "code": "public CCrossReferencesPanel(){\n  super(new BorderLayout());\n  m_table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  add(new JScrollPane(m_table));\n  m_table.addMouseListener(new InternalMouseListener());\n}\n", "docstring": "creates a new panel object .", "partition": "test"}
{"idx": "2925", "code": "public Session(){\n  long uptime=System.currentTimeMillis();\n  mMainHandler=new Handler(Looper.getMainLooper());\n  mTimestamp=(uptime / 1000) << 32 & (((uptime - ((uptime / 1000) * 1000)) >> 32) / 1000);\n  mOrigin=\"127.0.0.1\";\n  try {\n    sSignal.await();\n  }\n catch (  InterruptedException e) {\n  }\n}\n", "docstring": "creates a streaming session that can be customized by adding tracks .", "partition": "test"}
{"idx": "3954", "code": "private MarshalledWrapper lookupDo(Template tmpl){\n  if (isEmpty(tmpl.serviceTypes) || tmpl.serviceID != null) {\n    ItemIter iter=matchingItems(tmpl);\n    if (iter.hasNext())     return iter.next().service;\n    return null;\n  }\n  List services=matchingServices(tmpl.serviceTypes);\n  long now=System.currentTimeMillis();\n  int slen=services.size();\n  if (slen == 0)   return null;\n  int srand=Math.abs(random.nextInt() % slen);\n  for (int i=0; i < slen; i++) {\n    SvcReg reg=(SvcReg)services.get((i + srand) % slen);\n    if (reg.leaseExpiration > now && matchAttributes(tmpl,reg.item))     return reg.item.service;\n  }\n  return null;\n}\n", "docstring": "the code that does the real work of lookup . as a special case , if the template specifies at least one service type to match , and there are multiple items that match the template , then we make a random pick among them , in an attempt to load balance use of \" equivalent \" services and avoid starving any of them .", "partition": "test"}
{"idx": "1123", "code": "private void parseSwitch(int indent,boolean firstContent,String header,Layout layout,List<Elem> elems){\n  TokenStream tokens=new TokenStream(header);\n  Elem selector=parseExpr(tokens);\n  tokens.checkAtEnd();\n  ImmutableList.Builder<Case> cases=ImmutableList.builder();\n  List<Elem> defaultElems=null;\n  boolean done;\n  String line=getNextLine();\n  Matcher matcher=COMMAND_LINE.matcher(line);\n  String command;\n  String rest;\n  if (matcher.find()) {\n    command=matcher.group(COMMAND_NAME_GROUP);\n    rest=line.substring(matcher.end());\n    done=false;\n  }\n else {\n    error(\"expected \\'@end\\', \\'@case\\' or \\'@default\\' command after \\'switch\\'\");\n    done=true;\n    command=null;\n    rest=null;\n  }\n  while (!done) {\nswitch (command) {\ncase END_COMMAND:\n      checkHeaderEmpty(command,rest);\n    done=true;\n  break;\ncase DEFAULT_COMMAND:\ncheckHeaderEmpty(command,rest);\nif (defaultElems != null) {\nerror(\"duplicate \\'@default\\' in @switch\");\n}\ndefaultElems=parseUntil(indent,layout,END_COMMAND);\ncommand=lastTerminator;\nrest=lastTerminatorHeader;\ndone=lastTerminator == null;\nbreak;\ncase CASE_COMMAND:\ntokens=new TokenStream(rest);\nElem value=parseExpr(tokens);\ntokens.checkAtEnd();\nList<Elem> caseElems=parseUntil(indent,layout,END_COMMAND,CASE_COMMAND,DEFAULT_COMMAND);\nif (value != null) {\ncases.add(Case.create(value,caseElems));\n}\ncommand=lastTerminator;\nrest=lastTerminatorHeader;\ndone=lastTerminator == null;\nbreak;\ndefault :\nunexpectedCommandError(command);\ndone=true;\nbreak;\n}\n}\nif (selector != null) {\nelems.add(Block.create(!firstContent,Switch.create(input.location(),selector,cases.build(),defaultElems)));\n}\n}\n", "docstring": "parse a switch command .", "partition": "test"}
{"idx": "1853", "code": "private static String indent(final int height){\n  return CoreBaseBOp.indent(height);\n}\n", "docstring": "returns a string that may be used to indent a dump of the nodes in the tree .", "partition": "test"}
{"idx": "3156", "code": "protected int indexOf(String buffer,int start,int end,char ch){\n  for (int i=start; i < end; i++) {\n    if (buffer.charAt(i) == ch) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "docstring": "computes index of given char within stringbuffer", "partition": "test"}
{"idx": "816", "code": "private static void checkPathNeed(){\n  if (samplingInterval == -1) {\n    lastPreloadTime=readMorePaths();\n  }\n  if (!Double.isNaN(lastPreloadTime) && SimClock.getTime() >= lastPreloadTime - (samplingInterval * MIN_AHEAD_INTERVALS)) {\n    for (int i=0; i < nrofPreload && !Double.isNaN(lastPreloadTime); i++) {\n      lastPreloadTime=readMorePaths();\n    }\n  }\n}\n", "docstring": "checks if more paths should be preloaded and preloads them if needed .", "partition": "test"}
{"idx": "1630", "code": "@Override public void actionPerformed(ActionEvent event){\n  String command=event.getActionCommand();\n  if (command.equals(\"SelectLabelFont\")) {\n    attemptLabelFontSelection();\n  }\n else   if (command.equals(\"SelectLabelPaint\")) {\n    attemptModifyLabelPaint();\n  }\n else   if (command.equals(\"SelectTickLabelFont\")) {\n    attemptTickLabelFontSelection();\n  }\n}\n", "docstring": "handles user interaction with the property panel .", "partition": "test"}
{"idx": "4062", "code": "@SuppressWarnings(\"unused\") public static float valueRangeLimit(float value,float startValue,float endValue){\n  if (value < Math.min(startValue,endValue))   return Math.min(startValue,endValue);\n  if (value > Math.max(startValue,endValue))   return Math.max(startValue,endValue);\n  return value;\n}\n", "docstring": "limit number within a values range . this method not consider the sign and the upper and lower values limit order .", "partition": "test"}
{"idx": "944", "code": "public void addFooterView(View v,Object data,boolean isSelectable){\n  FixedViewInfo info=new FixedViewInfo();\n  info.view=v;\n  info.data=data;\n  info.isSelectable=isSelectable;\n  mFooterViewInfos.add(info);\n  if (mAdapter != null && mDataSetObserver != null) {\n    mDataSetObserver.onChanged();\n  }\n}\n", "docstring": "add a fixed view to appear at the bottom of the list . if addfooterview is called more than once , the views will appear in the order they were added . views added using this call can take focus if they want . < p > note : call this before calling setadapter . this is so listview can wrap the supplied cursor with one that will also account for header and footer views .", "partition": "test"}
{"idx": "3160", "code": "@Override public void sendLocationList(){\n  List<Location> locationList=lm.getLocationsByNameList();\n  ArrayList<Attribute> location;\n  for (  Location loc : locationList) {\n    location=new ArrayList<Attribute>(1);\n    location.add(new Attribute(LOCATIONS,loc));\n    try {\n      sendMessage(location);\n    }\n catch (    IOException ioe) {\n      log.debug(\"could not send train \" + loc.getName());\n    }\n  }\n}\n", "docstring": "send a list of locations known by operations to the client", "partition": "test"}
{"idx": "4189", "code": "private static int lookupQualSelector(XMPNode arrayNode,String qualName,String qualValue,int aliasForm) throws XMPException {\n  if (XML_LANG.equals(qualName)) {\n    qualValue=Utils.normalizeLangValue(qualValue);\n    int index=XMPNodeUtils.lookupLanguageItem(arrayNode,qualValue);\n    if (index < 0 && (aliasForm & AliasOptions.PROP_ARRAY_ALT_TEXT) > 0) {\n      XMPNode langNode=new XMPNode(ARRAY_ITEM_NAME,null);\n      XMPNode xdefault=new XMPNode(XML_LANG,X_DEFAULT,null);\n      langNode.addQualifier(xdefault);\n      arrayNode.addChild(1,langNode);\n      return 1;\n    }\n else {\n      return index;\n    }\n  }\n else {\n    for (int index=1; index < arrayNode.getChildrenLength(); index++) {\n      XMPNode currItem=arrayNode.getChild(index);\n      for (Iterator it=currItem.iterateQualifier(); it.hasNext(); ) {\n        XMPNode qualifier=(XMPNode)it.next();\n        if (qualName.equals(qualifier.getName()) && qualValue.equals(qualifier.getValue())) {\n          return index;\n        }\n      }\n    }\n    return -1;\n  }\n}\n", "docstring": "searches for a qualifier selector in a node : [ ? qualname = \" value \" ", "partition": "test"}
{"idx": "3177", "code": "public static void copy(File src,File dst) throws IOException {\n  if (src.isDirectory()) {\n    ensureDirectoryExists(dst);\n    String[] filesList=src.list();\n    for (    String file : filesList) {\n      File srcFile=new File(src,file);\n      File destFile=new File(dst,file);\n      copy(srcFile,destFile);\n    }\n  }\n else {\n    copyFile(src,dst);\n  }\n}\n", "docstring": "copy file object from one place to another . can be used to copy file to file , or folder to folder .", "partition": "test"}
{"idx": "22", "code": "public void run(){\n  while (m_keyboardStream != null) {\n    try {\n      if (m_keyboardReadRequest) {\n        String s=m_keyboardStream.readLine();\n        m_keyboardInput.add(s);\n        m_keyboardReadRequest=false;\nsynchronized (this) {\n          notifyAll();\n        }\n      }\n else       try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException ie) {\n      }\n    }\n catch (    IOException io) {\n    }\n  }\n}\n", "docstring": "a seperate thread collects our input so that we can block in the docontinue on the main thread and then allow the user to interrupt us via keyboard input on this thread . < p / > we built the stupid thing in this manner , since readline ( ) will block no matter what and if we \"'\" quit \"'\" we can \"'\" t seem to kill this thread . . close ( ) doesn \"'\" t work and thread . stop ( ) , etc . all fail to do the job . < p / > thus we needed to take a request response approach so that we only block when requested to do so .", "partition": "test"}
{"idx": "3647", "code": "public static X509Certificate createCertificateFromBytes(byte[] certBytes){\n  X509Certificate cert=null;\n  CertificateFactory certFactory;\n  try {\n    certFactory=CertificateFactory.getInstance(\"X.509\");\n    InputStream in=new ByteArrayInputStream(certBytes);\n    cert=(X509Certificate)certFactory.generateCertificate(in);\n  }\n catch (  CertificateException e) {\n    logger.warn(\"Excpetion caught in CryptCore.\" + \"createCertificateFromBytes, returning null\",e);\n  }\n  return cert;\n}\n", "docstring": "creates an x509 certificate for a given byte array", "partition": "test"}
{"idx": "3755", "code": "public void putStringNoNull(String s){\n  ensureCapacity(s.length() * 2);\n  System.arraycopy(s.getBytes(),0,this.byteBuffer,this.position,s.length());\n  this.position+=s.length();\n}\n", "docstring": "put a string in the buffer . no null terminated .", "partition": "test"}
{"idx": "594", "code": "public QueryStringDecoderUtil(URI uri){\n  this(uri,Charset.defaultCharset());\n}\n", "docstring": "creates a new decoder that decodes the specified uri . the decoder will assume that the query string is encoded in utf - 8 .", "partition": "test"}
{"idx": "418", "code": "protected static int toDigit(final char ch,final int index) throws HexDecodeException {\n  final int digit=Character.digit(ch,16);\n  if (digit == -1) {\n    throw new HexDecodeException(\"Illegal hexadecimal character \" + ch + \" at index \"+ index);\n  }\n  return digit;\n}\n", "docstring": "converts a hexadecimal character to an integer .", "partition": "test"}
{"idx": "846", "code": "private void encodeTypes(List<Type> types,Map<String,Object> m,String key,Declaration from){\n  if (types == null || types.isEmpty())   return;\n  List<Map<String,Object>> sats=new ArrayList<>(types.size());\n  for (  Type st : types) {\n    sats.add(typeMap(st,from));\n  }\n  m.put(key,sats);\n}\n", "docstring": "encodes the list of types and puts them under the specified key in the map .", "partition": "test"}
{"idx": "1530", "code": "public HttpMethodInfo(Method method,Object handler,Object[] args,MultivaluedMap<String,Object> formParameters,Response responder){\n  this.method=method;\n  this.handler=handler;\n  this.args=Arrays.copyOf(args,args.length);\n  this.formParameters=formParameters;\n  this.responder=responder;\n}\n", "docstring": "construct httpmethodinfo object for a handler method that does not support streaming .", "partition": "test"}
{"idx": "1254", "code": "private String convertTimestamp(){\n  String result=timestampFormat.replaceAll(VALID_DATEFORMAT_CHAR_PATTERN + \"+\",\"\\\\\\\\\\\\\\\\S+\");\n  result=result.replaceAll(Pattern.quote(\".\"),\"\\\\\\\\\\\\\\\\.\");\n  return result;\n}\n", "docstring": "helper method that will convert timestamp format to a pattern", "partition": "test"}
{"idx": "1501", "code": "public void stop(){\n  _throttle.setSpeedSetting(-0.5F);\n  _throttle.setSpeedSetting(0.0F);\n  stopLabel.setIcon(stopIcon);\n  stopLabel.setIconTextGap(_gap);\n  pack();\n}\n", "docstring": "perform an emergency stop", "partition": "test"}
{"idx": "3348", "code": "@SuppressWarnings(\"all\") final void reject(Runnable command){\n  handler.rejectedExecution(command,this);\n}\n", "docstring": "invokes the rejected execution handler for the given command . package - protected for use by scheduledthreadpoolexecutor .", "partition": "test"}
{"idx": "3656", "code": "public static int inflate(byte[] previous,int previousLength,byte[] current,int currentLength,byte[] result){\n  if (previous == null) {\n    System.arraycopy(current,0,result,0,currentLength);\n    return currentLength;\n  }\n  int length=0;\n  int start1=0;\n  int start2=0;\n  while (start1 < previousLength && start2 < currentLength) {\n    int end1=start1;\n    while (end1 < previousLength && previous[end1] != '\\\\t') {\n      end1++;\n    }\n    int end2=start2;\n    while (end2 < currentLength && current[end2] != '\\\\t') {\n      end2++;\n    }\n    if (current[start2] == '&' && end2 == start2 + 1) {\n      for (int i=start1; i < end1; i++)       result[length++]=previous[i];\n    }\n else {\n      for (int i=start2; i < end2; i++)       result[length++]=current[i];\n    }\n    if (end2 < currentLength)     result[length++]='\\\\t';\n    start1=end1 + 1;\n    start2=end2 + 1;\n  }\n  return length;\n}\n", "docstring": "inflate the current sam line by replacing all & by the corresponding field in the previous sam line", "partition": "test"}
{"idx": "2403", "code": "public void addOutboundRule(final OutboundRule outboundRule){\n  outboundRule.setId(outboundRuleIdCounter++);\n  outboundRules.add(outboundRule);\n}\n", "docstring": "will add the rule to the rules list .", "partition": "test"}
{"idx": "1710", "code": "public IntBuffer majorVersionBuffer(){\n  int[] holder=new int[1];\n  holder[0]=getMajorVersion();\n  IntBuffer ib=IntBuffer.wrap(holder);\n  ib.limit(1);\n  return ib;\n}\n", "docstring": "return an intbuffer that accesses the major version number . this is used to create a monitor object for this value .", "partition": "test"}
{"idx": "911", "code": "public void addNearKey(KeyCacheObject key,GridCacheSharedContext ctx) throws IgniteCheckedException {\n  nearKeys.add(key);\n}\n", "docstring": "adds a near key .", "partition": "test"}
{"idx": "2686", "code": "@Override public CategoricalResults clone(){\n  CategoricalResults copy=new CategoricalResults(n);\n  copy.probabilities=Arrays.copyOf(probabilities,probabilities.length);\n  return copy;\n}\n", "docstring": "creates a deep clone of this", "partition": "test"}
{"idx": "2057", "code": "private boolean isInThumbRange(float touchX,double normalizedThumbValue){\n  return Math.abs(touchX - normalizedToScreen(normalizedThumbValue)) <= mThumbHalfWidth;\n}\n", "docstring": "decides if given x - coordinate in screen space needs to be interpreted as \" within \" the normalized thumb x - coordinate .", "partition": "test"}
{"idx": "2857", "code": "public void addLeaf(CatalogTreeLeaf leaf){\n  _leaves.add(leaf);\n}\n", "docstring": "append leaf to the end of the leaves list", "partition": "test"}
{"idx": "1092", "code": "public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  if (!(c instanceof JPopupMenu)) {\n    return;\n  }\n  Font origFont=g.getFont();\n  Color origColor=g.getColor();\n  JPopupMenu popup=(JPopupMenu)c;\n  String title=popup.getLabel();\n  if (title == null) {\n    return;\n  }\n  g.setFont(font);\n  FontMetrics fm=SwingUtilities2.getFontMetrics(popup,g,font);\n  int fontHeight=fm.getHeight();\n  int descent=fm.getDescent();\n  int ascent=fm.getAscent();\n  Point textLoc=new Point();\n  int stringWidth=SwingUtilities2.stringWidth(popup,fm,title);\n  textLoc.y=y + ascent + TEXT_SPACING;\n  textLoc.x=x + ((width - stringWidth) / 2);\n  g.setColor(background);\n  g.fillRect(textLoc.x - TEXT_SPACING,textLoc.y - (fontHeight - descent),stringWidth + (2 * TEXT_SPACING),fontHeight - descent);\n  g.setColor(foreground);\n  SwingUtilities2.drawString(popup,g,title,textLoc.x,textLoc.y);\n  MotifGraphicsUtils.drawGroove(g,x,textLoc.y + TEXT_SPACING,width,GROOVE_HEIGHT,shadowColor,highlightColor);\n  g.setFont(origFont);\n  g.setColor(origColor);\n}\n", "docstring": "paints the border for the specified component with the specified position and size .", "partition": "test"}
{"idx": "2556", "code": "public synchronized void disableAttribute(String name){\n  enabledAttributes.removeElement(name);\n}\n", "docstring": "disables all the attribute change notifications the attribute name of which equals the specified attribute name to be sent to the listener . < br > if the specified name is not in the list of enabled attribute names , this method has no effect .", "partition": "test"}
{"idx": "2844", "code": "public DialogueRecorder(DialogueSystem system){\n  this.settings=system.getSettings();\n}\n", "docstring": "creates a new dialogue recorder for the dialogue system", "partition": "test"}
{"idx": "2661", "code": "private static void checkPermission() throws SecurityException {\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n  }\n}\n", "docstring": "checks whether the provider may be changed using permission \"'\" currenttime . setprovider \"'\" .", "partition": "test"}
{"idx": "3077", "code": "private static RoadPermission roadFlagComparision(Way iosmWay,String newTag,String newValue,EnumSet<EdgeStore.EdgeFlag> forwardExpected,EnumSet<EdgeStore.EdgeFlag> backwardExpected){\n  Way osmWay=new Way();\n  StringJoiner stringJoiner=new StringJoiner(\";\");\n  for (  OSMEntity.Tag tag : iosmWay.tags) {\n    osmWay.addTag(tag.key,tag.value);\n    stringJoiner.add(tag.key + \"=\" + tag.value);\n  }\n  if (newTag != null && newValue != null) {\n    osmWay.addTag(newTag,newValue);\n    stringJoiner.add(newTag + \"=\" + newValue);\n  }\n  Set<EdgeStore.EdgeFlag> forwardFiltered;\n  Set<EdgeStore.EdgeFlag> backwardFiltered;\n  RoadPermission roadPermission=traversalPermissionLabeler.getPermissions(osmWay);\n  forwardFiltered=filterFlags(roadPermission.forward);\n  backwardFiltered=filterFlags(roadPermission.backward);\n  String tags=\"Tags: \" + stringJoiner.toString();\n  assertEquals(tags,forwardExpected,forwardFiltered);\n  assertEquals(tags,backwardExpected,backwardFiltered);\n  return roadPermission;\n}\n", "docstring": "makes comparision of way with osmway tags and newtag with newvalue and compares forward and backward permissions with expected permissions copy of osmway is made since otherwise tags would be changed", "partition": "test"}
{"idx": "490", "code": "public boolean expired(){\n  return System.currentTimeMillis() - time > DFLT_EXPIRATION_TIMEOUT;\n}\n", "docstring": "checks if cassandra driver session expired .", "partition": "test"}
{"idx": "1139", "code": "boolean removeDisplay(Display display){\n  return m_displays.remove(display);\n}\n", "docstring": "remove a display from this visualization .", "partition": "test"}
{"idx": "2121", "code": "private Map<String,String> produceStream(String topic){\n  List<ProducerRecord<String,String>> messages=new ArrayList<>(EVENT_CNT);\n  Map<String,String> keyValMap=new HashMap<>();\n  for (int evt=0; evt < EVENT_CNT; evt++) {\n    long runtime=System.currentTimeMillis();\n    String key=topic + \"_\" + String.valueOf(evt);\n    String msg=runtime + String.valueOf(evt);\n    messages.add(new ProducerRecord<>(topic,key,msg));\n    keyValMap.put(key,msg);\n  }\n  kafkaBroker.sendMessages(messages);\n  return keyValMap;\n}\n", "docstring": "sends messages to kafka .", "partition": "test"}
{"idx": "2439", "code": "public boolean isConfigured(){\n  LOG.debug(\"lookup url: \" + url);\n  return url != null && !url.isEmpty();\n}\n", "docstring": "method to quickly indicate if the service is not configured .", "partition": "test"}
{"idx": "2503", "code": "public void onLoginFailure(Map requestParamsMap,HttpServletRequest req,HttpServletResponse res) throws AuthenticationException {\n  debug.message(\"ReplayPasswd.onLoginFailure: called\");\n}\n", "docstring": "post processing on failed authentication .", "partition": "test"}
{"idx": "3058", "code": "private void quickReply(){\n  quickReplySmsMessage=smsPopupPager.getActiveMessage();\n  quickReply(quickReplySmsMessage.getReplyText());\n}\n", "docstring": "show the quick reply dialog , resetting the text in the edittext and storing the current smsmmsmessage ( in case another message comes in )", "partition": "test"}
{"idx": "646", "code": "public Week(Date time,TimeZone zone,Locale locale){\n  ParamChecks.nullNotPermitted(time,\"time\");\n  ParamChecks.nullNotPermitted(zone,\"zone\");\n  ParamChecks.nullNotPermitted(locale,\"locale\");\n  Calendar calendar=Calendar.getInstance(zone,locale);\n  calendar.setTime(time);\n  int tempWeek=calendar.get(Calendar.WEEK_OF_YEAR);\n  if (tempWeek == 1 && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {\n    this.week=1;\n    this.year=(short)(calendar.get(Calendar.YEAR) + 1);\n  }\n else {\n    this.week=(byte)Math.min(tempWeek,LAST_WEEK_IN_YEAR);\n    int yyyy=calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.MONTH) == Calendar.JANUARY && this.week >= 52) {\n      yyyy--;\n    }\n    this.year=(short)yyyy;\n  }\n  peg(calendar);\n}\n", "docstring": "creates a time period for the week in which the specified date / time falls , calculated relative to the specified time zone .", "partition": "test"}
{"idx": "3818", "code": "protected abstract void writeSignatureBlock(byte[] signature,OutputStream out) throws IOException ;\n", "docstring": "write a . rsa file with a digital signature .", "partition": "test"}
{"idx": "1335", "code": "public void testCompareToEqualNeg(){\n  byte aBytes[]={12,56,100,-2,-76,89,45,91,3,-15,35,26,3,91};\n  byte bBytes[]={12,56,100,-2,-76,89,45,91,3,-15,35,26,3,91};\n  int aSign=-1;\n  int bSign=-1;\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  assertEquals(0,aNumber.compareTo(bNumber));\n}\n", "docstring": "compareto ( biginteger a ) . compare two equal negative numbers .", "partition": "test"}
{"idx": "1887", "code": "private Socket openDataConnection(String cmd) throws sun.net.ftp.FtpProtocolException, IOException {\n  Socket clientSocket;\n  if (passiveMode) {\n    try {\n      return openPassiveDataConnection(cmd);\n    }\n catch (    sun.net.ftp.FtpProtocolException e) {\n      String errmsg=e.getMessage();\n      if (!errmsg.startsWith(\"PASV\") && !errmsg.startsWith(\"EPSV\")) {\n        throw e;\n      }\n    }\n  }\n  ServerSocket portSocket;\n  InetAddress myAddress;\n  String portCmd;\n  if (proxy != null && proxy.type() == Proxy.Type.SOCKS) {\n    throw new sun.net.ftp.FtpProtocolException(\"Passive mode failed\");\n  }\n  portSocket=new ServerSocket(0,1,server.getLocalAddress());\n  try {\n    myAddress=portSocket.getInetAddress();\n    if (myAddress.isAnyLocalAddress()) {\n      myAddress=server.getLocalAddress();\n    }\n    portCmd=\"EPRT |\" + ((myAddress instanceof Inet6Address) ? \"2\" : \"1\") + \"|\"+ myAddress.getHostAddress()+ \"|\"+ portSocket.getLocalPort()+ \"|\";\n    if (!issueCommand(portCmd) || !issueCommand(cmd)) {\n      portCmd=\"PORT \";\n      byte[] addr=myAddress.getAddress();\n      for (int i=0; i < addr.length; i++) {\n        portCmd=portCmd + (addr[i] & 0xFF) + \",\";\n      }\n      portCmd=portCmd + ((portSocket.getLocalPort() >>> 8) & 0xff) + \",\"+ (portSocket.getLocalPort() & 0xff);\n      issueCommandCheck(portCmd);\n      issueCommandCheck(cmd);\n    }\n    if (connectTimeout >= 0) {\n      portSocket.setSoTimeout(connectTimeout);\n    }\n else {\n      if (defaultConnectTimeout > 0) {\n        portSocket.setSoTimeout(defaultConnectTimeout);\n      }\n    }\n    clientSocket=portSocket.accept();\n    if (readTimeout >= 0) {\n      clientSocket.setSoTimeout(readTimeout);\n    }\n else {\n      if (defaultSoTimeout > 0) {\n        clientSocket.setSoTimeout(defaultSoTimeout);\n      }\n    }\n  }\n  finally {\n    portSocket.close();\n  }\n  if (useCrypto) {\n    try {\n      clientSocket=sslFact.createSocket(clientSocket,serverAddr.getHostName(),serverAddr.getPort(),true);\n    }\n catch (    Exception ex) {\n      throw new IOException(ex.getLocalizedMessage());\n    }\n  }\n  return clientSocket;\n}\n", "docstring": "opens a data connection with the server according to the set mode ( active or passive ) then send the command passed as an argument .", "partition": "test"}
{"idx": "2061", "code": "public void dump(Writer writer){\n  PrintWriter pw=new PrintWriter(new BufferedWriter(writer));\n  pw.println(\"#========== Wave ==========\");\n  pw.println(\"#Type: NULL\");\n  pw.println(\"#Sample_Rate: \" + (int)audioFormat.getSampleRate());\n  pw.println(\"#Num_of_Samples: \" + samples.length / 2);\n  pw.println(\"#Num_of_Channels: \" + audioFormat.getChannels());\n  if (samples != null) {\n    for (int i=0; i < samples.length; i+=2) {\n      pw.println(WaveUtils.bytesToShort(samples[i],samples[i + 1]));\n    }\n  }\n  pw.flush();\n}\n", "docstring": "dumps the wave out to the given stream", "partition": "test"}
{"idx": "3526", "code": "public static JPanel createCheckbox(String boxlabel,String[] buttons,boolean[] checked,ActionListener al){\n  JPanel jp=createPaletteJPanel(boxlabel);\n  for (int j=0; j < buttons.length; j++) {\n    JCheckBox jcb=new JCheckBox(buttons[j]);\n    jcb.setActionCommand(Integer.toString(j));\n    if (al != null)     jcb.addActionListener(al);\n    jcb.setSelected(checked[j]);\n    jp.add(jcb);\n  }\n  return jp;\n}\n", "docstring": "create a panel containing a checkbox .", "partition": "test"}
{"idx": "2168", "code": "public double evaluate(VectorInstance x,VectorInstance y) throws Exception {\n  VectorInstance diff=x.subtract(y);\n  double result=-m_gamma * diff.dotProduct(diff);\n  return Math.exp(result);\n}\n", "docstring": "compute the result of the kernel evaluation on the supplied vectors", "partition": "test"}
{"idx": "1756", "code": "private void addProtocolIfNotExists(Set<String> protocols,String protocolType){\n  if (!protocols.contains(protocolType)) {\n    protocols.add(protocolType);\n  }\n}\n", "docstring": "verify whether protocoltype already exists or not . if it doesn \"'\" t exist then add .", "partition": "test"}
{"idx": "3016", "code": "public String description(){\n  StringBuilder sb=new StringBuilder();\n  if (isCombo()) {\n    int i=0;\n    for (    NewComboLeg leg : m_comboLegs) {\n      if (i++ > 0) {\n        sb.append(\"/\");\n      }\n      sb.append(leg.toString());\n    }\n  }\n else {\n    sb.append(m_symbol);\n    app(sb,m_secType);\n    app(sb,m_exchange);\n    if (m_exchange != null && m_exchange.equals(\"SMART\") && m_primaryExch != null) {\n      app(sb,m_primaryExch);\n    }\n    app(sb,m_expiry);\n    if (m_strike != 0) {\n      app(sb,m_strike);\n    }\n    if (m_right != Right.None) {\n      app(sb,m_right);\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "returns a text description that can be used for display .", "partition": "test"}
{"idx": "3973", "code": "protected void incorporateSignedProperties() throws DSSException {\n  signedPropertiesDom=DSSXMLUtils.addElement(documentDom,qualifyingPropertiesDom,XAdES,XADES_SIGNED_PROPERTIES);\n  signedPropertiesDom.setAttribute(ID,\"xades-\" + deterministicId);\n  incorporateSignedSignatureProperties();\n}\n", "docstring": "creates the signedproperties dom object element .", "partition": "test"}
{"idx": "1505", "code": "public static long lowerHexToUnsignedLong(String lowerHex){\n  int length=lowerHex.length();\n  if (length < 1 || length > 32)   throw isntLowerHexLong(lowerHex);\n  int i=length > 16 ? length - 16 : 0;\n  long result=0;\n  for (; i < length; i++) {\n    char c=lowerHex.charAt(i);\n    result<<=4;\n    if (c >= '0' && c <= '9') {\n      result|=c - '0';\n    }\n else     if (c >= 'a' && c <= 'f') {\n      result|=c - 'a' + 10;\n    }\n else {\n      throw isntLowerHexLong(lowerHex);\n    }\n  }\n  return result;\n}\n", "docstring": "parses a 1 to 32 character lower - hex string with no prefix into an unsigned long , tossing any bits higher than 64 .", "partition": "test"}
{"idx": "1007", "code": "public boolean isKnownSub(String subName){\n  return KNOWN_SUBS.contains(subName);\n}\n", "docstring": "checks if sub is indexed .", "partition": "test"}
{"idx": "2029", "code": "private boolean traverse(Tree tree,NodeRef node,int[] operatorNumber,boolean flip){\n  boolean update=false;\n  int nodeNum=node.getNumber();\n  NodeRef parent=tree.getParent(node);\n  if (operatorNumber != null) {\n    operatorNumber[0]=-1;\n  }\n  if (parent != null && updateNode[nodeNum]) {\n    final double branchRate=branchRateModel.getBranchRate(tree,node);\n    final double branchTime=branchRate * (tree.getNodeHeight(parent) - tree.getNodeHeight(node));\n    if (branchTime < 0.0) {\n      throw new RuntimeException(\"Negative branch length: \" + branchTime);\n    }\n    if (flip) {\n      matrixBufferHelper.flipOffset(nodeNum);\n    }\n    final int eigenIndex=0;\n    final int updateCount=branchUpdateCount[eigenIndex];\n    matrixUpdateIndices[eigenIndex][updateCount]=matrixBufferHelper.getOffsetIndex(nodeNum);\n    branchLengths[eigenIndex][updateCount]=branchTime;\n    branchUpdateCount[eigenIndex]++;\n    update=true;\n  }\n  if (!tree.isExternal(node)) {\n    NodeRef child1=tree.getChild(node,0);\n    final int[] op1={-1};\n    final boolean update1=traverse(tree,child1,op1,flip);\n    NodeRef child2=tree.getChild(node,1);\n    final int[] op2={-1};\n    final boolean update2=traverse(tree,child2,op2,flip);\n    if (update1 || update2) {\n      int x=operationCount[operationListCount] * Beagle.OPERATION_TUPLE_SIZE;\n      if (flip) {\n        partialBufferHelper.flipOffset(nodeNum);\n      }\n      final int[] operations=this.operations[operationListCount];\n      operations[x]=partialBufferHelper.getOffsetIndex(nodeNum);\n      if (useScaleFactors) {\n        int n=nodeNum - tipCount;\n        if (recomputeScaleFactors) {\n          scaleBufferHelper.flipOffset(n);\n          scaleBufferIndices[n]=scaleBufferHelper.getOffsetIndex(n);\n          operations[x + 1]=scaleBufferIndices[n];\n          operations[x + 2]=Beagle.NONE;\n        }\n else {\n          operations[x + 1]=Beagle.NONE;\n          operations[x + 2]=scaleBufferIndices[n];\n        }\n      }\n else {\n        if (useAutoScaling) {\n          scaleBufferIndices[nodeNum - tipCount]=partialBufferHelper.getOffsetIndex(nodeNum);\n        }\n        operations[x + 1]=Beagle.NONE;\n        operations[x + 2]=Beagle.NONE;\n      }\n      operations[x + 3]=partialBufferHelper.getOffsetIndex(child1.getNumber());\n      operations[x + 4]=matrixBufferHelper.getOffsetIndex(child1.getNumber());\n      operations[x + 5]=partialBufferHelper.getOffsetIndex(child2.getNumber());\n      operations[x + 6]=matrixBufferHelper.getOffsetIndex(child2.getNumber());\n      operationCount[operationListCount]++;\n      update=true;\n    }\n  }\n  return update;\n}\n", "docstring": "traverse the tree calculating partial likelihoods .", "partition": "test"}
{"idx": "2605", "code": "public FileInputReader(File f) throws IOException {\n  if (Debug.debugging(\"binaryfile\")) {\n    Debug.output(\"FileInputReader created from \" + f.getAbsolutePath());\n  }\n  name=f.getName();\n  absolutePath=f.getAbsolutePath();\n  inputFile=init(f);\n}\n", "docstring": "constructs a new binaryfile with the specified file as the input . the default byte - order is lsb first . reads start at the first byte of the file .", "partition": "test"}
{"idx": "3665", "code": "@Override public URI toEdgeURI(final Object key){\n  return toURI(key.toString());\n}\n", "docstring": "override to allow for colons in the id without urlencoding them .", "partition": "test"}
{"idx": "62", "code": "protected boolean cellConsumesEventType(Cell<?> cell,String eventType){\n  Set<String> consumedEvents=cell.getConsumedEvents();\n  return consumedEvents != null && consumedEvents.contains(eventType);\n}\n", "docstring": "check if a cell consumes the specified event type .", "partition": "test"}
{"idx": "1300", "code": "public void invalidateTitleSortable(){\n  for (  Movie movie : new ArrayList<>(movieList)) {\n    movie.clearTitleSortable();\n  }\n}\n", "docstring": "invalidate the title sortable upon changes to the sortable prefixes", "partition": "test"}
{"idx": "37", "code": "private void formatAndLogThrowable(LoggingLevel level,Color color,String msg,Throwable t){\n  if (!USE_COLORS) {\n    formatAndLogThrowable(level,msg,t);\n    return;\n  }\n  if (PhotonLogger.level.id < level.id) {\n    return;\n  }\n  LocalDateTime dateTime=LocalDateTime.now();\n  String formatted=formatLogLine(level,dateTime,msg);\n  LoggingService.logThrowable(dateTime,t,formatted,color);\n}\n", "docstring": "formats and logs a message with a throwable .", "partition": "test"}
{"idx": "565", "code": "public String patchFixIds(){\n  return properties.getProperty(\"patch.fix.ids\");\n}\n", "docstring": "returns the set of bug ids for fixes included in this build of the directory server .", "partition": "test"}
{"idx": "2697", "code": "public String canonicalize(String simpleURL){\n  String resultURL=simpleURL;\n  if (simpleURL.startsWith(\"ftp.\")) {\n    resultURL=\"ftp://\" + simpleURL;\n  }\n else   if (simpleURL.startsWith(\"gopher.\")) {\n    resultURL=\"gopher://\" + simpleURL;\n  }\n else   if (simpleURL.startsWith(\"/\")) {\n    resultURL=\"file:\" + simpleURL;\n  }\n else   if (!hasProtocolName(simpleURL)) {\n    if (isSimpleHostName(simpleURL)) {\n      simpleURL=\"www.\" + simpleURL + \".com\";\n    }\n    resultURL=\"http://\" + simpleURL;\n  }\n  return resultURL;\n}\n", "docstring": "given a possibly abbreviated url ( missing a protocol name , typically ) , this method \"'\" s job is to transform that url into a canonical form , by including a protocol name and additional syntax , if necessary . for a correctly formed url , this method should just return its argument .", "partition": "test"}
{"idx": "2894", "code": "public Builder addSourceFolder(@NonNull File folder){\n  foldersToScan.add(folder);\n  return this;\n}\n", "docstring": "root folder for labels - > documents . each subfolder name will be presented as label , and contents of this folder will be represented as labelleddocument , with label attached", "partition": "test"}
{"idx": "129", "code": "protected void ensurePathExists(String path){\n  String[] paths=path.split(\"/\");\n  StringBuffer spath=new StringBuffer(\"/\");\n  for (  String temp : paths) {\n    if (StringUtils.isBlank(temp)) {\n      continue;\n    }\n    spath.append(temp);\n    ensureExists(spath.toString(),null,acl,CreateMode.PERSISTENT);\n    spath.append(\"/\");\n  }\n}\n", "docstring": "ensures that the given path exists with no data , the current acl and no flags", "partition": "test"}
{"idx": "2324", "code": "private void paintCheckIconEnabledAndSelected(Graphics2D g,int width,int height){\n  Shape s=shapeGenerator.createCheckMark(0,0,width,height);\n  g.setPaint(iconEnabledSelected);\n  g.fill(s);\n}\n", "docstring": "paint the check mark in enabled state .", "partition": "test"}
{"idx": "2281", "code": "protected boolean customShouldTakeFocus(){\n  if (customArea instanceof Label) {\n    return false;\n  }\n  if (customArea instanceof CLabel) {\n    return (customArea.getStyle() & SWT.NO_FOCUS) > 0;\n  }\n  return true;\n}\n", "docstring": "return whether or not we should apply the workaround where we take focus for the default button or if that should be determined by the dialog . by default only return true if the custom area is a label or clabel that cannot take focus .", "partition": "test"}
{"idx": "2039", "code": "public void drawLinesAndPoints(Graphics2D g2d,ArrayList<ComparableLabel> orderedDateSet,HashMap<ComparableLabel,Integer> dataPoints,long yMaxMark){\n  int sectionWidth=this.graphWidth / orderedDateSet.size();\n  int xOffset=sectionWidth / 2;\n  int yPrevValue;\n  int yCurrentValue;\n  float prevOffsetPerc;\n  float currentOffsetPerc;\n  g2d.setColor(this.lineColor);\n  for (int i=0; i < orderedDateSet.size(); i++) {\n    if (i != 0) {\n      yPrevValue=dataPoints.get(orderedDateSet.get(i - 1));\n      yCurrentValue=dataPoints.get(orderedDateSet.get(i));\n      prevOffsetPerc=yPrevValue / (float)yMaxMark;\n      currentOffsetPerc=yCurrentValue / (float)yMaxMark;\n      g2d.drawLine(this.graphLeft + (i - 1) * sectionWidth + xOffset,this.graphBottom - Math.round(prevOffsetPerc * this.graphHeight),this.graphLeft + i * sectionWidth + xOffset,Math.round(this.graphBottom - currentOffsetPerc * this.graphHeight));\n    }\n else {\n      yCurrentValue=dataPoints.get(orderedDateSet.get(i));\n      currentOffsetPerc=yCurrentValue / (float)yMaxMark;\n      g2d.fillOval(this.graphLeft + (i) * sectionWidth + xOffset - this.pointRadius,this.graphBottom - Math.round(currentOffsetPerc * this.graphHeight) - this.pointRadius,this.pointRadius * 2,this.pointRadius * 2);\n    }\n  }\n}\n", "docstring": "draws the datapoints and the lines connecting the datapoints on the line graph", "partition": "test"}
{"idx": "1385", "code": "public static void openFileIntent(Context context,File openFile){\n  if (context != null && openFile.exists()) {\n    try {\n      Intent intent=getFileIntent(context,openFile);\n      context.startActivity(intent);\n    }\n catch (    Exception e) {\n      GlobalUtils.logThis(TAG,\"openFileIntent Exception\",e);\n    }\n  }\n}\n", "docstring": "open file using intent", "partition": "test"}
{"idx": "3253", "code": "public boolean load(File fi) throws JmriConfigureXmlException {\n  return load(fi,false);\n}\n", "docstring": "load a file . < p > handles problems locally to the extent that it can , by routing them to the creationerrorencountered method .", "partition": "test"}
{"idx": "1066", "code": "public Dependencies resolveFromFile(File file,String className,SootClass sc){\n  DexlibWrapper wrapper=cache.get(file);\n  if (wrapper == null) {\n    wrapper=new DexlibWrapper(file);\n    cache.put(file,wrapper);\n    wrapper.initialize();\n  }\n  Dependencies deps=wrapper.makeSootClass(sc,className);\n  addSourceFileTag(sc,\"dalvik_source_\" + file.getName());\n  return deps;\n}\n", "docstring": "resolve the class contained in file into the passed soot class .", "partition": "test"}
{"idx": "1227", "code": "@Override public int execute(final FormObject form,final int type,final String code,final int eventType,final char keyPressed){\n  int messageCode=ActionHandler.NOMESSAGE;\n  if (code instanceof String) {\n    final String js=code;\n    final String[] args=JSFunction.convertToArray(js);\n    final String command=args[0];\n    if (command.startsWith(\"AF\")) {\n      messageCode=handleAFCommands(form,command,js,args,eventType,keyPressed);\n    }\n  }\n  return messageCode;\n}\n", "docstring": "execute javascript and reset forms values", "partition": "test"}
{"idx": "3071", "code": "public int findLine(int offset){\n  int line=lineStarts.length - 1;\n  while ((lineStarts[line] > offset) && (line > 0)) {\n    line--;\n  }\n  return line;\n}\n", "docstring": "line in the original source file for the given offset .", "partition": "test"}
{"idx": "1407", "code": "public void initBlockViews(){\n  if (mWorkspaceView != null) {\n    List<Block> rootBlocks=mWorkspace.getRootBlocks();\n    ConnectionManager connManager=mWorkspace.getConnectionManager();\n    for (int i=0; i < rootBlocks.size(); i++) {\n      BlockGroup bg=mViewFactory.buildBlockGroupTree(rootBlocks.get(i),connManager,mTouchHandler);\n      mWorkspaceView.addView(bg);\n    }\n  }\n}\n", "docstring": "recursively initialize views for all the blocks in the model and add them to the view .", "partition": "test"}
{"idx": "582", "code": "public SignatureFakingOracle(final String documentString) throws SignatureFakingException {\n  Security.addProvider(new BouncyCastleProvider());\n  signatureValueElements=new LinkedList<Node>();\n  keyInfoElements=new LinkedList<Node>();\n  certificates=new LinkedList<String>();\n  certHandlers=new LinkedList<CertificateHandler>();\n  try {\n    doc=DomUtilities.stringToDom(documentString);\n    crawlSignatureElements();\n    log.debug(\"found \" + signatureValueElements.size() + \" SignatureValue elements\");\n    crawlKeyInfoElements();\n    log.debug(\"found \" + keyInfoElements.size() + \" KeyInfo elements containing X509 certificates\");\n  }\n catch (  SAXException e) {\n    throw new SignatureFakingException(e);\n  }\n}\n", "docstring": "creates signaturewrappingoracle , parses the document and searches for all the signaturevalue and keyinfo elements", "partition": "test"}
{"idx": "1533", "code": "public boolean required(){\n  return _parameterMetadata.contains(Metadata.REQUIRED);\n}\n", "docstring": "indicates whether the parameter is required . if the required parameter is not set , then the extension is not negotiated during the handshake .", "partition": "test"}
{"idx": "2094", "code": "default FieldDeclaration addPrivateField(Class<?> typeClass,String name){\n  return addField(typeClass,name,Modifier.PRIVATE);\n}\n", "docstring": "add a private field to this", "partition": "test"}
{"idx": "4151", "code": "private void addSpan(CacheSpan span){\n  TreeSet<CacheSpan> spansForKey=cachedSpans.get(span.key);\n  if (spansForKey == null) {\n    spansForKey=new TreeSet<CacheSpan>();\n    cachedSpans.put(span.key,spansForKey);\n  }\n  spansForKey.add(span);\n  totalSpace+=span.length;\n  notifySpanAdded(span);\n}\n", "docstring": "adds a cached span to the in - memory representation .", "partition": "test"}
{"idx": "2065", "code": "private void validateVNXFileSMISProviderMandatoryDetails(StorageSystemRequestParam param){\n  ArgValidator.checkFieldValidIP(param.getSmisProviderIP(),\"smis_provider_ip\");\n  ArgValidator.checkFieldNotNull(param.getSmisPortNumber(),\"smis_port_number\");\n  ArgValidator.checkFieldRange(param.getSmisPortNumber(),1,65535,\"smis_port_number\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisUserName(),\"smis_user_name\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisPassword(),\"smis_password\");\n}\n", "docstring": "validates smi - s provider attributes of the vnxfile as it is a mandatory fields for indications", "partition": "test"}
{"idx": "2295", "code": "public boolean containsPoly(SootMethod method){\n  return getMethod(method) != null;\n}\n", "docstring": "search for polymorphic containment based on inheritance of receiver and arguments .", "partition": "test"}
{"idx": "2058", "code": "public static void cleanupAllFiles(FileSystem fileSystem,String BaseUri) throws IOException {\n  try {\n    if (fileSystem != null) {\n      Path rootDir=new Path(BaseUri);\n      FileStatus[] files=fileSystem.listStatus(rootDir);\n      for (      FileStatus file : files) {\n        fileSystem.delete(file.getPath(),false);\n      }\n    }\n  }\n catch (  Exception e) {\n    LOG.error(\"Error in deleting all files.\");\n  }\n}\n", "docstring": "deletes all files in a container", "partition": "test"}
{"idx": "2199", "code": "public static int normalize(char[] src,int srcStart,int srcLimit,char[] dest,int destStart,int destLimit,Mode mode,int options){\n  int length=mode.normalize(src,srcStart,srcLimit,dest,destStart,destLimit,options);\n  if (length <= (destLimit - destStart)) {\n    return length;\n  }\n else {\n    throw new IndexOutOfBoundsException(Integer.toString(length));\n  }\n}\n", "docstring": "normalize a string . the string will be normalized according the the specified normalization mode and options .", "partition": "test"}
{"idx": "3855", "code": "@SuppressWarnings(\"unchecked\") public static <T extends DimensionalItemObject>List<T> asTypedList(Collection<DimensionalItemObject> collection){\n  List<T> list=new ArrayList<>();\n  if (collection != null) {\n    for (    DimensionalItemObject object : collection) {\n      list.add((T)object);\n    }\n  }\n  return list;\n}\n", "docstring": "returns a list typed with the desired erasure based on the given collection . this operation implies an unchecked cast and it is the responsibility of the caller to make sure the cast is valid . a copy of the given list will be returned .", "partition": "test"}
{"idx": "3531", "code": "private void initializeWorkList(){\n  for (  GVCongruenceClass c : B) {\n    if (c.size() == 1) {\n      continue;\n    }\n    Iterator<ValueGraphVertex> i=c.iterator();\n    ValueGraphVertex first=i.next();\n    while (i.hasNext()) {\n      ValueGraphVertex v=i.next();\n      if (!checkCongruence(first,v)) {\n        workList.push(c);\n        break;\n      }\n    }\n  }\n}\n", "docstring": "initialize the work list . a congruence class gets put on the work list if any two nodes in the class point to corresponding targets in separate partitions .", "partition": "test"}
{"idx": "1550", "code": "@Override public void applyInline(double[] data,int pos,int len){\n  int i;\n  double[] dataOut=new double[len];\n  if (len > real.length) {\n    throw new IllegalArgumentException(\"Length must not be larger than FFT size\");\n  }\n  int middle=len / 2 + len % 2;\n  System.arraycopy(data,0,dataOut,0,len);\n  System.arraycopy(dataOut,pos + middle,real,0,len - middle);\n  System.arraycopy(dataOut,pos,real,real.length - middle,middle);\n  if (real.length > len)   Arrays.fill(real,len - middle,real.length - middle,0);\n  Arrays.fill(imag,0,imag.length,0.);\n  FFT.transform(real,imag,false);\n  process(real,imag);\n  FFT.transform(real,imag,true);\n  System.arraycopy(real,0,dataOut,pos + middle,len - middle);\n  System.arraycopy(real,real.length - middle,dataOut,pos,middle);\n  double origAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  for (i=0; i < len; i++)   data[i]=amount * dataOut[i] + oneMinusAmount * data[i];\n  double newAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  double scale=origAvgEnergy / newAvgEnergy;\n  for (i=0; i < len; i++)   data[i]*=0.8 * scale;\n}\n", "docstring": "apply this frequency domain processor to the given data , and return the processing result in - place .", "partition": "test"}
{"idx": "140", "code": "public float realAbsolute(){\n  return Math.abs(mLeft);\n}\n", "docstring": "absolute value of real component", "partition": "test"}
{"idx": "715", "code": "private final StringBuilder appendParameterSignature(StringBuilder buffer,char[][] parameterTypes,char[][] parameterNames){\n  if (parameterTypes != null) {\n    for (int i=0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        buffer.append(',');\n        buffer.append(' ');\n      }\n      buffer.append(parameterTypes[i]);\n      if (parameterNames != null && parameterNames[i] != null) {\n        buffer.append(' ');\n        buffer.append(parameterNames[i]);\n      }\n    }\n  }\n  return buffer;\n}\n", "docstring": "creates a display string of a parameter list ( without the parentheses ) for the given parameter types and names .", "partition": "test"}
{"idx": "1305", "code": "@Override public void messageItemDetails(String strClass,String item,String description,String[] msgOption,int[] msgNumber,int defaultOption){\n  HashMap<Integer,String> options=new HashMap<>(msgOption.length);\n  for (int i=0; i < msgOption.length; i++) {\n    options.put(msgNumber[i],msgOption[i]);\n  }\n  messageItemDetails(strClass,description,item,options,defaultOption);\n}\n", "docstring": "add descriptive details about a specific message box , so that if it needs to be reset in the preferences , then it is easily identifiable . displayed to the user in the preferences gui .", "partition": "test"}
{"idx": "2557", "code": "public void push(final Handle handle){\n  mv.visitLdcInsn(handle);\n}\n", "docstring": "generates the instruction to push a handle on the stack .", "partition": "test"}
{"idx": "3947", "code": "void testString(){\n  String a=randomString();\n  if (returnNew) {\n    String b=StringUtils.fromCacheOrNew(a);\n    try {\n      assertEquals(a,b);\n    }\n catch (    Exception e) {\n      TestBase.logError(\"error\",e);\n    }\n    if (a != null && a == b && a.length() > 0) {\n      throw new AssertionError(\"a=\" + System.identityHashCode(a) + \" b=\"+ System.identityHashCode(b));\n    }\n  }\n else {\n    String b;\n    if (useIntern) {\n      b=a == null ? null : a.intern();\n    }\n else {\n      b=StringUtils.cache(a);\n    }\n    try {\n      assertEquals(a,b);\n    }\n catch (    Exception e) {\n      TestBase.logError(\"error\",e);\n    }\n  }\n}\n", "docstring": "test one string operation using the string cache .", "partition": "test"}
{"idx": "2872", "code": "public static boolean hasVisibleChildren(ActionGroup group,PresentationFactory factory,ActionManager actionManager,PerspectiveManager perspectiveManager){\n  ActionEvent event=new ActionEvent(factory.getPresentation(group),actionManager,perspectiveManager);\n  for (  Action anAction : group.getChildren(event)) {\n    if (anAction == null) {\n      Log.error(Utils.class,\"Null action found in group \" + group + \", \"+ factory.getPresentation(group));\n      continue;\n    }\n    if (anAction instanceof Separator) {\n      continue;\n    }\n    final Presentation presentation=factory.getPresentation(anAction);\n    anAction.update(new ActionEvent(presentation,actionManager,perspectiveManager));\n    if (anAction instanceof ActionGroup) {\n      ActionGroup childGroup=(ActionGroup)anAction;\n      if (childGroup.isPopup()) {\n        if (!presentation.isVisible()) {\n          continue;\n        }\n      }\n      if (hasVisibleChildren(childGroup,factory,actionManager,perspectiveManager)) {\n        return true;\n      }\n    }\n else     if (presentation.isVisible()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if action group has visible children .", "partition": "test"}
{"idx": "2752", "code": "private int[] mod(int[] a,int[] f){\n  int df=computeDegree(f);\n  if (df == -1) {\n    throw new ArithmeticException(\"Division by zero\");\n  }\n  int[] result=new int[a.length];\n  int hc=headCoefficient(f);\n  hc=field.inverse(hc);\n  System.arraycopy(a,0,result,0,result.length);\n  while (df <= computeDegree(result)) {\n    int[] q;\n    int coeff=field.mult(headCoefficient(result),hc);\n    q=multWithMonomial(f,computeDegree(result) - df);\n    q=multWithElement(q,coeff);\n    result=add(q,result);\n  }\n  return result;\n}\n", "docstring": "reduce a polynomial modulo another polynomial .", "partition": "test"}
{"idx": "2333", "code": "public float distanceToOtherCircle(Circle circle){\n  return (float)Math.abs(Math.sqrt(Math.pow(circle.center.x - center.x,2) + Math.pow(circle.center.y - center.y,2)));\n}\n", "docstring": "distance between circle center", "partition": "test"}
{"idx": "1282", "code": "public String constructTSDBMetricName(){\n  StringBuilder sb=new StringBuilder(getScope());\n  if (_namespace != null && !_namespace.isEmpty()) {\n    sb.append(getNamespace());\n  }\n  return sb.toString();\n}\n", "docstring": "constructs a native tsdb metric name for this metric .", "partition": "test"}
{"idx": "2190", "code": "public EconomyConcurrentHashMap(Map<? extends K,? extends V> m,IHashEntryHandler<K,V> handler){\n  this(Math.max((int)(m.size() / DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY),DEFAULT_LOAD_FACTOR,DEFAULT_CONCURRENCY_LEVEL,handler);\n  putAll(m);\n}\n", "docstring": "creates a new map with the same mappings as the given map . the map is created with a capacity of 1 . 5 times the number of mappings in the given map or 16 ( whichever is greater ) , and a default load factor ( 0 . 75 ) and concurrencylevel ( 16 ) .", "partition": "test"}
{"idx": "2566", "code": "public void testLMDirichlet() throws IOException {\n  float p=(FREQ + 2000.0f * (TOTAL_TERM_FREQ + 1) / (NUMBER_OF_FIELD_TOKENS + 1.0f)) / (DOC_LEN + 2000.0f);\n  float a=2000.0f / (DOC_LEN + 2000.0f);\n  float gold=(float)(Math.log(p / (a * (TOTAL_TERM_FREQ + 1) / (NUMBER_OF_FIELD_TOKENS + 1.0f))) + Math.log(a));\n  correctnessTestCore(new LMDirichletSimilarity(),gold);\n}\n", "docstring": "correctness test for the dirichlet lm model .", "partition": "test"}
{"idx": "1041", "code": "public static String decodeASCII(final byte[] key,final int off,final int len){\n  final byte[] b=new byte[len];\n  System.arraycopy(key,off,b,0,len);\n  for (int i=0; i < len; i++) {\n    b[i]=decodeByte(b[i]);\n  }\n  try {\n    return new String(b,\"US-ASCII\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "decodes an ascii string from a key .", "partition": "test"}
{"idx": "3358", "code": "public static Date stringToDate(String s,DateFormat formatter){\n  try {\n    return formatter.parse(s);\n  }\n catch (  ParseException e) {\n    return null;\n  }\n}\n", "docstring": "convert a date time string ( e . g . , \" 2011 - 06 - 07 19 : 12 : 18 \" ) to a date object .", "partition": "test"}
{"idx": "345", "code": "public void move(MouseEvent e){\n  Point2D pnt=getProjectionPoint(e);\n  int x=(int)pnt.getX();\n  int y=(int)pnt.getY();\n  if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n    gpm=new OffsetGrabPoint(x,y);\n    gpm.clear();\n  }\n else {\n    gpm=gpo;\n    gpm.clear();\n    gpm.set(x,y);\n  }\n  addPolyGrabPointsToOGP(gpm);\n  movingPoint=gpm;\n}\n", "docstring": "called to set the offsetgrabpoint to the current mouse location , and update the offsetgrabpoint with all the other grabpoint locations , so everything can shift smoothly . should also set the offsetgrabpoint to the movingpoint . should be called only once at the beginning of the general movement , in order to set the movingpoint . after that , redraw ( e ) should just be called , and the movingpoint will make the adjustments to the graphic that are needed .", "partition": "test"}
{"idx": "4142", "code": "public long copy(String filename,OutputStream out,long offset,long size) throws IOException, InterruptedException {\n  if (size < 0) {\n    return 0;\n  }\n  BufferedInputStream is=new BufferedInputStream(getFileInputStream(filename));\n  byte[] buf=new byte[64 * 1024];\n  int bytesRead;\n  long pos=0;\n  long remaining=size;\n  try {\n    if (offset != 0) {\n      is.skip(offset);\n      pos+=offset;\n    }\n    while (remaining != 0) {\n      int max=buf.length;\n      if (max > remaining) {\n        max=(int)remaining;\n      }\n      bytesRead=is.read(buf,0,max);\n      if (bytesRead == -1) {\n        break;\n      }\n      out.write(buf,0,bytesRead);\n      pos+=bytesRead;\n      remaining-=bytesRead;\n    }\n    out.flush();\n  }\n catch (  Exception e) {\n    out.flush();\n  }\n finally {\n    try {\n      is.close();\n    }\n catch (    Exception e) {\n    }\n  }\n  return pos;\n}\n", "docstring": "copies the given file to the output stream continously , i . e . not stop when end of file is reached , but rather wait for additional data to be appended to the file .", "partition": "test"}
{"idx": "28", "code": "@Override public void paint(Graphics g){\n  g.drawImage(image,0,0,this);\n  if (!paintCalled) {\n    paintCalled=true;\nsynchronized (this) {\n      notifyAll();\n    }\n  }\n}\n", "docstring": "paints the image on the window .", "partition": "test"}
{"idx": "3327", "code": "public Options resourceDirs(List<File> value){\n  resourceDirs.clear();\n  resourceDirs.addAll(value);\n  return this;\n}\n", "docstring": "sets the list of directories where the resources come from . this is to properly pack the paths .", "partition": "test"}
{"idx": "330", "code": "public static ReferenceBinding[] substitute(Substitution substitution,ReferenceBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    TypeBinding substitutedType=substitute(substitution,originalType);\n    if (!(substitutedType instanceof ReferenceBinding)) {\n      return null;\n    }\n    if (substitutedType != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new ReferenceBinding[length],0,i);\n      }\n      substitutedTypes[i]=(ReferenceBinding)substitutedType;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}\n", "docstring": "returns an array of types , where original types got substituted given a substitution . only allocate an array if anything is different .", "partition": "test"}
{"idx": "557", "code": "private void addGumball(float xPos,float yPos){\n  Gumball gumball=new Gumball();\n  gumball.mXInitPos=xPos;\n  gumball.mYInitPos=yPos;\n  gumball.mSoundPoolId=UUID.randomUUID();\n  mSoundPoolId.put(gumball.mSoundPoolId,false);\n  mGameView.addGumball(gumball);\n  mSoundPool.play(mSoundBallDrop,1,1,0,0,1);\n}\n", "docstring": "add a gumball to the game and play the ball drop sound .", "partition": "test"}
{"idx": "295", "code": "public double unsafeSabrVolatility(final double strike,final double forward,final double expiryTime,final double alpha,final double beta,final double nu,final double rho){\n  final double oneMinusBeta=1.0 - beta;\n  final double A=Math.pow(forward * strike,oneMinusBeta);\n  final double sqrtA=Math.sqrt(A);\n  double logM;\n  if (!isClose(forward,strike))   logM=Math.log(forward / strike);\n else {\n    final double epsilon=(forward - strike) / strike;\n    logM=epsilon - .5 * epsilon * epsilon;\n  }\n  final double z=(nu / alpha) * sqrtA * logM;\n  final double B=1.0 - 2.0 * rho * z + z * z;\n  final double C=oneMinusBeta * oneMinusBeta * logM* logM;\n  final double tmp=(Math.sqrt(B) + z - rho) / (1.0 - rho);\n  final double xx=Math.log(tmp);\n  final double D=sqrtA * (1.0 + C / 24.0 + C * C / 1920.0);\n  final double d=1.0 + expiryTime * (oneMinusBeta * oneMinusBeta * alpha* alpha / (24.0 * A) + 0.25 * rho * beta* nu* alpha / sqrtA + (2.0 - 3.0 * rho * rho) * (nu * nu / 24.0));\n  double multiplier;\n  final double m=10;\n  if (Math.abs(z * z) > Constants.QL_EPSILON * m)   multiplier=z / xx;\n else {\n    final double talpha=(0.5 - rho * rho) / (1.0 - rho);\n    final double tbeta=alpha - .5;\n    final double tgamma=rho / (1 - rho);\n    multiplier=1.0 - beta * z + (tgamma - talpha + tbeta * tbeta * .5) * z * z;\n  }\n  return (alpha / D) * multiplier * d;\n}\n", "docstring": "computes the black equivalent volatility without validating parameters", "partition": "test"}
{"idx": "573", "code": "public double calculateLogLikelihood(){\n  double logL=0.0;\n  for (  Statistic statistic : dataList) {\n    for (int j=0; j < statistic.getDimension(); j++) {\n      logL-=Math.log(statistic.getStatisticValue(j));\n    }\n  }\n  return logL;\n}\n", "docstring": "calculate the log likelihood of the current state .", "partition": "test"}
{"idx": "3835", "code": "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n  iInstant=(LocalDateTime)oos.readObject();\n  DateTimeFieldType type=(DateTimeFieldType)oos.readObject();\n  iField=type.getField(iInstant.getChronology());\n}\n", "docstring": "reads the property from a safe serialization format .", "partition": "test"}
{"idx": "3884", "code": "public static boolean isVolumeFullCopySource(Volume volume,DbClient dbClient){\n  boolean isFullCopySource=false;\n  StringSet fullCopyIds=volume.getFullCopies();\n  if ((fullCopyIds != null) && (!fullCopyIds.isEmpty())) {\n    Iterator<String> fullCopyIdsIter=fullCopyIds.iterator();\n    while (fullCopyIdsIter.hasNext()) {\n      URI fullCopyURI=URI.create(fullCopyIdsIter.next());\n      Volume fullCopyVolume=dbClient.queryObject(Volume.class,fullCopyURI);\n      if ((fullCopyVolume != null) && (!fullCopyVolume.getInactive())) {\n        isFullCopySource=true;\n      }\n    }\n  }\n  return isFullCopySource;\n}\n", "docstring": "determine if the passed volume is a source volume for any full copies .", "partition": "test"}
{"idx": "292", "code": "public final double sampleMax(){\n  return _activeCountMax.getAndSet(_activeCount.get());\n}\n", "docstring": "sample the active count", "partition": "test"}
{"idx": "2940", "code": "public AbbaLockingDetector startCollecting(){\n  thread=new Thread(this,\"AbbaLockingDetector\");\n  thread.setDaemon(true);\n  thread.start();\n  return this;\n}\n", "docstring": "start collecting locking data .", "partition": "test"}
{"idx": "752", "code": "public static Context createPendingActionContext(Context context,ReconAction action,String mappingName,JsonValue sourceObject,String reconId,Situation situation){\n  Map<String,Object> pendingActionMap=new HashMap<String,Object>();\n  pendingActionMap.put(MAPPING_NAME,mappingName);\n  pendingActionMap.put(SOURCE_OBJECT,sourceObject);\n  pendingActionMap.put(RECON_ID,reconId);\n  pendingActionMap.put(ORIGINAL_SITUATION,situation.toString());\n  PendingActionContext pendingActionContext=new PendingActionContext(context,pendingActionMap,action.toString());\n  return pendingActionContext;\n}\n", "docstring": "creates and populates a pendingactioncontext .", "partition": "test"}
{"idx": "923", "code": "private static DeleteVmResponse checkDeleteVmResponse(DeleteVmResponse deleteVmResponse) throws RpcException {\n  logger.info(\"Checking {}\",deleteVmResponse);\nswitch (deleteVmResponse.getResult()) {\ncase OK:\n    break;\ncase SYSTEM_ERROR:\n  throw new SystemErrorException(deleteVmResponse.getError());\ncase VM_NOT_FOUND:\nthrow new VmNotFoundException(deleteVmResponse.getError());\ncase VM_NOT_POWERED_OFF:\nthrow new VmNotPoweredOffException(deleteVmResponse.getError());\ndefault :\nthrow new RpcException(String.format(\"Unknown response: %s\",deleteVmResponse.getResult()));\n}\nreturn deleteVmResponse;\n}\n", "docstring": "this method validates a deletevmresponse object , raising an exception if the response reflects an operation failure .", "partition": "test"}
{"idx": "4156", "code": "private static String guessContentType(String url){\n  url=url.toLowerCase();\n  if (url.endsWith(\".webm\")) {\n    return \"video/webm\";\n  }\n else   if (url.endsWith(\".mp4\")) {\n    return \"video/mp4\";\n  }\n else   if (url.matches(\".*\\\\\\\\.jpe?g\")) {\n    return \"image/jpeg\";\n  }\n else   if (url.endsWith(\".png\")) {\n    return \"image/png\";\n  }\n else   if (url.endsWith(\".gif\")) {\n    return \"image/gif\";\n  }\n else {\n    return \"application/octet-stream\";\n  }\n}\n", "docstring": "guess a content type from the url .", "partition": "test"}
{"idx": "4020", "code": "protected void positiveClose(){\n  freeContent();\n}\n", "docstring": "method stub for sub classes do not call from fxdialog e . g . when a user press the \" ok \" button", "partition": "test"}
{"idx": "963", "code": "protected void updateRadioLinks(){\n  m_CVBut.setEnabled(true);\n  m_CVText.setEnabled(m_CVBut.isSelected());\n  m_CVLab.setEnabled(m_CVBut.isSelected());\n  m_SeedText.setEnabled(m_CVBut.isSelected());\n  m_SeedLab.setEnabled(m_CVBut.isSelected());\n  if (m_AttributeEvaluatorEditor.getValue() instanceof AttributeTransformer) {\n    m_CVBut.setSelected(false);\n    m_CVBut.setEnabled(false);\n    m_CVText.setEnabled(false);\n    m_CVLab.setEnabled(false);\n    m_SeedText.setEnabled(false);\n    m_SeedLab.setEnabled(false);\n    m_TrainBut.setSelected(true);\n  }\n}\n", "docstring": "updates the enabled status of the input fields and labels .", "partition": "test"}
{"idx": "2012", "code": "public void unsubscribe(AWSIotMessage message) throws AWSIotException {\n  try {\n    unsubscribeTopic(message);\n  }\n catch (  AwsIotRetryableException e) {\n    if (client.getMaxOfflineQueueSize() > 0 && unsubscribeQueue.size() < client.getMaxOfflineQueueSize()) {\n      unsubscribeQueue.add(message);\n    }\n else {\n      LOGGER.info(\"Failed to unsubscribe to \" + message.getTopic());\n      throw new AWSIotException(e);\n    }\n  }\n}\n", "docstring": "the actual unsubscribe method exposed by this class .", "partition": "test"}
{"idx": "3563", "code": "private boolean isAckRequired(){\n  return this.ackRequired;\n}\n", "docstring": "return true if a distributed ack message is required . on the client side of a transaction , this returns false , while returning true elsewhere .", "partition": "test"}
