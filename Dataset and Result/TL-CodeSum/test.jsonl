{"idx": "0", "code": "protected boolean[] datasetIntegrity(boolean nominalPredictor,boolean numericPredictor,boolean stringPredictor,boolean datePredictor,boolean relationalPredictor,boolean multiInstance,int classType,boolean predictorMissing,boolean classMissing){\n  print(\"kernel doesn\'t alter original datasets\");\n  printAttributeSummary(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType);\n  print(\"...\");\n  int numTrain=getNumInstances(), numClasses=2, missingLevel=20;\n  boolean[] result=new boolean[2];\n  Instances train=null;\n  Kernel kernel=null;\n  try {\n    train=makeTestDataset(42,numTrain,nominalPredictor ? getNumNominal() : 0,numericPredictor ? getNumNumeric() : 0,stringPredictor ? getNumString() : 0,datePredictor ? getNumDate() : 0,relationalPredictor ? getNumRelational() : 0,numClasses,classType,multiInstance);\n    if (missingLevel > 0) {\n      addMissing(train,missingLevel,predictorMissing,classMissing);\n    }\n    kernel=Kernel.makeCopies(getKernel(),1)[0];\n  }\n catch (  Exception ex) {\n    throw new Error(\"Error setting up for tests: \" + ex.getMessage());\n  }\n  try {\n    Instances trainCopy=new Instances(train);\n    kernel.buildKernel(trainCopy);\n    compareDatasets(train,trainCopy);\n    println(\"yes\");\n    result[0]=true;\n  }\n catch (  Exception ex) {\n    println(\"no\");\n    result[0]=false;\n    if (m_Debug) {\n      println(\"\\n=== Full Report ===\");\n      print(\"Problem during building\");\n      println(\": \" + ex.getMessage() + \"\\n\");\n      println(\"Here is the dataset:\\n\");\n      println(\"=== Train Dataset ===\\n\" + train.toString() + \"\\n\");\n    }\n  }\n  return result;\n}\n", "docstring": "checks whether the scheme alters the training dataset during building . if the scheme needs to modify the data it should take a copy of the training data . currently checks for changes to header structure , number of instances , order of instances , instance weights .", "partition": "test"}
{"idx": "1", "code": "public static int unionSize(long[] x,long[] y){\n  final int lx=x.length, ly=y.length;\n  final int min=(lx < ly) ? lx : ly;\n  int i=0, res=0;\n  for (; i < min; i++) {\n    res+=Long.bitCount(x[i] | y[i]);\n  }\n  for (; i < lx; i++) {\n    res+=Long.bitCount(x[i]);\n  }\n  for (; i < ly; i++) {\n    res+=Long.bitCount(y[i]);\n  }\n  return res;\n}\n", "docstring": "compute the union size of two bitsets .", "partition": "test"}
{"idx": "2", "code": "public void testReverseOrder4() throws Exception {\n  UUID id=UUID.randomUUID();\n  GridCacheAdapter<String,String> cache=grid.internalCache();\n  GridCacheContext<String,String> ctx=cache.context();\n  GridCacheTestEntryEx entry1=new GridCacheTestEntryEx(ctx,\"1\");\n  GridCacheTestEntryEx entry2=new GridCacheTestEntryEx(ctx,\"2\");\n  GridCacheVersion ver1=version(1);\n  GridCacheVersion ver2=version(2);\n  GridCacheVersion ver3=version(3);\n  GridCacheMvccCandidate v3k1=entry1.addLocal(3,ver3,0,true,false);\n  GridCacheMvccCandidate v3k2=entry2.addLocal(3,ver3,0,true,false);\n  linkCandidates(ctx,v3k1,v3k2);\n  entry1.readyLocal(ver3);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,false,false,false);\n  GridCacheMvccCandidate v1k1=entry1.addLocal(4,ver1,0,true,true);\n  GridCacheMvccCandidate v1k2=entry2.addLocal(4,ver1,0,true,true);\n  linkCandidates(ctx,v1k1,v1k2);\n  entry1.readyLocal(ver1);\n  entry2.readyLocal(ver1);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,false,false,false);\n  checkLocal(v1k1,ver1,true,false,false);\n  checkLocal(v1k2,ver1,true,false,false);\n  GridCacheMvccCandidate v2k2=entry2.addRemote(id,5,ver2,0,false,false);\n  checkRemote(v2k2,ver2,false,false);\n  entry2.readyLocal(v3k2);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,true,true,false);\n}\n", "docstring": "tests local candidates with remote version in the middle on key2 .", "partition": "test"}
{"idx": "3", "code": "@Override public void closingOK(){\n  List<AddUserFields.AttributeSpec> specs=new ArrayList<AddUserFields.AttributeSpec>();\n  for (int i=0; i < m_listModel.size(); i++) {\n    AddUserFields.AttributeSpec a=(AddUserFields.AttributeSpec)m_listModel.elementAt(i);\n    specs.add(a);\n  }\n  if (m_modifyL != null) {\n    m_modifyL.setModifiedStatus(AddUserFieldsCustomizer.this,true);\n  }\n  m_filter.setAttributeSpecs(specs);\n}\n", "docstring": "actions to perform when the user has closed the dialog with the ok button .", "partition": "test"}
{"idx": "4", "code": "public String toString(){\n  StringBuffer text=new StringBuffer();\n  if ((m_classAttribute == null)) {\n    return \"SMO: No model built yet.\";\n  }\n  try {\n    text.append(\"SMO\\n\\n\");\n    text.append(\"Kernel used:\\n  \" + m_kernel.toString() + \"\\n\\n\");\n    for (int i=0; i < m_classAttribute.numValues(); i++) {\n      for (int j=i + 1; j < m_classAttribute.numValues(); j++) {\n        text.append(\"Classifier for classes: \" + m_classAttribute.value(i) + \", \"+ m_classAttribute.value(j)+ \"\\n\\n\");\n        text.append(m_classifiers[i][j]);\n        if (m_fitLogisticModels) {\n          text.append(\"\\n\\n\");\n          if (m_classifiers[i][j].m_logistic == null) {\n            text.append(\"No logistic model has been fit.\\n\");\n          }\n else {\n            text.append(m_classifiers[i][j].m_logistic);\n          }\n        }\n        text.append(\"\\n\\n\");\n      }\n    }\n  }\n catch (  Exception e) {\n    return \"Can\'t print SMO classifier.\";\n  }\n  return text.toString();\n}\n", "docstring": "prints out the classifier .", "partition": "test"}
{"idx": "5", "code": "private static boolean isDoubleEqual(double value,double valueToCompare){\n  return (Math.abs(value - valueToCompare) < 0.001);\n}\n", "docstring": "checks if is double values are equal .", "partition": "test"}
{"idx": "6", "code": "@Override public void datasetChanged(DatasetChangeEvent event){\n  super.datasetChanged(event);\n  if (this.subplots == null) {\n    return;\n  }\n  XYDataset dataset=null;\n  if (event.getDataset() instanceof XYDataset) {\n    dataset=(XYDataset)event.getDataset();\n  }\n  for (  XYPlot subplot : this.subplots) {\n    if (subplot.indexOf(dataset) >= 0) {\n      subplot.configureRangeAxes();\n    }\n  }\n}\n", "docstring": "receives notification of a change to the plot \"'\" s dataset . < p > the axis ranges are updated if necessary .", "partition": "test"}
{"idx": "7", "code": "public boolean onScheduleAsLibrary(Config config,Config runtime,IScheduler scheduler,PackingPlan packing){\n  boolean ret=false;\n  try {\n    scheduler.initialize(config,runtime);\n    ret=scheduler.onSchedule(packing);\n    if (ret) {\n      ret=SchedulerUtils.setLibSchedulerLocation(runtime,scheduler,false);\n    }\n else {\n      LOG.severe(\"Failed to invoke IScheduler as library\");\n    }\n  }\n  finally {\n    scheduler.close();\n  }\n  return ret;\n}\n", "docstring": "invoke the onscheduler ( ) in ischeduler directly as a library", "partition": "test"}
{"idx": "8", "code": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}\n", "docstring": "returns true if specified type is java . lang . string", "partition": "test"}
{"idx": "9", "code": "public Entry updateOrCreateSource(User user,String id,String url,String title,Long modTime,Long createTime,boolean isAdmin,Errors errors){\n  if (user == null) {\n    Errors.add(errors,errorMessages.errorUserIsNull());\n    return null;\n  }\n  if (url == null) {\n    Errors.add(errors,errorMessages.errorUrlIsNull());\n    return null;\n  }\n  Entry source=getEntryByUserIdAndUrl(user.getId(),url);\n  if (source == null) {\n    if (url.isEmpty()) {\n      Errors.add(errors,errorMessages.errorUrlIsEmpty());\n      return null;\n    }\n    if (title == null) {\n      Errors.add(errors,errorMessages.errorTitleIsNull());\n      return null;\n    }\n    if (title.isEmpty()) {\n      Errors.add(errors,errorMessages.errorTitleIsEmpty());\n      return null;\n    }\n    if (modTime == null) {\n      Errors.add(errors,errorMessages.errorModTimeIsNull());\n      return null;\n    }\n    if (createTime == null) {\n      Errors.add(errors,errorMessages.errorCreateTimeIsNull());\n      return null;\n    }\n    if (id != null && !idGenerator.isIdWellFormed(id)) {\n      Errors.add(errors,errorMessages.errorIdIsInvalid());\n      return null;\n    }\n    if (createTime.longValue() > modTime.longValue()) {\n      modTime=createTime;\n    }\n    if (url != null) {\n      url=cleanUpText(url);\n    }\n    if (title != null) {\n      title=cleanUpText(title);\n    }\n    source=new Entry();\n    source.setDb(db);\n    if (id == null) {\n      id=idGenerator.getAnotherId();\n    }\n    source.setId(id);\n    source.setSourceUrl(url);\n    source.setSourceTitle(title);\n    source.setCreateTime(createTime);\n    source.setType(Constants.source);\n    source.setUserId(user.getId());\n    db.persistEntry(source);\n  }\n else   if (!canUserModifyEntry(user,source,isAdmin)) {\n    Errors.add(errors,errorMessages.errorUserIsNotEntitledToModifyTheSource());\n    return null;\n  }\n  source.setModTime(modTime);\n  return source;\n}\n", "docstring": "api method . returns an entry for the source indexed by the user and the url . this method creates it if it didn \"'\" t already exist .", "partition": "test"}
{"idx": "10", "code": "private void validateSqlStatement(String sql,int jdbcStatementIndex){\n  Assert.isTrue(StringUtils.isNotBlank(sql),\"JDBC statement [\" + jdbcStatementIndex + \"] SQL is required\");\n}\n", "docstring": "validates the given sql statement where its position in the list of statement is the given index . this method does not validate sql syntax .", "partition": "test"}
{"idx": "11", "code": "public static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}\n", "docstring": "converts to object array .", "partition": "test"}
{"idx": "12", "code": "@Override public boolean isTraceEnabled(){\n  return logger.isLoggable(Level.FINEST);\n}\n", "docstring": "is this logger instance enabled for the finest level ?", "partition": "test"}
{"idx": "13", "code": "private static void useMissile(Player player){\n  StackableItem projectilesItem=null;\n  if (player.getRangeWeapon() != null) {\n    projectilesItem=player.getAmmunition();\n  }\n  if (projectilesItem == null) {\n    projectilesItem=player.getMissileIfNotHoldingOtherWeapon();\n  }\n  if (projectilesItem != null) {\n    projectilesItem.removeOne();\n  }\n}\n", "docstring": "remove an used up missile from an attacking player .", "partition": "test"}
{"idx": "14", "code": "public TcpMatcher(final NetworkConfig config){\n  super(config);\n}\n", "docstring": "creates a new matcher for running coap over tcp .", "partition": "test"}
{"idx": "15", "code": "private int determineMaxLevelRec(int level,Node v){\n  int newLevel=level;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    newLevel=Math.max(newLevel,determineMaxLevelRec(level,e.getTarget()) + 1);\n  }\n  return newLevel;\n}\n", "docstring": "recursively does the work", "partition": "test"}
{"idx": "16", "code": "private synchronized void putMapEntry(String localId,MapEntry entry){\n  if (!isLocalId(localId)) {\n    throw new IllegalStateException(\"Tried to get invalid local id: \\\"\" + localId + \"\\\".\");\n  }\n  JSONObject json=new JSONObject();\n  try {\n    json.put(\"retainCount\",entry.retainCount);\n    if (entry.objectId != null) {\n      json.put(\"objectId\",entry.objectId);\n    }\n  }\n catch (  JSONException je) {\n    throw new IllegalStateException(\"Error creating local id map entry.\",je);\n  }\n  File file=new File(diskPath,localId);\n  if (!diskPath.exists()) {\n    diskPath.mkdirs();\n  }\n  try {\n    ParseFileUtils.writeJSONObjectToFile(file,json);\n  }\n catch (  IOException e) {\n  }\n}\n", "docstring": "writes one entry to the local id map on disk .", "partition": "test"}
{"idx": "17", "code": "public static void f(String msg,Object... args){\n  if (!allowWtf)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n", "docstring": "send a fatal error log message", "partition": "test"}
{"idx": "18", "code": "public void deleteLeaves(String name){\n  for (int i=0; i < _leaves.size(); i++) {\n    CatalogTreeLeaf leaf=_leaves.get(i);\n    if (name.equals(leaf.getName())) {\n      _leaves.remove(i);\n    }\n  }\n}\n", "docstring": "leaves can be used for many - to - many relations", "partition": "test"}
{"idx": "19", "code": "public String toString(){\n  final StringBuffer s=new StringBuffer();\n  final int size=size();\n  for (int i=0; i < size; i++)   s.append(getInt(i));\n  return s.toString();\n}\n", "docstring": "returns a string representation of this vector . < p > note that this string representation shows the bit of index 0 at the leftmost position .", "partition": "test"}
{"idx": "20", "code": "protected boolean validate(final char[] component,final int soffset,int eoffset,final BitSet generous){\n  if (eoffset == -1) {\n    eoffset=component.length - 1;\n  }\n  for (int i=soffset; i <= eoffset; i++) {\n    if (!generous.get(component[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "validate the uri characters within a specific component . the component must be performed after escape encoding . or it doesn \"'\" t include escaped characters . < p > it \"'\" s not that much strict , generous . the strict validation might be performed before being called this method .", "partition": "test"}
{"idx": "21", "code": "public boolean removeShutdownHook(Thread hook){\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(RuntimePermissionCollection.SHUTDOWN_HOOKS_PERMISSION);\n  }\n  if (hook == null)   throw new NullPointerException(\"null is not allowed here\");\n  if (VMState > 0) {\n    throw new IllegalStateException();\n  }\nsynchronized (hooksList) {\n    return hooksList.remove(hook);\n  }\n}\n", "docstring": "de - registers a previously - registered virtual - machine shutdown hook .", "partition": "test"}
{"idx": "22", "code": "public void run(){\n  while (m_keyboardStream != null) {\n    try {\n      if (m_keyboardReadRequest) {\n        String s=m_keyboardStream.readLine();\n        m_keyboardInput.add(s);\n        m_keyboardReadRequest=false;\nsynchronized (this) {\n          notifyAll();\n        }\n      }\n else       try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException ie) {\n      }\n    }\n catch (    IOException io) {\n    }\n  }\n}\n", "docstring": "a seperate thread collects our input so that we can block in the docontinue on the main thread and then allow the user to interrupt us via keyboard input on this thread . < p / > we built the stupid thing in this manner , since readline ( ) will block no matter what and if we \"'\" quit \"'\" we can \"'\" t seem to kill this thread . . close ( ) doesn \"'\" t work and thread . stop ( ) , etc . all fail to do the job . < p / > thus we needed to take a request response approach so that we only block when requested to do so .", "partition": "test"}
{"idx": "23", "code": "public boolean boundScroll(){\n  float curScroll=getStackScroll();\n  float newScroll=getBoundedStackScroll(curScroll);\n  if (Float.compare(newScroll,curScroll) != 0) {\n    setStackScroll(newScroll);\n    return true;\n  }\n  return false;\n}\n", "docstring": "bounds the current scroll if necessary", "partition": "test"}
{"idx": "24", "code": "@Override public AggregateableEvaluation aggregate(Evaluation evaluation){\n  m_Incorrect+=evaluation.incorrect();\n  m_Correct+=evaluation.correct();\n  m_Unclassified+=evaluation.unclassified();\n  m_MissingClass+=evaluation.m_MissingClass;\n  m_WithClass+=evaluation.m_WithClass;\n  if (evaluation.m_ConfusionMatrix != null) {\n    double[][] newMatrix=evaluation.confusionMatrix();\n    if (newMatrix != null) {\n      for (int i=0; i < m_ConfusionMatrix.length; i++) {\n        for (int j=0; j < m_ConfusionMatrix[i].length; j++) {\n          m_ConfusionMatrix[i][j]+=newMatrix[i][j];\n        }\n      }\n    }\n  }\n  double[] newClassPriors=evaluation.m_ClassPriors;\n  if (newClassPriors != null && m_ClassPriors != null) {\n    for (int i=0; i < this.m_ClassPriors.length; i++) {\n      m_ClassPriors[i]=newClassPriors[i];\n    }\n  }\n  m_ClassPriorsSum=evaluation.m_ClassPriorsSum;\n  m_TotalCost+=evaluation.totalCost();\n  m_SumErr+=evaluation.m_SumErr;\n  m_SumAbsErr+=evaluation.m_SumAbsErr;\n  m_SumSqrErr+=evaluation.m_SumSqrErr;\n  m_SumClass+=evaluation.m_SumClass;\n  m_SumSqrClass+=evaluation.m_SumSqrClass;\n  m_SumPredicted+=evaluation.m_SumPredicted;\n  m_SumSqrPredicted+=evaluation.m_SumSqrPredicted;\n  m_SumClassPredicted+=evaluation.m_SumClassPredicted;\n  m_SumPriorAbsErr+=evaluation.m_SumPriorAbsErr;\n  m_SumPriorSqrErr+=evaluation.m_SumPriorSqrErr;\n  m_SumKBInfo+=evaluation.m_SumKBInfo;\n  double[] newMarginCounts=evaluation.m_MarginCounts;\n  if (newMarginCounts != null) {\n    for (int i=0; i < m_MarginCounts.length; i++) {\n      m_MarginCounts[i]+=newMarginCounts[i];\n    }\n  }\n  m_ComplexityStatisticsAvailable=evaluation.m_ComplexityStatisticsAvailable;\n  m_CoverageStatisticsAvailable=evaluation.m_CoverageStatisticsAvailable;\n  m_SumPriorEntropy+=evaluation.m_SumPriorEntropy;\n  m_SumSchemeEntropy+=evaluation.m_SumSchemeEntropy;\n  m_TotalSizeOfRegions+=evaluation.m_TotalSizeOfRegions;\n  m_TotalCoverage+=evaluation.m_TotalCoverage;\n  ArrayList<Prediction> predsToAdd=evaluation.m_Predictions;\n  if (predsToAdd != null) {\n    if (m_Predictions == null) {\n      m_Predictions=new ArrayList<Prediction>();\n    }\n    for (int i=0; i < predsToAdd.size(); i++) {\n      m_Predictions.add(predsToAdd.get(i));\n    }\n  }\n  return this;\n}\n", "docstring": "adds the statistics encapsulated in the supplied evaluation object into this one . does not perform any checks for compatibility between the supplied evaluation object and this one .", "partition": "test"}
{"idx": "25", "code": "public void waitForVolumesToBeVisible(CGRequestParams request){\n  scan(request.getCopies(),request.getRsets());\n}\n", "docstring": "scans all sites until all volumes involved in the recoverpoint protection are visible", "partition": "test"}
{"idx": "26", "code": "protected void startAdditionalServices(final Cache cache,final Map<String,Object> options) throws Exception {\n}\n", "docstring": "this method is called immediately following cache creation in the spawned process , but prior to setting the running flag in the status file . so the spawning process will block until this method completes .", "partition": "test"}
{"idx": "27", "code": "public void updateView(){\n  if (fInputElement != null && fParentComposite != null) {\n    IndicatorViewState oldState=fStateMap.get(fInputElement);\n    boolean reload=fFilesToReoad.contains(fInputElement);\n    if (reload || oldState == null) {\n      JsonObject jsonObject=DroidsafePluginUtilities.parseIndicatorFile(fInputElement);\n      if (jsonObject == null)       return;\n      fFilesToReoad.remove(fInputElement);\n      fState=new IndicatorViewState(fInputElement,jsonObject,getSecuritySpec(),oldState);\n      fStateMap.put(fInputElement,fState);\n    }\n else {\n      fState=oldState;\n    }\n    setPartName(fState.indicatorType);\n    showPage(PAGE_VIEWER);\n    fTreeViewer.setInput(fState.jsonObject);\n    if (fTreeViewer.getSorter() == null)     sortByField(getSortByField());\n  }\n else {\n    setPartName(DEFAULT_PART_NAME);\n  }\n}\n", "docstring": "update the content of the outline view .", "partition": "test"}
{"idx": "28", "code": "@Override public void paint(Graphics g){\n  g.drawImage(image,0,0,this);\n  if (!paintCalled) {\n    paintCalled=true;\nsynchronized (this) {\n      notifyAll();\n    }\n  }\n}\n", "docstring": "paints the image on the window .", "partition": "test"}
{"idx": "29", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection with respect to the named event", "partition": "test"}
{"idx": "30", "code": "public boolean isPrefixed(){\n  return name.indexOf(':') >= 0;\n}\n", "docstring": "it returns true if the attribute is prefixed ( used the \" : \" character ) .", "partition": "test"}
{"idx": "31", "code": "public void releaseAnyConnection(Connection connection) throws SQLException {\n  try {\n    connection.close();\n  }\n catch (  Exception ex) {\n    throw new RuntimeException(ex);\n  }\n}\n", "docstring": "release a non - shard - specific connection .", "partition": "test"}
{"idx": "32", "code": "public QuickActionView addActions(Collection<Action> actions){\n  checkShown();\n  mActions.addAll(actions);\n  return this;\n}\n", "docstring": "adds a collection of actions to the quickactionview", "partition": "test"}
{"idx": "33", "code": "protected <T extends AbstractOptionValue<?,?>>AbstractOptions(Function<T,T> valueFilter,AbstractOptions baseOptions,Iterable<T> values){\n  requireNonNull(baseOptions,\"baseOptions\");\n  requireNonNull(valueFilter,\"valueFilter\");\n  requireNonNull(values,\"values\");\n  valueMap=new IdentityHashMap<>(baseOptions.valueMap);\n  putAll(valueFilter,StreamSupport.stream(values.spliterator(),false));\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "34", "code": "public CharSeq concat(CharSeq another){\n  return new CharSeq(str + another.str);\n}\n", "docstring": "append string of the given charseq to this charseq", "partition": "test"}
{"idx": "35", "code": "@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n  resp.setContentType(\"text/plain\");\n  PrintWriter sendToClient=resp.getWriter();\n  for (  Video v : this.videos) {\n    sendToClient.write(v.getName() + \" : \" + v.getUrl()+ \"\\n\");\n  }\n}\n", "docstring": "this method processes all of the http get requests routed to the servlet by the web container . this method loops through the lists of videos that have been sent to it and generates a plain / text list of the videos that is sent back to the client .", "partition": "test"}
{"idx": "36", "code": "protected void notifyStateChange(int oldState,int newState){\n  mState=newState;\n  if (oldState != newState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(oldState),Integer.valueOf(newState));\n  }\n}\n", "docstring": "change the stored state value and do notification , but don \"'\" t change anything in the hardware", "partition": "test"}
{"idx": "37", "code": "private void formatAndLogThrowable(LoggingLevel level,Color color,String msg,Throwable t){\n  if (!USE_COLORS) {\n    formatAndLogThrowable(level,msg,t);\n    return;\n  }\n  if (PhotonLogger.level.id < level.id) {\n    return;\n  }\n  LocalDateTime dateTime=LocalDateTime.now();\n  String formatted=formatLogLine(level,dateTime,msg);\n  LoggingService.logThrowable(dateTime,t,formatted,color);\n}\n", "docstring": "formats and logs a message with a throwable .", "partition": "test"}
{"idx": "38", "code": "public static String constructQueueRedisKey(String queueName,String shardName,int priority,PinLaterJobState state){\n  return String.format(\"%s_%s_%s.p%1d_s%1d\",PINLATER_QUEUE_KEY_PREFIX,shardName,queueName,priority,state.getValue());\n}\n", "docstring": "constructs the redis queue sorted set key name given a queue name , shard id and priority .", "partition": "test"}
{"idx": "39", "code": "public static String decodeCharset(String s,String charset){\n  if (s == null) {\n    return null;\n  }\n  try {\n    byte buf[]=s.getBytes(ASCII_CHARSET);\n    return (new String(buf,0,buf.length,charset));\n  }\n catch (  UnsupportedEncodingException uee) {\n    return s;\n  }\n}\n", "docstring": "decodes the string into specified charset", "partition": "test"}
{"idx": "40", "code": "public void addRestrictedDomain(String domainName){\n  if (StringUtils.isEmpty(domainName)) {\n    return;\n  }\n  if (restrictedDomains == null) {\n    restrictedDomains=new ArrayList<>();\n  }\n  restrictedDomains.add(domainName);\n}\n", "docstring": "adds specified domain name to the list of restricted domains", "partition": "test"}
{"idx": "41", "code": "StoppableReadLock(ReadWriteLock lock,CancelCriterion stopper){\n  this.lock=lock.readLock();\n  this.stopper=stopper;\n}\n", "docstring": "create a new read lock from the given lock", "partition": "test"}
{"idx": "42", "code": "private long computeInterfaceHash(){\n  long hash=0;\n  ByteArrayOutputStream sink=new ByteArrayOutputStream(512);\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    DataOutputStream out=new DataOutputStream(new DigestOutputStream(sink,md));\n    out.writeInt(INTERFACE_HASH_STUB_VERSION);\n    for (    Method method : remoteMethods) {\n      MethodDoc methodDoc=method.methodDoc();\n      out.writeUTF(methodDoc.name());\n      out.writeUTF(Util.methodDescriptorOf(methodDoc));\n      ClassDoc exceptions[]=methodDoc.thrownExceptions();\n      Arrays.sort(exceptions,new ClassDocComparator());\n      for (      ClassDoc ex : exceptions) {\n        out.writeUTF(Util.binaryNameOf(ex));\n      }\n    }\n    out.flush();\n    byte hashArray[]=md.digest();\n    for (int i=0; i < Math.min(8,hashArray.length); i++) {\n      hash+=((long)(hashArray[i] & 0xFF)) << (i * 8);\n    }\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new AssertionError(e);\n  }\n  return hash;\n}\n", "docstring": "computes the \" interface hash \" of the stub / skeleton pair for this remote implementation class . this is the 64 - bit value used to enforce compatibility between a stub class and a skeleton class in the jdk 1 . 1 version of the jrmp stub / skeleton protocol . it is calculated using the first 64 bits of an sha digest . the digest is of a stream consisting of the following data : ( int ) stub version number , always 1 for each remote method , in order of operation number : ( utf - 8 ) method name ( utf - 8 ) method descriptor for each declared exception , in alphabetical name order : ( utf - 8 ) name of exception class ( where \" utf - 8 \" includes a 16 - bit length prefix as written by java . io . dataoutput . writeutf ) .", "partition": "test"}
{"idx": "43", "code": "private static native boolean renderFrame(int[] pixels,long gifFileInPtr,int[] metaData);\n", "docstring": "decodes a frame if needed .", "partition": "test"}
{"idx": "44", "code": "private ServiceRegistrar[] buildServiceRegistrar(){\n  int k=0;\n  ServiceRegistrar[] proxys=new ServiceRegistrar[proxyRegSet.size()];\n  Iterator iter=proxyRegSet.iterator();\n  while (iter.hasNext()) {\n    ProxyReg reg=(ProxyReg)iter.next();\n    proxys[k++]=reg.proxy;\n  }\n  return proxys;\n}\n", "docstring": "returns array of serviceregistrar created from the proxyregset", "partition": "test"}
{"idx": "45", "code": "private static boolean checkValue(String val) throws MalformedObjectNameException {\n  if (val == null)   throw new NullPointerException(\"Invalid value (null)\");\n  final int len=val.length();\n  if (len == 0)   return false;\n  final char[] s=val.toCharArray();\n  final int[] result=parseValue(s,0);\n  final int endValue=result[0];\n  final boolean value_pattern=result[1] == 1;\n  if (endValue < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + s[endValue] + \"\'\");\n  return value_pattern;\n}\n", "docstring": "check if the supplied value is a valid value .", "partition": "test"}
{"idx": "46", "code": "protected void recoverPrimary(Set excludedServers){\n  if (pool.getPoolOrCacheCancelInProgress() != null) {\n    return;\n  }\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (queueConnections.getPrimary() != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"Primary recovery not needed\");\n    }\n    return;\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover\");\n  }\n  if (printRecoveringPrimary) {\n    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));\n    printRecoveringPrimary=false;\n  }\n  QueueConnectionImpl newPrimary=null;\n  while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {\n    List backups=queueConnections.getBackups();\n    newPrimary=promoteBackupToPrimary(backups);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\nsynchronized (lock) {\n        queueConnections=queueConnections.removeConnection(newPrimary);\n      }\n      newPrimary=null;\n    }\n  }\n  if (newPrimary != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"SubscriptionManager redundancy satisfier - Switched backup server to primary: {}\",newPrimary.getEndpoint());\n    }\n    if (PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    cqsConnected();\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  while (newPrimary == null) {\n    newPrimary=createNewPrimary(excludedServers);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\n      excludedServers.add(newPrimary.getServer());\n      newPrimary=null;\n    }\n    if (newPrimary != null) {\n      if (isDebugEnabled) {\n        logger.debug(\"SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}\",newPrimary.getEndpoint());\n      }\n      if (!recoverInterest(newPrimary,true)) {\n        excludedServers.add(newPrimary.getServer());\n        newPrimary=null;\n      }\n      cqsConnected();\n    }\n    if (newPrimary != null && PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  cqsDisconnected();\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - Could not recover a new primary\");\n  }\nsynchronized (lock) {\n    queueConnections=queueConnections.setPrimaryDiscoveryFailed(null);\n    lock.notifyAll();\n  }\n}\n", "docstring": "find a new primary , adding any failed servers we encounter to the excluded servers list first we try to make a backup server the primary , but if run out of backup servers we will try to find a new server .", "partition": "test"}
{"idx": "47", "code": "public void addNodesInDocOrder(DTMIterator iterator,XPathContext support){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  int node;\n  while (DTM.NULL != (node=iterator.nextNode())) {\n    addNodeInDocOrder(node,support);\n  }\n}\n", "docstring": "copy nodelist members into this nodelist , adding in document order . if a node is null , don \"'\" t add it .", "partition": "test"}
{"idx": "48", "code": "protected boolean needToRefetchData(){\n  long now=System.currentTimeMillis();\n  long last=lastDataFetchTime;\n  if ((last + fetchIntervalMillis) < now) {\n    lastDataFetchTime=now;\n    return true;\n  }\n  return false;\n}\n", "docstring": "fetches data if it hasn \"'\" t been fetched in a while .", "partition": "test"}
{"idx": "49", "code": "@Override public DocumentType createDocumentType(String qualifiedName,String publicID,String systemID){\n  checkQName(qualifiedName);\n  return new DocumentTypeImpl(null,qualifiedName,publicID,systemID);\n}\n", "docstring": "introduced in dom level 2 . < p > < p / > creates an empty documenttype node .", "partition": "test"}
{"idx": "50", "code": "public void handleRequest(RequestContext rc) throws CLIException {\n  super.handleRequest(rc);\n  ldapLogin();\n  SSOToken adminSSOToken=getAdminSSOToken();\n  IOutput outputWriter=getOutputWriter();\n  String realm=getStringOptionValue(IArgument.REALM_NAME);\n  String patternType=getStringOptionValue(IArgument.AGENT_TYPE);\n  String filter=getStringOptionValue(IArgument.FILTER);\n  if (patternType == null) {\n    patternType=\"\";\n  }\n  if ((filter == null) || (filter.length() == 0)) {\n    filter=\"*\";\n  }\n  String[] params={realm,patternType,filter};\n  writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"ATTEMPT_LIST_AGENTS\",params);\n  try {\n    AMIdentityRepository amir=new AMIdentityRepository(adminSSOToken,realm);\n    IdSearchResults isr=amir.searchIdentities(IdType.AGENTONLY,filter,new IdSearchControl());\n    Set results=isr.getSearchResults();\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        if (!matchType(amid,patternType)) {\n          i.remove();\n        }\n      }\n    }\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        Object[] args={amid.getName(),amid.getUniversalId()};\n        outputWriter.printlnMessage(MessageFormat.format(getResourceString(\"format-search-agent-results\"),args));\n      }\n    }\n else {\n      outputWriter.printlnMessage(getResourceString(\"search-agent-no-entries\"));\n    }\n    writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"SUCCEED_LIST_AGENTS\",params);\n  }\n catch (  IdRepoException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\ncatch (  SSOException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\n}\n", "docstring": "services a commandline request .", "partition": "test"}
{"idx": "51", "code": "public byte[] toBytes(){\n  try {\n    ByteArrayOutputStream out=new ByteArrayOutputStream();\n    _field.store(out,null);\n    return out.toByteArray();\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "docstring": "serializes this nested object into byte [ ", "partition": "test"}
{"idx": "52", "code": "@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}\n", "docstring": "returns first enum constant found in at space - separated list of style names .", "partition": "test"}
{"idx": "53", "code": "@HLEUnimplemented @HLEFunction(nid=0x3C37A7A6,version=150,checkInsideInterrupt=true) public int sceMpegNextAvcRpAu(@CheckArgument(\"checkMpegHandle\") int mpeg,int streamUid){\n  if (!streamMap.containsKey(streamUid)) {\n    log.warn(String.format(\"sceMpegNextAvcRpAu bad stream 0x%X\",streamUid));\n    return -1;\n  }\n  int result=hleMpegGetAvcAu(null);\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceMpegNextAvcRpAu returning 0x%08X\",result));\n    }\n    return result;\n  }\n  videoFrameCount++;\n  startedMpeg=true;\n  return 0;\n}\n", "docstring": "scempegnextavcrpau - skip one video frame", "partition": "test"}
{"idx": "54", "code": "private Map<URI,ExportMask> createExportMaskMap(Set<URI> placedMasks){\n  Map<URI,ExportMask> exportMaskMap=new HashMap<>();\n  Iterator<ExportMask> exportMaskIterator=dbClient.queryIterativeObjects(ExportMask.class,placedMasks,true);\n  while (exportMaskIterator.hasNext()) {\n    ExportMask exportMask=exportMaskIterator.next();\n    exportMaskMap.put(exportMask.getId(),exportMask);\n  }\n  return exportMaskMap;\n}\n", "docstring": "given a set of exportmask uris , return a map of exportmask uri to exportmask object", "partition": "test"}
{"idx": "55", "code": "public ImmutableArray2<K> insert(int index,K obj){\n  int len=length + 1;\n  int newLen=len;\n  boolean extendable;\n  if (index == len - 1) {\n    AtomicBoolean x=canExtend;\n    if (x != null) {\n      canExtend=null;\n      if (array.length > index && x.getAndSet(false)) {\n        array[index]=obj;\n        return new ImmutableArray2<K>(array,len,true);\n      }\n    }\n    extendable=true;\n    newLen=len + 4;\n  }\n else {\n    extendable=false;\n  }\n  @SuppressWarnings(\"unchecked\") K[] a2=(K[])new Object[newLen];\n  DataUtils.copyWithGap(array,a2,length,index);\n  a2[index]=obj;\n  return new ImmutableArray2<K>(a2,len,extendable);\n}\n", "docstring": "insert an entry at this index .", "partition": "test"}
{"idx": "56", "code": "public void writeNoScale(Image c,Component i){\n  if (page == null) {\n    newpage();\n  }\n  int x=x0 + width - (c.getWidth(null) + charwidth);\n  int y=y0 + (linenum * lineheight) + lineascent;\n  if (page != null && pagenum >= prFirst) {\n    page.drawImage(c,x,y,c.getWidth(null),c.getHeight(null),null);\n  }\n}\n", "docstring": "write a graphic to the printout . < p > this was not in the original class , but was added afterwards by kevin dickerson . it is a copy of the write , but without the scaling . < p > the image is positioned on the right side of the paper , at the current height .", "partition": "test"}
{"idx": "57", "code": "public static void copy(InputStream is,Resource out,boolean closeIS) throws IOException {\n  OutputStream os=null;\n  try {\n    os=toBufferedOutputStream(out.getOutputStream());\n  }\n catch (  IOException ioe) {\n    IOUtil.closeEL(os);\n    throw ioe;\n  }\n  copy(is,os,closeIS,true);\n}\n", "docstring": "copy a input resource to a output resource", "partition": "test"}
{"idx": "58", "code": "public String fadeAudio(String path,String type,double fadeInLength,double stopTime,double fadeOutLength) throws IOException {\n  final List<String> curves=Arrays.asList(new String[]{\"q\",\"h\",\"t\",\"l\",\"p\"});\n  if (!curves.contains(type)) {\n    throw new RuntimeException(\"fadeAudio: passed invalid type: \" + type);\n  }\n  File file=new File(path);\n  String outFile=file.getCanonicalPath() + \"_faded.wav\";\n  ArrayList<String> cmd=new ArrayList<String>();\n  cmd.add(soxBin);\n  cmd.add(path);\n  cmd.add(outFile);\n  cmd.add(\"fade\");\n  cmd.add(type);\n  cmd.add(fadeInLength + \"\");\n  if (stopTime != -1)   cmd.add(stopTime + \"\");\n  if (fadeOutLength != -1)   cmd.add(fadeOutLength + \"\");\n  try {\n    int rc=execSox(cmd,callback);\n    if (rc != 0) {\n      outFile=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return outFile;\n}\n", "docstring": "fade audio file sox < path > outfile fade < type > < fadeinlength > < stoptime > < fadeoutlength >", "partition": "test"}
{"idx": "59", "code": "@Override public void draw(Canvas canvas){\n  super.draw(canvas);\n  if (mEdgeGlowTop != null) {\n    final int scrollX=getScrollX();\n    if (!mEdgeGlowTop.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.top + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.bottom + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      int edgeX=Math.min(0,scrollX + mFirstPositionDistanceGuess);\n      canvas.rotate(-90);\n      canvas.translate(-getHeight() + topPadding,edgeX);\n      mEdgeGlowTop.setSize(height,height);\n      if (mEdgeGlowTop.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n    if (!mEdgeGlowBottom.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.left + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.right + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      final int width=getWidth();\n      int edgeX=Math.max(width,scrollX + mLastPositionDistanceGuess);\n      canvas.rotate(90);\n      canvas.translate(-topPadding,-edgeX);\n      mEdgeGlowBottom.setSize(height,height);\n      if (mEdgeGlowBottom.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n  }\n}\n", "docstring": "todo : to be implemented", "partition": "test"}
{"idx": "60", "code": "public static ClassProperties loadProperties(Class[] cls,Properties properties,boolean inherit){\n  ClassProperties cp=new ClassProperties(properties);\n  for (  Class c : cls) {\n    cp.load(c,inherit);\n  }\n  return cp;\n}\n", "docstring": "for all the classes , loads all properties from each class annotations for the given platform .", "partition": "test"}
{"idx": "61", "code": "private static void fixGPSTimeStamp(XMPNode exifSchema) throws XMPException {\n  XMPNode gpsDateTime=XMPNodeUtils.findChildNode(exifSchema,\"exif:GPSTimeStamp\",false);\n  if (gpsDateTime == null) {\n    return;\n  }\n  try {\n    XMPDateTime binGPSStamp;\n    XMPDateTime binOtherDate;\n    binGPSStamp=XMPUtils.convertToDate(gpsDateTime.getValue());\n    if (binGPSStamp.getYear() != 0 || binGPSStamp.getMonth() != 0 || binGPSStamp.getDay() != 0) {\n      return;\n    }\n    XMPNode otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeOriginal\",false);\n    if (otherDate == null) {\n      otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeDigitized\",false);\n    }\n    binOtherDate=XMPUtils.convertToDate(otherDate.getValue());\n    Calendar cal=binGPSStamp.getCalendar();\n    cal.set(Calendar.YEAR,binOtherDate.getYear());\n    cal.set(Calendar.MONTH,binOtherDate.getMonth());\n    cal.set(Calendar.DAY_OF_MONTH,binOtherDate.getDay());\n    binGPSStamp=new XMPDateTimeImpl(cal);\n    gpsDateTime.setValue(XMPUtils.convertFromDate(binGPSStamp));\n  }\n catch (  XMPException e) {\n    return;\n  }\n}\n", "docstring": "fixes the gps timestamp in exif .", "partition": "test"}
{"idx": "62", "code": "protected boolean cellConsumesEventType(Cell<?> cell,String eventType){\n  Set<String> consumedEvents=cell.getConsumedEvents();\n  return consumedEvents != null && consumedEvents.contains(eventType);\n}\n", "docstring": "check if a cell consumes the specified event type .", "partition": "test"}
{"idx": "63", "code": "public int read() throws IOException {\n  int b0=fInputStream.read();\n  if (b0 > 0x80) {\n    throw new IOException(Localizer.getMessage(\"jsp.error.xml.invalidASCII\",Integer.toString(b0)));\n  }\n  return b0;\n}\n", "docstring": "read a single character . this method will block until a character is available , an i / o error occurs , or the end of the stream is reached . < p > subclasses that intend to support efficient single - character input should override this method .", "partition": "test"}
{"idx": "64", "code": "protected void create_y_axis(int i){\n  Log.e(\"index vlaue\",i + \"\");\n  float ver_height=((graphheight / label_size) * i) + border;\n  if (i == largest_value_set.size() - 1)   canvas.drawLine(horstart,ver_height,width - (border),ver_height,paint);\n else   canvas.drawLine(horstart,ver_height,border,ver_height,paint);\n  paint.setColor(Color.BLACK);\n  int Y_labels=(int)size - 1 - i;\n  String y_labels=String.format(\"%.1f\",Y_labels * y_axis_ratio);\n  paint.setTextAlign(Paint.Align.RIGHT);\n  canvas.drawText(y_labels,horstart - 15,ver_height - 10,paint);\n  paint.setTextAlign(Paint.Align.LEFT);\n}\n", "docstring": "this function is used to plot the y axis and its breakdown with value . uses drawline ( ) method to create the y axis and lines to show breakdown of y axis and drawtext ( ) method to plot labels related with breakdowns", "partition": "test"}
{"idx": "65", "code": "public long max(){\n  return deltaMax.get();\n}\n", "docstring": "get running - maximum time - delta , in nanoseconds .", "partition": "test"}
{"idx": "66", "code": "public void print(File file) throws IOException {\n  checkExec();\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPrintJobAccess();\n  }\n  checkActionSupport(Action.PRINT);\n  checkFileValidation(file);\n  peer.print(file);\n}\n", "docstring": "prints a file with the native desktop printing facility , using the associated application \"'\" s print command .", "partition": "test"}
{"idx": "67", "code": "public void extend(RuleGrounding other){\n  if (other.isFailed()) {\n    groundings.clear();\n    return;\n  }\n  extend(other.getAlternatives());\n}\n", "docstring": "extends the existing groundings with the alternative groundings", "partition": "test"}
{"idx": "68", "code": "@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern \'\" + pattern.pattern() + \"\' was not encountered in document: \"+ document);\n  }\n  return token;\n}\n", "docstring": "this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor . if failed to do so , the method will be expected to throw an exception or take corrective measures .", "partition": "test"}
{"idx": "69", "code": "public void testGetTableTypesOrder() throws Exception {\n  DatabaseMetaData dmd=con.getMetaData();\n  ResultSet rs=dmd.getTableTypes();\n  String previousType=\"\";\n  while (rs.next()) {\n    String type=rs.getString(1);\n    assertTrue(type.compareTo(previousType) >= 0);\n    previousType=type;\n  }\n  rs.close();\n}\n", "docstring": "test for bug [ 974036 ", "partition": "test"}
{"idx": "70", "code": "public void addParameters(final NameValuePair[] parameters){\n  LOG.trace(\"enter PostMethod.addParameters(NameValuePair[])\");\n  if (parameters == null) {\n    LOG.warn(\"Attempt to addParameters(null) ignored\");\n  }\n else {\n    super.clearRequestBody();\n    for (int i=0; i < parameters.length; i++) {\n      params.add(parameters[i]);\n    }\n  }\n}\n", "docstring": "adds an array of parameters to be used in the post request body . logs a warning if the parameters argument is null .", "partition": "test"}
{"idx": "71", "code": "@Pure public Atom annotationInterfaceToAnnotationClass(){\n  byte[] annotationClassName_tmp=new byte[val.length + 2];\n  System.arraycopy(val,0,annotationClassName_tmp,0,val.length - 1);\n  annotationClassName_tmp[val.length - 1]='$';\n  annotationClassName_tmp[val.length]='$';\n  annotationClassName_tmp[val.length + 1]=';';\n  return Atom.findOrCreateUtf8Atom(annotationClassName_tmp);\n}\n", "docstring": "creates an annotation name from a class name . for example lfoo . bar ; becomes lfoo . bar $ $ ; nb in sun vms the annotation name of the first annotation is $ proxy1 . classpath may later rely on this to implement serialization correctly .", "partition": "test"}
{"idx": "72", "code": "public boolean resourceSupportAR(Integer id){\n  if (id == null) {\n    return false;\n  }\n  return resourceSupportAR(id.intValue());\n}\n", "docstring": "checks whether a given resource id supports advanced reservations or not .", "partition": "test"}
{"idx": "73", "code": "public PatternGuardExpr(String namespace,String name,Expression[] parameters,PatternExpr guarded){\n  this(namespace,name,Arrays.asList(parameters),guarded);\n}\n", "docstring": "ctor - for use to create a pattern expression tree , without pattern child expression .", "partition": "test"}
{"idx": "74", "code": "public static int unixTimestamp(){\n  return (int)(System.currentTimeMillis() / 1000L);\n}\n", "docstring": "get the seconds since 1970 - 01 - 01 00 : 00 : 00 utc . see http : / / dev . mysql . com / doc / refman / 5 . 1 / en / date - and - time - functions . html # function_unix - timestamp", "partition": "test"}
{"idx": "75", "code": "public boolean isPDFLicense(){\n  String key=getSummary();\n  return key != null && key.length() > 25;\n}\n", "docstring": "is there a pdf license", "partition": "test"}
{"idx": "76", "code": "public ZipStreamImpl openReadImpl(PathImpl path) throws IOException {\n  String pathName=path.getPath();\n  return openReadImpl(pathName);\n}\n", "docstring": "opens a stream to an entry in the jar .", "partition": "test"}
{"idx": "77", "code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 112) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "docstring": "unpacks the compressed character translation table .", "partition": "test"}
{"idx": "78", "code": "@Override public void onTmpFilesCopied(ResultCode result){\n  dismissLoadingDialog();\n  finish();\n}\n", "docstring": "process the result of copyanduploadcontenturistask", "partition": "test"}
{"idx": "79", "code": "public synchronized OMGraphicList prepare(){\n  Projection projection=getProjection();\n  boolean DEBUG_FINE=logger.isLoggable(Level.FINE);\n  if (projection == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": prepare called with null projection\");\n    }\n    return new OMGraphicList();\n  }\n  if (spatialIndex == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": spatialIndex is null!\");\n    }\n    OMGraphicList list=getList();\n    if (list != null) {\n      list.generate(projection,true);\n      return list;\n    }\n else {\n      return new OMGraphicList();\n    }\n  }\n  Point2D ul=projection.getUpperLeft();\n  Point2D lr=projection.getLowerRight();\n  double ulLat=ul.getY();\n  double ulLon=ul.getX();\n  double lrLat=lr.getY();\n  double lrLon=lr.getX();\n  OMGraphicList list=new OMGraphicList();\n  if (ProjMath.isCrossingDateline(ulLon,lrLon,projection.getScale())) {\n    if (DEBUG_FINE) {\n      logger.fine(\"ShapeLayer.computeGraphics(): Dateline is on screen\");\n    }\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(ulLon,ymin,180.0d,ymax,list,drawingAttributes,projection,coordTransform);\n      list=spatialIndex.getOMGraphics(-180.0d,ymin,lrLon,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n else {\n    double xmin=Math.min(ulLon,lrLon);\n    double xmax=Math.max(ulLon,lrLon);\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(xmin,ymin,xmax,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    java.io.IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "create the omgraphics using the shape file and spatialindex .", "partition": "test"}
{"idx": "80", "code": "private boolean isFieldPackagePrivate(Element attribute){\n  Set<Modifier> modifiers=attribute.getModifiers();\n  return !modifiers.contains(PUBLIC) && !modifiers.contains(PROTECTED) && !modifiers.contains(PRIVATE);\n}\n", "docstring": "checks if the given field has package - private visibility", "partition": "test"}
{"idx": "81", "code": "public void testDivideRoundHalfUpPos(){\n  String a=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=-24;\n  String b=\"7472334223847623782375469293018787918347987234564568\";\n  int bScale=13;\n  String c=\"1.24390557635720517122423359799284E+53\";\n  int resScale=-21;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  BigDecimal result=aNumber.divide(bNumber,resScale,BigDecimal.ROUND_HALF_UP);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",resScale,result.scale());\n}\n", "docstring": "divide : rounding mode is round_half_up , result is positive ; distance = - 1", "partition": "test"}
{"idx": "82", "code": "public boolean reallyRestoreMsWordListFormatForUser(String userId,InputStreamReader streamReader,boolean isAdmin,Errors errors){\n  if (userId == null) {\n    Errors.add(errors,errorMessages.errorsUserIdIsNull());\n    return false;\n  }\n  if (streamReader == null) {\n    Errors.add(errors,errorMessages.errorsTheInputStreamReaderIsNull());\n    return false;\n  }\n  BufferedReader bf=new BufferedReader(streamReader);\n  final User user=getUserById(userId);\n  if (user == null) {\n    return false;\n  }\n  boolean createdAnyChildren=false;\n  try {\n    final long now=System.currentTimeMillis();\n    Entry notebook=createEntryNoteBook(user,\"Restored Notebook\",now,null,null,false,false,false,isAdmin,false,errors);\n    if (notebook == null) {\n      return false;\n    }\n    Entry root=getEntryById(notebook.getRootId());\n    ArrayList<Entry> parents=new ArrayList<Entry>();\n    HashMap<String,Integer> bulletToDepth=new HashMap<String,Integer>();\n    String line=null;\n    Integer previousDepth=0;\n    parents.add(root);\n    while ((line=bf.readLine()) != null) {\n      line=line.trim();\n      if (line.isEmpty()) {\n        continue;\n      }\n      String note=line;\n      Integer depth=1;\n      if (line.length() > 1 && line.charAt(1) == \'\\t\') {\n        String bullet=line.substring(0,1);\n        note=line.substring(2);\n        depth=bulletToDepth.get(bullet);\n        if (depth == null) {\n          depth=new Integer(bulletToDepth.size() + 1);\n          bulletToDepth.put(bullet,depth);\n        }\n        for (int i=parents.size(); i > depth.intValue(); --i) {\n          parents.remove(i - 1);\n        }\n        depth=new Integer(parents.size() + 1);\n      }\n else {\n        previousDepth=0;\n        while (parents.size() > 1) {\n          parents.remove(parents.size() - 1);\n        }\n      }\n      if (parents.isEmpty()) {\n        return false;\n      }\n      Entry parent=parents.get(parents.size() - 1);\n      Entry entry=createSimpleEntry(user,note,now,parent.getId(),TreeRelType.Parent,false,false,false,isAdmin,Constants.note,errors,null);\n      if (entry == null) {\n        return false;\n      }\n      if (previousDepth.intValue() != depth.intValue()) {\n        parents.add(entry);\n      }\n else {\n        parents.set(parents.size() - 1,entry);\n      }\n      createdAnyChildren=true;\n    }\n  }\n catch (  IOException e) {\n    Errors.add(errors,errorMessages.errorProblemReadingInput());\n  }\n  return createdAnyChildren;\n}\n", "docstring": "helper method . does all the real work for restoremswordlistformatforuser ( ) .", "partition": "test"}
{"idx": "83", "code": "public static String convertCodes(String string){\n  if (string == null)   return string;\n  int current=0;\n  char[] cs=string.toCharArray();\n  StringBuilder sb=new StringBuilder();\n  for (  char c : cs) {\n    if (current <= cs.length && c == \'&\') {\n      char tc=Character.toLowerCase(cs[current + 1]);\n      if (tc == \'1\' || tc == \'2\' || tc == \'3\' || tc == \'4\' || tc == \'5\' || tc == \'6\' || tc == \'7\' || tc == \'8\' || tc == \'9\' || tc == \'0\' || tc == \'a\' || tc == \'b\' || tc == \'c\' || tc == \'d\' || tc == \'e\' || tc == \'f\' || tc == \'k\' || tc == \'l\' || tc == \'m\' || tc == \'n\' || tc == \'o\') {\n        sb.append(\"\u00a7\");\n      }\n else {\n        sb.append(c);\n      }\n    }\n else {\n      sb.append(c);\n    }\n    current++;\n  }\n  return sb.toString();\n}\n", "docstring": "converts all color and format codes", "partition": "test"}
{"idx": "84", "code": "private void loadText(InputStream is){\n  BufferedReader reader;\n  String line;\n  unitList=new ArrayList();\n  unitTypesList=new ArrayList();\n  if (is == null) {\n    throw new Error(\"Can\'t load cluster db file.\");\n  }\n  reader=new BufferedReader(new InputStreamReader(is));\n  try {\n    line=reader.readLine();\n    lineCount++;\n    while (line != null) {\n      if (!line.startsWith(\"***\")) {\n        parseAndAdd(line,reader);\n      }\n      line=reader.readLine();\n    }\n    reader.close();\n    units=new DatabaseClusterUnit[unitList.size()];\n    units=(DatabaseClusterUnit[])unitList.toArray(units);\n    unitList=null;\n    unitTypes=new UnitType[unitTypesList.size()];\n    unitTypes=(UnitType[])unitTypesList.toArray(unitTypes);\n    unitTypesList=null;\n  }\n catch (  IOException e) {\n    throw new Error(e.getMessage() + \" at line \" + lineCount);\n  }\n finally {\n  }\n}\n", "docstring": "loads the database from the given input stream .", "partition": "test"}
{"idx": "85", "code": "private int measureWidth(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)mTextPaint.measureText(mText) + getPaddingLeft() + getPaddingRight();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "docstring": "determines the width of this view", "partition": "test"}
{"idx": "86", "code": "public void test_getPutByteArray(){\n  final int capacity=200;\n  final ByteArrayBuffer buf=new ByteArrayBuffer(capacity);\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(capacity - 1));\n  final int pos=1;\n  for (int i=0; i < LIMIT; i++) {\n    final byte[] expected=new byte[r.nextInt(capacity - 2)];\n    r.nextBytes(expected);\n    buf.put(pos,expected);\n    assertEquals(0,BytesUtil.compareBytesWithLenAndOffset(0,expected.length,expected,pos,expected.length,buf.array()));\n    final byte[] actual=new byte[expected.length];\n    buf.get(pos,actual);\n    assertTrue(BytesUtil.bytesEqual(expected,actual));\n  }\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(pos + capacity - 2));\n}\n", "docstring": "test bulk get / put byte [ ", "partition": "test"}
{"idx": "87", "code": "@Override public void onAdded(final RPObject object){\n  if (isUser(object)) {\n    if (object.has(\"adminlevel\")) {\n      adminlevel=object.getInt(\"adminlevel\");\n    }\n  }\n}\n", "docstring": "an object was added .", "partition": "test"}
{"idx": "88", "code": "private String local_number() throws ParseException {\n  StringBuilder s=new StringBuilder();\n  if (debug)   dbg_enter(\"local_number\");\n  try {\n    int lc=0;\n    while (lexer.hasMoreChars()) {\n      char la=lexer.lookAhead(0);\n      if (la == \'*\' || la == \'#\' || la == \'-\' || la == \'.\' || la == \'(\' || la == \')\' || Lexer.isHexDigit(la)) {\n        lexer.consume(1);\n        s.append(la);\n        lc++;\n      }\n else       if (lc > 0)       break;\n else       throw createParseException(\"unexepcted \" + la);\n    }\n    return s.toString();\n  }\n  finally {\n    if (debug)     dbg_leave(\"local_number\");\n  }\n}\n", "docstring": "parser for the local phone # .", "partition": "test"}
{"idx": "89", "code": "public static void slideInFromTopAnimator(@NonNull List<Animator> animators,@NonNull View view,RecyclerView recyclerView){\n  alphaAnimator(animators,view,0f);\n  animators.add(ObjectAnimator.ofFloat(view,\"translationY\",-recyclerView.getMeasuredHeight() >> 1,0));\n  if (FlexibleAdapter.DEBUG)   Log.v(TAG,\"Added TOP Animator\");\n}\n", "docstring": "item will slide from top of the screen to its natural position .", "partition": "test"}
{"idx": "90", "code": "MutableBigInteger(MutableBigInteger val){\n  intLen=val.intLen;\n  value=Arrays.copyOfRange(val.value,val.offset,val.offset + intLen);\n}\n", "docstring": "construct a new mutablebiginteger with a magnitude equal to the specified mutablebiginteger .", "partition": "test"}
{"idx": "91", "code": "@RequestMapping(value=\"/SAML2/IDPSSO/{tenant:.*}\") public void ssoBindingError(Locale locale,@PathVariable(value=\"tenant\") String tenant,HttpServletResponse response) throws IOException {\n  logger.info(\"IDP SSO binding error! The client locale is \" + locale.toString() + \", tenant is \"+ tenant);\n  ssoDefaultTenantError(locale,response);\n}\n", "docstring": "handle request sent with a wrong binding", "partition": "test"}
{"idx": "92", "code": "public CheckpointManager(NetworkParameters params,@Nullable InputStream inputStream) throws IOException {\n  this.params=checkNotNull(params);\n  if (inputStream == null)   inputStream=openStream(params);\n  checkNotNull(inputStream);\n  inputStream=new BufferedInputStream(inputStream);\n  inputStream.mark(1);\n  int first=inputStream.read();\n  inputStream.reset();\n  if (first == BINARY_MAGIC.charAt(0))   dataHash=readBinary(inputStream);\n else   if (first == TEXTUAL_MAGIC.charAt(0))   dataHash=readTextual(inputStream);\n else   throw new IOException(\"Unsupported format.\");\n}\n", "docstring": "loads the checkpoints from the given stream", "partition": "test"}
{"idx": "93", "code": "public IndexSegmentIndex(IRawStore store,Checkpoint checkpoint,IndexMetadata metadata,boolean readOnly){\n  super(store,checkpoint,metadata,readOnly);\n}\n", "docstring": "load from the store .", "partition": "test"}
{"idx": "94", "code": "private String liveness(){\n  boolean isClosed=false;\n  try {\n    if (isClosed()) {\n      isClosed=true;\n    }\n  }\n catch (  SQLException s) {\n    isClosed=true;\n  }\n  if (isClosed) {\n    return \"CLOSED\";\n  }\n  return \"OPEN\";\n}\n", "docstring": "provides a string representation of whether this connection is closed or not", "partition": "test"}
{"idx": "95", "code": "private static void insertValue(final Map<String,List<String>> paramsMap,final String paramVal,final String parameterName){\n  if (paramVal != null) {\n    List<String> list=new ArrayList<>();\n    list.add(paramVal);\n    paramsMap.put(parameterName,list);\n  }\n}\n", "docstring": "puts the given parameter value into a new list object then adds it to the map .", "partition": "test"}
{"idx": "96", "code": "public Dimension minimumLayoutSize(Container target){\n  Dimension size;\nsynchronized (this) {\n    checkContainer(target);\n    checkRequests();\n    size=new Dimension(xTotal.minimum,yTotal.minimum);\n  }\n  Insets insets=target.getInsets();\n  size.width=(int)Math.min((long)size.width + (long)insets.left + (long)insets.right,Integer.MAX_VALUE);\n  size.height=(int)Math.min((long)size.height + (long)insets.top + (long)insets.bottom,Integer.MAX_VALUE);\n  return size;\n}\n", "docstring": "returns the minimum dimensions needed to lay out the components contained in the specified target container .", "partition": "test"}
{"idx": "97", "code": "private static void solve_l2r_l1l2_svr(Problem prob,double[] w,Parameter param){\n  int l=prob.l;\n  double C=param.C;\n  double p=param.p;\n  int w_size=prob.n;\n  double eps=param.eps;\n  int i, s, iter=0;\n  int max_iter=param.getMaxIters();\n  int active_size=l;\n  int[] index=new int[l];\n  double d, G, H;\n  double Gmax_old=Double.POSITIVE_INFINITY;\n  double Gmax_new, Gnorm1_new;\n  double Gnorm1_init=-1.0;\n  double[] beta=new double[l];\n  double[] QD=new double[l];\n  double[] y=prob.y;\n  double[] lambda=new double[]{0.5 / C};\n  double[] upper_bound=new double[]{Double.POSITIVE_INFINITY};\n  if (param.solverType == SolverType.L2R_L1LOSS_SVR_DUAL) {\n    lambda[0]=0;\n    upper_bound[0]=C;\n  }\n  for (i=0; i < l; i++)   beta[i]=0;\n  for (i=0; i < w_size; i++)   w[i]=0;\n  for (i=0; i < l; i++) {\n    QD[i]=0;\n    for (    Feature xi : prob.x[i]) {\n      double val=xi.getValue();\n      QD[i]+=val * val;\n      w[xi.getIndex() - 1]+=beta[i] * val;\n    }\n    index[i]=i;\n  }\n  while (iter < max_iter) {\n    Gmax_new=0;\n    Gnorm1_new=0;\n    for (i=0; i < active_size; i++) {\n      int j=i + random.nextInt(active_size - i);\n      swap(index,i,j);\n    }\n    for (s=0; s < active_size; s++) {\n      i=index[s];\n      G=-y[i] + lambda[GETI_SVR(i)] * beta[i];\n      H=QD[i] + lambda[GETI_SVR(i)];\n      for (      Feature xi : prob.x[i]) {\n        int ind=xi.getIndex() - 1;\n        double val=xi.getValue();\n        G+=val * w[ind];\n      }\n      double Gp=G + p;\n      double Gn=G - p;\n      double violation=0;\n      if (beta[i] == 0) {\n        if (Gp < 0)         violation=-Gp;\n else         if (Gn > 0)         violation=Gn;\n else         if (Gp > Gmax_old && Gn < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] >= upper_bound[GETI_SVR(i)]) {\n        if (Gp > 0)         violation=Gp;\n else         if (Gp < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] <= -upper_bound[GETI_SVR(i)]) {\n        if (Gn < 0)         violation=-Gn;\n else         if (Gn > Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] > 0)       violation=Math.abs(Gp);\n else       violation=Math.abs(Gn);\n      Gmax_new=Math.max(Gmax_new,violation);\n      Gnorm1_new+=violation;\n      if (Gp < H * beta[i])       d=-Gp / H;\n else       if (Gn > H * beta[i])       d=-Gn / H;\n else       d=-beta[i];\n      if (Math.abs(d) < 1.0e-12)       continue;\n      double beta_old=beta[i];\n      beta[i]=Math.min(Math.max(beta[i] + d,-upper_bound[GETI_SVR(i)]),upper_bound[GETI_SVR(i)]);\n      d=beta[i] - beta_old;\n      if (d != 0) {\n        for (        Feature xi : prob.x[i]) {\n          w[xi.getIndex() - 1]+=d * xi.getValue();\n        }\n      }\n    }\n    if (iter == 0)     Gnorm1_init=Gnorm1_new;\n    iter++;\n    if (iter % 10 == 0)     info(\".\");\n    if (Gnorm1_new <= eps * Gnorm1_init) {\n      if (active_size == l)       break;\n else {\n        active_size=l;\n        info(\"*\");\n        Gmax_old=Double.POSITIVE_INFINITY;\n        continue;\n      }\n    }\n    Gmax_old=Gmax_new;\n  }\n  info(\"%noptimization finished, #iter = %d%n\",iter);\n  if (iter >= max_iter)   info(\"%nWARNING: reaching max number of iterations%nUsing -s 11 may be faster%n%n\");\n  double v=0;\n  int nSV=0;\n  for (i=0; i < w_size; i++)   v+=w[i] * w[i];\n  v=0.5 * v;\n  for (i=0; i < l; i++) {\n    v+=p * Math.abs(beta[i]) - y[i] * beta[i] + 0.5 * lambda[GETI_SVR(i)] * beta[i]* beta[i];\n    if (beta[i] != 0)     nSV++;\n  }\n  info(\"Objective value = %g%n\",v);\n  info(\"nSV = %d%n\",nSV);\n}\n", "docstring": "a coordinate descent algorithm for l1 - loss and l2 - loss epsilon - svr dual problem min_ \\ beta 0 . 5 \\ beta ^ t ( q + diag ( lambda ) ) \\ beta - p \\ sum_ { i = 1 } ^ l | \\ beta_i | + \\ sum_ { i = 1 } ^ l yi \\ beta_i , s . t . - upper_bound_i < = \\ beta_i < = upper_bound_i , where qij = xi ^ t xj and d is a diagonal matrix in l1 - svm case : upper_bound_i = c lambda_i = 0 in l2 - svm case : upper_bound_i = inf lambda_i = 1 / ( 2 * c ) given : x , y , p , c eps is the stopping tolerance solution will be put in w see algorithm 4 of ho and lin , 2012", "partition": "test"}
{"idx": "98", "code": "public boolean select(int position){\n  View v=mAllList.get(position);\n  if (mMultiChoiceAdapter != null) {\n    performVibrate();\n    performSelect(v,position,true);\n    return true;\n  }\n  return false;\n}\n", "docstring": "select a view from position in the adapter", "partition": "test"}
{"idx": "99", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.addElement(new Option(\"\\tUse double precision format.\\n\" + \"\\t(default: single precision)\",\"double\",0,\"-double\"));\n  result.addElement(new Option(\"\\tUse tabs as separator.\\n\" + \"\\t(default: blanks)\",\"tabs\",0,\"-tabs\"));\n  result.addAll(Collections.list(super.listOptions()));\n  return result.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "100", "code": "@Override public void ignorableWhitespace(XMLString text,Augmentations augs) throws XNIException {\n  if (!fIncludeIgnorableWhitespace || fFilterReject) {\n    return;\n  }\n  if (!fDeferNodeExpansion) {\n    Node child=fCurrentNode.getLastChild();\n    if (child != null && child.getNodeType() == Node.TEXT_NODE) {\n      Text textNode=(Text)child;\n      textNode.appendData(text.toString());\n    }\n else {\n      Text textNode=fDocument.createTextNode(text.toString());\n      if (fDocumentImpl != null) {\n        TextImpl textNodeImpl=(TextImpl)textNode;\n        textNodeImpl.setIgnorableWhitespace(true);\n      }\n      fCurrentNode.appendChild(textNode);\n    }\n  }\n else {\n    int txt=fDeferredDocumentImpl.createDeferredTextNode(text.toString(),true);\n    fDeferredDocumentImpl.appendChild(fCurrentNodeIndex,txt);\n  }\n}\n", "docstring": "ignorable whitespace . for this method to be called , the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable . for example , the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model .", "partition": "test"}
{"idx": "101", "code": "private static final void waitForEditorToBeActive(IEditorPart internalFileEditor,IWorkbenchPage page){\n  long start=System.currentTimeMillis();\n  long end=start;\n  do {\n    end=System.currentTimeMillis();\n  }\n while (page.getActiveEditor() != internalFileEditor && (end - start) < 5000);\n  if (page.getActiveEditor() != internalFileEditor)   logger.warn(\"selected editor was not activated within timout\");\n}\n", "docstring": "get editor for provided file , returns once editor is active or after timeout", "partition": "test"}
{"idx": "102", "code": "private Solution largestObjectiveValue(int objective,Population population){\n  Solution largest=null;\n  double value=Double.NEGATIVE_INFINITY;\n  for (  Solution solution : population) {\n    if (solution.getObjective(objective) > value) {\n      largest=solution;\n      value=solution.getObjective(objective);\n    }\n  }\n  return largest;\n}\n", "docstring": "returns the solution with the largest objective value for the given objective .", "partition": "test"}
{"idx": "103", "code": "public static int convertLatmToY(int latm){\n  long v=Math.round((Mercator.MAX_Y - Mercator.lat2y(latm / LATLON_TO_LATLONM)) * MAX_AP_UNITS / (Mercator.MAX_Y * 2));\n  if (v > MAX_AP_UNITS)   return MAX_AP_UNITS;\n  if (v < 0)   return -1;\n  return (int)v;\n}\n", "docstring": "returns the y position based on latitude . note that this is based of mercator which will have infinite number of points approaching + / - 90 degrees . so if we are out of range , ( beyond the configured min / max latitude ) , we return - 1 and max_ap_units based on which direction we are out", "partition": "test"}
{"idx": "104", "code": "public void registerCallbackHandler(SMSObjectListener changeListener) throws SMSException {\n  objectListener=changeListener;\n  if (!notificationInitialized) {\n    String notificationFlag=SystemProperties.get(NOTIFICATION_PROPERTY,\"true\");\n    if (notificationFlag.equalsIgnoreCase(\"true\")) {\n      try {\n        URL url=WebtopNaming.getNotificationURL();\n        PLLClient.addNotificationHandler(JAXRPCUtil.SMS_SERVICE,new SMSNotificationHandler());\n        client.send(\"registerNotificationURL\",url.toString(),null,null);\n        if (debug.messageEnabled()) {\n          debug.message(\"SMSJAXRPCObject: Using \" + \"notification mechanism for cache updates: \" + url);\n        }\n      }\n catch (      Exception e) {\n        if (debug.warningEnabled()) {\n          debug.warning(\"SMSJAXRPCObject: Registering for \" + \"notification via URL failed: \" + e.getMessage() + \"\\nUsing polling mechanism for updates\");\n        }\n        startPollingThreadIfEnabled(getCachePollingInterval());\n      }\n    }\n else {\n      startPollingThreadIfEnabled(getCachePollingInterval());\n    }\n    notificationInitialized=true;\n  }\n}\n", "docstring": "registration for event change notifications . only smsnotificationmanager would be calling this method to register itself", "partition": "test"}
{"idx": "105", "code": "protected double currentScoreFunction(){\n  double score=0.;\n  for (int i=0; i < this.values[this.currentVar1].length; i++) {\n    for (int j=0; j < this.values[this.currentVar2].length; j++) {\n      score-=this.currentCounts[this.currentVar1][this.currentVar2][i][j] * Math.log(this.currentPi[i][j]);\n    }\n  }\n  return score;\n}\n", "docstring": "function to be minimized : - loglikelihood . it * is * assumed that computefibuffer and computecurrentpi were called before this method .", "partition": "test"}
{"idx": "106", "code": "public grammaticalityEstimator(Set FileNames,int iMinChar,int iMaxChar,int iCharWindow,int iMinWord,int iMaxWord,int iWordWindow){\n  iMinCharNGram=iMinChar;\n  iMaxCharNGram=iMaxChar;\n  iMinWordNGram=iMinWord;\n  iMaxWordNGram=iMaxWord;\n  iWordDist=iWordWindow;\n  iCharDist=iCharWindow;\n  DistroDocs=new TreeMap<Integer,DistributionDocument>();\n  DistroWordDocs=new TreeMap<Integer,DistributionWordDocument>();\n  StringBuffer sb=new StringBuffer();\n  Iterator iTexts=FileNames.iterator();\n  while (iTexts.hasNext()) {\n    String sFile=(String)iTexts.next();\n    try {\n      BufferedReader bf=new BufferedReader(new FileReader(sFile));\n      String sTmp;\n      while ((sTmp=bf.readLine()) != null)       sb.append(sTmp);\n      bf.close();\n    }\n catch (    FileNotFoundException ex) {\n      ex.printStackTrace(System.err);\n    }\ncatch (    IOException ex) {\n      ex.printStackTrace(System.err);\n    }\n    sb.append((char)0);\n  }\n  FullTextDataString=sb.toString();\n  for (int iCnt=iMinCharNGram; iCnt <= iMaxCharNGram; iCnt++) {\n    DistroDocs.put(iCnt,new DistributionDocument(iCharDist,iCnt));\n  }\n  for (int iCnt=iMinWordNGram; iCnt <= iMaxWordNGram; iCnt++) {\n    DistroWordDocs.put(iCnt,new DistributionWordDocument(iWordDist,iCnt));\n  }\n}\n", "docstring": "creates a new instance of grammaticalityestimator , using a given set of documents for training .", "partition": "test"}
{"idx": "107", "code": "private int checkZoneLink(SpannableStringBuilder out,String in,int start){\n  int pos=start + 3;\n  StringBuilder temp=new StringBuilder();\n  String targetString=in.substring(pos,Math.min(in.length(),pos + 20));\n  boolean prevIsDash=false;\n  for (int i=0; i < targetString.length(); i++) {\n    char c=targetString.charAt(i);\n    if ((c >= \'a\' && c <= \'z\') || (c >= \'0\' && c <= \'9\')) {\n      temp.append(c);\n      prevIsDash=false;\n    }\n else     if (c == \'-\') {\n      if (i == 0) {\n        return -1;\n      }\n      if (prevIsDash) {\n        temp.deleteCharAt(temp.length() - 1);\n        break;\n      }\n      temp.append(c);\n      prevIsDash=true;\n    }\n else {\n      if (prevIsDash) {\n        temp.deleteCharAt(temp.length() - 1);\n      }\n      break;\n    }\n  }\n  String zone=temp.toString();\n  if (zone.length() < 3 || zone.equalsIgnoreCase(\"null\")) {\n    return -1;\n  }\n  out.append(zone);\n  return pos + zone.length() - 1;\n}\n", "docstring": "change this should review zone . java", "partition": "test"}
{"idx": "108", "code": "public void checkNextPoissonConsistency(double mean){\n  final int sampleSize=1000;\n  final int minExpectedCount=7;\n  long maxObservedValue=0;\n  final double alpha=0.001;\n  UnitTestUtils.Frequency<Long> frequency=new UnitTestUtils.Frequency<Long>();\n  for (int i=0; i < sampleSize; i++) {\n    long value=randomData.nextPoisson(mean);\n    if (value > maxObservedValue) {\n      maxObservedValue=value;\n    }\n    frequency.addValue(value);\n  }\n  PoissonDistribution poissonDistribution=new PoissonDistribution(mean);\n  int lower=1;\n  while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n    lower++;\n  }\n  int upper=(int)(5 * mean);\n  while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n    upper--;\n  }\n  int binWidth=0;\n  boolean widthSufficient=false;\n  double lowerBinMass=0;\n  double upperBinMass=0;\n  while (!widthSufficient) {\n    binWidth++;\n    lowerBinMass=poissonDistribution.probability(lower - 1,lower + binWidth - 1);\n    upperBinMass=poissonDistribution.probability(upper - binWidth - 1,upper - 1);\n    widthSufficient=FastMath.min(lowerBinMass,upperBinMass) * sampleSize >= minExpectedCount;\n  }\n  List<Integer> binBounds=new ArrayList<Integer>();\n  binBounds.add(lower);\n  int bound=lower + binWidth;\n  while (bound < upper - binWidth) {\n    binBounds.add(bound);\n    bound+=binWidth;\n  }\n  binBounds.add(upper);\n  final int binCount=binBounds.size() + 1;\n  long[] observed=new long[binCount];\n  double[] expected=new double[binCount];\n  observed[0]=0;\n  for (int i=0; i < lower; i++) {\n    observed[0]+=frequency.getCount((long)i);\n  }\n  expected[0]=poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n  observed[binCount - 1]=0;\n  for (int i=upper; i <= maxObservedValue; i++) {\n    observed[binCount - 1]+=frequency.getCount((long)i);\n  }\n  expected[binCount - 1]=(1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n  for (int i=1; i < binCount - 1; i++) {\n    observed[i]=0;\n    for (int j=binBounds.get(i - 1); j < binBounds.get(i); j++) {\n      observed[i]+=frequency.getCount((long)j);\n    }\n    expected[i]=(poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) - poissonDistribution.cumulativeProbability(binBounds.get(i - 1) - 1)) * sampleSize;\n  }\n  if (UnitTestUtils.chiSquareTest(expected,observed) < alpha) {\n    StringBuilder msgBuffer=new StringBuilder();\n    DecimalFormat df=new DecimalFormat(\"#.##\");\n    msgBuffer.append(\"Chisquare test failed for mean = \");\n    msgBuffer.append(mean);\n    msgBuffer.append(\" p-value = \");\n    msgBuffer.append(UnitTestUtils.chiSquareTest(expected,observed));\n    msgBuffer.append(\" chisquare statistic = \");\n    msgBuffer.append(UnitTestUtils.chiSquare(expected,observed));\n    msgBuffer.append(\". \\n\");\n    msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n    for (int i=0; i < expected.length; i++) {\n      msgBuffer.append(\"[\");\n      msgBuffer.append(i == 0 ? 1 : binBounds.get(i - 1));\n      msgBuffer.append(\",\");\n      msgBuffer.append(i == binBounds.size() ? \"inf\" : binBounds.get(i));\n      msgBuffer.append(\")\");\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(df.format(expected[i]));\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(observed[i]);\n      msgBuffer.append(\"\\n\");\n    }\n    msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n    msgBuffer.append(alpha);\n    msgBuffer.append(\".\");\n    Assert.fail(msgBuffer.toString());\n  }\n}\n", "docstring": "verifies that nextpoisson ( mean ) generates an empirical distribution of values consistent with poissondistributionimpl by generating 1000 values , computing a grouped frequency distribution of the observed values and comparing this distribution to the corresponding expected distribution computed using poissondistributionimpl . uses chisquare test of goodness of fit to evaluate the null hypothesis that the distributions are the same . if the null hypothesis can be rejected with confidence 1 - alpha , the check fails .", "partition": "test"}
{"idx": "109", "code": "public static void checkValid(double[] x){\n  for (  double v : x) {\n    if (Double.isNaN(v)) {\n      throw new RuntimeException(\"Invalid entry \" + v);\n    }\n  }\n}\n", "docstring": "loop and ensure all elements are non - infiite and non - nan , throws an exception if one is", "partition": "test"}
{"idx": "110", "code": "protected void processConnectionEvent(ConnectionEvent event){\n  for (Enumeration<ConnectionListener> e=connectionListeners.elements(); e.hasMoreElements(); ) {\n    ConnectionListener l=e.nextElement();\nswitch (event.getType()) {\ncase ConnectionEvent.CONNECTED:\n      l.connected((ConnectedEvent)event);\n    break;\ncase ConnectionEvent.DISCONNECTED:\n  l.disconnected((DisconnectedEvent)event);\nbreak;\ncase ConnectionEvent.PACKET_RECEIVED:\nl.packetReceived((PacketReceivedEvent)event);\nbreak;\n}\n}\n}\n", "docstring": "processes game events occurring on this connection by dispatching them to any registered gamelistener objects .", "partition": "test"}
{"idx": "111", "code": "public double percentage(ConstantRange range){\n  SortedSet<Constant> sorted=values();\n  SortedSet<Constant> contained=new TreeSet<Constant>();\n  Constant prev=null;\n  for (  Constant pct : sorted) {\n    if (range.contains(pct))     contained.add(pct);\n else     if (contained.isEmpty())     prev=pct;\n  }\n  if (contained.size() == 0)   return 0.0;\n  double prevPercent=prev == null ? 0.0 : pcts.get(prev);\n  return pcts.get(contained.last()) - prevPercent;\n}\n", "docstring": "gets the percent of values within the specified value range .", "partition": "test"}
{"idx": "112", "code": "public static void closeQuiet(@Nullable Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    IOException ignored) {\n    }\n  }\n}\n", "docstring": "closes resource without reporting any error .", "partition": "test"}
{"idx": "113", "code": "@Override public void releaseLuceePageContext(PageContext pc,boolean register){\n  if (pc.getId() < 0)   return;\n  pc.release();\n  ThreadLocalPageContext.release();\n  runningPcs.remove(Integer.valueOf(pc.getId()));\n  if (pcs.size() < 100 && pc.getRequestTimeoutException() == null)   pcs.push(pc);\n}\n", "docstring": "similar to the releasepagecontext method , but take lucee pagecontext as entry", "partition": "test"}
{"idx": "114", "code": "private static byte[] stringToByteArray(String str){\n  if (str == null) {\n    return null;\n  }\n  byte[] srcByte=str.getBytes();\n  int srcLength=srcByte.length;\n  byte[] result=new byte[srcLength + 1];\n  System.arraycopy(srcByte,0,result,0,srcLength);\n  result[srcLength]=0;\n  return result;\n}\n", "docstring": "returns this java string as a null - terminated byte array", "partition": "test"}
{"idx": "115", "code": "public static Properties loadProperties(ClassLoader classLoader,String classpathResource){\n  return loadProperties(null,classpathResource);\n}\n", "docstring": "atomically load the properties file at the given location within the designated class loader .", "partition": "test"}
{"idx": "116", "code": "@Override public boolean equals(Object o){\n  if (o instanceof Graph) {\n    return string.equals(o.toString());\n  }\n  return false;\n}\n", "docstring": "returns true if the object is a graph with the same content .", "partition": "test"}
{"idx": "117", "code": "public final static NameValuePair parseNameValuePair(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=SaveHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  SaveParserCursor cursor=new SaveParserCursor(0,value.length());\n  return parser.parseNameValuePair(buffer,cursor);\n}\n", "docstring": "parses a name - value - pair with the given parser .", "partition": "test"}
{"idx": "118", "code": "private static MappingObject ObjectAt(PCalLocation loc,MappingObject[][] map){\n  return map[loc.getLine()][loc.getColumn()];\n}\n", "docstring": "returns the mappingobject at the location in map indicated by loc .", "partition": "test"}
{"idx": "119", "code": "public String parse(File file,JSON m){\n  try {\n    Template template=getTemplate(file);\n    if (template != null) {\n      StringWriter w=new StringWriter();\n      BufferedWriter writer=new BufferedWriter(w);\n      template.merge(new VelocityContext(m),writer);\n      writer.flush();\n      writer.close();\n      return w.toString();\n    }\n  }\n catch (  Exception e) {\n    log.error(e.getMessage(),e);\n  }\n  return null;\n}\n", "docstring": "parse the file to string with the json", "partition": "test"}
{"idx": "120", "code": "public Repository(String domain,boolean fairLock){\n  lock=new ReentrantReadWriteLock(fairLock);\n  domainTb=new HashMap<String,Map<String,NamedObject>>(5);\n  if (domain != null && domain.length() != 0)   this.domain=domain.intern();\n else   this.domain=ServiceName.DOMAIN;\n  domainTb.put(this.domain,new HashMap<String,NamedObject>());\n}\n", "docstring": "construct a new repository with the given default domain .", "partition": "test"}
{"idx": "121", "code": "public static synchronized void indexDocument(CodeIndexDocument codeIndexDocument) throws IOException {\n  Queue<CodeIndexDocument> queue=new ConcurrentLinkedQueue<>();\n  queue.add(codeIndexDocument);\n  indexDocuments(queue);\n  queue=null;\n}\n", "docstring": "possibly better in ultra low memory environments ? reuses the above method by creating a queue with one element and passes it in .", "partition": "test"}
{"idx": "122", "code": "private void updateVolumeLabels(Volume trustedSrc,Volume invalidTgt){\n  VirtualArray invalidTgtVA=dbClient.queryObject(VirtualArray.class,invalidTgt.getVirtualArray());\n  StringBuilder newLabel=new StringBuilder();\n  newLabel.append(trustedSrc.getLabel());\n  newLabel.append(\"-target-\");\n  newLabel.append(invalidTgtVA.getLabel());\n  log.info(\"Revised name for target: \" + newLabel.toString());\n  invalidTgt.setLabel(newLabel.toString());\n  NamedURI projectURI=invalidTgt.getProject();\n  projectURI.setName(newLabel.toString());\n  invalidTgt.setProject(projectURI);\n  NamedURI tenantURI=invalidTgt.getTenant();\n  tenantURI.setName(newLabel.toString());\n  invalidTgt.setTenant(tenantURI);\n  Volume tgtVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,invalidTgt);\n  if (tgtVplexVolume != null) {\n    Volume srcVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,trustedSrc);\n    if (srcVplexVolume != null) {\n      newLabel.setLength(0);\n      newLabel.append(srcVplexVolume.getLabel());\n      newLabel.append(\"-target-\");\n      newLabel.append(invalidTgtVA.getLabel());\n      log.info(\"Revised name for VPlex target: \" + newLabel.toString());\n      tgtVplexVolume.setLabel(newLabel.toString());\n      projectURI=tgtVplexVolume.getProject();\n      projectURI.setName(newLabel.toString());\n      tgtVplexVolume.setProject(projectURI);\n      tenantURI=tgtVplexVolume.getTenant();\n      tenantURI.setName(newLabel.toString());\n      tgtVplexVolume.setTenant(tenantURI);\n      dbClient.updateAndReindexObject(tgtVplexVolume);\n    }\n  }\n}\n", "docstring": "updates the label field of the invalidtgt , and if the volume is fronted by a vplex volume , also updates the target vplex volume label .", "partition": "test"}
{"idx": "123", "code": "protected void handle(Exception exception,String title,String message){\n  Utils.handleError(getShell(),exception,title,message);\n}\n", "docstring": "shows the given errors to the user .", "partition": "test"}
{"idx": "124", "code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n  in.defaultReadObject();\n  i18n=Environment.getI18n();\n  beanContextChildSupport=new BeanContextChildSupport(this);\n}\n", "docstring": "handle serialization a little bit better , replacing the i18n and beancontextchildsupport .", "partition": "test"}
{"idx": "125", "code": "private void paintForegroundEnabled(Graphics2D g,int width,int height){\n  Shape s=decodeArrowPath(width,height);\n  g.setPaint(enabledColor);\n  g.fill(s);\n}\n", "docstring": "paint the arrow in enabled state .", "partition": "test"}
{"idx": "126", "code": "public boolean allowsTrailingArguments(){\n  return allowsTrailingArguments;\n}\n", "docstring": "indicates whether this sub - command will allow unnamed trailing arguments . these will be arguments at the end of the list that are not preceded by either a long or short identifier and will need to be manually parsed by the application using this parser . note that once an unnamed trailing argument has been identified , all remaining arguments will be classified as such .", "partition": "test"}
{"idx": "127", "code": "private void evaluatePopup(MouseEvent e){\n  if (e.isPopupTrigger()) {\n    JPopupMenu menu=createBookmarkPopupMenu();\n    if (menu != null) {\n      menu.show(this,e.getX(),e.getY());\n    }\n  }\n}\n", "docstring": "checks if the given mouse event is a popup trigger and creates a new popup menu if necessary .", "partition": "test"}
{"idx": "128", "code": "private boolean removeTask(Task t,int min){\n  for (int i=tasks.size(); --i >= min; ) {\n    if (tasks.get(i) == t) {\n      tasks.remove(i);\n      if (i < firstPending) {\n        firstPending--;\n        for (int j=threads.size(); --j >= 0; ) {\n          TaskThread thread=threads.get(j);\n          if (thread.task == t) {\n            if (thread != Thread.currentThread())             thread.interrupt();\n            break;\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "remove a task if it has index > = min . if it is active and not being executed by the calling thread , interrupt the thread executing the task .", "partition": "test"}
{"idx": "129", "code": "protected void ensurePathExists(String path){\n  String[] paths=path.split(\"/\");\n  StringBuffer spath=new StringBuffer(\"/\");\n  for (  String temp : paths) {\n    if (StringUtils.isBlank(temp)) {\n      continue;\n    }\n    spath.append(temp);\n    ensureExists(spath.toString(),null,acl,CreateMode.PERSISTENT);\n    spath.append(\"/\");\n  }\n}\n", "docstring": "ensures that the given path exists with no data , the current acl and no flags", "partition": "test"}
{"idx": "130", "code": "public Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {\n  int i=name.lastIndexOf('.');\n  if (i != -1) {\n    SecurityManager sm=System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPackageAccess(name.substring(0,i));\n    }\n  }\n  if (ucp.knownToNotExist(name)) {\n    Class<?> c=findLoadedClass(name);\n    if (c != null) {\n      if (resolve) {\n        resolveClass(c);\n      }\n      return c;\n    }\n    throw new ClassNotFoundException(name);\n  }\n  return (super.loadClass(name,resolve));\n}\n", "docstring": "override loadclass so we can checkpackageaccess .", "partition": "test"}
{"idx": "131", "code": "Rules(Workspace workspace){\n  this.root=workspace.getRoot();\n  this.teamHook=workspace.getTeamHook();\n}\n", "docstring": "creates a new scheduling rule factory for the given workspace", "partition": "test"}
{"idx": "132", "code": "public void add(@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(items.size());\n  }\n}\n", "docstring": "adds the specified item to the end of the list", "partition": "test"}
{"idx": "133", "code": "private void checkPendingCustomMessages(){\n  if (joiningNodes.isEmpty() && isLocalNodeCoordinator()) {\n    TcpDiscoveryCustomEventMessage msg;\n    while ((msg=pendingCustomMsgs.poll()) != null) {\n      processCustomMessage(msg);\n      if (msg.verified())       msgHist.add(msg);\n    }\n  }\n}\n", "docstring": "checks and flushes custom event messages if no nodes are attempting to join the grid .", "partition": "test"}
{"idx": "134", "code": "protected int parseAndAddNode(XmlResourceParser parser,HashMap<String,TagParser> tagParserMap,ArrayList<Long> screenIds) throws XmlPullParserException, IOException {\n  if (TAG_INCLUDE.equals(parser.getName())) {\n    final int resId=getAttributeResourceValue(parser,ATTR_WORKSPACE,0);\n    if (resId != 0) {\n      return parseLayout(resId,screenIds);\n    }\n else {\n      return 0;\n    }\n  }\n  mValues.clear();\n  parseContainerAndScreen(parser,mTemp);\n  final long container=mTemp[0];\n  final long screenId=mTemp[1];\n  mValues.put(Favorites.CONTAINER,container);\n  mValues.put(Favorites.SCREEN,screenId);\n  mValues.put(Favorites.CELLX,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_X),mColumnCount));\n  mValues.put(Favorites.CELLY,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_Y),mRowCount));\n  TagParser tagParser=tagParserMap.get(parser.getName());\n  if (tagParser == null) {\n    if (LOGD)     Log.d(TAG,\"Ignoring unknown element tag: \" + parser.getName());\n    return 0;\n  }\n  long newElementId=tagParser.parseAndAdd(parser);\n  if (newElementId >= 0) {\n    if (!screenIds.contains(screenId) && container == Favorites.CONTAINER_DESKTOP) {\n      screenIds.add(screenId);\n    }\n    return 1;\n  }\n  return 0;\n}\n", "docstring": "parses the current node and returns the number of elements added .", "partition": "test"}
{"idx": "135", "code": "private float calculateScrambleImageHeightMultiplier(float multiplier){\nswitch (currentPuzzle) {\ncase PuzzleUtils.TYPE_777:\ncase PuzzleUtils.TYPE_666:\ncase PuzzleUtils.TYPE_555:\ncase PuzzleUtils.TYPE_222:\ncase PuzzleUtils.TYPE_444:\ncase PuzzleUtils.TYPE_333:\n    return (multiplier / 4) * 3;\ncase PuzzleUtils.TYPE_CLOCK:\n  return multiplier / 2;\ncase PuzzleUtils.TYPE_MEGA:\nreturn (multiplier / 2);\ncase PuzzleUtils.TYPE_PYRA:\nreturn (float)(multiplier / Math.sqrt(1.25));\ncase PuzzleUtils.TYPE_SKEWB:\nreturn (multiplier / 4) * 3;\ncase PuzzleUtils.TYPE_SQUARE1:\nreturn multiplier;\n}\nreturn multiplier;\n}\n", "docstring": "calculates scramble image height multiplier to respect aspect ratio", "partition": "test"}
{"idx": "136", "code": "public void testNumericScalars() throws Exception {\n  ObjectMapper m=new ObjectMapper();\n  m.enableDefaultTyping();\n  assertEquals(\"[123]\",m.writeValueAsString(new Object[]{Integer.valueOf(123)}));\n  assertEquals(\"[[\\\"java.lang.Long\\\",37]]\",m.writeValueAsString(new Object[]{Long.valueOf(37)}));\n  assertEquals(\"[0.25]\",m.writeValueAsString(new Object[]{Double.valueOf(0.25)}));\n  assertEquals(\"[[\\\"java.lang.Float\\\",0.5]]\",m.writeValueAsString(new Object[]{Float.valueOf(0.5f)}));\n}\n", "docstring": "unit test to verify that limited number of core types do not include type information , even if declared as object . this is only done for types that json scalar values natively map to : string , integer and boolean ( and nulls never have type information )", "partition": "test"}
{"idx": "137", "code": "protected void closeCallbacksExceptListener(){\n  closeCacheCallback(getCacheLoader());\n  closeCacheCallback(getCacheWriter());\n  closeCacheCallback(getEvictionController());\n}\n", "docstring": "the listener is not closed until after the afterregiondestroy event", "partition": "test"}
{"idx": "138", "code": "private void populateProfiles(final ProfileList profiles){\n  profilesComboBox.removeAllItems();\n  for (  Profile p : profiles) {\n    profilesComboBox.addItem(p);\n  }\n  final int count=profilesComboBox.getItemCount();\n  if (count != 0) {\n    profilesComboBox.setSelectedIndex(count - 1);\n  }\n}\n", "docstring": "populate the profiles combobox and select the default .", "partition": "test"}
{"idx": "139", "code": "private long checkFileHeader(BufferedFileDataInput bfdi) throws ReplicatorException, InterruptedException {\n  int magic=0;\n  short major=0;\n  short minor=0;\n  try {\n    bfdi.waitAvailable(HEADER_LENGTH,HEADER_WAIT_MILLIS);\n    magic=bfdi.readInt();\n    major=bfdi.readShort();\n    minor=bfdi.readShort();\n    baseSeqno=bfdi.readLong();\n  }\n catch (  IOException e) {\n    throw new THLException(\"Failed to read file header from  \" + file.getAbsolutePath(),e);\n  }\n  if (magic != MAGIC_NUMBER)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : invalid magic number\");\n  if (major != MAJOR_VERSION)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : incompatible major version\");\n  if (minor != MINOR_VERSION)   logger.warn(\"Minor version mismatch : file \" + file.getAbsolutePath() + \" using format \"+ major+ \".\"+ minor+ \" - Tungsten running version \"+ MAJOR_VERSION+ \".\"+ MINOR_VERSION);\n  return baseSeqno;\n}\n", "docstring": "read the file header and return the log sequence number stored in the file header .", "partition": "test"}
{"idx": "140", "code": "public float realAbsolute(){\n  return Math.abs(mLeft);\n}\n", "docstring": "absolute value of real component", "partition": "test"}
{"idx": "141", "code": "private ExtremumType extremumType(int n,double[] alpha_extreme,HyperBoundingBox interval){\n  if (n == alpha_extreme.length - 1) {\n    return extremumType;\n  }\n  double[] alpha_extreme_l=new double[alpha_extreme.length];\n  double[] alpha_extreme_r=new double[alpha_extreme.length];\n  double[] alpha_extreme_c=new double[alpha_extreme.length];\n  System.arraycopy(alpha_extreme,0,alpha_extreme_l,0,alpha_extreme.length);\n  System.arraycopy(alpha_extreme,0,alpha_extreme_r,0,alpha_extreme.length);\n  System.arraycopy(alpha_extreme,0,alpha_extreme_c,0,alpha_extreme.length);\n  double[] centroid=SpatialUtil.centroid(interval);\n  for (int i=0; i < n; i++) {\n    alpha_extreme_l[i]=centroid[i];\n    alpha_extreme_r[i]=centroid[i];\n    alpha_extreme_c[i]=centroid[i];\n  }\n  double intervalLength=interval.getMax(n) - interval.getMin(n);\n  alpha_extreme_l[n]=Math.random() * intervalLength + interval.getMin(n);\n  alpha_extreme_r[n]=Math.random() * intervalLength + interval.getMin(n);\n  double f_c=function(alpha_extreme_c);\n  double f_l=function(alpha_extreme_l);\n  double f_r=function(alpha_extreme_r);\n  if (f_l < f_c) {\n    if (f_r < f_c || Math.abs(f_r - f_c) < DELTA) {\n      return ExtremumType.MAXIMUM;\n    }\n  }\n  if (f_r < f_c) {\n    if (f_l < f_c || Math.abs(f_l - f_c) < DELTA) {\n      return ExtremumType.MAXIMUM;\n    }\n  }\n  if (f_l > f_c) {\n    if (f_r > f_c || Math.abs(f_r - f_c) < DELTA) {\n      return ExtremumType.MINIMUM;\n    }\n  }\n  if (f_r > f_c) {\n    if (f_l > f_c || Math.abs(f_l - f_c) < DELTA) {\n      return ExtremumType.MINIMUM;\n    }\n  }\n  if (Math.abs(f_l - f_c) < DELTA && Math.abs(f_r - f_c) < DELTA) {\n    return ExtremumType.CONSTANT;\n  }\n  throw new IllegalArgumentException(\"Houston, we have a problem!\\n\" + this + \"\\n\"+ \"f_l \"+ f_l+ \"\\n\"+ \"f_c \"+ f_c+ \"\\n\"+ \"f_r \"+ f_r+ \"\\n\"+ \"p \"+ vec.toArray()+ \"\\n\"+ \"alpha   \"+ FormatUtil.format(alpha_extreme_c)+ \"\\n\"+ \"alpha_l \"+ FormatUtil.format(alpha_extreme_l)+ \"\\n\"+ \"alpha_r \"+ FormatUtil.format(alpha_extreme_r)+ \"\\n\"+ \"n \"+ n);\n}\n", "docstring": "returns the type of the extremum at the specified alpha values .", "partition": "test"}
{"idx": "142", "code": "public static String map2OID(String algName){\n  return alg2OidMap.get(algName.toUpperCase(Locale.US));\n}\n", "docstring": "returns oid for algname", "partition": "test"}
{"idx": "143", "code": "@Override public Generator<ICircle> construct(String[] args){\n  return new UniformGenerator(Double.valueOf(args[0]));\n}\n", "docstring": "provide reflective behavior to construct instance of generator given an array of string arguments .", "partition": "test"}
{"idx": "144", "code": "protected void processMouseEvent(MouseEvent e){\n  if (myInplaceComponent != null && (MouseEvent.MOUSE_PRESSED == e.getID() || MouseEvent.MOUSE_RELEASED == e.getID())) {\n    finishEditing(true);\n  }\n  super.processMouseEvent(e);\n}\n", "docstring": "when there is an inplace editor we \" listen \" all mouse event and finish editing by any mouse_pressed or mouse_released event . we are acting like yet another glass pane over the standard glass layer .", "partition": "test"}
{"idx": "145", "code": "protected boolean hasAllTables() throws CouldntLoadDataException, InvalidDatabaseException {\n  NaviLogger.info(\"Checking the existence of the BinNavi database tables\");\n  final int counter=PostgreSQLHelpers.getTableCount(getConnection(),Lists.newArrayList(TABLES));\n  if (counter == 0) {\n    return false;\n  }\n else   if (counter == TABLES.length) {\n    return true;\n  }\n else {\n    throw new InvalidDatabaseException(String.format(\"Invalid database state (%d of %d tables found)\",counter,TABLES.length));\n  }\n}\n", "docstring": "makes sure that all required binnavi database tables exist . this method tries to find out whether the database is empty or already initialized ( or inconsistent ) .", "partition": "test"}
{"idx": "146", "code": "public List<String> classify(List<List<Feature>> features) throws CleartkProcessingException {\n  String[][] featureStringArray=toStrings(features);\n  Pipe pipe=transducer.getInputPipe();\n  Instance instance=new Instance(featureStringArray,null,null,null);\n  instance=pipe.instanceFrom(instance);\n  Sequence<?> data=(Sequence<?>)instance.getData();\n  Sequence<?> untypedSequence=transducer.transduce(data);\n  Sequence<String> sequence=ReflectionUtil.uncheckedCast(untypedSequence);\n  List<String> returnValues=new ArrayList<String>();\n  for (int i=0; i < sequence.size(); i++) {\n    String encodedOutcome=sequence.get(i);\n    returnValues.add(outcomeEncoder.decode(encodedOutcome));\n  }\n  return returnValues;\n}\n", "docstring": "this method classifies several instances at once", "partition": "test"}
{"idx": "147", "code": "public void onBindHeaderViewHolder(RecyclerView.ViewHolder holder,int position){\n  onBindHeaderViewHolder(holder,position,Collections.emptyList());\n}\n", "docstring": "bind header with provided viewholder at specified position", "partition": "test"}
{"idx": "148", "code": "private void updateLineList(){\n  if (horizontalLineRadiobutton.isSelected()) {\n    setHorizontalLineSelected();\n  }\n else {\n    setVerticalLineSelected();\n  }\n  updateButtonStates();\n}\n", "docstring": "updates the displayed list of lines .", "partition": "test"}
{"idx": "149", "code": "public void rectangle(double x,double y,double halfWidth,double halfHeight){\n  if (halfWidth < 0)   throw new IllegalArgumentException(\"half width can\'t be negative\");\n  if (halfHeight < 0)   throw new IllegalArgumentException(\"half height can\'t be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * halfWidth);\n  double hs=factorY(2 * halfHeight);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Rectangle2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "docstring": "draws a rectangle of given half width and half height , centered on ( x , y ) .", "partition": "test"}
{"idx": "150", "code": "public void replaceSplitElement(int aIndex,Fragment aSplitElement){\n  splits.set(aIndex,aSplitElement);\n}\n", "docstring": "replaces a split element with another one", "partition": "test"}
{"idx": "151", "code": "private void startItemList(StringBuilder result,String rootId){\n  result.append(\"<div class=\\\"container\\\"\" + \"><div class=\\\"alone fakealone\\\" id=\\\"alone_ef_\" + rootId + \"\\\"></div><div class=\\\"justchildren fakejustchildren\\\">\");\n}\n", "docstring": "called to start an item list .", "partition": "test"}
{"idx": "152", "code": "private static int numInitialSplits(long numRecords){\n  final int maxSplits=100;\n  final long recordsPerSplit=10000;\n  return (int)Math.min(maxSplits,numRecords / recordsPerSplit + 1);\n}\n", "docstring": "pick a number of initial splits based on the number of records expected to be processed .", "partition": "test"}
{"idx": "153", "code": "public void mouseClicked(MouseEvent e){\n  if (e.getClickCount() > 1) {\n    System.gc();\n  }\n}\n", "docstring": "invoked when the mouse has been clicked on a component .", "partition": "test"}
{"idx": "154", "code": "private static String[] scanForSources(final File sourceDir,final Set<String> sourceIncludes,final Set<String> sourceExcludes){\n  final DirectoryScanner ds=new DirectoryScanner();\n  ds.setFollowSymlinks(true);\n  ds.setBasedir(sourceDir);\n  ds.setIncludes(sourceIncludes.toArray(new String[sourceIncludes.size()]));\n  ds.setExcludes(sourceExcludes.toArray(new String[sourceExcludes.size()]));\n  ds.addDefaultExcludes();\n  try {\n    ds.scan();\n  }\n catch (  IllegalStateException e) {\n    return new String[0];\n  }\n  return ds.getIncludedFiles();\n}\n", "docstring": "scans a single source dir for sources and includes only the files whose name match the patterns in sourceincludes and excludes all files whose names match the patterns in sourceexcludes", "partition": "test"}
{"idx": "155", "code": "public boolean hasSingleElement(){\n  return mSelectedWidgets.size() == 1;\n}\n", "docstring": "check if the selection has a single element", "partition": "test"}
{"idx": "156", "code": "public IgfsPath(URI uri){\n  A.notNull(uri,\"uri\");\n  path=normalizePath(uri.getPath());\n}\n", "docstring": "constructs a path from an uri", "partition": "test"}
{"idx": "157", "code": "public int toInt(Element el,String attributeName){\n  return Caster.toIntValue(el.getAttribute(attributeName),Integer.MIN_VALUE);\n}\n", "docstring": "reads a xml element attribute ans cast it to a int value", "partition": "test"}
{"idx": "158", "code": "public void addGetters(int assignedPropertyNumber,String propertyName){\n  for (  EventType type : knownTypes) {\n    EventPropertyGetter getter=type.getGetter(propertyName);\n    VariantPropertyGetterRow row=allGetters.get(type);\n    if (row == null) {\nsynchronized (this) {\n        row=new VariantPropertyGetterRow(type,new EventPropertyGetter[assignedPropertyNumber + 1]);\n        allGetters.put(type,row);\n      }\n    }\n    row.addGetter(assignedPropertyNumber,getter);\n  }\n  properties.add(propertyName);\n}\n", "docstring": "adds the getters for a property that is identified by a property number which indexes into array of getters per type .", "partition": "test"}
{"idx": "159", "code": "protected void markUsed(Entry entry){\n  entry.lastUsed=System.nanoTime();\n}\n", "docstring": "marks the specified entry as used by setting its last used time to the current time in nanoseconds .", "partition": "test"}
{"idx": "160", "code": "@Override public String execute(){\n  return SUCCESS;\n}\n", "docstring": "default : just returns \" success \"", "partition": "test"}
{"idx": "161", "code": "private void handleStateLeft(InetAddress endpoint,String[] pieces){\n  assert pieces.length >= 2;\n  Collection<Token> tokens=getTokensFor(endpoint);\n  if (logger.isDebugEnabled())   logger.debug(\"Node {} state left, tokens {}\",endpoint,tokens);\n  excise(tokens,endpoint,extractExpireTime(pieces));\n}\n", "docstring": "handle node leaving the ring . this will happen when a node is decommissioned", "partition": "test"}
{"idx": "162", "code": "public static void register(String algorithmURI,Class<? extends SignatureAlgorithmSpi> implementingClass) throws AlgorithmAlreadyRegisteredException, ClassNotFoundException, XMLSignatureException {\n  JavaUtils.checkRegisterPermission();\n  if (log.isLoggable(java.util.logging.Level.FINE)) {\n    log.log(java.util.logging.Level.FINE,\"Try to register \" + algorithmURI + \" \"+ implementingClass);\n  }\n  Class<? extends SignatureAlgorithmSpi> registeredClass=algorithmHash.get(algorithmURI);\n  if (registeredClass != null) {\n    Object exArgs[]={algorithmURI,registeredClass};\n    throw new AlgorithmAlreadyRegisteredException(\"algorithm.alreadyRegistered\",exArgs);\n  }\n  algorithmHash.put(algorithmURI,implementingClass);\n}\n", "docstring": "registers implementing class of the transform algorithm with algorithmuri", "partition": "test"}
{"idx": "163", "code": "@SuppressWarnings(\"UnusedDeclaration\") public KeyValuePersistenceSettings(File settingsFile){\n  InputStream in;\n  try {\n    in=new FileInputStream(settingsFile);\n  }\n catch (  IOException e) {\n    throw new IgniteException(\"Failed to get input stream for Cassandra persistence settings file: \" + settingsFile.getAbsolutePath(),e);\n  }\n  init(loadSettings(in));\n}\n", "docstring": "constructs ignite cache key / value persistence settings .", "partition": "test"}
{"idx": "164", "code": "public boolean containsWordBreakingChar(final @NonNull CharSequence input){\n  if (!TextUtils.isEmpty(input)) {\n    for (int i=0; i < input.length(); i++) {\n      char c=input.charAt(i);\n      if (isWordBreakingChar(c)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the input string contains a word - breaking character .", "partition": "test"}
{"idx": "165", "code": "private void checkInteriorIntersections(){\n  for (Iterator i=segStrings.iterator(); i.hasNext(); ) {\n    SegmentString ss0=(SegmentString)i.next();\n    for (Iterator j=segStrings.iterator(); j.hasNext(); ) {\n      SegmentString ss1=(SegmentString)j.next();\n      checkInteriorIntersections(ss0,ss1);\n    }\n  }\n}\n", "docstring": "checks all pairs of segments for intersections at an interior point of a segment", "partition": "test"}
{"idx": "166", "code": "private <T>UnaryOperator<T> compose(UnaryOperator<T> before,UnaryOperator<T> after){\n  return null;\n}\n", "docstring": "compose two functions together into a single function", "partition": "test"}
{"idx": "167", "code": "private void addCdcColSpecs(ArrayList<ColumnSpec> cdcSpecs,OneRowChange cdcRowChangeData){\n  int cdcPos=cdcSpecs.size();\n  if (cdcColumnsAtFront)   cdcPos=0;\n  ColumnSpec spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1);\n  spec.setName(\"CDC_OP_TYPE\");\n  spec.setType(java.sql.Types.VARCHAR);\n  spec.setLength(1);\n  cdcSpecs.add(cdcPos,spec);\n  spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1 + 1);\n  spec.setName(\"CDC_TIMESTAMP\");\n  spec.setType(java.sql.Types.TIMESTAMP);\n  cdcSpecs.add(cdcPos + 1,spec);\n  spec=cdcRowChangeData.new ColumnSpec();\n  spec.setIndex(cdcPos + 1 + 2);\n  spec.setName(\"CDC_SEQUENCE_NUMBER\");\n  spec.setType(java.sql.Types.BIGINT);\n  cdcSpecs.add(cdcPos + 2,spec);\n}\n", "docstring": "add cdc column specifications .", "partition": "test"}
{"idx": "168", "code": "public static String convertToJavaFieldName(String name){\n  int dotIndex=name.indexOf(\'.\');\n  if (dotIndex >= 0) {\n    name=name.substring(0,dotIndex);\n  }\n  String[] split=name.split(\"[_-]\");\n  StringBuilder out=new StringBuilder();\n  boolean first=true;\n  for (  String section : split) {\n    if (first) {\n      first=false;\n      out.append(section);\n    }\n else {\n      out.append(StringUtil.capitalize(section));\n    }\n  }\n  return out.toString();\n}\n", "docstring": "utility method to convert a variable name into java field name .", "partition": "test"}
{"idx": "169", "code": "protected void execute(String[] sqls,SQLiteDatabase db){\n  String throwSQL=\"\";\n  try {\n    if (sqls != null) {\n      for (      String sql : sqls) {\n        throwSQL=sql;\n        db.execSQL(BaseUtility.changeCase(sql));\n      }\n    }\n  }\n catch (  SQLException e) {\n    throw new DatabaseGenerateException(DatabaseGenerateException.SQL_ERROR + throwSQL);\n  }\n}\n", "docstring": "use the parameter sqlitedatabase to execute the passing sqls . subclasses can add their own logic when do the executing job by overriding this method .", "partition": "test"}
{"idx": "170", "code": "private void refreshDoneButton(boolean done){\n  butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n}\n", "docstring": "refreshes the done button . the label will say the opposite of the player \"'\" s \" done \" status , indicating that clicking it will reverse the condition .", "partition": "test"}
{"idx": "171", "code": "private void createMigrationTaskPage(){\n  MigrationTaskEditor migrationTaskEditor=new MigrationTaskEditor(migrationTask,getContainer());\n  int index=addPage(migrationTaskEditor.getControl());\n  setPageText(index,\"Task\");\n  taskListeners.add(migrationTaskEditor);\n}\n", "docstring": "create the basic editor .", "partition": "test"}
{"idx": "172", "code": "private boolean hasNext(Pattern pattern){\n  if (!hasNext()) {\n    return false;\n  }\n  Matcher matcher=pattern.matcher(gserValue.substring(pos,length));\n  return matcher.find();\n}\n", "docstring": "determines if the remaining gser string matches the provided pattern .", "partition": "test"}
{"idx": "173", "code": "void pushInt(int i){\nswitch (i) {\ncase -1:\n    mv.visitInsn(ICONST_M1);\n  return;\ncase 0:\nmv.visitInsn(ICONST_0);\nreturn;\ncase 1:\nmv.visitInsn(ICONST_1);\nreturn;\ncase 2:\nmv.visitInsn(ICONST_2);\nreturn;\ncase 3:\nmv.visitInsn(ICONST_3);\nreturn;\ncase 4:\nmv.visitInsn(ICONST_4);\nreturn;\ncase 5:\nmv.visitInsn(ICONST_5);\nreturn;\n}\nif (i >= Byte.MIN_VALUE && i <= Byte.MAX_VALUE) {\nmv.visitIntInsn(BIPUSH,i);\nreturn;\n}\nif (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {\nmv.visitIntInsn(SIPUSH,i);\nreturn;\n}\nmv.visitLdcInsn(Integer.valueOf(i));\n}\n", "docstring": "push i onto our operand stack", "partition": "test"}
{"idx": "174", "code": "public static String xmlNode(String name,String attributes,String content,boolean indent){\n  String start=attributes == null ? name : name + attributes;\n  if (content == null) {\n    return \"<\" + start + \"/>\\n\";\n  }\n  if (indent && content.indexOf(\'\\n\') >= 0) {\n    content=\"\\n\" + indent(content);\n  }\n  return \"<\" + start + \">\"+ content+ \"</\"+ name+ \">\\n\";\n}\n", "docstring": "create an xml node with optional attributes and content . the data is indented with 4 spaces if it contains a newline character and the indent parameter is set to true .", "partition": "test"}
{"idx": "175", "code": "public void add(int position,@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(position,item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(position);\n  }\n}\n", "docstring": "adds the specified item to the list with the specified position", "partition": "test"}
{"idx": "176", "code": "public List<String> splitStringWithDefaultDelimiterEscaped(String inputString){\n  String delimiter=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER);\n  String escapeChar=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER_ESCAPE_CHAR);\n  List<String> splitString=new ArrayList<>();\n  if (StringUtils.isNotBlank(inputString)) {\n    String regex=\"(?<!\" + Pattern.quote(escapeChar) + \")\"+ Pattern.quote(delimiter);\n    for (    String s : inputString.split(regex)) {\n      splitString.add(s.replace(escapeChar + delimiter,delimiter));\n    }\n  }\n  return splitString;\n}\n", "docstring": "splits the input string based on the default delimiter , and also escapes delimiter .", "partition": "test"}
{"idx": "177", "code": "protected final boolean readAvailableBlocking() throws IOException {\n  char[] buffer=myBuffer;\n  StringBuilder token=myTextBuffer;\n  token.setLength(0);\n  boolean read=false;\n  int n;\n  while ((n=myReader.read(buffer)) > 0) {\n    if (myScheduledSubmitter != null)     myScheduledSubmitter.cancel(true);\n    read=true;\nsynchronized (myTextBuffer) {\n      processLine(buffer,token,n);\n    }\n    myScheduledSubmitter=myExecutorService.submit(myTokenSubmitter);\n  }\n  submitToken();\n  return read;\n}\n", "docstring": "reads data with blocking . should be used in case when ready method always returns false for your input stream . should be used if we want to to make our reader exit when end of stream reached . could be used if we prefer io - blocking over cpu sleeping .", "partition": "test"}
{"idx": "178", "code": "public void deleteObligation(final Obligation obligation,int basicBlockId) throws ObligationAcquiredOrReleasedInLoopException {\n  Map<ObligationSet,State> updatedStateMap=new HashMap<ObligationSet,State>();\n  for (Iterator<State> i=stateIterator(); i.hasNext(); ) {\n    State state=i.next();\n    checkCircularity(state,obligation,basicBlockId);\n    ObligationSet obligationSet=state.getObligationSet();\n    obligationSet.remove(obligation);\n    if (!obligationSet.isEmpty()) {\n      updatedStateMap.put(obligationSet,state);\n    }\n  }\n  replaceMap(updatedStateMap);\n}\n", "docstring": "remove an obligation from every state in the stateset .", "partition": "test"}
{"idx": "179", "code": "public ContentImpl createCompoundPackageContent(OleBlobImpl blob,String prettyName,String className,String typeName,ByteBuffer blobBb,int dataBlockLen){\n  return new CompoundContentImpl(blob,prettyName,className,typeName,blobBb.position(),dataBlockLen);\n}\n", "docstring": "creates a nes compoundcontent for the given blob information .", "partition": "test"}
{"idx": "180", "code": "protected boolean checkCoverage(){\n  int i;\n  int n;\n  int[] count;\n  Range r;\n  String attrIndex;\n  SubspaceClusterDefinition cl;\n  count=new int[getNumAttributes()];\n  for (i=0; i < getNumAttributes(); i++) {\n    for (n=0; n < getClusters().length; n++) {\n      cl=(SubspaceClusterDefinition)getClusters()[n];\n      r=new Range(cl.getAttrIndexRange());\n      r.setUpper(getNumAttributes());\n      if (r.isInRange(i)) {\n        count[i]++;\n      }\n    }\n  }\n  attrIndex=\"\";\n  for (i=0; i < count.length; i++) {\n    if (count[i] == 0) {\n      if (attrIndex.length() != 0) {\n        attrIndex+=\",\";\n      }\n      attrIndex+=(i + 1);\n    }\n  }\n  if (attrIndex.length() != 0) {\n    throw new IllegalArgumentException(\"The following attributes are not covered by a cluster \" + \"definition: \" + attrIndex + \"\\n\");\n  }\n  return true;\n}\n", "docstring": "checks , whether all attributes are covered by cluster definitions and returns true in that case .", "partition": "test"}
{"idx": "181", "code": "private Set<Integer> findValues(String string){\n  Set<Integer> results=new TreeSet<Integer>();\n  for (  String str : string.split(\",\")) {\n    if (!str.equals(\"\")) {\n      results.add(findValue(str));\n    }\n  }\n  return results;\n}\n", "docstring": "search for a string in the enumeration .", "partition": "test"}
{"idx": "182", "code": "@Deprecated public void append(final String name,final String value){\n  List<String> l=map.get(name);\n  if (l != null) {\n    l.add(value);\n  }\n else {\n    l=Lists.newArrayList(value);\n    map.put(name,l);\n  }\n}\n", "docstring": "add a new value for name", "partition": "test"}
{"idx": "183", "code": "public Statement between(Object former,Object later){\n  statement.append(\" BETWEEN \");\n  append(former);\n  statement.append(\" AND \");\n  append(later);\n  return this;\n}\n", "docstring": "appending the between operator clause .", "partition": "test"}
{"idx": "184", "code": "public byte[] encode1(final String s){\n  final ByteArrayBuffer tmp=new ByteArrayBuffer(s.length());\n  final int nwritten=uc.encode(s,tmp);\n  final int npack=LongPacker.getByteLength(nwritten);\n  final byte[] a=new byte[npack + nwritten];\n  final DataOutputBuffer dob=new DataOutputBuffer(0,a);\n  try {\n    dob.packLong(nwritten);\n    dob.append(tmp.array(),0,tmp.pos());\n    return a;\n  }\n  finally {\n    try {\n      dob.close();\n    }\n catch (    IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "docstring": "encode a unicode string .", "partition": "test"}
{"idx": "185", "code": "public static Map<Object,Long> valueHistogram(GeoTimeSerie gts){\n  Map<Object,Long> occurrences=new HashMap<Object,Long>();\n  for (int i=0; i < gts.values; i++) {\n    Object value=GTSHelper.valueAtIndex(gts,i);\n    if (!occurrences.containsKey(value)) {\n      occurrences.put(value,1L);\n    }\n else {\n      occurrences.put(value,1L + occurrences.get(value));\n    }\n  }\n  if (GTSHelper.isBucketized(gts) && gts.bucketcount != gts.values) {\n    occurrences.put(null,(long)(gts.bucketcount - gts.values));\n  }\n  return occurrences;\n}\n", "docstring": "build an occurrence count by value for the given time serie .", "partition": "test"}
{"idx": "186", "code": "public QueryStringQueryBuilder field(String field){\n  if (fields == null) {\n    fields=new ArrayList<>();\n  }\n  fields.add(field);\n  return this;\n}\n", "docstring": "adds a field to run the query string against .", "partition": "test"}
{"idx": "187", "code": "public static <R,A,B>CompletionStage<R> combine(CompletionStage<A> a,CompletionStage<B> b,BiFunction<A,B,R> function){\n  return a.thenCombine(b,function);\n}\n", "docstring": "combines multiple stages by applying a function .", "partition": "test"}
{"idx": "188", "code": "protected String buildCreateSchemaStatement() throws ReplicatorException {\n  return null;\n}\n", "docstring": "return a statement that will create the schema , null if no create schema can be given", "partition": "test"}
{"idx": "189", "code": "public void testNegPosFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=1;\n  byte rBytes[]={0,-128,9,56,100,0,0,1,1,90,1,-32,0,10,-126,21,82,-31,-95};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.and(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "and for a negative and a positive numbers ; the first is shorter", "partition": "test"}
{"idx": "190", "code": "public StreamInfoManager(TwitchApi api,StreamInfoListener listener){\n  this.listener=listener;\n  this.api=api;\n  pendingRequests=new HashMap<>();\n  invalidStreamInfo=new StreamInfo(\"invalid\",listener);\n  invalidStreamInfo.setRequested();\n}\n", "docstring": "create a new manager object .", "partition": "test"}
{"idx": "191", "code": "public Sentence asSentence(){\n  return Sentence.newConjunction(sentences);\n}\n", "docstring": "returns the list of sentences in the knowledge base chained together as a single sentence .", "partition": "test"}
{"idx": "192", "code": "public boolean isPronoun(){\n  return typeString.contains(SUFFIX_PRONOUN);\n}\n", "docstring": "determine if the expression is a pronoun .", "partition": "test"}
{"idx": "193", "code": "protected void appendShortType(StringBuilder sb,FieldType fieldType,int fieldWidth){\n  sb.append(\"SMALLINT\");\n}\n", "docstring": "output the sql type for a java short .", "partition": "test"}
{"idx": "194", "code": "public static Vector tokenizeString(String source,String separator){\n  if (separator.length() == 1) {\n    return tokenizeString(source,separator.charAt(0));\n  }\n  Vector tokenized=new Vector();\n  int len=source.length();\n  StringBuilder buf=new StringBuilder();\n  for (int iter=0; iter < len; iter++) {\n    char current=source.charAt(iter);\n    if (separator.indexOf(current) > -1) {\n      if (buf.length() > 0) {\n        tokenized.addElement(buf.toString());\n        buf=new StringBuilder();\n      }\n    }\n else {\n      buf.append(current);\n    }\n  }\n  if (buf.length() > 0) {\n    tokenized.addElement(buf.toString());\n  }\n  return tokenized;\n}\n", "docstring": "breaks a string to multiple strings ( similar to string tokenizer )", "partition": "test"}
{"idx": "195", "code": "private void backupFavorites(BackupDataOutput data) throws IOException {\n  ContentResolver cr=mContext.getContentResolver();\n  Cursor cursor=cr.query(Favorites.CONTENT_URI,FAVORITE_PROJECTION,getUserSelectionArg(),null,null);\n  try {\n    cursor.moveToPosition(-1);\n    while (cursor.moveToNext()) {\n      final long id=cursor.getLong(ID_INDEX);\n      final long updateTime=cursor.getLong(ID_MODIFIED);\n      Key key=getKey(Key.FAVORITE,id);\n      mKeys.add(key);\n      final String backupKey=keyToBackupKey(key);\n      if (!mExistingKeys.contains(backupKey) || updateTime >= mLastBackupRestoreTime) {\n        writeRowToBackup(key,packFavorite(cursor),data);\n      }\n else {\n        if (DEBUG)         Log.d(TAG,\"favorite already backup up: \" + id);\n      }\n    }\n  }\n  finally {\n    cursor.close();\n  }\n}\n", "docstring": "write all modified favorites to the data stream .", "partition": "test"}
{"idx": "196", "code": "public void update(){\n  if (lastTime != -1L) {\n    long delta=System.nanoTime() - lastTime;\n    rollingAverage.addValue(delta);\n  }\n  lastTime=System.nanoTime();\n}\n", "docstring": "update the fps counter . < p / > call this method every frame !", "partition": "test"}
{"idx": "197", "code": "public List<ValidationErrorMessage> validate(){\n  errorMessageIds.clear();\n  if (paymentProduct == null) {\n    throw new NullPointerException(\"Error validating PaymentRequest, please set a paymentProduct first.\");\n  }\n  for (  PaymentProductField field : paymentProduct.getPaymentProductFields()) {\n    if (!isFieldInAccountOnFileAndNotAltered(field)) {\n      errorMessageIds.addAll(field.validateValue(getValue(field.getId())));\n    }\n  }\n  return errorMessageIds;\n}\n", "docstring": "validates all fields based on their value and their validationrules if a field is prefilled from the account on file , but it has been altered , it will be validated .", "partition": "test"}
{"idx": "198", "code": "KeyStoreState(){\n}\n", "docstring": "create an empty state .", "partition": "test"}
{"idx": "199", "code": "CryptoResult(final T result,final List<K> masterKeys,final CiphertextHeaders headers){\n  result_=result;\n  masterKeys_=Collections.unmodifiableList(masterKeys);\n  headers_=headers;\n  encryptionContext_=headers_.getEncryptionContextMap();\n}\n", "docstring": "note , does not make a defensive copy of any of the data .", "partition": "test"}
{"idx": "200", "code": "public void stateChanged(ChangeEvent e){\n  if (ignoreUpdate) {\n    return;\n  }\n  double value=(double)(1800 - setpointSlider.getValue()) / 10;\n  setSetPoint(value);\n  sim.setSetPoint(value);\n}\n", "docstring": "handle a change in the slider by updating the dataset value . this automatically triggers a chart repaint .", "partition": "test"}
{"idx": "201", "code": "public static String[] parseDelimitedList(String list,char delimiter){\n  String delim=\"\" + delimiter;\n  StringTokenizer st=new StringTokenizer(list + delim + \" \",delim,true);\n  ArrayList<String> v=new ArrayList<String>();\n  String lastToken=\"\";\n  String word=\"\";\n  while (st.hasMoreTokens()) {\n    String tok=st.nextToken();\n    if (lastToken != null) {\n      if (tok.equals(delim)) {\n        word=word + lastToken;\n        if (lastToken.equals(delim))         tok=null;\n      }\n else {\n        if (!word.equals(\"\"))         v.add(word);\n        word=\"\";\n      }\n    }\n    lastToken=tok;\n  }\n  return v.toArray(new String[0]);\n}\n", "docstring": "parse a list of substrings separated by a given delimiter . the delimiter can also appear in substrings ( just double them ) : parsedelimitedstring ( \" this | is \" , \"'\" | \"'\" ) returns [ \" this \" , \" is \" ", "partition": "test"}
{"idx": "202", "code": "private void initializeLayout(){\n  GridLayout gl=new GridLayout(0,2);\n  gl.setVgap(5);\n  setLayout(gl);\n  add(new JLabel(\"Frozen: \"));\n  add(frozenDD);\n  add(new JLabel(\"Upper Bound:\"));\n  add(tfUpBound);\n  add(new JLabel(\"Lower Bound\"));\n  add(tfLowBound);\n  add(new JLabel(\"Increment:\"));\n  add(tfIncrement);\n  add(new JLabel(\"Delay:\"));\n  add(tfDelay);\n  setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n}\n", "docstring": "lays out the panel", "partition": "test"}
{"idx": "203", "code": "@Override public boolean isRunning(){\n  return (frame != null && frame.isVisible());\n}\n", "docstring": "returns true if the gui is started and not paused , and false otherwise .", "partition": "test"}
{"idx": "204", "code": "public static MosaicDefinition createMosaicDefinition(final Account creator){\n  return createMosaicDefinition(creator,Utils.createMosaicId(\"alice.vouchers\",\"alice\'s gift vouchers\"),createMosaicProperties());\n}\n", "docstring": "creates a default mosaic definition .", "partition": "test"}
{"idx": "205", "code": "public Result result(SqlNode node,Collection<Clause> clauses,RelNode rel){\n  final String alias2=SqlValidatorUtil.getAlias(node,-1);\n  final String alias3=alias2 != null ? alias2 : \"t\";\n  final String alias4=SqlValidatorUtil.uniquify(alias3,aliasSet,SqlValidatorUtil.EXPR_SUGGESTER);\n  final String alias5=alias2 == null || !alias2.equals(alias4) ? alias4 : null;\n  return new Result(node,clauses,alias5,Collections.singletonList(Pair.of(alias4,rel.getRowType())));\n}\n", "docstring": "creates a result based on a single relational expression .", "partition": "test"}
{"idx": "206", "code": "private static void _trustAllHttpsCertificates(){\n  SSLContext context;\n  if (_trustManagers == null) {\n    _trustManagers=new TrustManager[]{new FakeX509TrustManager()};\n  }\n  try {\n    context=SSLContext.getInstance(\"SSL\");\n    context.init(null,_trustManagers,new SecureRandom());\n  }\n catch (  GeneralSecurityException gse) {\n    throw new IllegalStateException(gse.getMessage());\n  }\n  HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n}\n", "docstring": "set the default x509 trust manager to an instance of a fake class that trust all certificates , even the self - signed ones .", "partition": "test"}
{"idx": "207", "code": "private static boolean isInNeedOfForm(UIComponent component){\n  return (component instanceof ActionSource || component instanceof ActionSource2 || component instanceof EditableValueHolder);\n}\n", "docstring": "is the component in need of a form .", "partition": "test"}
{"idx": "208", "code": "private void addInternalListeners(){\n  cbDistribution.addItemListener(cbItemListener);\n}\n", "docstring": "adds all internal listeners . currently this just consists of an item listener for the combo - box which switches to the correct \" card \" for the given probability distribution .", "partition": "test"}
{"idx": "209", "code": "public static long runMultiThreaded(Iterable<Callable<?>> calls,GridTestSafeThreadFactory threadFactory) throws Exception {\n  if (!busyLock.enterBusy())   throw new IllegalStateException(\"Failed to start new threads (test is being stopped).\");\n  Collection<Thread> threads=new ArrayList<>();\n  long time;\n  try {\n    for (    Callable<?> call : calls)     threads.add(threadFactory.newThread(call));\n    time=System.currentTimeMillis();\n    for (    Thread t : threads)     t.start();\n  }\n  finally {\n    busyLock.leaveBusy();\n  }\n  for (  Thread t : threads)   t.join();\n  time=System.currentTimeMillis() - time;\n  threadFactory.checkError();\n  return time;\n}\n", "docstring": "runs callable tasks each in separate threads .", "partition": "test"}
{"idx": "210", "code": "private void bappend(char ch){\n  try {\n    mBuff[++mBuffIdx]=ch;\n  }\n catch (  Exception exp) {\n    char buff[]=new char[mBuff.length << 1];\n    System.arraycopy(mBuff,0,buff,0,mBuff.length);\n    mBuff=buff;\n    mBuff[mBuffIdx]=ch;\n  }\n}\n", "docstring": "appends a character to parser \"'\" s buffer .", "partition": "test"}
{"idx": "211", "code": "public void initializeOwnerReferencesForField(StateManager sm,FieldMetaData fmd){\n  if (fmd.getAssociationType() == FieldMetaData.ONE_TO_MANY) {\n    Collection<?> collection=(Collection<?>)sm.fetch(fmd.getIndex());\n    if (collection != null) {\n      for (      Object item : collection) {\n        if (item != null) {\n          _relationsManager.setOwnerStateManagerForPersistentInstance(item,sm,fmd);\n        }\n      }\n    }\n  }\n else   if (fmd.getAssociationType() == FieldMetaData.ONE_TO_ONE || fmd.isEmbeddedPC()) {\n    Object value=sm.fetch(fmd.getIndex());\n    if (value != null) {\n      _relationsManager.setOwnerStateManagerForPersistentInstance(value,sm,fmd);\n    }\n  }\n}\n", "docstring": "sets the provided state manager as the owner for the provided field value .", "partition": "test"}
{"idx": "212", "code": "public Node(Coordinate pt){\n  this(pt,new DirectedEdgeStar());\n}\n", "docstring": "constructs a node with the given location .", "partition": "test"}
{"idx": "213", "code": "public synchronized void increase(){\n  if (accuracy > 0) {\n    long timePassed=System.currentTimeMillis() - lastAdded;\n    if (timePassed > accuracy) {\n      clearUp();\n      if (count > 0) {\n        data.addFirst(lastAdded + accuracy);\n      }\n      lastAdded=System.currentTimeMillis();\n      count=0;\n    }\n    count++;\n  }\n else {\n    clearUp();\n    data.addFirst(System.currentTimeMillis());\n  }\n}\n", "docstring": "adds an element to the counter or caches it to be added .", "partition": "test"}
{"idx": "214", "code": "public void revert(final VirtualFile root,final List<FilePath> files) throws VcsException {\n  for (  List<String> paths : VcsFileUtil.chunkPaths(root,files)) {\n    GitSimpleHandler handler=new GitSimpleHandler(myProject,root,GitCommand.CHECKOUT);\n    handler.addParameters(\"HEAD\");\n    handler.endOptions();\n    handler.addParameters(paths);\n    handler.run();\n  }\n}\n", "docstring": "reverts the list of files we are passed .", "partition": "test"}
{"idx": "215", "code": "public TaggedValueIterator(final String aLine,final boolean attemptFirstWord,final String... tags){\n  this.aLine=aLine;\n  this.attemptFirstWord=attemptFirstWord;\n  this.tags=tags;\n  tagPos=0;\n  nextResult=getNextResult();\n  if (attemptFirstWord) {\n    int a=0;\n    while (a < aLine.length()) {\n      if (aLine.charAt(a) == '>' || aLine.charAt(a) == '@' || Character.isWhitespace(aLine.charAt(a)))       a++;\n else       break;\n    }\n    int b=a + 1;\n    while (b < aLine.length()) {\n      if (Character.isLetterOrDigit(aLine.charAt(b)) || aLine.charAt(b) == '_')       b++;\n else       break;\n    }\n    if (b - a > 4) {\n      nextResult=aLine.substring(a,b);\n    }\n    tagPos=b;\n  }\n}\n", "docstring": "iterator over all values following an occurrence of tag in aline . example : aline = gi | 4444 | gi | 5555 and tag = gi | with return 4444 and then 5555 value consists of letters , digits or underscore", "partition": "test"}
{"idx": "216", "code": "public void ascendTree(){\n  if (null != parentPath) {\n    parentPath.append(PARENT_PATH);\n    return;\n  }\n  File parentTree=calcParentTree();\n  if (null != parentTree) {\n    treeFile=parentTree;\n    return;\n  }\n  parentPath=new StringBuilder(provideLastName());\n  parentPath.append(PARENT_PATH);\n}\n", "docstring": "move higher in the tree , beyond even an apparent root of tree .", "partition": "test"}
{"idx": "217", "code": "public boolean canRead(){\n  return _is != null;\n}\n", "docstring": "returns true if there \"'\" s an associated file .", "partition": "test"}
{"idx": "218", "code": "void onItemDismissed(final int position){\n  final T removed=mData.get(position);\n  final boolean wasRemoved=remove(position);\n  if (wasRemoved && mDataChangeListener != null) {\n    mDataChangeListener.onItemRemoved(removed,position);\n  }\n}\n", "docstring": "dismisses item from the given position .", "partition": "test"}
{"idx": "219", "code": "public static double normalPDF(double x,double variance,double meanValue){\n  double standardDeviation=Math.sqrt(variance);\n  return (1 / (standardDeviation * Math.sqrt(2 * Math.PI))) * Math.pow(Math.E,-((x - meanValue) * (x - meanValue)) / (2 * variance));\n}\n", "docstring": "calculate a normal probability density function ( pdf ) based on a variance and mean value", "partition": "test"}
{"idx": "220", "code": "private void clearRegisters(Instruction start,Instruction end){\n  for (Instruction p=start; ; p=p.nextInstructionInCodeOrder()) {\n    for (Enumeration<Operand> ops=p.getOperands(); ops.hasMoreElements(); ) {\n      Operand op=ops.nextElement();\n      if (op instanceof RegisterOperand) {\n        RegisterOperand rOp=(RegisterOperand)op;\n        clearDepGraphNodeForRegister(rOp.getRegister());\n      }\n    }\n    if (p == end)     break;\n  }\n  for (Enumeration<Register> e=GenericPhysicalDefUse.enumerateAllImplicitDefUses(ir); e.hasMoreElements(); ) {\n    Register r=e.nextElement();\n    clearDepGraphNodeForRegister(r);\n  }\n}\n", "docstring": "initialize ( clear ) the dnode field in register for all registers in this basic block by setting them to null . handles both explicit and implict use / defs .", "partition": "test"}
{"idx": "221", "code": "public void fireAnnotationSelected(WorkflowAnnotation anno){\n  List<WorkflowAnnotation> list=new LinkedList<>();\n  list.add(anno);\n  fireAnnotationsChanged(AnnotationEvent.SELECTED_ANNOTATION_CHANGED,list);\n}\n", "docstring": "fire when an annotation has been selected .", "partition": "test"}
{"idx": "222", "code": "public boolean updateStatsAndReturnIfAllowed(){\n  long now=SystemClock.elapsedRealtime();\n  long deltaMs=now - mLastRequestTimestamp;\n  if (deltaMs < mDelayMs)   return false;\n  mLastRequestTimestamp=now;\n  if (deltaMs < 2 * mDelayMs) {\n    mDelayMs=Math.min(MAX_DELAY,mDelayMs * 2);\n  }\n else {\n    mDelayMs=MIN_DELAY;\n  }\n  return true;\n}\n", "docstring": "updates the prediction stats and return whether prediction is allowed . the policy is : 1 . if the client does not wait more than mdelayms , decline the request . 2 . if the client waits for more than mdelayms but less than 2 * mdelayms , accept the request and double mdelayms . 3 . if the client waits for more than 2 * mdelayms , accept the request and reset mdelayms . and : 100ms < = mdelayms < = 10s . this way , if an application sends a burst of requests , it is quickly seriously throttled . if it stops being this way , back to normal .", "partition": "test"}
{"idx": "223", "code": "public boolean verifyServerEvidenceMessage(BigInteger serverM2) throws CryptoException {\n  if ((this.A == null) || (this.M1 == null) || (this.S == null)) {\n    throw new CryptoException(\"Impossible to compute and verify M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\n  }\n  BigInteger computedM2=SRP6Util.calculateM2(digest,N,A,M1,S);\n  if (computedM2.equals(serverM2)) {\n    this.M2=serverM2;\n    return true;\n  }\n  return false;\n}\n", "docstring": "authenticates the server evidence message m2 received and saves it only if correct .", "partition": "test"}
{"idx": "224", "code": "public void handleText(String text){\n  if (skippingCharacters > 0) {\n    if (skippingCharacters >= text.length()) {\n      skippingCharacters-=text.length();\n      return;\n    }\n else {\n      text=text.substring(skippingCharacters);\n      skippingCharacters=0;\n    }\n  }\n  if (rtfDestination != null) {\n    rtfDestination.handleText(text);\n    return;\n  }\n  warning(\"Text with no destination. oops.\");\n}\n", "docstring": "handles any pure text ( containing no control characters ) in the input stream . called by the superclass .", "partition": "test"}
{"idx": "225", "code": "public final boolean remove(final URI serviceURI){\n  boolean modified=false;\nsynchronized (this) {\n    if (aliases.remove(serviceURI) != null) {\n      modified=true;\n    }\n    final ServiceFactory factory=services.remove(serviceURI);\n    if (factory != null) {\n      modified=true;\n      if (factory instanceof CustomServiceFactory) {\n        customServices.remove(factory);\n      }\n    }\n  }\n  return modified;\n}\n", "docstring": "remove a service from the registry and / or set of known aliases .", "partition": "test"}
{"idx": "226", "code": "@Nullable private static String referenceToAttribute(String attrib,boolean includeDummies){\n  while (attrib.startsWith(\"\\\\\\\\\")) {\n    attrib=attrib.substring(2);\n  }\n  if (attrib.startsWith(\"\\\\$\")) {\n    if (includeDummies) {\n      attrib=attrib.substring(1);\n    }\n else     return null;\n  }\n  if (!StringUtil.startsWithChar(attrib,\'$\')) {\n    return null;\n  }\n  attrib=attrib.substring(1);\n  if (StringUtil.startsWithChar(attrib,\'{\')) {\n    String cleanAttribute=null;\n    for (int i=1; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == \'{\' || currChar == \'.\') {\n        cleanAttribute=null;\n        break;\n      }\n else       if (currChar == \'}\') {\n        cleanAttribute=attrib.substring(1,i);\n        break;\n      }\n    }\n    attrib=cleanAttribute;\n  }\n else {\n    for (int i=0; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == \'{\' || currChar == \'}\' || currChar == \'.\') {\n        attrib=attrib.substring(0,i);\n        break;\n      }\n    }\n  }\n  return attrib;\n}\n", "docstring": "removes each two leading \"'\" \\ \"'\" , removes leading $ , removes { } examples : $ qqq - > qqq \\ $ qqq - > qqq if dummy attributes are collected too , null otherwise \\ \\ $ qqq - > qqq $ { qqq } - > qqq", "partition": "test"}
{"idx": "227", "code": "public void record(RecordBuilderImpl recordBuilder){\n  storeBitmap(recordBuilder);\n  OutputStream viewHierarchyDump=null;\n  try {\n    viewHierarchyDump=mAlbum.openViewHierarchyFile(recordBuilder.getName());\n    mViewHierarchy.deflate(recordBuilder.getView(),viewHierarchyDump);\n    mAlbum.addRecord(recordBuilder);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    if (viewHierarchyDump != null) {\n      try {\n        viewHierarchyDump.close();\n      }\n catch (      IOException e) {\n        Log.e(\"ScreenshotImpl\",\"Exception closing viewHierarchyDump\",e);\n      }\n    }\n  }\n}\n", "docstring": "records the recordbuilderimpl , and verifies if required", "partition": "test"}
{"idx": "228", "code": "protected boolean isCorrectMethod(Method method,Object[] args){\n  return (proxySignature.equals(method.getName()) && args.length == 1);\n}\n", "docstring": "compare the method that was called to the intended method when the osxadapter instance was created ( e . g . handleabout , handlequit , handleopenfile , etc . ) .", "partition": "test"}
{"idx": "229", "code": "public void testCase17(){\n  byte aBytes[]={-127,100,56,7,98,-1,39,-128,127,75};\n  byte bBytes[]={27,-15,65,39,100};\n  int aSign=1;\n  int bSign=1;\n  byte rBytes[]={12,-21,73,56,27};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.remainder(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "remainder of division of two positive numbers", "partition": "test"}
{"idx": "230", "code": "public Metadata.Property.Builder clear(){\n  Metadata_Property_Builder _defaults=new Metadata.Property.Builder();\n  type=_defaults.type;\n  boxedType=_defaults.boxedType;\n  name=_defaults.name;\n  capitalizedName=_defaults.capitalizedName;\n  allCapsName=_defaults.allCapsName;\n  getterName=_defaults.getterName;\n  codeGenerator=_defaults.codeGenerator;\n  fullyCheckedCast=_defaults.fullyCheckedCast;\n  accessorAnnotations.clear();\n  _unsetProperties.clear();\n  _unsetProperties.addAll(_defaults._unsetProperties);\n  return (Metadata.Property.Builder)this;\n}\n", "docstring": "resets the state of this builder .", "partition": "test"}
{"idx": "231", "code": "public static float r_distance(vec3 a,vec3 b){\n  float x=a.m[0] - b.m[0];\n  float y=a.m[1] - b.m[1];\n  float z=a.m[2] - b.m[2];\n  float result=(float)Math.sqrt(x * x + y * y + z * z);\n  return result;\n}\n", "docstring": "\\ brief distance ( vec3 a , vec3 b )", "partition": "test"}
{"idx": "232", "code": "public void checkBackupInfo(final File backupInfoFile,boolean backupInMultiVdc){\n  try (InputStream fis=new FileInputStream(backupInfoFile)){\n    Properties properties=new Properties();\n    properties.load(fis);\n    checkVersion(properties);\n    checkHosts(properties,backupInMultiVdc);\n  }\n catch (  IOException ex) {\n    log.warn(\"Unable to check backup Info\",ex);\n  }\n}\n", "docstring": "checks version and ips", "partition": "test"}
{"idx": "233", "code": "static String toLowerCase(String s){\n  int len=s.length();\n  StringBuilder sb=null;\n  for (int i=0; i < len; i++) {\n    char c=s.charAt(i);\n    if ((c >= \'a\' && c <= \'z\') || (c == \'.\')) {\n      if (sb != null)       sb.append(c);\n    }\n else     if ((c >= \'0\' && c <= \'9\') || (c == \'-\')) {\n      if (sb != null)       sb.append(c);\n    }\n else     if (c >= \'A\' && c <= \'Z\') {\n      if (sb == null) {\n        sb=new StringBuilder(len);\n        sb.append(s,0,i);\n      }\n      sb.append((char)(c - CASE_DIFF));\n    }\n else {\n      throw new IllegalArgumentException(\"Invalid characters in hostname\");\n    }\n  }\n  return sb == null ? s : sb.toString();\n}\n", "docstring": "convert to lower case , and check that all chars are ascii alphanumeric , \"'\" - \"'\" or \"'\" . \"'\" only .", "partition": "test"}
{"idx": "234", "code": "public static void assertProps(UniformPair<EventBean> received,String[] propertyNames,Object[] expectedInsert,Object[] expectedRemoved){\n  assertProps(received.getFirst(),propertyNames,expectedInsert);\n  assertProps(received.getSecond(),propertyNames,expectedRemoved);\n}\n", "docstring": "assert that the property values of a new event and a removed event match the expected insert and removed values .", "partition": "test"}
{"idx": "235", "code": "public int size(){\n  return al.size();\n}\n", "docstring": "returns the number of elements in this set .", "partition": "test"}
{"idx": "236", "code": "public static String toUpperCase(String src){\n  if (src == null) {\n    return null;\n  }\n else {\n    return src.toUpperCase();\n  }\n}\n", "docstring": "safely convert the string to uppercase .", "partition": "test"}
{"idx": "237", "code": "public final Iterator<KnowledgeEdge> requiredEdgesIterator(){\n  Set<KnowledgeEdge> edges=new HashSet<>();\n  for (  OrderedPair<Set<MyNode>> o : requiredRulesSpecs) {\n    final Set<MyNode> first=o.getFirst();\n    for (    MyNode s1 : first) {\n      final Set<MyNode> second=o.getSecond();\n      for (      MyNode s2 : second) {\n        if (!s1.equals(s2)) {\n          edges.add(new KnowledgeEdge(s1.getName(),s2.getName()));\n        }\n      }\n    }\n  }\n  return edges.iterator();\n}\n", "docstring": "iterator over the knowledgeedge \"'\" s representing required edges .", "partition": "test"}
{"idx": "238", "code": "@Deprecated public void unlock(LockState<T> lockState){\n  if (lockState == null) {\n    throw new IllegalArgumentException(\"lockState is null\");\n  }\n  if (lockState.setLock != this) {\n    throw new IllegalArgumentException(\"The lockState passed was not from this instance\");\n  }\n  if (lockState.thread != Thread.currentThread()) {\n    throw new IllegalArgumentException(\"The thread that created this lockState is not the same as the one unlocking it\");\n  }\n  threadSet.remove(Thread.currentThread());\n  for (  ReentrantLock lock : lockState.locks) {\n    lock.unlock();\n  }\n}\n", "docstring": "unlocks the objects acquired from locking . this method should always be in a finally block immediately after the lock . if you try to unlock from another thread , no objects are unlocked .", "partition": "test"}
{"idx": "239", "code": "private static String forceNumberStringToTwoDigits(String text){\n  while (text.length() < 2) {\n    text=\"0\" + text;\n  }\n  if (text.length() > 2) {\n    text=text.substring(text.length() - 2,text.length());\n  }\n  return text;\n}\n", "docstring": "forcenumberstringtotwodigits , this takes a string of digits , and forces it to be two digits long . first any extra leftmost digits are truncated , leaving only the right one digit or right two digits . if there is only one digit , it is zero padded to enforce a two digit string result . this function is used by the datepickerutilities . doesparseddatematchtext ( ) function .", "partition": "test"}
{"idx": "240", "code": "public void addDropItem(final String name,final double probability,final int min,final int max){\n  dropsItems.add(new DropItem(name,probability,min,max));\n}\n", "docstring": "adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn \"'\" t been called first , this will change all creatures of this kind .", "partition": "test"}
{"idx": "241", "code": "public static <E extends Identifiable>List<E> findByPrimaryKeys(EntityManager em,List<BigInteger> ids,Class<E> type){\n  requireArgument(em != null,\"The entity manager cannot be null.\");\n  requireArgument(ids != null && !ids.isEmpty(),\"IDs cannot be null or empty.\");\n  requireArgument(type != null,\"The entity type cannot be null.\");\n  TypedQuery<E> query=em.createNamedQuery(\"JPAEntity.findByPrimaryKeys\",type);\n  query.setHint(\"javax.persistence.cache.storeMode\",\"REFRESH\");\n  try {\n    query.setParameter(\"ids\",ids);\n    query.setParameter(\"deleted\",false);\n    return query.getResultList();\n  }\n catch (  NoResultException ex) {\n    return new ArrayList<>(0);\n  }\n}\n", "docstring": "finds jpa entities by their primary keys .", "partition": "test"}
{"idx": "242", "code": "public int hashCode(){\n  int h=hash;\n  if (h == -1) {\n    try {\n      h=Arrays.hashCode(X509CertImpl.getEncodedInternal(this));\n    }\n catch (    CertificateException e) {\n      h=0;\n    }\n    hash=h;\n  }\n  return h;\n}\n", "docstring": "returns a hashcode value for this certificate from its encoded form .", "partition": "test"}
{"idx": "243", "code": "public static boolean verify(byte[] data,byte[] signature,byte[] pub){\n  Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n  ByteBuffer byteBuff=nativeECDSABuffer.get();\n  if (byteBuff == null) {\n    byteBuff=ByteBuffer.allocateDirect(32 + 8 + 520+ 520);\n    byteBuff.order(ByteOrder.nativeOrder());\n    nativeECDSABuffer.set(byteBuff);\n  }\n  byteBuff.rewind();\n  byteBuff.put(data);\n  byteBuff.putInt(signature.length);\n  byteBuff.putInt(pub.length);\n  byteBuff.put(signature);\n  byteBuff.put(pub);\n  return secp256k1_ecdsa_verify(byteBuff) == 1;\n}\n", "docstring": "verifies the given secp256k1 signature in native code . calling when enabled = = false is undefined ( probably library not loaded )", "partition": "test"}
{"idx": "244", "code": "@SuppressWarnings(\"unchecked\") static public void assertSameIteratorAnyOrder(final Object[] expected,final Iterator actual){\n  assertSameIteratorAnyOrder(\"\",expected,actual);\n}\n", "docstring": "verifies that the iterator visits the specified objects in some arbitrary ordering and that the iterator is exhausted once all expected objects have been visited . the implementation uses a selection without replacement \" pattern \" .", "partition": "test"}
{"idx": "245", "code": "public static String formattingFinishedPercentage(final RolloutGroup rolloutGroup,final float finishedPercentage){\n  float tmpFinishedPercentage=0;\nswitch (rolloutGroup.getStatus()) {\ncase READY:\ncase SCHEDULED:\ncase ERROR:\n    tmpFinishedPercentage=0.0F;\n  break;\ncase FINISHED:\ntmpFinishedPercentage=100.0F;\nbreak;\ncase RUNNING:\ntmpFinishedPercentage=finishedPercentage;\nbreak;\ndefault :\nbreak;\n}\nreturn String.format(\"%.1f\",tmpFinishedPercentage);\n}\n", "docstring": "formats the finished percentage of a rollout group into a string with one digit after comma .", "partition": "test"}
{"idx": "246", "code": "public static String generateHostName(String vmName,String hostId){\n  String hostname=vmName + \'-\' + hostId;\n  Preconditions.checkState(hostname.equals(hostname.toLowerCase()),\"hostname should not contain upper case characters\");\n  return hostname;\n}\n", "docstring": "generates the hostname for a node .", "partition": "test"}
{"idx": "247", "code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }\n", "docstring": "transfer all the sequences listed in the supplied file , interpreting entries appropriately .", "partition": "test"}
{"idx": "248", "code": "private static String unwrap(String expression){\n  if (expression.startsWith(\"((\")) {\n    expression=expression.substring(expression.indexOf(\")\") + 1,expression.length() - 1);\n    if (expression.endsWith(\"]\")) {\n      expression=expression.substring(0,expression.lastIndexOf(\"[\"));\n    }\n else {\n      expression=expression.substring(0,expression.lastIndexOf(\".\"));\n    }\n  }\n  return expression;\n}\n", "docstring": "removes the outermost property from a nested getter expression", "partition": "test"}
{"idx": "249", "code": "protected int drawNextEventTimeDiff(){\n  int timeDiff=msgInterval[0] == msgInterval[1] ? 0 : rng.nextInt(msgInterval[1] - msgInterval[0]);\n  return msgInterval[0] + timeDiff;\n}\n", "docstring": "generates a ( random ) time difference between two events", "partition": "test"}
{"idx": "250", "code": "public static String toBits(final long x){\n  final StringBuilder sb=new StringBuilder();\n  long t=x;\n  for (int i=0; i < 64; i++) {\n    if ((i & 7) == 0 && i > 0) {\n      sb.append(\":\");\n    }\n    sb.append(t < 0 ? \"1\" : \"0\");\n    t=t << 1;\n  }\n  assert t == 0;\n  return sb.toString();\n}\n", "docstring": "convert a number into a bit string with separators between each group of 8 .", "partition": "test"}
{"idx": "251", "code": "public MessageTokenizer(IDiscordClient client,String content){\n  if (content == null)   throw new IllegalArgumentException(\"Content cannot be null!\");\n  if (content.length() == 0)   throw new IllegalArgumentException(\"Content must have length!\");\n  if (client == null)   throw new IllegalArgumentException(\"Client cannot be null!\");\n  this.content=content;\n  this.client=client;\n  stepForward(0);\n}\n", "docstring": "initializes with the string contents .", "partition": "test"}
{"idx": "252", "code": "public void await(int ID) throws InterruptedException {\n  if (parties == 1)   return;\n  final boolean startCondition=competitionCondition;\n  int competingFor=(locks.length * 2 - 1 - ID) / 2;\n  while (competingFor >= 0) {\n    final Lock node=locks[competingFor];\n    if (node.tryLock()) {\nsynchronized (node) {\n        while (competitionCondition == startCondition)         node.wait();\n      }\n      node.unlock();\n      wakeUpTarget(competingFor * 2 + 1);\n      wakeUpTarget(competingFor * 2 + 2);\n      return;\n    }\n else {\n      if (competingFor == 0)       break;\n      competingFor=(competingFor - 1) / 2;\n    }\n  }\n  competitionCondition=!competitionCondition;\n  wakeUpTarget(0);\n}\n", "docstring": "waits for all threads to reach this barrier .", "partition": "test"}
{"idx": "253", "code": "private void loadTranslationsCacheIfEmpty(){\n  if (translationCache.isEmpty()) {\n    for (    ObjectTranslation translation : translations) {\n      if (translation.getLocale() != null && translation.getProperty() != null && !StringUtils.isEmpty(translation.getValue())) {\n        String key=ObjectTranslation.getCacheKey(translation.getLocale(),translation.getProperty());\n        translationCache.put(key,translation.getValue());\n      }\n    }\n  }\n}\n", "docstring": "populates the translationscache map unless it is already populated .", "partition": "test"}
{"idx": "254", "code": "public NavMouseMode(boolean shouldConsumeEvents){\n  super(modeID,shouldConsumeEvents);\n  setModeCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n  rectAttributes.setLinePaint(Color.GRAY);\n  rectAttributes.setMattingPaint(Color.LIGHT_GRAY);\n  rectAttributes.setMatted(true);\n}\n", "docstring": "construct a navmousemode . lets you set the consume mode . if the events are consumed , then a mouseevent is sent only to the first mapmouselistener that successfully processes the event . if they are not consumed , then all of the listeners get a chance to act on the event .", "partition": "test"}
{"idx": "255", "code": "public void addEvent(SimEvent newEvent){\n  newEvent.setSerial(serial++);\n  sortedSet.add(newEvent);\n}\n", "docstring": "adds a new event to the queue . adding a new event to the queue preserves the temporal order of the events in the queue .", "partition": "test"}
{"idx": "256", "code": "public String toStringSummary(){\n  int resultsetLength;\n  String result;\n  String titles;\n  int i;\n  int j;\n  if (m_NonSigWins == null)   return \"-summary data not set-\";\n  resultsetLength=1 + Math.max((int)(Math.log(getColCount()) / Math.log(10)),(int)(Math.log(getRowCount()) / Math.log(10)));\n  result=\"\";\n  titles=\"\";\n  result+=\"{\\\\centering\\n\";\n  result+=\"\\\\begin{table}[thb]\\n\\\\caption{\\\\label{labelname}\" + \"Table Caption}\\n\";\n  result+=\"\\\\footnotesize\\n\";\n  result+=\"\\\\begin{tabular}{l\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    titles+=\" &\";\n    result+=\"c\";\n    titles+=\' \' + Utils.padLeft(\"\" + getSummaryTitle(i),resultsetLength * 2 + 3);\n  }\n  result+=\"}\\\\\\\\\\n\\\\hline\\n\";\n  result+=titles + \" \\\\\\\\\\n\\\\hline\\n\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    for (j=0; j < getColCount(); j++) {\n      if (getColHidden(j))       continue;\n      if (j == 0)       result+=(char)((int)\'a\' + i % 26);\n      if (j == i)       result+=\" & - \";\n else       result+=\"& \" + m_NonSigWins[i][j] + \" (\"+ m_Wins[i][j]+ \") \";\n    }\n    result+=\"\\\\\\\\\\n\";\n  }\n  result+=\"\\\\hline\\n\\\\end{tabular} \\\\footnotesize \\\\par\\n\\\\end{table}}\";\n  return result;\n}\n", "docstring": "returns the summary as string .", "partition": "test"}
{"idx": "257", "code": "public static File createTempPath(String path) throws IOException {\n  String sep=File.separator;\n  File tempDir=new File(System.getProperty(\"java.io.tmpdir\") + sep + path);\n  if (!tempDir.exists())   if (!tempDir.mkdirs()) {\n    boolean status=tempDir.delete();\n    throw new IOException(\"creation failed for dir \" + tempDir + \"status = \"+ status);\n  }\n  tempDir.deleteOnExit();\n  return tempDir;\n}\n", "docstring": "create a hierarchy of directories ( a path ) in the designated temp dir . if the jvm terminates normally , these will be cleaned up .", "partition": "test"}
{"idx": "258", "code": "public void hspan(double start,double end,Paint color,String legend){\n  LegendText legendText=new LegendText(color,legend);\n  comments.add(legendText);\n  plotElements.add(new HSpan(start,end,color,legendText));\n}\n", "docstring": "draws a horizontal span into the graph and optionally adds a legend .", "partition": "test"}
{"idx": "259", "code": "public StateInteractive extent_to_whole_connections(){\n  Set<BrdItem> selected_items=new TreeSet<BrdItem>();\n  for (  BrdItem curr_item : items_list) {\n    if (curr_item instanceof BrdConnectable) {\n      selected_items.addAll(curr_item.get_connection_items());\n    }\n  }\n  if (selected_items.isEmpty()) {\n    return return_state;\n  }\n  items_list=selected_items;\n  actlog_start_scope(LogfileScope.EXTEND_TO_WHOLE_CONNECTIONS);\n  filter();\n  i_brd.repaint();\n  return this;\n}\n", "docstring": "select also all items belonging to any connection of the current selected items .", "partition": "test"}
{"idx": "260", "code": "public static IKeyBuilder newInstance(int capacity,CollatorEnum collatorChoice,Locale locale,Object strength,DecompositionEnum mode){\n  if (collatorChoice == CollatorEnum.ASCII) {\n    return new KeyBuilder(capacity);\n  }\n  if (locale == null) {\n    locale=Locale.getDefault();\n    if (log.isInfoEnabled())     log.info(\"Using default locale: \" + locale.getDisplayName());\n  }\n  final boolean icu=collatorChoice == CollatorEnum.ICU;\n  if (icu && !DefaultKeyBuilderFactory.isICUAvailable()) {\n    throw new UnsupportedOperationException(DefaultKeyBuilderFactory.ICU_NOT_AVAILABLE);\n  }\n  final byte[] buf=createBuffer(capacity);\n  final int len=0;\nswitch (collatorChoice) {\ncase ICU:\n    return new KeyBuilder(new ICUSortKeyGenerator(locale,strength,mode),len,buf);\ncase JDK:\n  return new KeyBuilder(new JDKSortKeyGenerator(locale,strength,mode),len,buf);\ndefault :\nthrow new UnsupportedOperationException(\"Collator not supported: \" + collatorChoice);\n}\n}\n", "docstring": "create a new instance that optionally supports unicode sort keys .", "partition": "test"}
{"idx": "261", "code": "protected void configureFromProperties(InputStream is,String rootDirectory) throws IOException {\n  Properties props=new Properties();\n  props.load(is);\n  props.put(ROOT_DIR_PATH_PROPERTY,rootDirectory);\n  String oldPrefix=getPropertyPrefix();\n  setProperties(null,props);\n  setPropertyPrefix(oldPrefix);\n}\n", "docstring": "called with an input stream for a properties file , used for reading tiles . omp files .", "partition": "test"}
{"idx": "262", "code": "Connection openNewConnection() throws SQLException {\n  Connection newConn=DriverManager.getConnection(url,user,password);\n  if (url.startsWith(\"jdbc:derby:\")) {\n    try (Statement s=newConn.createStatement()){\n    }\n   }\n else   if (url.startsWith(\"jdbc:hsqldb:\")) {\n    try (Statement s=newConn.createStatement()){\n      s.execute(\"SET WRITE_DELAY 1\");\n    }\n   }\n  return newConn;\n}\n", "docstring": "open a new database connection . this connection must be closed by calling conn . close ( ) .", "partition": "test"}
{"idx": "263", "code": "@Override public void addRelations(Task task,Iterable<ObjectId> projectIds,String fieldName){\n  List<Project> newProjectList=new LinkedList<>();\n  Iterable<Project> projectsToAdd=projectRepository.findAll(projectIds,null);\n  for (  Project project : projectsToAdd) {\n    newProjectList.add(project);\n  }\n  try {\n    if (PropertyUtils.getProperty(task,fieldName) != null) {\n      Iterable<Project> projects=(Iterable<Project>)PropertyUtils.getProperty(task,fieldName);\n      for (      Project project : projects) {\n        newProjectList.add(project);\n      }\n    }\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  try {\n    PropertyUtils.setProperty(task,fieldName,newProjectList);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  taskRepository.save(task);\n}\n", "docstring": "a simple implementation of the addrelations method which presents the general concept of the method . it should not be used in production because of possible race condition - production ready code should perform an atomic operation .", "partition": "test"}
{"idx": "264", "code": "protected void doFloodBDDP(long pinSwitch,OFPacketIn pi,FloodlightContext cntx){\n  TopologyInstance ti=getCurrentInstance(false);\n  Set<Long> switches=ti.getSwitchesInOpenflowDomain(pinSwitch);\n  if (switches == null) {\n    switches=new HashSet<Long>();\n    switches.add(pinSwitch);\n  }\n  for (  long sid : switches) {\n    IOFSwitch sw=floodlightProvider.getSwitch(sid);\n    if (sw == null)     continue;\n    Collection<Short> enabledPorts=sw.getEnabledPortNumbers();\n    if (enabledPorts == null)     continue;\n    Set<Short> ports=new HashSet<Short>();\n    ports.addAll(enabledPorts);\n    Set<Short> portsKnownToTopo=ti.getPortsWithLinks(sid);\n    if (portsKnownToTopo != null) {\n      for (      short p : portsKnownToTopo) {\n        NodePortTuple npt=new NodePortTuple(sid,p);\n        if (ti.isBroadcastDomainPort(npt) == false) {\n          ports.remove(p);\n        }\n      }\n    }\n    Set<Short> portsToEliminate=getPortsToEliminateForBDDP(sid);\n    if (portsToEliminate != null) {\n      ports.removeAll(portsToEliminate);\n    }\n    if (pinSwitch == sid) {\n      ports.remove(pi.getInPort());\n    }\n    doMultiActionPacketOut(pi.getPacketData(),sw,ports,cntx);\n  }\n}\n", "docstring": "the bddp packets are forwarded out of all the ports out of an openflowdomain . get all the switches in the same openflow domain as the sw ( disabling tunnels ) . then get all the external switch ports and send these packets out .", "partition": "test"}
{"idx": "265", "code": "public void sleepMillis(final long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  final InterruptedException e) {\n    logger.error(e,e);\n  }\n}\n", "docstring": "waits the specified number of milliseconds .", "partition": "test"}
{"idx": "266", "code": "private static void verifyWriteSetNotFound(final BTree btree){\n  log.info(\"\");\n  for (int i=0; i < 1000; i++) {\n    if (btree.contains(i)) {\n      throw new RuntimeException(\"Not expecting: key=\" + i);\n    }\n  }\n}\n", "docstring": "verify that the write set is not found ( no keys in [ 0 : 1000 ) ) .", "partition": "test"}
{"idx": "267", "code": "private double calculateEntropy(double... masses){\n  double res=0;\n  for (  double d : masses) {\n    res-=(d == 0) ? 0 : d * Math.log(d);\n  }\n  return res / LOG2;\n}\n", "docstring": "calculates the entropy corresponding to the input masses .", "partition": "test"}
{"idx": "268", "code": "@Override public void mousePressed(MouseEvent e){\n  m_frameLimiter.setRepeats(true);\n  if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && !e.isAltDown() && m_mouseState == 0 && m_scaling == 0) {\n    if (((e.getModifiers() & InputEvent.CTRL_MASK) != 0) && ((e.getModifiers() & InputEvent.SHIFT_MASK) == 0)) {\n      m_mouseState=2;\n    }\n else     if (((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) && ((e.getModifiers() & InputEvent.CTRL_MASK) == 0)) {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=3;\n      Graphics g=getGraphics();\n      if (m_ZoomBoxColor == null) {\n        g.setColor(Color.black);\n      }\n else {\n        g.setColor(m_ZoomBoxColor);\n      }\n      if (m_ZoomBoxXORColor == null) {\n        g.setXORMode(Color.white);\n      }\n else {\n        g.setXORMode(m_ZoomBoxXORColor);\n      }\n      g.drawRect(m_oldMousePos.width,m_oldMousePos.height,m_newMousePos.width - m_oldMousePos.width,m_newMousePos.height - m_oldMousePos.height);\n      g.dispose();\n    }\n else {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=1;\n      m_frameLimiter.start();\n    }\n  }\n else   if ((e.getButton() == MouseEvent.BUTTON1) && e.isAltDown() && e.isShiftDown()&& !e.isControlDown()) {\n    saveComponent();\n  }\n else   if (m_mouseState == 0 && m_scaling == 0) {\n  }\n}\n", "docstring": "determines what action the user wants to perform .", "partition": "test"}
{"idx": "269", "code": "private static double parseDoubleValue(String parseString,String openTag,String closeTag,DataTypeValidationException exception) throws DataTypeValidationException {\n  String tagValue;\n  tagValue=parseStringValue(parseString,openTag,closeTag,exception);\n  double doubleValue;\n  try {\n    doubleValue=Double.parseDouble(tagValue);\n  }\n catch (  NumberFormatException e) {\n    throw e;\n  }\n  return doubleValue;\n}\n", "docstring": "parses out and converts the text located between first occurrences of the open and closed tags into double .", "partition": "test"}
{"idx": "270", "code": "public void putString(String s) throws ArrayIndexOutOfBoundsException, UnsupportedEncodingException {\n  byte[] bytes=s.getBytes(\"UTF-8\");\n  int length=bytes.length;\n  int endAt=m_index + length + 1;\n  if (endAt > m_content.length)   throw new ArrayIndexOutOfBoundsException(endAt + \" > \" + m_content.length);\n  System.arraycopy(bytes,0,m_content,m_index,length);\n  m_index+=length;\n  m_content[m_index++]=\'\\0\';\n  debugAppendString(s);\n}\n", "docstring": "place a string into the message ( using utf - 8 encoding )", "partition": "test"}
{"idx": "271", "code": "public void addRtcpListener(RtcpEventListener listener){\n  listeners.addElement(listener);\n}\n", "docstring": "add a rtcp event listener", "partition": "test"}
{"idx": "272", "code": "@Override protected void ensureNumberOfColumns(int numberOfColumns){\n  if (data.length >= numberOfColumns) {\n    return;\n  }\n  double[] newData=new double[numberOfColumns];\n  System.arraycopy(data,0,newData,0,data.length);\n  data=newData;\n}\n", "docstring": "creates a new array of the given size if necessary and copies the data into the new array .", "partition": "test"}
{"idx": "273", "code": "@Override public void error(String domain,String key,XMLParseException exception) throws XNIException {\n  if (fErrorHandler != null) {\n    SAXParseException saxException=createSAXParseException(exception);\n    try {\n      fErrorHandler.error(saxException);\n    }\n catch (    SAXParseException e) {\n      throw createXMLParseException(e);\n    }\ncatch (    SAXException e) {\n      throw createXNIException(e);\n    }\n  }\n}\n", "docstring": "reports an error . errors are non - fatal and usually signify that the document is invalid with respect to its grammar ( s ) .", "partition": "test"}
{"idx": "274", "code": "public CStatusPanel(final BackEndDebuggerProvider debuggerProvider){\n  super(new BorderLayout());\n  Preconditions.checkNotNull(debuggerProvider,\"IE1094: Debugger provider argument can not be null\");\n  m_label.setForeground(Color.BLACK);\n  add(m_label);\n  m_synchronizer=new CStatusLabelSynchronizer(m_label,debuggerProvider);\n}\n", "docstring": "creates a new status panel .", "partition": "test"}
{"idx": "275", "code": "@Override public boolean open(String access){\n  if (access.equals(\"r\")) {\n    try {\n      iStream=new FileImageInputStream(new File(filePath));\n      parser=new LabelParser();\n      metadata=parser.parseHeader(iStream);\n      iStream.close();\n      iStream=null;\n    }\n catch (    IOException e) {\n      try {\n        iStream.close();\n      }\n catch (      Exception x) {\n      }\n      return (false);\n    }\n  }\n  return (super.open(access));\n}\n", "docstring": "open the pds file .", "partition": "test"}
{"idx": "276", "code": "@Nullable public String fileName(){\n  return JavaLogger.fileName(delegate);\n}\n", "docstring": "returns current log file .", "partition": "test"}
{"idx": "277", "code": "public static BNode parseBNode(String nTriplesBNode,ValueFactory valueFactory) throws IllegalArgumentException {\n  if (nTriplesBNode.startsWith(\"_:\")) {\n    return valueFactory.createBNode(nTriplesBNode.substring(2));\n  }\n else {\n    throw new IllegalArgumentException(\"Not a legal N-Triples Blank Node: \" + nTriplesBNode);\n  }\n}\n", "docstring": "parses an n - triples bnode , creates an object for it using the supplied valuefactory and returns this object .", "partition": "test"}
{"idx": "278", "code": "public void resetPSRs(){\n  pilotRolls.removeAllElements();\n}\n", "docstring": "resets the psr list .", "partition": "test"}
{"idx": "279", "code": "public static void sort(byte[] array){\n  DualPivotQuicksort.sort(array);\n}\n", "docstring": "sorts the specified array in ascending numerical order .", "partition": "test"}
{"idx": "280", "code": "public void freeObject(int id){\n  if (cacheId == id) {\n    cacheId=-1;\n    cache=null;\n  }\n  map.remove(id);\n}\n", "docstring": "remove an object from the map .", "partition": "test"}
{"idx": "281", "code": "private void stretchViewVertically(View view,int crossSize){\n  LayoutParams lp=(LayoutParams)view.getLayoutParams();\n  int newHeight=crossSize - lp.topMargin - lp.bottomMargin;\n  newHeight=Math.max(newHeight,0);\n  view.measure(MeasureSpec.makeMeasureSpec(view.getMeasuredWidth(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(newHeight,MeasureSpec.EXACTLY));\n}\n", "docstring": "expand the view vertically to the size of the crosssize ( considering the view margins )", "partition": "test"}
{"idx": "282", "code": "public static InetAddress hexToInet6Address(String addrHexString) throws IllegalArgumentException {\n  try {\n    return numericToInetAddress(String.format(\"%s:%s:%s:%s:%s:%s:%s:%s\",addrHexString.substring(0,4),addrHexString.substring(4,8),addrHexString.substring(8,12),addrHexString.substring(12,16),addrHexString.substring(16,20),addrHexString.substring(20,24),addrHexString.substring(24,28),addrHexString.substring(28,32)));\n  }\n catch (  Exception e) {\n    Log.e(\"NetworkUtils\",\"error in hexToInet6Address(\" + addrHexString + \"): \"+ e);\n    throw new IllegalArgumentException(e);\n  }\n}\n", "docstring": "convert a 32 char hex string into a inet6address . throws a runtime exception if the string isn \"'\" t 32 chars , isn \"'\" t hex or can \"'\" t be made into an inet6address", "partition": "test"}
{"idx": "283", "code": "public double readDouble() throws IOException {\n  return primitiveTypes.readDouble();\n}\n", "docstring": "reads a double ( 64 bit ) from the source stream .", "partition": "test"}
{"idx": "284", "code": "private boolean isAtMaximum(Adjustable bar){\n  return (bar.getValue() + bar.getVisibleAmount() >= bar.getMaximum());\n}\n", "docstring": "check if a scroll bar is at its maximum value .", "partition": "test"}
{"idx": "285", "code": "protected void parseAndAddMapTileSet(URL tileSetProperties) throws IOException, MalformedURLException {\n  Properties descProps=new Properties();\n  Logger logger=getLogger();\n  logger.info(\"going to read props\");\n  InputStream descURLStream=tileSetProperties.openStream();\n  descProps.load(descURLStream);\n  logger.info(\"loaded \" + tileSetProperties.toString() + \" \"+ descProps.toString());\n  MapTileSet mts=createMapTileSetFromProperties(descProps);\n  if (mts != null && mts.allGood()) {\n    String mtsName=mts.getName();\n    mapTileSets.put(mts.getName(),mts);\n    logger.info(\"Adding \" + mtsName + \" dataset\");\n  }\n  descURLStream.close();\n}\n", "docstring": "given a url to a properties file describing a maptileset , create it and add it to the list .", "partition": "test"}
{"idx": "286", "code": "protected Date compute(double value){\n  if (Double.isNaN(value)) {\n    return null;\n  }\n  long dateLong=(long)value;\n  Date date=new Date(dateLong);\n  Calendar cal=Calendar.getInstance();\n  cal.setTime(date);\n  return cal.getTime();\n}\n", "docstring": "computes the result for one input double value .", "partition": "test"}
{"idx": "287", "code": "public void enablePan(BluetoothAdapter adapter){\n  if (mPan == null)   mPan=(BluetoothPan)connectProxy(adapter,BluetoothProfile.PAN);\n  assertNotNull(mPan);\n  long start=System.currentTimeMillis();\n  mPan.setBluetoothTethering(true);\n  long stop=System.currentTimeMillis();\n  assertTrue(mPan.isTetheringOn());\n  writeOutput(String.format(\"enablePan() completed in %d ms\",(stop - start)));\n}\n", "docstring": "enables pan tethering on the local device and checks to make sure that tethering is enabled .", "partition": "test"}
{"idx": "288", "code": "private int distBetweenPoints(int x1,int z1,int x2,int z2,boolean bAllowDiags){\n  int w=Math.abs(x2 - x1);\n  int h=Math.abs(z2 - z1);\n  if (bAllowDiags) {\n    if (w < h)     w=0;\n else     h=0;\n  }\n  return w + h + 1;\n}\n", "docstring": "calculate the number of cells on the shortest path between ( x1 , z1 ) and ( x2 , z2 )", "partition": "test"}
{"idx": "289", "code": "private Workflow.Method createVolumesMethod(URI systemURI,URI poolURI,List<URI> volumeURIs,VirtualPoolCapabilityValuesWrapper capabilities){\n  return new Workflow.Method(\"createVolumes\",systemURI,poolURI,volumeURIs,capabilities);\n}\n", "docstring": "return a workflow . method for createvolumes .", "partition": "test"}
{"idx": "290", "code": "public FileCommandInfo(int fd,String command,int result,String parameters){\n  this(true,fd,command,result,parameters);\n}\n", "docstring": "example : 0x1001 , \" close \" , 0x0 , \" \"", "partition": "test"}
{"idx": "291", "code": "public void init(GuiManualHerblore manual){\n  for (  ManualWidgetBase widget : widgets)   widget.init(manual);\n}\n", "docstring": "initializes the widgets in this page", "partition": "test"}
{"idx": "292", "code": "public final double sampleMax(){\n  return _activeCountMax.getAndSet(_activeCount.get());\n}\n", "docstring": "sample the active count", "partition": "test"}
{"idx": "293", "code": "@Get public Representation userCodeForm() throws OAuth2RestletException, InvalidGrantException, NotFoundException, ServerException {\n  final OAuth2Request request=requestFactory.create(getRequest());\n  if (request.getParameter(OAuth2Constants.DeviceCode.USER_CODE) != null) {\n    return verify(null);\n  }\n else {\n    return getTemplateRepresentation(FORM,request,null);\n  }\n}\n", "docstring": "handles get requests to the oauth2 device / user endpoint , returning a form to allow the user to submit their user code", "partition": "test"}
{"idx": "294", "code": "public void testMissionNameConstruction(){\n  String xml=\"\";\n  xml+=createStartMissionXml(\"\",\"Name\");\n  xml+=createEndMissionXml();\n  InputStream missionInputStream=new ByteArrayInputStream(xml.getBytes());\n  String missionName=null;\n  try {\n    missionName=MissionParser.getMissionName(missionInputStream);\n  }\n catch (  MissionParseException e) {\n    e.printStackTrace();\n  }\n  Assert.assertEquals(\"Name\",missionName);\n}\n", "docstring": "test for correct reading of a mission name .", "partition": "test"}
{"idx": "295", "code": "public double unsafeSabrVolatility(final double strike,final double forward,final double expiryTime,final double alpha,final double beta,final double nu,final double rho){\n  final double oneMinusBeta=1.0 - beta;\n  final double A=Math.pow(forward * strike,oneMinusBeta);\n  final double sqrtA=Math.sqrt(A);\n  double logM;\n  if (!isClose(forward,strike))   logM=Math.log(forward / strike);\n else {\n    final double epsilon=(forward - strike) / strike;\n    logM=epsilon - .5 * epsilon * epsilon;\n  }\n  final double z=(nu / alpha) * sqrtA * logM;\n  final double B=1.0 - 2.0 * rho * z + z * z;\n  final double C=oneMinusBeta * oneMinusBeta * logM* logM;\n  final double tmp=(Math.sqrt(B) + z - rho) / (1.0 - rho);\n  final double xx=Math.log(tmp);\n  final double D=sqrtA * (1.0 + C / 24.0 + C * C / 1920.0);\n  final double d=1.0 + expiryTime * (oneMinusBeta * oneMinusBeta * alpha* alpha / (24.0 * A) + 0.25 * rho * beta* nu* alpha / sqrtA + (2.0 - 3.0 * rho * rho) * (nu * nu / 24.0));\n  double multiplier;\n  final double m=10;\n  if (Math.abs(z * z) > Constants.QL_EPSILON * m)   multiplier=z / xx;\n else {\n    final double talpha=(0.5 - rho * rho) / (1.0 - rho);\n    final double tbeta=alpha - .5;\n    final double tgamma=rho / (1 - rho);\n    multiplier=1.0 - beta * z + (tgamma - talpha + tbeta * tbeta * .5) * z * z;\n  }\n  return (alpha / D) * multiplier * d;\n}\n", "docstring": "computes the black equivalent volatility without validating parameters", "partition": "test"}
{"idx": "296", "code": "public void close(){\n  while (!mReceivers.isEmpty()) {\n    mContext.unregisterReceiver(mReceivers.remove(0));\n  }\n  if (mOutputWriter != null) {\n    try {\n      mOutputWriter.close();\n    }\n catch (    IOException e) {\n      Log.w(mTag,\"Test output file could not be closed\",e);\n    }\n  }\n}\n", "docstring": "closes the utility instance and unregisters any broadcastreceivers .", "partition": "test"}
{"idx": "297", "code": "private void resolveFiles(List<String> classpaths,Map<String,String> files,String[] paths,String prefix){\n  for (  String path : paths) {\n    String relativePath=fileHandler.getName(path);\n    if (prefix != null) {\n      relativePath=fileHandler.append(prefix,relativePath);\n    }\n    if (classpaths != null) {\n      classpaths.add(relativePath);\n    }\n    if (fileHandler.isDirectory(path)) {\n      String[] children=fileHandler.getChildren(path);\n      if (children != null && children.length != 0) {\n        resolveFiles(null,files,children,relativePath);\n      }\n    }\n else {\n      files.put(relativePath,path);\n    }\n  }\n}\n", "docstring": "resolves all files it finds into a map , with relative paths as the key and absolute path as the value .", "partition": "test"}
{"idx": "298", "code": "public synchronized void reloadConfiguration(){\n  properties=null;\n  finalParameters.clear();\n}\n", "docstring": "reload configuration from previously added resources . this method will clear all the configuration read from the added resources , and final parameters . this will make the resources to be read again before accessing the values . values that are added via set methods will overlay values read from the resources .", "partition": "test"}
{"idx": "299", "code": "protected void removeMessageProcessor(MessageProcessor oldMessageProcessor){\nsynchronized (messageProcessors) {\n    if (messageProcessors.remove(oldMessageProcessor)) {\n      oldMessageProcessor.stop();\n    }\n  }\n}\n", "docstring": "removes a messageprocessor from this sipstack .", "partition": "test"}
{"idx": "300", "code": "X509IssuerSerial(X509Certificate cert){\n  this(cert.getIssuerX500Principal(),cert.getSerialNumber());\n}\n", "docstring": "construct an x509issuerserial from an x509certificate .", "partition": "test"}
{"idx": "301", "code": "private void addToSet(ObjectXmlPersist persist,IFile file,String setName) throws IOException, CoreException {\n  Collection<GraphEdgeMatcherDescriptor> updateSet=loadEdgeMatchers(persist,file);\n  persistUpdatedBundle(persist,file,updateSet,setName);\n}\n", "docstring": "add the set to an existing file .", "partition": "test"}
{"idx": "302", "code": "public void putBytes(byte[] bytes){\n  ensureCapacity(bytes.length);\n  System.arraycopy(bytes,0,this.byteBuffer,this.position,bytes.length);\n  this.position+=bytes.length;\n}\n", "docstring": "put an array of bytes in the buffer .", "partition": "test"}
{"idx": "303", "code": "public static String arrayToDelimitedString(Object[] arr,String delim){\n  if (arr == null) {\n    return \"\";\n  }\n  StringBuffer sb=new StringBuffer();\n  for (int i=0; i < arr.length; i++) {\n    if (i > 0) {\n      sb.append(delim);\n    }\n    sb.append(arr[i]);\n  }\n  return sb.toString();\n}\n", "docstring": "convenience method to return a string array as a delimited ( e . g . csv ) string . e . g . useful for tostring ( ) implementations .", "partition": "test"}
{"idx": "304", "code": "public static CompiereColor parse(String attributes){\n  CompiereColor cc=new CompiereColor();\n  try {\n    if (attributes != null && attributes.length() > 0)     cc.parseAttributres(attributes);\n  }\n catch (  Exception e) {\n    log.severe(\"(\" + attributes + \") - \"+ e.toString());\n  }\n  return cc;\n}\n", "docstring": "parse attributes and return adempierecolor", "partition": "test"}
{"idx": "305", "code": "public synchronized static LuaState newLuaState(){\n  int i=getNextStateIndex();\n  LuaState L=new LuaState(i);\n  states.add(i,L);\n  return L;\n}\n", "docstring": "method that creates a new instance of luastate", "partition": "test"}
{"idx": "306", "code": "static long checkPreambleSize(Memory mem){\n  final long cap=mem.getCapacity();\n  if (cap < 8) {\n    throwNotBigEnough(cap,8);\n  }\n  final long pre0=mem.getLong(0);\n  final int preLongs=(int)(pre0 & 0X3FL);\n  final int required=Math.max(preLongs << 3,8);\n  if (cap < required) {\n    throwNotBigEnough(cap,required);\n  }\n  return pre0;\n}\n", "docstring": "checks memory for capacity to hold the preamble and returns the first 8 bytes .", "partition": "test"}
{"idx": "307", "code": "public int read() throws IOException {\n  if (inputStream == null) {\n    reopen();\n  }\n  count(1);\n  return inputStream.read();\n}\n", "docstring": "read from the file .", "partition": "test"}
{"idx": "308", "code": "public void shutdown(){\n  final long begin=System.currentTimeMillis();\n  log.info(\"ThreadPoolManager: Shutting down.\");\n  log.info(\"\\t... executing \" + getTaskCount(scheduledPool) + \" scheduled tasks.\");\n  log.info(\"\\t... executing \" + getTaskCount(instantPool) + \" instant tasks.\");\n  log.info(\"\\t... executing \" + getTaskCount(longRunningPool) + \" long running tasks.\");\n  log.info(\"\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  scheduledPool.shutdown();\n  instantPool.shutdown();\n  longRunningPool.shutdown();\n  workStealingPool.shutdown();\n  boolean success=false;\n  try {\n    success|=awaitTermination(5000);\n    scheduledPool.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    scheduledPool.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    success|=awaitTermination(10000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  log.info(\"\\t... success: \" + success + \" in \"+ (System.currentTimeMillis() - begin)+ \" msec.\");\n  log.info(\"\\t... \" + getTaskCount(scheduledPool) + \" scheduled tasks left.\");\n  log.info(\"\\t... \" + getTaskCount(instantPool) + \" instant tasks left.\");\n  log.info(\"\\t... \" + getTaskCount(longRunningPool) + \" long running tasks left.\");\n  log.info(\"\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  workStealingPool.shutdownNow();\n}\n", "docstring": "shutdown all thread pools .", "partition": "test"}
{"idx": "309", "code": "public static Collection<InetAddress> toInetAddresses(Collection<String> addrs,Collection<String> hostNames) throws IgniteCheckedException {\n  Set<InetAddress> res=new HashSet<>(addrs.size());\n  Iterator<String> hostNamesIt=hostNames.iterator();\n  for (  String addr : addrs) {\n    String hostName=hostNamesIt.hasNext() ? hostNamesIt.next() : null;\n    InetAddress inetAddr=null;\n    if (!F.isEmpty(hostName)) {\n      try {\n        inetAddr=InetAddress.getByName(hostName);\n      }\n catch (      UnknownHostException ignored) {\n      }\n    }\n    if (inetAddr == null || inetAddr.isLoopbackAddress()) {\n      try {\n        inetAddr=InetAddress.getByName(addr);\n      }\n catch (      UnknownHostException ignored) {\n      }\n    }\n    if (inetAddr != null)     res.add(inetAddr);\n  }\n  if (res.isEmpty())   throw new IgniteCheckedException(\"Addresses can not be resolved [addr=\" + addrs + \", hostNames=\"+ hostNames+ \']\');\n  return res;\n}\n", "docstring": "returns tha list of resolved inet addresses . first addresses are resolved by host names , if this attempt fails then the addresses are resolved by ip addresses .", "partition": "test"}
{"idx": "310", "code": "public static String removeNewLineChars(String s){\n  String retString=null;\n  if ((s != null) && (s.length() > 0) && (s.indexOf('\\n') != -1)) {\n    char[] chars=s.toCharArray();\n    int len=chars.length;\n    StringBuffer sb=new StringBuffer(len);\n    for (int i=0; i < len; i++) {\n      char c=chars[i];\n      if (c != '\\n') {\n        sb.append(c);\n      }\n    }\n    retString=sb.toString();\n  }\n else {\n    retString=s;\n  }\n  return retString;\n}\n", "docstring": "removes new line charactors .", "partition": "test"}
{"idx": "311", "code": "void calculateCounters(){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  int total=0;\n  write.lock();\n  try {\n    countResetFeedsAndCategories();\n    total+=countFeedsWithUnread();\n    countCategoriesWithUnread();\n    countSpecialCategories(total);\n  }\n  finally {\n    write.unlock();\n  }\n  Log.i(TAG,String.format(\"Recalculated counters, total unread: %s (took %sms)\",total,(System.currentTimeMillis() - time)));\n}\n", "docstring": "set unread counters for feeds and categories according to real amount of unread articles . split up the tasks in single transactions so we can do other work in between .", "partition": "test"}
{"idx": "312", "code": "protected void appendHTML(final StringBuilder sbuf,final char ch){\nswitch (ch) {\ncase \'<\':\n    sbuf.append(\"&lt;\");\n  break;\ncase \'>\':\nsbuf.append(\"&gt;\");\nbreak;\ncase \'&\':\nsbuf.append(\"&amp;\");\nbreak;\ndefault :\nsbuf.append(ch);\nbreak;\n}\n}\n", "docstring": "append a character to a buffer , escaping html meta - characters when needed .", "partition": "test"}
{"idx": "313", "code": "private Collection<Var> migrateColumns(SQLTable currentTable){\n  List<Var> vars=new ArrayList<>();\n  String tableType=currentTable.getEntityType();\n  Map<String,ResourceType.DataType> columns=currentTable.getColumns();\n  Map<String,String> foreignColumns=currentTable.getForeignKeyColumns();\n  for (  String column : columns.keySet()) {\n    ResourceType.DataType columnType=columns.get(column);\n    if (foreignColumns.containsKey(column)) {\n      vars.addAll(migrateAsRelation(tableType,column,foreignColumns.get(column)));\n    }\n else {\n      vars.addAll(migrateAsResource(tableType,columnType,column));\n    }\n  }\n  return vars;\n}\n", "docstring": "loop through each of the columns in the given table , migrating each as a resource or relation .", "partition": "test"}
{"idx": "314", "code": "public int retrieveRowCount(String tableName) throws SQLException {\n  ResultSet rs=null;\n  int rowCount=-1;\n  try {\n    rs=statement.executeQuery(\"SELECT COUNT(*) FROM \" + tableName);\n    rs.next();\n    rowCount=rs.getInt(1);\n  }\n  finally {\n    if (rs != null) {\n      rs.close();\n    }\n  }\n  return rowCount;\n}\n", "docstring": "does a count on a given table .", "partition": "test"}
{"idx": "315", "code": "@Override public int addAttribute(Attribute a){\n  if (a == null) {\n    throw new IllegalArgumentException(\"Attribute must not be null\");\n  }\n else {\n    int index=-1;\n    Attribute original=a;\n    a=(Attribute)a.clone();\n    if (unusedColumnList.size() > 0) {\nsynchronized (unusedColumnList) {\n        if (unusedColumnList.size() > 0) {\n          index=unusedColumnList.remove(0);\n          attributes.set(index,a);\n        }\n else {\n          index=attributes.size();\n          attributes.add(a);\n        }\n      }\n    }\n else {\n      index=attributes.size();\n      attributes.add(a);\n    }\n    a.setTableIndex(index);\n    original.setTableIndex(index);\n    return index;\n  }\n}\n", "docstring": "adds the attribute to the list of attributes assigning it a free column index . if the name is already in use , the attribute will be renamed .", "partition": "test"}
{"idx": "316", "code": "default B with(String key,int value){\n  return with(key,Integer.toString(value));\n}\n", "docstring": "associate the given value with the specified key .", "partition": "test"}
{"idx": "317", "code": "public static <X>void sortTopN(X[] array,int offset,int limit,Comparator<? super X> comp){\n  partitionTopN(array,offset,limit,comp);\n  Arrays.sort(array,offset,(int)Math.min((long)offset + limit,array.length),comp);\n}\n", "docstring": "find the top limit values using given comparator and place them as in a full array sort , in descending order .", "partition": "test"}
{"idx": "318", "code": "protected boolean isServerTransaction(){\n  return this instanceof SIPServerTransaction;\n}\n", "docstring": "a shortcut way of telling if we are a server transaction .", "partition": "test"}
{"idx": "319", "code": "public static void readFully(InputStream in,byte buf[],int off,int len) throws IOException {\n  int toRead=len;\n  while (toRead > 0) {\n    int ret=in.read(buf,off,toRead);\n    if (ret < 0) {\n      throw new IOException(\"Premature EOF from inputStream\");\n    }\n    toRead-=ret;\n    off+=ret;\n  }\n}\n", "docstring": "does the readfully based on the input read .", "partition": "test"}
{"idx": "320", "code": "public static void assumeTrue(BooleanSupplier assumptionSupplier,Supplier<String> messageSupplier) throws TestAbortedException {\n  if (!assumptionSupplier.getAsBoolean()) {\n    throwTestAbortedException(messageSupplier.get());\n  }\n}\n", "docstring": "validate the given assumption .", "partition": "test"}
{"idx": "321", "code": "public static String addToCartBulk(HttpServletRequest request,HttpServletResponse response){\n  String categoryId=request.getParameter(\"category_id\");\n  ShoppingCart cart=getCartObject(request);\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCartHelper cartHelper=new ShoppingCartHelper(delegator,dispatcher,cart);\n  String controlDirective;\n  Map<String,Object> result;\n  Map<String,Object> paramMap=UtilHttp.getParameterMap(request);\n  String catalogId=CatalogWorker.getCurrentCatalogId(request);\n  result=cartHelper.addToCartBulk(catalogId,categoryId,paramMap);\n  controlDirective=processResult(result,request);\n  if (controlDirective.equals(ERROR)) {\n    return \"error\";\n  }\n else {\n    return \"success\";\n  }\n}\n", "docstring": "adds all products in a category according to quantity request parameter for each ; if no parameter for a certain product in the category , or if quantity is 0 , do not add", "partition": "test"}
{"idx": "322", "code": "public void addFrequentSet(FrequentItemSet itemSet){\n  frequentSets.add(itemSet);\n  maximumSetSize=Math.max(itemSet.getNumberOfItems(),maximumSetSize);\n}\n", "docstring": "adds a frequent item set to this container . conditionalitems and frequentitems are merged .", "partition": "test"}
{"idx": "323", "code": "private int skipFromPeekBuffer(int length){\n  int bytesSkipped=Math.min(peekBufferLength,length);\n  updatePeekBuffer(bytesSkipped);\n  return bytesSkipped;\n}\n", "docstring": "skips from the peek buffer .", "partition": "test"}
{"idx": "324", "code": "protected Workflow.Method createRemoveVolumesFromCGMethod(URI vplexURI,URI cgURI,List<URI> vplexVolumeURIs){\n  return new Workflow.Method(REMOVE_VOLUMES_FROM_CG_STEP,vplexURI,cgURI,vplexVolumeURIs);\n}\n", "docstring": "a method that creates the workflow method for removing vplex volumes from a consistency group .", "partition": "test"}
{"idx": "325", "code": "private static int showUrlsPrompt(Component parent,List<String> urls){\n  String text=\"<html><body style=\'width: 100px;\'>\";\n  for (  String url : urls) {\n    url=splitUrl(url);\n    text+=url + \"<br />\";\n  }\n  String okOption=\"Open URL\";\n  if (urls.size() > 1) {\n    okOption=\"Open \" + urls.size() + \" URLs\";\n  }\n  String[] options={okOption,\"Cancel\"};\n  if (urls.size() == 1) {\n    options=new String[]{okOption,\"Copy URL\",\"Cancel\"};\n  }\n  int chosenOption=JOptionPane.showOptionDialog(parent,text,\"Open in default browser?\",JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,1);\n  return chosenOption;\n}\n", "docstring": "actually show the dialog that contain the given urls and give the user the option to open the url , copy it or cancel the dialog .", "partition": "test"}
{"idx": "326", "code": "int convertMouse(MouseEvent event){\n  int result;\n  if (panelFont == null)   return (NO_MOUSE);\n  int colOff=event.getX() - GRID_WIDTH - PANEL_MARGIN;\n  int colNum=colOff / horizStep;\n  int colRem=colOff % horizStep;\n  if ((colNum >= panelColumns) || (colRem < TEXT_MARGIN) || (colRem > (horizStep - GRID_WIDTH - TEXT_MARGIN))) {\n    return (NO_MOUSE);\n  }\n  int rowOff=event.getY() - GRID_WIDTH - PANEL_MARGIN;\n  int rowNum=rowOff / vertiStep;\n  int rowRem=rowOff % vertiStep;\n  if ((rowRem < TEXT_MARGIN) || (rowRem > (vertiStep - GRID_WIDTH - TEXT_MARGIN))) {\n    return (NO_MOUSE);\n  }\n  result=cornerIndex + (rowNum * panelColumns) + colNum;\n  if (result >= cellCount)   return (NO_MOUSE);\n  return (result);\n}\n", "docstring": "convert mouse . convert mouse coordinates to a cell index . return < no_mouse > if the mouse is not well - centered on a defined character .", "partition": "test"}
{"idx": "327", "code": "private static String computeRegexString(String originalString,String oldName,String newName){\n  StringBuilder builder=new StringBuilder(originalString.length());\n  String oldNameOrNewNameRegEx=String.format(\"(%s)|(%s)\",Pattern.quote(oldName),Pattern.quote(newName));\n  int i=originalString.indexOf(oldName);\n  if (i >= 0) {\n    int prevI=0;\n    while (i >= 0) {\n      builder.append(Pattern.quote(originalString.substring(prevI,i)));\n      builder.append(oldNameOrNewNameRegEx);\n      prevI=i;\n      i=originalString.indexOf(oldName,i + oldName.length());\n    }\n    builder.append(Pattern.quote(originalString.substring(prevI + oldName.length(),originalString.length())));\n  }\n  return builder.toString();\n}\n", "docstring": "computes a regular expression string where each instance of the old name can be fulfilled by either the old name or new name .", "partition": "test"}
{"idx": "328", "code": "public synchronized String generateCallIdentifier(String address){\n  String date=Long.toString(System.currentTimeMillis() + callIDCounter++ + rand.nextLong());\n  byte cid[]=digester.digest(date.getBytes());\n  String cidString=Utils.toHexString(cid);\n  return cidString + \"@\" + address;\n}\n", "docstring": "generate a call identifier . this is useful when we want to generate a call identifier in advance of generating a message .", "partition": "test"}
{"idx": "329", "code": "public void doHistory(KeyEvent e){\n  if (e.getSource() == m_Input) {\nswitch (e.getKeyCode()) {\ncase KeyEvent.VK_UP:\n      if (m_HistoryPos > 0) {\n        m_HistoryPos--;\n        String command=m_CommandHistory.elementAt(m_HistoryPos);\n        m_Input.setText(command);\n      }\n    break;\ncase KeyEvent.VK_DOWN:\n  if (m_HistoryPos < m_CommandHistory.size()) {\n    m_HistoryPos++;\n    String command=\"\";\n    if (m_HistoryPos < m_CommandHistory.size()) {\n      command=m_CommandHistory.elementAt(m_HistoryPos);\n    }\n    m_Input.setText(command);\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n}\n", "docstring": "changes the currently displayed command line when certain keys are pressed . the up arrow moves back through history entries and the down arrow moves forward through history entries .", "partition": "test"}
{"idx": "330", "code": "public static ReferenceBinding[] substitute(Substitution substitution,ReferenceBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    TypeBinding substitutedType=substitute(substitution,originalType);\n    if (!(substitutedType instanceof ReferenceBinding)) {\n      return null;\n    }\n    if (substitutedType != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new ReferenceBinding[length],0,i);\n      }\n      substitutedTypes[i]=(ReferenceBinding)substitutedType;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}\n", "docstring": "returns an array of types , where original types got substituted given a substitution . only allocate an array if anything is different .", "partition": "test"}
{"idx": "331", "code": "@Override protected void onDraw(Canvas canvas){\n  super.onDraw(canvas);\n  if (mBitmapShader == null)   return;\n  canvas.drawCircle(mCenterX,mCenterY,mCoverRadius,mCoverPaint);\n  canvas.drawCircle(mCenterX,mCenterY,mCoverRadius,mCoverFrontPaint);\n  mDurationText=secondsToTime(mDurationSecondsCurrent);\n  mDurationPaint.getTextBounds(mDurationText,0,mDurationText.length(),mRectDuration);\n  canvas.drawText(mDurationText,(mCenterX - (mRectDuration.width() / 2.0f)),(mCenterY + (mRectDuration.height() / 2.0f)),mDurationPaint);\n  if (mBitmapUnselectedAction1 != null && mBitmapSelectedAction1 != null) {\n    canvas.drawBitmap(isAction1Selected ? mBitmapSelectedAction1 : mBitmapUnselectedAction1,(mCenterX - (5 * (mCenterX / 13.0f))),mCenterY + (mCenterY / 3.0f) - (mCenterY / 13.0f),mActionPaint);\n  }\n  if (mBitmapUnselectedAction2 != null && mBitmapSelectedAction2 != null) {\n    canvas.drawBitmap(isAction2Selected ? mBitmapSelectedAction2 : mBitmapUnselectedAction2,mCenterX - (mCenterX / 13.0f),mCenterY + (mCenterY / 3.0f) - (mCenterY / 13.0f),mActionPaint);\n  }\n  if (mBitmapUnselectedAction3 != null && mBitmapSelectedAction3 != null) {\n    canvas.drawBitmap(isAction3Selected ? mBitmapSelectedAction3 : mBitmapUnselectedAction3,(int)(mCenterX + (3 * (mCenterX / 13.0f))),mCenterY + (mCenterY / 3.0f) - (mCenterY / 13.0f),mActionPaint);\n  }\n  canvas.drawArc(mProgressRectF,0,360,false,mPaintEmptyProgress);\n  canvas.drawArc(mProgressRectF,270,calculatePastProgress(),false,mPaintLoadedProgress);\n  canvas.drawCircle((float)(mCenterX + ((mCenterX - 20.0f) * Math.cos(Math.toRadians(calculatePastProgress() - 90)))),(float)(mCenterY + ((mCenterX - 20.0f) * Math.sin(Math.toRadians(calculatePastProgress() - 90)))),mRadiusToggle,mPaintProgressToggle);\n}\n", "docstring": "what magic happens . 1 - draw image cover in circle 2 - draw black shadow on it to make seconds and icons more visible 3 - draw duration center of image . 4 - put icon / s on it 5 - draw progress", "partition": "test"}
{"idx": "332", "code": "private static Collection<TCPTransport> allKnownTransports(){\n  Set<TCPTransport> s;\nsynchronized (localEndpoints) {\n    s=new HashSet<TCPTransport>(localEndpoints.size());\n    for (    LinkedList<TCPEndpoint> epList : localEndpoints.values()) {\n      TCPEndpoint ep=epList.getFirst();\n      s.add(ep.transport);\n    }\n  }\n  return s;\n}\n", "docstring": "returns the current list of known transports . the returned list is an unshared collection of transports , including all transports which may have channels to remote endpoints .", "partition": "test"}
{"idx": "333", "code": "public void requestSecondsUntilIdleLockout(){\n  operations.add(PasswordPolicyStateOperationType.GET_SECONDS_UNTIL_IDLE_LOCKOUT);\n}\n", "docstring": "returns the seconds until idle lockout .", "partition": "test"}
{"idx": "334", "code": "@RequestMapping(value=\"/hive\",method={RequestMethod.GET}) @ResponseBody private static List<String> showHiveDatabases() throws IOException {\n  IHiveClient hiveClient=HiveClientFactory.getHiveClient();\n  List<String> results=null;\n  try {\n    results=hiveClient.getHiveDbNames();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new IOException(e);\n  }\n  return results;\n}\n", "docstring": "show all databases in hive", "partition": "test"}
{"idx": "335", "code": "public void testNegNegFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=-1;\n  byte rBytes[]={-1,127,-10,-57,-101,1,2,2,2,-96,-16,8,-40,-59,68,-88,-88,16,73};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.and(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,result.signum());\n}\n", "docstring": "and for two negative numbers ; the first is shorter", "partition": "test"}
{"idx": "336", "code": "private static double hackyAdjuster(double f){\n  double tmp=Math.sqrt(1.0 - f);\n  return (f <= 0.5) ? tmp : tmp + (0.01 * (f - 0.5));\n}\n", "docstring": "this hackyadjuster is tightly coupled with the width of the confidence interval normally specified with number of standard deviations . to simplify this interface the number of standard deviations has been fixed to 2 . 0 , which corresponds to a confidence interval of 95 % .", "partition": "test"}
{"idx": "337", "code": "private boolean copyDocument(SearchDocument newDocument,SearchDocument document,Map<String,Set<String>> removedProperties){\n  boolean mutated=false;\n  for (  String oldFieldName : document.getPropertyNames()) {\n    newDocument.addProperty(oldFieldName);\n    List<String> oldValues=document.getProperty(oldFieldName);\n    if (oldValues != null) {\n      Set<String> objectsRemoved=(removedProperties != null) ? removedProperties.get(oldFieldName) : null;\n      for (      String oldValue : oldValues) {\n        if ((objectsRemoved != null) && (objectsRemoved.contains(oldValue))) {\n          mutated=true;\n        }\n else {\n          addProperty(oldFieldName,oldValue,newDocument);\n        }\n      }\n    }\n  }\n  return mutated;\n}\n", "docstring": "creates a copy of the old document ; updating the retrieved document instance works ok for stored properties but indexed data gets lost when doing an indexwriter . updatedocument with it .", "partition": "test"}
{"idx": "338", "code": "public SVDMatrix(Matrix Arg){\n  this(Arg,true,true,true);\n}\n", "docstring": "construct the singular value decomposition", "partition": "test"}
{"idx": "339", "code": "public void unlockForClear(InternalDistributedMember locker){\nsynchronized (this.clearLockSync) {\n    InternalDistributedSystem instance=InternalDistributedSystem.getAnyInstance();\n    if (instance != null && logger.isDebugEnabled()) {\n      logger.debug(\"Unlocking for clear, from member {} RVV {}\",locker,System.identityHashCode(this));\n    }\n    if (this.lockOwner != null && !locker.equals(this.lockOwner)) {\n      if (instance != null && logger.isDebugEnabled()) {\n        logger.debug(\"current clear lock owner was {} not unlocking\",lockOwner);\n      }\n      return;\n    }\n    unlockVersionGeneration(locker);\n  }\n}\n", "docstring": "unlocks version generation for clear ( ) operations", "partition": "test"}
{"idx": "340", "code": "public UnicastRef(){\n}\n", "docstring": "create a new ( empty ) unicast remote reference .", "partition": "test"}
{"idx": "341", "code": "private static int lastIndexOf(Object o,@NotNull Object[] elements,int index){\n  if (o == null) {\n    for (int i=index; i >= 0; i--) {\n      if (elements[i] == null) {\n        return i;\n      }\n    }\n  }\n else {\n    for (int i=index; i >= 0; i--) {\n      if (o.equals(elements[i])) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n", "docstring": "static version of lastindexof .", "partition": "test"}
{"idx": "342", "code": "public void write(ByteBuffer buffer) throws IOException {\n  buffer.position(0);\n  if (mFileChannel.size() + buffer.capacity() < mMaxSize) {\n    while (buffer.hasRemaining()) {\n      mFileChannel.write(buffer);\n    }\n    updateWaveFileSize();\n  }\n else {\n    int remaining=(int)(mMaxSize - mFileChannel.size());\n    remaining-=(int)(remaining % mAudioFormat.getFrameSize());\n    byte[] bytes=buffer.array();\n    ByteBuffer current=ByteBuffer.wrap(Arrays.copyOf(bytes,remaining));\n    ByteBuffer next=ByteBuffer.wrap(Arrays.copyOfRange(bytes,remaining,bytes.length));\n    while (current.hasRemaining()) {\n      mFileChannel.write(current);\n    }\n    updateWaveFileSize();\n    rollover();\n    while (next.hasRemaining()) {\n      mFileChannel.write(next);\n    }\n    updateWaveFileSize();\n  }\n}\n", "docstring": "writes the buffer contents to the file . assumes that the buffer is full and the first byte of data is at position 0 .", "partition": "test"}
{"idx": "343", "code": "public static double dmod_d(double lhs,double rhs){\n  return rhs != 0 ? lhs - rhs * Math.floor(lhs / rhs) : Double.NaN;\n}\n", "docstring": "take modulo for double numbers according to lua math , and return a double result .", "partition": "test"}
{"idx": "344", "code": "private synchronized void block(boolean tf){\n  if (tf) {\n    try {\n      if (m_ioThread.isAlive() && m_state != IDLE) {\n        wait();\n      }\n    }\n catch (    InterruptedException ex) {\n    }\n  }\n else {\n    notifyAll();\n  }\n}\n", "docstring": "function used to stop code that calls accepttrainingset . this is needed as classifier construction is performed inside a separate thread of execution .", "partition": "test"}
{"idx": "345", "code": "public void move(MouseEvent e){\n  Point2D pnt=getProjectionPoint(e);\n  int x=(int)pnt.getX();\n  int y=(int)pnt.getY();\n  if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n    gpm=new OffsetGrabPoint(x,y);\n    gpm.clear();\n  }\n else {\n    gpm=gpo;\n    gpm.clear();\n    gpm.set(x,y);\n  }\n  addPolyGrabPointsToOGP(gpm);\n  movingPoint=gpm;\n}\n", "docstring": "called to set the offsetgrabpoint to the current mouse location , and update the offsetgrabpoint with all the other grabpoint locations , so everything can shift smoothly . should also set the offsetgrabpoint to the movingpoint . should be called only once at the beginning of the general movement , in order to set the movingpoint . after that , redraw ( e ) should just be called , and the movingpoint will make the adjustments to the graphic that are needed .", "partition": "test"}
{"idx": "346", "code": "public static boolean containIP(int cidrPrefix,int cidrMaskBits,int ip){\n  boolean matched=true;\n  int bitsToShift=32 - cidrMaskBits;\n  if (bitsToShift > 0) {\n    cidrPrefix=cidrPrefix >> bitsToShift;\n    ip=ip >> bitsToShift;\n    cidrPrefix=cidrPrefix << bitsToShift;\n    ip=ip << bitsToShift;\n  }\n  if (cidrPrefix != ip) {\n    matched=false;\n  }\n  return matched;\n}\n", "docstring": "check whether the cidr address contains the ip address", "partition": "test"}
{"idx": "347", "code": "protected static Boolean lock(String serviceName,Object name){\n  DistributedLockService service=DistributedLockService.getServiceNamed(serviceName);\n  boolean locked=service.lock(name,1000,-1);\n  return Boolean.valueOf(locked);\n}\n", "docstring": "accessed via reflection . do not remove", "partition": "test"}
{"idx": "348", "code": "protected int checkKnownCookie(){\n  int retVal=0;\n  debug.message(\"{}.checkKnownCookie:\",ADAPTIVE);\n  HttpServletRequest req=getHttpServletRequest();\n  if (req != null) {\n    Cookie cookie=CookieUtils.getCookieFromReq(req,knownCookieName);\n    if (cookie != null) {\n      if (knownCookieValue.equalsIgnoreCase(CookieUtils.getCookieValue(cookie))) {\n        retVal=knownCookieScore;\n      }\n    }\n  }\n  if (knownCookieValue == null) {\n    knownCookieValue=\"1\";\n  }\n  if (knownCookieSave) {\n    postAuthNMap.put(\"COOKIENAME\",knownCookieName);\n    postAuthNMap.put(\"COOKIEVALUE\",knownCookieValue);\n  }\n  if (!knownCookieInvert) {\n    retVal=knownCookieScore - retVal;\n  }\n  return retVal;\n}\n", "docstring": "check to see if the client has a cookie with optional value", "partition": "test"}
{"idx": "349", "code": "public File[] selectImportFiles(final String title,boolean multipleSelection,FileNameExtensionFilter[] fileNameExtensionFilters){\n  if (Boolean.parseBoolean(System.getProperty(\"use.native.choosers\",Boolean.toString(OSType.isMac())))) {\n    FileDialog importDialog=fileDialogs.get(title);\n    if (importDialog == null) {\n      importDialog=new FileDialog(this,title,FileDialog.LOAD);\n      fileDialogs.put(title,importDialog);\n    }\n    importDialog.setVisible(true);\n    if (importDialog.getFile() != null) {\n      return new File[]{new File(importDialog.getDirectory(),importDialog.getFile())};\n    }\n  }\n else {\n    JFileChooser importChooser=fileChoosers.get(title);\n    if (importChooser == null) {\n      importChooser=new JFileChooser(Utils.getCWD());\n      importChooser.setMultiSelectionEnabled(multipleSelection);\n      for (      FileNameExtensionFilter fileNameExtensionFilter : fileNameExtensionFilters) {\n        importChooser.setFileFilter(fileNameExtensionFilter);\n      }\n      importChooser.setDialogTitle(title);\n      fileChoosers.put(title,importChooser);\n    }\n    int returnVal=importChooser.showOpenDialog(this);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n      if (importChooser.isMultiSelectionEnabled()) {\n        return importChooser.getSelectedFiles();\n      }\n else {\n        return new File[]{importChooser.getSelectedFile()};\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "use the native file dialog on the mac because the swing one is bad . on linux , the native one is bad . no preference on windows .", "partition": "test"}
{"idx": "350", "code": "public GT_MetaGenerated_Item(String aUnlocalized,short aOffset,short aItemAmount){\n  super(aUnlocalized);\n  setCreativeTab(GregTech_API.TAB_GREGTECH_MATERIALS);\n  setHasSubtypes(true);\n  setMaxDamage(0);\n  mEnabledItems=new BitSet(aItemAmount);\n  mVisibleItems=new BitSet(aItemAmount);\n  mOffset=(short)Math.min(32766,aOffset);\n  mItemAmount=(short)Math.min(aItemAmount,32766 - mOffset);\n  mIconList=new IIcon[aItemAmount][1];\n  sInstances.put(getUnlocalizedName(),this);\n}\n", "docstring": "creates the item using these parameters .", "partition": "test"}
{"idx": "351", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(8);\n  newVector.addElement(new Option(\"\\tSet confidence threshold for pruning.\\n\" + \"\\t(default 0.25)\",\"C\",1,\"-C <pruning confidence>\"));\n  newVector.addElement(new Option(\"\\tSet minimum number of objects per leaf.\\n\" + \"\\t(default 2)\",\"M\",1,\"-M <minimum number of objects>\"));\n  newVector.addElement(new Option(\"\\tUse reduced error pruning.\",\"R\",0,\"-R\"));\n  newVector.addElement(new Option(\"\\tSet number of folds for reduced error\\n\" + \"\\tpruning. One fold is used as pruning set.\\n\" + \"\\t(default 3)\",\"N\",1,\"-N <number of folds>\"));\n  newVector.addElement(new Option(\"\\tUse binary splits only.\",\"B\",0,\"-B\"));\n  newVector.addElement(new Option(\"\\tGenerate unpruned decision list.\",\"U\",0,\"-U\"));\n  newVector.addElement(new Option(\"\\tDo not use MDL correction for info gain on numeric attributes.\",\"J\",0,\"-J\"));\n  newVector.addElement(new Option(\"\\tSeed for random data shuffling (default 1).\",\"Q\",1,\"-Q <seed>\"));\n  newVector.addElement(new Option(\"\\tDo not make split point actual value.\",\"-doNotMakeSplitPointActualValue\",0,\"-doNotMakeSplitPointActualValue\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options . valid options are : < p > - c confidence < br > set confidence threshold for pruning . ( default : 0 . 25 ) < p > - m number < br > set minimum number of instances per leaf . ( default : 2 ) < p > - r < br > use reduced error pruning . < p > - n number < br > set number of folds for reduced error pruning . one fold is used as the pruning set . ( default : 3 ) < p > - b < br > use binary splits for nominal attributes . < p > - u < br > generate unpruned decision list . < p > - q < br > the seed for reduced - error pruning . < p >", "partition": "test"}
{"idx": "352", "code": "public static ParsedSql parseSqlStatement(String sql){\n  Set<String> namedParameters=new HashSet<String>();\n  ParsedSql parsedSql=new ParsedSql(sql);\n  char[] statement=sql.toCharArray();\n  int namedParameterCount=0;\n  int unnamedParameterCount=0;\n  int totalParameterCount=0;\n  int i=0;\n  while (i < statement.length) {\n    int skipToPosition=skipCommentsAndQuotes(statement,i);\n    if (i != skipToPosition) {\n      if (skipToPosition >= statement.length) {\n        break;\n      }\n      i=skipToPosition;\n    }\n    char c=statement[i];\n    if (c == ':' || c == '&') {\n      int j=i + 1;\n      if (j < statement.length && statement[j] == ':' && c == ':') {\n        i=i + 2;\n        continue;\n      }\n      while (j < statement.length && !isParameterSeparator(statement[j])) {\n        j++;\n      }\n      if (j - i > 1) {\n        String parameter=sql.substring(i + 1,j);\n        if (!namedParameters.contains(parameter)) {\n          namedParameters.add(parameter);\n          namedParameterCount++;\n        }\n        parsedSql.addNamedParameter(parameter,i,j);\n        totalParameterCount++;\n      }\n      i=j - 1;\n    }\n else {\n      if (c == '?') {\n        unnamedParameterCount++;\n        totalParameterCount++;\n      }\n    }\n    i++;\n  }\n  parsedSql.setNamedParameterCount(namedParameterCount);\n  parsedSql.setUnnamedParameterCount(unnamedParameterCount);\n  parsedSql.setTotalParameterCount(totalParameterCount);\n  return parsedSql;\n}\n", "docstring": "parse the sql statement and locate any placeholders or named parameters . named parameters are substituted for a jdbc placeholder .", "partition": "test"}
{"idx": "353", "code": "final void putLong(int offset,long value){\n  unsafe.putLong(offset + address,value);\n}\n", "docstring": "writes a long at the specified offset from this native object \"'\" s base address .", "partition": "test"}
{"idx": "354", "code": "public boolean onEvent(ActionResult result){\nsynchronized (this) {\n    String requestId=result.getResponseInfo().mRequestId;\n    if (requestId == null) {\n      return false;\n    }\n    boolean eventRemoved=mRequestIds.remove(requestId);\n    if (eventRemoved) {\n      Class key=null;\n      for (      Class type : mLastRequestIdByType.keySet()) {\n        if (requestId.equals(mLastRequestIdByType.get(type))) {\n          key=type;\n          break;\n        }\n      }\n      if (key != null) {\n        mLastRequestIdByType.remove(key);\n      }\n    }\n    return eventRemoved;\n  }\n}\n", "docstring": "required method to be called if you are using requestkeeper to funnel your requests .", "partition": "test"}
{"idx": "355", "code": "public static String gensalt(int log_rounds,SecureRandom random){\n  StringBuffer rs=new StringBuffer();\n  byte rnd[]=new byte[BCRYPT_SALT_LEN];\n  random.nextBytes(rnd);\n  rs.append(\"$2a$\");\n  if (log_rounds < 10) {\n    rs.append(\"0\");\n  }\n  if (log_rounds > 30) {\n    throw new IllegalArgumentException(\"log_rounds exceeds maximum (30)\");\n  }\n  rs.append(Integer.toString(log_rounds));\n  rs.append(\"$\");\n  rs.append(encode_base64(rnd,rnd.length));\n  return rs.toString();\n}\n", "docstring": "generate a salt for use with the bcrypt . hashpw ( ) method .", "partition": "test"}
{"idx": "356", "code": "public StringBuffer numberToString(final String strNumberToConvert){\n  String strNumber=\"\", signBit=\"\";\n  if (strNumberToConvert.startsWith(\"-\")) {\n    strNumber=\"\" + strNumberToConvert.substring(1,strNumberToConvert.length());\n    signBit=\"-\";\n  }\n else   strNumber=\"\" + strNumberToConvert;\n  final DecimalFormat dft=new DecimalFormat(\"##############0.00\");\n  final String strtemp=\"\" + dft.format(Double.parseDouble(strNumber));\n  StringBuffer strbNumber=new StringBuffer(strtemp);\n  final int intLen=strbNumber.length();\n  for (int i=intLen - 6; i > 0; i=i - 2)   strbNumber.insert(i,\',\');\n  if (signBit.equals(\"-\"))   strbNumber=strbNumber.insert(0,\"-\");\n  return strbNumber;\n}\n", "docstring": "function to format amount into to indaian rupees format", "partition": "test"}
{"idx": "357", "code": "private void runInitScriptIfRequired(String url,Connection connection) throws SQLException {\n  Matcher matcher=INITSCRIPT_MATCHING_PATTERN.matcher(url);\n  if (matcher.matches()) {\n    String initScriptPath=matcher.group(2);\n    try {\n      URL resource=Resources.getResource(initScriptPath);\n      String sql=Resources.toString(resource,Charsets.UTF_8);\n      ScriptUtils.executeSqlScript(connection,initScriptPath,sql);\n    }\n catch (    IOException|IllegalArgumentException e) {\n      LOGGER.warn(\"Could not load classpath init script: {}\",initScriptPath);\n      throw new SQLException(\"Could not load classpath init script: \" + initScriptPath,e);\n    }\ncatch (    ScriptException e) {\n      LOGGER.error(\"Error while executing init script: {}\",initScriptPath,e);\n      throw new SQLException(\"Error while executing init script: \" + initScriptPath,e);\n    }\n  }\n}\n", "docstring": "run an init script from the classpath .", "partition": "test"}
{"idx": "358", "code": "public static void checkFinite(final double[] val) throws MathIllegalArgumentException {\n  for (int i=0; i < val.length; i++) {\n    final double x=val[i];\n    if (Double.isInfinite(x) || Double.isNaN(x)) {\n      throw new MathIllegalArgumentException(LocalizedCoreFormats.NOT_FINITE_NUMBER,x);\n    }\n  }\n}\n", "docstring": "check that all the elements are real numbers .", "partition": "test"}
{"idx": "359", "code": "private void initKeyboardButtons(KeyboardView view){\n  mButtons=new ArrayList<>();\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_0));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_1));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_2));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_3));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_4));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_5));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_6));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_7));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_8));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_9));\n  mButtons.add((KeyboardButtonView)view.findViewById(R.id.pin_code_button_clear));\n  for (  View button : mButtons) {\n    button.setOnClickListener(this);\n  }\n}\n", "docstring": "init the keyboard buttons ( onclicklistener )", "partition": "test"}
{"idx": "360", "code": "public static boolean isAutoNew(Properties ctx,int WindowNo){\n  if (ctx == null)   throw new IllegalArgumentException(\"Require Context\");\n  String s=getContext(ctx,WindowNo,\"AutoNew\",false);\n  if (s != null) {\n    if (s.equals(\"Y\"))     return true;\n else     return false;\n  }\n  return isAutoNew(ctx);\n}\n", "docstring": "is window auto new record ( if not set use default )", "partition": "test"}
{"idx": "361", "code": "private static String findRelativePath(String filePath,String dirPath){\n  String relPath;\n  if (!dirPath.endsWith(File.separator)) {\n    dirPath=dirPath + File.separator;\n  }\n  if (filePath.startsWith(dirPath)) {\n    relPath=filePath.substring(dirPath.length());\n  }\n else {\n    relPath=filePath;\n  }\n  return relPath;\n}\n", "docstring": "determine the path to the file relative to the given directory path .", "partition": "test"}
{"idx": "362", "code": "public boolean init(){\n  log.config(\"\");\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = \'Y\' \"+ \"                 AND p.IsActive = \'Y\' \"+ \"                 AND l.IsActive = \'Y\' \"+ \"                 AND cl.IsActive = \'Y\' \"+ \"                 AND pp.ASP_Status = \'S\') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = \'Y\' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = \'S\') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = \'Y\' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = \'H\')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive=\'Y\' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language=\'\" + Env.getAD_Language(Env.getCtx()) + \"\'\"+ \" AND p.IsActive=\'Y\' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  Rows rows=new Rows();\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs,rows);\n      isPair=!isPair;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_wEditors.size() || m_mFields2.size() != m_wEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    centerPanel.appendChild(rows);\n    dynamicDisplay();\n  }\n else   dispose();\n  return hasFields;\n}\n", "docstring": "read fields to display", "partition": "test"}
{"idx": "363", "code": "public void resetSingleton(){\n  root=null;\n  tmpFileCounter.set(0);\n  accessedFiles.clear();\n  shouldAllThrowIOException=false;\n  classesThatShouldThrowIOException.clear();\nsynchronized (leakingResources) {\n    for (    LeakingResource resource : leakingResources) {\n      try {\n        resource.release();\n      }\n catch (      Exception e) {\n        logger.warn(\"Failed to release resource: \" + e.getMessage(),e);\n      }\n    }\n    leakingResources.clear();\n  }\n}\n", "docstring": "reset the internal state of this singleton", "partition": "test"}
{"idx": "364", "code": "public void testAndNotNegNegFirstLonger(){\n  byte aBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  byte bBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  int aSign=-1;\n  int bSign=-1;\n  byte rBytes[]={73,-92,-48,4,12,6,4,32,48,64,0,8,2};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.andNot(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "andnot for two negative numbers ; the first is longer", "partition": "test"}
{"idx": "365", "code": "public static String generateStringOfCharacters(int count){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < count; i++) {\n    sb.append(CHARACTERS.charAt((int)(Math.random() * CHARACTERS.length())));\n  }\n  return sb.toString();\n}\n", "docstring": "creates a random string which only consists of letters", "partition": "test"}
{"idx": "366", "code": "private ExchangeRateManager(){\n  if (System.getProperty(\"EXPERIMENTAL\") == null)   throw new UnsupportedOperationException(\"Work in progress\");\n  addKnownRates();\n}\n", "docstring": "constructs a new exchangeratemanager and initialises the most used rates . note : private ; should only be accessed by getinstance ( ) .", "partition": "test"}
{"idx": "367", "code": "public void removeAttribute(String name){\n  if (name != null)   if (attributesList != null) {\n    for (int i=0; i < attributesList.size(); i++) {\n      Object o=attributesList.elementAt(i);\n      if (o instanceof AttributeField) {\n        AttributeField a=(AttributeField)o;\n        try {\n          String n=a.getName();\n          if (n != null) {\n            if (name.equals(n)) {\n              attributesList.remove(a);\n            }\n          }\n        }\n catch (        SdpParseException e) {\n        }\n      }\n    }\n  }\n}\n", "docstring": "removes the attribute specified by the value parameter .", "partition": "test"}
{"idx": "368", "code": "@Override public void evict(String key){\n  key=safetyKey(key);\n  final File file=new File(cacheDirectory,key);\n  file.delete();\n}\n", "docstring": "delete the object previously saved .", "partition": "test"}
{"idx": "369", "code": "public static boolean isUniqueContraintError(Exception e){\n  if (DB.isPostgreSQL())   return isSQLState(e,\"23505\");\n  return isErrorCode(e,1);\n}\n", "docstring": "check if unique constraint exception ( aka ora - 00001 )", "partition": "test"}
{"idx": "370", "code": "private void insertUsedContextPrefixes(){\n  int unknownPrefixesCount=unknownPrefixesInXMLLiteral.size();\n  if (unknownPrefixesCount > 0) {\n    StringBuilder contextPrefixes=new StringBuilder(1024);\n    ElementInfo topElement=peekStack();\n    for (int i=0; i < unknownPrefixesCount; i++) {\n      String prefix=unknownPrefixesInXMLLiteral.get(i);\n      String namespace=topElement.getNamespace(prefix);\n      if (namespace != null) {\n        appendNamespaceDecl(contextPrefixes,prefix,namespace);\n      }\n    }\n    int endOfFirstStartTag=charBuf.indexOf(\">\");\n    charBuf.insert(endOfFirstStartTag,contextPrefixes.toString());\n  }\n  unknownPrefixesInXMLLiteral.clear();\n}\n", "docstring": "inserts prefix mappings from an xml literal \"'\" s context for all prefixes that are used in the xml literal and that are not defined in the xml literal itself .", "partition": "test"}
{"idx": "371", "code": "public void addPutTimeNanos(long duration){\n  putTimeNanos.addAndGet(duration);\n  if (delegate != null)   delegate.addPutTimeNanos(duration);\n}\n", "docstring": "increments the put time accumulator .", "partition": "test"}
{"idx": "372", "code": "public static List<Integer> precomputeHashes(byte[] data,long tweak){\n  ArrayList<Integer> list=new ArrayList<>(MAX_HASH_FUNCS);\n  for (int i=0; i < MAX_HASH_FUNCS; ++i) {\n    list.add(murmurhash3bit(i,data,tweak));\n  }\n  return list;\n}\n", "docstring": "precompute hashes used to set mask bits for a data .", "partition": "test"}
{"idx": "373", "code": "@RequestProcessing(value=\"/member/{userName}/following/tags\",method=HTTPRequestMethod.GET) @Before(adviceClass={StopwatchStartAdvice.class,AnonymousViewCheck.class,UserBlockCheck.class}) @After(adviceClass=StopwatchEndAdvice.class) public void showHomeFollowingTags(final HTTPRequestContext context,final HttpServletRequest request,final HttpServletResponse response,final String userName) throws Exception {\n  final JSONObject user=(JSONObject)request.getAttribute(User.USER);\n  request.setAttribute(Keys.TEMAPLTE_DIR_NAME,Symphonys.get(\"skinDirName\"));\n  final AbstractFreeMarkerRenderer renderer=new SkinRenderer();\n  context.setRenderer(renderer);\n  renderer.setTemplateName(\"/home/following-tags.ftl\");\n  final Map<String,Object> dataModel=renderer.getDataModel();\n  filler.fillHeaderAndFooter(request,response,dataModel);\n  String pageNumStr=request.getParameter(\"p\");\n  if (Strings.isEmptyOrNull(pageNumStr) || !Strings.isNumeric(pageNumStr)) {\n    pageNumStr=\"1\";\n  }\n  final int pageNum=Integer.valueOf(pageNumStr);\n  final int pageSize=Symphonys.getInt(\"userHomeFollowingTagsCnt\");\n  final int windowSize=Symphonys.getInt(\"userHomeFollowingTagsWindowSize\");\n  fillHomeUser(dataModel,user);\n  final String followingId=user.optString(Keys.OBJECT_ID);\n  dataModel.put(Follow.FOLLOWING_ID,followingId);\n  avatarQueryService.fillUserAvatarURL(user);\n  final JSONObject followingTagsResult=followQueryService.getFollowingTags(followingId,pageNum,pageSize);\n  final List<JSONObject> followingTags=(List<JSONObject>)followingTagsResult.opt(Keys.RESULTS);\n  dataModel.put(Common.USER_HOME_FOLLOWING_TAGS,followingTags);\n  final boolean isLoggedIn=(Boolean)dataModel.get(Common.IS_LOGGED_IN);\n  if (isLoggedIn) {\n    final JSONObject currentUser=(JSONObject)dataModel.get(Common.CURRENT_USER);\n    final String followerId=currentUser.optString(Keys.OBJECT_ID);\n    final boolean isFollowing=followQueryService.isFollowing(followerId,followingId);\n    dataModel.put(Common.IS_FOLLOWING,isFollowing);\n    for (    final JSONObject followingTag : followingTags) {\n      final String homeUserFollowingTagId=followingTag.optString(Keys.OBJECT_ID);\n      followingTag.put(Common.IS_FOLLOWING,followQueryService.isFollowing(followerId,homeUserFollowingTagId));\n    }\n  }\n  user.put(UserExt.USER_T_CREATE_TIME,new Date(user.getLong(Keys.OBJECT_ID)));\n  final int followingTagCnt=followingTagsResult.optInt(Pagination.PAGINATION_RECORD_COUNT);\n  final int pageCount=(int)Math.ceil(followingTagCnt / (double)pageSize);\n  final List<Integer> pageNums=Paginator.paginate(pageNum,pageSize,pageCount,windowSize);\n  if (!pageNums.isEmpty()) {\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM,pageNums.get(0));\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM,pageNums.get(pageNums.size() - 1));\n  }\n  dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM,pageNum);\n  dataModel.put(Pagination.PAGINATION_PAGE_COUNT,pageCount);\n  dataModel.put(Pagination.PAGINATION_PAGE_NUMS,pageNums);\n}\n", "docstring": "shows user home following tags page .", "partition": "test"}
{"idx": "374", "code": "public int elevationAt(float lat,float lon){\n  if (frame_is_valid == true) {\n    if (lat >= dsi.sw_lat && lat <= dsi.ne_lat && lon >= dsi.sw_lon && lon <= dsi.ne_lon) {\n      int lat_index=Math.round((lat - dsi.sw_lat) * 36000 / uhl.lat_post_interval);\n      int lon_index=Math.round((lon - dsi.sw_lon) * 36000 / uhl.lon_post_interval);\n      if (elevations[lon_index] == null)       readDataRecord(lon_index);\n      return (int)elevations[lon_index][lat_index];\n    }\n  }\n  return -32767;\n}\n", "docstring": "the elevation at the closest sw post to the given lat / lon . this is just a go - to - the - closest - post solution .", "partition": "test"}
{"idx": "375", "code": "ObservedObject createObservedObject(ObjectName object){\n  return new ObservedObject(object);\n}\n", "docstring": "factory method for observedobject creation .", "partition": "test"}
{"idx": "376", "code": "private void saveInitialChildState(FacesContext facesContext,UIComponent component){\n  if (component instanceof EditableValueHolder && !component.isTransient()) {\n    String clientId=component.getClientId(facesContext);\n    SavedState state=new SavedState();\n    initialChildState.put(clientId,state);\n    state.populate((EditableValueHolder)component);\n  }\n  Iterator<UIComponent> iterator=component.getFacetsAndChildren();\n  while (iterator.hasNext()) {\n    saveChildState(facesContext,iterator.next());\n  }\n}\n", "docstring": "recursively create the initial state for the given component .", "partition": "test"}
{"idx": "377", "code": "public boolean is_overlap(){\n  Set<BrdItem> start_contacts=get_start_contacts();\n  Set<BrdItem> end_contacts=get_end_contacts();\n  for (  BrdItem end_contact : end_contacts) {\n    if (start_contacts.contains(end_contact))     return true;\n  }\n  return false;\n}\n", "docstring": "looks , if this trace is connected to the same object at its start and its end point", "partition": "test"}
{"idx": "378", "code": "static Object ensureNotNull(Location location,Object value){\n  if (value == null) {\n    throw new EvalException(location,\"Snippet runtime does not support null values.\");\n  }\n  return value;\n}\n", "docstring": "ensure the given value is not null and return it .", "partition": "test"}
{"idx": "379", "code": "private static String padRight(String s,int minLength){\n  return String.format(\"%1$-\" + minLength + \"s\",s);\n}\n", "docstring": "adds padding to the end of a string with a repeating character if the string \"'\" s length is less than the minimum length", "partition": "test"}
{"idx": "380", "code": "@Override public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumRules\");\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration of the additional measure names", "partition": "test"}
{"idx": "381", "code": "protected synchronized void onSendTaskCompleted(RecordBuffer<R> buffer){\n  logger.trace(\"{}:{} Send Completed\",name(),buffer);\n  activeSendTasks.decrementAndGet();\n}\n", "docstring": "this method should not raise any exceptions .", "partition": "test"}
{"idx": "382", "code": "public void addPreferencesButton(){\n  JButton prefsButton=new JButton(\"Prefs\");\n  prefsButton.setHideActionText(true);\n  prefsButton.setAction(RasterPlotActions.getPropertiesDialogAction(this));\n  buttonPanel.add(prefsButton);\n}\n", "docstring": "add button for showing preferences .", "partition": "test"}
{"idx": "383", "code": "public void clearUnused(ConfigImpl config){\n  SystemOut.printDate(config.getOutWriter(),\"PagePool: \" + size() + \">(\"+ maxSize+ \")\");\n  if (size() > maxSize) {\n    Object[] keys=keys();\n    LongKeyList list=new LongKeyList();\n    for (int i=0; i < keys.length; i++) {\n      PageSource ps=getPageSource(keys[i],false);\n      long updateTime=ps.getLastAccessTime();\n      if (updateTime + timeout < System.currentTimeMillis()) {\n        long add=((ps.getAccessCount() - 1) * 10000);\n        if (add > timeout)         add=timeout;\n        list.add(updateTime + add,keys[i]);\n      }\n    }\n    while (size() > maxSize) {\n      Object key=list.shift();\n      if (key == null)       break;\n      remove(key);\n    }\n  }\n}\n", "docstring": "clear unused pages from page pool", "partition": "test"}
{"idx": "384", "code": "public static GridField[] createFields(Properties ctx,int WindowNo,int TabNo,int AD_Tab_ID){\n  ArrayList<GridFieldVO> listVO=new ArrayList<GridFieldVO>();\n  int AD_Window_ID=0;\n  boolean readOnly=false;\n  String sql=GridFieldVO.getSQL(ctx);\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,AD_Tab_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      GridFieldVO vo=GridFieldVO.create(ctx,WindowNo,TabNo,AD_Window_ID,AD_Tab_ID,readOnly,rs);\n      listVO.add(vo);\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n  GridField[] retValue=new GridField[listVO.size()];\n  for (int i=0; i < listVO.size(); i++)   retValue[i]=new GridField((GridFieldVO)listVO.get(i));\n  return retValue;\n}\n", "docstring": "create fields . used by apanel . cmd_find and viewer . cmd_find", "partition": "test"}
{"idx": "385", "code": "public ShortInterleavedRaster(SampleModel sampleModel,DataBuffer dataBuffer,Point origin){\n  this(sampleModel,dataBuffer,new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}\n", "docstring": "constructs a shortinterleavedraster with the given samplemodel and databuffer . the raster \"'\" s upper left corner is origin and it is the same sizes the samplemodel . the databuffer is not initialized and must be a databufferushort compatible with samplemodel . samplemodel must be of type pixelinterleavedsamplemodel or singlepixelpackedsamplemodel .", "partition": "test"}
{"idx": "386", "code": "@Override public boolean flingBackward(Selector obj,boolean isVertical) throws UiObjectNotFoundException {\n  UiScrollable scrollable=new UiScrollable(obj.toUiSelector());\n  if (isVertical)   scrollable.setAsVerticalList();\n else   scrollable.setAsHorizontalList();\n  return scrollable.flingBackward();\n}\n", "docstring": "performs a backwards fling action with the default number of fling steps ( 5 ) . if the swipe direction is set to vertical , then the swipe will be performed from top to bottom . if the swipe direction is set to horizontal , then the swipes will be performed from left to right . make sure to take into account devices configured with right - to - left languages like arabic and hebrew .", "partition": "test"}
{"idx": "387", "code": "protected static double toDouble(String s){\n  try {\n    return Double.parseDouble(s);\n  }\n catch (  Exception e) {\n    TestCase.fail(\"Failed to parse double: \" + s + \"\\n\"+ throwableToString(e));\n    return Double.NaN;\n  }\n}\n", "docstring": "attempts to parse the string as double . in case this fails , testcase . fail ( ) is triggered .", "partition": "test"}
{"idx": "388", "code": "public void addListener(final IFilterPanelListener<T> listener){\n  m_listeners.addListener(listener);\n}\n", "docstring": "adds a listener that is notified about changes in the filter .", "partition": "test"}
{"idx": "389", "code": "public void testmirror(File orig,File origni,File truecolor){\n  File mirror=TestSupport.addSuffixToName(orig,\"_mirror\");\n  File recov=TestSupport.addSuffixToName(orig,\"_recov\");\n  long crc0=0;\n  boolean interlaced;\n  boolean palete;\n{\n    PngReader pngr=new PngReader(orig);\n    PngWriter pngw=null;\n    try {\n      if (rand.nextBoolean())       pngr.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      palete=pngr.imgInfo.indexed;\n      pngr.prepareSimpleDigestComputation();\n      interlaced=pngr.isInterlaced();\n      pngw=new PngWriter(mirror,pngr.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_CYCLIC);\n      pngw.copyChunksFrom(pngr.getChunksList());\n      IImageLineSet<? extends IImageLine> lines=pngr.readRows();\n      for (int row=0; row < pngr.imgInfo.rows; row++) {\n        mirrorLine(lines.getImageLine(row),pngr.imgInfo);\n        pngw.writeRow(lines.getImageLine(row));\n      }\n      pngr.end();\n      crc0=PngHelperInternal.getDigest(pngr);\n      pngw.end();\n    }\n  finally {\n      pngr.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n{\n    PngReader pngr2=new PngReader(mirror);\n    PngWriter pngw=null;\n    try {\n      if (pngr2.imgInfo.bitDepth < 16 && rand.nextBoolean())       pngr2.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      pngw=new PngWriter(recov,pngr2.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_DEFAULT);\n      pngw.copyChunksFrom(pngr2.getChunksList());\n      for (int row=0; row < pngr2.imgInfo.rows; row++) {\n        IImageLine line=pngr2.readRow();\n        mirrorLine(line,pngr2.imgInfo);\n        pngw.writeRow(line);\n      }\n      pngr2.end();\n      pngw.end();\n    }\n  finally {\n      pngr2.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n  if (!interlaced)   TestSupport.testCrcEquals(recov,crc0);\n else   TestSupport.testSameCrc(recov,origni);\n  if (interlaced)   additionalTestInterlaced(orig,origni);\n  if (palete && truecolor.exists())   additionalTestPalette(orig,truecolor);\n}\n", "docstring": "takes a image , mirrors it using row - per - row int reading , mirror it again using byte ( if possible ) and compares if the original was interlaced , compares with origni", "partition": "test"}
{"idx": "390", "code": "public boolean isStable(){\n  return myFeatures.contains(FEATURE_STABLE);\n}\n", "docstring": "returns true if gapis is considered stable ( non - experimental ) :", "partition": "test"}
{"idx": "391", "code": "public static void calcTextSize(Paint paint,String demoText,FSize outputFSize){\n  Rect r=mCalcTextSizeRect;\n  r.set(0,0,0,0);\n  paint.getTextBounds(demoText,0,demoText.length(),r);\n  outputFSize.width=r.width();\n  outputFSize.height=r.height();\n}\n", "docstring": "calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )", "partition": "test"}
{"idx": "392", "code": "protected void performDefaults(){\n  super.performDefaults();\n  initializeValues();\n  verifyValidation();\n}\n", "docstring": "defaults was clicked . restore the svn preferences to their default values", "partition": "test"}
{"idx": "393", "code": "public static void write(int x1,int y1,Image image,int image_width,int image_height,LinkProperties properties,DataOutputStream dos) throws IOException, InterruptedException {\n  int[] pixels=new int[image_width * image_height];\n  PixelGrabber pixelgrabber=new PixelGrabber(image,0,0,image_width,image_height,pixels,0,image_width);\n  pixelgrabber.grabPixels();\n  LinkRaster.write(x1,y1,image_width,image_height,pixels,properties,dos);\n}\n", "docstring": "write an image , x / y placement with an imageicon .", "partition": "test"}
{"idx": "394", "code": "@SuppressWarnings(\"unchecked\") public void testProjectionPredicateDifferentClassLoaders() throws Exception {\n  final Ignite ignite3=startGrid(3);\n  URL[] clsLdrUrls;\n  try {\n    clsLdrUrls=new URL[]{new URL(GridTestProperties.getProperty(\"p2p.uri.cls\"))};\n  }\n catch (  MalformedURLException e) {\n    throw new RuntimeException(\"Define property p2p.uri.cls\",e);\n  }\n  ClassLoader ldr1=new URLClassLoader(clsLdrUrls,getClass().getClassLoader());\n  Class taskCls=ldr1.loadClass(\"org.apache.ignite.tests.p2p.JobStealingTask\");\n  Class nodeFilterCls=ldr1.loadClass(\"org.apache.ignite.tests.p2p.ExcludeNodeFilter\");\n  IgnitePredicate<ClusterNode> nodeFilter=(IgnitePredicate<ClusterNode>)nodeFilterCls.getConstructor(UUID.class).newInstance(ignite2.cluster().localNode().id());\n  Map<UUID,Integer> ret=(Map<UUID,Integer>)executeAsync(compute(ignite1.cluster().forPredicate(nodeFilter)),taskCls,null).get(TASK_EXEC_TIMEOUT_MS);\n  assert ret != null;\n  assert ret.get(ignite1.cluster().localNode().id()) != null && ret.get(ignite1.cluster().localNode().id()) == 2 : ret.get(ignite1.cluster().localNode().id());\n  assert ret.get(ignite3.cluster().localNode().id()) != null && ret.get(ignite3.cluster().localNode().id()) == 2 : ret.get(ignite3.cluster().localNode().id());\n}\n", "docstring": "tests job stealing with peer deployment and different class loaders .", "partition": "test"}
{"idx": "395", "code": "public static void writeToFile(String content,File dstFile) throws IOException {\n  BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(dstFile,false));\n  bufferedWriter.write(content);\n  bufferedWriter.close();\n}\n", "docstring": "save string into the file", "partition": "test"}
{"idx": "396", "code": "private void updateStatus(String relayState,int currentStatus){\n  Integer tmp=(Integer)currentStatusMap.get(relayState);\n  if (tmp != null) {\n    int previousStatus=tmp.intValue();\nswitch (previousStatus) {\ncase LOGOUT_SUCCEEDED_STATUS:\n      if (currentStatus > previousStatus) {\n        currentStatusMap.put(relayState,new Integer(currentStatus));\n      }\n    break;\ncase LOGOUT_FAILED_STATUS:\n  if (currentStatus < LOGOUT_FAILED_STATUS) {\n    currentStatusMap.put(relayState,new Integer(LOGOUT_PARTIAL_STATUS));\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n else {\ncurrentStatusMap.put(relayState,new Integer(currentStatus));\n}\n}\n", "docstring": "updates logout status based on current status and what stored in the internal map .", "partition": "test"}
{"idx": "397", "code": "public static Set<String> listServers(SSOToken ssoToken,String siteName) throws SMSException, SSOException, ConfigurationException {\n  Set<String> members=new HashSet<>();\n  String siteId=getSiteId(ssoToken,siteName);\n  if (siteId != null) {\n    Set<String> allServers=ServerConfiguration.getServers(ssoToken);\n    for (    String svr : allServers) {\n      if (ServerConfiguration.belongToSite(ssoToken,svr,siteName)) {\n        members.add(svr);\n      }\n    }\n  }\n  return members;\n}\n", "docstring": "returns the server instance names that belong to a site .", "partition": "test"}
{"idx": "398", "code": "public static GenericObjectEditorDialog createDialog(Container parent){\n  return createDialog(parent,null);\n}\n", "docstring": "creates a modal dialog for the parent .", "partition": "test"}
{"idx": "399", "code": "public static boolean containsInLineFeatures(StyledLayerDescriptor sld){\n  if (sld != null) {\n    for (    StyledLayer layer : sld.layers()) {\n      if (layer instanceof UserLayer) {\n        UserLayer userLayer=(UserLayer)layer;\n        if (userLayer.getInlineFeatureDatastore() != null) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "checks to see if sld contains inline features .", "partition": "test"}
{"idx": "400", "code": "public static void runFinalization(){\n  RUNTIME.runFinalization();\n}\n", "docstring": "provides a hint to the virtual machine that it would be useful to attempt to perform any outstanding object finalizations .", "partition": "test"}
{"idx": "401", "code": "private void displayAllStringDefinedInStringXml(){\n  SimpleIconFontTextView textView=(SimpleIconFontTextView)findViewById(R.id.text_view_1);\n  List<String> list=new ArrayList<>();\n  list.add(getString(R.string.gems_logo));\n  String text=TextUtils.join(\" \",list);\n  textView.setText(text);\n}\n", "docstring": "display the string defined in the string xml file : iconfont_string . xml", "partition": "test"}
{"idx": "402", "code": "public static void checkHTTPRequestLength(HttpServletRequest request) throws ServletException {\n  int maxContentLength=SAMLUtils.getMaxContentLength();\n  if (maxContentLength != 0) {\n    int length=request.getContentLength();\n    if (length == -1) {\n      throw new ServletException(bundle.getString(\"unknownLength\"));\n    }\n    if (length > maxContentLength) {\n      if (debug.messageEnabled()) {\n        debug.message(\"FSUtils.checkHTTPRequestLength: \" + \"content length too large\" + length);\n      }\n      throw new ServletException(bundle.getString(\"largeContentLength\"));\n    }\n  }\n}\n", "docstring": "checks content length of a http request to avoid dos attack . in case idff inter - op with other idff vendor who may not provide content length in httpservletrequest . we decide to support no length restriction for http communication . here , we use a special value ( e . g . 0 ) to indicate that no enforcement is required .", "partition": "test"}
{"idx": "403", "code": "public void addForeignKeyConstraint(String name,String sourceField,String targetField,String targetTable){\n  ForeignKeyConstraint foreignKey=new ForeignKeyConstraint(name,sourceField,targetField,targetTable);\n  addForeignKeyConstraint(foreignKey);\n}\n", "docstring": "public : add a foreign key constraint to the table . if there is a same name foreign key constraint already , nothing will happen .", "partition": "test"}
{"idx": "404", "code": "public void push(Notification notification,NotificationResponseListener listener){\n  final String notificationTopic=notification.getTopic();\n  final String topic=notificationTopic == null ? defaultTopic : notificationTopic;\n  Request req=Utils.buildRequest(client,topic,notification,gateway);\n  semaphore.acquireUninterruptibly();\n  req.send(new ResponseListener(semaphore,notification,listener));\n}\n", "docstring": "sends a notification to the apple push notification service .", "partition": "test"}
{"idx": "405", "code": "public void updateFromResource(){\n  for (  String resource : resources) {\n    InputStream is=ClassLoader.getSystemResourceAsStream(resource);\n    LinkedHashMap<EntryType,LinkedHashMap<String,ConfigEntry>> parseResult=parse(is);\n    for (    EntryType type : myMap.keySet()) {\n      LinkedHashMap<String,ConfigEntry> dataMappings=myMap.get(type);\n      LinkedHashMap<String,ConfigEntry> resourceMappings=parseResult.get(type);\n      LinkedHashMap<String,ConfigEntry> tempMappings=new LinkedHashMap<String,ConfigEntry>();\n      LinkedHashSet<String> keys=new LinkedHashSet<String>();\n      keys.addAll(dataMappings.keySet());\n      keys.addAll(resourceMappings.keySet());\n      for (      String key : keys) {\n        if (resourceMappings.containsKey(key)) {\n          tempMappings.put(key,resourceMappings.get(key));\n        }\n else {\n          tempMappings.put(key,dataMappings.get(key));\n        }\n      }\n      myMap.put(type,tempMappings);\n    }\n  }\n}\n", "docstring": "maintains order of all keys , but overwrites all data keys with values from resources .", "partition": "test"}
{"idx": "406", "code": "private void deselect(final int index,final boolean shouldFireEvents){\n  checkWidget();\n  if (index < 0 || index >= items.size()) {\n    return;\n  }\n  final DLItem item=selection.remove(index);\n  if (shouldFireEvents) {\n    fireSelectionEvent(item);\n  }\n  final List<DLItem> deselectedItems=new ArrayList<DLItem>();\n  item.setLastAction(LAST_ACTION.DESELECTION);\n  deselectedItems.add(item);\n  if (shouldFireEvents) {\n    fireSelectionChangeEvent(deselectedItems);\n  }\n  redrawTables();\n}\n", "docstring": "deselects the item at the given zero - relative index in the receiver . if the item at the index was already deselected , it remains deselected . indices that are out of range are ignored .", "partition": "test"}
{"idx": "407", "code": "public boolean isLeaf(Object nd){\n  Node node=(Node)nd;\n  return !node.hasChildNodes();\n}\n", "docstring": "gets the leaf attribute of the domtreemodel object", "partition": "test"}
{"idx": "408", "code": "public void addListener(Listener listener){\n  mListeners.add(listener);\n  notifyServiceDiscovered(mMatchingDrones);\n}\n", "docstring": "add a listener all callbacks of the interface listener will be called within this function should be called in the main thread", "partition": "test"}
{"idx": "409", "code": "@Override boolean equals(Object obj);\n", "docstring": "checks if this date - time is equal to another date - time , including the chronology . < p > compares this date - time with another ensuring that the date - time and chronology are the same .", "partition": "test"}
{"idx": "410", "code": "private double[] parseVector(String s){\n  String[] entries=WHITESPACE_PATTERN.split(s);\n  double[] d=new double[entries.length];\n  for (int i=0; i < entries.length; i++) {\n    try {\n      d[i]=ParseUtil.parseDouble(entries[i]);\n    }\n catch (    NumberFormatException e) {\n      throw new AbortException(\"Could not parse vector.\");\n    }\n  }\n  return d;\n}\n", "docstring": "parse a string into a vector . todo : move this into utility package ?", "partition": "test"}
{"idx": "411", "code": "public void test_create_update() throws IOException {\n  final String id=\"test\";\n  final Map<String,Object> metadata=new HashMap<String,Object>();\n  metadata.put(FileMetadataSchema.ID,id);\n  metadata.put(\"foo\",\"bar\");\n  final int version0;\n  final long createTime0;\n  final byte[] expected0=new byte[]{1,2,3};\n{\n    version0=repo.create(metadata);\n    metadata.put(FileMetadataSchema.VERSION,Integer.valueOf(version0));\n    assertEquals(\"version\",0,version0);\n    RepositoryDocumentImpl doc=(RepositoryDocumentImpl)repo.read(id);\n    createTime0=doc.getVersionCreateTime();\n    Map<String,Object> actual=doc.asMap();\n    assertEquals(\"id\",id,actual.get(FileMetadataSchema.ID));\n    assertEquals(\"version\",version0,actual.get(FileMetadataSchema.VERSION));\n    assertEquals(\"user property\",\"bar\",actual.get(\"foo\"));\n    assertEquals(\"size\",metadata.size(),actual.size());\n    repo.copyStream(id,version0,new ByteArrayInputStream(expected0));\n    assertEquals(\"version0\",expected0,read(repo.inputStream(id,version0)));\n  }\n  final int version1;\n  final long createTime1;\n  final byte[] expected1=new byte[]{4,5,6};\n{\n    metadata.put(\"foo\",\"baz\");\n    DocumentImpl doc1=new DocumentImpl(metadata);\n    doc1.copyStream(expected1);\n    version1=repo.update(doc1);\n    assertEquals(\"version\",1,version1);\n    metadata.put(FileMetadataSchema.VERSION,Integer.valueOf(version1));\n    RepositoryDocumentImpl doc=(RepositoryDocumentImpl)repo.read(id);\n    createTime1=doc.getVersionCreateTime();\n    assertNotSame(\"createTime\",0L,createTime1);\n    assertNotSame(\"createTime\",createTime0,createTime1);\n    Map<String,Object> actual=doc.asMap();\n    assertEquals(\"id\",id,actual.get(FileMetadataSchema.ID));\n    assertEquals(\"version\",version1,actual.get(FileMetadataSchema.VERSION));\n    assertEquals(\"user property\",\"baz\",actual.get(\"foo\"));\n    assertEquals(\"size\",metadata.size(),actual.size());\n    assertEquals(\"version1\",expected1,read(repo.inputStream(id,version1)));\n    assertEquals(\"version0\",new byte[]{},read(repo.inputStream(id,version0)));\n{\n      ITPS tps=repo.readMetadata(id,createTime1 - 1L);\n      ITPV tpv=tps.get(FileMetadataSchema.VERSION);\n      assertEquals(\"version\",null,tpv.getValue());\n    }\n  }\n}\n", "docstring": "create an empty file and write some data on it . then update its metadata , verify the new metadata and the updated version , and then write some data on the new version . verify the both file versions can be read .", "partition": "test"}
{"idx": "412", "code": "public SessionWrapper(Session ses){\n  this.ses=ses;\n  this.time=System.currentTimeMillis();\n}\n", "docstring": "creates instance of cassandra driver session wrapper .", "partition": "test"}
{"idx": "413", "code": "public static List<BatchResponse> postWithSingleRequest(final RequestSpecification requestSpec,final ResponseSpecification responseSpec,final BatchRequest br){\n  final List<BatchRequest> batchRequests=new ArrayList<>();\n  batchRequests.add(br);\n  final String jsonifiedRequest=BatchHelper.toJsonString(batchRequests);\n  final List<BatchResponse> response=BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,responseSpec,jsonifiedRequest);\n  Assert.assertNotNull(response);\n  Assert.assertTrue(response.size() > 0);\n  return response;\n}\n", "docstring": "returns a batchresponse based on the given batchrequest , by posting the request to the server .", "partition": "test"}
{"idx": "414", "code": "public File programDirectory(){\n  return programDirectory;\n}\n", "docstring": "returns the directory in which the main program is located .", "partition": "test"}
{"idx": "415", "code": "@Override public void clearRouteSensors(){\n  _controlSensorList=new ArrayList<>();\n}\n", "docstring": "method to delete all control sensors from this route", "partition": "test"}
{"idx": "416", "code": "public static KEYSTORE_TYPE fromString(String x) throws ConfigurationException {\n  for (  KEYSTORE_TYPE currentType : KEYSTORE_TYPE.values()) {\n    if (x.equalsIgnoreCase(currentType.toString()))     return currentType;\n  }\n  throw new ConfigurationException(MessageFormat.format(\"Cannot cast into a known CERTIFICATE_KEY_TYPE: {0}\",x));\n}\n", "docstring": "converts a string into the corresponding keystore_type", "partition": "test"}
{"idx": "417", "code": "public ObjectMapper nextLevel(ObjectMapper level){\n  ObjectMapper previous=levelStack.peek();\n  levelStack.push(level);\n  return previous;\n}\n", "docstring": "sets the new current nested level and pushes old current nested level down the stack returns that level .", "partition": "test"}
{"idx": "418", "code": "protected static int toDigit(final char ch,final int index) throws HexDecodeException {\n  final int digit=Character.digit(ch,16);\n  if (digit == -1) {\n    throw new HexDecodeException(\"Illegal hexadecimal character \" + ch + \" at index \"+ index);\n  }\n  return digit;\n}\n", "docstring": "converts a hexadecimal character to an integer .", "partition": "test"}
{"idx": "419", "code": "public JSONObject toJson() throws JSONException {\n  JSONObject json=new JSONObject();\n  JSONArray jpods=new JSONArray();\n  for (  DiasporaPod pod : pods) {\n    jpods.put(pod.toJson());\n  }\n  json.put(\"pods\",jpods);\n  json.put(\"timestamp\",System.currentTimeMillis());\n  return json;\n}\n", "docstring": "convert diasporapodlist to json", "partition": "test"}
{"idx": "420", "code": "public static KeyStore load(File keyStoreFile,Password password) throws CryptoException, FileNotFoundException {\n  KeyStoreType keyStoreType=null;\n  try {\n    keyStoreType=CryptoFileUtil.detectKeyStoreType(new FileInputStream(keyStoreFile));\n  }\n catch (  FileNotFoundException ex) {\n    throw ex;\n  }\ncatch (  IOException ex) {\n    throw new CryptoException(res.getString(\"NoLoadKeyStore.exception.message\"),ex);\n  }\n  if (keyStoreType == null) {\n    return null;\n  }\n  return load(keyStoreFile,password,keyStoreType);\n}\n", "docstring": "load a keystore , auto - detecting the type , from a file accessed by a password .", "partition": "test"}
{"idx": "421", "code": "@VisibleForTesting static boolean isPrecachingEnabled(Context context){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n  return prefs.getBoolean(PREF_IS_PRECACHING_ENABLED,false);\n}\n", "docstring": "returns true if precaching is able to run . set by precachelauncher # updateprecachingenabled .", "partition": "test"}
{"idx": "422", "code": "public void and(LongBitSet other){\n  int pos=Math.min(numWords,other.numWords);\n  while (--pos >= 0) {\n    bits[pos]&=other.bits[pos];\n  }\n  if (numWords > other.numWords) {\n    Arrays.fill(bits,other.numWords,numWords,0L);\n  }\n}\n", "docstring": "this = this and other", "partition": "test"}
{"idx": "423", "code": "@Override public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (!(obj instanceof PrincipalEntry))   return false;\n  PrincipalEntry that=(PrincipalEntry)obj;\n  return (principalClass.equals(that.principalClass) && principalName.equals(that.principalName));\n}\n", "docstring": "test for equality between the specified object and this object . two principalentries are equal if their class and name values are equal .", "partition": "test"}
{"idx": "424", "code": "public boolean isValidLockdownProfile(){\n  try {\n    return true;\n  }\n catch (  IllegalArgumentException e) {\n    Log.w(TAG,\"Invalid address\",e);\n    return false;\n  }\n}\n", "docstring": "test if profile is valid for lockdown , which requires ipv4 address for both server and dns . server hostnames would require using dns before connection .", "partition": "test"}
{"idx": "425", "code": "private int readServerResponse() throws IOException {\n  StringBuffer replyBuf=new StringBuffer(32);\n  int c;\n  int continuingCode=-1;\n  int code;\n  String response;\n  serverResponse.setSize(0);\n  while (true) {\n    while ((c=in.read()) != -1) {\n      if (c == \'\\r\') {\n        if ((c=in.read()) != \'\\n\') {\n          replyBuf.append(\'\\r\');\n        }\n      }\n      replyBuf.append((char)c);\n      if (c == \'\\n\') {\n        break;\n      }\n    }\n    response=replyBuf.toString();\n    replyBuf.setLength(0);\n    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n      logger.finest(\"Server [\" + serverAddr + \"] --> \"+ response);\n    }\n    if (response.length() == 0) {\n      code=-1;\n    }\n else {\n      try {\n        code=Integer.parseInt(response.substring(0,3));\n      }\n catch (      NumberFormatException e) {\n        code=-1;\n      }\ncatch (      StringIndexOutOfBoundsException e) {\n        continue;\n      }\n    }\n    serverResponse.addElement(response);\n    if (continuingCode != -1) {\n      if (code != continuingCode || (response.length() >= 4 && response.charAt(3) == \'-\')) {\n        continue;\n      }\n else {\n        continuingCode=-1;\n        break;\n      }\n    }\n else     if (response.length() >= 4 && response.charAt(3) == \'-\') {\n      continuingCode=code;\n      continue;\n    }\n else {\n      break;\n    }\n  }\n  return code;\n}\n", "docstring": "pulls the response from the server and returns the code as a number . returns - 1 on failure .", "partition": "test"}
{"idx": "426", "code": "public FromClause(Stream streamOne,OuterJoinQualifier outerJoinQualifier,Stream streamTwo){\n  this(streamOne);\n  add(streamTwo);\n  outerJoinQualifiers.add(outerJoinQualifier);\n}\n", "docstring": "ctor for an outer join between two streams .", "partition": "test"}
{"idx": "427", "code": "public static KdbDatabase createKdbDatabase(Credentials credentials,KdbHeader kdbHeader,InputStream inputStream) throws IOException {\n  DataInput dataInput=new LittleEndianDataInputStream(inputStream);\n  checkSignature(dataInput);\n  deserializeHeader(kdbHeader,dataInput);\n  InputStream decryptedInputStream=kdbHeader.createDecryptedInputStream(credentials.getKey(),inputStream);\n  MessageDigest digest=Encryption.getMessageDigestInstance();\n  DigestInputStream digestInputStream=new DigestInputStream(decryptedInputStream,digest);\n  dataInput=new LittleEndianDataInputStream(digestInputStream);\n  KdbDatabase kdbDatabase=new KdbDatabase();\n  KdbGroup lastGroup=(KdbGroup)kdbDatabase.getRootGroup();\n  for (long group=0; group < kdbHeader.getGroupCount(); group++) {\n    lastGroup=deserializeGroup(lastGroup,dataInput);\n  }\n  for (long entry=0; entry < kdbHeader.getEntryCount(); entry++) {\n    deserializeEntry(kdbDatabase,dataInput);\n  }\n  if (!Arrays.equals(digest.digest(),kdbHeader.getContentHash())) {\n    throw new IllegalStateException(\"Hash values did not match\");\n  }\n  digestInputStream.close();\n  return kdbDatabase;\n}\n", "docstring": "construct a kdb database from the supplied inputstream .", "partition": "test"}
{"idx": "428", "code": "private DiffPart decodeAdd(final int blockSize_S,final int blockSize_L) throws UnsupportedEncodingException, DecodingException {\n  if (blockSize_S < 1 || blockSize_L < 1) {\n    throw new DecodingException(\"Invalid value for blockSize_S: \" + blockSize_S + \" or blockSize_L: \"+ blockSize_L);\n  }\n  int s=r.read(blockSize_S);\n  int l=r.read(blockSize_L);\n  ByteArrayOutputStream output=new ByteArrayOutputStream();\n  for (int i=0; i < l; i++) {\n    output.write(r.readByte());\n  }\n  DiffPart part=new DiffPart(DiffAction.INSERT);\n  part.setStart(s);\n  part.setText(output.toString(WIKIPEDIA_ENCODING));\n  return part;\n}\n", "docstring": "decodes an add operation .", "partition": "test"}
{"idx": "429", "code": "public void rebuildPanel(){\n  if (activeWorker != null && !activeWorker.isDone()) {\n    activeWorker.cancel(true);\n  }\n  panelImages.removeAll();\n  panelImages.revalidate();\n  scrollPane.repaint();\n  activeWorker=new ImageLoader(mediaFiles);\n  activeWorker.execute();\n}\n", "docstring": "trigger to rebuild the panel", "partition": "test"}
{"idx": "430", "code": "protected void processBytes(byte[] buf,int off,int len){\n  nBytesIn+=len;\n  if (len < 1 || state.isDone())   return;\n  if (state == State.ROW_READY)   throw new PngjInputException(\"this should only be called if waitingForMoreInput\");\n  if (inf.needsDictionary() || !inf.needsInput())   throw new RuntimeException(\"should not happen\");\n  inf.setInput(buf,off,len);\n  if (isCallbackMode()) {\n    while (inflateData()) {\n      int nextRowLen=processRowCallback();\n      prepareForNextRow(nextRowLen);\n      if (isDone())       processDoneCallback();\n    }\n  }\n else   inflateData();\n}\n", "docstring": "feeds the inflater with the compressed bytes in poll mode , the caller should not call repeatedly this , without consuming first , checking isdatareadyforconsumer ( )", "partition": "test"}
{"idx": "431", "code": "@Override protected String toString(File obj){\n  return obj.getAbsolutePath();\n}\n", "docstring": "turns an object into a string for storing in the props .", "partition": "test"}
{"idx": "432", "code": "public final void goToNextPage(){\n  final boolean isLastPage=viewPager.getCurrentItem() == (pages.size() - 1);\n  if (!isLastPage) {\n    viewPager.setCurrentItem(viewPager.getCurrentItem() + 1,true);\n  }\n}\n", "docstring": "navigates to the next page ( if not already there ) .", "partition": "test"}
{"idx": "433", "code": "public List<TypeId<?>> asList(){\n  return Collections.unmodifiableList(Arrays.asList(types));\n}\n", "docstring": "returns an immutable list .", "partition": "test"}
{"idx": "434", "code": "private static void deleteRules(List<String> batchList,List<Rule> rulesToDelete){\n  String deleteStatement=\"DELETE FROM \" + RULES_TABLE + \" WHERE RULE_INTERNAL_ID=%d\";\n  for (  Rule rule : rulesToDelete) {\n    batchList.add(String.format(deleteStatement,rule.getUid()));\n  }\n}\n", "docstring": "the sql commands to be added to the batchlist for deleting the rules in rulestodelete .", "partition": "test"}
{"idx": "435", "code": "public boolean isVisited(Object element){\n  return myVisitedElements.containsKey(element);\n}\n", "docstring": "returns true if this element was already visited .", "partition": "test"}
{"idx": "436", "code": "public AwsIotConnection(AbstractAwsIotClient client){\n  this.client=client;\n}\n", "docstring": "instantiates a new connection object .", "partition": "test"}
{"idx": "437", "code": "public static <T>CompletableFuture<T> exceptionallyCompletedFuture(Throwable throwable){\n  final CompletableFuture<T> future=new CompletableFuture<T>();\n  future.completeExceptionally(throwable);\n  return future;\n}\n", "docstring": "returns a new completablefuture that is already exceptionally completed with the given exception .", "partition": "test"}
{"idx": "438", "code": "protected void initForecastErrors(ArrayList<Float> model,TimeSeries.DataSequence data){\n  double sumErr=0.0;\n  double sumAbsErr=0.0;\n  double sumAbsPercentErr=0.0;\n  double sumErrSquared=0.0;\n  int processedPoints=0;\n  int n=data.size();\n  for (int i=0; i < n; i++) {\n    double error=model.get(i) - data.get(i).value;\n    sumErr+=error;\n    sumAbsErr+=Math.abs(error);\n    sumAbsPercentErr+=Math.abs(error / data.get(i).value);\n    sumErrSquared+=error * error;\n    processedPoints++;\n  }\n  this.bias=sumErr / processedPoints;\n  this.mad=sumAbsErr / processedPoints;\n  this.mape=sumAbsPercentErr / processedPoints;\n  this.mse=sumErrSquared / processedPoints;\n  this.sae=sumAbsErr;\n  errorsInit=true;\n}\n", "docstring": "initializes all errors given the model .", "partition": "test"}
{"idx": "439", "code": "public boolean checkModifiers(MouseEvent e){\n  return e.getModifiers() == modifiers;\n}\n", "docstring": "check the mouse event modifiers against the instance member modifiers . default implementation checks equality . can be overridden to test with a mask", "partition": "test"}
{"idx": "440", "code": "public void emitRetainedVars(GenerateJsVisitor gen){\n  if (!retainedVars.isEmpty()) {\n    gen.out(\"var \");\n    boolean first=true;\n    for (    String varName : retainedVars) {\n      if (!first) {\n        gen.out(\",\");\n      }\n      first=false;\n      gen.out(varName);\n    }\n    gen.endLine(true);\n    retainedVars.clear();\n  }\n}\n", "docstring": "writes all retained variables to the output of the specified generator , then clears them .", "partition": "test"}
{"idx": "441", "code": "public List<StructuredTranslation> KbestExtractOnHG(HyperGraph hg,int topN){\n  resetState();\n  if (hg == null || hg.goalNode == null) {\n    return emptyList();\n  }\n  final List<StructuredTranslation> kbest=new ArrayList<>(topN);\n  for (int k=1; k <= topN; k++) {\n    StructuredTranslation translation=getKthStructuredTranslation(hg.goalNode,k);\n    if (translation == null) {\n      break;\n    }\n    kbest.add(translation);\n  }\n  return kbest;\n}\n", "docstring": "this is an entry point for extracting k - best hypotheses as structuredtranslation objects . it computes all of them and returning a list of structuredtranslation objects . these objects hold all translation information ( string , tokens , features , alignments , score ) .", "partition": "test"}
{"idx": "442", "code": "public static boolean isSnapshotFullCopySupported(URI blockSnapURI,DbClient dbClient){\n  BlockSnapshot blockObj=dbClient.queryObject(BlockSnapshot.class,blockSnapURI);\n  StorageSystem storage=dbClient.queryObject(StorageSystem.class,blockObj.getStorageController());\n  return (storage != null && (storage.deviceIsType(Type.openstack) || storage.deviceIsType(Type.vnxblock) || storage.deviceIsType(Type.ibmxiv)|| storage.deviceIsType(Type.vmax)));\n}\n", "docstring": "check if the storage system type is openstack , vnxblock , vmax or ibmxiv . snapshot full copy is supported only on these storage systems .", "partition": "test"}
{"idx": "443", "code": "public Iterable<ServiceDescriptor> listServices(){\n  ArrayList<ServiceDescriptor> serviceDescriptors=new ArrayList<ServiceDescriptor>();\n  for (  FileDescriptor fileDescriptor : fileDescriptors) {\n    serviceDescriptors.addAll(fileDescriptor.getServices());\n  }\n  return serviceDescriptors;\n}\n", "docstring": "lists all of the services found in the file descriptors", "partition": "test"}
{"idx": "444", "code": "private String stripCodeValueSentences(String string){\n  return string.replaceAll(\"This result code corresponds to the LDAP result code value of \\\\{@code \\\\d+\\\\}.\",\"\");\n}\n", "docstring": "returns a string with lines sentences of the following form removed : this result code corresponds to the ldap result code value of & # x7b ; & # x40 ; code 0 & # x7d ; .", "partition": "test"}
{"idx": "445", "code": "public static double quantile(double p,double alpha,double beta){\n  if (Double.isNaN(alpha) || Double.isNaN(beta) || Double.isNaN(p)|| alpha < 0. || beta < 0.) {\n    return Double.NaN;\n  }\n  if (p < 0 || p > 1) {\n    return Double.NaN;\n  }\n  if (p == 0) {\n    return 0.0;\n  }\n  if (p == 1) {\n    return 1.0;\n  }\n  if (p > 0.5) {\n    return 1 - rawQuantile(1 - p,beta,alpha,logBeta(beta,alpha));\n  }\n else {\n    return rawQuantile(p,alpha,beta,logBeta(alpha,beta));\n  }\n}\n", "docstring": "compute quantile ( inverse cdf ) for beta distributions .", "partition": "test"}
{"idx": "446", "code": "public boolean validate(String cert,String signedData,String signature) throws NoSuchAlgorithmException, IOException, Exception {\n  byte[] certBytes=Base64.decode(cert);\n  byte[] signedDataBytes=Base64.decode(signedData);\n  byte[] signatureBytes=Base64.decode(signature);\n  return validate(certBytes,signedDataBytes,signatureBytes);\n}\n", "docstring": "example implementation . it only knows to verify sha256withec algorithm .", "partition": "test"}
{"idx": "447", "code": "private SharedDeployment createNewDeployment(GridDeploymentMetadata meta,boolean isCache){\n  assert Thread.holdsLock(mux);\n  assert meta.parentLoader() == null;\n  IgniteUuid ldrId=IgniteUuid.fromUuid(ctx.localNodeId());\n  GridDeploymentClassLoader clsLdr;\n  if (meta.deploymentMode() == CONTINUOUS || meta.participants() == null) {\n    clsLdr=new GridDeploymentClassLoader(ldrId,meta.userVersion(),meta.deploymentMode(),false,ctx,ctx.config().getClassLoader() != null ? ctx.config().getClassLoader() : U.gridClassLoader(),meta.classLoaderId(),meta.senderNodeId(),comm,ctx.config().getNetworkTimeout(),log,ctx.config().getPeerClassLoadingLocalClassPathExclude(),ctx.config().getPeerClassLoadingMissedResourcesCacheSize(),meta.deploymentMode() == CONTINUOUS,false);\n    if (meta.participants() != null)     for (    Map.Entry<UUID,IgniteUuid> e : meta.participants().entrySet())     clsLdr.register(e.getKey(),e.getValue());\n    if (log.isDebugEnabled())     log.debug(\"Created class loader in CONTINUOUS mode or without participants \" + \"[ldr=\" + clsLdr + \", meta=\"+ meta+ \']\');\n  }\n else {\n    assert meta.deploymentMode() == SHARED;\n    clsLdr=new GridDeploymentClassLoader(ldrId,meta.userVersion(),meta.deploymentMode(),false,ctx,U.gridClassLoader(),meta.participants(),comm,ctx.config().getNetworkTimeout(),log,ctx.config().getPeerClassLoadingLocalClassPathExclude(),ctx.config().getPeerClassLoadingMissedResourcesCacheSize(),false,false);\n    if (log.isDebugEnabled())     log.debug(\"Created classloader in SHARED mode with participants \" + \"[ldr=\" + clsLdr + \", meta=\"+ meta+ \']\');\n  }\n  SharedDeployment dep=new SharedDeployment(meta.deploymentMode(),clsLdr,ldrId,meta.userVersion(),meta.alias());\n  if (log.isDebugEnabled())   log.debug(\"Created new deployment: \" + dep);\n  if (isCache) {\n    List<SharedDeployment> deps=F.addIfAbsent(cache,meta.userVersion(),new LinkedList<SharedDeployment>());\n    assert deps != null;\n    deps.add(dep);\n    if (log.isDebugEnabled())     log.debug(\"Added deployment to cache: \" + cache);\n  }\n  return dep;\n}\n", "docstring": "creates and caches new deployment .", "partition": "test"}
{"idx": "448", "code": "public void testAddServletRunAsRole() throws Exception {\n  String xml=WEBAPP_TEST_HEADER + \"  <servlet>\" + \"    <servlet-name>s1</servlet-name>\"+ \"    <servlet-class>sclass1</servlet-class>\"+ \"  </servlet>\"+ \"</web-app>\";\n  WebXml webXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(xml.getBytes(\"UTF-8\")),getEntityResolver());\n  WebXmlUtils.addServletRunAsRoleName(webXml,\"s1\",\"r1\");\n  String roleName=WebXmlUtils.getServletRunAsRoleName(webXml,\"s1\");\n  assertEquals(\"r1\",roleName);\n}\n", "docstring": "tests that a run - as role - name can be added to a servlet .", "partition": "test"}
{"idx": "449", "code": "public MultiTermQuery(final String field){\n  this.field=Objects.requireNonNull(field,\"field must not be null\");\n}\n", "docstring": "constructs a query matching terms that cannot be represented with a single term .", "partition": "test"}
{"idx": "450", "code": "public static void printLine(Object message){\n  if (!isDisabled()) {\n    printLine(String.valueOf(message));\n  }\n}\n", "docstring": "prints the message passed as a non - string object and a new line .", "partition": "test"}
{"idx": "451", "code": "public void testInvalidXml() throws Exception {\n  testInvalidGpx(INVALID_XML_GPX);\n}\n", "docstring": "test an invalid xml input .", "partition": "test"}
{"idx": "452", "code": "public String toString(boolean expand){\n  StringBuilder acc=new StringBuilder();\n  toString(acc,0,expand);\n  return acc.toString();\n}\n", "docstring": "convert a re to a string .", "partition": "test"}
{"idx": "453", "code": "public static boolean isAccessorPair(TMember member,TMember member2){\n  return (member instanceof TGetter && member2 instanceof TSetter) || (member instanceof TSetter && member2 instanceof TGetter);\n}\n", "docstring": "returns true if one of the members is a getter and the other one is a setter . no further validation such as name or owner comparison is done as this is expected to be done in the client already .", "partition": "test"}
{"idx": "454", "code": "public static DateFormat createUTCDateFormatter(String dateFormat){\n  DateFormat formatter=new SimpleDateFormat(dateFormat);\n  formatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n  return formatter;\n}\n", "docstring": "creates a dateformat that assumes the incoming date is in utc time .", "partition": "test"}
{"idx": "455", "code": "public void writeLinkedKml(final String filename,final KmlType kml){\n  if (filename.equals(\"doc.kml\")) {\n    throw new IllegalArgumentException(\"The filename \'doc.kml\' is reserved for the primary kml.\");\n  }\n  if (filename.equals(\"main.kml\")) {\n    throw new IllegalArgumentException(\"The filename \'main.kml\' is reserved for the main kml.\");\n  }\n  writeKml(filename,kml);\n}\n", "docstring": "adds the specified kml - object to the file .", "partition": "test"}
{"idx": "456", "code": "String destinationFilePath(){\n  return destinationFilePath;\n}\n", "docstring": "get destination file path of this download request .", "partition": "test"}
{"idx": "457", "code": "public BootPanel(){\n  initComponents();\n}\n", "docstring": "creates new form bootpanel", "partition": "test"}
{"idx": "458", "code": "private List<Header> defaultHeaders(){\n  DateFormat dateFormat=new SimpleDateFormat(\"EEE, dd mmm yyyy HH:mm:ss zzz\");\n  List<Header> headers=new ArrayList<>();\n  headers.add(new BasicHeader(\"Date\",dateFormat.format(new Date())));\n  return headers;\n}\n", "docstring": "create default headers for server response .", "partition": "test"}
{"idx": "459", "code": "public AemParsys clear(){\n  List<WebElement> list=currentScope.findElements(By.cssSelector(SELECTOR_FOR_COMPONENT_IN_PARSYS));\n  list.forEach(null);\n  return this;\n}\n", "docstring": "remove all components in parsys .", "partition": "test"}
{"idx": "460", "code": "private void registerNewClient(JsonObject jData){\n  Client newClient=gson.fromJson(jData,Client.class);\n  if (newClient.isValid()) {\n    addClient(newClient);\n    broadcastNewClient(newClient);\n    sendClientList(newClient);\n  }\n else {\n    logger.log(Level.WARNING,\"Could not unpack received data into a Client.\");\n  }\n}\n", "docstring": "create client from given json data , add client to client list , broadcast newly registered client to all previously registered clients and send client list to new client .", "partition": "test"}
{"idx": "461", "code": "@Override public void parse(InputStream in,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (in == null) {\n    throw new IllegalArgumentException(\"Input stream cannot be \'null\'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be \'null\'\");\n  }\n  InputSource inputSource=new InputSource(new BOMInputStream(in,false));\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}\n", "docstring": "parses the data from the supplied inputstream , using the supplied baseuri to resolve any relative uri references .", "partition": "test"}
{"idx": "462", "code": "public static Date parseDate(String dateValue,Collection dateFormats) throws DateParseException {\n  if (dateValue == null) {\n    throw new IllegalArgumentException(\"dateValue is null\");\n  }\n  if (dateFormats == null) {\n    dateFormats=DEFAULT_PATTERNS;\n  }\n  if (dateValue.length() > 1 && dateValue.startsWith(\"\'\") && dateValue.endsWith(\"\'\")) {\n    dateValue=dateValue.substring(1,dateValue.length() - 1);\n  }\n  SimpleDateFormat dateParser=null;\n  final Iterator formatIter=dateFormats.iterator();\n  while (formatIter.hasNext()) {\n    final String format=(String)formatIter.next();\n    if (dateParser == null) {\n      dateParser=new SimpleDateFormat(format,Locale.US);\n      dateParser.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n else {\n      dateParser.applyPattern(format);\n    }\n    try {\n      return dateParser.parse(dateValue);\n    }\n catch (    final ParseException pe) {\n    }\n  }\n  throw new DateParseException(\"Unable to parse the date \" + dateValue);\n}\n", "docstring": "parses the date value using the given date formats .", "partition": "test"}
{"idx": "463", "code": "public JSONObject remove(String name){\n  if (name == null) {\n    throw new NullPointerException(\"name is null\");\n  }\n  int index=indexOf(name);\n  if (index != -1) {\n    table.remove(index);\n    names.remove(index);\n    values.remove(index);\n  }\n  return this;\n}\n", "docstring": "removes a member with the specified name from this object . if this object contains multiple members with the given name , only the last one is removed . if this object does not contain a member with the specified name , the object is not modified .", "partition": "test"}
{"idx": "464", "code": "EdgeMap<Block> findLoops(Deque<Block> code,Map<Block,Block> idom,SetMap<Block,Edge> pred){\n  EdgeMap<Block> loops=new EdgeMap<Block>();\n  for (  Block b : code)   for (  Edge s : b.succ())   if (isLoop(s,idom)) {\n    verboseStatus(\"backedge \" + s);\n    Block h=s.to;\n    Set<Block> loop=loops.get(h);\n    Set<Block> work=new TreeSet<Block>();\n    for (    Edge p : pred.get(h)) {\n      if (isLoop(p,idom) && !loop.contains(p.from) && p.from != h) {\n        loop.add(p.from);\n        work.add(p.from);\n      }\n    }\n    while (!work.isEmpty()) {\n      Block x=getBlock(work);\n      for (      Edge p : pred.get(x)) {\n        if (p.from != h && !loop.contains(p.from)) {\n          loop.add(p.from);\n          work.add(p.from);\n        }\n      }\n    }\n  }\n  return loops;\n}\n", "docstring": "loop code layout the loop is defined by the back edge from t - > h . h ( header ) is the source of the back edge . we want h at the bottom of the loop and t at the top . lay the blocks out in dfs order starting with t and skipping any blocks that aren \"'\" t part of the loop . prefer to have fall - through blocks that are part of the loop .", "partition": "test"}
{"idx": "465", "code": "public int[] readLine(){\n  int record[]=new int[MAX_LEN];\n  int checksum=0;\n  try {\n    while (((charIn=buffIn.read()) == 0xd) || (charIn == 0xa)) {\n    }\n    if (charIn != \':\') {\n      if (log.isDebugEnabled()) {\n        log.debug(\"HexFile.readLine no colon at start of line \" + lineNo);\n      }\n      return new int[]{-1};\n    }\n  }\n catch (  IOException e) {\n    JOptionPane.showMessageDialog(this,\"I/O Error reading hex file!\",\"Hex File\",JOptionPane.ERROR_MESSAGE);\n    if (log.isDebugEnabled()) {\n      log.debug(\"I/O Error reading hex file!\" + e.toString());\n    }\n  }\n  record[LEN]=rdHexByte();\n  checksum+=record[LEN];\n  record[ADDRH]=rdHexByte();\n  checksum+=record[ADDRH];\n  record[ADDRL]=rdHexByte();\n  checksum+=record[ADDRL];\n  record[TYPE]=rdHexByte();\n  checksum+=record[TYPE];\n  address=(address & 0xffff0000) + record[ADDRH] * 256 + record[ADDRL];\n  type=record[TYPE];\n  if (type != END) {\n    len=record[LEN];\n    for (int i=1; i <= len; i++) {\n      record[TYPE + i]=rdHexByte();\n      checksum+=record[TYPE + i];\n    }\n  }\n  int fileCheck=rdHexByte();\n  if (((checksum + fileCheck) & 0xff) != 0) {\n    log.error(\"HexFile.readLine bad checksum at line \" + lineNo);\n  }\n  lineNo++;\n  return record;\n}\n", "docstring": "read a line from the hex file and verify the checksum .", "partition": "test"}
{"idx": "466", "code": "private void generateHiveTestFiles() throws FileNotFoundException {\n  try (PrintWriter writerA=new PrintWriter(new File(testWorkDir,\"data-a\"));PrintWriter writerB=new PrintWriter(new File(testWorkDir,\"data-b\"))){\n    char sep=\'\\t\';\n    int idB=0;\n    int idA=0;\n    int v=1000;\n    for (int i=0; i < 1000; i++) {\n      writerA.print(idA++);\n      writerA.print(sep);\n      writerA.println(idB);\n      writerB.print(idB++);\n      writerB.print(sep);\n      writerB.println(v+=2);\n      writerB.print(idB++);\n      writerB.print(sep);\n      writerB.println(v+=2);\n    }\n    writerA.flush();\n    writerB.flush();\n  }\n }\n", "docstring": "generates two data files to join its with hive .", "partition": "test"}
{"idx": "467", "code": "public void renameEditorPanel(Editor panel){\n  if (panelsList.size() == 0) {\n    return;\n  }\n  for (int i=0; i < panelsList.size(); i++) {\n    Object o=panelsList.get(i);\n    if (o == panel) {\n      JCheckBoxMenuItem r=(JCheckBoxMenuItem)panelsSubMenu.getItem(i);\n      r.setText(panel.getTitle());\n      return;\n    }\n  }\n}\n", "docstring": "rename an editor type panel in show panels sub menu", "partition": "test"}
{"idx": "468", "code": "private boolean fitsAsSingleLine(int col){\n  return (col + singleLineWidth() <= PcalTLAGen.wrapColumn) || (bodyFormulas.sf == null && (prcdFormulas == null || prcdFormulas.size() == 0));\n}\n", "docstring": "returns true iff format ( col ) should return a single - line version of the formula .", "partition": "test"}
{"idx": "469", "code": "public void sphericalToWorld(Vector3 vec){\n  if (pjUnprojected == null) {\n    String projStr=\"+proj=longlat +a=\" + projInfo.getSemiMajorAxis() + \" +b=\"+ projInfo.getSemiMinorAxis()+ \" +no_defs\";\n    pjUnprojected=Proj4.newInstance(projStr);\n  }\n  if (pjProjected == null) {\n    pjProjected=Proj4.newInstance(proj4String);\n  }\n  try {\n    vec.toArray(coord);\n    coord[0]=Math.toRadians(coord[0]);\n    coord[1]=Math.toRadians(coord[1]);\n    pjUnprojected.transform(pjProjected,coord);\n    vec.setX(coord[0]);\n    vec.setY(coord[1]);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "convert lon / lat ( degree ) coordinate to virtual world coordinates .", "partition": "test"}
{"idx": "470", "code": "public static String encodeUrl(final String str){\n  return encode(str,\"%20\");\n}\n", "docstring": "encode a string for html requests", "partition": "test"}
{"idx": "471", "code": "public void drawRenderedImage(RenderedImage img,AffineTransform xform){\n  if (img == null) {\n    return;\n  }\n  mPrintMetrics.drawImage(this,img);\n  mDrawingArea.addInfinite();\n}\n", "docstring": "draws an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics2d . the given transformation is applied to the image before the transform attribute in the graphics2d state is applied . the rendering attributes applied include the clip , transform , and composite attributes . note that the result is undefined , if the given transform is noninvertible .", "partition": "test"}
{"idx": "472", "code": "private long buildSize(int durationInSeconds,LinkInfo linfo){\n  long result=-1;\n  double bitRateSum=0;\nswitch (linfo.fmt) {\ncase 5:\n    bitRateSum=0.25 + 64d / 1024d;\n  break;\ncase 6:\nbitRateSum=0.8 + 64d / 1024d;\nbreak;\ncase 17:\nbitRateSum=0.05 + 24d / 1024d;\nbreak;\ncase 18:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 22:\nbitRateSum=2.9 + 192d / 1024d;\nbreak;\ncase 34:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 35:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 36:\nbitRateSum=0.17 + 38d / 1024d;\nbreak;\ncase 37:\nbitRateSum=5.9 + 192d / 1024d;\nbreak;\ncase 38:\nbitRateSum=5 + 192d / 1024d;\nbreak;\ncase 43:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 44:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 45:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 46:\nbitRateSum=3 + 192d / 1024d;\nbreak;\ncase 82:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 83:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 84:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 85:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 100:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 101:\nbitRateSum=1 + 192d / 1024d;\nbreak;\ncase 102:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 133:\nbitRateSum=0.3 + 256d / 1024d;\nbreak;\ncase 134:\nbitRateSum=0.4 + 256d / 1024d;\nbreak;\ncase 135:\nbitRateSum=1 + 256d / 1024d;\nbreak;\ncase 136:\nbitRateSum=1.5 + 256d / 1024d;\nbreak;\ncase 137:\nbitRateSum=2.9 + 256d / 1024d;\nbreak;\ncase 139:\nbitRateSum=48d / 1024d;\nbreak;\ncase 140:\nbitRateSum=128d / 1024d;\nbreak;\ncase 141:\nbitRateSum=256d / 1024d;\nbreak;\n}\nbitRateSum=bitRateSum * 1024 * 1024;\nresult=(long)(Math.ceil((bitRateSum * durationInSeconds) / 8));\nreturn result;\n}\n", "docstring": "upper guess to determine the duration in bytes , using highest bitrate of the stream .", "partition": "test"}
{"idx": "473", "code": "@Override public void actOn(File f){\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new FileReader(f));\n    announceSeedsFromReader(reader);\n  }\n catch (  FileNotFoundException fnf) {\n    logger.log(Level.SEVERE,\"seed file source not found\",fnf);\n  }\n finally {\n    IOUtils.closeQuietly(reader);\n  }\n}\n", "docstring": "treat the given file as a source of additional seeds , announcing to seedlisteners .", "partition": "test"}
{"idx": "474", "code": "public void addPropertyChangeListener(String propertyName,PropertyChangeListener listener){\n  propertyChangeSupport.addPropertyChangeListener(propertyName,listener);\n}\n", "docstring": "adds the property change listener .", "partition": "test"}
{"idx": "475", "code": "public File createNewFolder(File containingDir) throws IOException {\n  if (containingDir == null) {\n    throw new IOException(\"Containing directory is null:\");\n  }\n  File newFolder=createFileObject(containingDir,newFolderString);\n  int i=2;\n  while (newFolder.exists() && i < 100) {\n    newFolder=createFileObject(containingDir,MessageFormat.format(newFolderNextString,new Integer(i)));\n    i++;\n  }\n  if (newFolder.exists()) {\n    throw new IOException(\"Directory already exists:\" + newFolder.getAbsolutePath());\n  }\n else {\n    newFolder.mkdirs();\n  }\n  return newFolder;\n}\n", "docstring": "creates a new folder with a default folder name .", "partition": "test"}
{"idx": "476", "code": "public ResourcesPoet addTypedArray(String name,@NotNull List<String> values){\n  Element element=document.createElement(\"array\");\n  element.setAttribute(\"name\",name);\n  for (  String value : values) {\n    Element valueElement=document.createElement(\"item\");\n    valueElement.appendChild(document.createTextNode(value));\n    element.appendChild(valueElement);\n  }\n  resourceElement.appendChild(element);\n  return this;\n}\n", "docstring": "add a typed array to the config", "partition": "test"}
{"idx": "477", "code": "public boolean addSubAction(final ConfAction actionConf) throws GeneralException, ConfigurationException {\n  if (actionConf.getType() != null) {\n    final SubAction sub=SubAction.factory(actionConf.getType(),actionConf);\n    if (sub == null) {\n      if (Cfg.DEBUG) {\n        Check.log(TAG + \" Error (addSubAction): unknown type: \" + actionConf.getType());\n      }\n      return false;\n    }\n    list.add(sub);\n    if (sub instanceof SubActionSlow) {\n      setQueue(MAIN_QUEUE);\n    }\n    return true;\n  }\n else {\n    if (Cfg.DEBUG) {\n      Check.log(TAG + \" Error (addSubAction): null type \");\n    }\n    return false;\n  }\n}\n", "docstring": "adds the sub action .", "partition": "test"}
{"idx": "478", "code": "void fillEntryTree(Set<PageLeafEntry> entries,Row row){\n  int ptr=_rowHead;\n  byte[] buffer=_buffer;\n  while (ptr < BLOCK_SIZE) {\n    int code=buffer[ptr] & CODE_MASK;\n    int len=getLength(code,row);\n    if (code == INSERT || code == REMOVE) {\n      PageLeafEntry entry=new PageLeafEntry(this,row,ptr,len,code);\n      entries.add(entry);\n    }\n    ptr+=len;\n  }\n}\n", "docstring": "fills the entry tree map with entries from the block .", "partition": "test"}
{"idx": "479", "code": "public static <S>boolean containsAtleastOne(Collection<S> left,Collection<S> right){\n  if (left == null || right == null) {\n    return false;\n  }\n  for (  S id : left) {\n    if (right.contains(id)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if right hand collection has atleast one same item as left hand collection .", "partition": "test"}
{"idx": "480", "code": "public void logDiff(String id,String field,String db,String hw){\n  StringBuffer diffBuffer=new StringBuffer(String.format(\"Controller database object ID [%s], field [%s]: \",id,field));\n  if (db == null || db.isEmpty() || db.equalsIgnoreCase(NO_MATCHING_ENTRY)) {\n    diffBuffer.append(String.format(\"The hardware reported entry [%s], whereas the controller is not managing or does not have a reference to the same resource\\n\",hw));\n  }\n else   if (hw == null || hw.isEmpty() || hw.equalsIgnoreCase(NO_MATCHING_ENTRY)) {\n    diffBuffer.append(String.format(\"The controller is managing resource [%s], whereas the hardware did not report that resource\\n\",db));\n  }\n else {\n    diffBuffer.append(String.format(\"The controller references resource: [%s], whereas the hardware reported the actual resource as: [%s]\\n\",db != null ? db : \"null\",hw != null ? hw : \"null\"));\n  }\n  msgs.append(diffBuffer.toString() + \"\\n\");\n  if (log != null) {\n    log.info(diffBuffer.toString());\n  }\n}\n", "docstring": "log a discrepancy in the data .", "partition": "test"}
{"idx": "481", "code": "public FieldFrameBodyIMG(Lyrics3Image image){\n  images.add(image);\n}\n", "docstring": "creates a new fieldbodyimg datatype .", "partition": "test"}
{"idx": "482", "code": "public AbstractResource(String mimetype){\n  this(mimetype,System.currentTimeMillis());\n}\n", "docstring": "initializes this abstractresource with the given mimetype . the modification time of the resource is set to the current system time .", "partition": "test"}
{"idx": "483", "code": "private Parameters(){\n  for (Iterator i=arguments.iterator(); i.hasNext(); ) {\n    String arg=(String)i.next();\n    arg=arg.toLowerCase();\n    if (!arg.startsWith(\"-\"))     throw new IllegalArgumentException(\"Command-line argument does not start with \'-\': \" + arg);\n    int colonIndex=arg.indexOf(\":\");\n    String key;\n    String value;\n    if (colonIndex >= 0) {\n      key=arg.substring(1,colonIndex);\n      value=arg.substring(colonIndex + 1);\n    }\n else {\n      key=arg.substring(1);\n      value=\"\";\n    }\n    if (!allowedKeys.contains(key))     throw new IllegalArgumentException(\"Unrecognized command-line argument: \" + arg.substring(1) + \". Valid arguments are: \"+ StringUtil.toCommaDelimitedString(allowedKeys));\n    hashtable.put(key,value);\n  }\n  for (Iterator i=requiredKeys.iterator(); i.hasNext(); ) {\n    String requiredKey=(String)i.next();\n    if (!hashtable.containsKey(requiredKey))     throw new IllegalArgumentException(\"Required command-line argument is missing: \" + requiredKey);\n  }\n}\n", "docstring": "creates a parameters object for the given main - method arguments .", "partition": "test"}
{"idx": "484", "code": "public List<TLV> initRespondSmp(String question,String secret,boolean initiating) throws OtrException {\n  if (question != null && !initiating)   throw new IllegalArgumentException(\"Only supply a question if initiating\");\n  byte[] our_fp=Hex.decode(keyManager.getLocalFingerprint(sessionID));\n  String remoteFingerprint=keyManager.getRemoteFingerprint(sessionID);\n  if (remoteFingerprint == null)   throw new OtrException(\"no fingerprint for remote user\");\n  byte[] their_fp=Hex.decode(remoteFingerprint);\n  byte[] sessionId;\n  try {\n    sessionId=computeSessionId(session.getS());\n  }\n catch (  SMException ex) {\n    throw new OtrException(ex);\n  }\n  byte[] bytes=secret.getBytes(SerializationUtils.UTF8);\n  int combined_buf_len=41 + sessionId.length + bytes.length;\n  byte[] combined_buf=new byte[combined_buf_len];\n  combined_buf[0]=1;\n  if (initiating) {\n    System.arraycopy(our_fp,0,combined_buf,1,20);\n    System.arraycopy(their_fp,0,combined_buf,21,20);\n  }\n else {\n    System.arraycopy(their_fp,0,combined_buf,1,20);\n    System.arraycopy(our_fp,0,combined_buf,21,20);\n  }\n  System.arraycopy(sessionId,0,combined_buf,41,sessionId.length);\n  System.arraycopy(bytes,0,combined_buf,41 + sessionId.length,bytes.length);\n  MessageDigest sha256;\n  try {\n    sha256=MessageDigest.getInstance(\"SHA-256\");\n  }\n catch (  NoSuchAlgorithmException ex) {\n    throw new OtrException(ex);\n  }\n  byte[] combined_secret=sha256.digest(combined_buf);\n  byte[] smpmsg;\n  try {\n    if (initiating) {\n      smpmsg=SM.step1(smstate,combined_secret);\n    }\n else {\n      smpmsg=SM.step2b(smstate,combined_secret);\n    }\n  }\n catch (  SMException ex) {\n    throw new OtrException(ex);\n  }\n  if (question != null) {\n    bytes=question.getBytes(SerializationUtils.UTF8);\n    byte[] qsmpmsg=new byte[bytes.length + 1 + smpmsg.length];\n    System.arraycopy(bytes,0,qsmpmsg,0,bytes.length);\n    System.arraycopy(smpmsg,0,qsmpmsg,bytes.length + 1,smpmsg.length);\n    smpmsg=qsmpmsg;\n  }\n  TLV sendtlv=new TLV(initiating ? (question != null ? TLV.SMP1Q : TLV.SMP1) : TLV.SMP2,smpmsg);\n  smstate.nextExpected=initiating ? SM.EXPECT2 : SM.EXPECT3;\n  return makeTlvList(sendtlv);\n}\n", "docstring": "respond to or initiate an smp negotiation", "partition": "test"}
{"idx": "485", "code": "private double melToLinFreq(double inputFreq){\n  return (700.0 * (Math.pow(10.0,(inputFreq / 2595.0)) - 1.0));\n}\n", "docstring": "compute linear frequency from mel frequency .", "partition": "test"}
{"idx": "486", "code": "public RoundedIconGenerator(int iconWidthPx,int iconHeightPx,int cornerRadiusPx,int backgroundColor,float textSizePx){\n  mIconWidthPx=iconWidthPx;\n  mIconHeightPx=iconHeightPx;\n  mCornerRadiusPx=cornerRadiusPx;\n  mBackgroundRect=new RectF(0,0,mIconWidthPx,mIconHeightPx);\n  mBackgroundPaint=new Paint(Paint.ANTI_ALIAS_FLAG);\n  mBackgroundPaint.setColor(backgroundColor);\n  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);\n  mTextPaint.setColor(Color.WHITE);\n  mTextPaint.setFakeBoldText(true);\n  mTextPaint.setTextSize(textSizePx);\n  FontMetrics textFontMetrics=mTextPaint.getFontMetrics();\n  mTextHeight=(float)Math.ceil(textFontMetrics.bottom - textFontMetrics.top);\n  mTextYOffset=-textFontMetrics.top;\n}\n", "docstring": "constructs the generator and initializes the common members ignoring display density .", "partition": "test"}
{"idx": "487", "code": "public static byte[] randomBytes(int size){\n  byte[] bytes=new byte[size];\n  seededRandom.nextBytes(bytes);\n  return bytes;\n}\n", "docstring": "generate an array of random bytes", "partition": "test"}
{"idx": "488", "code": "@Override public String toString(){\n  StringBuffer BfString=new StringBuffer();\n  BfString.append(\"\\tAttribute ranking.\\n\");\n  if (m_starting != null) {\n    BfString.append(\"\\tIgnored attributes: \");\n    BfString.append(startSetToString());\n    BfString.append(\"\\n\");\n  }\n  if (m_threshold != -Double.MAX_VALUE) {\n    BfString.append(\"\\tThreshold for discarding attributes: \" + Utils.doubleToString(m_threshold,8,4) + \"\\n\");\n  }\n  return BfString.toString();\n}\n", "docstring": "returns a description of the search as a string", "partition": "test"}
{"idx": "489", "code": "protected void arraycopy(byte[] buf,int pos,int length){\n  mMessage.write(buf,pos,length);\n  mPosition=mPosition + length;\n}\n", "docstring": "copy buf to mmessage .", "partition": "test"}
{"idx": "490", "code": "public boolean expired(){\n  return System.currentTimeMillis() - time > DFLT_EXPIRATION_TIMEOUT;\n}\n", "docstring": "checks if cassandra driver session expired .", "partition": "test"}
{"idx": "491", "code": "private void handleSelection(View view,Item item,int position){\n  if (!item.isSelectable()) {\n    return;\n  }\n  if (item.isSelected() && !mAllowDeselection) {\n    return;\n  }\n  boolean selected=false;\n  if (mPositionBasedStateManagement) {\n    selected=mSelections.contains(position);\n  }\n else {\n    selected=item.isSelected();\n  }\n  if (mSelectWithItemUpdate || view == null) {\n    if (!mMultiSelect) {\n      deselect();\n    }\n    if (selected) {\n      deselect(position);\n    }\n else {\n      select(position);\n    }\n  }\n else {\n    if (!mMultiSelect) {\n      if (mPositionBasedStateManagement) {\n        Iterator<Integer> entries=mSelections.iterator();\n        while (entries.hasNext()) {\n          Integer pos=entries.next();\n          if (pos != position) {\n            deselect(pos,entries);\n          }\n        }\n      }\n else {\n        Set<Integer> selections=getSelections();\n        for (        int pos : selections) {\n          if (pos != position) {\n            deselect(pos);\n          }\n        }\n      }\n    }\n    item.withSetSelected(!selected);\n    view.setSelected(!selected);\n    if (mSelectionListener != null)     mSelectionListener.onSelectionChanged(item,!selected);\n    if (mPositionBasedStateManagement) {\n      if (selected) {\n        if (mSelections.contains(position)) {\n          mSelections.remove(position);\n        }\n      }\n else {\n        mSelections.add(position);\n      }\n    }\n  }\n}\n", "docstring": "handles the selection and deselects item if multiselect is disabled", "partition": "test"}
{"idx": "492", "code": "public boolean canInvoke(MDepreciationWorkfile assetwk,MAssetAcct assetAcct,int A_Current_Period,BigDecimal Accum_Dep){\n  if (assetwk == null) {\n    log.warning(\"@NotFound@ @A_Depreciation_Workfile_ID@\");\n    return false;\n  }\n  int offset=0;\n  int lifePeriods=assetwk.getUseLifeMonths(assetwk.isFiscal());\n  boolean ok=(offset <= A_Current_Period);\n  if (CLogMgt.isLevelFinest())   log.finest(\"A_Current_Period=\" + A_Current_Period + \", lifePeriods=\"+ lifePeriods+ \" (offset=\"+ offset+ \") ==> OK=\"+ ok);\n  return ok;\n}\n", "docstring": "check if the method can be invoked to give parameters", "partition": "test"}
{"idx": "493", "code": "public TreeMap<Float,List<List<Integer>>> packModifiedFirstFitDescending(){\n  throw new UnsupportedOperationException(\"Not implemented yet!\");\n}\n", "docstring": "note : upper bound is 71 / 60 opt + 6 / 9 ( ~ 1 . 18 opt )", "partition": "test"}
{"idx": "494", "code": "public void addTextChangeListener(final FilterQueryChangeListener textChangeListener){\n  listeners.add(textChangeListener);\n}\n", "docstring": "adds the given listener", "partition": "test"}
{"idx": "495", "code": "@Override public Iterator<Profile> iterator(){\n  return profiles.iterator();\n}\n", "docstring": "get an iterator of profiles .", "partition": "test"}
{"idx": "496", "code": "private boolean startsWithSpace(String str){\n  return str.length() != 0 && str.charAt(0) == ' ';\n}\n", "docstring": "checks if the string starts with a space character , false if the string is empty or starts with a non - space character .", "partition": "test"}
{"idx": "497", "code": "private int keyToLevel(String key){\n  String[] token=key.split(\"/\");\n  return (token.length - 1);\n}\n", "docstring": "given a key , find the level", "partition": "test"}
{"idx": "498", "code": "public boolean mouseDragged(MouseEvent e){\n  if (grabbed_plot_graphics_) {\n    int x=e.getX();\n    int y=e.getY();\n    int dx=x - prevX;\n    int dy=y - prevY;\n    plotX+=dx;\n    plotY+=dy;\n    prevX=x;\n    prevY=y;\n    graph.resize(plotX,plotY,plotWidth,plotHeight);\n    OMGraphicList plotGraphics=graph.getPlotGraphics();\n    plotGraphics.generate(getProjection(),true);\n    repaint();\n  }\n  return false;\n}\n", "docstring": "called whenever the mouse is dragged on this layer and one of the requested mouse modes is active .", "partition": "test"}
{"idx": "499", "code": "public void load(GeneralSubtrees generalSubtrees){\n  List<GeneralSubtree> generalSubtreesList=generalSubtrees.getGeneralSubtrees();\n  Collections.sort(generalSubtreesList,new GeneralSubtreeBaseComparator());\n  data=new Object[generalSubtreesList.size()][3];\n  int i=0;\n  for (  GeneralSubtree generalSubtree : generalSubtreesList) {\n    data[i][0]=generalSubtree;\n    data[i][1]=generalSubtree;\n    data[i][2]=generalSubtree;\n    i++;\n  }\n  fireTableDataChanged();\n}\n", "docstring": "load the generalsubtreestablemodel with general subtrees .", "partition": "test"}
{"idx": "500", "code": "public boolean isPingDisabled(){\n  return (null != healthcheck && !healthcheck.exists());\n}\n", "docstring": "returns true if the healthcheck flag - file is enabled but does not exist , otherwise ( no file configured , or file configured and exists ) returns false .", "partition": "test"}
{"idx": "501", "code": "public static void writeToFile(File file,String contents) throws IOException {\n  FileOutputStream fos=new FileOutputStream(file);\n  fos.write(contents.getBytes());\n  fos.close();\n}\n", "docstring": "writes the contents to the file at the given location ( this creates the file or deletes its existing contents . )", "partition": "test"}
{"idx": "502", "code": "public void makeTreeOfWritables(Iterable<Pair<String,Integer>> flatData){\n  Text key=new Text();\n  for (  Pair<String,Integer> pair : flatData) {\n    key.set(pair.key);\n    ArrayList<IntWritable> valList;\n    if (!mockInput.containsKey(key)) {\n      valList=new ArrayList<>();\n      mockInput.put(key,valList);\n      key=new Text();\n    }\n else     valList=(ArrayList<IntWritable>)mockInput.get(key);\n    valList.add(new IntWritable(pair.value()));\n  }\n}\n", "docstring": "generate one - key - multiple - values tree from array of key - value pairs , and wrap its into writable objects . the result is placed into mock input .", "partition": "test"}
{"idx": "503", "code": "public static double angle(Coordinate p0,Coordinate p1){\n  double dx=p1.x - p0.x;\n  double dy=p1.y - p0.y;\n  return Math.atan2(dy,dx);\n}\n", "docstring": "returns the angle of the vector from p0 to p1 , relative to the positive x - axis . the angle is normalized to be in the range [ - pi , pi ", "partition": "test"}
{"idx": "504", "code": "public InMemoryCursor(String[] columnNames){\n  mCurrentPosition=-1;\n  mColumnNames=columnNames;\n}\n", "docstring": "creates a new cursor setting the columns names that will be used by this cursor . the length of this array determines the number of columns that the cursor can handle . filling that below this number will set the rest of the values to null , and all items above it will be ignored .", "partition": "test"}
{"idx": "505", "code": "@Override public boolean isEnabled(){\n  if ((attributeSelectionPanel != null) && !isValueOnly()) {\n    return attributeSelectionPanel.isEnabled();\n  }\n else {\n    if (slider != null) {\n      return slider.isEnabled();\n    }\n  }\n  return false;\n}\n", "docstring": "checks if is enabled .", "partition": "test"}
{"idx": "506", "code": "private void renderForeground(final ExecutionUnit process,final Graphics2D g2,boolean printing){\n  if (drawHighlight && !printing && (model.isDragStarted() || model.isDropTargetSet() && model.isImportDragged()) || model.isOperatorSourceHovered()) {\nswitch (RapidMinerGUI.getDragHighlighteMode()) {\ncase FULL:\ncase BORDER:\n      drawDragBorder(process,g2);\n    break;\ncase NONE:\ndefault :\n  break;\n}\n}\n}\n", "docstring": "renders the drag border if needed .", "partition": "test"}
{"idx": "507", "code": "public ModbusTransaction createTransaction(){\n  ModbusSerialTransaction transaction=new ModbusSerialTransaction();\n  transaction.setTransport(this);\n  return transaction;\n}\n", "docstring": "creates a new transaction suitable for the serial port", "partition": "test"}
{"idx": "508", "code": "public void start(){\n  if (runner == null) {\n    runner=new Thread(this,\"Runner\");\n    runner.start();\n  }\n}\n", "docstring": "we \"'\" re starting the thread", "partition": "test"}
{"idx": "509", "code": "protected final File createDBFFDCDirectory(){\n  File dbffdcDir=new File(ffdcDirectoryName);\n  if (!dbffdcDir.exists()) {\n    final boolean isDBFFDcDirCreated=dbffdcDir.mkdirs();\n    if (isDBFFDcDirCreated) {\n      dbffdcDir=new File(ffdcDirectoryName);\n      return dbffdcDir;\n    }\n  }\n else   if (!dbffdcDir.isDirectory()) {\n    return null;\n  }\n  return dbffdcDir;\n}\n", "docstring": "creates the sub - directory where this particular back - up instance will be kept .", "partition": "test"}
{"idx": "510", "code": "public static String readCharacterSizedString(InputStream stream) throws IOException {\n  StringBuilder result=new StringBuilder();\n  int strLen=readUINT16(stream);\n  int character=stream.read();\n  character|=stream.read() << 8;\n  do {\n    if (character != 0) {\n      result.append((char)character);\n      character=stream.read();\n      character|=stream.read() << 8;\n    }\n  }\n while (character != 0 || (result.length() + 1) > strLen);\n  if (strLen != (result.length() + 1)) {\n    throw new IllegalStateException(\"Invalid Data for current interpretation\");\n  }\n  return result.toString();\n}\n", "docstring": "this method reads a utf - 16 string , which length is given on the number of characters it consists of . < br > the stream must be at the number of characters . this number contains the terminating zero character ( uint16 ) .", "partition": "test"}
{"idx": "511", "code": "protected void processChildren(QueryNode queryTree) throws QueryNodeException {\n  List<QueryNode> children=queryTree.getChildren();\n  ChildrenList newChildren;\n  if (children != null && children.size() > 0) {\n    newChildren=allocateChildrenList();\n    try {\n      for (      QueryNode child : children) {\n        child=processIteration(child);\n        if (child == null) {\n          throw new NullPointerException();\n        }\n        newChildren.add(child);\n      }\n      List<QueryNode> orderedChildrenList=setChildrenOrder(newChildren);\n      queryTree.set(orderedChildrenList);\n    }\n  finally {\n      newChildren.beingUsed=false;\n    }\n  }\n}\n", "docstring": "this method is called every time a child is processed .", "partition": "test"}
{"idx": "512", "code": "private void initializeMessages(List<String> messages){\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getGeneralMessages()));\n  if (OSUtils.isWindows()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getWindowsMessages()));\n  }\n else   if (OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getMacOSXMessages()));\n  }\n else   if (OSUtils.isLinux()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getLinuxMessages()));\n  }\n else {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getOtherMessages()));\n  }\n  if (!OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getNonMacOSXMessages()));\n  }\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getFrostWireMessages()));\n  Collections.shuffle(messages);\n  _currentTip=-1;\n}\n", "docstring": "iterates through all the tips \"'\" keys and stores the ones that are valid for this os .", "partition": "test"}
{"idx": "513", "code": "public PersistedQueue(final File queueEnvPath,final String queueName,final int cacheSize){\n  queueEnvPath.mkdirs();\n  final EnvironmentConfig dbEnvConfig=new EnvironmentConfig();\n  dbEnvConfig.setTransactional(false);\n  dbEnvConfig.setAllowCreate(true);\n  this.dbEnv=new Environment(queueEnvPath,dbEnvConfig);\n  DatabaseConfig dbConfig=new DatabaseConfig();\n  dbConfig.setTransactional(false);\n  dbConfig.setAllowCreate(true);\n  dbConfig.setDeferredWrite(true);\n  this.queueDatabase=dbEnv.openDatabase(null,queueName,dbConfig);\n  this.queueName=queueName;\n  this.cacheSize=cacheSize;\n  this.opsCounter=0;\n}\n", "docstring": "creates instance of persistent queue .", "partition": "test"}
{"idx": "514", "code": "protected final StringBuilder write(StringBuilder sb,final Object... objects){\n  for (  Object string : objects)   sb.append(string);\n  return sb;\n}\n", "docstring": "this method adds to the sb the objects .", "partition": "test"}
{"idx": "515", "code": "public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  int vocabSize=in.readInt();\n  for (int i=0; i < vocabSize; i++) {\n    String line=in.readUTF();\n    Vocabulary.id(line);\n  }\n  numTokens=in.readDouble();\n  countFuncs=new long[in.readInt()][2];\n  for (int i=0; i < countFuncs.length; i++) {\n    countFuncs[i][0]=in.readLong();\n    countFuncs[i][1]=in.readLong();\n  }\n  typesFuncs=new long[in.readInt()][2];\n  for (int i=0; i < typesFuncs.length; i++) {\n    typesFuncs[i][0]=in.readLong();\n    typesFuncs[i][1]=in.readLong();\n  }\n  quantizationBase=in.readDouble();\n  bf=new BloomFilter();\n  bf.readExternal(in);\n}\n", "docstring": "read a bloom filter lm from an external file .", "partition": "test"}
{"idx": "516", "code": "public static double computeMAD(double[] x,double median){\n  for (int i=0; i < x.length; i++) {\n    x[i]=Math.abs(x[i] - median);\n  }\n  double mad=QuickSelect.median(x);\n  if (!(mad > 0.)) {\n    double min=Double.POSITIVE_INFINITY;\n    for (    double xi : x) {\n      if (xi > 0. && xi < min) {\n        min=xi;\n      }\n    }\n    if (min < Double.POSITIVE_INFINITY) {\n      mad=min;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  if (mad == Double.POSITIVE_INFINITY) {\n    double max=0.;\n    for (    double xi : x) {\n      if (xi < Double.POSITIVE_INFINITY && xi > max) {\n        max=xi;\n      }\n    }\n    if (max < Double.POSITIVE_INFINITY) {\n      mad=max;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  return mad;\n}\n", "docstring": "compute the median absolute deviation from median .", "partition": "test"}
{"idx": "517", "code": "public SdpException(Throwable rootCause){\n  super(rootCause.getLocalizedMessage());\n}\n", "docstring": "constructs a new sdpexception as a result of a system exception and uses the localized system exception message .", "partition": "test"}
{"idx": "518", "code": "protected void notifyPropertyChangeListener(String property,Object oldValue,Object newValue){\n  Set<PropertyChangeListener> v;\nsynchronized (this) {\n    v=new HashSet<>(listeners);\n  }\n  for (  PropertyChangeListener listener : v) {\n    listener.propertyChange(new PropertyChangeEvent(this,property,oldValue,newValue));\n  }\n}\n", "docstring": "trigger the notification of all propertychangelisteners", "partition": "test"}
{"idx": "519", "code": "public boolean indicateDirtyRead(ITemplateHolder template){\n  return ((template.isReadOperation() && _useDirtyRead) || template.isDirtyReadRequested());\n}\n", "docstring": "given an entry and a template , return true if dirty - read should be performed", "partition": "test"}
{"idx": "520", "code": "protected void applyAttributesToSymbol(TacticalGraphicAttributes graphicAttributes,TacticalSymbolAttributes symbolAttributes){\n  Double value=graphicAttributes.getInteriorOpacity();\n  if (value != null) {\n    symbolAttributes.setOpacity(value);\n  }\n  value=graphicAttributes.getScale();\n  if (value != null) {\n    symbolAttributes.setScale(value);\n  }\n  Material material=graphicAttributes.getInteriorMaterial();\n  symbolAttributes.setInteriorMaterial(material);\n  Font font=graphicAttributes.getTextModifierFont();\n  if (font != null) {\n    symbolAttributes.setTextModifierFont(font);\n  }\n  material=graphicAttributes.getTextModifierMaterial();\n  if (material != null) {\n    symbolAttributes.setTextModifierMaterial(material);\n  }\n}\n", "docstring": "apply graphic attributes to the symbol .", "partition": "test"}
{"idx": "521", "code": "public RemoteServiceDescriptor(String baseUrl,HttpJsonRequestFactory requestFactory) throws IllegalArgumentException {\n  this.baseUrl=baseUrl;\n  this.requestFactory=requestFactory;\n  try {\n    final URL baseUrlURL=new URL(baseUrl);\n    final String protocol=baseUrlURL.getProtocol();\n    if (!(protocol.equals(\"http\") || protocol.equals(\"https\"))) {\n      throw new IllegalArgumentException(String.format(\"Invalid URL: %s\",baseUrl));\n    }\n  }\n catch (  MalformedURLException e) {\n    throw new IllegalArgumentException(String.format(\"Invalid URL: %s\",baseUrl));\n  }\n}\n", "docstring": "creates new descriptor of remote restful service .", "partition": "test"}
{"idx": "522", "code": "public Server start() throws SQLException {\n  try {\n    started=true;\n    service.start();\n    String name=service.getName() + \" (\" + service.getURL()+ \")\";\n    Thread t=new Thread(this,name);\n    t.setDaemon(service.isDaemon());\n    t.start();\n    for (int i=1; i < 64; i+=i) {\n      wait(i);\n      if (isRunning(false)) {\n        return this;\n      }\n    }\n    if (isRunning(true)) {\n      return this;\n    }\n    throw DbException.get(ErrorCode.EXCEPTION_OPENING_PORT_2,name,\"timeout; \" + \"please check your network configuration, specially the file /etc/hosts\");\n  }\n catch (  DbException e) {\n    throw DbException.toSQLException(e);\n  }\n}\n", "docstring": "tries to start the server .", "partition": "test"}
{"idx": "523", "code": "@Override public boolean isComplete(){\n  return true;\n}\n", "docstring": "test if the profile is complete .", "partition": "test"}
{"idx": "524", "code": "public ByteMatrix encode(String contents,int width,int height,Map<EncodeHintType,Object> hints) throws WriterException {\n  if (contents == null || contents.length() == 0) {\n    throw new IllegalArgumentException(\"Found empty contents\");\n  }\n  if (width < 0 || height < 0) {\n    throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + \'x\'+ height);\n  }\n  ErrorCorrectionLevel errorCorrectionLevel=ErrorCorrectionLevel.L;\n  if (hints != null) {\n    ErrorCorrectionLevel requestedECLevel=(ErrorCorrectionLevel)hints.get(EncodeHintType.ERROR_CORRECTION);\n    if (requestedECLevel != null) {\n      errorCorrectionLevel=requestedECLevel;\n    }\n  }\n  QRCode code=new QRCode();\n  Encoder.encode(contents,errorCorrectionLevel,hints,code);\n  return renderResult(code,width,height);\n}\n", "docstring": "encode a string into a qr code with dimensions width x height . hints contains suggestions for error - correction level and version . the default error - correction level is l , the default version is the smallest version for which the contents will fit into the qr - code .", "partition": "test"}
{"idx": "525", "code": "public Request header(String key,String value){\n  Objects.requireNonNull(key);\n  Objects.requireNonNull(value);\n  _headers.put(key,value);\n  return this;\n}\n", "docstring": "sets a header to use with http request", "partition": "test"}
{"idx": "526", "code": "public void updateUI(){\n  super.updateUI();\n  setBackground(new Color(255,255,255,0));\n  setWrapStyleWord(true);\n  setHighlighter(null);\n  setEditable(false);\n  LookAndFeel.installBorder(this,\"Label.border\");\n  LookAndFeel.installColorsAndFont(this,\"Label.background\",\"Label.foreground\",\"Label.font\");\n  if (resizeHandler != null) {\n    resizeHandler.componentResized(null);\n  }\n  SizePolicy policy=(SizePolicy)getClientProperty(SizePolicy.class);\n  if (policy != null) {\n    GUIUtils.restrictSize(this,policy);\n  }\n}\n", "docstring": "tells the look and feel to reset some of the values for this component so that it doesn \"'\" t use jtextarea \"'\" s default values . do not call this method yourself !", "partition": "test"}
{"idx": "527", "code": "public static void generateExtensionManager(File rootFolder) throws IOException {\n  File outFile=new File(rootFolder,REGISTRY_PATH);\n  StringBuilder builder=new StringBuilder();\n  builder.append(\"package org.eclipse.che.ide.client;\\n\\n\");\n  generateImports(builder);\n  generateClass(builder);\n  FileUtils.writeStringToFile(outFile,builder.toString());\n}\n", "docstring": "generate to source of the class .", "partition": "test"}
{"idx": "528", "code": "public synchronized Future<V> submit(Callable<V> task) throws RejectedExecutionException {\n  return pool.submit(task);\n}\n", "docstring": "submits a task for execution .", "partition": "test"}
{"idx": "529", "code": "private void checkBucketName(String name) throws InvalidBucketNameException {\n  if (name == null) {\n    throw new InvalidBucketNameException(NULL_STRING,\"null bucket name\");\n  }\n  if (name.length() < 3 || name.length() > 63) {\n    String msg=\"bucket name must be at least 3 and no more than 63 characters long\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n  if (name.matches(\"\\\\.\\\\.\")) {\n    String msg=\"bucket name cannot contain successive periods. For more information refer \" + \"http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n  if (!name.matches(\"^[a-z0-9][a-z0-9\\\\.\\\\-]+[a-z0-9]$\")) {\n    String msg=\"bucket name does not follow Amazon S3 standards. For more information refer \" + \"http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\";\n    throw new InvalidBucketNameException(name,msg);\n  }\n}\n", "docstring": "validates if given bucket name is dns compatible .", "partition": "test"}
{"idx": "530", "code": "private void validateUserNamespaceAuthorizationCreateRequest(UserNamespaceAuthorizationCreateRequest request){\n  Assert.notNull(request,\"A user namespace authorization create request must be specified.\");\n  validateUserNamespaceAuthorizationKey(request.getUserNamespaceAuthorizationKey());\n  validateNamespacePermissions(request.getNamespacePermissions());\n}\n", "docstring": "validates the user namespace authorization create request . this method also trims the request parameters .", "partition": "test"}
{"idx": "531", "code": "protected String format(Object o){\n  return o.toString();\n}\n", "docstring": "default object formatter using object . tostring ( ) .", "partition": "test"}
{"idx": "532", "code": "public void calculateDerived(){\n  xStats.calculateDerived();\n  yStats.calculateDerived();\n  differencesStats.calculateDerived();\n  correlation=Double.NaN;\n  if (!Double.isNaN(xStats.stdDev) && !Double.isNaN(yStats.stdDev) && !Utils.eq(xStats.stdDev,0)) {\n    double slope=(xySum - xStats.sum * yStats.sum / count) / (xStats.sumSq - xStats.sum * xStats.mean);\n    if (!Utils.eq(yStats.stdDev,0)) {\n      correlation=slope * xStats.stdDev / yStats.stdDev;\n    }\n else {\n      correlation=1.0;\n    }\n  }\n  if (Utils.gr(differencesStats.stdDev,0)) {\n    double tval=differencesStats.mean * Math.sqrt(count) / differencesStats.stdDev;\n    if (m_degreesOfFreedom >= 1) {\n      differencesProbability=Statistics.FProbability(tval * tval,1,m_degreesOfFreedom);\n    }\n else {\n      if (count > 1) {\n        differencesProbability=Statistics.FProbability(tval * tval,1,(int)count - 1);\n      }\n else {\n        differencesProbability=1;\n      }\n    }\n  }\n else {\n    if (differencesStats.sumSq == 0) {\n      differencesProbability=1.0;\n    }\n else {\n      differencesProbability=0.0;\n    }\n  }\n  differencesSignificance=0;\n  if (differencesProbability <= sigLevel) {\n    if (xStats.mean > yStats.mean) {\n      differencesSignificance=1;\n    }\n else {\n      differencesSignificance=-1;\n    }\n  }\n}\n", "docstring": "calculates the derived statistics ( significance etc ) .", "partition": "test"}
{"idx": "533", "code": "protected boolean canDeleteConsistencyGroup(final BlockConsistencyGroup consistencyGroup){\n  return (!consistencyGroup.getInactive() && !consistencyGroup.created());\n}\n", "docstring": "check to see if the consistency group is active and not created . in this case we can delete the consistency group . otherwise we should not delete the consistency group .", "partition": "test"}
{"idx": "534", "code": "public AmqpMessage receiveNoWait() throws Exception {\n  checkClosed();\n  return prefetch.poll();\n}\n", "docstring": "if a message is already available in this receiver \"'\" s prefetch buffer then it is returned immediately otherwise this methods return null without waiting .", "partition": "test"}
{"idx": "535", "code": "private boolean zzRefill() throws java.io.IOException {\n  if (zzStartRead > 0) {\n    System.arraycopy(zzBuffer,zzStartRead,zzBuffer,0,zzEndRead - zzStartRead);\n    zzEndRead-=zzStartRead;\n    zzCurrentPos-=zzStartRead;\n    zzMarkedPos-=zzStartRead;\n    zzPushbackPos-=zzStartRead;\n    zzStartRead=0;\n  }\n  if (zzCurrentPos >= zzBuffer.length) {\n    final char newBuffer[]=new char[zzCurrentPos * 2];\n    System.arraycopy(zzBuffer,0,newBuffer,0,zzBuffer.length);\n    zzBuffer=newBuffer;\n  }\n  final int numRead=zzReader.read(zzBuffer,zzEndRead,zzBuffer.length - zzEndRead);\n  if (numRead < 0) {\n    return true;\n  }\n else {\n    zzEndRead+=numRead;\n    return false;\n  }\n}\n", "docstring": "refills the input buffer .", "partition": "test"}
{"idx": "536", "code": "private void checkDuplicateNamesDuringDelete(List<Integer> ids){\n  ArrayList<Entity> myEntities=game.getPlayerEntities(game.getPlayer(localPlayerNumber),false);\n  Hashtable<String,ArrayList<Integer>> rawNameToId=new Hashtable<String,ArrayList<Integer>>((int)(myEntities.size() * 1.26));\n  for (  Entity e : myEntities) {\n    String rawName=e.getShortNameRaw();\n    ArrayList<Integer> namedIds=rawNameToId.get(rawName);\n    if (namedIds == null) {\n      namedIds=new ArrayList<Integer>();\n    }\n    namedIds.add(e.getId());\n    rawNameToId.put(rawName,namedIds);\n  }\n  for (  int id : ids) {\n    Entity removedEntity=game.getEntity(id);\n    if (removedEntity == null) {\n      continue;\n    }\n    String removedRawName=removedEntity.getShortNameRaw();\n    Integer count=duplicateNameHash.get(removedEntity.getShortNameRaw());\n    if ((count != null) && (count > 1)) {\n      ArrayList<Integer> namedIds=rawNameToId.get(removedRawName);\n      for (      Integer i : namedIds) {\n        Entity e=game.getEntity(i);\n        String eRawName=e.getShortNameRaw();\n        if (eRawName.equals(removedRawName) && (e.duplicateMarker > removedEntity.duplicateMarker)) {\n          e.duplicateMarker--;\n          e.generateShortName();\n          e.generateDisplayName();\n          if (!ids.contains(e.getId())) {\n            sendUpdateEntity(e);\n          }\n        }\n      }\n      duplicateNameHash.put(removedEntity.getShortNameRaw(),new Integer(count - 1));\n    }\n else     if (count != null) {\n      duplicateNameHash.remove(removedEntity.getShortNameRaw());\n    }\n  }\n}\n", "docstring": "if we remove an entity , we may need to update the duplicate identifier .", "partition": "test"}
{"idx": "537", "code": "protected void stopBKCluster() throws Exception {\n  if (bkc != null) {\n    bkc.close();\n  }\n  for (  BookieServer server : bs) {\n    server.shutdown();\n    AutoRecoveryMain autoRecovery=autoRecoveryProcesses.get(server);\n    if (autoRecovery != null && isAutoRecoveryEnabled()) {\n      autoRecovery.shutdown();\n      LOG.debug(\"Shutdown auto recovery for bookieserver:\" + server.getLocalAddress());\n    }\n  }\n  bs.clear();\n  for (  File f : tmpDirs) {\n    FileUtils.deleteDirectory(f);\n  }\n}\n", "docstring": "stop cluster . also , stops all the auto recovery processes for the bookie cluster , if isautorecoveryenabled is true .", "partition": "test"}
{"idx": "538", "code": "public void releaseSelections(Set<Entity> items){\n  for (  Entity item : items) {\n    releaseSelection(item);\n  }\n}\n", "docstring": "remove selection to a list of items", "partition": "test"}
{"idx": "539", "code": "public HubLinkMapping(String fileName,int numberOfHubs,Network network){\n  this.numberOfHubs=numberOfHubs;\n  if (fileName.contains(\".mappingTable.\")) {\n    readMappingTable(fileName);\n    unMappedLinksAtZeroHub=true;\n    return;\n  }\n  handleUnmappedLinksStart();\n  try {\n    FileReader fr=new FileReader(fileName);\n    BufferedReader br=new BufferedReader(fr);\n    String line;\n    StringTokenizer tokenizer;\n    String token;\n    int linkId;\n    line=br.readLine();\n    while (line != null) {\n      tokenizer=new StringTokenizer(line);\n      for (int i=0; i < this.numberOfHubs; i++) {\n        token=tokenizer.nextToken();\n        linkId=(int)Double.parseDouble(token);\n        linkHubMapping.put(Integer.toString(linkId),i);\n      }\n      if (tokenizer.hasMoreTokens()) {\n        throw new RuntimeException(\"the number of hubs is wrong\");\n      }\n      line=br.readLine();\n    }\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error reading the hub link mapping file\");\n  }\n  linkHubMapping.remove(\"-1\");\n  handleUnmappedLinksEnd(network);\n}\n", "docstring": "reads the mappings from the file . the file has columns ( first column for first hub and all the links corresponding to that hub below it )", "partition": "test"}
{"idx": "540", "code": "public boolean deleteLoadName(String load){\n  if (!_loadList.contains(load)) {\n    return false;\n  }\n  _loadList.remove(load);\n  log.debug(\"train (\" + getName() + \") delete car load \"+ load);\n  setDirtyAndFirePropertyChange(LOADS_CHANGED_PROPERTY,_loadList.size() + 1,_loadList.size());\n  return true;\n}\n", "docstring": "delete a load name that the train will either service or exclude . see setloadoption", "partition": "test"}
{"idx": "541", "code": "private ComputeState validateComputeName(String awsId,String vmName) throws Throwable {\n  if (this.isAwsClientMock) {\n    return null;\n  }\n  ComputeState computeState=getComputeByAWSId(this.host,awsId);\n  String tagNameValue=computeState.name;\n  assertNotNull(\"\'displayName\' property should be present\",tagNameValue);\n  assertEquals(vmName,tagNameValue);\n  return computeState;\n}\n", "docstring": "validates the tag information on a compute state matches an expected virtual machine name .", "partition": "test"}
{"idx": "542", "code": "public static String fromTag(IntArrayTag tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  int value : tag.getValue()) {\n    IntTag i=new IntTag(value);\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromTag(i));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}\n", "docstring": "creates a mojangson string from the given intarray tag .", "partition": "test"}
{"idx": "543", "code": "public static int removeArgsAndReturnInsertionIndex(List<String> args,int argIndex,boolean tryRemovingArgValue){\n  if (argIndex < 0 || argIndex >= args.size()) {\n    return 0;\n  }\n  if (tryRemovingArgValue) {\n    String argValue=getArgValue(args,argIndex + 1);\n    if (argValue != null) {\n      args.remove(argIndex + 1);\n    }\n  }\n  args.remove(argIndex);\n  return argIndex;\n}\n", "docstring": "removes the argument at the given index .", "partition": "test"}
{"idx": "544", "code": "void replacePolicyInResourceTree(ServiceTypeManager svtm,SSOToken token,Policy oldPolicy,Policy newPolicy) throws PolicyException, SSOException {\n  removePolicyFromResourceTree(svtm,token,oldPolicy);\n  addPolicyToResourceTree(svtm,token,newPolicy);\n}\n", "docstring": "replaces a policy \"'\" s relevant content in the resource tree .", "partition": "test"}
{"idx": "545", "code": "public AtomicDoubleArray(int length){\n  larray=new AtomicLongArray(length);\n  long ZERO=Double.doubleToRawLongBits(0.0);\n  for (int i=0; i < length; i++)   larray.set(i,ZERO);\n}\n", "docstring": "creates a new atomicdoublearray of the given length , with all values initialized to zero", "partition": "test"}
{"idx": "546", "code": "private void recomputeSeperation(double[][] means,double[][] cdist,LongStatistic diststat){\n  final int k=means.length;\n  for (int i=1; i < k; i++) {\n    DoubleVector mi=DoubleVector.wrap(means[i]);\n    for (int j=0; j < i; j++) {\n      cdist[i][j]=cdist[j][i]=distanceFunction.distance(mi,DoubleVector.wrap(means[j]));\n    }\n  }\n  if (diststat != null) {\n    diststat.increment((k * (k - 1)) >> 1);\n  }\n}\n", "docstring": "recompute the separation of cluster means .", "partition": "test"}
{"idx": "547", "code": "private static BufferedImage makeSquare(BufferedImage input){\n  if (input.getHeight() == input.getWidth()) {\n    return input;\n  }\n else {\n    int max=Math.max(input.getHeight(),input.getWidth());\n    int dx=(max - input.getWidth()) / 2;\n    int dy=(max - input.getHeight()) / 2;\n    return createImg(max,max,input.getType(),null);\n  }\n}\n", "docstring": "returns an image where the input image is centered .", "partition": "test"}
{"idx": "548", "code": "public void writeStartElement(String localName) throws XMLStreamException {\n  if (localName == null || localName.length() == 0) {\n    throw new XMLStreamException(\"Local Name cannot be null or empty\");\n  }\n  _state=STATE_ELEMENT;\n  if (_currentEle != null && _currentEle.getState() == ELEMENT_STARTTAG_OPEN) {\n    closeStartTag();\n  }\n  _currentEle=new Element(_currentEle,localName,false);\n  openStartTag();\n  _writer.write(localName);\n}\n", "docstring": "writes a start tag to the output .", "partition": "test"}
{"idx": "549", "code": "public void addProcessInteractionListener(final ProcessInteractionListener l){\n  if (l == null) {\n    throw new IllegalArgumentException(\"l must not be null!\");\n  }\n  processInteractionListeners.add(l);\n}\n", "docstring": "adds a listener that will be informed when the user right - clicks an operator or a port .", "partition": "test"}
{"idx": "550", "code": "private void traverseInternal(Object root,boolean yieldRoot,IdentityHashMap<Object,Object> seen){\n  if (root == null || seen.containsKey(root)) {\n    return;\n  }\n  if (yieldRoot) {\n    if (!visit(root)) {\n      return;\n    }\n  }\n  seen.put(root,root);\n  if (root instanceof JSONObject) {\n    JSONObject json=(JSONObject)root;\n    Iterator<String> keys=json.keys();\n    while (keys.hasNext()) {\n      String key=keys.next();\n      try {\n        traverseInternal(json.get(key),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof JSONArray) {\n    JSONArray array=(JSONArray)root;\n    for (int i=0; i < array.length(); ++i) {\n      try {\n        traverseInternal(array.get(i),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof Map) {\n    Map<?,?> map=(Map<?,?>)root;\n    for (    Object value : map.values()) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof List) {\n    List<?> list=(List<?>)root;\n    for (    Object value : list) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof ParseObject) {\n    if (traverseParseObjects) {\n      ParseObject object=(ParseObject)root;\n      for (      String key : object.keySet()) {\n        traverseInternal(object.get(key),true,seen);\n      }\n    }\n  }\n else   if (root instanceof ParseACL) {\n    ParseACL acl=(ParseACL)root;\n    ParseUser user=acl.getUnresolvedUser();\n    if (user != null && user.isCurrentUser()) {\n      traverseInternal(user,true,seen);\n    }\n  }\n}\n", "docstring": "internal implementation of traverse .", "partition": "test"}
{"idx": "551", "code": "public StrBuilder replaceFirst(final String searchStr,final String replaceStr){\n  final int searchLen=(searchStr == null ? 0 : searchStr.length());\n  if (searchLen > 0) {\n    final int index=indexOf(searchStr,0);\n    if (index >= 0) {\n      final int replaceLen=(replaceStr == null ? 0 : replaceStr.length());\n      replaceImpl(index,index + searchLen,searchLen,replaceStr,replaceLen);\n    }\n  }\n  return this;\n}\n", "docstring": "replaces the first instance of the search string with the replace string .", "partition": "test"}
{"idx": "552", "code": "protected abstract void internalPut(int index,byte b);\n", "docstring": "stores the byte at the index given .", "partition": "test"}
{"idx": "553", "code": "public CommonTurnoutOperationConfig(TurnoutOperation op){\n  super(op);\n  myOp=(CommonTurnoutOperation)op;\n  maxTriesSpinner=new JSpinner();\n  intervalSpinner=new JSpinner();\n  Box vbox=Box.createVerticalBox();\n  Box hbox1=Box.createHorizontalBox();\n  Box hbox2=Box.createHorizontalBox();\n  vbox.add(hbox2);\n  vbox.add(hbox1);\n  vbox.add(Box.createVerticalGlue());\n  hbox1.add(new JLabel(Bundle.getMessage(\"Interval\")));\n  hbox1.add(Box.createHorizontalGlue());\n  intervalSpinner.setMinimumSize(new Dimension(100,20));\n  intervalSpinner.setModel(new SpinnerNumberModel(myOp.getInterval(),CommonTurnoutOperation.minInterval,CommonTurnoutOperation.maxInterval,CommonTurnoutOperation.intervalStepSize));\n  hbox1.add(intervalSpinner);\n  hbox2.add(new JLabel(Bundle.getMessage(\"TimesToTry\")));\n  hbox2.add(Box.createHorizontalGlue());\n  maxTriesSpinner.setMinimumSize(new Dimension(100,20));\n  maxTriesSpinner.setModel(new SpinnerNumberModel(myOp.getMaxTries(),CommonTurnoutOperation.minMaxTries,CommonTurnoutOperation.maxMaxTries,1));\n  hbox2.add(maxTriesSpinner);\n  Box hbox3=Box.createHorizontalBox();\n  hbox3.add(Box.createHorizontalStrut(150));\n  vbox.add(hbox3);\n  add(vbox);\n}\n", "docstring": "create the config jpanel , if there is one , to configure this operation type", "partition": "test"}
{"idx": "554", "code": "public String findInterlanguageLink(String lang){\n  int start=page.indexOf(\"[[\" + lang + \":\");\n  if (start < 0)   return null;\n  int end=page.indexOf(\"]]\",start);\n  if (end < 0)   return null;\n  String link=page.substring(start + 3 + lang.length(),end);\n  if (link.indexOf(\"\\n\") != -1) {\n    return null;\n  }\n  if (link.length() == 0)   return null;\n  return link;\n}\n", "docstring": "returns the inter - language link to a specific language ( if any ) .", "partition": "test"}
{"idx": "555", "code": "private void updateActions(final INaviAddressSpace addressSpace){\n  m_loadAddressSpaceAction.setEnabled(!addressSpace.isLoaded());\n}\n", "docstring": "updates the menu actions depending on the state of the given address space .", "partition": "test"}
{"idx": "556", "code": "public static <T>ParallelFlux<T> from(Publisher<? extends T> source,int parallelism){\n  return from(source,parallelism,QueueSupplier.SMALL_BUFFER_SIZE,QueueSupplier.small());\n}\n", "docstring": "take a publisher and prepare to consume it on parallallism number of \"'\" rails \"'\" , possibly ordered and round - robin fashion .", "partition": "test"}
{"idx": "557", "code": "private void addGumball(float xPos,float yPos){\n  Gumball gumball=new Gumball();\n  gumball.mXInitPos=xPos;\n  gumball.mYInitPos=yPos;\n  gumball.mSoundPoolId=UUID.randomUUID();\n  mSoundPoolId.put(gumball.mSoundPoolId,false);\n  mGameView.addGumball(gumball);\n  mSoundPool.play(mSoundBallDrop,1,1,0,0,1);\n}\n", "docstring": "add a gumball to the game and play the ball drop sound .", "partition": "test"}
{"idx": "558", "code": "int put(T segment,List<? super T> recycleBin){\n  int count;\n  if (lastCount == 0) {\n    count=0;\n    lastCount=1;\n    last=segment;\n  }\n else   if (Objects.deepEquals(last,segment)) {\n    ++lastCount;\n    count=0;\n    recycleBin.add(segment);\n  }\n else {\n    count=lastCount;\n    lastCount=1;\n    last=segment;\n  }\n  return count;\n}\n", "docstring": "adds an element to the stream . if that element is the same as the last element this buffer saw , it won \"'\" t be added to the stream , but will instead be recycled . if this element is different than the one before , this class will return the number of times that other element had been seen . the caller is responsible for having retrieved that element before calling this method .", "partition": "test"}
{"idx": "559", "code": "public Channel chan(final String topic,final JsonNode payload){\n  LOG.log(Level.FINE,\"chan: {0}, {1}\",new Object[]{topic,payload});\n  final Channel channel=new Channel(topic,payload,Socket.this);\nsynchronized (channels) {\n    channels.add(channel);\n  }\n  return channel;\n}\n", "docstring": "retrieve a channel instance for the specified topic", "partition": "test"}
{"idx": "560", "code": "public PlaPointFloat change_size(double p_new_size){\n  if (v_x == 0 && v_y == 0) {\n    return this;\n  }\n  double length=Math.sqrt(v_x * v_x + v_y * v_y);\n  double new_x=(v_x * p_new_size) / length;\n  double new_y=(v_y * p_new_size) / length;\n  return new PlaPointFloat(new_x,new_y);\n}\n", "docstring": "approximates a floatpoint on the line from zero to this point with distance p_new_length from zero .", "partition": "test"}
{"idx": "561", "code": "int insert(Row row,byte[] sourceBuffer,int sourceOffset,BlobOutputStream[] blobs){\n  int rowHead=_rowHead;\n  int blobTail=_blobTail;\n  int rowLength=row.length();\n  rowHead-=rowLength;\n  if (rowHead < blobTail) {\n    return -1;\n  }\n  byte[] buffer=_buffer;\n  System.arraycopy(sourceBuffer,sourceOffset,buffer,rowHead,rowLength);\n  buffer[rowHead]=(byte)((buffer[rowHead] & ~CODE_MASK) | INSERT);\n  blobTail=row.insertBlobs(buffer,rowHead,blobTail,blobs);\n  if (blobTail < 0) {\n    return -1;\n  }\n  setBlobTail(blobTail);\n  rowHead(rowHead);\n  validateBlock(row);\n  return rowHead;\n}\n", "docstring": "inserts a new row into the block .", "partition": "test"}
{"idx": "562", "code": "private void addDefaultUri() throws IgniteSpiException {\n  assert uriEncodedList != null;\n  URI uri;\n  try {\n    uri=U.resolveWorkDirectory(DFLT_DEPLOY_DIR,false).toURI();\n  }\n catch (  IgniteCheckedException e) {\n    throw new IgniteSpiException(\"Failed to initialize default file scanner\",e);\n  }\n  uriEncodedList.add(uri);\n}\n", "docstring": "add configuration for file scanner .", "partition": "test"}
{"idx": "563", "code": "protected void transfer(String seqRange) throws IOException {\n  try {\n    final int rangePos=seqRange.indexOf(\'-\');\n    if (rangePos == -1) {\n      transfer(Long.parseLong(seqRange));\n    }\n else {\n      final String start=seqRange.substring(0,rangePos);\n      final String end=seqRange.substring(rangePos + 1);\n      final long startIdx;\n      if (start.length() == 0) {\n        startIdx=0;\n      }\n else {\n        startIdx=Long.parseLong(start);\n      }\n      final long endIdx;\n      if (end.length() == 0) {\n        endIdx=mReader.numberSequences() - 1;\n      }\n else {\n        endIdx=Long.parseLong(end);\n      }\n      if (startIdx > endIdx) {\n        throw new NumberFormatException(\"Invalid range: \" + seqRange);\n      }\n      for (long i=startIdx; i <= endIdx; i++) {\n        transfer(i);\n      }\n    }\n  }\n catch (  final NumberFormatException e) {\n    warnInvalidSequence(seqRange);\n  }\n}\n", "docstring": "transfer an interpreted sequence or set of sequences from the reader to the writer . this implementation allows ids to be specified as a range , e . g . 123 - 456", "partition": "test"}
{"idx": "564", "code": "public static double distancePointLinePerpendicular(Coordinate p,Coordinate A,Coordinate B){\n  double len2=(B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  double s=((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2);\n}\n", "docstring": "computes the perpendicular distance from a point p to the ( infinite ) line containing the points ab", "partition": "test"}
{"idx": "565", "code": "public String patchFixIds(){\n  return properties.getProperty(\"patch.fix.ids\");\n}\n", "docstring": "returns the set of bug ids for fixes included in this build of the directory server .", "partition": "test"}
{"idx": "566", "code": "public final void readFully(byte[] b) throws java.io.IOException {\n  readFully(b,0,b.length);\n}\n", "docstring": "see the general contract of the readfully method of datainput . bytes for this operation are read from the contained input stream .", "partition": "test"}
{"idx": "567", "code": "private void createGui(){\n  final JPanel outerNamePanel=new JPanel(new BorderLayout());\n  outerNamePanel.setBorder(new TitledBorder(\"Tag\"));\n  final JPanel namePanel=new JPanel(new BorderLayout());\n  namePanel.setBorder(new EmptyBorder(0,0,5,0));\n  final JLabel nameLabel=new CHelpLabel(\"Name\" + \":\",new CNameHelp());\n  nameLabel.setPreferredSize(new Dimension(110,25));\n  namePanel.add(nameLabel,BorderLayout.WEST);\n  namePanel.add(m_nameTextField,BorderLayout.CENTER);\n  outerNamePanel.add(namePanel,BorderLayout.CENTER);\n  final JPanel outerDescriptionPanel=new JPanel(new BorderLayout());\n  outerDescriptionPanel.setBorder(new EmptyBorder(5,0,0,0));\n  final JPanel descriptionPanel=new JPanel(new BorderLayout());\n  descriptionPanel.setBorder(new TitledBorder(\"Description\"));\n  descriptionPanel.setMinimumSize(new Dimension(0,120));\n  descriptionPanel.add(new JScrollPane(m_descriptionField));\n  outerDescriptionPanel.add(descriptionPanel,BorderLayout.CENTER);\n  final JPanel buttonPanel=new JPanel(new GridLayout(1,2));\n  buttonPanel.add(new JPanel());\n  buttonPanel.setBorder(new EmptyBorder(5,0,5,2));\n  buttonPanel.add(m_saveButton);\n  final JPanel topPanel=new JPanel(new BorderLayout());\n  topPanel.add(outerNamePanel,BorderLayout.NORTH);\n  topPanel.add(outerDescriptionPanel,BorderLayout.CENTER);\n  topPanel.add(buttonPanel,BorderLayout.SOUTH);\n  final JPanel bottomPanel=new JPanel(new BorderLayout());\n  bottomPanel.setBorder(m_tableBorder);\n  final JScrollPane scrollPane=new JScrollPane(m_childrenTagTable);\n  bottomPanel.add(scrollPane,BorderLayout.CENTER);\n  final JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topPanel,bottomPanel);\n  splitPane.setOneTouchExpandable(true);\n  splitPane.setDividerLocation(splitPane.getMinimumDividerLocation());\n  splitPane.setResizeWeight(0.5);\n  add(splitPane);\n}\n", "docstring": "creates the gui of the component .", "partition": "test"}
{"idx": "568", "code": "public static boolean isJellybeanOrLater(){\n  return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN;\n}\n", "docstring": "returns whether the sdk is the jellybean release or later .", "partition": "test"}
{"idx": "569", "code": "public PartialCorrelationPdf(int n,int k){\n  this.n=n;\n  this.k=k;\n  double gammaRatio=gammaRatio(n,k);\n  this.constant=(1 / Math.pow(Math.PI,0.5)) * gammaRatio;\n  this.outsideExp=(double)(n - k - 2) / 2.0;\n}\n", "docstring": "constructs a new zero partial correlation distribution function with the given values for n and k .", "partition": "test"}
{"idx": "570", "code": "private static boolean isEnabled(){\n  if (SystemUtils.IS_OS_WINDOWS) {\n    return false;\n  }\n  try {\n    List<String> lines=CommandUtil.executeCommandAndGetLines(Collections.singletonList(\"sestatus\"));\n    for (    String line : lines) {\n      if (line.contains(\"SELinux status\")) {\n        if (line.contains(\"enabled\")) {\n          Logger.info(\"SELinux is enabled on this system\");\n          return true;\n        }\n        return false;\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n  return false;\n}\n", "docstring": "check whether selinux is enabled or not .", "partition": "test"}
{"idx": "571", "code": "public boolean validate(){\n  outputFile=new File(outputPath);\n  if (outputFile.exists() || outputFile.isDirectory()) {\n    invalidMessage=\"Output file already exists.\";\n    return valid=false;\n  }\n  if (!signMode) {\n    keyFile=new File(keyFilePath);\n    if (!keyFile.exists() || keyFile.isDirectory()) {\n      invalidMessage=\"Key file not found.\";\n      return valid=false;\n    }\n  }\n  return valid=true;\n}\n", "docstring": "initialises and checks validity of files . this objects tostring ( ) method changes to reflect failures in validation in order for the user to be informed .", "partition": "test"}
{"idx": "572", "code": "public void addResponseCodeListener(ActionListener a){\n  responseCodeListeners.addElement(a);\n}\n", "docstring": "adds a response listener on the requests", "partition": "test"}
{"idx": "573", "code": "public double calculateLogLikelihood(){\n  double logL=0.0;\n  for (  Statistic statistic : dataList) {\n    for (int j=0; j < statistic.getDimension(); j++) {\n      logL-=Math.log(statistic.getStatisticValue(j));\n    }\n  }\n  return logL;\n}\n", "docstring": "calculate the log likelihood of the current state .", "partition": "test"}
{"idx": "574", "code": "public static boolean hasDeadStatesFromInitial(Automaton a){\n  BitSet reachableFromInitial=getLiveStatesFromInitial(a);\n  BitSet reachableFromAccept=getLiveStatesToAccept(a);\n  reachableFromInitial.andNot(reachableFromAccept);\n  return reachableFromInitial.isEmpty() == false;\n}\n", "docstring": "returns true if there are dead states reachable from an initial state .", "partition": "test"}
{"idx": "575", "code": "public Decimal subtract(Decimal decimal){\n  assertDefined();\n  if (null == m_value) {\n    return (decimal);\n  }\n  BigDecimal value=m_value.subtract(decimal.getBigDecimalValue());\n  return new Decimal(value,SCALE);\n}\n", "docstring": "subtracts two decimal objects", "partition": "test"}
{"idx": "576", "code": "public final boolean equals(Object object){\n  if (object == null) {\n    return false;\n  }\n  if (!(object instanceof KnowledgeEdge)) {\n    return false;\n  }\n  KnowledgeEdge pair=(KnowledgeEdge)object;\n  return from.equals(pair.from) && to.equals(pair.to);\n}\n", "docstring": "reteurns true if ( from1 , to1 ) = = ( from2 , to2 ) .", "partition": "test"}
{"idx": "577", "code": "protected int skipLine(int c) throws IOException {\n  while (c != -1 && c != '\\r' && c != '\\n') {\n    c=reader.read();\n  }\n  if (c == '\\n') {\n    c=reader.read();\n    lineNo++;\n    reportLocation(lineNo,1);\n  }\n else   if (c == '\\r') {\n    c=reader.read();\n    if (c == '\\n') {\n      c=reader.read();\n    }\n    lineNo++;\n    reportLocation(lineNo,1);\n  }\n  return c;\n}\n", "docstring": "reads characters from reader until the first eol has been read . the first character after the eol is returned . in case the end of the character stream has been reached , - 1 is returned .", "partition": "test"}
{"idx": "578", "code": "@Override public void listVolumes(CommandInput input,CompletionHandler completionHandler){\n  createOrUpdateTargetSsl(input);\n  URI uri=UriUtils.extendUri(input.getDockerUri(),\"/volumes\");\n  sendGet(uri,null,completionHandler);\n}\n", "docstring": "https : / / docs . docker . com / engine / reference / api / docker_remote_api_v1 . 24 / section 3 . 4 volumes - list volumes", "partition": "test"}
{"idx": "579", "code": "public static ByteBuffer base64StringToByteBuffer(String base64EncodedKey){\n  return ByteBuffer.wrap(base64DecodeString(base64EncodedKey));\n}\n", "docstring": "converts a base64 encoded key into a bytebuffer", "partition": "test"}
{"idx": "580", "code": "public boolean step(){\n  long current=System.currentTimeMillis();\n  if (mStart == 0 || (current - mStart < 0)) {\n    mProgress=0;\n  }\n else   if (current - mStart > mDuration) {\n    if (mLoop) {\n      mProgress=0;\n      start();\n      return true;\n    }\n    mProgress=1;\n    return false;\n  }\n else {\n    mProgress=(current - mStart) / (double)mDuration;\n  }\n  return true;\n}\n", "docstring": "step in the animation . will compute the current progress as well .", "partition": "test"}
{"idx": "581", "code": "protected void load_raw_characters(StringBuilder sb) throws IOException {\n  int c=read_char();\n  for (; ; ) {\n    c=read_char();\nswitch (c) {\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:\n      continue;\ncase -1:\n    return;\ndefault :\n  if (!IonTokenConstsX.is7bitValue(c)) {\n    c=read_large_char_sequence(c);\n  }\n}\nif (IonUTF8.needsSurrogateEncoding(c)) {\nsb.append(IonUTF8.highSurrogate(c));\nc=IonUTF8.lowSurrogate(c);\n}\nsb.append((char)c);\n}\n}\n", "docstring": "this is used to load a previously marked set of bytes into the stringbuilder without escaping . it expects the caller to have set a save point so that the eof will stop us at the right time . this does handle utf8 decoding and surrogate encoding as the bytes are transfered .", "partition": "test"}
{"idx": "582", "code": "public SignatureFakingOracle(final String documentString) throws SignatureFakingException {\n  Security.addProvider(new BouncyCastleProvider());\n  signatureValueElements=new LinkedList<Node>();\n  keyInfoElements=new LinkedList<Node>();\n  certificates=new LinkedList<String>();\n  certHandlers=new LinkedList<CertificateHandler>();\n  try {\n    doc=DomUtilities.stringToDom(documentString);\n    crawlSignatureElements();\n    log.debug(\"found \" + signatureValueElements.size() + \" SignatureValue elements\");\n    crawlKeyInfoElements();\n    log.debug(\"found \" + keyInfoElements.size() + \" KeyInfo elements containing X509 certificates\");\n  }\n catch (  SAXException e) {\n    throw new SignatureFakingException(e);\n  }\n}\n", "docstring": "creates signaturewrappingoracle , parses the document and searches for all the signaturevalue and keyinfo elements", "partition": "test"}
{"idx": "583", "code": "public ArbitraryLengthPathNode(final TermNode left,final TermNode right,final VarNode tVarLeft,final VarNode tVarRight,final long lowerBound,final long upperBound){\n  this(new BOp[]{new JoinGroupNode()},NV.asMap(new NV(Annotations.LEFT_TERM,left),new NV(Annotations.RIGHT_TERM,right),new NV(Annotations.TRANSITIVITY_VAR_LEFT,tVarLeft),new NV(Annotations.TRANSITIVITY_VAR_RIGHT,tVarRight),new NV(Annotations.DROP_VARS,new ArrayList<VarNode>()),new NV(Annotations.LOWER_BOUND,lowerBound),new NV(Annotations.UPPER_BOUND,upperBound)));\n  final Set<VarNode> dropVars=new LinkedHashSet<>();\n  dropVars.add(tVarLeft);\n  dropVars.add(tVarRight);\n  setProperty(Annotations.DROP_VARS,dropVars);\n}\n", "docstring": "fully construct an arbitrary length path node with all required annotations .", "partition": "test"}
{"idx": "584", "code": "private Integer scanYamlDirectiveNumber(Mark startMark){\n  char ch=reader.peek();\n  if (!Character.isDigit(ch)) {\n    throw new ScannerException(\"while scanning a directive\",startMark,\"expected a digit, but found \" + ch + \"(\"+ ((int)ch)+ \")\",reader.getMark());\n  }\n  int length=0;\n  while (Character.isDigit(reader.peek(length))) {\n    length++;\n  }\n  Integer value=Integer.parseInt(reader.prefixForward(length));\n  return value;\n}\n", "docstring": "read a % yaml directive number : this is either the major or the minor part . stop reading at a non - digit character ( usually either \"'\" . \"'\" or \"'\" \\ n \"'\" ) .", "partition": "test"}
{"idx": "585", "code": "public static final String toBitString(int i[]){\n  StringBuilder sb=new StringBuilder(i.length);\n  for (  int b : i) {\n    sb.append(b);\n  }\n  return sb.toString();\n}\n", "docstring": "tobitstring - returns a string representation of i [ ", "partition": "test"}
{"idx": "586", "code": "public static ByteBuffer convertToSigned16BitSamples(Buffer buffer){\n  return convertToSigned16BitSamples(buffer.getSamples());\n}\n", "docstring": "converts the float samples in a complex buffer to a little endian 16 - bit buffer", "partition": "test"}
{"idx": "587", "code": "boolean checkToken(ByteWrapper token,Key nodeId,InetAddress ip,int port,Key lookupKey){\n  updateTokenTimestamps();\n  boolean valid=checkToken(token,nodeId,ip,port,lookupKey,timestampCurrent.get()) || checkToken(token,nodeId,ip,port,lookupKey,timestampPrevious);\n  if (!valid)   DHT.logDebug(\"Received Invalid token from \" + ip.getHostAddress());\n  return valid;\n}\n", "docstring": "check if a received token is ok .", "partition": "test"}
{"idx": "588", "code": "public void expandAll(){\n  cancelEditing();\n  final TreeModel tm=getModel();\n  final Object root=tm.getRoot();\n  if (root != null) {\n    expandAllPaths(new TreePath(root),tm);\n  }\n}\n", "docstring": "expands all paths in the tree .", "partition": "test"}
{"idx": "589", "code": "protected void describeVocabularies(final IVCount[] predicatePartitionCounts){\n  final Set<String> namespaces=new LinkedHashSet<String>();\n{\n    for (    IVCount tmp : predicatePartitionCounts) {\n      final URI p=(URI)tmp.getValue();\n      String namespace=p.getNamespace();\n      if (namespace.endsWith(\"#\")) {\n        namespace=namespace.substring(0,namespace.length() - 1);\n      }\n      namespaces.add(namespace);\n    }\n  }\n  final String[] a=namespaces.toArray(new String[namespaces.size()]);\n  Arrays.sort(a);\n  for (  String namespace : a) {\n    g.add(aDataset,VoidVocabularyDecl.vocabulary,f.createURI(namespace));\n  }\n}\n", "docstring": "describe the vocabularies which are in use in the kb based on the predicate partition statistics .", "partition": "test"}
{"idx": "590", "code": "public void testInvokeAny4() throws Throwable {\n  CountDownLatch latch=new CountDownLatch(1);\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    List<Callable<String>> l=new ArrayList<Callable<String>>();\n    l.add(latchAwaitingStringTask(latch));\n    l.add(null);\n    try {\n      e.invokeAny(l);\n      shouldThrow();\n    }\n catch (    NullPointerException success) {\n    }\n    latch.countDown();\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "invokeany ( c ) throws nullpointerexception if c has null elements", "partition": "test"}
{"idx": "591", "code": "private static void solve_l2r_l1l2_svr(Problem prob,double[] w,Parameter param){\n  int l=prob.l;\n  double C=param.C;\n  double p=param.p;\n  int w_size=prob.n;\n  double eps=param.eps;\n  int i, s, iter=0;\n  int max_iter=1000;\n  int active_size=l;\n  int[] index=new int[l];\n  double d, G, H;\n  double Gmax_old=Double.POSITIVE_INFINITY;\n  double Gmax_new, Gnorm1_new;\n  double Gnorm1_init=0;\n  double[] beta=new double[l];\n  double[] QD=new double[l];\n  double[] y=prob.y;\n  double[] lambda=new double[]{0.5 / C};\n  double[] upper_bound=new double[]{Double.POSITIVE_INFINITY};\n  if (param.solverType == SolverType.L2R_L1LOSS_SVR_DUAL) {\n    lambda[0]=0;\n    upper_bound[0]=C;\n  }\n  for (i=0; i < l; i++) {\n    beta[i]=0;\n  }\n  for (i=0; i < w_size; i++) {\n    w[i]=0;\n  }\n  for (i=0; i < l; i++) {\n    QD[i]=0;\n    for (    Feature xi : prob.x[i]) {\n      double val=xi.getValue();\n      QD[i]+=val * val;\n      w[xi.getIndex() - 1]+=beta[i] * val;\n    }\n    index[i]=i;\n  }\n  while (iter < max_iter) {\n    Gmax_new=0;\n    Gnorm1_new=0;\n    for (i=0; i < active_size; i++) {\n      int j=i + random.nextInt(active_size - i);\n      swap(index,i,j);\n    }\n    for (s=0; s < active_size; s++) {\n      i=index[s];\n      G=-y[i] + lambda[GETI_SVR(i)] * beta[i];\n      H=QD[i] + lambda[GETI_SVR(i)];\n      for (      Feature xi : prob.x[i]) {\n        int ind=xi.getIndex() - 1;\n        double val=xi.getValue();\n        G+=val * w[ind];\n      }\n      double Gp=G + p;\n      double Gn=G - p;\n      double violation=0;\n      if (beta[i] == 0) {\n        if (Gp < 0) {\n          violation=-Gp;\n        }\n else         if (Gn > 0) {\n          violation=Gn;\n        }\n else         if (Gp > Gmax_old && Gn < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] >= upper_bound[GETI_SVR(i)]) {\n        if (Gp > 0) {\n          violation=Gp;\n        }\n else         if (Gp < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] <= -upper_bound[GETI_SVR(i)]) {\n        if (Gn < 0) {\n          violation=-Gn;\n        }\n else         if (Gn > Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] > 0) {\n        violation=Math.abs(Gp);\n      }\n else {\n        violation=Math.abs(Gn);\n      }\n      Gmax_new=Math.max(Gmax_new,violation);\n      Gnorm1_new+=violation;\n      if (Gp < H * beta[i]) {\n        d=-Gp / H;\n      }\n else       if (Gn > H * beta[i]) {\n        d=-Gn / H;\n      }\n else {\n        d=-beta[i];\n      }\n      if (Math.abs(d) < 1.0e-12) {\n        continue;\n      }\n      double beta_old=beta[i];\n      beta[i]=Math.min(Math.max(beta[i] + d,-upper_bound[GETI_SVR(i)]),upper_bound[GETI_SVR(i)]);\n      d=beta[i] - beta_old;\n      if (d != 0) {\n        for (        Feature xi : prob.x[i]) {\n          w[xi.getIndex() - 1]+=d * xi.getValue();\n        }\n      }\n    }\n    if (iter == 0) {\n      Gnorm1_init=Gnorm1_new;\n    }\n    iter++;\n    if (iter % 10 == 0) {\n      info(\".\");\n    }\n    if (Gnorm1_new <= eps * Gnorm1_init) {\n      if (active_size == l) {\n        break;\n      }\n else {\n        active_size=l;\n        info(\"*\");\n        Gmax_old=Double.POSITIVE_INFINITY;\n        continue;\n      }\n    }\n    Gmax_old=Gmax_new;\n  }\n  info(\"%noptimization finished, #iter = %d%n\",iter);\n  if (iter >= max_iter) {\n    info(\"%nWARNING: reaching max number of iterations%nUsing -s 11 may be faster%n%n\");\n  }\n  double v=0;\n  int nSV=0;\n  for (i=0; i < w_size; i++) {\n    v+=w[i] * w[i];\n  }\n  v=0.5 * v;\n  for (i=0; i < l; i++) {\n    v+=p * Math.abs(beta[i]) - y[i] * beta[i] + 0.5 * lambda[GETI_SVR(i)] * beta[i]* beta[i];\n    if (beta[i] != 0) {\n      nSV++;\n    }\n  }\n  info(\"Objective value = %g%n\",v);\n  info(\"nSV = %d%n\",nSV);\n}\n", "docstring": "a coordinate descent algorithm for l1 - loss and l2 - loss epsilon - svr dual problem min_ \\ beta 0 . 5 \\ beta ^ t ( q + diag ( lambda ) ) \\ beta - p \\ sum_ { i = 1 } ^ l | \\ beta_i | + \\ sum_ { i = 1 } ^ l yi \\ beta_i , s . t . - upper_bound_i < = \\ beta_i < = upper_bound_i , where qij = xi ^ t xj and d is a diagonal matrix in l1 - svm case : upper_bound_i = c lambda_i = 0 in l2 - svm case : upper_bound_i = inf lambda_i = 1 / ( 2 * c ) given : x , y , p , c eps is the stopping tolerance solution will be put in w see algorithm 4 of ho and lin , 2012", "partition": "test"}
{"idx": "592", "code": "public SignalGroupSubTableAction(String s){\n}\n", "docstring": "create an action with a specific title . < p > note that the argument is the action title , not the title of the resulting frame . perhaps this should be changed ?", "partition": "test"}
{"idx": "593", "code": "private HashMap addAttr(SvcReg reg,EntryClass eclass,int fldidx,Object value){\n  HashMap[] attrMaps=serviceByAttr.get(eclass);\n  if (attrMaps == null) {\n    attrMaps=new HashMap[eclass.getNumFields()];\n    serviceByAttr.put(eclass,attrMaps);\n  }\n  HashMap map=attrMaps[fldidx];\n  if (map == null) {\n    map=new HashMap(11);\n    attrMaps[fldidx]=map;\n  }\n  ArrayList regs=(ArrayList)map.get(value);\n  if (regs == null) {\n    regs=new ArrayList(3);\n    map.put(value,regs);\n  }\n else   if (regs.contains(reg))   return map;\n  regs.add(reg);\n  return map;\n}\n", "docstring": "put the service under the given attribute value for the given defining class and field , if it isn \"'\" t already there . return the hashmap for the given class and field .", "partition": "test"}
{"idx": "594", "code": "public QueryStringDecoderUtil(URI uri){\n  this(uri,Charset.defaultCharset());\n}\n", "docstring": "creates a new decoder that decodes the specified uri . the decoder will assume that the query string is encoded in utf - 8 .", "partition": "test"}
{"idx": "595", "code": "public static void showErrorMessage(String msg){\n  showErrorMessage(msg,3500);\n}\n", "docstring": "simplifies a common use case of showing an error message with an error icon that fades out after a few seconds", "partition": "test"}
{"idx": "596", "code": "@Override protected void onDestroy(){\n  super.onDestroy();\n  doReallyStop(false);\n  mFragments.dispatchDestroy();\n  if (mLoaderManager != null) {\n    mLoaderManager.doDestroy();\n  }\n}\n", "docstring": "destroy all fragments and loaders .", "partition": "test"}
{"idx": "597", "code": "static WindowsFileAttributes fromFindData(long address){\n  int fileAttrs=unsafe.getInt(address + OFFSETOF_FIND_DATA_ATTRIBUTES);\n  long creationTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_CREATETIME);\n  long lastAccessTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTACCESSTIME);\n  long lastWriteTime=unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTWRITETIME);\n  long size=((long)(unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZEHIGH)) << 32) + (unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZELOW) & 0xFFFFFFFFL);\n  int reparseTag=isReparsePoint(fileAttrs) ? unsafe.getInt(address + OFFSETOF_FIND_DATA_RESERVED0) : 0;\n  return new WindowsFileAttributes(fileAttrs,creationTime,lastAccessTime,lastWriteTime,size,reparseTag,0,0,0);\n}\n", "docstring": "create a windowsfileattributes from a win32_find_data structure", "partition": "test"}
{"idx": "598", "code": "public static final void writeMapXml(Map val,XmlSerializer out,WriteMapCallback callback) throws XmlPullParserException, IOException {\n  if (val == null) {\n    return;\n  }\n  Set s=val.entrySet();\n  Iterator i=s.iterator();\n  while (i.hasNext()) {\n    Map.Entry e=(Map.Entry)i.next();\n    writeValueXml(e.getValue(),(String)e.getKey(),out,callback);\n  }\n}\n", "docstring": "flatten a map into an xmlserializer . the map can later be read back with readthismapxml ( ) . this method presumes that the start tag and name attribute have already been written and does not write an end tag .", "partition": "test"}
{"idx": "599", "code": "public void fireEventProgrammatically(Event event){\n  if (!event.isConsumed())   ripplerPane.fireEvent(event);\n}\n", "docstring": "fire event to the rippler pane manually", "partition": "test"}
{"idx": "600", "code": "private boolean hasFullEntry(JsonValue entry,QuerySide querySide){\n  if (querySide == QuerySide.SOURCE && sourceQueryFullEntry != null) {\n    return sourceQueryFullEntry;\n  }\n else   if (querySide == QuerySide.TARGET && targetQueryFullEntry != null) {\n    return targetQueryFullEntry;\n  }\n  if (entry != null) {\n    short ignoreFields=0;\n    if (entry.isDefined(\"_id\")) {\n      ignoreFields++;\n    }\n    if (entry.isDefined(\"_rev\")) {\n      ignoreFields++;\n    }\n    ignoreFields+=2;\n    return entry.size() > ignoreFields;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "whether the query ( source or target side query of a reconciliation ) returns full entry data , or just ids if explicitly configured , returns that setting . if not , tries to auto - detect if a given entry contains just id info , or contains full data the detection has limitations , such as requiring at least three data fields aside from fields it expects in id queries . this may not be case for all custom connectors , in which case explicit config is required instead of using auto detect .", "partition": "test"}
{"idx": "601", "code": "public static boolean isModule(IResource resource){\n  return (resource != null && TLA_EXTENSION.equals(resource.getFileExtension()));\n}\n", "docstring": "determines if the given member is a tla + module", "partition": "test"}
{"idx": "602", "code": "public int writeAnnotation(Annotation annotation){\n  int off=data.position();\n  writeByte(annotation.visibility);\n  writeEncodedArray(annotation.encodedAnnotation);\n  return off;\n}\n", "docstring": "write annotation item into current section .", "partition": "test"}
{"idx": "603", "code": "public static long fromInet4Address(final InetAddress inetAddress){\n  ensureIsInet4Address(inetAddress);\n  return Integer.toUnsignedLong(inetAddress.hashCode());\n}\n", "docstring": "pack ipv4 address and match - all socket flag into a long .", "partition": "test"}
{"idx": "604", "code": "public boolean revisionContainsTemplateName(int revId,String templateName) throws WikiApiException {\n  return revisionContainsTemplateNames(revId,Arrays.asList(new String[]{templateName}));\n}\n", "docstring": "determines whether a given revision contains a given template name", "partition": "test"}
{"idx": "605", "code": "public List<GenericEntry> retrieveAllAccountInfoRequests(Date fromDate) throws AppsForYourDomainException, IOException, ServiceException {\n  String url=BASE_URL + \"account/\" + domain;\n  if (fromDate != null) {\n    url+=\"?fromDate=\" + DATE_FORMAT.format(fromDate);\n  }\n  return getAllPages(new URL(url),GenericFeed.class);\n}\n", "docstring": "retrieve all the account info requests from the given start date .", "partition": "test"}
{"idx": "606", "code": "protected void drawCylinder(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean isShadow){\n  int h4=h / 4;\n  int r=w - 1;\n  if (fillColor != null || fillPaint != null) {\n    Area area=new Area(new Rectangle(x,y + h4 / 2,r,h - h4));\n    area.add(new Area(new Rectangle(x,y + h4 / 2,r,h - h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y,r,h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y + h - h4,r,h4)));\n    if (isShadow) {\n      g.setColor(mxConstants.SHADOW_COLOR);\n      g.translate(mxConstants.SHADOW_OFFSETX,mxConstants.SHADOW_OFFSETY);\n      g.fill(area);\n      g.translate(-mxConstants.SHADOW_OFFSETX,-mxConstants.SHADOW_OFFSETY);\n    }\n    if (fillPaint != null) {\n      g.setPaint(fillPaint);\n    }\n else {\n      g.setColor(fillColor);\n    }\n    g.fill(area);\n  }\n  if (penColor != null) {\n    g.setColor(penColor);\n    int h2=h4 / 2;\n    g.drawOval(x,y,r,h4);\n    g.drawLine(x,y + h2,x,y + h - h2);\n    g.drawLine(x + w - 1,y + h2,x + w - 1,y + h - h2);\n    g.drawArc(x,y + h - h4,r,h4,0,-180);\n  }\n}\n", "docstring": "draws a cylinder for the given parameters .", "partition": "test"}
{"idx": "607", "code": "public StringList plus(String... args){\n  StringList newList=new StringList();\n  newList.addAll(this);\n  newList.addAll(Arrays.asList(args));\n  return newList;\n}\n", "docstring": "add a list of strings .", "partition": "test"}
{"idx": "608", "code": "private void walkParseTree(List<SwiftBaseListener> listeners,TopLevelContext tree){\n  ParseTreeWalker walker=new ParseTreeWalker();\n  listeners.forEach(null);\n}\n", "docstring": "walks the provided parse tree using the list of listeners .", "partition": "test"}
{"idx": "609", "code": "protected List<DecompoundedWord> makeSplit(String aWord){\n  List<DecompoundedWord> result=new ArrayList<DecompoundedWord>();\n  for (int i=0; i < aWord.length(); i++) {\n    String leftWord=aWord.substring(0,i + 1);\n    String rightWord=aWord.substring(i + 1);\n    boolean leftGood=dict.contains(leftWord) && leftWord.length() >= minWordLength;\n    boolean rightGood=rightWord.length() > minRestLength || rightWord.length() == 0;\n    if (leftGood && rightGood) {\n      DecompoundedWord split=DecompoundedWord.createFromString(leftWord + \"+\" + rightWord);\n      split.setSplitPos(i);\n      result.add(split);\n    }\n    for (    String morpheme : morphemes.getAll()) {\n      try {\n        String leftWithoutMorpheme=leftWord.substring(0,leftWord.length() - morpheme.length());\n        if (leftWord.endsWith(morpheme) && dict.contains(leftWithoutMorpheme) && rightGood) {\n          DecompoundedWord split=DecompoundedWord.createFromString(leftWithoutMorpheme + \"(\" + morpheme+ \")+\"+ rightWord);\n          split.setSplitPos(i);\n          result.add(split);\n        }\n      }\n catch (      StringIndexOutOfBoundsException e) {\n        continue;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "splits a word in two word .", "partition": "test"}
{"idx": "610", "code": "public static String classNamePath(String className){\n  String filename=className.replace(\".\",File.separator);\n  filename=filename.replaceFirst(\"[$][0-9]+\",\"\");\n  if (filename.indexOf(\"$\") > 0) {\n    filename=filename.substring(0,filename.indexOf(\"$\"));\n  }\n  return \"src\" + File.separator + filename+ \".java\";\n}\n", "docstring": "returns the relative path for a fully qualified classname . adds \" src / \" before the pathname for the class . strips away internal class names .", "partition": "test"}
{"idx": "611", "code": "public void removeTitlePrefix(String prfx){\n  titlePrefix.remove(prfx);\n  firePropertyChange(TITLE_PREFIX,null,titlePrefix);\n}\n", "docstring": "removes the title prefix .", "partition": "test"}
{"idx": "612", "code": "public void send(Set recipients,boolean multicast) throws InterruptedException, ReplyException {\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (Thread.interrupted())   throw new InterruptedException();\n  recipients=new HashSet(recipients);\n  DistributedMember me=originDm.getDistributionManagerId();\n  if (recipients.contains(me)) {\n    recipients.remove(me);\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"Recipients for SerialAckedMessage are {}\",recipients);\n  }\n  rp=new ReplyProcessor21(originDm,recipients);\n  processorId=rp.getProcessorId();\n  setRecipients(recipients);\n  setMulticast(multicast);\n  Set failures=originDm.putOutgoing(this);\n  if (failures != null && failures.size() > 0) {\n    for (Iterator i=failures.iterator(); i.hasNext(); ) {\n      InternalDistributedMember mbr=(InternalDistributedMember)i.next();\n      if (isDebugEnabled) {\n        logger.debug(\"Unable to send serial acked message to {}\",mbr);\n      }\n    }\n  }\n  rp.waitForReplies();\n}\n", "docstring": "send the message and wait for replies", "partition": "test"}
{"idx": "613", "code": "private boolean isRelevant(Object service,Entry[] attributes){\n  LOOP:   for (  Entry e : _serviceAttributes) {\n    for (    Entry en : attributes) {\n      if (e.equals(en))       continue LOOP;\n    }\n    return false;\n  }\n  boolean flag=false;\n  for (  Entry en : attributes) {\n    if (_serviceName.equals(en)) {\n      flag=true;\n      break;\n    }\n  }\n  if (!flag)   return false;\n  flag=false;\n  for (  Class cl : _classes) {\n    if (cl.isInstance(service)) {\n      flag=true;\n      break;\n    }\n  }\n  return flag;\n}\n", "docstring": "is relevant service . used as filter for the incoming events .", "partition": "test"}
{"idx": "614", "code": "public int findCarByRoadNumber(String roadNumber){\n  if (sysList != null) {\n    if (!roadNumber.equals(_roadNumber)) {\n      return getIndex(0,roadNumber);\n    }\n    int index=getIndex(_index,roadNumber);\n    if (index > 0) {\n      return index;\n    }\n    return getIndex(0,roadNumber);\n  }\n  return -1;\n}\n", "docstring": "search for car by road number", "partition": "test"}
{"idx": "615", "code": "@SlashedClassName @SuppressFBWarnings(\"TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK\") public static String toSlashedClassName(@SlashedClassName(when=When.UNKNOWN) String className){\n  if (className.indexOf(\'.\') >= 0) {\n    return DescriptorFactory.canonicalizeString(className.replace(\'.\',\'/\'));\n  }\n  return className;\n}\n", "docstring": "convert class name to slashed format . if the class name is already in slashed format , it is returned unmodified .", "partition": "test"}
{"idx": "616", "code": "public static double P_AveragePrecision(int y[],int r[]){\n  double avg_prec=0;\n  int L=y.length;\n  List<Integer> ones=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      ones.add(j);\n    }\n  }\n  if (ones.size() <= 0)   return 1.0;\n  for (  int j : ones) {\n    double s=0.0;\n    for (    int k : ones) {\n      if (r[k] <= r[j]) {\n        s++;\n      }\n    }\n    avg_prec+=(s / (1. + r[j]));\n  }\n  avg_prec/=ones.size();\n  return avg_prec;\n}\n", "docstring": "average precision - computes for each relevant label the percentage of relevant labels among all labels that are ranked before it .", "partition": "test"}
{"idx": "617", "code": "public Location newLocation(String name){\n  Location location=getLocationByName(name);\n  if (location == null) {\n    _id++;\n    location=new Location(Integer.toString(_id),name);\n    Integer oldSize=Integer.valueOf(_locationHashTable.size());\n    _locationHashTable.put(location.getId(),location);\n    setDirtyAndFirePropertyChange(LISTLENGTH_CHANGED_PROPERTY,oldSize,Integer.valueOf(_locationHashTable.size()));\n  }\n  return location;\n}\n", "docstring": "finds an existing location or creates a new location if needed requires location \"'\" s name creates a unique id for this location", "partition": "test"}
{"idx": "618", "code": "@Override public void close(){\n  closing=true;\n  if (reservations == null || reservations.compareAndSet(0,-1))   doClose();\n}\n", "docstring": "closes tree map and reclaims memory .", "partition": "test"}
{"idx": "619", "code": "public static boolean isAndroidSdkDirInLocalPropertiesFile(@NotNull File projectDir){\n  String androidHome=getAndroidHomeFromLocalPropertiesFile(projectDir);\n  if (!Strings.isNullOrEmpty(androidHome)) {\n    String msg=String.format(\"Found Android SDK home at \'%1$s\' (from local.properties file)\",androidHome);\n    LOG.info(msg);\n    return true;\n  }\n  return false;\n}\n", "docstring": "indicates whether the path of the android sdk home directory is specified in a local . properties file .", "partition": "test"}
{"idx": "620", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (eventName.equals(\"trainingSet\") && m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection with respect to the named event", "partition": "test"}
{"idx": "621", "code": "public static Vector2 pow(Vector2 o,double power){\n  return new Vector2(Math.pow(o.x,power),Math.pow(o.z,power));\n}\n", "docstring": "raises the x and y values of a vector2 to the given power .", "partition": "test"}
{"idx": "622", "code": "public static Object invokeStatic(String clazz,String methodName,Class[] types,Object[] values) throws NoSuchMethodException {\n  try {\n    return invokeStatic(Class.forName(clazz),methodName,types,values);\n  }\n catch (  ClassNotFoundException e) {\n    throw new NoSuchMethodException(\"class \" + clazz + \" not found\");\n  }\n}\n", "docstring": "invokes the specified parameterless method if it exists .", "partition": "test"}
{"idx": "623", "code": "public Prototype undump(InputStream stream,String chunkname) throws IOException {\n  if (stream.read() != LUA_SIGNATURE[0] || stream.read() != LUA_SIGNATURE[1] || stream.read() != LUA_SIGNATURE[2] || stream.read() != LUA_SIGNATURE[3])   return null;\n  String sname=getSourceName(chunkname);\n  LoadState s=new LoadState(stream,sname);\n  s.loadHeader();\nswitch (s.luacNumberFormat) {\ncase NUMBER_FORMAT_FLOATS_OR_DOUBLES:\ncase NUMBER_FORMAT_INTS_ONLY:\ncase NUMBER_FORMAT_NUM_PATCH_INT32:\n    break;\ndefault :\n  throw new LuaError(\"unsupported int size\");\n}\nreturn s.loadFunction(LuaString.valueOf(sname));\n}\n", "docstring": "load input stream as a lua binary chunk if the first 4 bytes are the lua binary signature .", "partition": "test"}
{"idx": "624", "code": "public void addButton(URL url,String info,ActionListener al){\n  JButton b=new JButton(new ImageIcon(url,info));\n  b.setToolTipText(info);\n  b.setMargin(new Insets(0,0,0,0));\n  b.addActionListener(al);\n  b.setBorderPainted(false);\n  add(b);\n}\n", "docstring": "add a button to the panel .", "partition": "test"}
{"idx": "625", "code": "private void mapRequestToResponses(Matcher<Request> requestMatcher,ResponseSource responses){\n  mappings.add(new MatcherResponseSourcePair(requestMatcher,responses));\n}\n", "docstring": "set up a reaction to requests matching certain criteria . the supplied responsesource will be invoked for each request that matches the supplied matcher .", "partition": "test"}
{"idx": "626", "code": "@Override protected void commitToInput(){\n  JmxBeanSensorAssignment assignment=getInput();\n  if (null != assignment) {\n    assignment.setDomain(domainText.getText());\n    assignment.setObjectNameParameters(new HashMap<>(parametersMap));\n    if (allAttributesButton.getSelection()) {\n      assignment.setAttributes(Collections.<String>emptySet());\n    }\n else {\n      assignment.setAttributes(new HashSet<>(attributesSet));\n    }\n  }\n}\n", "docstring": "commits changes in page to input .", "partition": "test"}
{"idx": "627", "code": "public static String[] split(String original,String separator){\n  Vector nodes=new Vector();\n  int index=original.indexOf(separator);\n  while (index >= 0) {\n    nodes.addElement(original.substring(0,index));\n    original=original.substring(index + separator.length());\n    index=original.indexOf(separator);\n  }\n  nodes.addElement(original);\n  String[] ret=new String[nodes.size()];\n  for (int i=0; i < nodes.size(); i++) {\n    ret[i]=(String)nodes.elementAt(i);\n  }\n  return ret;\n}\n", "docstring": "provides a utility method breaks a given string to array of string according to the given separator", "partition": "test"}
{"idx": "628", "code": "public void insertTwin(Instruction inst,Instruction twin){\n  ListIterator<GCIRMapElement> iter=list.listIterator();\n  while (iter.hasNext()) {\n    GCIRMapElement newPtr=iter.next();\n    if (newPtr.getInstruction() == inst) {\n      iter.add(newPtr.createTwin(twin));\n      return;\n    }\n  }\n  throw new OptimizingCompilerException(\"GCIRMap.createTwin: \" + inst + \" not found\");\n}\n", "docstring": "this method inserts an entry for a \" twin \" instruction immediately after the original entry . if the instruction is not found in the gc map an exception is thrown .", "partition": "test"}
{"idx": "629", "code": "public java.lang.Object newInstance() throws java.lang.InstantiationException, java.lang.IllegalAccessException {\n  Object o=newInstanceImpl();\n  if (o == null) {\n    throw new InstantiationException();\n  }\n  return o;\n}\n", "docstring": "creates a new instance of a class .", "partition": "test"}
{"idx": "630", "code": "public static void toString(Iterator<?> iter,String separator,StringBuilder sb){\n  while (iter.hasNext()) {\n    sb.append(iter.next());\n    if (iter.hasNext()) {\n      sb.append(separator);\n    }\n  }\n}\n", "docstring": "converts an iterator to a string by concatenating all of the string representations of objects in the iterator , divided by a separator .", "partition": "test"}
{"idx": "631", "code": "public boolean isFull(){\n  if (maxSize > 0 && notifications.size() >= maxSize) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "check whether this matcher has reached \" max - size \" or not .", "partition": "test"}
{"idx": "632", "code": "private void schedulePlaylistSave(){\n  if (!mPlaylistLoading) {\n    if (mPlaylistSavePending.compareAndSet(false,true)) {\n      mThreadPoolManager.scheduleOnce(new PlaylistSaveTask(),2,TimeUnit.SECONDS);\n    }\n  }\n}\n", "docstring": "schedules a playlist save task . subsequent calls to this method will be ignored until the save event occurs , thus limiting repetitive playlist saving to a minimum .", "partition": "test"}
{"idx": "633", "code": "public boolean isToRead(){\n  Iterator<VariableValue> i=variables.iterator();\n  while (i.hasNext()) {\n    VariableValue v=i.next();\n    if (v.isToRead()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "this variable needs to be read if any of it \"'\" s subsidiary variables needs to be read .", "partition": "test"}
{"idx": "634", "code": "public void actionPerformed(ActionEvent e){\n  navigateToPriorDemo();\n}\n", "docstring": "invoked when an action occurs .", "partition": "test"}
{"idx": "635", "code": "public String toString(){\n  StringBuffer text=new StringBuffer();\n  for (int i=0; i < m_Elements.length; i++) {\n    if (i > 0)     text.append(\",\");\n    text.append(Utils.doubleToString(m_Elements[i],6));\n  }\n  text.append(\"\\n\");\n  return text.toString();\n}\n", "docstring": "converts a vector to a string", "partition": "test"}
{"idx": "636", "code": "@Deprecated public static Integer Integer(int i){\n  return Integer.valueOf(i);\n}\n", "docstring": "return a integer object with same value", "partition": "test"}
{"idx": "637", "code": "public void saveIndexes(){\n  ArrayList toSave=new ArrayList();\nsynchronized (this) {\n    Object[] valueTable=this.indexes.valueTable;\n    for (int i=0, l=valueTable.length; i < l; i++) {\n      Index index=(Index)valueTable[i];\n      if (index != null)       toSave.add(index);\n    }\n  }\n  boolean allSaved=true;\n  for (int i=0, length=toSave.size(); i < length; i++) {\n    Index index=(Index)toSave.get(i);\n    ReadWriteMonitor monitor=index.monitor;\n    if (monitor == null)     continue;\n    try {\n      monitor.enterRead();\n      if (index.hasChanged()) {\n        if (monitor.exitReadEnterWrite()) {\n          try {\n            saveIndex(index);\n          }\n catch (          IOException e) {\n            if (VERBOSE) {\n              Util.verbose(\"-> got the following exception while saving:\",System.err);\n              e.printStackTrace();\n            }\n            allSaved=false;\n          }\n finally {\n            monitor.exitWriteEnterRead();\n          }\n        }\n else {\n          allSaved=false;\n        }\n      }\n    }\n  finally {\n      monitor.exitRead();\n    }\n  }\n  if (this.participantsContainers != null && this.participantUpdated) {\n    writeParticipantsIndexNamesFile();\n    this.participantUpdated=false;\n  }\n  this.needToSave=!allSaved;\n}\n", "docstring": "commit all index memory changes to disk", "partition": "test"}
{"idx": "638", "code": "public void putAll(Map<? extends K,? extends V> m){\n  tryPresize(m.size());\n  for (  Map.Entry<? extends K,? extends V> e : m.entrySet())   putVal(e.getKey(),e.getValue(),false);\n}\n", "docstring": "copies all of the mappings from the specified map to this one . these mappings replace any mappings that this map had for any of the keys currently in the specified map .", "partition": "test"}
{"idx": "639", "code": "public UndoableEdit insertString(int where,String str) throws BadLocationException {\n  if (where >= count || where < 0) {\n    throw new BadLocationException(\"Invalid location\",count);\n  }\n  char[] chars=str.toCharArray();\n  replace(where,0,chars,0,chars.length);\n  if (marks != null) {\n    updateMarksForInsert(where,str.length());\n  }\n  return new InsertUndo(where,str.length());\n}\n", "docstring": "inserts a string into the content .", "partition": "test"}
{"idx": "640", "code": "boolean writeData() throws IOException {\n  int tosend;\n  int sent;\n  byte[] block=new byte[kBlockSize];\n  do {\n    tosend=Math.min(sendStreamSize - totalSent,block.length);\n    System.arraycopy(sendData,totalSent,block,0,tosend);\n    if (tosend > 0) {\n      sent=localSend(block,tosend);\n      updateLocalClock();\n      if (sent != -1) {\n        totalSent+=sent;\n      }\n else {\n        logger.log(Level.FINE,\"Flow Controlled\");\n      }\n    }\n else {\n      sent=tosend=0;\n    }\n  }\n while (sent > 0);\n  if (logger.isLoggable(Level.FINER)) {\n    logger.log(Level.FINER,\"Sent: \" + totalSent + \" remaining: \"+ (sendStreamSize - totalSent));\n  }\n  return tosend == 0;\n}\n", "docstring": "writes the data until there \"'\" s space available", "partition": "test"}
{"idx": "641", "code": "public static int copyAndCloseOutput(Reader input,Writer output) throws IOException {\n  try {\n    return copy(input,output);\n  }\n  finally {\n    output.close();\n  }\n}\n", "docstring": "copy input to output and close the output stream before returning", "partition": "test"}
{"idx": "642", "code": "public int checkBookiesUp(int count,int timeout) throws Exception {\n  ZooKeeper zkc=connectZooKeeper(zkHost,zkPort,zkTimeoutSec);\n  try {\n    int mostRecentSize=0;\n    for (int i=0; i < timeout; i++) {\n      try {\n        List<String> children=zkc.getChildren(\"/ledgers/available\",false);\n        children.remove(\"readonly\");\n        mostRecentSize=children.size();\n        if ((mostRecentSize > count) || LOG.isDebugEnabled()) {\n          LOG.info(\"Found \" + mostRecentSize + \" bookies up, \"+ \"waiting for \"+ count);\n          if ((mostRecentSize > count) || LOG.isTraceEnabled()) {\n            for (            String child : children) {\n              LOG.info(\" server: \" + child);\n            }\n          }\n        }\n        if (mostRecentSize == count) {\n          break;\n        }\n      }\n catch (      KeeperException e) {\n      }\n      Thread.sleep(1000);\n    }\n    return mostRecentSize;\n  }\n  finally {\n    zkc.close();\n  }\n}\n", "docstring": "check that a number of bookies are available", "partition": "test"}
{"idx": "643", "code": "public Point2D inverseTransform(Point2D src,Point2D dst){\n  try {\n    src.setLocation(src.getX() + rotXOffset,src.getY() + rotYOffset);\n    dst=rotTransform.inverseTransform(src,dst);\n  }\n catch (  NoninvertibleTransformException e) {\n    logger.log(Level.FINE,e.getMessage(),e);\n  }\n  return dst;\n}\n", "docstring": "returns dst , the unrotated pixel location of the map .", "partition": "test"}
{"idx": "644", "code": "protected ArrayList<KeyNamePair> loadRMAData(int C_BPartner_ID){\n  ArrayList<KeyNamePair> list=new ArrayList<KeyNamePair>();\n  String sqlStmt=\"SELECT r.M_RMA_ID, r.DocumentNo || \'-\' || r.Amt from M_RMA r \" + \"WHERE ISSOTRX=\'N\' AND r.DocStatus in (\'CO\', \'CL\') \" + \"AND r.C_BPartner_ID=? \"+ \"AND NOT EXISTS (SELECT * FROM C_Invoice inv \"+ \"WHERE inv.M_RMA_ID=r.M_RMA_ID AND inv.DocStatus IN (\'CO\', \'CL\'))\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sqlStmt,null);\n    pstmt.setInt(1,C_BPartner_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      list.add(new KeyNamePair(rs.getInt(1),rs.getString(2)));\n    }\n    rs.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sqlStmt.toString(),e);\n  }\n finally {\n    if (pstmt != null) {\n      try {\n        pstmt.close();\n      }\n catch (      Exception ex) {\n        log.severe(\"Could not close prepared statement\");\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "load pbartner dependent order / invoice / shipment field .", "partition": "test"}
{"idx": "645", "code": "@Override public List<WorkOrder> searchWOForBilling(final Map<String,Object> criteriaMap){\n  logger.debug(\"-------------------------Inside searchWOForBilling-----------------------\");\n  final List<WorkOrder> filteredList=new ArrayList<WorkOrder>();\n  criteriaMap.put(ACTION_FLAG,\"searchWOForBilling\");\n  for (  final WorkOrder workorder : searchWO(criteriaMap))   if (!isWOValidforBill(workorder.getId()))   filteredList.add(workorder);\n  return filteredList;\n}\n", "docstring": "this method will search list of wo \"'\" s for the given criteria and eligible for mb . criteriamap will have : contractor_id , create_date , tender_no , workorder_no , project_code filter : 1 ) an existing bill with status in \" new \" or \" approval pending \" or \" rejected will not be retrieved 2 ) work orders for which the final bill is generated will not be retrieved for selection in the search result set . 2 ) work orders with existing bill with status \" approved \" with no existing bill can be retrieved for selection", "partition": "test"}
{"idx": "646", "code": "public Week(Date time,TimeZone zone,Locale locale){\n  ParamChecks.nullNotPermitted(time,\"time\");\n  ParamChecks.nullNotPermitted(zone,\"zone\");\n  ParamChecks.nullNotPermitted(locale,\"locale\");\n  Calendar calendar=Calendar.getInstance(zone,locale);\n  calendar.setTime(time);\n  int tempWeek=calendar.get(Calendar.WEEK_OF_YEAR);\n  if (tempWeek == 1 && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {\n    this.week=1;\n    this.year=(short)(calendar.get(Calendar.YEAR) + 1);\n  }\n else {\n    this.week=(byte)Math.min(tempWeek,LAST_WEEK_IN_YEAR);\n    int yyyy=calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.MONTH) == Calendar.JANUARY && this.week >= 52) {\n      yyyy--;\n    }\n    this.year=(short)yyyy;\n  }\n  peg(calendar);\n}\n", "docstring": "creates a time period for the week in which the specified date / time falls , calculated relative to the specified time zone .", "partition": "test"}
{"idx": "647", "code": "public ResourceQueue(final NonBlockingLockManagerWithNewDesign<R> lockService,final R resource){\n  if (lockService == null)   throw new IllegalArgumentException();\n  if (resource == null)   throw new IllegalArgumentException();\n  this.lockService=lockService;\n  this.resource=resource;\n  this.queue=new LinkedBlockingQueue<T>();\n  this.statisticsTask=new QueueSizeMovingAverageTask(resource.toString(),queue);\n}\n", "docstring": "create a queue of lock requests for a resource .", "partition": "test"}
{"idx": "648", "code": "public void encodeAndSign(X500Name subject,Signature signature) throws CertificateException, IOException, SignatureException {\n  DerOutputStream out, scratch;\n  byte[] certificateRequestInfo;\n  byte[] sig;\n  if (encoded != null)   throw new SignatureException(\"request is already signed\");\n  this.subject=subject;\n  scratch=new DerOutputStream();\n  scratch.putInteger(BigInteger.ZERO);\n  subject.encode(scratch);\n  scratch.write(subjectPublicKeyInfo.getEncoded());\n  attributeSet.encode(scratch);\n  out=new DerOutputStream();\n  out.write(DerValue.tag_Sequence,scratch);\n  certificateRequestInfo=out.toByteArray();\n  scratch=out;\n  signature.update(certificateRequestInfo,0,certificateRequestInfo.length);\n  sig=signature.sign();\n  AlgorithmId algId=null;\n  try {\n    algId=AlgorithmId.get(signature.getAlgorithm());\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    throw new SignatureException(nsae);\n  }\n  algId.encode(scratch);\n  scratch.putBitString(sig);\n  out=new DerOutputStream();\n  out.write(DerValue.tag_Sequence,scratch);\n  encoded=out.toByteArray();\n}\n", "docstring": "create the signed certificate request . this will later be retrieved in either string or binary format .", "partition": "test"}
{"idx": "649", "code": "public synchronized void schedulePeriodicTask(TimerTask task,long period){\n  try {\n    m_timer.scheduleAtFixedRate(task,0,period);\n  }\n catch (  IllegalStateException ie) {\n    m_timer=new Timer();\n    m_timer.scheduleAtFixedRate(task,0,period);\n  }\n}\n", "docstring": "schedule a task that starts immediately", "partition": "test"}
{"idx": "650", "code": "protected void stopWraparoundTest(){\n  if (testRunning && wrapTest) {\n    wrapTimer.stop();\n    statusText1.setText(\"Wraparound Test Stopped, \" + Integer.toString(numErrors) + \" Errors Found\");\n    statusText1.setVisible(true);\n    statusText2.setText(Integer.toString(numIterations) + \" Cycles Completed\");\n    statusText2.setVisible(true);\n  }\n}\n", "docstring": "local method to stop a wraparound test", "partition": "test"}
{"idx": "651", "code": "protected void checkRowIndex(final int row) throws MathIllegalArgumentException {\n  if (row < 0 || row >= getRowDimension()) {\n    throw new MathIllegalArgumentException(LocalizedCoreFormats.ROW_INDEX,row,0,getRowDimension() - 1);\n  }\n}\n", "docstring": "check if a row index is valid .", "partition": "test"}
{"idx": "652", "code": "private void nukeSymbols(){\n  _count=0;\n  _longestCollisionList=0;\n  Arrays.fill(_mainHash,0);\n  Arrays.fill(_mainNames,null);\n  Arrays.fill(_collList,null);\n  _collCount=0;\n  _collEnd=0;\n}\n", "docstring": "helper method called to empty all shared symbols , but to leave arrays allocated", "partition": "test"}
{"idx": "653", "code": "public Name join(String identifier){\n  validateLowerUnderscore(identifier);\n  List<NamePiece> newPieceList=new ArrayList<>();\n  newPieceList.addAll(namePieces);\n  newPieceList.add(new NamePiece(identifier,CaseFormat.LOWER_UNDERSCORE));\n  return new Name(newPieceList);\n}\n", "docstring": "returns a new name containing the pieces from this name plus the given identifier added on the end .", "partition": "test"}
{"idx": "654", "code": "private LocalDateTime parseDate(String dateStr,boolean tryAgain){\n  LocalDateTime date=LocalDateTime.now(ZoneId.of(\"GMT\"));\n  if (mDateTimeFormatter == null) {\n    initFormatter(dateStr);\n  }\n  if (mDateTimeFormatter != null) {\n    try {\n      date=LocalDateTime.parse(dateStr,mDateTimeFormatter);\n    }\n catch (    DateTimeParseException e) {\n      Timber.d(String.format(\"ParseException parsing date: %s\",dateStr));\n      if (tryAgain) {\n        Timber.d(\"ParseException encountered, re-initializing the date parser\");\n        mDateTimeFormatter=null;\n        parseDate(dateStr,false);\n      }\n    }\n  }\n  return date;\n}\n", "docstring": "parses a string date into a java date object", "partition": "test"}
{"idx": "655", "code": "public String toString(){\n  String string=caller;\n  if (level > 0 || thread != -1) {\n    string+=\"[\";\n  }\n  if (level > 0) {\n    string+=level;\n  }\n  if (thread != -1) {\n    string+=\",\" + thread;\n  }\n  if (level > 0 || thread != -1) {\n    string+=\"]\";\n  }\n  string+=\":\";\n  if (spawnMessage) {\n    string+=\">\";\n  }\n  if (answer.length() > 0) {\n    string+=answer + \"=\";\n  }\n  if (callee.length() > 0) {\n    string+=callee + \".\";\n  }\n  string+=message;\n  if (returnsInstantly) {\n    string+=\"&\";\n  }\n  return string;\n}\n", "docstring": "returns a string representation of the message data . todo : broadcasts , ( answer ) note number , escaping", "partition": "test"}
{"idx": "656", "code": "public static boolean isWhiteSpace(int c){\nswitch (c) {\ncase NUL_CHAR:\ncase '\\t':\ncase '\\n':\ncase FF_CHAR:\ncase '\\r':\ncase ' ':\n    return true;\ndefault :\n  return false;\n}\n}\n", "docstring": "is the argument a white space character according to the pdf spec ? . iso spec 32000 - 1 : 2008 - table 1", "partition": "test"}
{"idx": "657", "code": "public void remove(RequestFilter filter){\n  filters.remove(filter);\n}\n", "docstring": "unregister filter ( it won \"'\" t get anymore events )", "partition": "test"}
{"idx": "658", "code": "protected void removeClassifiers(int[] indices){\n  int i;\n  if (indices == null) {\n    m_ModelClassifiers.removeAllElements();\n  }\n else {\n    for (i=indices.length - 1; i >= 0; i--)     m_ModelClassifiers.remove(indices[i]);\n  }\n  setModified(true);\n}\n", "docstring": "removes the specified classifiers .", "partition": "test"}
{"idx": "659", "code": "public void addElement(Object anObject){\n  p_data.add(anObject);\n  fireIntervalAdded(this,p_data.size() - 1,p_data.size() - 1);\n  if (p_data.size() == 1 && m_selectedObject == null && anObject != null)   setSelectedItem(anObject);\n}\n", "docstring": "add element at the end", "partition": "test"}
{"idx": "660", "code": "public void addAssignedVirtualArrays(Set<String> virtualArrayURIs){\n  if ((virtualArrayURIs != null) && (!virtualArrayURIs.isEmpty())) {\n    HashSet<String> addVirtualArrays=new HashSet<String>();\n    addVirtualArrays.addAll(virtualArrayURIs);\n    if (_assignedVirtualArrays == null) {\n      setAssignedVirtualArrays(new StringSet());\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n else {\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n    updateVirtualArrayTags();\n  }\n}\n", "docstring": "adds the passed virtual array uris to the set of virtual array uris assigned to the resources by the user .", "partition": "test"}
{"idx": "661", "code": "@Override public boolean isCellEditable(int row,int column){\n  EnvVar envVar=dataList.get(row);\n  if (column == COL_VALUE) {\n    return true;\n  }\n  return !envVar.isPredefined();\n}\n", "docstring": "checks if is cell editable .", "partition": "test"}
{"idx": "662", "code": "private boolean dropInTrash(){\n  if (mHighlightedBlockView != null) {\n    mHighlightedBlockView.setHighlightedConnection(null);\n    mHighlightedBlockView=null;\n  }\n  mDraggedConnections.clear();\n  return mController.trashRootBlock(mPendingDrag.getRootDraggedBlock());\n}\n", "docstring": "ends a drag in the trash can , clearing state and deleting blocks as needed .", "partition": "test"}
{"idx": "663", "code": "<T>List<T> concatValues(final T[]... data){\n  final List<T> rv=new ArrayList<>();\n  for (  T[] values : data) {\n    rv.addAll(Arrays.asList(values));\n  }\n  return rv;\n}\n", "docstring": "helper for concatenating several arrays .", "partition": "test"}
{"idx": "664", "code": "public DagIterator(Graph pattern){\n  for (  Edge edge : pattern.getEdges()) {\n    if (Edges.isDirectedEdge(edge) || Edges.isUndirectedEdge(edge)) {\n      continue;\n    }\n    throw new IllegalArgumentException(\"The graph may consist only of \" + \"directed and undirected edges: \" + edge);\n  }\n  decoratedGraphs.add(new DecoratedGraph(pattern));\n}\n", "docstring": "the given pattern must be a pattern . if it does not consist entirely of directed and undirected edges and if it is not acyclic , it is rejected .", "partition": "test"}
{"idx": "665", "code": "private boolean validateCustomCatalog(String title,String value){\n  return false;\n}\n", "docstring": "check a field that defines a custom catalog", "partition": "test"}
{"idx": "666", "code": "public FunctionExecutionPooledExecutor(BlockingQueue<Runnable> q,int poolSize,PoolStatHelper stats,ThreadFactory tf){\n  this(q,poolSize,stats,tf,Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + \"IDLE_THREAD_TIMEOUT\",30000 * 60),false);\n}\n", "docstring": "sets timeout to idle_thread_timeout", "partition": "test"}
{"idx": "667", "code": "protected boolean isSSDPDiscovery(String body){\n  if (body != null && body.startsWith(\"M-SEARCH * HTTP/1.1\") && body.contains(\"MAN: \\\"ssdp:discover\\\"\")) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "very naive ssdp discovery packet detection", "partition": "test"}
{"idx": "668", "code": "@Override public void addChild(WXComponent child,int index){\n  if (child == null || index < -1) {\n    return;\n  }\n  if (child instanceof WXBaseRefresh) {\n    if (!checkRefreshOrLoading(child)) {\n      mRefreshs.add(child);\n    }\n    return;\n  }\n  if (mChildren == null) {\n    mChildren=new ArrayList<>();\n  }\n  int count=mChildren.size();\n  index=index >= count ? -1 : index;\n  if (index == -1) {\n    mChildren.add(child);\n  }\n else {\n    mChildren.add(index,child);\n  }\n}\n", "docstring": "intercept refresh view and loading view", "partition": "test"}
{"idx": "669", "code": "private void restoreSortingSelection(int[] selection,int lead,ModelChange change){\n  for (int i=selection.length - 1; i >= 0; i--) {\n    selection[i]=convertRowIndexToView(selection[i],change);\n  }\n  lead=convertRowIndexToView(lead,change);\n  if (selection.length == 0 || (selection.length == 1 && selection[0] == getSelectedRow())) {\n    return;\n  }\n  selectionModel.setValueIsAdjusting(true);\n  selectionModel.clearSelection();\n  for (int i=selection.length - 1; i >= 0; i--) {\n    if (selection[i] != -1) {\n      selectionModel.addSelectionInterval(selection[i],selection[i]);\n    }\n  }\n  SwingUtilities2.setLeadAnchorWithoutSelection(selectionModel,lead,lead);\n  selectionModel.setValueIsAdjusting(false);\n}\n", "docstring": "restores the selection after a model event / sort order changes . all coordinates are in terms of the model .", "partition": "test"}
{"idx": "670", "code": "@After public void clean(){\n  mute(null);\n  mute(null);\n  mute(null);\n}\n", "docstring": "cleanups after each tests .", "partition": "test"}
{"idx": "671", "code": "public void consume(int eventCount,long timeoutInMillis,Predicate<Event> condition) throws TimeoutException {\n  if (eventCount < 0)   throw new IllegalArgumentException(\"The eventCount may not be negative\");\n  if (eventCount == 0)   return;\n  int eventsRemaining=eventCount;\n  final long stopTime=System.currentTimeMillis() + timeoutInMillis;\n  while (eventsRemaining > 0 && System.currentTimeMillis() < stopTime) {\n    Event nextEvent=queue.poll();\n    if (nextEvent != null) {\n      if (condition.test(nextEvent)) {\n        --eventsRemaining;\n        consumedEvents.accept(nextEvent);\n      }\n else {\n        ignoredEvents.accept(nextEvent);\n      }\n    }\n  }\n  if (eventsRemaining > 0) {\n    throw new TimeoutException(\"Received \" + (eventCount - eventsRemaining) + \" of \"+ eventCount+ \" in \"+ timeoutInMillis+ \"ms\");\n  }\n}\n", "docstring": "blocks until the listener has consume the specified number of matching events , blocking at most the specified number of milliseconds . if this method has not reached the number of matching events and comes across events that do not satisfy the predicate , those events are consumed and ignored .", "partition": "test"}
{"idx": "672", "code": "private void updateUiFromCommand(Command command){\n  if (command == null) {\n    return;\n  }\n  actionsComboBox.setText(command.getAction());\n  dataTextField.setText(command.getData());\n  categoryTextField.setText(command.getCategory());\n  mimeTextField.setText(command.getMimeType());\n  componentTextField.setText(command.getComponent());\n  userTextField.setText(command.getUser());\n  flagsList_.removeSelectionInterval(0,flagsList_.getItemsCount());\n  List<IntentFlags> flags=command.getFlags();\n  if (flags != null && flags.size() > 0) {\n    for (    IntentFlags flag : command.getFlags()) {\n      flagsList_.setSelectedValue(flag,false);\n    }\n  }\n else {\n    flagsList_.setSelectedIndex(0);\n  }\n  updateFlagsTextField();\n  tableModel_.removeAllRows();\n  List<ExtraField> extras=command.getExtras();\n  if (extras != null && extras.size() > 0) {\n    for (    ExtraField extra : extras) {\n      tableModel_.addRow(extra);\n    }\n  }\n  updateTableVisibility();\n}\n", "docstring": "fills up vies from given command", "partition": "test"}
{"idx": "673", "code": "public static int randGaussian(final int mean,final int sd){\n  return (int)(rand.nextGaussian() * sd + mean);\n}\n", "docstring": "generates a normally distributed random number and rounds it .", "partition": "test"}
{"idx": "674", "code": "public IVector(int c){\n  vector=new int[Math.max(defaultCapacity,c)];\n}\n", "docstring": "constructs a new vector with the specified capacity .", "partition": "test"}
{"idx": "675", "code": "public void processInvite(RequestEvent requestEvent,ServerTransaction serverTransaction){\n  final Request request=requestEvent.getRequest();\n  final SipProvider sipProvider=(SipProvider)requestEvent.getSource();\n  ServerTransaction st=serverTransaction;\n  try {\n    if (st == null) {\n      try {\n        st=sipProvider.getNewServerTransaction(request);\n      }\n catch (      TransactionUnavailableException tae) {\n        tae.printStackTrace();\n        return;\n      }\ncatch (      TransactionAlreadyExistsException taex) {\n        return;\n      }\n    }\n    final String toTag=\"\" + System.nanoTime();\n    Response response=messageFactory.createResponse(Response.RINGING,request);\n    ToHeader toHeader=(ToHeader)response.getHeader(ToHeader.NAME);\n    toHeader.setTag(toTag);\n    st.sendResponse(response);\n    response=messageFactory.createResponse(Response.OK,request);\n    final Address address=addressFactory.createAddress(\"Shootme <sip:\" + myAddress + \":\"+ myPort+ \">\");\n    final ContactHeader contactHeader=headerFactory.createContactHeader(address);\n    response.addHeader(contactHeader);\n    toHeader=(ToHeader)response.getHeader(ToHeader.NAME);\n    toHeader.setTag(toTag);\n    st.sendResponse(response);\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}\n", "docstring": "process the invite request .", "partition": "test"}
{"idx": "676", "code": "public static IgniteLogger logger(GridKernalContext ctx,AtomicReference<IgniteLogger> logRef,Object obj){\n  IgniteLogger log=logRef.get();\n  if (log == null) {\n    logRef.compareAndSet(null,ctx.log(obj.getClass()));\n    log=logRef.get();\n  }\n  return log;\n}\n", "docstring": "initializes logger into / from log reference passed in .", "partition": "test"}
{"idx": "677", "code": "protected boolean readReceiveDelay(){\n  try {\n    receiveDelay=Integer.parseInt(receiveDelayField.getText());\n  }\n catch (  Exception e) {\n    statusText1.setText(rb.getString(\"Error7\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay < 0) {\n    statusText1.setText(rb.getString(\"Error8\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay > 65535) {\n    statusText1.setText(rb.getString(\"Error9\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  return true;\n}\n", "docstring": "read receive delay from window returns \"'\" true \"'\" if successful , \"'\" false \"'\" if an error was detected . if an error is detected , a suitable error message is placed in the notes area", "partition": "test"}
{"idx": "678", "code": "private void writeIndent(int times) throws IOException {\n  for (int i=options.getBaseIndent() + times; i > 0; i--) {\n    writer.write(options.getIndent());\n  }\n}\n", "docstring": "writes indents and automatically includes the baseindend from the options .", "partition": "test"}
{"idx": "679", "code": "public static int parseString(String value){\n  return Integer.parseInt(value);\n}\n", "docstring": "parse string value returning a int .", "partition": "test"}
{"idx": "680", "code": "void doHandleJavaMouseEvent(MouseEvent mouseEvent){\n  if (!XToolkit.isLeftMouseButton(mouseEvent) && !XToolkit.isRightMouseButton(mouseEvent)) {\n    return;\n  }\n  XBaseWindow grabWindow=XAwtState.getGrabWindow();\n  Point ptGlobal=mouseEvent.getLocationOnScreen();\n  if (!hasPointerMoved) {\n    if (grabInputPoint == null || (Math.abs(ptGlobal.x - grabInputPoint.x) > getMouseMovementSmudge()) || (Math.abs(ptGlobal.y - grabInputPoint.y) > getMouseMovementSmudge())) {\n      hasPointerMoved=true;\n    }\n  }\n  XBaseMenuWindow wnd=getMenuWindowFromPoint(ptGlobal);\n  XMenuItemPeer item=(wnd != null) ? wnd.getItemFromPoint(wnd.toLocal(ptGlobal)) : null;\n  XBaseMenuWindow cwnd=getShowingLeaf();\nswitch (mouseEvent.getID()) {\ncase MouseEvent.MOUSE_PRESSED:\n    showingMousePressedSubmenu=null;\n  if ((grabWindow == this) && (wnd == null)) {\n    ungrabInput();\n  }\n else {\n    grabInput();\n    if (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\n      if (wnd.getShowingSubmenu() == item) {\n        showingMousePressedSubmenu=(XMenuPeer)item;\n      }\n      wnd.selectItem(item,true);\n    }\n else {\n      if (wnd != null) {\n        wnd.selectItem(null,false);\n      }\n    }\n  }\nbreak;\ncase MouseEvent.MOUSE_RELEASED:\nif (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\nif (item instanceof XMenuPeer) {\n  if (showingMousePressedSubmenu == item) {\n    if (wnd instanceof XMenuBarPeer) {\n      ungrabInput();\n    }\n else {\n      wnd.selectItem(item,false);\n    }\n  }\n}\n else {\n  item.action(mouseEvent.getWhen());\n  ungrabInput();\n}\n}\n else {\nif (hasPointerMoved || (wnd instanceof XMenuBarPeer)) {\n  ungrabInput();\n}\n}\nshowingMousePressedSubmenu=null;\nbreak;\ncase MouseEvent.MOUSE_DRAGGED:\nif (wnd != null) {\nif (item != null && !item.isSeparator() && item.isTargetItemEnabled()) {\nif (grabWindow == this) {\nwnd.selectItem(item,true);\n}\n}\n else {\nwnd.selectItem(null,false);\n}\n}\n else {\nif (cwnd != null) {\ncwnd.selectItem(null,false);\n}\n}\nbreak;\n}\n}\n", "docstring": "performs handling of java mouse event note that this function should be invoked only from root of menu window \"'\" s hierarchy that grabs input focus", "partition": "test"}
{"idx": "681", "code": "public boolean isInvalidNode(){\n  ASTNode first=fNodes.get(0);\n  ASTNode candidate=first.getParent();\n  if (candidate == null)   return false;\n  if (candidate.getNodeType() == ASTNode.METHOD_DECLARATION)   return true;\n  return false;\n}\n", "docstring": "tests whether the node to be replaced is invalid .", "partition": "test"}
{"idx": "682", "code": "public void onMotion(MotionEvent event,Interaction iact){\n}\n", "docstring": "notifies listener of a mouse motion event . a motion event is dispatched when no button is currently pressed , in an isolated \" one shot \" interaction , and always goes to the layer hit by the event coordinates .", "partition": "test"}
{"idx": "683", "code": "public synchronized void removeBatchClustererListener(BatchClustererListener cl){\n  m_batchClustererListeners.remove(cl);\n}\n", "docstring": "remove a batch clusterer listener", "partition": "test"}
{"idx": "684", "code": "public HeldLocksGrant refresh(long expirationDateMs){\n  return new HeldLocksGrant(grantId,creationDateMs,expirationDateMs,lockMap,lockTimeout,versionId);\n}\n", "docstring": "this should only be called by the lock service . calling this method won \"'\" t actually refresh the grant .", "partition": "test"}
{"idx": "685", "code": "void removeKnownObject(ParseObject object){\nsynchronized (mutex) {\n    knownObjects.remove(object);\n  }\n}\n", "docstring": "removes an object that is known to not be in the relation . this is used for offline caching .", "partition": "test"}
{"idx": "686", "code": "static HeapBytesStore<byte[]> wrap(@NotNull byte[] bytes){\n  return HeapBytesStore.wrap(bytes);\n}\n", "docstring": "wraps a byte [ ", "partition": "test"}
{"idx": "687", "code": "private static String parse(JsonValue base){\n  if (!base.isString()) {\n    return null;\n  }\n  return buildString(base.asString());\n}\n", "docstring": "start the string parsing . if base is not a string , will return null .", "partition": "test"}
{"idx": "688", "code": "public void beforeInsert(int index,char element){\n  if (index > size || index < 0)   throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"+ size);\n  ensureCapacity(size + 1);\n  System.arraycopy(elements,index,elements,index + 1,size - index);\n  elements[index]=element;\n  size++;\n}\n", "docstring": "inserts the specified element before the specified position into the receiver . shifts the element currently at that position ( if any ) and any subsequent elements to the right .", "partition": "test"}
{"idx": "689", "code": "private void growEntries(){\n  int newLen=(next.length << 1) + 1;\n  int[] newNext=new int[newLen];\n  GridUnsafe.copyMemory(next,INT_ARR_OFF,newNext,INT_ARR_OFF,size << 2);\n  next=newNext;\n  nextEmpty=new int[newLen];\n  Arrays.fill(nextEmpty,-1);\n  Object[] newObjs=new Object[newLen];\n  System.arraycopy(objs,0,newObjs,0,size);\n  objs=newObjs;\n}\n", "docstring": "increases hash table capacity by lengthening entry arrays .", "partition": "test"}
{"idx": "690", "code": "public SidedPlane(final Vector p,final boolean onSide,final Vector A,final Vector B){\n  super(A,B);\n  sigNum=onSide ? Math.signum(evaluate(p)) : -Math.signum(evaluate(p));\n  if (sigNum == 0.0)   throw new IllegalArgumentException(\"Cannot determine sidedness because check point is on plane.\");\n}\n", "docstring": "construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .", "partition": "test"}
{"idx": "691", "code": "private void clear(){\n  valid=false;\n  if ((listenerObjects == null) || listenerObjects.isEmpty()) {\n    deregisterListener();\n  }\n  ssm=null;\n  if (SMSEntry.cacheSMSEntries) {\n    orgConfigs.clear();\n    globalConfigs.clear();\n  }\n}\n", "docstring": "clears instance cache and deregisters listeners", "partition": "test"}
{"idx": "692", "code": "public static void registerDecayableObject(Decayable obj){\n  decayObjects.add(obj);\n}\n", "docstring": "registers an object that should be decayed . the passed object will have its decay method called when the decaying thread decides it is time for the system to decay .", "partition": "test"}
{"idx": "693", "code": "public static void assertExpectedOutputContains(String expectedString,String x){\n  if (!x.contains(expectedString)) {\n    fail(\"expected \'\" + expectedString + \"\' not found in \'\"+ x+ \"\'\");\n  }\n}\n", "docstring": "fails if expectedstring is not found in x", "partition": "test"}
{"idx": "694", "code": "public boolean remove(String classname){\n  String pkgname;\n  HashSet<String> names;\n  classname=cleanUp(classname);\n  pkgname=extractPackage(classname);\n  names=m_Cache.get(pkgname);\n  if (names != null) {\n    return names.remove(classname);\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "removes the classname from the cache .", "partition": "test"}
{"idx": "695", "code": "public void testFailedStage(){\n  CFException ex=new CFException();\n  CompletionStage<Integer> f=CompletableFuture.failedStage(ex);\n  AtomicInteger x=new AtomicInteger(0);\n  AtomicReference<Throwable> r=new AtomicReference<Throwable>();\n  f.whenComplete(null);\n  assertEquals(x.get(),0);\n  assertEquals(r.get(),ex);\n}\n", "docstring": "failedstage returns a completionstage completed exceptionally with the given exception", "partition": "test"}
{"idx": "696", "code": "@Override public void paintComponent(Graphics g){\n  super.paintComponent(g);\n  Graphics2D graphics=(Graphics2D)g;\n  graphics.setBackground(mColorSpectrumBackground);\n  RenderingHints renderHints=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  renderHints.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n  graphics.setRenderingHints(renderHints);\n  drawFrequencies(graphics);\n  drawCursor(graphics);\n}\n", "docstring": "renders the channel configs , lines , labels , and cursor", "partition": "test"}
{"idx": "697", "code": "public void classLoaderDestroy(DynamicClassLoader loader){\n  Method destroy=getDestroyMethod(_resource.getClass());\n  if (destroy == null)   return;\n  try {\n    destroy.invoke(_resource);\n  }\n catch (  Throwable e) {\n    log.log(Level.WARNING,e.toString(),e);\n  }\n}\n", "docstring": "handles the case where a class loader is dropped .", "partition": "test"}
{"idx": "698", "code": "public boolean deleteAttachmentPoint(DatapathId sw,OFPort port){\n  AttachmentPoint ap=new AttachmentPoint(sw,port,new Date(0));\n  if (this.oldAPs != null) {\n    ArrayList<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n    apList.addAll(this.oldAPs);\n    int index=apList.indexOf(ap);\n    if (index > 0) {\n      apList.remove(index);\n      this.oldAPs=apList;\n    }\n  }\n  if (this.attachmentPoints != null) {\n    ArrayList<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n    apList.addAll(this.attachmentPoints);\n    int index=apList.indexOf(ap);\n    if (index > 0) {\n      apList.remove(index);\n      this.attachmentPoints=apList;\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "delete ( sw , port ) from the list of list of attachment points and oldaps .", "partition": "test"}
{"idx": "699", "code": "static boolean isAssignableTo(ClassNode type,ClassNode toBeAssignedTo){\n  if (UNKNOWN_PARAMETER_TYPE == type)   return true;\n  if (type == toBeAssignedTo)   return true;\n  if (toBeAssignedTo.redirect() == STRING_TYPE && type.redirect() == GSTRING_TYPE) {\n    return true;\n  }\n  if (isPrimitiveType(toBeAssignedTo))   toBeAssignedTo=getWrapper(toBeAssignedTo);\n  if (isPrimitiveType(type))   type=getWrapper(type);\n  if (Double_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE);\n  }\n  if (Float_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect();\n  }\n  if (Long_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect();\n  }\n  if (Integer_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect() && Long_TYPE != type.redirect();\n  }\n  if (Short_TYPE == toBeAssignedTo) {\n    return type.isDerivedFrom(Number_TYPE) && Double_TYPE != type.redirect() && Float_TYPE != type.redirect() && Long_TYPE != type.redirect() && Integer_TYPE != type.redirect();\n  }\n  if (Byte_TYPE == toBeAssignedTo) {\n    return type.redirect() == Byte_TYPE;\n  }\n  if (type.isArray() && toBeAssignedTo.isArray()) {\n    return isAssignableTo(type.getComponentType(),toBeAssignedTo.getComponentType());\n  }\n  if (type.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(toBeAssignedTo)) {\n    return true;\n  }\n  if (toBeAssignedTo.isDerivedFrom(GSTRING_TYPE) && STRING_TYPE.equals(type)) {\n    return true;\n  }\n  if (implementsInterfaceOrIsSubclassOf(type,toBeAssignedTo)) {\n    if (OBJECT_TYPE.equals(toBeAssignedTo))     return true;\n    if (toBeAssignedTo.isUsingGenerics()) {\n      GenericsType gt=GenericsUtils.buildWildcardType(toBeAssignedTo);\n      return gt.isCompatibleWith(type);\n    }\n    return true;\n  }\n  if (type.isDerivedFrom(CLOSURE_TYPE) && isSAMType(toBeAssignedTo)) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "checks if a class node is assignable to another . this is used for example in assignment checks where you want to verify that the assignment is valid .", "partition": "test"}
{"idx": "700", "code": "public synchronized int totalRecoverFiles(){\n  int total=0;\n  for (  File file : fileDetails.values()) {\n    if (file.reused() == false) {\n      total++;\n    }\n  }\n  return total;\n}\n", "docstring": "total number of files to be recovered ( potentially not yet done )", "partition": "test"}
{"idx": "701", "code": "@Override @Timed public void deleteAssignment(Experiment experiment,User.ID userID,Context context,Application.Name appName,Assignment currentAssignment){\n  deleteUserFromLookUp(experiment.getID(),userID,context);\n  boolean countUp=false;\n  assignmentsCountExecutor.execute(new AssignmentCountEnvelope(assignmentsRepository,experimentRepository,dbRepository,experiment,currentAssignment,countUp,eventLog,null,assignUserToExport,assignBucketCount));\n  deleteAssignmentOld(experiment.getID(),userID,context,appName,currentAssignment.getBucketLabel());\n  removeIndexUserToExperiment(userID,experiment.getID(),context,appName);\n  removeIndexUserToBucket(userID,experiment.getID(),context,currentAssignment.getBucketLabel());\n  removeIndexExperimentsToUser(userID,experiment.getID(),context,appName);\n}\n", "docstring": "deletes the existing assignment between a user and an experiment .", "partition": "test"}
{"idx": "702", "code": "String format(Object obj,StringBuffer toAppendTo) throws IllegalArgumentException {\n  Date source=null;\n  if (obj instanceof Date) {\n    source=(Date)obj;\n  }\n else   if (obj instanceof String) {\n    try {\n      source=parse((String)obj);\n    }\n catch (    ParseException pe) {\n      throw new RuntimeException(pe.toString());\n    }\n  }\n  if (source == null) {\n    throw new IllegalArgumentException((obj == null) ? \"null\" : obj.toString());\n  }\n  return format(source,toAppendTo);\n}\n", "docstring": "format a given object .", "partition": "test"}
{"idx": "703", "code": "public static ThreadDump create(){\n  ThreadDump threadDump=_threadDumpRef.get();\n  if (threadDump == null) {\n    threadDump=new ThreadDumpPro();\n    _threadDumpRef.compareAndSet(null,threadDump);\n    threadDump=_threadDumpRef.get();\n  }\n  return threadDump;\n}\n", "docstring": "returns the singleton instance , creating if necessary . an instance of com . caucho . server . admin . prothreaddump will be returned if available and licensed . prothreaddump includes the uri of the request the thread is processing , if applicable .", "partition": "test"}
{"idx": "704", "code": "private void checkStart(){\n  if (mCanProcessAudio && !mOutput.isRunning() && mOutput.available() <= mBufferStartThreshold) {\n    mOutput.start();\n  }\n}\n", "docstring": "starts audio playback once audio buffer is almost full and remaining capacity falls below the start threshold .", "partition": "test"}
{"idx": "705", "code": "protected boolean matchesFilter(final String input,final String[] filter){\n  for (  final String match : filter) {\n    if (!input.contains(match))     return false;\n  }\n  return true;\n}\n", "docstring": "checks if all keywords in filter array are in input", "partition": "test"}
{"idx": "706", "code": "public IStatus run(IProgressMonitor monitor){\n  InputStream input=null;\n  FileOutputStream output=null;\n  IStatus jobStatus=Status.OK_STATUS;\n  byte[] b=new byte[1024];\n  int bytesRead;\n  try {\n    HttpURLConnection connection=(HttpURLConnection)url.openConnection();\n    input=url.openStream();\n    long totalBytesRead=0L;\n    int responseStatusCode=connection.getResponseCode();\n    if (responseStatusCode >= HttpURLConnection.HTTP_BAD_REQUEST) {\n      jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,MessageFormat.format(\"Remote ServerError: {0} ({1})\",responseStatusCode,connection.getResponseMessage()));\n    }\n    long contentLength=connection.getContentLength();\n    output=new FileOutputStream(target);\n    monitor.beginTask(\"Downloading \" + url.toString(),(int)contentLength);\n    while (jobStatus == Status.OK_STATUS) {\n      if (contentLength > 0 && totalBytesRead >= contentLength) {\n        break;\n      }\n      bytesRead=input.read(b);\n      if (bytesRead == -1) {\n        break;\n      }\n      output.write(b,0,bytesRead);\n      totalBytesRead+=bytesRead;\n      monitor.worked(bytesRead);\n      if (monitor.isCanceled()) {\n        jobStatus=Status.CANCEL_STATUS;\n        break;\n      }\n    }\n  }\n catch (  MalformedURLException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"Malformed URL: \" + url.toExternalForm(),e);\n  }\ncatch (  IOException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"IO error while downloading \" + url.toExternalForm(),e);\n  }\n  closeStreams(input,output);\n  return jobStatus;\n}\n", "docstring": "executes the downloadrunnable using the provided monitor to update the user and provide cancel capabilities .", "partition": "test"}
{"idx": "707", "code": "private void createMissingValues(){\n  String sql=\"SELECT ra.A_RegistrationAttribute_ID \" + \"FROM A_RegistrationAttribute ra\" + \" LEFT OUTER JOIN A_RegistrationProduct rp ON (rp.A_RegistrationAttribute_ID=ra.A_RegistrationAttribute_ID)\"+ \" LEFT OUTER JOIN A_Registration r ON (r.M_Product_ID=rp.M_Product_ID) \"+ \"WHERE r.A_Registration_ID=?\"+ \" AND NOT EXISTS (SELECT A_RegistrationAttribute_ID FROM A_RegistrationValue v \"+ \"WHERE ra.A_RegistrationAttribute_ID=v.A_RegistrationAttribute_ID AND r.A_Registration_ID=v.A_Registration_ID)\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getA_Registration_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRegistrationValue v=new MRegistrationValue(this,rs.getInt(1),\"?\");\n      v.saveEx();\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,null,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n}\n", "docstring": "create missing attribute values", "partition": "test"}
{"idx": "708", "code": "private static String normalisePath(String path){\n  return path.replace('\\\\','/');\n}\n", "docstring": "this method replaces all \\ to / .", "partition": "test"}
{"idx": "709", "code": "public void startLaunchNotifier(){\n  if (m_launchNotification == null)   throw new NullPointerException();\n  m_launchNotifierThread.setDaemon(true);\n  m_launchNotifierThread.start();\n}\n", "docstring": "creates a background thread that will call the launch notifier when the process terminates .", "partition": "test"}
{"idx": "710", "code": "private static void encode(List<AclEntry> acl,long address){\n  long offset=address;\n  for (  AclEntry ace : acl) {\n    int flags=0;\n    UserPrincipal who=ace.principal();\n    if (!(who instanceof UnixUserPrincipals.User))     throw new ProviderMismatchException();\n    UnixUserPrincipals.User user=(UnixUserPrincipals.User)who;\n    int uid;\n    if (user.isSpecial()) {\n      uid=-1;\n      if (who == UnixUserPrincipals.SPECIAL_OWNER)       flags|=ACE_OWNER;\n else       if (who == UnixUserPrincipals.SPECIAL_GROUP)       flags|=(ACE_GROUP | ACE_IDENTIFIER_GROUP);\n else       if (who == UnixUserPrincipals.SPECIAL_EVERYONE)       flags|=ACE_EVERYONE;\n else       throw new AssertionError(\"Unable to map special identifier\");\n    }\n else {\n      if (user instanceof UnixUserPrincipals.Group) {\n        uid=user.gid();\n        flags|=ACE_IDENTIFIER_GROUP;\n      }\n else {\n        uid=user.uid();\n      }\n    }\n    int type;\nswitch (ace.type()) {\ncase ALLOW:\n      type=ACE_ACCESS_ALLOWED_ACE_TYPE;\n    break;\ncase DENY:\n  type=ACE_ACCESS_DENIED_ACE_TYPE;\nbreak;\ncase AUDIT:\ntype=ACE_SYSTEM_AUDIT_ACE_TYPE;\nbreak;\ncase ALARM:\ntype=ACE_SYSTEM_ALARM_ACE_TYPE;\nbreak;\ndefault :\nthrow new AssertionError(\"Unable to map ACE type\");\n}\nSet<AclEntryPermission> aceMask=ace.permissions();\nint mask=0;\nif (aceMask.contains(AclEntryPermission.READ_DATA)) mask|=ACE_READ_DATA;\nif (aceMask.contains(AclEntryPermission.WRITE_DATA)) mask|=ACE_WRITE_DATA;\nif (aceMask.contains(AclEntryPermission.APPEND_DATA)) mask|=ACE_APPEND_DATA;\nif (aceMask.contains(AclEntryPermission.READ_NAMED_ATTRS)) mask|=ACE_READ_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.WRITE_NAMED_ATTRS)) mask|=ACE_WRITE_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.EXECUTE)) mask|=ACE_EXECUTE;\nif (aceMask.contains(AclEntryPermission.DELETE_CHILD)) mask|=ACE_DELETE_CHILD;\nif (aceMask.contains(AclEntryPermission.READ_ATTRIBUTES)) mask|=ACE_READ_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.WRITE_ATTRIBUTES)) mask|=ACE_WRITE_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.DELETE)) mask|=ACE_DELETE;\nif (aceMask.contains(AclEntryPermission.READ_ACL)) mask|=ACE_READ_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_ACL)) mask|=ACE_WRITE_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_OWNER)) mask|=ACE_WRITE_OWNER;\nif (aceMask.contains(AclEntryPermission.SYNCHRONIZE)) mask|=ACE_SYNCHRONIZE;\nSet<AclEntryFlag> aceFlags=ace.flags();\nif (aceFlags.contains(AclEntryFlag.FILE_INHERIT)) flags|=ACE_FILE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.DIRECTORY_INHERIT)) flags|=ACE_DIRECTORY_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.NO_PROPAGATE_INHERIT)) flags|=ACE_NO_PROPAGATE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.INHERIT_ONLY)) flags|=ACE_INHERIT_ONLY_ACE;\nunsafe.putInt(offset + OFFSETOF_UID,uid);\nunsafe.putInt(offset + OFFSETOF_MASK,mask);\nunsafe.putShort(offset + OFFSETOF_FLAGS,(short)flags);\nunsafe.putShort(offset + OFFSETOF_TYPE,(short)type);\noffset+=SIZEOF_ACE_T;\n}\n}\n", "docstring": "encode the acl to the given buffer", "partition": "test"}
{"idx": "711", "code": "public static String expandHiddenDir(final String filename){\n  final int macro=filename.indexOf(hiddenDirMacro,0);\n  String expandedFilter;\n  if (macro == -1) {\n    return filename;\n  }\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expanding macro\");\n  }\n  expandedFilter=filename.replaceFirst(\"\\\\$dir\\\\$\",StringUtils.chomp(Path.hidden(),\"/\"));\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expandedFilter: \" + expandedFilter);\n  }\n  return expandedFilter;\n}\n", "docstring": "transforms \" something $ dir $ / other / \" to \" something / path / to / hidden / other / \"", "partition": "test"}
{"idx": "712", "code": "private boolean tryQueueCurrentBuffer(long elapsedWaiting){\n  if (currentBuffer.isEmpty())   return true;\n  if (isOpen && neverPubQueue.size() < neverPubCapacity) {\n    neverPubQueue.add(currentBuffer);\n    totalQueuedRecords.addAndGet(currentBuffer.sizeRecords());\n    totalQueuedBuffers.incrementAndGet();\n    onQueueBufferSuccess(currentBuffer,elapsedWaiting);\n    currentBuffer=new RecordBuffer<>(flow);\n    return true;\n  }\n else   if (elapsedWaiting > 0) {\n    onQueueBufferTimeout(currentBuffer,elapsedWaiting);\n    return false;\n  }\n else   return false;\n}\n", "docstring": "keep private . call only when holding lock .", "partition": "test"}
{"idx": "713", "code": "public void updateValue(final Object value,final boolean isSelected,boolean sync){\n  if (isReadOnly()) {\n    return;\n  }\n  if (GenericFormFactory.isTextForm(formType)) {\n    textString=(String)value;\n    if (textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n  }\n else {\n    textString=(String)value;\n    this.isSelected=isSelected;\n    if (isSelected != lastIsSelected && lastTextString != null && textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n    lastIsSelected=isSelected;\n  }\n  if ((sync && guiType != FormFactory.ULC) && guiComp != null) {\n    syncGUI(value);\n  }\n}\n", "docstring": "allow us to update value ( and sync to gui version if exists", "partition": "test"}
{"idx": "714", "code": "public boolean hasNext() throws IOException {\n  dataInputStream.mark(1);\n  int val=dataInputStream.read();\n  dataInputStream.reset();\n  return val != -1;\n}\n", "docstring": "checks if another objects is available by attempting to read another byte from the stream .", "partition": "test"}
{"idx": "715", "code": "private final StringBuilder appendParameterSignature(StringBuilder buffer,char[][] parameterTypes,char[][] parameterNames){\n  if (parameterTypes != null) {\n    for (int i=0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        buffer.append(',');\n        buffer.append(' ');\n      }\n      buffer.append(parameterTypes[i]);\n      if (parameterNames != null && parameterNames[i] != null) {\n        buffer.append(' ');\n        buffer.append(parameterNames[i]);\n      }\n    }\n  }\n  return buffer;\n}\n", "docstring": "creates a display string of a parameter list ( without the parentheses ) for the given parameter types and names .", "partition": "test"}
{"idx": "716", "code": "public void completeHeartbeat(Database database,long seqno,String eventId) throws SQLException {\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update\");\n  Statement st=null;\n  ResultSet rs=null;\n  Timestamp sts=new Timestamp(0);\n  Timestamp now=new Timestamp(System.currentTimeMillis());\n  ArrayList<Column> whereClause=new ArrayList<Column>();\n  ArrayList<Column> values=new ArrayList<Column>();\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update: \" + now);\n  try {\n    st=database.createStatement();\n    rs=st.executeQuery(sourceTsQuery);\n    if (rs.next())     sts=rs.getTimestamp(1);\n  }\n  finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n    if (st != null) {\n      try {\n        st.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n  }\n  long lag_millis=now.getTime() - sts.getTime();\n  hbId.setValue(KEY);\n  whereClause.add(hbId);\n  hbSeqno.setValue(seqno);\n  hbEventId.setValue(eventId);\n  hbTargetTstamp.setValue(now);\n  hbLagMillis.setValue(lag_millis);\n  values.add(hbSeqno);\n  values.add(hbEventId);\n  values.add(hbTargetTstamp);\n  values.add(hbLagMillis);\n  database.update(hbTable,whereClause,values);\n}\n", "docstring": "execute this call to fill in heartbeat data on the slave . this call must be invoked after a heartbeat event is applied .", "partition": "test"}
{"idx": "717", "code": "public CipherParameters decrypt(byte[] in,int inOff,int inLen,int keyLen) throws IllegalArgumentException {\n  if (!key.isPrivate()) {\n    throw new IllegalArgumentException(\"Private key required for decryption\");\n  }\n  BigInteger n=key.getModulus();\n  BigInteger d=key.getExponent();\n  byte[] C=new byte[inLen];\n  System.arraycopy(in,inOff,C,0,C.length);\n  BigInteger c=new BigInteger(1,C);\n  BigInteger r=c.modPow(d,n);\n  return generateKey(n,r,keyLen);\n}\n", "docstring": "decrypt an encapsulated session key .", "partition": "test"}
{"idx": "718", "code": "public PrivateKey loadPrivateKey() throws Exception {\n  if (defaultKeys) {\n    return getPrivateKeyFromString(RSAKeyLoader.DEFAULT_PKEY);\n  }\n  if (priKey == null) {\n    FileReader f=new FileReader(path + \"privatekey\" + this.id);\n    BufferedReader r=new BufferedReader(f);\n    String tmp=\"\";\n    String key=\"\";\n    while ((tmp=r.readLine()) != null) {\n      key=key + tmp;\n    }\n    f.close();\n    r.close();\n    priKey=getPrivateKeyFromString(key);\n  }\n  return priKey;\n}\n", "docstring": "loads the private key of this process", "partition": "test"}
{"idx": "719", "code": "public void removeCategoriesListener(SnapshotCategoriesListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "removes a listener for changes of registered snapshot categories .", "partition": "test"}
{"idx": "720", "code": "private Integer zGetWeekNumberForASevenDayRange(LocalDate firstDateInRange,WeekFields weekFieldRules,boolean requireUnanimousWeekNumber){\n  ArrayList<Integer> weekNumbersList=new ArrayList<Integer>();\n  for (int daysIntoTheFuture=0; daysIntoTheFuture <= 6; ++daysIntoTheFuture) {\n    LocalDate currentDateInRange;\n    try {\n      currentDateInRange=firstDateInRange.plusDays(daysIntoTheFuture);\n      int currentWeekNumber=currentDateInRange.get(weekFieldRules.weekOfWeekBasedYear());\n      weekNumbersList.add(currentWeekNumber);\n    }\n catch (    Exception ex) {\n      return 1;\n    }\n  }\n  boolean isUnanimous=(InternalUtilities.areObjectsEqual(weekNumbersList.get(0),weekNumbersList.get(6)));\n  if (isUnanimous) {\n    return weekNumbersList.get(0);\n  }\n  if (requireUnanimousWeekNumber) {\n    return null;\n  }\n  int mostCommonWeekNumber=InternalUtilities.getMostCommonElementInList(weekNumbersList);\n  return mostCommonWeekNumber;\n}\n", "docstring": "zgetweeknumberforasevendayrange , this returns a week number for the specified seven day range , according to the supplied weekfieldrules . if all seven days fall on the same week number , then that week number will be returned . if \" requireunanimousweeknumber \" is true and the supplied range falls across two week numbers , then null is returned . if \" requireunanimousweeknumber \" is false and the supplied range falls across two week numbers , then the \" majority rules \" system is used for determining the returned week number . the majority rules system means that the most common week number in the seven day range will be returned . for example : if days 1 and 2 are in week 30 , and days 3 through 7 are in week 31 , then the week number 31 will be returned . there is no possibility of a \" tie \" week number , because the number of days in the range is seven ( an odd number ) . additionally , the returned week number will always be the correct week number for a minimum of four days out of the seven day range . to make sure that all seven days in the range - can - fall on the same week number , the caller of the function would need to supply a seven day range that starts on the same \" first day of the week \" that is used by the supplied weekfieldrules . i don \"'\" t know if there are any special cases where these matching parameters are supplied , but the result is still not a unanimous week number . the week fields object can be created from a specific locale , ( including locale . iso if desired ) , or the week fields can be configured to match any desired week field rules . examples of creating week field instances : weekfields weekfields = weekfields . of ( locale locale ) ; weekfields weekfields = weekfields . of ( dayofweek firstdayofweek , int minimaldaysinfirstweek ) ;", "partition": "test"}
{"idx": "721", "code": "private boolean isNotInArray(String str,String[] array){\n  for (int i=0; i < array.length; i++) {\n    if (str.equals(array[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "returns true iff str is not an element of array .", "partition": "test"}
{"idx": "722", "code": "public void init() throws Exception {\n  loadParameterFromZK();\n  _invalidLoginCleanupExecutor.scheduleWithFixedDelay(new InvalidLoginCleaner(),CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS,CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS,TimeUnit.MINUTES);\n  _log.info(\"Max invalid login attempts from the same client IP: {}\",_maxAuthnLoginAttemtsCount);\n  _log.info(\"Life time in minutes of invalid login records for a client IP: {}\",_maxAuthnLoginAttemtsLifeTimeInMins);\n  _log.info(\"Cleanup thread schedule interval: {} minutes\",CLEANUP_THREAD_SCHEDULE_INTERVAL_IN_MINS);\n}\n", "docstring": "initialize the background task to be run every hour . at each run that task will walk through the invalid login records and clean all expired records .", "partition": "test"}
{"idx": "723", "code": "public List<String> makeURLList(String shard){\n  List<String> urls=StrUtils.splitSmart(shard,\"|\",true);\n  for (int i=0; i < urls.size(); i++) {\n    urls.set(i,buildUrl(urls.get(i)));\n  }\n  if (urls.size() > 1)   Collections.shuffle(urls,r);\n  return urls;\n}\n", "docstring": "creates a randomized list of urls for the given shard .", "partition": "test"}
{"idx": "724", "code": "private byte[] toZLIB(RenderedImage image,Color bkg,String colorModel) throws IOException {\n  return ImageGraphics2D.toByteArray(image,ImageConstants.RAW,ImageConstants.ENCODING_FLATE_ASCII85,ImageGraphics2D.getRAWProperties(bkg,colorModel));\n}\n", "docstring": "creates the zlib bytes for pdf images", "partition": "test"}
{"idx": "725", "code": "public void addVertex(Object id) throws IllegalArgumentException {\n  if (initialized) {\n    throw new IllegalArgumentException();\n  }\n  Vertex vertex=new Vertex(id);\n  Object existing=vertexMap.put(id,vertex);\n  if (existing != null) {\n    throw new IllegalArgumentException();\n  }\n  vertexList.add(vertex);\n}\n", "docstring": "defines a new vertex with the given id . the depth - first search is performed in the relative order in which vertexes were added to the graph .", "partition": "test"}
{"idx": "726", "code": "public void configureLocalServices(){\n  clientMemo.setLnTrafficController(this);\n  clientMemo.configureCommandStation(LnCommandStationType.COMMAND_STATION_DCS100,false,false);\n  clientMemo.configureManagers();\n}\n", "docstring": "set up all of the other objects to operate with a server connected to this application .", "partition": "test"}
{"idx": "727", "code": "private static int indexOf(int fromIndex,CharSequence csq){\n  if (csq == null)   return 0;\n  int length=csq.length();\n  int j=fromIndex;\n  int i=(j < length) ? csq.charAt(j++) : 0;\n  i<<=16;\n  i|=(j < length) ? csq.charAt(j++) : 0;\n  return i;\n}\n", "docstring": "returns the index starting at the specified index ( two characters at a time ) .", "partition": "test"}
{"idx": "728", "code": "protected SizeRequirements calculateMinorAxisRequirements(int axis,SizeRequirements r){\n  updateGrid();\n  calculateColumnRequirements(axis);\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  long min=0;\n  long pref=0;\n  int n=columnRequirements.length;\n  for (int i=0; i < n; i++) {\n    SizeRequirements req=columnRequirements[i];\n    min+=req.minimum;\n    pref+=req.preferred;\n  }\n  int adjust=(n + 1) * cellSpacing + 2 * borderWidth;\n  min+=adjust;\n  pref+=adjust;\n  r.minimum=(int)min;\n  r.preferred=(int)pref;\n  r.maximum=(int)pref;\n  AttributeSet attr=getAttributes();\n  CSS.LengthValue cssWidth=(CSS.LengthValue)attr.getAttribute(CSS.Attribute.WIDTH);\n  if (BlockView.spanSetFromAttributes(axis,r,cssWidth,null)) {\n    if (r.minimum < (int)min) {\n      r.maximum=r.minimum=r.preferred=(int)min;\n    }\n  }\n  totalColumnRequirements.minimum=r.minimum;\n  totalColumnRequirements.preferred=r.preferred;\n  totalColumnRequirements.maximum=r.maximum;\n  Object o=attr.getAttribute(CSS.Attribute.TEXT_ALIGN);\n  if (o != null) {\n    String ta=o.toString();\n    if (ta.equals(\"left\")) {\n      r.alignment=0;\n    }\n else     if (ta.equals(\"center\")) {\n      r.alignment=0.5f;\n    }\n else     if (ta.equals(\"right\")) {\n      r.alignment=1;\n    }\n else {\n      r.alignment=0;\n    }\n  }\n else {\n    r.alignment=0;\n  }\n  return r;\n}\n", "docstring": "calculate the requirements for the minor axis . this is called by the superclass whenever the requirements need to be updated ( i . e . a preferencechanged was messaged through this view ) . < p > this is implemented to calculate the requirements as the sum of the requirements of the columns and then adjust it if the css width or height attribute is specified and applicable to the axis .", "partition": "test"}
{"idx": "729", "code": "public void append(String string){\n  for (int i=0; i < string.length(); i++)   append(string.charAt(i));\n}\n", "docstring": "appends an int ( little endian ) in the buffer", "partition": "test"}
{"idx": "730", "code": "public ListenableFuture<String> push(final String name,final Expression func){\n  String let=String.format(\"let %s = %s\",name,func.toHaskell());\n  return pullRaw(let);\n}\n", "docstring": "uploads a new let binding to ghci", "partition": "test"}
{"idx": "731", "code": "public final String toString(int depth){\n  if (depth <= 0)   return \"\";\n  return (\"\\n*DecimalNode\" + super.toString(depth) + \"Mantissa: \"+ mantissa+ \"; exponent: \"+ exponent+ \"; big value: \"+ (bigVal != null ? bigVal.toString() : \"<null>\")+ \"\\n; image = \"+ image);\n}\n", "docstring": "displays this node as a string , implementing explorenode interface ; depth parameter is a bound on the depth of the portion of the tree that is displayed .", "partition": "test"}
{"idx": "732", "code": "public MetaDataColumnDescriptor(String columnName,int jdbcType,Object defaultValue){\n  _columnName=columnName.toUpperCase();\n  _jdbcType=jdbcType;\n  _defaultValue=defaultValue;\n}\n", "docstring": "creates a new descriptor instance .", "partition": "test"}
{"idx": "733", "code": "private void bulkLoad(double[] lmin,double[] lmax,List<Node> children,ArrayModifiableDBIDs ids,int start,int end,int dim,int level,int code){\n  if (dim == 0) {\n    DBIDArrayIter iter=ids.iter();\n    iter.seek(start);\n    NumberVector first=relation.get(iter);\n    iter.advance();\n    boolean degenerate=true;\n    loop:     for (; iter.getOffset() < end; iter.advance()) {\n      NumberVector other=relation.get(iter);\n      for (int d=0; d < lmin.length; d++) {\n        if (Math.abs(first.doubleValue(d) - other.doubleValue(d)) > 1E-15) {\n          degenerate=false;\n          break loop;\n        }\n      }\n    }\n    if (degenerate) {\n      double[] center=new double[lmin.length];\n      for (int d=0; d < lmin.length; d++) {\n        center[d]=lmin[d] * .5 + lmax[d] * .5 + shift[d];\n        if (center[d] > min[d] + width[d]) {\n          center[d]-=width[d];\n        }\n      }\n      children.add(new Node(code,center,end - start,level,null));\n      return;\n    }\n  }\n  if (dim == lmin.length) {\n    double[] center=new double[lmin.length];\n    for (int d=0; d < lmin.length; d++) {\n      center[d]=lmin[d] * .5 + lmax[d] * .5 + shift[d];\n      if (center[d] > min[d] + width[d]) {\n        center[d]-=width[d];\n      }\n    }\n    if (end - start < nmin) {\n      children.add(new Node(code,center,end - start,level,null));\n      return;\n    }\n else {\n      List<Node> newchildren=new ArrayList<>();\n      bulkLoad(lmin,lmax,newchildren,ids,start,end,0,level + 1,0);\n      children.add(new Node(code,center,end - start,level,newchildren));\n      return;\n    }\n  }\n else {\n    DBIDArrayIter siter=ids.iter(), eiter=ids.iter();\n    siter.seek(start);\n    eiter.seek(end - 1);\n    while (siter.getOffset() < eiter.getOffset()) {\n      if (getShiftedDim(relation.get(siter),dim,level) <= .5) {\n        siter.advance();\n        continue;\n      }\n      if (getShiftedDim(relation.get(eiter),dim,level) > 0.5) {\n        eiter.retract();\n        continue;\n      }\n      ids.swap(siter.getOffset(),eiter.getOffset() - 1);\n      siter.advance();\n      eiter.retract();\n    }\n    final int spos=siter.getOffset();\n    if (start < spos) {\n      final double tmp=lmax[dim];\n      lmax[dim]=lmax[dim] * .5 + lmin[dim] * .5;\n      bulkLoad(lmin,lmax,children,ids,start,spos,dim + 1,level,code);\n      lmax[dim]=tmp;\n    }\n    if (spos < end) {\n      final double tmp=lmin[dim];\n      lmin[dim]=lmax[dim] * .5 + lmin[dim] * .5;\n      bulkLoad(lmin,lmax,children,ids,spos,end,dim + 1,level,code | (1 << dim));\n      lmin[dim]=tmp;\n    }\n  }\n}\n", "docstring": "bulk load the tree", "partition": "test"}
{"idx": "734", "code": "protected ArrayList<float[]> _forwardPoly(float[] rawllpts,int ltype,int nsegs,boolean isFilled){\n  boolean DEBUG=Debug.debugging(\"proj\");\n  int len=rawllpts.length >>> 1;\n  if (len < 2)   return new ArrayList<float[]>(0);\n  if (isComplicatedLineType(ltype))   return doPolyDispatch(rawllpts,ltype,nsegs,isFilled);\n  int invalid_count=0;\n  boolean curr_invalid, prev_invalid=false;\n  Point temp=new Point();\n  AzimuthVar az_first=null, az_save=null, azVar=new AzimuthVar();\n  ArrayList<AzimuthVar> sections=new ArrayList<AzimuthVar>(128);\n  float[] x_, xs=new float[len];\n  float[] y_, ys=new float[len];\n  _forward(rawllpts[0],rawllpts[1],temp,azVar);\n  xs[0]=temp.x;\n  ys[0]=temp.y;\n  prev_invalid=azVar.invalid_forward;\n  if (prev_invalid) {\n    ++invalid_count;\n  }\n else {\n    azVar.index=0;\n    azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[0],rawllpts[1]);\n    if (!isFilled) {\n      sections.add(azVar);\n    }\n else {\n      az_first=azVar;\n    }\n    azVar=new AzimuthVar();\n  }\n  int i=0, j=0;\n  for (i=1, j=2; i < len; i++, j+=2) {\n    azVar.invalid_forward=false;\n    _forward(rawllpts[j],rawllpts[j + 1],temp,azVar);\n    curr_invalid=azVar.invalid_forward;\n    xs[i]=temp.x;\n    ys[i]=temp.y;\n    if (!curr_invalid && prev_invalid) {\n      azVar.index=i - 1;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n      azVar=new AzimuthVar();\n    }\n else     if (curr_invalid) {\n      if (!prev_invalid) {\n        azVar.index=i;\n        if (isFilled && (invalid_count == 0)) {\n          az_save=azVar;\n        }\n else {\n          sections.add(azVar);\n        }\n        azVar=new AzimuthVar();\n      }\n      ++invalid_count;\n    }\n    prev_invalid=curr_invalid;\n  }\n  if (invalid_count == 0) {\n    ArrayList<float[]> ret_val=new ArrayList<float[]>(2);\n    ret_val.add(xs);\n    ret_val.add(ys);\n    return ret_val;\n  }\n  if (invalid_count == len) {\n    return new ArrayList<float[]>(0);\n  }\n  if (!prev_invalid) {\n    if (isFilled && (az_save != null)) {\n      int l=az_save.index;\n      x_=new float[len + l];\n      y_=new float[len + l];\n      System.arraycopy(xs,0,x_,0,len);\n      System.arraycopy(ys,0,y_,0,len);\n      System.arraycopy(xs,0,x_,len,l);\n      System.arraycopy(ys,0,y_,len,l);\n      az_save.index=len + l;\n      sections.add(az_save);\n      xs=x_;\n      ys=y_;\n    }\n else {\n      if (DEBUG && isFilled && (az_save == null)) {\n        Debug.output(\"AA, filled, no-wrap!\");\n      }\n      azVar.index=i;\n      j=rawllpts.length;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n    }\n  }\n else   if (az_save != null) {\n    if (DEBUG)     Debug.output(\"DD, filled!\");\n    sections.add(az_first);\n    sections.add(az_save);\n  }\n  int size=sections.size();\n  ArrayList<float[]> ret_val=new ArrayList<float[]>(size);\n  if (isFilled && (len > 2)) {\n    generateFilledPoly(xs,ys,sections,ret_val);\n    return ret_val;\n  }\n  for (j=0; j < size; j+=2) {\n    AzimuthVar az1=(AzimuthVar)sections.get(j);\n    AzimuthVar az2=(AzimuthVar)sections.get(j + 1);\n    int off1=az1.index;\n    int off2=az2.index;\n    int l=off2 - off1;\n    x_=new float[l];\n    y_=new float[l];\n    System.arraycopy(xs,off1,x_,0,l);\n    System.arraycopy(ys,off1,y_,0,l);\n    ret_val.add(x_);\n    ret_val.add(y_);\n  }\n  return ret_val;\n}\n", "docstring": "forward project a lat / lon poly . this is a complex method . please read the in - code documentation for an explanation of the algorithm .", "partition": "test"}
{"idx": "735", "code": "public DataProviderEvent(final LocalizableMessage reason,final Set<Type> types){\n  Reject.ifNull(reason,types);\n  Reject.ifTrue(types.isEmpty());\n  this.reason=reason;\n  final EnumSet<Type> tmp=EnumSet.noneOf(Type.class);\n  tmp.addAll(types);\n  this.types=Collections.unmodifiableSet(tmp);\n}\n", "docstring": "creates a new data provider event .", "partition": "test"}
{"idx": "736", "code": "public <T>List<String> validateBean(T bean,String errIfBeanNull){\n  List<String> errors=new ArrayList<String>();\n  if (bean == null) {\n    errors.add(errIfBeanNull);\n    return errors;\n  }\n  Set<ConstraintViolation<T>> violations=validator.validate(bean);\n  for (  ConstraintViolation<T> violation : violations) {\n    errors.add(violation.getMessage());\n  }\n  return errors;\n}\n", "docstring": "validate the bean is not null ; then validate its fields", "partition": "test"}
{"idx": "737", "code": "protected void smartInsertAfterBracket(IDocument document,DocumentCommand command){\n  if (command.offset == -1 || document.getLength() == 0) {\n    return;\n  }\n  try {\n    int p=(command.offset == document.getLength() ? command.offset - 1 : command.offset);\n    int line=document.getLineOfOffset(p);\n    int start=document.getLineOffset(line);\n    int whiteend=findEndOfWhiteSpace(document,start,command.offset);\n    if (whiteend == command.offset) {\n      int indLine=findMatchingOpenBracket(document,line,command.offset,1);\n      if (indLine != -1 && indLine != line) {\n        StringBuffer replaceText=new StringBuffer(getIndentOfLine(document,indLine));\n        replaceText.append(document.get(whiteend,command.offset - whiteend));\n        replaceText.append(command.text);\n        command.length=command.offset - start;\n        command.offset=start;\n        command.text=replaceText.toString();\n      }\n    }\n  }\n catch (  BadLocationException e) {\n    GWTPluginLog.logError(e);\n  }\n}\n", "docstring": "set the indent of a bracket based on the command provided in the supplied document .", "partition": "test"}
{"idx": "738", "code": "private String attemptToChooseFormattingPattern(){\n  if (nationalNumber.length() >= MIN_LEADING_DIGITS_LENGTH) {\n    getAvailableFormats(nationalNumber.toString());\n    String formattedNumber=attemptToFormatAccruedDigits();\n    if (formattedNumber.length() > 0) {\n      return formattedNumber;\n    }\n    return maybeCreateNewTemplate() ? inputAccruedNationalNumber() : accruedInput.toString();\n  }\n else {\n    return appendNationalNumber(nationalNumber.toString());\n  }\n}\n", "docstring": "attempts to set the formatting template and returns a string which contains the formatted version of the digits entered so far .", "partition": "test"}
{"idx": "739", "code": "private void fillPicks() throws Exception {\n  MLookup orgL=MLookupFactory.get(Env.getCtx(),m_WindowNo,0,2223,DisplayType.TableDir);\n  fWarehouse=new VLookup(\"M_Warehouse_ID\",true,false,true,orgL);\n  lWarehouse.setText(Msg.translate(Env.getCtx(),\"M_Warehouse_ID\"));\n  fWarehouse.addVetoableChangeListener(this);\n  m_M_Warehouse_ID=fWarehouse.getValue();\n  MLookup bpL=MLookupFactory.get(Env.getCtx(),m_WindowNo,0,2762,DisplayType.Search);\n  fBPartner=new VLookup(\"C_BPartner_ID\",false,false,true,bpL);\n  lBPartner.setText(Msg.translate(Env.getCtx(),\"C_BPartner_ID\"));\n  fBPartner.addVetoableChangeListener(this);\n  lDocType.setText(Msg.translate(Env.getCtx(),\"C_DocType_ID\"));\n  cmbDocType.addItem(new KeyNamePair(MOrder.Table_ID,Msg.translate(Env.getCtx(),\"Order\")));\n  cmbDocType.addItem(new KeyNamePair(MRMA.Table_ID,Msg.translate(Env.getCtx(),\"VendorRMA\")));\n  cmbDocType.addActionListener(this);\n}\n", "docstring": "fill picks . column_id from c_order", "partition": "test"}
{"idx": "740", "code": "@Override protected FieldConfigBase createCopy(FieldConfigBase fieldConfigBase){\n  FieldConfigFontPreview copy=null;\n  if (fieldConfigBase != null) {\n    copy=new FieldConfigFontPreview(fieldConfigBase.getCommonData());\n  }\n  return copy;\n}\n", "docstring": "creates a copy of the field .", "partition": "test"}
{"idx": "741", "code": "private void printAnnotationFromEditor(final WorkflowAnnotation anno,final Graphics2D g2){\n  Graphics2D gPr=(Graphics2D)g2.create();\n  Rectangle2D loc=anno.getLocation();\n  gPr.translate(loc.getX(),loc.getY());\n  gPr.setClip(0,0,(int)loc.getWidth(),(int)loc.getHeight());\n  Dimension size=new Dimension((int)loc.getWidth(),(int)loc.getHeight());\n  pane.setSize(size);\n  pane.setText(AnnotationDrawUtils.createStyledCommentString(anno));\n  pane.setCaretPosition(0);\n  pane.paint(gPr);\n  gPr.dispose();\n}\n", "docstring": "bypass the cache and the speedy image drawing and directly paint the jeditorpane to the context . required for printing in svg format which would turn out pixelated if it were drawn as an image .", "partition": "test"}
{"idx": "742", "code": "public void add(IPoint pt){\n  if (inProgress) {\n    throw new ConcurrentModificationException(\"Can\'t add point while iterator in progress\");\n  }\n  points.add(pt);\n}\n", "docstring": "add point to the result set .", "partition": "test"}
{"idx": "743", "code": "public static Configuration load(Reader reader) throws IOException {\n  try {\n    Properties properties=new Properties();\n    properties.load(reader);\n    return from(properties);\n  }\n  finally {\n    reader.close();\n  }\n}\n", "docstring": "obtain a configuration instance by loading the properties from the supplied reader .", "partition": "test"}
{"idx": "744", "code": "public void add(OffsettedItem item){\n  throwIfPrepared();\n  try {\n    if (item.getAlignment() > getAlignment()) {\n      throw new IllegalArgumentException(\"incompatible item alignment\");\n    }\n  }\n catch (  NullPointerException ex) {\n    throw new NullPointerException(\"item == null\");\n  }\n  items.add(item);\n}\n", "docstring": "adds an item to this instance . this will in turn tell the given item that it has been added to this instance . it is invalid to add the same item to more than one instance , nor to add the same items multiple times to a single instance .", "partition": "test"}
{"idx": "745", "code": "public static void addAnnotationToXML(Element annotationsElement,String name,String value){\n  if (value == null) {\n    deleteAnnotationFromXML(annotationsElement,name);\n  }\n else {\n    final Document doc=annotationsElement.getOwnerDocument();\n    Element elem=doc.createElement(\"annotation\");\n    annotationsElement.appendChild(elem);\n    elem.setAttribute(\"key\",name);\n    elem.setTextContent(value);\n  }\n}\n", "docstring": "updates the xml representation to contain this annotation .", "partition": "test"}
{"idx": "746", "code": "public boolean readBoolean() throws IOException {\n  return primitiveTypes.readBoolean();\n}\n", "docstring": "reads a boolean from the source stream .", "partition": "test"}
{"idx": "747", "code": "public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumIterations\");\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration of the additional measure names", "partition": "test"}
{"idx": "748", "code": "@Override public Instances defineDataFormat() throws Exception {\n  ArrayList<Attribute> atts;\n  ArrayList<String> attValues;\n  int i;\n  m_Random=new Random(getSeed());\n  m_nextClassShouldBeZero=true;\n  m_lastLabel=Double.NaN;\n  setNumExamplesAct(getNumExamples());\n  atts=new ArrayList<Attribute>();\n  atts.add(new Attribute(\"salary\"));\n  atts.add(new Attribute(\"commission\"));\n  atts.add(new Attribute(\"age\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 5; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"elevel\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=1; i <= 20; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"car\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 9; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"zipcode\",attValues));\n  atts.add(new Attribute(\"hvalue\"));\n  atts.add(new Attribute(\"hyears\"));\n  atts.add(new Attribute(\"loan\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 2; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"group\",attValues));\n  m_DatasetFormat=new Instances(getRelationNameToUse(),atts,0);\n  return m_DatasetFormat;\n}\n", "docstring": "initializes the format for the dataset produced . must be called before the generateexample or generateexamples methods are used . re - initializes the random number generator with the given seed .", "partition": "test"}
{"idx": "749", "code": "public static double lnGamma(double alpha){\n  double x=alpha, f=0.0, z;\n  if (x < 7) {\n    f=1;\n    z=x - 1;\n    while (++z < 7) {\n      f*=z;\n    }\n    x=z;\n    f=-Math.log(f);\n  }\n  z=1 / (x * x);\n  return f + (x - 0.5) * Math.log(x) - x + 0.918938533204673 + (((-0.000595238095238 * z + 0.000793650793651) * z - 0.002777777777778) * z + 0.083333333333333) / x;\n}\n", "docstring": "log gamma function : ln ( gamma ( alpha ) ) for alpha > 0 , accurate to 10 decimal places", "partition": "test"}
{"idx": "750", "code": "public void startTicker(long delay,boolean rightToLeft){\n  if (!tickerEnabled) {\n    return;\n  }\n  if (!isCellRenderer()) {\n    Form parent=getComponentForm();\n    if (parent != null) {\n      parent.registerAnimatedInternal(this);\n    }\n  }\n  tickerStartTime=System.currentTimeMillis();\n  tickerDelay=delay;\n  tickerRunning=true;\n  this.rightToLeft=rightToLeft;\n  if (isRTL()) {\n    this.rightToLeft=!this.rightToLeft;\n  }\n}\n", "docstring": "this method will start the text ticker", "partition": "test"}
{"idx": "751", "code": "static CipherSuite valueOf(int id1,int id2){\n  id1&=0xff;\n  id2&=0xff;\n  int id=(id1 << 8) | id2;\n  CipherSuite c=idMap.get(id);\n  if (c == null) {\n    String h1=Integer.toString(id1,16);\n    String h2=Integer.toString(id2,16);\n    c=new CipherSuite(\"Unknown 0x\" + h1 + \":0x\"+ h2,id);\n  }\n  return c;\n}\n", "docstring": "return a ciphersuite with the given id . a temporary object is constructed if the id is unknown . use isavailable ( ) to verify that the ciphersuite can actually be used .", "partition": "test"}
{"idx": "752", "code": "public static Context createPendingActionContext(Context context,ReconAction action,String mappingName,JsonValue sourceObject,String reconId,Situation situation){\n  Map<String,Object> pendingActionMap=new HashMap<String,Object>();\n  pendingActionMap.put(MAPPING_NAME,mappingName);\n  pendingActionMap.put(SOURCE_OBJECT,sourceObject);\n  pendingActionMap.put(RECON_ID,reconId);\n  pendingActionMap.put(ORIGINAL_SITUATION,situation.toString());\n  PendingActionContext pendingActionContext=new PendingActionContext(context,pendingActionMap,action.toString());\n  return pendingActionContext;\n}\n", "docstring": "creates and populates a pendingactioncontext .", "partition": "test"}
{"idx": "753", "code": "public void showDroidsafeTextMarkers(IEditorPart openedEditor,String className){\n  if (openedEditor != null && openedEditor instanceof ITextEditor && fProcessedClasses != null) {\n    ITextEditor editor=(ITextEditor)openedEditor;\n    if (fProcessedClasses.contains(className)) {\n      if (fClassesNeedUpdate.contains(className)) {\n        ClassMarkerProcessor classProcessor=get(className);\n        classProcessor.updateTaintMarkers(editor);\n        fClassesNeedUpdate.remove(className);\n      }\n    }\n else {\n      fProcessedClasses.add(className);\n      Map<String,Map<IntRange,Map<String,Set<CallLocationModel>>>> classTaintedDataMap=fTaintedDataMap.get(className);\n      Map<String,Set<IntRange>> classUnreachableMethodMap=fUnreachableSourceMethodMap.get(className);\n      if (classTaintedDataMap != null || classUnreachableMethodMap != null) {\n        IEditorInput input=editor.getEditorInput();\n        if (input instanceof FileEditorInput) {\n          ClassMarkerProcessor classProcessor=get(className);\n          classProcessor.showDroidsafeTextMarkers(editor);\n        }\n      }\n    }\n  }\n}\n", "docstring": "displays the annotations of the droidsafe text markers for the given class name in the given java editor .", "partition": "test"}
{"idx": "754", "code": "private static void resolveNewExpression(NewExpression objSubjectExpression,HashSet<String> objTypesSet){\n  ClassReference objClassRef=objSubjectExpression.getClassReference();\n  if (null == objClassRef || null == objClassRef.getFQN()) {\n    objTypesSet.add(Types.strResolvingAbortedOnPsiLevel);\n    return;\n  }\n  objTypesSet.add(objClassRef.getFQN());\n}\n", "docstring": "will resolve type of new expression", "partition": "test"}
{"idx": "755", "code": "private static List<Size> pickUpToThree(List<Size> sizes){\n  List<Size> result=new ArrayList<Size>();\n  Size largest=sizes.get(0);\n  result.add(largest);\n  Size lastSize=largest;\n  for (  Size size : sizes) {\n    double targetArea=Math.pow(.5,result.size()) * area(largest);\n    if (area(size) < targetArea) {\n      if (!result.contains(lastSize) && (targetArea - area(lastSize) < area(size) - targetArea)) {\n        result.add(lastSize);\n      }\n else {\n        result.add(size);\n      }\n    }\n    lastSize=size;\n    if (result.size() == 3) {\n      break;\n    }\n  }\n  if (result.size() < 3 && !result.contains(lastSize)) {\n    result.add(lastSize);\n  }\n  return result;\n}\n", "docstring": "given a list of sizes of a similar aspect ratio , it tries to pick evenly spaced out options . it starts with the largest , then tries to find one at 50 % of the last chosen size for the subsequent size .", "partition": "test"}
{"idx": "756", "code": "public static void copyToClipboard(Transferable t){\n  ClipboardHelper.copyToClipboard(t);\n}\n", "docstring": "copies the given transferable to the system \"'\" s clipboard .", "partition": "test"}
{"idx": "757", "code": "public static String formatPercent(int downloadSize,int fileSize){\n  float num=(float)downloadSize / fileSize;\n  float percent=((float)(int)(num * 1000)) / 10;\n  return String.valueOf(percent + \"%\");\n}\n", "docstring": "format the download percent", "partition": "test"}
{"idx": "758", "code": "final private String attrDef2AttrDesc(Attributes attrs) throws NamingException {\n  StringBuffer attrDesc=new StringBuffer(\"( \");\n  Attribute attr=null;\n  int count=0;\n  attr=attrs.get(NUMERICOID_ID);\n  if (attr != null) {\n    attrDesc.append(writeNumericOID(attr));\n    count++;\n  }\n else {\n    throw new ConfigurationException(\"Attribute type doesn\'t\" + \"have a numeric OID\");\n  }\n  attr=attrs.get(NAME_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDescrs(attr));\n    count++;\n  }\n  attr=attrs.get(DESC_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  attr=attrs.get(OBSOLETE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(SUP_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(EQUALITY_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(ORDERING_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SUBSTR_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SYNTAX_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SINGLE_VAL_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(COLLECTIVE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(NO_USER_MOD_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(USAGE_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  if (count < attrs.size()) {\n    String attrId=null;\n    for (NamingEnumeration<? extends Attribute> ae=attrs.getAll(); ae.hasMoreElements(); ) {\n      attr=ae.next();\n      attrId=attr.getID();\n      if (attrId.equals(NUMERICOID_ID) || attrId.equals(NAME_ID) || attrId.equals(SYNTAX_ID)|| attrId.equals(DESC_ID)|| attrId.equals(SINGLE_VAL_ID)|| attrId.equals(EQUALITY_ID)|| attrId.equals(ORDERING_ID)|| attrId.equals(SUBSTR_ID)|| attrId.equals(NO_USER_MOD_ID)|| attrId.equals(USAGE_ID)|| attrId.equals(SUP_ID)|| attrId.equals(COLLECTIVE_ID)|| attrId.equals(OBSOLETE_ID)) {\n        continue;\n      }\n else {\n        attrDesc.append(writeQDStrings(attr));\n      }\n    }\n  }\n  attrDesc.append(\")\");\n  return attrDesc.toString();\n}\n", "docstring": "translate attributes that describe an attribute definition into the string description as defined in rfc 2252 .", "partition": "test"}
{"idx": "759", "code": "public static <T>Collection<T> makeImmutable(Collection<T> mutableCollection){\n  Collection<T> newCollection;\n  try {\n    @SuppressWarnings(\"unchecked\") Class<Collection<T>> cls=(Class<Collection<T>>)mutableCollection.getClass();\n    newCollection=cls.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n  for (  T element : mutableCollection) {\n    newCollection.add(Utils.makeImmutable(element));\n  }\n  return Collections.unmodifiableCollection(newCollection);\n}\n", "docstring": "a recursive call to make a collection and all it \"'\" s values immutable .", "partition": "test"}
{"idx": "760", "code": "public synchronized void trackHexImages(IHex hex,MediaTracker tracker){\n  Image base=hexToImageCache.get(hex);\n  List<Image> superImgs=hexToImageListCache.get(hex);\n  List<Image> orthoImgs=orthoListCache.get(hex);\n  tracker.addImage(base,1);\n  if (superImgs != null) {\n    for (Iterator<Image> i=superImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n  if (orthoImgs != null) {\n    for (Iterator<Image> i=orthoImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n}\n", "docstring": "adds all images associated with the hex to the specified tracker", "partition": "test"}
{"idx": "761", "code": "public static Date parseText(String dateStr){\n  try {\n    return mSimpleTextFormat.parse(dateStr);\n  }\n catch (  ParseException e) {\n    e.printStackTrace();\n    throw new RuntimeException(\"date formatDateTime error\");\n  }\n}\n", "docstring": "parse string to datetime", "partition": "test"}
{"idx": "762", "code": "public boolean isProcessed(Trace trace,Node node,Direction direction){\n  boolean ret=false;\n  if (processor.getNodeType() == node.getType() && processor.getDirection() == direction) {\n    if (uriFilter == null || uriFilter.test(node.getUri())) {\n      ret=true;\n    }\n  }\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(\"ProcessManager/Processor: isProcessed trace=\" + trace + \" node=\"+ node+ \" direction=\"+ direction+ \"? \"+ ret);\n  }\n  return ret;\n}\n", "docstring": "this method checks that this processor matches the supplied business txn name and node details .", "partition": "test"}
{"idx": "763", "code": "@Override public synchronized void powerOnSelfTest() throws Error {\n  for (Iterator<WaveformSynthesizer> it=waveformSynthesizers.iterator(); it.hasNext(); ) {\n    WaveformSynthesizer ws=it.next();\n    ws.powerOnSelfTest();\n  }\n}\n", "docstring": "perform a power - on self test by processing some example input data .", "partition": "test"}
{"idx": "764", "code": "private QuadEdge[] fetchTriangleToVisit(QuadEdge edge,Stack edgeStack,boolean includeFrame,Set visitedEdges){\n  QuadEdge curr=edge;\n  int edgeCount=0;\n  boolean isFrame=false;\n  do {\n    triEdges[edgeCount]=curr;\n    if (isFrameEdge(curr))     isFrame=true;\n    QuadEdge sym=curr.sym();\n    if (!visitedEdges.contains(sym))     edgeStack.push(sym);\n    visitedEdges.add(curr);\n    edgeCount++;\n    curr=curr.lNext();\n  }\n while (curr != edge);\n  if (isFrame && !includeFrame)   return null;\n  return triEdges;\n}\n", "docstring": "stores the edges for a visited triangle . also pushes sym ( neighbour ) edges on stack to visit later .", "partition": "test"}
{"idx": "765", "code": "public void deleteEntityConfig(String realm,String federationId) throws WSFederationMetaException {\n  if (federationId == null) {\n    return;\n  }\n  if (realm == null) {\n    realm=\"/\";\n  }\n  String[] objs={federationId,realm};\n  try {\n    Map oldAttrs=configInst.getConfiguration(realm,federationId);\n    Set oldValues=(Set)oldAttrs.get(ATTR_ENTITY_CONFIG);\n    if (oldValues == null || oldValues.isEmpty()) {\n      LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_DESCRIPTOR_DELETE_ENTITY_CONFIG,objs,null);\n      throw new WSFederationMetaException(\"entity_config_not_exist\",objs);\n    }\n    IDPSSOConfigElement idpconfig=getIDPSSOConfig(realm,federationId);\n    if (idpconfig != null) {\n      removeFromCircleOfTrust(idpconfig,realm,federationId);\n    }\n    SPSSOConfigElement spconfig=getSPSSOConfig(realm,federationId);\n    if (spconfig != null) {\n      removeFromCircleOfTrust(spconfig,realm,federationId);\n    }\n    Set attr=new HashSet();\n    attr.add(ATTR_ENTITY_CONFIG);\n    configInst.deleteConfiguration(realm,federationId,attr);\n    LogUtil.access(Level.INFO,LogUtil.ENTITY_CONFIG_DELETED,objs,null);\n    WSFederationMetaCache.putEntityConfig(realm,federationId,null);\n  }\n catch (  ConfigurationException e) {\n    debug.error(\"WSFederationMetaManager.deleteEntityConfig:\",e);\n    String[] data={e.getMessage(),federationId,realm};\n    LogUtil.error(Level.INFO,LogUtil.CONFIG_ERROR_DELETE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(e);\n  }\n}\n", "docstring": "deletes the extended entity configuration under the realm .", "partition": "test"}
{"idx": "766", "code": "public static synchronized DataSourceViewsManager sharedInstance(){\n  if (sharedInstance == null)   sharedInstance=new DataSourceViewsManager();\n  return sharedInstance;\n}\n", "docstring": "returns singleton instance of datasourceviewsmanager .", "partition": "test"}
{"idx": "767", "code": "public String tag(String inner,String c1,String c2){\n  boolean color=((attr & ATTR_COLOR) == ATTR_COLOR) && ToastBootstrap.color;\n  String s=\"[\";\n  if (color)   s+=\"<\" + c1 + \">\";\n  s+=inner;\n  if (color)   s+=\"<\" + c2 + \">\";\n  s+=\"] \";\n  if (color)   s+=\"<\" + c1 + \">\";\n  return color ? Pretty.format(s) : s;\n}\n", "docstring": "return a tag , maybe formatted with color", "partition": "test"}
{"idx": "768", "code": "private final String loadXmlDefinition(){\n  final Cache cache=CacheFactory.getAnyInstance();\n  final StringWriter stringWriter=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(stringWriter);\n  CacheXmlGenerator.generate(cache,printWriter,true,false,false);\n  printWriter.close();\n  return loadXmlDefinition(stringWriter.toString());\n}\n", "docstring": "use the cachexmlgenerator to create xml from the entity associated with the current cache .", "partition": "test"}
{"idx": "769", "code": "private Long id(HttpServletRequest request){\n  Long id=null;\n  String pathInfo=request.getPathInfo();\n  if (pathInfo != null && pathInfo.length() > 1) {\n    String idString=pathInfo.substring(1);\n    id=Long.valueOf(idString);\n  }\n  return id;\n}\n", "docstring": "extract id from the http request .", "partition": "test"}
{"idx": "770", "code": "public void uncompress(){\n  data.position(0);\n  InflaterInputStream inflater=new InflaterInputStream(data.asInputStream());\n  byte[] buffer=new byte[8192];\n  IoBuffer tmp=IoBuffer.allocate(0);\n  tmp.setAutoExpand(true);\n  try {\n    while (inflater.available() > 0) {\n      int decompressed=inflater.read(buffer);\n      if (decompressed <= 0) {\n        break;\n      }\n      tmp.put(buffer,0,decompressed);\n    }\n  }\n catch (  IOException e) {\n    tmp.free();\n    throw new RuntimeException(\"could not uncompress data\",e);\n  }\n finally {\n    if (inflater != null) {\n      try {\n        inflater.close();\n      }\n catch (      IOException e1) {\n      }\n    }\n  }\n  data.free();\n  data=tmp;\n  data.flip();\n  prepareIO();\n}\n", "docstring": "decompress contents using zlib .", "partition": "test"}
{"idx": "771", "code": "public void poll(final TcpSocketStatisticsHandler handler){\n  this.statisticsHandler=handler;\n  try {\n    fileLoader.load();\n    final ByteBuffer buffer=fileLoader.getBuffer();\n    lineParser.reset();\n    lineParser.handleToken(buffer,buffer.position(),buffer.limit());\n  }\n  finally {\n    this.statisticsHandler=null;\n  }\n  monitoredSockets.purgeEntriesOlderThan(updateCount);\n  updateCount++;\n}\n", "docstring": "read from monitored file , report any changed values for monitored socket statistics . not thread - safe , only call from a single thread .", "partition": "test"}
{"idx": "772", "code": "public int compareTo(CharBuffer otherBuffer){\n  int compareRemaining=(remaining() < otherBuffer.remaining()) ? remaining() : otherBuffer.remaining();\n  int thisPos=position;\n  int otherPos=otherBuffer.position;\n  char thisByte, otherByte;\n  while (compareRemaining > 0) {\n    thisByte=get(thisPos);\n    otherByte=otherBuffer.get(otherPos);\n    if (thisByte != otherByte) {\n      return thisByte < otherByte ? -1 : 1;\n    }\n    thisPos++;\n    otherPos++;\n    compareRemaining--;\n  }\n  return remaining() - otherBuffer.remaining();\n}\n", "docstring": "compare the remaining chars of this buffer to another char buffer \"'\" s remaining chars .", "partition": "test"}
{"idx": "773", "code": "public UrbanSimZoneCSVWriterV2(String matsim4opusTempDirectory,String matsimOutputDirectory){\n  this.matsim4opusTempDirectory=matsim4opusTempDirectory;\n  this.matsimOutputDirectory=matsimOutputDirectory;\n  try {\n    log.info(\"Initializing UrbanSimZoneCSVWriterV2 ...\");\n    zoneWriter=IOUtils.getBufferedWriter(matsim4opusTempDirectory + FILE_NAME);\n    log.info(\"Writing data into \" + matsim4opusTempDirectory + FILE_NAME+ \" ...\");\n    zoneWriter.write(Labels.ZONE_ID + \",\" + Labels.ACCESSIBILITY_BY_FREESPEED+ \",\"+ Labels.ACCESSIBILITY_BY_CAR+ \",\"+ Labels.ACCESSIBILITY_BY_BIKE+ \",\"+ Labels.ACCESSIBILITY_BY_WALK+ \",\"+ Labels.ACCESSIBILITY_BY_PT);\n    zoneWriter.newLine();\n    log.info(\"... done!\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "writes the header for zones csv file", "partition": "test"}
{"idx": "774", "code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    ByteBuffer buffer=ByteBuffer.wrap((byte[])newVal);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      aggVal+=buffer.getLong();\n      count+=buffer.getDouble();\n      firstTime=false;\n    }\n    return;\n  }\n  aggVal+=(Long)newVal;\n  count++;\n  firstTime=false;\n}\n", "docstring": "average aggregate function which will add all the aggregate values and it will increment the total count every time , for average value", "partition": "test"}
{"idx": "775", "code": "private static PolicyNotification extractPolicyNotification(String xml) throws PolicyEvaluationException {\n  PolicyNotification policyNotification=null;\n  try {\n    String notificationDataBlock=getNotificationDataBlock(xml);\n    if (notificationDataBlock != null) {\n      Document doc=XMLUtils.getXMLDocument(new ByteArrayInputStream(notificationDataBlock.getBytes()));\n      Node rootNode=XMLUtils.getRootNode(doc,NODE_POLICY_SERVICE);\n      if (rootNode != null) {\n        Node notificationNode=XMLUtils.getChildNode(rootNode,NODE_POLICY_NOTIFICATION);\n        if (notificationNode != null) {\n          policyNotification=PolicyNotification.parseXML(notificationNode);\n        }\n else {\n          debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\" + \"cannot find notification node\");\n          throw new PolicyEvaluationException(ResBundleUtils.rbName,\"invalid_root_element\",null,null);\n        }\n      }\n else {\n        debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\");\n      }\n    }\n else {\n      debug.error(\"ResultsCacheUtil:\" + \"extractPolicyNotification():\" + \"notification data block is null\");\n    }\n  }\n catch (  Exception xe) {\n    debug.error(\"ResultsCacheUtil.extractPolicyNotification():\",xe);\n    throw new PolicyEvaluationException(ResBundleUtils.rbName,\"xml_parsing_error\",null,xe);\n  }\n  return policyNotification;\n}\n", "docstring": "returns the notification xml node", "partition": "test"}
{"idx": "776", "code": "private Object findParcel(@NonNull byte[] objectArray,@NonNull String className){\n  try {\n    Class classTmp=getClassForName(className);\n    Constructor declaredConstructor=classTmp.getDeclaredConstructor(Parcel.class);\n    declaredConstructor.setAccessible(true);\n    return declaredConstructor.newInstance(WearBusTools.byteToParcel(objectArray));\n  }\n catch (  Exception e) {\n    Log.d(WearBusTools.BUSWEAR_TAG,\"syncEvent error: \" + e.getMessage());\n  }\n  return null;\n}\n", "docstring": "attempts to locate the class specified by classname to instantiate with the given objectarray", "partition": "test"}
{"idx": "777", "code": "private static final String decodeFieldName(final String pXmlFieldName){\n  StringBuilder str=new StringBuilder();\n  int fieldNameLength=pXmlFieldName.length();\n  char currentChar;\n  for (int i=0; i < fieldNameLength; i++) {\n    currentChar=pXmlFieldName.charAt(i);\n    if (currentChar == '-') {\n      str.append(Character.toUpperCase(pXmlFieldName.charAt(++i)));\n    }\n else {\n      str.append(currentChar);\n    }\n  }\n  return str.toString();\n}\n", "docstring": "decodes a field name from xml notation ( e . g . my - field - name ) to a valid java field name ( e . g . myfieldname )", "partition": "test"}
{"idx": "778", "code": "public boolean isLoginSet(){\n  return (username != null && (password != null && !username.equals(\"\") && !password.equals(\"\"))) || oauth;\n}\n", "docstring": "return true if either login / pass is set or if oauth is enabled", "partition": "test"}
{"idx": "779", "code": "public void addContentItem(ContentItem contentItem){\n  if (contentItems == null) {\n    contentItems=new ArrayList<ContentItem>();\n  }\n  contentItems.add(contentItem);\n}\n", "docstring": "adds a content item .", "partition": "test"}
{"idx": "780", "code": "public static String canonicalizeClassName(String name){\n  String classname=name.replace(\'/\',\'.\');\n  classname=classname.replace(\'\\\\\',\'.\');\n  if (classname.startsWith(\"class \"))   classname=classname.substring(6);\n  if (classname.endsWith(\".class\"))   classname=classname.substring(0,classname.length() - 6);\n  return classname;\n}\n", "docstring": "create a proper class name from a messy thing . turn / or \\ into . , remove leading class and trailing . class note : this makes lots of strings . . . could be faster .", "partition": "test"}
{"idx": "781", "code": "public static final void pause(final int milliseconds){\n  if (milliseconds >= 1000 || logger.isDebugEnabled()) {\n    logger.info(\"Pausing for {} ms...\",milliseconds);\n  }\n  final long target=System.currentTimeMillis() + milliseconds;\n  try {\n    for (; ; ) {\n      long msLeft=target - System.currentTimeMillis();\n      if (msLeft <= 0) {\n        break;\n      }\n      Thread.sleep(msLeft);\n    }\n  }\n catch (  InterruptedException e) {\n    Assert.fail(\"interrupted\",e);\n  }\n}\n", "docstring": "pause for the specified milliseconds . make sure system clock has advanced by the specified number of millis before returning .", "partition": "test"}
{"idx": "782", "code": "public boolean isHighlightWithInvisibleEdge(){\n  return highlightWithInvisibleEdge;\n}\n", "docstring": "indicates if neighbor nodes with edges currently not visible still get highlighted .", "partition": "test"}
{"idx": "783", "code": "private Configuration prepareJobForCancelling() throws Exception {\n  prepareFile(\"/testFile\",1500);\n  executedTasks.set(0);\n  cancelledTasks.set(0);\n  failMapperId.set(0);\n  splitsCount.set(0);\n  Configuration cfg=new Configuration();\n  setupFileSystems(cfg);\n  Job job=Job.getInstance(cfg);\n  job.setOutputKeyClass(Text.class);\n  job.setOutputValueClass(IntWritable.class);\n  job.setMapperClass(CancellingTestMapper.class);\n  job.setNumReduceTasks(0);\n  job.setInputFormatClass(InFormat.class);\n  FileInputFormat.setInputPaths(job,new Path(\"igfs://:\" + getTestGridName(0) + \"@/\"));\n  FileOutputFormat.setOutputPath(job,new Path(\"igfs://:\" + getTestGridName(0) + \"@/output/\"));\n  job.setJarByClass(getClass());\n  return job.getConfiguration();\n}\n", "docstring": "prepare job with mappers to cancel .", "partition": "test"}
{"idx": "784", "code": "public static double[] lsf2lpc(double[] lsf){\n  MathUtils.quickSort(lsf);\n  int P=lsf.length;\n  int half_order=P / 2;\n  int i, j;\n  double xf, xx;\n  double[] a=new double[P / 2 + 1];\n  double[] a1=new double[P / 2 + 1];\n  double[] a2=new double[P / 2 + 1];\n  double[] b=new double[P / 2 + 1];\n  double[] b1=new double[P / 2 + 1];\n  double[] b2=new double[P / 2 + 1];\n  double[] p=new double[P / 2];\n  double[] q=new double[P / 2];\n  double[] oneMinusA=new double[P + 1];\n  oneMinusA[0]=1.;\n  if ((lsf[0] <= 0.0) || (lsf[0] >= 0.5)) {\n    throw new IllegalArgumentException(\"LSFs out of bounds; lsf[0] = \" + lsf[0]);\n  }\n  for (i=1; i < P; i++) {\n    if (lsf[i] <= lsf[i - 1])     throw new IllegalArgumentException(\"nonmonotonic LSFs\");\n    if ((lsf[i] <= 0.0) || (lsf[i] >= 0.5))     throw new IllegalArgumentException(\"LSFs out of bounds; lsf[\" + i + \"] = \"+ lsf[i]);\n  }\n  for (i=0; i < half_order; i++) {\n    p[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i]);\n    q[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i + 1]);\n  }\n  xf=0.0;\n  for (i=0; i <= P; i++) {\n    if (i == 0)     xx=1.0;\n else     xx=0.0;\n    a[0]=xx + xf;\n    b[0]=xx - xf;\n    xf=xx;\n    for (j=0; j < half_order; j++) {\n      a[j + 1]=a[j] + p[j] * a1[j] + a2[j];\n      b[j + 1]=b[j] + q[j] * b1[j] + b2[j];\n      a2[j]=a1[j];\n      a1[j]=a[j];\n      b2[j]=b1[j];\n      b1[j]=b[j];\n    }\n    if (i > 0)     oneMinusA[i]=0.5 * (a[half_order] + b[half_order]);\n  }\n  return oneMinusA;\n}\n", "docstring": "convert lsf frequencies into lpc coefficients . the analysis filter may be reconstructed : a ( z ) = 1 / 2 [ p ( z ) + q ( z ) ", "partition": "test"}
{"idx": "785", "code": "protected void generateFields(){\n  for (Iterator<Element> iterator=mElements.iterator(); iterator.hasNext(); ) {\n    Element element=iterator.next();\n    if (!element.used) {\n      iterator.remove();\n      continue;\n    }\n    PsiField[] fields=mClass.getFields();\n    boolean duplicateField=false;\n    for (    PsiField field : fields) {\n      String name=field.getName();\n      if (name != null && name.equals(element.getFieldName())) {\n        duplicateField=true;\n        break;\n      }\n    }\n    if (duplicateField) {\n      iterator.remove();\n      continue;\n    }\n    mClass.add(mFactory.createFieldFromText(\"private \" + element.name + \" \"+ element.getFieldName()+ \";\",mClass));\n  }\n}\n", "docstring": "create fields for injections inside main class", "partition": "test"}
{"idx": "786", "code": "public boolean isFlying(){\n  return (flyThroughDialog != null);\n}\n", "docstring": "determine if in flight", "partition": "test"}
{"idx": "787", "code": "public synchronized void init(){\n  channelFactory=new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());\n  datagramChannelFactory=new NioDatagramChannelFactory(Executors.newCachedThreadPool());\n  timer=new HashedWheelTimer();\n}\n", "docstring": "initialize ; cached threadpool is safe as it is releasing resources automatically if idle", "partition": "test"}
{"idx": "788", "code": "private void consumeNestedScroll(int dxUnconsumed,int dyUnconsumed,int dxFinalUnconsumed,int dyFinalUnconsumed){\n  if (mOverScrollEffect == OverScrollEffect.BOUNCE && dyFinalUnconsumed != 0) {\n    mUnconsumedOverScrollOffset+=-dyFinalUnconsumed;\n    int maxOffset=mOverScrollOffsetLimit;\n    if (mUnconsumedOverScrollOffset > 0) {\n      mUnconsumedOverScrollOffset=Math.min(maxOffset,mUnconsumedOverScrollOffset);\n    }\n else     if (mUnconsumedOverScrollOffset < 0) {\n      mUnconsumedOverScrollOffset=Math.max(-maxOffset,mUnconsumedOverScrollOffset);\n    }\n    setScrollingOffset(getUnconsumedScrollingOffset());\n  }\n  pullEdgeEffects(dxUnconsumed,dyUnconsumed);\n}\n", "docstring": "consume the final unconsumed nested scroll after all behaviors done .", "partition": "test"}
{"idx": "789", "code": "private void retrieveWaypoints(SearchQuery query,ArrayList<Waypoint> waypoints){\n  String queryLikeSelection2=\"%\" + query.textQuery + \"%\";\n  String[] waypointSelectionArgs=new String[]{queryLikeSelection2,queryLikeSelection2,queryLikeSelection2};\n  Cursor cursor=null;\n  try {\n    cursor=providerUtils.getWaypointCursor(WAYPOINT_SELECTION_QUERY,waypointSelectionArgs,WAYPOINT_SELECTION_ORDER,MAX_SCORED_WAYPOINTS);\n    if (cursor != null) {\n      waypoints.ensureCapacity(cursor.getCount());\n      while (cursor.moveToNext()) {\n        Waypoint waypoint=providerUtils.createWaypoint(cursor);\n        if (LocationUtils.isValidLocation(waypoint.getLocation())) {\n          waypoints.add(waypoint);\n        }\n      }\n    }\n  }\n  finally {\n    if (cursor != null) {\n      cursor.close();\n    }\n  }\n}\n", "docstring": "retrieves waypoints matching the given query from the database .", "partition": "test"}
{"idx": "790", "code": "void release(){\n  imageLoader.cancelPendingRequests();\n  loading=new boolean[noxItems.size()];\n}\n", "docstring": "cancels all the pending noxitem downloads to the imageloader .", "partition": "test"}
{"idx": "791", "code": "public void add(String name,long cnt){\n  if (_values == null) {\n    _values=new ArrayList<>(30);\n  }\n  _values.add(new Count(this,name,cnt));\n}\n", "docstring": "insert at the end of the list", "partition": "test"}
{"idx": "792", "code": "void closeDialog();\n", "docstring": "closes dialog ( if opened ) .", "partition": "test"}
{"idx": "793", "code": "public void addParam(AstNode param){\n  assertNotNull(param);\n  if (params == null) {\n    params=new ArrayList<AstNode>();\n  }\n  params.add(param);\n  param.setParent(this);\n}\n", "docstring": "adds a parameter to the function parameter list . sets the parent of the param node to this node .", "partition": "test"}
{"idx": "794", "code": "DeleteEvent(@NonNull JSONObject json) throws JSONException {\n  super(TYPE_DELETE,json);\n  if (TextUtils.isEmpty(mBlockId)) {\n    throw new JSONException(TYPENAME_DELETE + \" requires \" + JSON_BLOCK_ID);\n  }\n  mOldXml=json.optString(JSON_OLD_VALUE);\n  JSONArray ids=json.getJSONArray(JSON_IDS);\n  int count=ids.length();\n  List<String> temp=new ArrayList<>(count);\n  for (int i=0; i < count; ++i) {\n    temp.add(ids.getString(i));\n  }\n  mIds=Collections.unmodifiableList(temp);\n}\n", "docstring": "constructs a deleteevent from the json serialized representation .", "partition": "test"}
{"idx": "795", "code": "public static boolean isFullCopyRestorable(Volume volume,DbClient dbClient){\n  boolean result=false;\n  String replicaState=volume.getReplicaState();\n  if (isVolumeFullCopy(volume,dbClient) && replicaState != null && !replicaState.isEmpty()) {\n    ReplicationState state=ReplicationState.getEnumValue(replicaState);\n    if (state != null && state == ReplicationState.SYNCHRONIZED) {\n      result=true;\n    }\n  }\n  return result;\n}\n", "docstring": "check if the full copy volume could be restored .", "partition": "test"}
{"idx": "796", "code": "private final static String[] readQDStrings(String string,int[] pos) throws NamingException {\n  return readQDescrs(string,pos);\n}\n", "docstring": "dstring = 1 * utf8 qdstring = whsp \" \"'\" \" dstring \" \"'\" \" whsp qdstringlist = [ qdstring * ( qdstring ) ", "partition": "test"}
{"idx": "797", "code": "private static boolean isBufferTooLarge(ByteBuffer buf){\n  return isBufferTooLarge(buf.capacity());\n}\n", "docstring": "returns true if the buffer is too large to be added to the buffer cache , false otherwise .", "partition": "test"}
{"idx": "798", "code": "public static void resetIndexBufferTime(){\n  SAFE_QUERY_TIME.set(0);\n}\n", "docstring": "only for test purposes this should not be called from any product code . calls from product code will possibly cause continous reevaluation ( performance issue ) or incorrect query results ( functional issue )", "partition": "test"}
{"idx": "799", "code": "protected abstract AdminResponse createResponse(DistributionManager dm);\n", "docstring": "must return a proper response to this request .", "partition": "test"}
{"idx": "800", "code": "protected boolean checkExternalStorageAndNotify(String fileName){\n  if (fileName != null && fileName.startsWith(\"null\")) {\n    alertDownloadFailure(R.string.download_no_sdcard_dlg_title);\n    return false;\n  }\n  String status=Environment.getExternalStorageState();\n  if (!status.equals(Environment.MEDIA_MOUNTED)) {\n    int title;\n    if (status.equals(Environment.MEDIA_SHARED)) {\n      title=R.string.download_sdcard_busy_dlg_title;\n    }\n else {\n      title=R.string.download_no_sdcard_dlg_title;\n    }\n    alertDownloadFailure(title);\n    return false;\n  }\n  return true;\n}\n", "docstring": "check the external storage and notify user on error .", "partition": "test"}
{"idx": "801", "code": "public static String plnoun(final int quantity,final String noun){\n  final String enoun=fullForm(noun);\n  if (quantity == 1) {\n    return singular(enoun);\n  }\n else {\n    return plural(noun);\n  }\n}\n", "docstring": "returns either the plural or singular form of the given noun , depending on the quantity .", "partition": "test"}
{"idx": "802", "code": "public boolean verifyXMLSignature(org.w3c.dom.Element element,java.lang.String certAlias) throws XMLSignatureException {\n  return verifyXMLSignature(element,DEF_ID_ATTRIBUTE,certAlias);\n}\n", "docstring": "verify the signature of the xml document", "partition": "test"}
{"idx": "803", "code": "public void readTransportSystems(final int[] columnsIndices,final BufferedReader reader) throws IOException {\n  String line=reader.readLine();\n  while (line != null && line.length() > 0) {\n    line=reader.readLine();\n  }\n}\n", "docstring": "reads the transport systems of the visum file", "partition": "test"}
{"idx": "804", "code": "public ComponentConfigBuilder addItemInMultifield(String multifieldLabel,int index,String itemType,String itemLabel,String value){\n  String type=String.format(\"multifield#%s#%s\",index,itemType);\n  String label=String.format(\"%s#%s\",multifieldLabel,itemLabel);\n  config.add(new ConfigurationEntry(currentTab,type,label,value));\n  return this;\n}\n", "docstring": "adds multifield entry , equivalent of : | tab_name | multifield # index # itemtype | multifieldlabel # itemlabel | value |", "partition": "test"}
{"idx": "805", "code": "private void parseParameters(String parameters){\n  Log.v(\"HttpHeader\",\"HttpAuthHeader.parseParameters():\" + \" parameters: \" + parameters);\n  if (parameters != null) {\n    int i;\n    do {\n      i=parameters.indexOf(\',\');\n      if (i < 0) {\n        parseParameter(parameters);\n      }\n else {\n        parseParameter(parameters.substring(0,i));\n        parameters=parameters.substring(i + 1);\n      }\n    }\n while (i >= 0);\n  }\n}\n", "docstring": "parses a comma - separated list of authentification scheme parameters .", "partition": "test"}
{"idx": "806", "code": "public void addHttpSessionToken(String site,String token){\n  if (!site.contains(\":\")) {\n    site=site + (\":80\");\n  }\n  HttpSessionTokensSet siteTokens=sessionTokens.get(site);\n  if (siteTokens == null) {\n    siteTokens=new HttpSessionTokensSet();\n    sessionTokens.put(site,siteTokens);\n  }\n  log.info(\"Added new session token for site \'\" + site + \"\': \"+ token);\n  siteTokens.addToken(token);\n  unmarkRemovedDefaultSessionToken(site,token);\n}\n", "docstring": "adds a new session token for a particular site .", "partition": "test"}
{"idx": "807", "code": "public GradleDistribution deserializeFromString(String distributionString){\n  Preconditions.checkNotNull(distributionString);\n  String localInstallationPrefix=\"GRADLE_DISTRIBUTION(LOCAL_INSTALLATION(\";\n  if (distributionString.startsWith(localInstallationPrefix) && distributionString.endsWith(\"))\")) {\n    String localInstallationDir=distributionString.substring(localInstallationPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forLocalInstallation(new File(localInstallationDir));\n  }\n  String remoteDistributionPrefix=\"GRADLE_DISTRIBUTION(REMOTE_DISTRIBUTION(\";\n  if (distributionString.startsWith(remoteDistributionPrefix) && distributionString.endsWith(\"))\")) {\n    String remoteDistributionUri=distributionString.substring(remoteDistributionPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forRemoteDistribution(createURI(remoteDistributionUri));\n  }\n  String versionPrefix=\"GRADLE_DISTRIBUTION(VERSION(\";\n  if (distributionString.startsWith(versionPrefix) && distributionString.endsWith(\"))\")) {\n    String version=distributionString.substring(versionPrefix.length(),distributionString.length() - 2);\n    return GradleDistribution.forVersion(version);\n  }\n  String wrapperString=\"GRADLE_DISTRIBUTION(WRAPPER)\";\n  if (distributionString.equals(wrapperString)) {\n    return GradleDistribution.fromBuild();\n  }\n  String message=String.format(\"Cannot deserialize Gradle distribution string \'%s.\'\",distributionString);\n  throw new RuntimeException(message);\n}\n", "docstring": "deserializes the gradle distribution from the the given string representation .", "partition": "test"}
{"idx": "808", "code": "public double metersToPixels(){\n  double screenCenterLat=screenTopLeft.latitude - screenSize.latitude / 2;\n  double metersToLon=1 / (Util.LON_TO_METERS_AT_EQUATOR * Math.cos(screenCenterLat / 180 * Math.PI));\n  return screenSize.longitude / windowWidth * metersToLon;\n}\n", "docstring": "returns the ratio of meters to pixels at the center of the screen", "partition": "test"}
{"idx": "809", "code": "public boolean sendViaDataSocket(byte[] bytes,int start,int len){\n  if (dataOutputStream == null) {\n    Log.i(TAG,\"Can\'t send via null dataOutputStream\");\n    return false;\n  }\n  if (len == 0) {\n    return true;\n  }\n  try {\n    dataOutputStream.write(bytes,start,len);\n  }\n catch (  IOException e) {\n    Log.i(TAG,\"Couldn\'t write output stream for data socket\");\n    Log.i(TAG,e.toString());\n    return false;\n  }\n  localDataSocket.reportTraffic(len);\n  return true;\n}\n", "docstring": "sends a byte array over the already - established data socket", "partition": "test"}
{"idx": "810", "code": "private void pushContext(BaseContext c){\n  contextStack.push(c);\n}\n", "docstring": "add a new parsing context onto the parse context stack .", "partition": "test"}
{"idx": "811", "code": "@Override public void bookmarksOrHistoryPicker(ComboViews startView){\n  if (mTabControl.getCurrentWebView() == null) {\n    return;\n  }\n  if (isInCustomActionMode()) {\n    endActionMode();\n  }\n  Bundle extras=new Bundle();\n  extras.putBoolean(BrowserBookmarksPage.EXTRA_DISABLE_WINDOW,!mTabControl.canCreateNewTab());\n  mUi.showComboView(startView,extras);\n}\n", "docstring": "open the go page .", "partition": "test"}
{"idx": "812", "code": "public FST(String fileName,String encoding,boolean verbose) throws IOException {\n  FileInputStream fis=new FileInputStream(fileName);\n  try {\n    loadHeaderless(fis,encoding,verbose);\n  }\n  finally {\n    fis.close();\n  }\n}\n", "docstring": "initialise the finite state transducer .", "partition": "test"}
{"idx": "813", "code": "public static double[] normalizeZscore(double[] x){\n  double mn=mean(x,0);\n  double sd=standardDeviation(x,0);\n  for (int i=0; i < x.length; i++)   if (!Double.isNaN(x[i]))   x[i]=(x[i] - mn) / sd;\n  return x;\n}\n", "docstring": "calcualtes x_i = ( x_i - mean ( x ) ) / std ( x ) this function can deal with nans", "partition": "test"}
{"idx": "814", "code": "void addLocation(String location){\n  if (fLocationList.contains(location)) {\n    return;\n  }\n  fLocationList.add(location);\n  fTableViewer.refresh();\n  fTableViewer.setChecked(location,true);\n  fTableViewer.setSelection(new StructuredSelection(location));\n  validateLocations();\n}\n", "docstring": "adds the given location to the table", "partition": "test"}
{"idx": "815", "code": "public JavaFormatter(String lineDelimiter,int initialIndentLevel,boolean useCodeFormatter,IJavaProject project){\n  fLineDelimiter=lineDelimiter;\n  fUseCodeFormatter=useCodeFormatter;\n  fInitialIndentLevel=initialIndentLevel;\n  fProject=project;\n}\n", "docstring": "creates a javaformatter with the target line delimiter .", "partition": "test"}
{"idx": "816", "code": "private static void checkPathNeed(){\n  if (samplingInterval == -1) {\n    lastPreloadTime=readMorePaths();\n  }\n  if (!Double.isNaN(lastPreloadTime) && SimClock.getTime() >= lastPreloadTime - (samplingInterval * MIN_AHEAD_INTERVALS)) {\n    for (int i=0; i < nrofPreload && !Double.isNaN(lastPreloadTime); i++) {\n      lastPreloadTime=readMorePaths();\n    }\n  }\n}\n", "docstring": "checks if more paths should be preloaded and preloads them if needed .", "partition": "test"}
{"idx": "817", "code": "public double wide(Prior prior,Likelihood likelihood) throws OperatorFailedException {\n  final int nodeCount=tree.getNodeCount();\n  final NodeRef root=tree.getRoot();\n  NodeRef i;\n  int indexI;\n  do {\n    indexI=MathUtils.nextInt(nodeCount);\n    i=tree.getNode(indexI);\n  }\n while (root == i || (tree.getParent(i) == root && tree.getNodeHeight(i) > tree.getNodeHeight(getOtherChild(tree,tree.getParent(i),i))));\n  List<Integer> secondNodeIndices=new ArrayList<Integer>();\n  List<Double> probabilities=new ArrayList<Double>();\n  NodeRef j, jP;\n  NodeRef iP=tree.getParent(i);\n  double heightIP=tree.getNodeHeight(iP);\n  double heightI=tree.getNodeHeight(i);\n  double sum=0.0;\n  double backward=calculateTreeLikelihood(prior,likelihood,tree);\n  int offset=(int)-backward;\n  backward=Math.exp(backward + offset);\n  for (int n=0; n < nodeCount; n++) {\n    j=tree.getNode(n);\n    if (j != root) {\n      jP=tree.getParent(j);\n      if ((iP != jP) && (tree.getNodeHeight(j) < heightIP) && (heightI < tree.getNodeHeight(jP))) {\n        secondNodeIndices.add(n);\n        swap(tree,i,j,iP,jP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        probabilities.add(prob);\n        swap(tree,i,j,jP,iP);\n        sum+=prob;\n      }\n    }\n  }\n  if (sum <= 1E-100) {\n    throw new OperatorFailedException(\"Couldn\'t find another proposal with a decent likelihood.\");\n  }\n  double ran=Math.random() * sum;\n  int index=0;\n  while (ran > 0.0) {\n    ran-=probabilities.get(index);\n    index++;\n  }\n  index--;\n  j=tree.getNode(secondNodeIndices.get(index));\n  jP=tree.getParent(j);\n  double heightJP=tree.getNodeHeight(jP);\n  double heightJ=tree.getNodeHeight(j);\n  double sumForward2=0.0;\n  NodeRef k, kP;\n  for (int n=0; n < nodeCount; n++) {\n    k=tree.getNode(n);\n    if (k != root) {\n      kP=tree.getParent(k);\n      if ((jP != kP) && (tree.getNodeHeight(k) < heightJP) && (heightJ < tree.getNodeHeight(kP))) {\n        swap(tree,j,k,jP,kP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        sumForward2+=prob;\n        swap(tree,j,k,kP,jP);\n      }\n    }\n  }\n  swap(tree,i,j,iP,jP);\n  double forward=probabilities.get(index);\n  iP=jP;\n  heightIP=heightJP;\n  double sumBackward=0.0;\n  for (int n=0; n < nodeCount; n++) {\n    j=tree.getNode(n);\n    if (j != root) {\n      jP=tree.getParent(j);\n      if ((iP != jP) && (tree.getNodeHeight(j) < heightIP) && (heightI < tree.getNodeHeight(jP))) {\n        swap(tree,i,j,iP,jP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        sumBackward+=prob;\n        swap(tree,i,j,jP,iP);\n      }\n    }\n  }\n  double sumBackward2=0.0;\n  j=tree.getNode(secondNodeIndices.get(index));\n  jP=tree.getParent(j);\n  heightJP=tree.getNodeHeight(jP);\n  heightJ=tree.getNodeHeight(j);\n  for (int n=0; n < nodeCount; n++) {\n    k=tree.getNode(n);\n    if (k != root) {\n      kP=tree.getParent(k);\n      if ((jP != kP) && (tree.getNodeHeight(k) < heightJP) && (heightJ < tree.getNodeHeight(kP))) {\n        swap(tree,j,k,jP,kP);\n        double prob=Math.exp(calculateTreeLikelihood(prior,likelihood,tree) + offset);\n        sumBackward2+=prob;\n        swap(tree,j,k,kP,jP);\n      }\n    }\n  }\n  double forwardProb=(forward / sum) + (forward / sumForward2);\n  double backwardProb=(backward / sumBackward) + (backward / sumBackward2);\n  double hastingsRatio=Math.log(backwardProb / forwardProb);\n  return hastingsRatio;\n}\n", "docstring": "warning : assumes strictly bifurcating tree .", "partition": "test"}
{"idx": "818", "code": "public boolean isInputColumnNameAllowed(String columnName){\n  if (columnName == null || columnName.length() == 0)   return false;\n  getInputColumnNames(false);\n  for (int i=0; i < m_inputcolumnnames.length; i++) {\n    if (columnName.equals(m_inputcolumnnames[i]))     return true;\n  }\n  return false;\n}\n", "docstring": "is input column name allowed", "partition": "test"}
{"idx": "819", "code": "public void testEmptyOrNullBlob() throws Exception {\n  try {\n    PreparedStatement stmt=connection.prepareStatement(\"INSERT INTO test_blob(id, bin_data) VALUES(?, ?)\");\n    try {\n      stmt.setInt(1,3);\n      stmt.setBytes(2,new byte[0]);\n      int insertedCount=stmt.executeUpdate();\n      assertTrue(\"Should insert one row.\",insertedCount == 1);\n      stmt.setInt(1,4);\n      stmt.setNull(2,Types.BINARY);\n      insertedCount=stmt.executeUpdate();\n      assertTrue(\"Should insert one row.\",insertedCount == 1);\n    }\n  finally {\n      stmt.close();\n    }\n    stmt=connection.prepareStatement(\"SELECT bin_data FROM test_blob WHERE id = ?\");\n    stmt.setInt(1,3);\n    try {\n      ResultSet rs=stmt.executeQuery();\n      assertTrue(\"Should select at least one row.\",rs.next());\n      assertTrue(\"Result should byte[0]\",Arrays.equals(rs.getBytes(1),new byte[0]));\n      rs.close();\n      stmt.setInt(1,4);\n      rs=stmt.executeQuery();\n      assertTrue(\"Should select at least one row.\",rs.next());\n      assertTrue(\"Result should byte[0]\",rs.getObject(1) == null);\n      rs.close();\n    }\n  finally {\n      stmt.close();\n    }\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n    throw ex;\n  }\n}\n", "docstring": "test if driver returns correctly empty and null blobs .", "partition": "test"}
{"idx": "820", "code": "private synchronized void rebuildJournal() throws IOException {\n  if (journalWriter != null) {\n    journalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFileTmp),Utils.US_ASCII));\n  try {\n    writer.write(MAGIC);\n    writer.write(\"\\n\");\n    writer.write(VERSION_1);\n    writer.write(\"\\n\");\n    writer.write(Integer.toString(appVersion));\n    writer.write(\"\\n\");\n    writer.write(Integer.toString(valueCount));\n    writer.write(\"\\n\");\n    writer.write(\"\\n\");\n    for (    Entry entry : lruEntries.values()) {\n      if (entry.currentEditor != null) {\n        writer.write(DIRTY + \' \' + entry.key+ \'\\n\');\n      }\n else {\n        writer.write(CLEAN + \' \' + entry.key+ entry.getLengths()+ \'\\n\');\n      }\n    }\n  }\n  finally {\n    writer.close();\n  }\n  if (journalFile.exists()) {\n    renameTo(journalFile,journalFileBackup,true);\n  }\n  renameTo(journalFileTmp,journalFile,false);\n  journalFileBackup.delete();\n  journalWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(journalFile,true),Utils.US_ASCII));\n}\n", "docstring": "creates a new journal that omits redundant information . this replaces the current journal if it exists .", "partition": "test"}
{"idx": "821", "code": "@SuppressWarnings(\"unchecked\") public void restore(String fileName) throws IOException, ClassNotFoundException {\n  ObjectInputStream ois=new ObjectInputStream(new FileInputStream(fileName));\n  locations=(Map<V,Point>)ois.readObject();\n  ois.close();\n  initializeLocations();\n  locked=true;\n  fireStateChanged();\n}\n", "docstring": "restore the graph vertex locations from a file", "partition": "test"}
{"idx": "822", "code": "public void waitForData(){\n  if (this.initialized) {\n    return;\n  }\n  waitOnInitialization(this.initializationLatchAfterGetInitialImage);\n}\n", "docstring": "wait until data is ready in this region", "partition": "test"}
{"idx": "823", "code": "private void blackmanHarris4sMin(int size){\n  int start=(windowFunction.length - size) / 2;\n  int stop=(windowFunction.length + size) / 2;\n  double scale=1.0 / (double)size / 0.36;\n  for (int i=0; start < stop; start++, i++)   windowFunction[i]=scale * (0.35875 - 0.48829 * Math.cos(twoPI * i / size) + 0.14128 * Math.cos(2 * twoPI * i / size) - 0.01168 * Math.cos(3 * twoPI * i / size));\n}\n", "docstring": "fill an array with the values of a minimum 4 - sample blackman - harris window function", "partition": "test"}
{"idx": "824", "code": "public int hashCode(){\n  return _lowerNick.hashCode();\n}\n", "docstring": "returns the hash code of this user object .", "partition": "test"}
{"idx": "825", "code": "public boolean incrementReceived(){\n  Long diff=System.currentTimeMillis() - startTime;\n  if (diff >= 1000) {\n    packetsPerSecond=intervalPackets;\n    startTime=System.currentTimeMillis();\n    intervalPackets=1;\n    return true;\n  }\n else {\n    intervalPackets++;\n  }\n  this.receivedPackets++;\n  return false;\n}\n", "docstring": "used for incrementing the number of packets received from the client", "partition": "test"}
{"idx": "826", "code": "Sentence parseSentence(final String text,final ConversationContext ctx){\n  if (isEmpty()) {\n    return ConversationParser.parse(text,ctx);\n  }\n  String txt=text.trim();\n  final Sentence sentence=new SentenceImplementation(ctx,txt);\n  txt=ConversationParser.detectSentenceType(txt,sentence);\n  if (typeMatching) {\n    readTypeMatchExpressions(txt,ctx,sentence);\n  }\n else   if (exactMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (similarMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (jokerMatching) {\n    readJokerExpressions(txt,ctx,sentence);\n  }\n else   if (caseInsensitive) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n  return sentence;\n}\n", "docstring": "parse the given text string and create a sentence object using the current matching flags .", "partition": "test"}
{"idx": "827", "code": "public KafkaCluster usingDirectory(File dataDir){\n  if (running)   throw new IllegalStateException(\"Unable to add a broker when the cluster is already running\");\n  if (dataDir != null && dataDir.exists() && !dataDir.isDirectory() && !dataDir.canWrite() && !dataDir.canRead()) {\n    throw new IllegalArgumentException(\"The directory must be readable and writable\");\n  }\n  this.dataDir=dataDir;\n  return this;\n}\n", "docstring": "set the parent directory where the brokers logs and server \"'\" s logs and snapshots will be kept .", "partition": "test"}
{"idx": "828", "code": "protected boolean checkProsodicPosition(Element currentRulePart,String prosodicPositionType){\n  NamedNodeMap attNodes=currentRulePart.getAttributes();\n  for (int z=0; z < attNodes.getLength(); z++) {\n    Node el=attNodes.item(z);\n    String currentAtt=el.getNodeName();\n    String currentVal=el.getNodeValue();\n    if (currentAtt.equals(\"type\")) {\n      if (!currentVal.startsWith(\"!\")) {\n        if (!prosodicPositionType.equals(currentVal))         return false;\n      }\n else {\n        currentVal=currentVal.substring(1,currentVal.length());\n        if (prosodicPositionType.equals(currentVal))         return false;\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "checks rule part with tag \" prosodicposition \" ; there is only the \" type \" attribute right now : checks if prosodic position of a token is the same as the value of the type attribute in the rule ; values : prenuclear , nuclearparagraphfinal , nuclearparagraphnonfinal , postnuclear", "partition": "test"}
{"idx": "829", "code": "public static void registerOperators(String name,InputStream operatorsXML,ClassLoader classLoader){\n  registerOperators(name,operatorsXML,classLoader,null);\n}\n", "docstring": "registers all operators from a given xml input stream . closes the stream .", "partition": "test"}
{"idx": "830", "code": "public void deleteSubGroupContainers(Set groupContainers) throws AMException, SSOException {\n  Iterator iter=groupContainers.iterator();\n  while (iter.hasNext()) {\n    String groupContainerDN=(String)iter.next();\n    AMGroupContainer groupContainer=new AMGroupContainerImpl(token,groupContainerDN);\n    groupContainer.delete();\n  }\n}\n", "docstring": "deletes sub group containers in this group container .", "partition": "test"}
{"idx": "831", "code": "public GlowTask(Plugin owner,Runnable task,boolean sync,long delay,long period){\n  super(task,null);\n  taskId=nextTaskId.getAndIncrement();\n  description=task.toString();\n  this.owner=owner;\n  this.delay=delay;\n  this.period=period;\n  counter=0;\n  this.sync=sync;\n}\n", "docstring": "creates a new task with the specified number of ticks between consecutive calls to execute ( ) .", "partition": "test"}
{"idx": "832", "code": "public static void init(String[] args){\n  try {\n    compiler.initCompiler(args);\n    if (VM.BuildForAdaptiveSystem && VM.BuildWithBaseBootImageCompiler) {\n      optCompiler.initCompiler(args);\n    }\n  }\n catch (  Throwable e) {\n    while (e != null) {\n      e.printStackTrace();\n      e=e.getCause();\n    }\n  }\n}\n", "docstring": "initialize boot image compiler .", "partition": "test"}
{"idx": "833", "code": "static native boolean openDev();\n", "docstring": "open fm device , call before power up", "partition": "test"}
{"idx": "834", "code": "public static String encode(Serializable o){\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\n  try {\n    ObjectOutputStream oos=new ObjectOutputStream(bos);\n    try {\n      oos.writeObject(o);\n      oos.flush();\n    }\n  finally {\n      oos.close();\n    }\n    return Base64.encodeBytes(bos.toByteArray());\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "encode a object to a base64 string", "partition": "test"}
{"idx": "835", "code": "private static boolean isIdentifierName(String k){\n  int n=k.length();\n  if (n == 0) {\n    return false;\n  }\n  if (!Character.isJavaIdentifierStart(k.charAt(0))) {\n    return false;\n  }\n  for (int i=1; i < n; ++i) {\n    if (!Character.isJavaIdentifierPart(k.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "an ecmascript identifiername is an identifier or reserved word . this is approximate to avoid bringing in extra dependencies .", "partition": "test"}
{"idx": "836", "code": "static boolean lessThanUnsignedLong(long x1,long x2){\n  return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);\n}\n", "docstring": "returns true if x1 is less than x2 , when both values are treated as unsigned long .", "partition": "test"}
{"idx": "837", "code": "private void moveSingleNode(Object source,Point newPoint){\n  DisplayNode node=(DisplayNode)source;\n  int deltaX=newPoint.x - clickPoint.x;\n  int deltaY=newPoint.y - clickPoint.y;\n  int newX=node.getLocation().x + deltaX;\n  int newY=node.getLocation().y + deltaY;\n  node.setLocation(newX,newY);\n}\n", "docstring": "move a single , unselected node .", "partition": "test"}
{"idx": "838", "code": "@SuppressWarnings(\"rawtypes\") protected KafkaSpoutWrapper createKafkaSpout(Map conf,TopologyContext context,SpoutOutputCollector collector,final String topic,String schemeClsName,SpoutSpec spoutSpec,Map<String,StreamDefinition> sds) throws Exception {\n  String kafkaBrokerZkQuorum=config.getString(\"spout.kafkaBrokerZkQuorum\");\n  BrokerHosts hosts=null;\n  if (config.hasPath(\"spout.kafkaBrokerZkBasePath\")) {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum,config.getString(\"spout.kafkaBrokerZkBasePath\"));\n  }\n else {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum);\n  }\n  String transactionZkRoot=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_ROOT;\n  if (config.hasPath(\"spout.stormKafkaTransactionZkPath\")) {\n    transactionZkRoot=config.getString(\"spout.stormKafkaTransactionZkPath\");\n  }\n  String zkStateTransactionRelPath=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_RELATIVE_PATH;\n  if (config.hasPath(\"spout.stormKafkaEagleConsumer\")) {\n    zkStateTransactionRelPath=config.getString(\"spout.stormKafkaEagleConsumer\");\n  }\n  SpoutConfig spoutConfig=new SpoutConfig(hosts,topic,transactionZkRoot,zkStateTransactionRelPath + \"/\" + topic+ \"/\"+ topologyId);\n  boolean stormKafkaUseSameZkQuorumWithKafkaBroker=config.getBoolean(\"spout.stormKafkaUseSameZkQuorumWithKafkaBroker\");\n  if (stormKafkaUseSameZkQuorumWithKafkaBroker) {\n    ZkServerPortUtils utils=new ZkServerPortUtils(kafkaBrokerZkQuorum);\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n else {\n    ZkServerPortUtils utils=new ZkServerPortUtils(config.getString(\"spout.stormKafkaTransactionZkQuorum\"));\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n  spoutConfig.stateUpdateIntervalMs=config.hasPath(\"spout.stormKafkaStateUpdateIntervalMs\") ? config.getInt(\"spout.stormKafkaStateUpdateIntervalMs\") : 2000;\n  spoutConfig.fetchSizeBytes=config.hasPath(\"spout.stormKafkaFetchSizeBytes\") ? config.getInt(\"spout.stormKafkaFetchSizeBytes\") : 1048586;\n  if (config.hasPath(\"spout.stormKafkaStartOffsetTime\")) {\n    spoutConfig.startOffsetTime=config.getInt(\"spout.stormKafkaStartOffsetTime\");\n  }\n  spoutConfig.scheme=createMultiScheme(conf,topic,schemeClsName);\n  KafkaSpoutWrapper wrapper=new KafkaSpoutWrapper(spoutConfig,kafkaSpoutMetric);\n  SpoutOutputCollectorWrapper collectorWrapper=new SpoutOutputCollectorWrapper(this,collector,topic,spoutSpec,numOfRouterBolts,sds,this.serializer);\n  wrapper.open(conf,context,collectorWrapper);\n  if (LOG.isInfoEnabled()) {\n    LOG.info(\"create and open kafka wrapper: topic {}, scheme class{} \",topic,schemeClsName);\n  }\n  return wrapper;\n}\n", "docstring": "make this method protected to make sure unit test can work well q : where to persist consumer state , i . e . what offset has been consumed for each topic and partition a : stormkafkatransactionzkpath + \" / \" + consumerid + \" / \" + topic + \" / \" + topologyid + \" / \" + partitionid note1 : partitionmanager . committedpath for composing zkstate path , _spoutconfig . zkroot + \" / \" + _spoutconfig . id + \" / \" + _partition . getid ( ) ; consumerid by default is eagleconsumer unless it is specified by \" stormkafkaeagleconsumer \" note2 : put topologyid as part of zkstate because one topic by design can be consumed by multiple topologies so one topology needs to know processed offset for itself < p > todo : should avoid use config . get in deep calling stack , should generate config bean as early as possible", "partition": "test"}
{"idx": "839", "code": "public Builder addEmail(Email email){\n  emails.add(email);\n  return this;\n}\n", "docstring": "adds or updates a emil of an existing user if the . getvalue ( ) already exists a update will be done . if not a new one will be added", "partition": "test"}
{"idx": "840", "code": "public static HashProvider best(HashParameters params){\n  return best(params,EnumSet.of(HashSupport.STATEFUL));\n}\n", "docstring": "returns the best hash provider supporting at least a stateful implementation of a hash function with the given parameters .", "partition": "test"}
{"idx": "841", "code": "public byte[] readRawBytes(final int size) throws IOException {\n  if (size < 0) {\n    throw InvalidProtocolBufferNanoException.negativeSize();\n  }\n  if (bufferPos + size > currentLimit) {\n    skipRawBytes(currentLimit - bufferPos);\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n  if (size <= bufferSize - bufferPos) {\n    final byte[] bytes=new byte[size];\n    System.arraycopy(buffer,bufferPos,bytes,0,size);\n    bufferPos+=size;\n    return bytes;\n  }\n else {\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n}\n", "docstring": "read a fixed size of bytes from the input .", "partition": "test"}
{"idx": "842", "code": "static boolean pairSum(int ar[],int x){\n  Arrays.sort(ar);\n  int len=ar.length;\n  for (int i=0, j=len - 1; i < j; ) {\n    if (ar[i] + ar[j] == x) {\n      return true;\n    }\n else     if (ar[i] + ar[j] < x) {\n      i++;\n    }\n else {\n      j--;\n    }\n  }\n  return false;\n}\n", "docstring": "using sorting . if we use merge sort or heap sort then ( - ) ( nlogn ) in worst case . if we use quick sort then o ( n ^ 2 ) in worst case .", "partition": "test"}
{"idx": "843", "code": "public synchronized void loadFromFile(){\n  entries.clear();\n  Path file=Paths.get(fileName);\n  try (BufferedReader reader=Files.newBufferedReader(file,CHARSET)){\n    String line;\n    do {\n      line=reader.readLine();\n      AddressbookEntry parsedEntry=parseLine(line);\n      if (parsedEntry != null) {\n        entries.put(parsedEntry.getName(),parsedEntry);\n      }\n    }\n while (line != null);\n  }\n catch (  IOException ex) {\n    LOGGER.warning(\"Error reading addressbook: \" + ex.getLocalizedMessage());\n  }\n  LOGGER.info(\"Read \" + entries.size() + \" addressbook entries from \"+ fileName);\n  scanCategories();\n}\n", "docstring": "loads the addressbook from file .", "partition": "test"}
{"idx": "844", "code": "public double localScore(int i,int... parents){\n  for (  int p : parents)   if (forbidden.contains(p))   return Double.NaN;\n  double residualVariance=covariances.get(i,i);\n  int n=getSampleSize();\n  int p=parents.length;\n  Matrix covxx=getSelection1(covariances,parents);\n  try {\n    Matrix covxxInv=covxx.inverse();\n    Matrix covxy=getSelection2(covariances,parents,i);\n    Matrix b=covxxInv.times(covxy);\n    double dot=0.0;\n    for (int j=0; j < covxy.getRowDimension(); j++) {\n      for (int k=0; k < covxy.getColumnDimension(); k++) {\n        dot+=covxy.get(j,k) * b.get(j,k);\n      }\n    }\n    residualVariance-=dot;\n    if (residualVariance <= 0) {\n      if (isVerbose()) {\n        out.println(\"Nonpositive residual varianceY: resVar / varianceY = \" + (residualVariance / covariances.get(i,i)));\n      }\n      return Double.NaN;\n    }\n    double c=getPenaltyDiscount();\n    return score(residualVariance,n,logn,p,c);\n  }\n catch (  Exception e) {\n    boolean removedOne=true;\n    while (removedOne) {\n      List<Integer> _parents=new ArrayList<>();\n      for (int y=0; y < parents.length; y++)       _parents.add(parents[y]);\n      _parents.removeAll(forbidden);\n      parents=new int[_parents.size()];\n      for (int y=0; y < _parents.size(); y++)       parents[y]=_parents.get(y);\n      removedOne=printMinimalLinearlyDependentSet(parents,covariances);\n    }\n    return Double.NaN;\n  }\n}\n", "docstring": "calculates the sample likelihood and bic score for i given its parents in a simple sem model", "partition": "test"}
{"idx": "845", "code": "public boolean remove(final int position){\n  final AdapterTransaction removeTransaction=new RemoveTransaction<>(this,position);\n  final boolean success=removeTransaction.perform();\n  mTransactions.offer(removeTransaction);\n  return success;\n}\n", "docstring": "removes item from the given position .", "partition": "test"}
{"idx": "846", "code": "private void encodeTypes(List<Type> types,Map<String,Object> m,String key,Declaration from){\n  if (types == null || types.isEmpty())   return;\n  List<Map<String,Object>> sats=new ArrayList<>(types.size());\n  for (  Type st : types) {\n    sats.add(typeMap(st,from));\n  }\n  m.put(key,sats);\n}\n", "docstring": "encodes the list of types and puts them under the specified key in the map .", "partition": "test"}
{"idx": "847", "code": "public static void clearAssertionInformation(){\n  _AssertInfos.clear();\n  _AssertOccured=false;\n}\n", "docstring": "clears internal assertion information storage", "partition": "test"}
{"idx": "848", "code": "public void build(String code,String customStatus){\n  try {\n    if (customStatus != null) {\n      result.put(resources.getString(R.string.intent_extra_status),customStatus);\n    }\n else {\n      result.put(resources.getString(R.string.intent_extra_status),resources.getString(R.string.shared_pref_default_status));\n    }\n    result.put(resources.getString(R.string.intent_extra_code),code);\n    operationListResult.put(result);\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON format.\" + e.toString());\n  }\n}\n", "docstring": "add operation results to the array to be returned .", "partition": "test"}
{"idx": "849", "code": "public static Operator generateBranchPlan(AkibanInformationSchema ais,Table table){\n  final Operator indexScan=generateIndexScan(ais,table);\n  final Schema schema=SchemaCache.globalSchema(ais);\n  PrimaryKey pkey=table.getPrimaryKeyIncludingInternal();\n  IndexRowType indexType=schema.indexRowType(pkey.getIndex());\n  return generateBranchPlan(table,indexScan,indexType);\n}\n", "docstring": "scan a group starting with primary key of a table , then get all of the children ( if any ) . primary key is set as parameters to the query context . generates a plan : branch lookup index scan ( table , pk - > ? [ , ? . . . ", "partition": "test"}
{"idx": "850", "code": "public long startstack(){\n  return Long.parseLong(fields[27]);\n}\n", "docstring": "the address of the start ( i . e . , bottom ) of the stack .", "partition": "test"}
{"idx": "851", "code": "public static void copyRealmPrivilegesFromParent(SSOToken token,OrganizationConfigManager parent,OrganizationConfigManager child) throws SSOException, DelegationException {\n  if (debug.messageEnabled()) {\n    debug.message(\"DelegationUtils.copyRealmPrivilegesFromParent\" + \" Parent org: \" + parent.getOrganizationName() + \" Child org: \"+ child.getOrganizationName());\n  }\n  DelegationManager pdm=new DelegationManager(token,parent.getOrganizationName());\n  DelegationManager cdm=new DelegationManager(token,child.getOrganizationName());\n  String childOrgName=DNMapper.orgNameToDN(child.getOrganizationName());\n  Set pdps=pdm.getPrivileges();\n  if (pdps == null || pdps.isEmpty()) {\n    if (debug.messageEnabled()) {\n      debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: No privilege subjects in parent\");\n    }\n    return;\n  }\n  for (Iterator items=pdps.iterator(); items.hasNext(); ) {\n    DelegationPrivilege dp=(DelegationPrivilege)items.next();\n    Set subjects=dp.getSubjects();\n    if (subjects == null || subjects.isEmpty()) {\n      if (debug.messageEnabled()) {\n        debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: No subjects in privilege: \" + dp);\n      }\n      continue;\n    }\n    Set newSubjects=new HashSet();\n    for (Iterator subs=subjects.iterator(); subs.hasNext(); ) {\n      String sName=(String)subs.next();\n      try {\n        AMIdentity id=IdUtils.getIdentity(token,sName);\n        AMIdentity newId=new AMIdentity(token,id.getName(),id.getType(),childOrgName,id.getDN());\n        newSubjects.add(IdUtils.getUniversalId(newId));\n      }\n catch (      IdRepoException ide) {\n        if (debug.messageEnabled()) {\n          debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: IdRepoException for: \" + dp,ide);\n        }\n        continue;\n      }\n    }\n    dp.setSubjects(newSubjects);\n    Set permissions=dp.getPermissions();\n    if ((permissions != null) && (!permissions.isEmpty())) {\n      Iterator it=permissions.iterator();\n      while (it.hasNext()) {\n        DelegationPermission perm=(DelegationPermission)it.next();\n        perm.setOrganizationName(\"*\" + childOrgName);\n      }\n    }\n    cdm.addPrivilege(dp);\n    if (debug.messageEnabled()) {\n      debug.message(\"DelegationUtils.copyRealmPrivileges\" + \"FromParent: Privilege copied from parent: \" + dp);\n    }\n  }\n}\n", "docstring": "creates default privileges for a newly created realm this method should be called in realm mode only .", "partition": "test"}
{"idx": "852", "code": "public boolean match(MimeType other){\n  if (this == other)   return true;\n  if (type != null && other.type != null && !type.equals(other.type))   return false;\n  if (subtype != null && other.subtype != null && !subtype.equals(other.subtype))   return false;\n  return true;\n}\n", "docstring": "checks if given mimetype is covered by current mimetype", "partition": "test"}
{"idx": "853", "code": "@Override public boolean isArmed(){\n  return other.isArmed();\n}\n", "docstring": "all these methods simply delegate to the \" other \" model that is being decorated .", "partition": "test"}
{"idx": "854", "code": "public EncoderTestSuiteBuilder valid(int min,int max){\n  _valid.set(min,max + 1);\n  _invalid.clear(min,max + 1);\n  _encoded.clear(min,max + 1);\n  return this;\n}\n", "docstring": "tells the builder that a range of code - points is valid .", "partition": "test"}
{"idx": "855", "code": "protected List<VolumeDescriptor> createChangeVirtualPoolDescriptors(StorageSystem vplexSystem,Volume volume,VirtualPool newVpool,String taskId,List<Recommendation> recommendations,VirtualPoolCapabilityValuesWrapper capabilities,ControllerOperationValuesWrapper operationsWrapper) throws InternalException {\n  URI volumeVarrayURI=volume.getVirtualArray();\n  VirtualArray volumeVarray=_dbClient.queryObject(VirtualArray.class,volumeVarrayURI);\n  s_logger.info(\"Virtual volume varray is {}\",volumeVarrayURI);\n  URI volumeVpoolURI=volume.getVirtualPool();\n  VirtualPool currentVpool=_dbClient.queryObject(VirtualPool.class,volumeVpoolURI);\n  List<VolumeDescriptor> descriptors=new ArrayList<VolumeDescriptor>();\n  VolumeDescriptor vplexVirtualVolumeDesc=new VolumeDescriptor(VolumeDescriptor.Type.VPLEX_VIRT_VOLUME,volume.getStorageController(),volume.getId(),volume.getPool(),null);\n  Map<String,Object> volumeParams=new HashMap<String,Object>();\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_EXISTING_VOLUME_ID,volume.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_NEW_VPOOL_ID,newVpool.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_OLD_VPOOL_ID,volume.getVirtualPool());\n  if (operationsWrapper != null) {\n    if (operationsWrapper.getMigrationSuspendBeforeCommit() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_COMMIT,operationsWrapper.getMigrationSuspendBeforeCommit());\n    }\n    if (operationsWrapper.getMigrationSuspendBeforeDeleteSource() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_DELETE_SOURCE,operationsWrapper.getMigrationSuspendBeforeDeleteSource());\n    }\n  }\n  vplexVirtualVolumeDesc.setParameters(volumeParams);\n  descriptors.add(vplexVirtualVolumeDesc);\n  if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentVpool,newVpool)) {\n    Volume migSrcVolume=getAssociatedVolumeInVArray(volume,volumeVarrayURI);\n    descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,volumeVarray,newVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,false,capabilities));\n  }\n  URI haVarrayURI=VirtualPoolChangeAnalyzer.getHaVarrayURI(currentVpool);\n  if (haVarrayURI != null) {\n    VirtualArray haVarray=_dbClient.queryObject(VirtualArray.class,haVarrayURI);\n    VirtualPool currentHaVpool=VirtualPoolChangeAnalyzer.getHaVpool(currentVpool,_dbClient);\n    VirtualPool newHaVpool=VirtualPoolChangeAnalyzer.getNewHaVpool(currentVpool,newVpool,_dbClient);\n    if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentHaVpool,newHaVpool)) {\n      Volume migSrcVolume=getAssociatedVolumeInVArray(volume,haVarrayURI);\n      descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,haVarray,newHaVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,true,capabilities));\n    }\n  }\n  return descriptors;\n}\n", "docstring": "change the virtualpool for the passed virtual volume on the passed vplex storage system .", "partition": "test"}
{"idx": "856", "code": "public static boolean isJavaScriptEnabled(HttpServletRequest request){\n  HttpSession session=request.getSession();\n  Boolean javaScriptEnabled=(Boolean)session.getAttribute(\"javaScriptEnabled\");\n  if (javaScriptEnabled != null) {\n    return javaScriptEnabled.booleanValue();\n  }\n  return false;\n}\n", "docstring": "returns true if the user has javascript enabled .", "partition": "test"}
{"idx": "857", "code": "public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (obj instanceof ECFieldFp) {\n    return (p.equals(((ECFieldFp)obj).p));\n  }\n  return false;\n}\n", "docstring": "compares this prime finite field for equality with the specified object .", "partition": "test"}
{"idx": "858", "code": "private static String checksumMD5(String data){\n  MessageDigest md5=null;\n  try {\n    md5=MessageDigest.getInstance(\"MD5\");\n  }\n catch (  NoSuchAlgorithmException ex) {\n    throw new RuntimeException(\"Unable to create MD5 instance\",ex);\n  }\n  return hexEncode(md5.digest(data.getBytes()));\n}\n", "docstring": "md5 version of the \" h ( ) \" function from rfc2617 .", "partition": "test"}
{"idx": "859", "code": "public static boolean validSkinSpecFile(String fileName){\n  File file=new File(Configuration.skinsDir(),fileName);\n  if (!file.exists() || !file.isFile()) {\n    return false;\n  }\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  try {\n    DocumentBuilder builder=dbf.newDocumentBuilder();\n    Document doc=builder.parse(file);\n    NodeList listOfComponents=doc.getElementsByTagName(UI_ELEMENT);\n    if (listOfComponents.getLength() > 0) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  Exception e) {\n    return false;\n  }\n}\n", "docstring": "checks whether the given path points to a file that is a valid skin specification .", "partition": "test"}
{"idx": "860", "code": "public StrBuilder insert(final int index,final Object obj){\n  if (obj == null) {\n    return insert(index,nullText);\n  }\n  return insert(index,obj.toString());\n}\n", "docstring": "inserts the string representation of an object into this builder . inserting null will use the stored null text value .", "partition": "test"}
{"idx": "861", "code": "@Override public void handleMouseMoved(ChartCanvas canvas,MouseEvent e){\n  if (!canvas.isTooltipEnabled()) {\n    return;\n  }\n  String text=getTooltipText(canvas,e.getX(),e.getY());\n  canvas.setTooltip(text,e.getScreenX(),e.getScreenY());\n}\n", "docstring": "handles a mouse moved event by updating the tooltip .", "partition": "test"}
{"idx": "862", "code": "private boolean loadUnpackedUMD(String filename) throws IOException, GeneralJpcspException {\n  if (doUmdBuffering) {\n    return false;\n  }\n  File file=new File(filename);\n  if (file.exists()) {\n    RandomAccessFile raf=new RandomAccessFile(file,\"r\");\n    FileChannel roChannel=raf.getChannel();\n    ByteBuffer readbuffer=roChannel.map(FileChannel.MapMode.READ_ONLY,0,(int)roChannel.size());\n    emulator.load(\"disc0:/PSP_GAME/SYSDIR/EBOOT.BIN\",readbuffer);\n    raf.close();\n    log.info(\"Using unpacked UMD EBOOT.BIN image\");\n    return true;\n  }\n  return false;\n}\n", "docstring": "don \"'\" t call this directly , see loadumd ( file file )", "partition": "test"}
{"idx": "863", "code": "public boolean disableVMAX3Compression(URI blockObjectURI,StorageSystem storageSystem){\n  VirtualPool virtualPool=null;\n  StoragePool storagePool=null;\n  Volume volume=null;\n  if (URIUtil.isType(blockObjectURI,Volume.class)) {\n    volume=_dbClient.queryObject(Volume.class,blockObjectURI);\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockSnapshot.class)) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,blockObjectURI);\n    volume=_dbClient.queryObject(Volume.class,snapshot.getParent());\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockMirror.class)) {\n    BlockMirror mirror=_dbClient.queryObject(BlockMirror.class,blockObjectURI);\n    virtualPool=_dbClient.queryObject(VirtualPool.class,mirror.getVirtualPool());\n    storagePool=_dbClient.queryObject(StoragePool.class,mirror.getPool());\n  }\n  if (volume != null) {\n    virtualPool=_dbClient.queryObject(VirtualPool.class,volume.getVirtualPool());\n    storagePool=_dbClient.queryObject(StoragePool.class,volume.getPool());\n  }\n  return (checkIfProviderSupportsCompressionOperations(storageSystem) && !virtualPool.getCompressionEnabled() && storagePool.getCompressionEnabled());\n}\n", "docstring": "this method is will check if the storage pool associated with the volume supports compression . if it does support compression , it will check if the associated virtual pool has compression enabled . it will recommend the user to disable compression if the virtual pool has compression disabled and the storage pool enables compression by default .", "partition": "test"}
{"idx": "864", "code": "public static LatLon rhumbEndPosition(LatLon p,double rhumbAzimuthRadians,double pathLengthRadians){\n  if (p == null) {\n    throw new IllegalArgumentException(\"LatLon Is Null\");\n  }\n  return rhumbEndPosition(p,Angle.fromRadians(rhumbAzimuthRadians),Angle.fromRadians(pathLengthRadians));\n}\n", "docstring": "computes the location on a rhumb line with the given starting location , rhumb azimuth , and arc distance along the line .", "partition": "test"}
{"idx": "865", "code": "public Dimension maximumLayoutSize(Container target){\n  return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);\n}\n", "docstring": "returns the maximum dimensions for this layout given the components in the specified target container .", "partition": "test"}
{"idx": "866", "code": "public static String readStream(InputStream in){\n  BufferedReader reader=new BufferedReader(new InputStreamReader(in));\n  StringBuilder sb=new StringBuilder();\n  String line=null;\n  try {\n    while ((line=reader.readLine()) != null) {\n      sb.append(line + \"\\n\");\n    }\n  }\n catch (  IOException e) {\n    FreshAirLog.e(\"Error reading stream\",e);\n  }\n finally {\n    try {\n      in.close();\n    }\n catch (    IOException e) {\n    }\n    try {\n      reader.close();\n    }\n catch (    IOException e) {\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "utility method for pulling plain text from an inputstream object", "partition": "test"}
{"idx": "867", "code": "private void logExpiration(Entry e){\n  if (e.renewalsDone()) {\n    logger.log(Level.FINE,\"Reached desired expiration for lease {0}\",e.lease);\n  }\n else {\n    logger.log(Levels.FAILED,\"Lease {0} expired before reaching desired expiration\",e.lease);\n  }\n}\n", "docstring": "logs a lease expiration , distinguishing between expected and premature expirations .", "partition": "test"}
{"idx": "868", "code": "void removeRipple(Ripple ripple){\n  final Ripple[] ripples=mExitingRipples;\n  final int count=mExitingRipplesCount;\n  final int index=getRippleIndex(ripple);\n  if (index >= 0) {\n    System.arraycopy(ripples,index + 1,ripples,index,count - (index + 1));\n    ripples[count - 1]=null;\n    mExitingRipplesCount--;\n    invalidateSelf();\n  }\n}\n", "docstring": "removes a ripple from the exiting ripple list .", "partition": "test"}
{"idx": "869", "code": "protected final void writeS(ByteBuffer buf,String text){\n  if (text == null) {\n    buf.putChar('\\000');\n  }\n else {\n    final int len=text.length();\n    for (int i=0; i < len; i++) {\n      buf.putChar(text.charAt(i));\n    }\n    buf.putChar('\\000');\n  }\n}\n", "docstring": "write string to buffer", "partition": "test"}
{"idx": "870", "code": "@Override public void onDrawEye(Eye eye){\n  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);\n  Engine.checkGLError(\"mColorParam\");\n  if (!prefOrientationProviderString.equals(\"0\")) {\n    if (firstOnDrawEye > 0) {\n      firstOnDrawEye--;\n      float[] m=new float[16];\n      Matrix.invertM(m,0,mHeadViewSDK,0);\n      Matrix.multiplyMM(m,0,eye.getEyeView(),0,m,0);\n      if (eye.getType() == Eye.Type.RIGHT) {\n        mEyeRightView=m;\n      }\n else       if (eye.getType() == Eye.Type.LEFT) {\n        mEyeLeftView=m;\n      }\n      return;\n    }\n    float[] m=new float[16];\n    if (eye.getType() == Eye.Type.RIGHT) {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeRightView,0);\n    }\n else {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeLeftView,0);\n    }\n    Matrix.multiplyMM(mView,0,m,0,mCamera,0);\n  }\n else {\n    Matrix.multiplyMM(mView,0,eye.getEyeView(),0,mCamera,0);\n  }\n  float[] perspective=eye.getPerspective(Z_NEAR,Z_FAR);\n  GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n  GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA,GLES20.GL_ONE_MINUS_SRC_ALPHA);\n  GLES20.glEnable(GLES20.GL_BLEND);\n  if (prefShowEnv && bgEnv.isReady()) {\n    Matrix.multiplyMM(mModelView,0,mView,0,bgEnv.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    bgEnv.draw(eye.getType(),mModelViewProjection);\n  }\n  GLES20.glDisable(GLES20.GL_DEPTH_TEST);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,cameraPreview.model,0);\n  cameraPreview.draw(eye.getType(),mModelViewProjection);\n  Matrix.multiplyMM(mModelView,0,mView,0,screen.model,0);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n  screen.draw(eye.getType(),mModelViewProjection);\n  for (  ButtonThing button : buttonList) {\n    Matrix.multiplyMM(mModelView,0,mView,0,button.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    button.draw(eye.getType(),mModelViewProjection);\n  }\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,aimPoint.model,0);\n  aimPoint.draw(Eye.Type.MONOCULAR,mModelViewProjection);\n}\n", "docstring": "draws a frame for an eye .", "partition": "test"}
{"idx": "871", "code": "protected SourceRecords consumeRecordsByTopic(int numRecords) throws InterruptedException {\n  SourceRecords records=new SourceRecords();\n  consumeRecords(numRecords,null);\n  return records;\n}\n", "docstring": "try to consume and capture exactly the specified number of records from the connector .", "partition": "test"}
{"idx": "872", "code": "@Override public boolean equals(Object o){\n  if (this == o) {\n    return true;\n  }\n  if (!(o instanceof PrototypeSize)) {\n    return false;\n  }\n  PrototypeSize size=(PrototypeSize)o;\n  return prototype.equals(size.prototype);\n}\n", "docstring": "indicates whether some other constantsize is \" equal to \" this one .", "partition": "test"}
{"idx": "873", "code": "private static int compareVersion(String versionStr1,String versionStr2){\n  if (versionStr1 == null) {\n    throw new MLContextException(\"First version argument to compareVersion() is null\");\n  }\n  if (versionStr2 == null) {\n    throw new MLContextException(\"Second version argument to compareVersion() is null\");\n  }\n  Scanner scanner1=null;\n  Scanner scanner2=null;\n  try {\n    scanner1=new Scanner(versionStr1);\n    scanner2=new Scanner(versionStr2);\n    scanner1.useDelimiter(\"\\\\.\");\n    scanner2.useDelimiter(\"\\\\.\");\n    while (scanner1.hasNextInt() && scanner2.hasNextInt()) {\n      int version1=scanner1.nextInt();\n      int version2=scanner2.nextInt();\n      if (version1 < version2) {\n        return -1;\n      }\n else       if (version1 > version2) {\n        return 1;\n      }\n    }\n    return scanner1.hasNextInt() ? 1 : 0;\n  }\n  finally {\n    scanner1.close();\n    scanner2.close();\n  }\n}\n", "docstring": "compare two version strings ( ie , \" 1 . 4 . 0 \" and \" 1 . 4 . 1 \" ) .", "partition": "test"}
{"idx": "874", "code": "public static boolean isValidVector(Vector2f vector){\n  if (vector == null) {\n    return false;\n  }\n  if (Float.isNaN(vector.x) || Float.isNaN(vector.y)) {\n    return false;\n  }\n  if (Float.isInfinite(vector.x) || Float.isInfinite(vector.y)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .", "partition": "test"}
{"idx": "875", "code": "public boolean isObsessional(){\n  return typeString.contains(SUFFIX_OBSESSIONAL);\n}\n", "docstring": "determine if the expression is a obsessional one .", "partition": "test"}
{"idx": "876", "code": "@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"FE_FLOATING_POINT_EQUALITY\",justification=\"equality is specifically \'Unchanged\' here\") public void changeLocoSpeed(DccThrottle t,Block blk,float speed){\n  if (blk == referenced && speed == desiredSpeedStep) {\n    return;\n  }\n  float blockLength=blk.getLengthMm();\n  if (blk == referenced) {\n    distanceRemaining=distanceRemaining - getDistanceTravelled(_throttle.getIsForward(),_throttle.getSpeedSetting(),((float)(System.nanoTime() - lastTimeTimerStarted) / 1000000000));\n    blockLength=distanceRemaining;\n    log.debug(\"Block passed is the same as we are currently processing\");\n  }\n else {\n    referenced=blk;\n  }\n  changeLocoSpeed(t,blockLength,speed);\n}\n", "docstring": "set speed of a throttle to a speeed set by a float , using the block for the length details", "partition": "test"}
{"idx": "877", "code": "public boolean remove(Object targetChild){\n  return remove(targetChild,true);\n}\n", "docstring": "removes a child from this beancontext . if the child object is not for adding then this method throws an illegalstateexception .", "partition": "test"}
{"idx": "878", "code": "private void notifyClassObservers(ClassDescriptor classDescriptor){\n  for (  IClassObserver observer : classObserverList) {\n    observer.observeClass(classDescriptor);\n  }\n}\n", "docstring": "notify all iclassobservers that we are visiting given class .", "partition": "test"}
{"idx": "879", "code": "public void dup2(){\n  mv.visitInsn(Opcodes.DUP2);\n}\n", "docstring": "generates a dup2 instruction .", "partition": "test"}
{"idx": "880", "code": "public static NativePage createNativePageForURL(String url,NativePage candidatePage,Tab tab,TabModelSelector tabModelSelector,Activity activity){\n  return createNativePageForURL(url,candidatePage,tab,tabModelSelector,activity,tab.isIncognito());\n}\n", "docstring": "returns a nativepage for displaying the given url if the url is a valid chrome - native url , or null otherwise . if candidatepage is non - null and corresponds to the url , it will be returned . otherwise , a new nativepage will be constructed .", "partition": "test"}
{"idx": "881", "code": "protected void throwParseException(ParseException e) throws ParseException {\n  if (locator != null) {\n    String elementLocation=\"\";\n    if (curHandler != null) {\n      elementLocation+=\", element \" + curHandler.qName;\n    }\n    String location=\"[Line \" + String.valueOf(locator.getLineNumber()) + \", Column \"+ String.valueOf(locator.getColumnNumber())+ elementLocation+ \"] \";\n    LogUtils.logException(logger,Level.FINE,location,e);\n    throw new ParseException(location + e.getMessage(),e);\n  }\n else {\n    LogUtils.logException(logger,Level.FINE,null,e);\n    throw e;\n  }\n}\n", "docstring": "throws a parse exception with line / column information .", "partition": "test"}
{"idx": "882", "code": "public CustomEditor(){\n  setLayout(new BorderLayout());\n  add(m_Label,BorderLayout.CENTER);\n  m_DeleteBut.addActionListener(m_InnerActionListener);\n  m_EditBut.addActionListener(m_InnerActionListener);\n  m_UpBut.addActionListener(m_InnerActionListener);\n  m_DownBut.addActionListener(m_InnerActionListener);\n  m_AddBut.addActionListener(m_InnerActionListener);\n  m_ElementList.addListSelectionListener(m_InnerSelectionListener);\n  m_ElementList.addMouseListener(m_InnerMouseListener);\n  m_AddBut.setToolTipText(\"Add the current item to the list\");\n  m_DeleteBut.setToolTipText(\"Delete the selected list item\");\n  m_EditBut.setToolTipText(\"Edit the selected list item\");\n  m_UpBut.setToolTipText(\"Move the selected item(s) one up\");\n  m_DownBut.setToolTipText(\"Move the selected item(s) one down\");\n}\n", "docstring": "sets up the array editor .", "partition": "test"}
{"idx": "883", "code": "public MemoidOne(Function<? super Input,? extends Output> fn,BiPredicate<Input,Input> equality){\n  fn_=Objects.requireNonNull(fn);\n  equality_=Objects.requireNonNull(equality);\n}\n", "docstring": "create a new memoidone , using the supplied transformation function .", "partition": "test"}
{"idx": "884", "code": "public static EPType singleValue(Class singleValueType){\n  if (singleValueType != null && singleValueType.isArray()) {\n    return new ClassMultiValuedEPType(singleValueType,singleValueType.getComponentType());\n  }\n  return new ClassEPType(singleValueType);\n}\n", "docstring": "indicate that the expression return type is a single ( non - enumerable ) value of the given type . the expression can still return an array or collection or events however since the engine would not know the type of such objects and may not use runtime reflection it may not allow certain operations on expression results .", "partition": "test"}
{"idx": "885", "code": "private static Class<?> convertFieldType(String fieldType){\n  if (fieldTypeMap.containsKey(fieldType)) {\n    return fieldTypeMap.get(fieldType);\n  }\n  return null;\n}\n", "docstring": "convert field type from string to a class type .", "partition": "test"}
{"idx": "886", "code": "void addXMLElementAfterTokenIndex(int lastTokenIndex,XMLElement element,boolean addAfterNewLine) throws Exception {\n  addXMLElementAfterTokenIndex(lastTokenIndex,element,addAfterNewLine,true);\n}\n", "docstring": "adds the given xmlelement after the token whoes index matches the given lasttokenindex value . if the flag addafternewline is true , a new line is added before the addition of the new element to this document .", "partition": "test"}
{"idx": "887", "code": "public static boolean arrayEquals(Object x,Object y,double tolf,double told){\n  if (x == null && y == null) {\n    return true;\n  }\n  if (x == null || y == null) {\n    return false;\n  }\n  Class<?> xClass=x.getClass();\n  Class<?> yClass=y.getClass();\n  if (xClass != yClass) {\n    return false;\n  }\n  if (!xClass.isArray()) {\n    return x.equals(y);\n  }\n else {\n    if (xClass.equals(int[].class)) {\n      return Arrays.equals((int[])x,(int[])y);\n    }\n else     if (xClass.equals(double[].class)) {\n      if (told == 0) {\n        return Arrays.equals((double[])x,(double[])y);\n      }\n else {\n        return doubleArrayEquals((double[])x,(double[])y,told);\n      }\n    }\n else     if (xClass.equals(long[].class)) {\n      return Arrays.equals((long[])x,(long[])y);\n    }\n else     if (xClass.equals(float[].class)) {\n      if (tolf == 0) {\n        return Arrays.equals((float[])x,(float[])y);\n      }\n else {\n        return floatArrayEquals((float[])x,(float[])y,(float)tolf);\n      }\n    }\n else     if (xClass.equals(byte[].class)) {\n      return Arrays.equals((byte[])x,(byte[])y);\n    }\n else     if (xClass.equals(short[].class)) {\n      return Arrays.equals((short[])x,(short[])y);\n    }\n else     if (xClass.equals(char[].class)) {\n      return Arrays.equals((char[])x,(char[])y);\n    }\n else     if (xClass.equals(boolean[].class)) {\n      return Arrays.equals((boolean[])x,(boolean[])y);\n    }\n else {\n      Object[] xo=(Object[])x;\n      Object[] yo=(Object[])y;\n      if (xo.length != yo.length) {\n        return false;\n      }\n      for (int i=0; i < xo.length; i+=1) {\n        if (!arrayEquals(xo[i],yo[i],tolf,told)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n", "docstring": "are two objects equal ? arrays have the standard object equals method which only returns true if the two object are the same . this method returns true if every element of the arrays match . the inputs may be of any dimensionality . the dimensionality and dimensions of the arrays must match as well as any elements . if the elements are non - primitive . non - tiledimageoperation objects , then the equals method is called for each element . if both elements are multi - dimensional arrays , then the method recurses .", "partition": "test"}
{"idx": "888", "code": "public Dictionary(Directory tempDir,String tempFileNamePrefix,InputStream affix,List<InputStream> dictionaries,boolean ignoreCase) throws IOException, ParseException {\n  this.ignoreCase=ignoreCase;\n  this.needsInputCleaning=ignoreCase;\n  this.needsOutputCleaning=false;\n  flagLookup.add(new BytesRef());\n  Path aff=Files.createTempFile(tempPath,\"affix\",\"aff\");\n  OutputStream out=new BufferedOutputStream(Files.newOutputStream(aff));\n  InputStream aff1=null;\n  InputStream aff2=null;\n  boolean success=false;\n  try {\n    final byte[] buffer=new byte[1024 * 8];\n    int len;\n    while ((len=affix.read(buffer)) > 0) {\n      out.write(buffer,0,len);\n    }\n    out.close();\n    aff1=new BufferedInputStream(Files.newInputStream(aff));\n    String encoding=getDictionaryEncoding(aff1);\n    CharsetDecoder decoder=getJavaEncoding(encoding);\n    aff2=new BufferedInputStream(Files.newInputStream(aff));\n    readAffixFile(aff2,decoder);\n    IntSequenceOutputs o=IntSequenceOutputs.getSingleton();\n    Builder<IntsRef> b=new Builder<>(FST.INPUT_TYPE.BYTE4,o);\n    readDictionaryFiles(tempDir,tempFileNamePrefix,dictionaries,decoder,b);\n    words=b.finish();\n    aliases=null;\n    morphAliases=null;\n    success=true;\n  }\n  finally {\n    IOUtils.closeWhileHandlingException(out,aff1,aff2);\n    if (success) {\n      Files.delete(aff);\n    }\n else {\n      IOUtils.deleteFilesIgnoringExceptions(aff);\n    }\n  }\n}\n", "docstring": "creates a new dictionary containing the information read from the provided inputstreams to hunspell affix and dictionary files . you have to close the provided inputstreams yourself .", "partition": "test"}
{"idx": "889", "code": "public void collapseBuilding(Building bldg){\n  buildings.removeElement(bldg);\n  Enumeration<Coords> bldgCoords=bldg.getCoords();\n  while (bldgCoords.hasMoreElements()) {\n    final Coords coords=bldgCoords.nextElement();\n    collapseBuilding(coords);\n  }\n}\n", "docstring": "the given building has collapsed . remove it from the board and replace it with rubble .", "partition": "test"}
{"idx": "890", "code": "@RpcMethod public void detachISO(String vmId,boolean isDeleteFile,AsyncMethodCallback<Host.AsyncClient.detach_iso_call> handler) throws RpcException {\n  ensureClient();\n  DetachISORequest detachISORequest=new DetachISORequest(vmId);\n  detachISORequest.setDelete_file(isDeleteFile);\n  clientProxy.setTimeout(DETACH_ISO_TIMEOUT_MS);\n  logger.info(\"detach_iso vm {}, target {}, request {}\",vmId,getHostIp(),detachISORequest);\n  try {\n    clientProxy.detach_iso(detachISORequest,handler);\n  }\n catch (  TException e) {\n    throw new RpcException(e.getMessage());\n  }\n}\n", "docstring": "this method performs an asynchronous thrift call to detach an iso from a vm . on completion , the specified handler is invoked .", "partition": "test"}
{"idx": "891", "code": "private String readNfcErrorMsg(ByteBuffer reply) throws IOException {\n  int errorType=reply.getInt();\n  int errorCode=reply.getInt();\n  int msgLen=reply.getInt();\n  if (msgLen == 0) {\n    return \"\";\n  }\n  ByteBuffer msgBuffer=ByteBuffer.allocate(msgLen);\n  readFully(msgBuffer);\n  String errorMsg=new String(msgBuffer.array(),0,msgLen - 1,Charsets.US_ASCII);\n  return String.format(\"NFC Error %d/%d: %s\",errorType,errorCode,errorMsg);\n}\n", "docstring": "read nfc error from reply message .", "partition": "test"}
{"idx": "892", "code": "private void show(boolean show){\n  if (show) {\n    if (mXFade != null) {\n      mXFade.cancel();\n    }\n    mState=STATE_PIE;\n    mCurrentItem=null;\n    PieItem root=getRoot();\n    for (    PieItem openItem : mOpen) {\n      if (openItem.hasItems()) {\n        for (        PieItem item : openItem.getItems()) {\n          item.setSelected(false);\n        }\n      }\n    }\n    mLabel.setText(\"\");\n    mOpen.clear();\n    mOpen.add(root);\n    layoutPie();\n    fadeIn();\n  }\n else {\n    mState=STATE_IDLE;\n    mTapMode=false;\n    if (mXFade != null) {\n      mXFade.cancel();\n    }\n    if (mLabel != null) {\n      mLabel.setText(\"\");\n    }\n  }\n  setVisible(show);\n  mHandler.sendEmptyMessage(show ? MSG_OPEN : MSG_CLOSE);\n}\n", "docstring": "guaranteed has center set", "partition": "test"}
{"idx": "893", "code": "private synchronized void persistProfileAndNotifyChange(AuthnProvider modifiedProvider,boolean newObject){\n  modifiedProvider.setLastModified(System.currentTimeMillis());\n  if (newObject) {\n    _dbClient.createObject(modifiedProvider);\n  }\n else {\n    _dbClient.persistObject(modifiedProvider);\n  }\n  notifyChange();\n}\n", "docstring": "update the timestamp and notify", "partition": "test"}
{"idx": "894", "code": "public void addUndoableAction(UndoableAction action){\n  undoStack.push(action);\n  redoStack.removeAllElements();\n}\n", "docstring": "add a new undoable action .", "partition": "test"}
{"idx": "895", "code": "public IntArrayList(int[] data){\n  array=new int[(int)(data.length * 1.1) + 1];\n  size=data.length;\n  System.arraycopy(data,0,array,0,size);\n}\n", "docstring": "constructs a list containing the elements of the specified array . the list instance has an initial capacity of 110 % the size of the specified array .", "partition": "test"}
{"idx": "896", "code": "private void addPingTimeData(long sample){\n  lastPingTimesLock.lock();\n  try {\n    if (lastPingTimes == null) {\n      lastPingTimes=new long[PING_MOVING_AVERAGE_WINDOW];\n      Arrays.fill(lastPingTimes,sample);\n    }\n else {\n      System.arraycopy(lastPingTimes,1,lastPingTimes,0,lastPingTimes.length - 1);\n      lastPingTimes[lastPingTimes.length - 1]=sample;\n    }\n  }\n  finally {\n    lastPingTimesLock.unlock();\n  }\n}\n", "docstring": "adds a ping time sample to the averaging window .", "partition": "test"}
{"idx": "897", "code": "public StringBuilder encodeBody(StringBuilder buffer){\n  return buffer.append(contentEncoding);\n}\n", "docstring": "canonical encoding of body of the header .", "partition": "test"}
{"idx": "898", "code": "protected void tearDown(){\n  try {\n    ds.close();\n    sds.close();\n  }\n catch (  Exception e) {\n  }\n}\n", "docstring": "tears down the fixture , for example , close a network connection . this method is called after a test is executed .", "partition": "test"}
{"idx": "899", "code": "public String substring(String subject,int start,int stop){\n  if (stop == -1 || stop >= subject.length()) {\n    return subject.substring(start);\n  }\n  return subject.substring(start,stop);\n}\n", "docstring": "get a substring from a string", "partition": "test"}
{"idx": "900", "code": "public boolean controlRunTrain(int idx){\n  if (log.isDebugEnabled()) {\n    log.debug(\"controlRunTrain= \" + idx + \" runMode= \"+ _runMode+ \" - warrant= \"+ getDisplayName());\n  }\n  boolean ret=true;\n  int oldIndex=-MODE_MANUAL;\n  if (_engineer == null) {\nswitch (idx) {\ncase HALT:\ncase RESUME:\ncase RETRY:\n      ret=false;\n    break;\ncase ABORT:\n  if (_runMode == Warrant.MODE_LEARN) {\n    firePropertyChange(\"abortLearn\",Integer.valueOf(-MODE_LEARN),Integer.valueOf(_idxCurrentOrder));\n  }\n else {\n    stopWarrant(true);\n  }\nbreak;\n}\n}\n else {\nsynchronized (_engineer) {\noldIndex=_engineer.getRunState();\nswitch (idx) {\ncase HALT:\n_engineer.setHalt(true);\nbreak;\ncase RESUME:\n_engineer.setHalt(false);\nrestart();\nret=moveIntoNextBlock(MID);\nbreak;\ncase RETRY:\nBlockOrder bo=getBlockOrderAt(_idxCurrentOrder + 1);\nret=false;\nif (bo != null) {\nOBlock b=bo.getBlock();\nif (b.allocate(this) == null && (b.getState() & OBlock.OCCUPIED) != 0) {\n_idxCurrentOrder++;\nif (b.equals(_stoppingBlock)) {\n_stoppingBlock.removePropertyChangeListener(this);\n_stoppingBlock=null;\n}\nbo.setPath(this);\nrestart();\ngoingActive(b);\nret=true;\n}\n}\nbreak;\ncase ABORT:\nstopWarrant(true);\nbreak;\n}\n}\n}\nif (ret) {\nfirePropertyChange(\"controlChange\",Integer.valueOf(oldIndex),Integer.valueOf(idx));\n}\nreturn ret;\n}\n", "docstring": "pause and resume auto - running train or abort any allocation state _engineer . abort ( ) calls setrunmode ( mode_none , . . . ) which calls deallocate all .", "partition": "test"}
{"idx": "901", "code": "public void removeCustomSashFormListener(ICustomSashFormListener listener){\n  if (customSashFormListeners != null) {\n    customSashFormListeners.remove(listener);\n  }\n}\n", "docstring": "removes the custom sashform listener .", "partition": "test"}
{"idx": "902", "code": "@Override public void close() throws IOException {\n  if (mBufferCount > 0) {\n    try {\n      mQueue.write(mBuffer,0,mBufferCount);\n    }\n catch (    InterruptedException e) {\n      throw new IOException(\"GzipAsynchOutputStream interrupted during write/3\");\n    }\n    mBufferCount=0;\n  }\n  mQueue.close();\n  try {\n    mThread.join();\n  }\n catch (  InterruptedException e) {\n    throw new IOException(\"AsynchOutputStream interrupted during close\");\n  }\n finally {\n    super.close();\n  }\n  checkException();\n}\n", "docstring": "this also io errors that happened in the gzip thread .", "partition": "test"}
{"idx": "903", "code": "public static int parseStringAsInt(String in) throws IndexParseFieldException {\n  try {\n    return Integer.parseInt(in);\n  }\n catch (  NumberFormatException e) {\n    throw new IndexParseFieldException(in,e);\n  }\n}\n", "docstring": "parses a string as a int .", "partition": "test"}
{"idx": "904", "code": "public void writeAll(ResultSet rs,boolean includeColumnNames,boolean trim) throws SQLException, IOException {\n  if (includeColumnNames) {\n    writeColumnNames(rs);\n  }\n  while (rs.next()) {\n    writeNext(resultService.getColumnValues(rs,trim));\n  }\n}\n", "docstring": "writes the entire resultset to a csv file . the caller is responsible for closing the resultset .", "partition": "test"}
{"idx": "905", "code": "public ZoneRulesBuilder addWindow(ZoneOffset standardOffset,LocalDateTime until,TimeDefinition untilDefinition){\n  Objects.requireNonNull(standardOffset,\"standardOffset\");\n  Objects.requireNonNull(until,\"until\");\n  Objects.requireNonNull(untilDefinition,\"untilDefinition\");\n  TZWindow window=new TZWindow(standardOffset,until,untilDefinition);\n  if (windowList.size() > 0) {\n    TZWindow previous=windowList.get(windowList.size() - 1);\n    window.validateWindowOrder(previous);\n  }\n  windowList.add(window);\n  return this;\n}\n", "docstring": "adds a window to the builder that can be used to filter a set of rules . < p > this method defines and adds a window to the zone where the standard offset is specified . the window limits the effect of subsequent additions of transition rules or fixed savings . if neither rules or fixed savings are added to the window then the window will default to no savings . < p > each window must be added sequentially , as the start instant of the window is derived from the until instant of the previous window .", "partition": "test"}
{"idx": "906", "code": "public Hashtable<IPoint,List<ILineSegment>> intersections(Iterator<ILineSegment> it){\n  Collection<ILineSegment> c=new ArrayList<ILineSegment>();\n  while (it.hasNext()) {\n    c.add(it.next());\n  }\n  return intersections(c.toArray(new ILineSegment[]{}));\n}\n", "docstring": "compute the intersection of all segments when given an iterator of segments .", "partition": "test"}
{"idx": "907", "code": "public boolean isTTFNativeFont(){\n  return ttf;\n}\n", "docstring": "indicates if this is a ttf native font that can be derived and manipulated . this is true for a font loaded from file ( ttf ) or using the native : font name", "partition": "test"}
{"idx": "908", "code": "private void registerProviders(){\n  final DevMachine devMachine=appContext.getDevMachine();\n  if (devMachine == null) {\n    return;\n  }\n  final Set<Macro> providers=getMacros(devMachine);\n  checkNotNull(providers);\n  if (providers.isEmpty()) {\n    return;\n  }\n  providerRegistry.register(providers);\n}\n", "docstring": "register macro providers which returns the implementation .", "partition": "test"}
{"idx": "909", "code": "protected void populateStreamBlob(int testId,byte[] baseContent,int requiredSize) throws SQLException {\n  final byte[] testBytes=generateBlobContent(baseContent,requiredSize);\n  try (FbDatabase db=createDatabaseConnection()){\n    listener=new SimpleStatementListener();\n    transaction=getTransaction(db);\n    try {\n      statement=db.createStatement(transaction);\n      statement.addStatementListener(listener);\n      final BlobParameterBuffer blobParameterBuffer=db.createBlobParameterBuffer();\n      blobParameterBuffer.addArgument(BlobParameterBuffer.TYPE,BlobParameterBuffer.TYPE_STREAM);\n      final FbBlob blob=db.createBlobForOutput(transaction,blobParameterBuffer);\n      blob.open();\n      int bytesWritten=0;\n      while (bytesWritten < testBytes.length) {\n        byte[] buffer=new byte[Math.min(blob.getMaximumSegmentSize(),testBytes.length - bytesWritten)];\n        System.arraycopy(testBytes,bytesWritten,buffer,0,buffer.length);\n        blob.putSegment(buffer);\n        bytesWritten+=buffer.length;\n      }\n      blob.close();\n      statement.prepare(INSERT_BLOB_TABLE);\n      final DatatypeCoder datatypeCoder=db.getDatatypeCoder();\n      FieldValue param1=new FieldValue(datatypeCoder.encodeInt(testId));\n      FieldValue param2=new FieldValue(datatypeCoder.encodeLong(blob.getBlobId()));\n      statement.execute(RowValue.of(param1,param2));\n      statement.close();\n    }\n  finally {\n      transaction.commit();\n    }\n  }\n }\n", "docstring": "populates a stream blob for testing .", "partition": "test"}
{"idx": "910", "code": "private static long signFromBit_antiCyclic(final double value){\n  return Double.doubleToRawLongBits(value) >> 62 | 1;\n}\n", "docstring": "redefined here , to avoid cyclic dependency with ( strict ) fastmath .", "partition": "test"}
{"idx": "911", "code": "public void addNearKey(KeyCacheObject key,GridCacheSharedContext ctx) throws IgniteCheckedException {\n  nearKeys.add(key);\n}\n", "docstring": "adds a near key .", "partition": "test"}
{"idx": "912", "code": "private void analyzeClassFields(String className,int action){\n  try {\n    Class<?> dynamicClass=Class.forName(className);\n    Field[] fields=dynamicClass.getDeclaredFields();\n    for (    Field field : fields) {\n      if (isPrivateAndNonPrimitive(field)) {\n        oneToAnyConditions(className,field,action);\n        manyToAnyConditions(className,field,action);\n      }\n    }\n  }\n catch (  ClassNotFoundException ex) {\n    ex.printStackTrace();\n    throw new DatabaseGenerateException(DatabaseGenerateException.CLASS_NOT_FOUND + className);\n  }\n}\n", "docstring": "introspection of the passed in class . analyze the fields of current class and find out the associations of it .", "partition": "test"}
{"idx": "913", "code": "public static void loadAll(final JFrame parent,final IDebugger debugger,final IAddress offset,final int size){\n  checkArguments(parent,debugger,offset);\n  final CDumpAllWaiter waiter=new CDumpAllWaiter(debugger,offset,size);\n  CProgressDialog.showEndless(parent,\"Loading memory\" + \" ...\",waiter);\n  if (waiter.getException() != null) {\n    CUtilityFunctions.logException(waiter.getException());\n    final String innerMessage=\"E00078: \" + \"Could not load memory section\";\n    final String innerDescription=CUtilityFunctions.createDescription(String.format(\"The memory section starting at address \'%s\' could not loaded.\",offset.toHexString()),new String[]{\"There was a problem with the connection to the debug client.\"},new String[]{\"The memory data was not loaded.\"});\n    NaviErrorDialog.show(parent,innerMessage,innerDescription,waiter.getException());\n  }\n}\n", "docstring": "loads all data of a memory section .", "partition": "test"}
{"idx": "914", "code": "public static boolean deleteDirectory(String directory,boolean useOSNativeDelete) throws IOException {\n  boolean result=false;\n  if (!useOSNativeDelete) {\n    File dir=new File(directory);\n    for (    File file : dir.listFiles()) {\n      if (file.delete()) {\n        log.debug(\"{} was deleted\",file.getName());\n      }\n else {\n        log.debug(\"{} was not deleted\",file.getName());\n        file.deleteOnExit();\n      }\n      file=null;\n    }\n    if (dir.delete()) {\n      log.debug(\"Directory was deleted\");\n      result=true;\n    }\n else {\n      log.debug(\"Directory was not deleted, it may be deleted on exit\");\n      dir.deleteOnExit();\n    }\n    dir=null;\n  }\n else {\n    Process p=null;\n    Thread std=null;\n    try {\n      Runtime runTime=Runtime.getRuntime();\n      log.debug(\"Execute runtime\");\n      if (File.separatorChar == \'\\\\\') {\n        p=runTime.exec(\"CMD /D /C \\\"RMDIR /Q /S \" + directory.replace(\'/\',\'\\\\\') + \"\\\"\");\n      }\n else {\n        p=runTime.exec(\"rm -rf \" + directory.replace(\'\\\\\',File.separatorChar));\n      }\n      std=stdOut(p);\n      while (std.isAlive()) {\n        try {\n          Thread.sleep(250);\n        }\n catch (        Exception e) {\n        }\n      }\n      log.debug(\"Process threads wait exited\");\n      result=true;\n    }\n catch (    Exception e) {\n      log.error(\"Error running delete script\",e);\n    }\n finally {\n      if (null != p) {\n        log.debug(\"Destroying process\");\n        p.destroy();\n        p=null;\n      }\n      std=null;\n    }\n  }\n  return result;\n}\n", "docstring": "deletes a directory and its contents . this will fail if there are any file locks or if the directory cannot be emptied .", "partition": "test"}
{"idx": "915", "code": "public static String findEditTable(String tables){\n  if (!StringUtils.isEmpty(tables)) {\n    int spacepos=tables.indexOf(\' \');\n    int commapos=tables.indexOf(\',\');\n    if (spacepos > 0 && (spacepos < commapos || commapos < 0)) {\n      return tables.substring(0,spacepos);\n    }\n else     if (commapos > 0 && (commapos < spacepos || spacepos < 0)) {\n      return tables.substring(0,commapos);\n    }\n    return tables;\n  }\n else {\n    throw new IllegalStateException(\"Invalid tables\");\n  }\n}\n", "docstring": "finds the name of the first table , which is editable .", "partition": "test"}
{"idx": "916", "code": "public void writeOperationsCarFile(){\n  makeBackupFile(defaultOperationsFilename());\n  try {\n    if (!checkFile(defaultOperationsFilename())) {\n      java.io.File file=new java.io.File(defaultOperationsFilename());\n      java.io.File parentDir=file.getParentFile();\n      if (!parentDir.exists()) {\n        if (!parentDir.mkdir()) {\n          log.error(\"Directory wasn\'t created\");\n        }\n      }\n      if (file.createNewFile()) {\n        log.debug(\"File created\");\n      }\n    }\n    writeFile(defaultOperationsFilename());\n  }\n catch (  Exception e) {\n    log.error(\"Exception while writing the new CSV operations file, may not be complete: \" + e);\n  }\n}\n", "docstring": "store the all of the operation car objects in the default place , including making a backup if needed", "partition": "test"}
{"idx": "917", "code": "private boolean hasNewFollowers(List<Follower> followers){\n  return !followers.isEmpty() && followers.get(0).newFollower;\n}\n", "docstring": "checks if this has new followers . only checks the first follower in the list , because followers at the end might be new , even though they actually are not ( if someone unfollows , older followers might show up for the first time this session ) .", "partition": "test"}
{"idx": "918", "code": "private void onTrackPointElementStart(Attributes attributes) throws SAXException {\n  String latitude=attributes.getValue(ATT_LAT);\n  String longitude=attributes.getValue(ATT_LON);\n  if (latitude == null || longitude == null) {\n    throw new SAXException(createErrorMessage(\"Point with no longitude or latitude.\"));\n  }\n  try {\n    latitudeValue=Double.parseDouble(latitude);\n    longitudeValue=Double.parseDouble(longitude);\n  }\n catch (  NumberFormatException e) {\n    throw new SAXException(createErrorMessage(\"Unable to parse latitude/longitude: \" + latitude + \"/\"+ longitude),e);\n  }\n}\n", "docstring": "on track point element start .", "partition": "test"}
{"idx": "919", "code": "protected final void firePropertyChange(PropertyChangeEvent evt){\n  pcs.firePropertyChange(evt);\n}\n", "docstring": "fire an existing propertychangeevent to any registered listeners . no event is fired if the given event \"'\" s old and new values are equal and non - null .", "partition": "test"}
{"idx": "920", "code": "public static void sortFields(FieldBinding[] sortedFields,int left,int right){\n  Arrays.sort(sortedFields,left,right,FIELD_COMPARATOR);\n}\n", "docstring": "sort the field array using a quicksort", "partition": "test"}
{"idx": "921", "code": "private void drawBackground(final Graphics g){\n  g.setColor(m_bgColorOffset);\n  g.fillRect(-m_firstColumn * m_charWidth,0,m_offsetViewWidth,getHeight());\n}\n", "docstring": "draws the background of the view .", "partition": "test"}
{"idx": "922", "code": "public void addUniqueAttribute(final String elementName,final String attrName){\n  if ((elementName != null) && (attrName != null)) {\n    _uniqueElementAttrMap.put(elementName,attrName);\n  }\n}\n", "docstring": "add unique attribute to the element which will force elements to be identical .", "partition": "test"}
{"idx": "923", "code": "private static DeleteVmResponse checkDeleteVmResponse(DeleteVmResponse deleteVmResponse) throws RpcException {\n  logger.info(\"Checking {}\",deleteVmResponse);\nswitch (deleteVmResponse.getResult()) {\ncase OK:\n    break;\ncase SYSTEM_ERROR:\n  throw new SystemErrorException(deleteVmResponse.getError());\ncase VM_NOT_FOUND:\nthrow new VmNotFoundException(deleteVmResponse.getError());\ncase VM_NOT_POWERED_OFF:\nthrow new VmNotPoweredOffException(deleteVmResponse.getError());\ndefault :\nthrow new RpcException(String.format(\"Unknown response: %s\",deleteVmResponse.getResult()));\n}\nreturn deleteVmResponse;\n}\n", "docstring": "this method validates a deletevmresponse object , raising an exception if the response reflects an operation failure .", "partition": "test"}
{"idx": "924", "code": "public BlazeValueFactory valueFactory(){\n  return vf;\n}\n", "docstring": "return the factory used to round - trip between tinkerpop values and rdf values .", "partition": "test"}
{"idx": "925", "code": "public StatefulRefreshToken(JsonValue token) throws InvalidGrantException {\n  super(token);\n  if (!OAUTH_REFRESH_TOKEN.equals(getTokenName())) {\n    throw new InvalidGrantException(\"Token is not an refresh token: \" + getTokenId());\n  }\n}\n", "docstring": "constructs a new refreshtoken backed with the data in the specified jsonvalue .", "partition": "test"}
{"idx": "926", "code": "public void putStyle(String styleId,StyleSelector styleSelector){\n  try {\n    int id=Integer.parseInt(styleId);\n    mMaxStyleId=Math.max(mMaxStyleId,id);\n  }\n catch (  NumberFormatException e) {\n  }\n  mStyles.put(styleId,styleSelector);\n}\n", "docstring": "put the styleselector ( style or stylemap ) in the list of shared styles , associated to its styleid", "partition": "test"}
{"idx": "927", "code": "private static String extractClientName(String clientId,String host){\n  String hostExcludedId=\"\";\n  if ((isIPv6(host) || isIPv4(host)) && clientId.startsWith(host)) {\n    hostExcludedId=clientId.substring(host.length());\n  }\n else {\n    int firstDotIndex=host.indexOf(\".\");\n    if (firstDotIndex != -1) {\n      String hostShortName=host.substring(0,firstDotIndex);\n      hostExcludedId=clientId.substring(hostShortName.length());\n    }\n  }\n  String vmPIDAndKindRegex=\"\\\\(\\\\w+:\\\\w+\\\\)\";\n  String regex=\"(\\\\<ec\\\\>)?:[0-9]+(:\\\\w+){2}+\";\n  String name=NOT_AVAILABLE;\n  String temp=hostExcludedId;\n  int openIndex=temp.indexOf(\"(\");\n  if (openIndex != -1) {\n    regex=vmPIDAndKindRegex + regex;\n  }\n  if (temp.matches(regex)) {\n    String[] splitted=temp.split(\":\");\n    name=splitted[splitted.length - 1];\n  }\n  return name;\n}\n", "docstring": "excludes the host name from the client id and returns the string . if the host name can not be detected , returns an empty string . typically , the client id looks like : host ( vm_pid : vm_kind ) : port : random_string : client_name extracts the client name from the client id . if the client id is not in the expected format , returns \"'\" n / a \"'\"", "partition": "test"}
{"idx": "928", "code": "public static <T>FastFuture<T> fromCompletableFuture(final CompletableFuture<T> cf){\n  final FastFuture<T> f=new FastFuture<>();\n  cf.thenAccept(null);\n  cf.exceptionally(null);\n  return f;\n}\n", "docstring": "internal conversion method to convert completablefutures to fastfuture .", "partition": "test"}
{"idx": "929", "code": "public static boolean isPlaceAction(InventoryAction action){\nswitch (action) {\ncase SWAP_WITH_CURSOR:\ncase PLACE_ONE:\ncase PLACE_ALL:\ncase PLACE_SOME:\n    return true;\n}\nreturn false;\n}\n", "docstring": "check if a given inventoryaction involves placing items into the slot .", "partition": "test"}
{"idx": "930", "code": "public static byte[] readInputStream(InputStream i) throws IOException {\n  ByteArrayOutputStream b=new ByteArrayOutputStream();\n  copy(i,b);\n  return b.toByteArray();\n}\n", "docstring": "converts a small input stream to a byte array", "partition": "test"}
{"idx": "931", "code": "public void playMedia(boolean showPlayerWindow){\n  String filename=stopAndPrepareFilename();\n  if (filename.length() > 0) {\n    MPlayerMediator mplayerMediator=MPlayerMediator.instance();\n    if (mplayerMediator != null) {\n      mplayerMediator.showPlayerWindow(showPlayerWindow);\n    }\n    mplayer.open(filename,getAdjustedVolume());\n  }\n  notifyState(getState());\n}\n", "docstring": "force showing or not the media player window", "partition": "test"}
{"idx": "932", "code": "public static String toUTF8String(String s){\n  return new String(s.getBytes(),Charset.forName(PanboxConstants.STANDARD_CHARSET));\n}\n", "docstring": "string conversion into standard charset", "partition": "test"}
{"idx": "933", "code": "public static int encodeCacheFlags(Collection<GridClientCacheFlag> flagSet){\n  int bits=0;\n  if (flagSet.contains(GridClientCacheFlag.SKIP_STORE))   bits|=1;\n  return bits;\n}\n", "docstring": "encodes cache flags to bit map .", "partition": "test"}
{"idx": "934", "code": "public void add(DataSource source,boolean visible){\n  add(data.size(),source,visible);\n}\n", "docstring": "adds a new data series to the plot .", "partition": "test"}
{"idx": "935", "code": "@Override public void addValue(double value,double weight){\n  m_WeightedSum+=value * weight;\n  m_WeightedSumSquared+=value * value * weight;\n  m_SumOfWeights+=weight;\n  if (m_TM.get(value) == null) {\n    m_TM.put(value,weight);\n  }\n else {\n    m_TM.put(value,m_TM.get(value) + weight);\n  }\n}\n", "docstring": "adds a value to the density estimator .", "partition": "test"}
{"idx": "936", "code": "private static synchronized String formatAndParse(SimpleDateFormat formatDate,SimpleDateFormat parseDate,String text){\n  try {\n    Date date=parseDate.parse(text);\n    String result=formatDate.format(date);\n    return result;\n  }\n catch (  ParseException e) {\n    logger.warning(\"Unable to parse:\" + text);\n  }\n  return \"\";\n}\n", "docstring": "synchronized because simpledatformat aren \"'\" t thread safe", "partition": "test"}
{"idx": "937", "code": "private void throwArrayIndexOutOfBoundsException(int itemIndex){\n  throw new ArrayIndexOutOfBoundsException(\"Your item index can\'t be 0 or greater than space item size,\" + \" your items size is \" + spaceItems.size() + \", your current index is :\"+ itemIndex);\n}\n", "docstring": "throw array index out of bounds exception", "partition": "test"}
{"idx": "938", "code": "private LocusInfo createNextUncoveredLocusInfo(final Locus stopBeforeLocus){\n  while (lastReferenceSequence <= stopBeforeLocus.getSequenceIndex() && lastReferenceSequence <= referenceSequenceMask.getMaxSequenceIndex()) {\n    if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex() && lastPosition + 1 >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n    final int nextbit=referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition);\n    if (nextbit == -1) {\n      if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex()) {\n        lastPosition=stopBeforeLocus.getPosition();\n        return null;\n      }\n      lastReferenceSequence++;\n      lastPosition=0;\n    }\n else     if (lastReferenceSequence < stopBeforeLocus.getSequenceIndex() || nextbit < stopBeforeLocus.getPosition()) {\n      lastPosition=nextbit;\n      return new LocusInfo(getReferenceSequence(lastReferenceSequence),lastPosition);\n    }\n else     if (nextbit >= stopBeforeLocus.getPosition()) {\n      return null;\n    }\n  }\n  return null;\n}\n", "docstring": "create the next relevant zero - coverage locusinfo", "partition": "test"}
{"idx": "939", "code": "public void globalConfigChanged(String serviceName,String version,String groupName,String serviceComponent,int changeType){\n}\n", "docstring": "this method will be invoked when a service \"'\" s global configuation data has been changed . the parameter groupname denote the name of the configuration grouping ( e . g . default ) and servicecomponent denotes the service \"'\" s sub - component that changed", "partition": "test"}
{"idx": "940", "code": "public static void launchEmailIntent(final Activity activity,String addr,String text){\n  Log.i(LOG_TAG,\"Launch email intent from \" + activity.getLocalClassName());\n  Intent emailIntent=new Intent(Intent.ACTION_SEND);\n  emailIntent.putExtra(Intent.EXTRA_EMAIL,new String[]{addr});\n  emailIntent.setType(\"text/plain\");\n  PackageManager emailpackageManager=activity.getPackageManager();\n  List<ResolveInfo> emailresolveInfos=emailpackageManager.queryIntentActivities(emailIntent,0);\n  if (emailresolveInfos.size() > 0) {\n    activity.startActivity(emailIntent);\n  }\n}\n", "docstring": "launch an email intent if the device is capable .", "partition": "test"}
{"idx": "941", "code": "public int count(){\n  return n;\n}\n", "docstring": "returns the number of data values .", "partition": "test"}
{"idx": "942", "code": "public void writeLEChars(String s) throws IOException {\n  int length=s.length();\n  for (int i=0; i < length; i++) {\n    int c=s.charAt(i);\n    out.write(c & 0xFF);\n    out.write((c >>> 8) & 0xFF);\n  }\n  written+=length * 2;\n}\n", "docstring": "writes a string in little endian", "partition": "test"}
{"idx": "943", "code": "public void writeToFile(String filename){\n  GridUtils.writeSpatialGridTable(this,filename);\n}\n", "docstring": "just for debugging convenience", "partition": "test"}
{"idx": "944", "code": "public void addFooterView(View v,Object data,boolean isSelectable){\n  FixedViewInfo info=new FixedViewInfo();\n  info.view=v;\n  info.data=data;\n  info.isSelectable=isSelectable;\n  mFooterViewInfos.add(info);\n  if (mAdapter != null && mDataSetObserver != null) {\n    mDataSetObserver.onChanged();\n  }\n}\n", "docstring": "add a fixed view to appear at the bottom of the list . if addfooterview is called more than once , the views will appear in the order they were added . views added using this call can take focus if they want . < p > note : call this before calling setadapter . this is so listview can wrap the supplied cursor with one that will also account for header and footer views .", "partition": "test"}
{"idx": "945", "code": "public void readConfig(String filename) throws FileNotFoundException {\n  if (filename == null || filename.equals(\"\"))   return;\n  readConfig(new FileReader(filename));\n}\n", "docstring": "read the specified file and parse the configuration .", "partition": "test"}
{"idx": "946", "code": "private void applyTradingBonus(Player player){\n  player.incrementTradescore();\n}\n", "docstring": "rewards player for a successfull trade", "partition": "test"}
{"idx": "947", "code": "private static void createCombinedTrace(final TraceList newTrace,final List<TraceList> traces,final Set<BreakpointAddress> addresses){\n  final Set<BreakpointAddress> visitedAddresses=new LinkedHashSet<BreakpointAddress>();\n  for (  final TraceList trace : traces) {\n    for (    final ITraceEvent event : trace) {\n      final BreakpointAddress address=event.getOffset();\n      if (!addresses.contains(address)) {\n        continue;\n      }\n      if (visitedAddresses.contains(address)) {\n        continue;\n      }\n      visitedAddresses.add(address);\n      newTrace.addEvent(event);\n    }\n  }\n}\n", "docstring": "fills a combined trace from the events of multiple input traces .", "partition": "test"}
{"idx": "948", "code": "public void interruptAll(){\nsynchronized (knownActorTasks) {\n    for (    Future<Void> ft : knownActorTasks) {\n      ft.cancel(true);\n    }\n    threadGuard.interruptAll();\n  }\n}\n", "docstring": "ensure that any guarded regions are interrupted .", "partition": "test"}
{"idx": "949", "code": "@SuppressWarnings(\"unchecked\") public void registerDefaultDeviceTypes(){\n  final HashMap<String,String> devicesList=DefaultPlatform.getDeviceServiceMap();\n  for (  HashMap.Entry<String,String> entry : devicesList.entrySet()) {\n    String key=entry.getKey();\n    String value=entry.getValue();\n    try {\n      registerDeviceService((Class<DeviceService>)Class.forName(key),(Class<DiscoveryProvider>)Class.forName(value));\n    }\n catch (    ClassNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "registers a commonly - used set of deviceservices with discoverymanager . this method will be called on first call of startdiscovery if no deviceservices have been registered . - castdiscoveryprovider + castservice - ssdpdiscoveryprovider + dialservice + dlnaservice ( limited to lg tvs , currently ) + netcasttvservice + rokuservice + webostvservice + multiscreenservice - zeroconfdiscoveryprovider + airplayservice", "partition": "test"}
{"idx": "950", "code": "private static void removeDependencySubsets(String swcLocation,Map<String,Set<String>> dependencyMap,SwcDependencyInfoImpl depInfo){\n  Set<String> removeSet=new HashSet<String>();\n  SwcExternalScriptInfo externalInfo=depInfo.getSwcExternalScriptInfo(swcLocation);\n  Map<String,Set<String>> externalsBySwc=new HashMap<String,Set<String>>();\n  for (  String swcDependLocation : dependencyMap.get(swcLocation)) {\n    for (    String swcDependLocation2 : dependencyMap.get(swcLocation)) {\n      if (swcDependLocation.equals(swcDependLocation2))       continue;\n      Set<String> externalScripts=externalsBySwc.get(swcDependLocation);\n      Set<String> externalScripts2=externalsBySwc.get(swcDependLocation2);\n      if (externalScripts == null) {\n        externalScripts=externalInfo.getExternalScripts(swcDependLocation);\n        externalsBySwc.put(swcDependLocation,externalScripts);\n      }\n      if (externalScripts2 == null) {\n        externalScripts2=externalInfo.getExternalScripts(swcDependLocation2);\n        externalsBySwc.put(swcDependLocation2,externalScripts2);\n      }\n      if (externalScripts2.size() > externalScripts.size() && externalScripts2.containsAll(externalScripts)) {\n        removeSet.add(swcDependLocation);\n        break;\n      }\n    }\n  }\n  Set<String> dependencySet=dependencyMap.get(swcLocation);\n  dependencySet.removeAll(removeSet);\n}\n", "docstring": "look at the dependency information and remove swc dependencies that are subsets of other swc dependencies .", "partition": "test"}
{"idx": "951", "code": "public void testFindSpringOpenLdap(){\n  LdapProxy proxy=getLdapOpenLdap();\n  List result=null;\n  try {\n    result=proxy.find(getLdapSearchVO(\"\",LdapConstants.NO_SEARCH_LIMIT,null,null,null,LdapScopeConstants.SCOPE_SUBTREE));\n  }\n catch (  Exception e) {\n  }\n  assertNotNull(result);\n  assertEquals(4,result.size());\n}\n", "docstring": "test de busqueda open ldap", "partition": "test"}
{"idx": "952", "code": "public void delete(SSOToken token,String dn) throws SMSException, SSOException {\n  for (  String entry : subEntries(token,dn,\"*\",0,false,false)) {\n    debug.message(\"SMSLdapObject: deleting sub-entry: {}\",entry);\n    delete(token,getNamingAttribute() + \"=\" + entry+ \",\"+ dn);\n  }\n  for (  String subOrg : searchSubOrgNames(token,dn,\"*\",0,false,false,false)) {\n    debug.message(\"SMSLdapObject: deleting suborganization: {}\",subOrg);\n    delete(token,subOrg);\n  }\n  delete(token.getPrincipal(),dn);\n  objectChanged(dn,DELETE);\n}\n", "docstring": "delete the entry in the directory . this will delete sub - entries also !", "partition": "test"}
{"idx": "953", "code": "private static <T extends AbstractBlockBase<T>>void enqueueSuccessors(T block,PriorityQueue<T> worklist,BitSet visitedBlocks){\n  for (  T successor : block.getSuccessors()) {\n    if (!visitedBlocks.get(successor.getId())) {\n      visitedBlocks.set(successor.getId());\n      worklist.add(successor);\n    }\n  }\n}\n", "docstring": "add successor blocks into the given work list if they are not already marked as visited .", "partition": "test"}
{"idx": "954", "code": "public void addRole(String role){\n  if (role != null) {\n    roles.add(role);\n  }\n}\n", "docstring": "add a role to this user .", "partition": "test"}
{"idx": "955", "code": "public CModulesCheckBoxPanel(final CModulesTableModel modulesTableModel){\n  super(new BorderLayout());\n  final JCheckBox checkBox=new JCheckBox(\"Show full module paths\");\n  checkBox.addItemListener(new InternalCheckboxListener());\n  add(checkBox);\n  m_modulesTableModel=modulesTableModel;\n}\n", "docstring": "creates the checkbox panel to control if full paths should be shown in the modules table .", "partition": "test"}
{"idx": "956", "code": "public QDate(){\n  this(_gmtTimeZone);\n}\n", "docstring": "creates the date for gmt .", "partition": "test"}
{"idx": "957", "code": "protected void responseSent(StreamResponseMessage responseMessage){\n  if (syncProtocol != null)   syncProtocol.responseSent(responseMessage);\n}\n", "docstring": "must be called by a subclass after the response has been successfully sent to the client .", "partition": "test"}
{"idx": "958", "code": "protected Tuple<BlobStoreIndexShardSnapshots,Integer> buildBlobStoreIndexShardSnapshots(Map<String,BlobMetaData> blobs){\n  int latest=-1;\n  for (  String name : blobs.keySet()) {\n    if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {\n      try {\n        int gen=Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()));\n        if (gen > latest) {\n          latest=gen;\n        }\n      }\n catch (      NumberFormatException ex) {\n        logger.warn(\"failed to parse index file name [{}]\",name);\n      }\n    }\n  }\n  if (latest >= 0) {\n    try {\n      return new Tuple<>(indexShardSnapshotsFormat.read(blobContainer,Integer.toString(latest)),latest);\n    }\n catch (    IOException e) {\n      logger.warn(\"failed to read index file  [{}]\",e,SNAPSHOT_INDEX_PREFIX + latest);\n    }\n  }\n  List<SnapshotFiles> snapshots=new ArrayList<>();\n  for (  String name : blobs.keySet()) {\n    try {\n      BlobStoreIndexShardSnapshot snapshot=null;\n      if (name.startsWith(SNAPSHOT_PREFIX)) {\n        snapshot=indexShardSnapshotFormat.readBlob(blobContainer,name);\n      }\n else       if (name.startsWith(LEGACY_SNAPSHOT_PREFIX)) {\n        snapshot=indexShardSnapshotLegacyFormat.readBlob(blobContainer,name);\n      }\n      if (snapshot != null) {\n        snapshots.add(new SnapshotFiles(snapshot.snapshot(),snapshot.indexFiles()));\n      }\n    }\n catch (    IOException e) {\n      logger.warn(\"failed to read commit point [{}]\",e,name);\n    }\n  }\n  return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots),-1);\n}\n", "docstring": "loads all available snapshots in the repository", "partition": "test"}
{"idx": "959", "code": "protected MapleQuestRequirement(MapleQuest quest,ReadBin data) throws IOException {\n  this.quest=quest;\n  this.dayByDay=data.readByte() > 0;\n  this.normalAutoStart=data.readByte() > 0;\n  this.lvmin=data.readShort();\n  this.lvmax=data.readShort();\n  this.mbmin=data.readShort();\n  this.charismaMin=data.readShort();\n  this.charmMin=data.readShort();\n  this.craftMin=data.readShort();\n  this.insightMin=data.readShort();\n  this.senseMin=data.readShort();\n  this.willMin=data.readShort();\n  this.pop=data.readShort();\n  this.pettamenessmin=data.readShort();\n  this.subJobFlag=data.readShort();\n  this.npc=data.readInt();\n  this.interval=data.readInt();\n  this.end=data.readString();\n  this.startscript=data.readString();\n  this.endscript=data.readString();\n  short size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int field=data.readInt();\n    fieldEnter.add(field);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    short job=data.readShort();\n    jobs.add(job);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    boolean acquire=data.readByte() > 0;\n    skills.put(id,acquire);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    byte state=data.readByte();\n    byte order=data.readByte();\n    quests.put(id,state);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    int count=data.readInt();\n    byte order=data.readByte();\n    items.put(id,count);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    int count=data.readInt();\n    mobs.put(id,count);\n  }\n  size=data.readShort();\n  for (int i=0; i < size; i++) {\n    int id=data.readInt();\n    pets.add(id);\n  }\n}\n", "docstring": "creates a new instance of maplequestrequirement .", "partition": "test"}
{"idx": "960", "code": "public boolean isArmed(){\n  return other.isArmed();\n}\n", "docstring": "all these methods simply delegate to the \" other \" model that is being decorated .", "partition": "test"}
{"idx": "961", "code": "public static AttribKey forHtmlAttrib(ElKey el,String localName){\n  return new AttribKey(el,HTML_NS,localName);\n}\n", "docstring": "looks up an attribute key by element and local name .", "partition": "test"}
{"idx": "962", "code": "SparseArray(Class<L> linearArrayType,int[] rowIndices,int[] colIndices,L realValues,L imagValues,int numRows,int numCols){\n  validateUserSuppliedParameters(linearArrayType,rowIndices,colIndices,realValues,imagValues);\n  _baseComponentType=linearArrayType.getComponentType();\n  _outputArrayType=(Class<L[]>)ArrayUtils.getArrayClass(_baseComponentType,2);\n  Map<SparseKey,SparseValue> sparseMap=createSparseMap(linearArrayType,rowIndices,colIndices,realValues,imagValues,numRows,numCols);\n  _numRows=numRows;\n  _numCols=numCols;\n  ArrayList<SparseKey> keys=new ArrayList<SparseKey>(sparseMap.keySet());\n  Collections.sort(keys);\n  _rowIndices=new int[keys.size()];\n  _colIndices=new int[keys.size()];\n  _linearIndices=new int[keys.size()];\n  _realValues=linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  _imagValues=imagValues == null ? null : linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  for (int i=0; i < keys.size(); i++) {\n    SparseKey key=keys.get(i);\n    _rowIndices[i]=key.row;\n    _colIndices[i]=key.col;\n    _linearIndices[i]=key.linearIndex;\n    SparseValue value=sparseMap.get(key);\n    setSparseValue(value,_realValues,_imagValues,i);\n  }\n}\n", "docstring": "data provided by a user ; this data needs to be validated and processed .", "partition": "test"}
{"idx": "963", "code": "protected void updateRadioLinks(){\n  m_CVBut.setEnabled(true);\n  m_CVText.setEnabled(m_CVBut.isSelected());\n  m_CVLab.setEnabled(m_CVBut.isSelected());\n  m_SeedText.setEnabled(m_CVBut.isSelected());\n  m_SeedLab.setEnabled(m_CVBut.isSelected());\n  if (m_AttributeEvaluatorEditor.getValue() instanceof AttributeTransformer) {\n    m_CVBut.setSelected(false);\n    m_CVBut.setEnabled(false);\n    m_CVText.setEnabled(false);\n    m_CVLab.setEnabled(false);\n    m_SeedText.setEnabled(false);\n    m_SeedLab.setEnabled(false);\n    m_TrainBut.setSelected(true);\n  }\n}\n", "docstring": "updates the enabled status of the input fields and labels .", "partition": "test"}
{"idx": "964", "code": "private String idString(int id1,int id2){\n  return \"0x\" + Integer.toHexString(id2 & 0x7F) + \" 0x\"+ Integer.toHexString(id1 & 0x7F)+ \" (\"+ ((id2 & 0x7F) * 128 + (id1 & 0x7F))+ \")\";\n}\n", "docstring": "convert throttle id to a human friendly format .", "partition": "test"}
{"idx": "965", "code": "public EtagCache resetStats(){\n  hits.set(0);\n  misses.set(0);\n  return this;\n}\n", "docstring": "reset stats tracked for cache hits and misses", "partition": "test"}
{"idx": "966", "code": "public void testOtherToStringDefault(){\n  NumberConverter converter=makeConverter();\n  assertEquals(\"Default Convert \",\"ABC\",converter.convert(String.class,new StringBuffer(\"ABC\")));\n}\n", "docstring": "convert other - - > string ( default conversion )", "partition": "test"}
{"idx": "967", "code": "private void showFilterDialog(Filter filter){\n  int sortOrder=mAdapter.getCount() - 1;\n  if (filter == null) {\n    EditFilterActivity.createNewFilter(getActivity(),sortOrder);\n  }\n else {\n    EditFilterActivity.editFilter(getActivity(),filter,sortOrder);\n  }\n}\n", "docstring": "shows the filter dialog", "partition": "test"}
{"idx": "968", "code": "public static int numPixelsBetween(int x1,int y1,int x2,int y2){\n  return (int)Math.sqrt(Math.pow((double)(x1 - x2),2.0) + Math.pow((double)(y1 - y2),2.0));\n}\n", "docstring": "little math utility that both tools use , that just implements the pythagorean theorem to do the number of pixels between two screen points .", "partition": "test"}
{"idx": "969", "code": "static boolean allowsPopup(FormObject formObject){\nswitch (formObject.getParameterConstant(PdfDictionary.Subtype)) {\ncase PdfDictionary.Text:\ncase PdfDictionary.Square:\ncase PdfDictionary.Highlight:\ncase PdfDictionary.Underline:\ncase PdfDictionary.StrickOut:\ncase PdfDictionary.Stamp:\n    return true;\ndefault :\n  return false;\n}\n}\n", "docstring": "utility method to check if formobject should have a popup", "partition": "test"}
{"idx": "970", "code": "public static LocalGitRepo fromCurrentDir(String remoteUrl) throws ValidationException {\n  Git git;\n  File gitDir=new File(\".\");\n  try {\n    git=Git.open(gitDir);\n  }\n catch (  RepositoryNotFoundException rnfe) {\n    String fullPathOfCurrentDir=pathOf(gitDir);\n    File gitRoot=getGitRootIfItExistsInOneOfTheParentDirectories(new File(fullPathOfCurrentDir));\n    String summary;\n    List<String> messages=new ArrayList<String>();\n    if (gitRoot == null) {\n      summary=\"Releases can only be performed from Git repositories.\";\n      messages.add(summary);\n      messages.add(fullPathOfCurrentDir + \" is not a Git repository.\");\n    }\n else {\n      summary=\"The release plugin can only be run from the root folder of your Git repository\";\n      messages.add(summary);\n      messages.add(fullPathOfCurrentDir + \" is not the root of a Gir repository\");\n      messages.add(\"Try running the release plugin from \" + pathOf(gitRoot));\n    }\n    throw new ValidationException(summary,messages);\n  }\ncatch (  Exception e) {\n    throw new ValidationException(\"Could not open git repository. Is \" + pathOf(gitDir) + \" a git repository?\",Arrays.asList(\"Exception returned when accessing the git repo:\",e.toString()));\n  }\n  return new LocalGitRepo(git,remoteUrl);\n}\n", "docstring": "uses the current working dir to open the git repository .", "partition": "test"}
{"idx": "971", "code": "public static Vector2 min(Vector2 o1,Vector2 o2){\n  return new Vector2(Math.min(o1.x,o2.x),Math.min(o1.z,o2.z));\n}\n", "docstring": "returns a vector2 containing the smallest x and y values .", "partition": "test"}
{"idx": "972", "code": "public void addTestCall(GenericAccessibleObject<?> call) throws IllegalArgumentException {\n  Inputs.checkNull(call);\n  testMethods.add(call);\n}\n", "docstring": "add a test call", "partition": "test"}
{"idx": "973", "code": "public void serialize(KXmlSerializer serializer) throws IOException {\n  mDeviceInfo.serialize(serializer);\n  serializeHostInfo(serializer);\n  serializeTestSummary(serializer);\n  monkeyTag.serialize(serializer);\n  List<TestPackageResult> pkgs=new ArrayList<TestPackageResult>(mPackageMap.values());\n  Collections.sort(pkgs,new PkgComparator());\n  for (  TestPackageResult r : pkgs) {\n    r.serialize(serializer);\n  }\n}\n", "docstring": "serialize the test results to xml .", "partition": "test"}
{"idx": "974", "code": "private void verifyBlockMirrorMigration() throws Exception {\n  log.info(\"Verifying BlockMirror migration.\");\n  Iterator<BlockMirror> blockMirrorItr=_dbClient.queryIterativeObjects(BlockMirror.class,blockMirrorURIs);\n  List<BlockObject> blockObjects=new ArrayList<BlockObject>();\n  while (blockMirrorItr.hasNext()) {\n    blockObjects.add(blockMirrorItr.next());\n  }\n  verifyBlockObjects(blockObjects);\n}\n", "docstring": "verify the blockmirror objects have been migrated correctly .", "partition": "test"}
{"idx": "975", "code": "public LogFormatter(Logger log){\n  if (log == null)   log=Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n  Level lvl=null;\n  while (log != null) {\n    lvl=log.getLevel();\n    if (lvl != null)     break;\n    log=log.getParent();\n  }\n  ;\n  if (lvl == null)   lvl=Level.WARNING;\n  this.level=lvl;\n}\n", "docstring": "create a log formatter around a given logger . if null , uses the global logger .", "partition": "test"}
{"idx": "976", "code": "private Element createIDPEntityDescriptor(boolean exportPrivateData) throws Exception {\n  Element entEle=doc.createElementNS(null,SAMLNames.ENTDESCRIPTOR);\n  String id=idmClient.getEntityID(tenantName);\n  String alias=idmClient.getLocalIDPAlias(tenantName);\n  if (id == null) {\n    id=tenantName;\n  }\n  entEle.setAttribute(SAMLNames.ENTID,id);\n  Element idpSSO=createIDPSSODescriptor(exportPrivateData);\n  entEle.appendChild(idpSSO);\n  if (exportPrivateData) {\n    if (alias == null || alias.isEmpty()) {\n      alias=id;\n    }\n    Element orgEle=createOrganization(tenantName,tenantName,alias,SAMLNames.ENGLISH);\n    entEle.appendChild(orgEle);\n  }\n  return entEle;\n}\n", "docstring": "create extension element of entitydescriptor in dom .", "partition": "test"}
{"idx": "977", "code": "public void clear(){\n  infoQueue.clear();\n  while (!dataQueue.isEmpty()) {\n    allocator.release(dataQueue.remove());\n  }\n  totalBytesDropped=0;\n  totalBytesWritten=0;\n  lastAllocation=null;\n  lastAllocationOffset=allocationLength;\n}\n", "docstring": "clears the buffer , returning all allocations to the allocator .", "partition": "test"}
{"idx": "978", "code": "public void applyCamera(GL2 gl){\n  gl.glMatrixMode(GL2.GL_PROJECTION);\n  gl.glLoadIdentity();\n  glu.gluPerspective(45f,width / (float)height,0.f,10.f);\n  eye[0]=(float)Math.sin(theta) * 2.f;\n  eye[1]=.5f;\n  eye[2]=(float)Math.cos(theta) * 2.f;\n  glu.gluLookAt(eye[0],eye[1],eye[2],.0f,.0f,0.f,0.f,1.f,0.f);\n  gl.glMatrixMode(GL2.GL_MODELVIEW);\n  gl.glLoadIdentity();\n  gl.glViewport(0,0,width,height);\n}\n", "docstring": "apply the camera settings .", "partition": "test"}
{"idx": "979", "code": "public static ResultSet pointTable(double x,double y){\n  GeometryFactory factory=new GeometryFactory();\n  SimpleResultSet rs=new SimpleResultSet();\n  rs.addColumn(\"THE_GEOM\",Types.JAVA_OBJECT,\"GEOMETRY\",0,0);\n  rs.addRow(factory.createPoint(new Coordinate(x,y)));\n  return rs;\n}\n", "docstring": "this method is called via reflection from the database .", "partition": "test"}
{"idx": "980", "code": "public void addToExistingVolumesIfAbsent(Map<String,Integer> volumeWWNs){\n  if (_existingVolumes == null) {\n    _existingVolumes=new StringMap();\n  }\n  for (  String wwn : volumeWWNs.keySet()) {\n    String normalizedWWN=BlockObject.normalizeWWN(wwn);\n    if (!_existingVolumes.containsKey(normalizedWWN) && (_userAddedVolumes == null || !_userAddedVolumes.containsKey(normalizedWWN))) {\n      String hluStr=ExportGroup.LUN_UNASSIGNED_STR;\n      Integer hlu=volumeWWNs.get(normalizedWWN);\n      if (hlu != null) {\n        hluStr=hlu.toString();\n      }\n      _existingVolumes.put(normalizedWWN,hluStr);\n    }\n  }\n}\n", "docstring": "this method will add to the existing volumes list only those members that don \"'\" t already exist in either the existing or user - created volume list .", "partition": "test"}
{"idx": "981", "code": "public PathImpl createTempFile(String prefix,String suffix) throws IOException {\n  if (prefix == null || prefix.length() == 0)   prefix=\"t\";\n  if (suffix == null)   suffix=\".tmp\";\nsynchronized (LOCK) {\n    for (int i=0; i < 32768; i++) {\n      int r=Math.abs((int)RandomUtil.getRandomLong());\n      PathImpl file=lookup(prefix + r + suffix);\n      if (file.createNewFile())       return file;\n    }\n  }\n  throw new IOException(\"cannot create temp file\");\n}\n", "docstring": "creates a unique temporary file as a child of this directory .", "partition": "test"}
{"idx": "982", "code": "static Map<TargetType,List<TypeCompound>> partitionByTargetType(Collection<TypeCompound> annos,List<TypeCompound> unmatched,TargetType... targetTypes){\n  final Map<TargetType,List<TypeCompound>> targetTypeToAnnos=new HashMap<>();\n  for (  TargetType targetType : targetTypes) {\n    targetTypeToAnnos.put(targetType,new ArrayList<TypeCompound>(10));\n  }\n  for (  final TypeCompound anno : annos) {\n    final List<TypeCompound> annoSet=targetTypeToAnnos.get(anno.getPosition().type);\n    if (annoSet != null) {\n      annoSet.add(anno);\n    }\n else     if (unmatched != null) {\n      unmatched.add(anno);\n    }\n  }\n  return targetTypeToAnnos;\n}\n", "docstring": "use a map to partition annotations with the given targettypes into lists , where each target type is a key in the output map . any annotation that does not have one of these target types will be added to unmatched", "partition": "test"}
{"idx": "983", "code": "public void load(){\n  try {\n    if (fileChannel == null) {\n      fileChannel=FileChannel.open(path,StandardOpenOption.READ);\n    }\n    fileChannel.position(0L);\n    buffer.clear();\n    tmp.clear();\n    while (fileChannel.read(tmp) > 0) {\n      tmp.flip();\n      if (tmp.remaining() > buffer.capacity() - buffer.position()) {\n        final ByteBuffer next=ByteBuffer.allocateDirect(Math.max(buffer.capacity() * 2,tmp.remaining()));\n        buffer.flip();\n        next.put(buffer);\n        buffer=next;\n      }\n      buffer.put(tmp);\n      tmp.clear();\n    }\n    buffer.flip();\n  }\n catch (  final IOException e) {\n    throw new UncheckedIOException(e);\n  }\n}\n", "docstring": "opens a channel to the specified path if it does not already exist . allocates a larger bytebuffer if file size & gt ; current buffer size . reads file data into bytebuffer .", "partition": "test"}
{"idx": "984", "code": "private void onHPChange(final int amount){\n  if (User.squaredDistanceTo(x,y) < HEARING_DISTANCE_SQ) {\n    if (amount > 0) {\n      addTextIndicator(\"+\" + amount,NotificationType.POSITIVE);\n    }\n else {\n      addTextIndicator(String.valueOf(amount),NotificationType.NEGATIVE);\n    }\n  }\n}\n", "docstring": "called when entity adjusts hp .", "partition": "test"}
{"idx": "985", "code": "@NotNull private File resolveName(@NotNull String name) throws IOException {\n  File file;\n  if (name.startsWith(ROOT)) {\n    file=new File(myTemplateRootFolder,name.substring(ROOT.length()));\n  }\n else   if (myLastTemplateFolders != null) {\n    file=new File(myLastTemplateFolders.peek(),name);\n  }\n else {\n    file=new File(myTemplateRootFolder,name);\n  }\n  return file.getCanonicalFile();\n}\n", "docstring": "resolve a freemarker name reference .", "partition": "test"}
{"idx": "986", "code": "public void initToolTip(){\n  if (ttmanager == null) {\n    ttmanager=ToolTipManager.sharedInstance();\n    ttmanager.registerComponent(map);\n    ttmanager.setEnabled(true);\n    return;\n  }\n  if (map != null) {\n    map.setToolTipText(null);\n  }\n}\n", "docstring": "this method should be called to initialize the tooltip status so that an old tooltip doesn \"'\" t remain when a layer starts listening to mouse events .", "partition": "test"}
{"idx": "987", "code": "public static String[] decodeArray(String encodedArray){\n  String[] items=encodedArray.split(\"_\\\\.\");\n  ArrayList<String> list=new ArrayList<String>();\n  for (int i=0; i < items.length; i++) {\n    String item=items[i];\n    item=gsub(\"__\",\"_\",item);\n    if (!item.equals(\"\")) {\n      list.add(item);\n    }\n  }\n  return list.toArray(new String[list.size()]);\n}\n", "docstring": "decodes a string generated by encodearray .", "partition": "test"}
{"idx": "988", "code": "private void sendResource(final UUID uuid,final Object resource,final long length,final InputStream is) throws IOException {\n  assert uuid != null;\n  assert resource != null;\n  assert length >= 0;\n  assert is != null;\n  assert !sentStatus;\n  long bytesWritten=0L;\n  final long begin=System.nanoTime();\n  final OutputStream os=s.getOutputStream();\n  try {\n{\n      final DataOutputStream dos=new DataOutputStream(os);\n      dos.write(new byte[]{StatusEnum.OK.get()});\n      dos.writeLong(length);\n      dos.flush();\n      bytesWritten+=1 + Bytes.SIZEOF_LONG;\n      sentStatus=true;\n    }\n    final long checksum;\n{\n      final int BUFSIZE=Bytes.kilobyte32 * 2;\n      final CheckedInputStream cis=new CheckedInputStream(new BufferedInputStream(is),new Adler32());\n      final byte[] buff=new byte[BUFSIZE];\n      while (true) {\n        final int read=cis.read(buff,0,BUFSIZE);\n        if (read <= 0)         break;\n        os.write(buff,0,read);\n        bytesWritten+=read;\n      }\n      checksum=cis.getChecksum().getValue();\n    }\n{\n      final DataOutputStream dos=new DataOutputStream(os);\n      dos.writeLong(checksum);\n      bytesWritten+=Bytes.SIZEOF_LONG;\n      dos.flush();\n    }\n    os.flush();\n    if (log.isInfoEnabled())     log.info(\"Sent: uuid=\" + uuid + \", resource=\"+ resource+ \", length=\"+ length+ \", checksum=\"+ checksum+ \", elapsed=\"+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin)+ \"ms\");\n  }\n  finally {\n    try {\n      os.close();\n    }\n catch (    Throwable t) {\n    }\n    counters.bytesWritten.add(bytesWritten);\n    counters.elapsedWriteNanos.add(System.nanoTime() - begin);\nsynchronized (counters.maxWriteSizeLock) {\n      counters.maxWriteSize=Math.max(counters.maxWriteSize,bytesWritten);\n    }\n  }\n}\n", "docstring": "sends given resource to the socket .", "partition": "test"}
{"idx": "989", "code": "public long sigignore(){\n  return Long.parseLong(fields[32]);\n}\n", "docstring": "the bitmap of ignored signals , displayed as a decimal number . obsolete , because it does not provide information on real - time signals ; use / proc / [ pid ", "partition": "test"}
{"idx": "990", "code": "private static byte[] generateSeed(){\n  try {\n    final ByteArrayOutputStream seedBuffer=new ByteArrayOutputStream();\n    final DataOutputStream seedBufferOut=new DataOutputStream(seedBuffer);\n    seedBufferOut.writeLong(System.currentTimeMillis());\n    seedBufferOut.writeLong(System.nanoTime());\n    seedBufferOut.writeInt(Process.myPid());\n    seedBufferOut.writeInt(Process.myUid());\n    seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);\n    seedBufferOut.close();\n    return seedBuffer.toByteArray();\n  }\n catch (  final IOException e) {\n    throw new SecurityException(\"Failed to generate seed\",e);\n  }\n}\n", "docstring": "generates a device - and invocation - specific seed to be mixed into the linux prng .", "partition": "test"}
{"idx": "991", "code": "public String render(ValueExpr theExpr) throws Exception {\n  theExpr.visit(this);\n  return mBuffer.toString();\n}\n", "docstring": "return the rendering of the valueexpr object", "partition": "test"}
{"idx": "992", "code": "public void stopSampling(){\n  if (mSamplingCounter.decrementAndGet() == 0) {\n    mHandler.stopSamplingThread();\n    addFinalSample();\n  }\n}\n", "docstring": "finish sampling and prevent further changes to the connectionclass until another timer is started .", "partition": "test"}
{"idx": "993", "code": "public DSignCsr(JFrame parent,PKCS10CertificationRequest pkcs10Csr,File csrFile,PrivateKey signPrivateKey,KeyPairType signKeyPairType,X509Certificate verificationCertificate,Provider provider) throws CryptoException {\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  this.pkcs10Csr=pkcs10Csr;\n  this.csrFile=csrFile;\n  this.signPrivateKey=signPrivateKey;\n  this.signKeyPairType=signKeyPairType;\n  this.verificationCertificate=verificationCertificate;\n  this.provider=provider;\n  setTitle(res.getString(\"DSignCsr.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dsigncsr dialog for a pkcs # 10 formatted csr .", "partition": "test"}
{"idx": "994", "code": "public static String parseVolumeHostDirectory(String volume){\n  if (StringUtils.isEmpty(volume)) {\n    return volume;\n  }\n  if (!volume.contains(HOST_CONTAINER_DIR_DELIMITER)) {\n    return volume;\n  }\n  String[] hostContainerDir=volume.split(HOST_CONTAINER_DIR_DELIMITER);\n  if (hostContainerDir.length != 2) {\n    throw new IllegalArgumentException(\"Invalid volume directory.\");\n  }\n  String hostDir=hostContainerDir[0];\n  return hostDir;\n}\n", "docstring": "parses volume host directory only .", "partition": "test"}
{"idx": "995", "code": "private String fmtTime(double time){\n  return Utilities.pad(timeFormatter.format(time) + \"s\",10);\n}\n", "docstring": "formats times into a standard format .", "partition": "test"}
{"idx": "996", "code": "public static String right(String s,int width,char fillChar){\n  if (s.length() >= width) {\n    return s;\n  }\n  StringBuffer sb=new StringBuffer(width);\n  for (int i=width - s.length(); --i >= 0; ) {\n    sb.append(fillChar);\n  }\n  sb.append(s);\n  return sb.toString();\n}\n", "docstring": "right justify a string .", "partition": "test"}
{"idx": "997", "code": "public synchronized boolean addAll(Collection<? extends E> c){\n  modCount++;\n  Object[] a=c.toArray();\n  int numNew=a.length;\n  ensureCapacityHelper(elementCount + numNew);\n  System.arraycopy(a,0,elementData,elementCount,numNew);\n  elementCount+=numNew;\n  return numNew != 0;\n}\n", "docstring": "appends all of the elements in the specified collection to the end of this vector , in the order that they are returned by the specified collection \"'\" s iterator . the behavior of this operation is undefined if the specified collection is modified while the operation is in progress . ( this implies that the behavior of this call is undefined if the specified collection is this vector , and this vector is nonempty . )", "partition": "test"}
{"idx": "998", "code": "@Override public void update(DefaultApplicationState transState){\n  newCheckpoint(transState.getState(),transState.getStateHash(),transState.getLastCheckpointCID());\n  setLastCheckpointCID(transState.getLastCheckpointCID());\n}\n", "docstring": "updates this log , according to the information contained in the transferablestate object", "partition": "test"}
{"idx": "999", "code": "private List<Pair<String,Object>> toPairList(final Map<String,Object> bindings){\n  final List<Pair<String,Object>> blist=new ArrayList<Pair<String,Object>>();\n  for (  final Map.Entry<String,Object> pair : bindings.entrySet()) {\n    blist.add(new Pair<String,Object>(pair.getKey(),pair.getValue()));\n  }\n  return blist;\n}\n", "docstring": "converts a hash map of bindings to a list of binding pairs .", "partition": "test"}
{"idx": "1000", "code": "public void addMessageObserver(final MessageObserver observer){\n  if (observer == null) {\n    throw new NullPointerException();\n  }\n else   if (messageObservers == null) {\n    initMessageObserverList();\n  }\n  messageObservers.add(observer);\n}\n", "docstring": "adds the specified message observer .", "partition": "test"}
{"idx": "1001", "code": "public void show(char initialChar){\n  initialString=initialString.append(initialChar);\n  show();\n  if (SWT.getPlatform() != \"carbon\") {\n    setEditText(initialString.toString());\n  }\n}\n", "docstring": "performs show and sets the edit string to be the initial character or string", "partition": "test"}
{"idx": "1002", "code": "private static void byte2hex(byte b,StringBuffer buf){\n  int high=((b & 0xf0) >> 4);\n  int low=(b & 0x0f);\n  buf.append(HEX_DIGITS[high]);\n  buf.append(HEX_DIGITS[low]);\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "1003", "code": "public E remove(int index){\n  hashCodeUpToDate=false;\n  modCount++;\n  E oldValue=elementData(index);\n  int numMoved=size - index - 1;\n  if (numMoved > 0)   System.arraycopy(elementData,index + 1,elementData,index,numMoved);\n  elementData[--size]=null;\n  return oldValue;\n}\n", "docstring": "removes the element at the specified position in this list . shifts any subsequent elements to the left ( subtracts one from their indices ) .", "partition": "test"}
{"idx": "1004", "code": "public static DoubleVector rnorm(int n,double mean,double sd,Random random){\n  if (sd < 0.0)   throw new IllegalArgumentException(\"standard deviation < 0.0\");\n  if (sd == 0.0)   return new DoubleVector(n,mean);\n  DoubleVector v=new DoubleVector(n);\n  for (int i=0; i < n; i++)   v.set(i,(random.nextGaussian() + mean) / sd);\n  return v;\n}\n", "docstring": "generates a sample of a normal distribution .", "partition": "test"}
{"idx": "1005", "code": "private PdfObject readCompressedStream(PdfObject rootObj,int pointer,final PdfFileReader currentPdfFile,final ObjectReader objectReader,final PdfObject linearObj) throws PdfException {\n  while (pointer != -1) {\n    movePointer(pointer);\n    final byte[] raw=objectReader.readObjectData(-1,null);\n    final StringBuilder objectName=new StringBuilder();\n    char current1, last=' ';\n    int matched=0, i1=0;\n    while (i1 < raw.length) {\n      current1=(char)raw[i1];\n      if (current1 == 10 || current1 == 13) {\n        current1=' ';\n      }\n      if (current1 == ' ' && last == ' ') {\n        matched=0;\n      }\n else       if (current1 == pattern.charAt(matched)) {\n        matched++;\n      }\n else {\n        matched=0;\n        objectName.append(current1);\n      }\n      if (matched == 3) {\n        break;\n      }\n      last=current1;\n      i1++;\n    }\n    objectName.append('R');\n    final PdfObject pdfObject=new CompressedObject(objectName.toString());\n    pdfObject.setCompressedStream(true);\n    final ObjectDecoder objectDecoder=new ObjectDecoder(currentPdfFile);\n    objectDecoder.readDictionaryAsObject(pdfObject,0,raw);\n    final int[] fieldSizes=pdfObject.getIntArray(PdfDictionary.W);\n    byte[] xrefs=pdfObject.getDecodedStream();\n    if (xrefs == null) {\n      xrefs=currentPdfFile.readStream(pdfObject,true,true,false,false,true,null);\n    }\n    final int[] Index=pdfObject.getIntArray(PdfDictionary.Index);\n    if (Index == null) {\n      CompressedObjects.readCompressedOffsets(0,0,pdfObject.getInt(PdfDictionary.Size),fieldSizes,xrefs,offset,pdf_datafile);\n    }\n else {\n      final int count=Index.length;\n      int pntr=0;\n      for (int aa=0; aa < count; aa+=2) {\n        pntr=CompressedObjects.readCompressedOffsets(pntr,Index[aa],Index[aa + 1],fieldSizes,xrefs,offset,pdf_datafile);\n      }\n    }\n    if (rootObj == null) {\n      rootObj=pdfObject.getDictionary(PdfDictionary.Root);\n      encryptObj=pdfObject.getDictionary(PdfDictionary.Encrypt);\n      if (encryptObj != null) {\n        final byte[][] IDs=pdfObject.getStringArray(PdfDictionary.ID);\n        if (IDs != null && this.ID == null) {\n          this.ID=IDs[0];\n        }\n      }\n      infoObject=pdfObject.getDictionary(PdfDictionary.Info);\n    }\n    if (linearObj != null) {\n      pointer=-1;\n    }\n else {\n      pointer=pdfObject.getInt(PdfDictionary.Prev);\n      if (pointer != -1 && !isCompressedStream(pointer,(int)eof)) {\n        return readLegacyReferenceTable(rootObj,pointer,(int)eof,currentPdfFile);\n      }\n    }\n  }\n  return rootObj;\n}\n", "docstring": "read 1 . 5 compression stream ref table", "partition": "test"}
{"idx": "1006", "code": "protected void warningOccurred(int code){\n  cbLock.lock();\n  try {\n    if ((code < 0) || (code > MAX_WARNING)) {\n      throw new InternalError(\"Invalid warning index\");\n    }\n    processWarningOccurred(\"com.sun.imageio.plugins.jpeg.JPEGImageReaderResources\",Integer.toString(code));\n  }\n  finally {\n    cbLock.unlock();\n  }\n}\n", "docstring": "called by the native code or other classes to signal a warning . the code is used to lookup a localized message to be used when sending warnings to listeners .", "partition": "test"}
{"idx": "1007", "code": "public boolean isKnownSub(String subName){\n  return KNOWN_SUBS.contains(subName);\n}\n", "docstring": "checks if sub is indexed .", "partition": "test"}
{"idx": "1008", "code": "public boolean isStored(){\n  return Integer.signum(id) != -1;\n}\n", "docstring": "determines whether the view was previously stored to the database .", "partition": "test"}
{"idx": "1009", "code": "public boolean isSearchLightBit(int bit){\n  if (nodeType != SMINI) {\n    log.error(\"Invalid query of Searchlights bits - not SMINI node\");\n    return (false);\n  }\n  if ((bit < 0) || (bit > 47)) {\n    log.error(\"Invalid bit number in query of SMINI Searchlights bits: \" + Integer.toString(bit));\n    return (false);\n  }\n  if (locSearchLightBits[bit] == 1) {\n    return (true);\n  }\n  return (false);\n}\n", "docstring": "query searchlightbits by bit number ( smini only ) bit - bitnumber of the either bit of an oscillating search light bit pair note : returns \"'\" true \"'\" if bit is an oscillating searchlightbit , otherwise \"'\" false \"'\" is returned", "partition": "test"}
{"idx": "1010", "code": "public void calcMajorTick(){\n  majorTick=10;\n  majorTickCount=(int)Math.round(log10(maxTick / minTick)) + 1;\n}\n", "docstring": "calculate the optimum major tick distance .", "partition": "test"}
{"idx": "1011", "code": "public void put(String sample,HiddenAttribute attribute,Object value){\n  put(sample,attribute.toString(),value);\n}\n", "docstring": "put a value in the table", "partition": "test"}
{"idx": "1012", "code": "void postMessage(List<JetstreamMessage> msgs,DispatchQueueStats stats) throws MessageServiceException {\n  m_msgRcvCounter.addAndGet(msgs.size());\n  if ((monitorUpstreamQueueAndPauseTraffic() == UpstreamQueueState.FULL) && (m_paused.get())) {\n    if (!m_msgProcessor.hasAvailableCapacity(m_twentyPercentCapacity)) {\n      m_totalMsgsDropped.increment();\n      return;\n    }\n  }\n  List<Runnable> requests=new ArrayList<Runnable>(msgs.size());\n  for (int i=0, t=msgs.size(); i < t; i++) {\n    JetstreamMessage tm=msgs.get(i);\n    if (tm.getTopic() == null) {\n      m_totalMsgsDropped.increment();\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"Topic is not present in incoming message\");\n      }\n      continue;\n    }\n    MessageServiceRequest msr=new MessageServiceRequest(tm);\n    msr.setPriority(tm.getPriority());\n    msr.setSequenceid(tm.getSequenceId());\n    if (msr.getPriority() == JetstreamMessage.INTERNAL_MSG_PRIORITY) {\n      if (!m_internalMsgProcessor.processRequest(msr)) {\n        m_totalMsgsDropped.increment();\n        throw new MessageServiceException(MessageServiceException.BUFFER_FULL,\"Dispatch Queue Full\");\n      }\n      if (m_msgsRcvdPerSec.addAndGet(1) < 0)       m_msgsRcvdPerSec.set(0);\n      m_totalMsgsRcvd.increment();\n    }\n else {\n      requests.add(msr);\n    }\n  }\n  if (!requests.isEmpty()) {\n    int batchsize=requests.size();\n    if (!m_msgProcessor.processBatch(requests)) {\n      m_totalMsgsDropped.addAndGet(batchsize);\n      throw new MessageServiceException(MessageServiceException.BUFFER_FULL,\"High Priority Dispatch Queue Full - \" + \" Requested capacity = \" + batchsize + \" : available capacity = \"+ m_msgProcessor.getAvailableCapacity());\n    }\n    m_avgMsgsRcvdPerSec.add(batchsize);\n    m_totalMsgsRcvd.addAndGet(batchsize);\n  }\n  if (stats != null) {\n    stats.setHighPriorityQueueDepth((int)m_msgProcessor.getPendingRequests());\n    stats.setLowPriorityQueueDepth((int)m_msgProcessor.getPendingRequests());\n    stats.setMaxQueueDepth((int)m_msgProcessor.getMaxQueueSz());\n  }\n}\n", "docstring": "post a batch of messages .", "partition": "test"}
{"idx": "1013", "code": "public boolean unsetOrdering(Object first,Object second){\n  DigraphNode firstPONode=(DigraphNode)poNodes.get(first);\n  DigraphNode secondPONode=(DigraphNode)poNodes.get(second);\n  return firstPONode.removeEdge(secondPONode) || secondPONode.removeEdge(firstPONode);\n}\n", "docstring": "removes any ordering between two nodes .", "partition": "test"}
{"idx": "1014", "code": "public String convertSWFToHTML(InputStream in) throws Exception {\n  StringWriter out1=new StringWriter();\n  output=new PrintWriter(out1);\n  TagParser parser=new TagParser(this);\n  SWFReader reader=new SWFReader(parser,in);\n  reader.readFile();\n  in.close();\n  sizeCount=reader.size;\n  final String ret=\"<html>\" + (headerstr.isEmpty() ? \"<body>\" : \"<header>\" + headerstr + \"</header><body>\") + out1.toString()+ \"</body></html>\";\n  return ret;\n}\n", "docstring": "parses swf input and extracts text and wrap it as html", "partition": "test"}
{"idx": "1015", "code": "public Shape greatCircleLineShape(){\n  GeneralPath path=null;\n  if (llpts != null && llpts.length >= 4 && llpts.length % 2 == 0) {\n    double y1=llpts[0];\n    double x1=llpts[1];\n    path=new GeneralPath(GeneralPath.WIND_EVEN_ODD,llpts.length / 2);\n    boolean firstCoords=true;\n    for (int i=2; i < llpts.length; i+=2) {\n      double y2=llpts[i];\n      double x2=llpts[i + 1];\n      double radDist=GreatCircle.sphericalDistance(y1,x1,y2,x2);\n      int nsegs=(int)(ProjMath.radToDeg(radDist) * segsPerDeg);\n      if (nsegs == 0) {\n        nsegs=1;\n      }\n      double[] coords=GreatCircle.greatCircle(y1,x1,y2,x2,nsegs,false);\n      if (returnDegrees) {\n        ProjMath.arrayRadToDeg(coords);\n      }\n      for (int j=0; j <= coords.length - 1; j+=2) {\n        if (firstCoords) {\n          path.moveTo(coords[j + 1],coords[j]);\n          firstCoords=false;\n        }\n else {\n          path.lineTo(coords[j + 1],coords[j]);\n        }\n      }\n      x1=x2;\n      y1=y2;\n    }\n    if (returnDegrees) {\n      path.lineTo(ProjMath.radToDeg(x1),ProjMath.radToDeg(y1));\n    }\n else {\n      path.lineTo(x1,y1);\n    }\n  }\n  return path;\n}\n", "docstring": "create a java . awt . shape object of coordinates connected by great circle lines .", "partition": "test"}
{"idx": "1016", "code": "public Connection(final InetSocketAddress peerAddress){\n  this(peerAddress,(Handshaker)null);\n}\n", "docstring": "creates a new connection to a given peer .", "partition": "test"}
{"idx": "1017", "code": "protected static Vector convertToVector(final Object[] anArray){\n  if (anArray == null) {\n    return null;\n  }\n  final Vector v=new Vector(anArray.length);\n  for (  final Object element : anArray) {\n    v.addElement(element);\n  }\n  return v;\n}\n", "docstring": "returns a vector that contains the same objects as the array .", "partition": "test"}
{"idx": "1018", "code": "protected synchronized void notifyVersion(SprogVersion v){\n  ver=v;\n  for (  SprogVersionListener listener : getCopyOfListeners()) {\n    try {\n      listener.notifyVersion(ver);\n      versionListeners.remove(listener);\n    }\n catch (    Exception e) {\n      log.warn(\"notify: During dispatch to \" + listener + \"\\nException \"+ e);\n    }\n  }\n}\n", "docstring": "notify all registered listeners of the sprog version", "partition": "test"}
{"idx": "1019", "code": "protected void acceptDrop(int dropOperation){\n  DropTargetContextPeer peer=getDropTargetContextPeer();\n  if (peer != null) {\n    peer.acceptDrop(dropOperation);\n  }\n}\n", "docstring": "called to signal that the drop is acceptable using the specified operation . must be called during droptargetlistener . drop method invocation . < p >", "partition": "test"}
{"idx": "1020", "code": "@Override public String toString(){\n  String result;\n  result=super.toString();\n  if (m_CapabilitiesFilter != null) {\n    initCapabilities();\n    if (m_Capabilities != null) {\n      if (m_Capabilities.supportsMaybe(m_CapabilitiesFilter) && !m_Capabilities.supports(m_CapabilitiesFilter)) {\n        result=\"<html><font color=\\\"\" + MAYBE_SUPPORT + \"\\\">\"+ result+ \"</font></i><html>\";\n      }\n else       if (!m_Capabilities.supports(m_CapabilitiesFilter)) {\n        result=\"<html><font color=\\\"\" + NO_SUPPORT + \"\\\">\"+ result+ \"</font></i><html>\";\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "returns a string representation of this treenode .", "partition": "test"}
{"idx": "1021", "code": "public void splitNode(KDTreeNode node,int numNodesCreated,double[][] nodeRanges,double[][] universe) throws Exception {\n  correctlyInitialized();\n  if (node.m_NodesRectBounds == null) {\n    node.m_NodesRectBounds=new double[2][node.m_NodeRanges.length];\n    for (int i=0; i < node.m_NodeRanges.length; i++) {\n      node.m_NodesRectBounds[MIN][i]=node.m_NodeRanges[i][MIN];\n      node.m_NodesRectBounds[MAX][i]=node.m_NodeRanges[i][MAX];\n    }\n  }\n  double maxRectWidth=Double.NEGATIVE_INFINITY, maxPtWidth=Double.NEGATIVE_INFINITY, tempval;\n  int splitDim=-1, classIdx=m_Instances.classIndex();\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval > maxRectWidth && node.m_NodeRanges[i][WIDTH] > 0.0)     maxRectWidth=tempval;\n  }\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval >= maxRectWidth * (1 - ERR) && node.m_NodeRanges[i][WIDTH] > 0.0) {\n      if (node.m_NodeRanges[i][WIDTH] > maxPtWidth) {\n        maxPtWidth=node.m_NodeRanges[i][WIDTH];\n        if (m_NormalizeNodeWidth)         maxPtWidth=maxPtWidth / universe[i][WIDTH];\n        splitDim=i;\n      }\n    }\n  }\n  double splitVal=node.m_NodesRectBounds[MIN][splitDim] + (node.m_NodesRectBounds[MAX][splitDim] - node.m_NodesRectBounds[MIN][splitDim]) * 0.5;\n  if (splitVal < node.m_NodeRanges[splitDim][MIN])   splitVal=node.m_NodeRanges[splitDim][MIN];\n else   if (splitVal >= node.m_NodeRanges[splitDim][MAX])   splitVal=node.m_NodeRanges[splitDim][MAX] - node.m_NodeRanges[splitDim][WIDTH] * 0.001;\n  int rightStart=rearrangePoints(m_InstList,node.m_Start,node.m_End,splitDim,splitVal);\n  if (rightStart == node.m_Start || rightStart > node.m_End) {\n    if (rightStart == node.m_Start)     throw new Exception(\"Left child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n else     throw new Exception(\"Right child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n  }\n  node.m_SplitDim=splitDim;\n  node.m_SplitValue=splitVal;\n  double[][] widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MAX][splitDim]=splitVal;\n  node.m_Left=new KDTreeNode(numNodesCreated + 1,node.m_Start,rightStart - 1,m_EuclideanDistance.initializeRanges(m_InstList,node.m_Start,rightStart - 1),widths);\n  widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MIN][splitDim]=splitVal;\n  node.m_Right=new KDTreeNode(numNodesCreated + 2,rightStart,node.m_End,m_EuclideanDistance.initializeRanges(m_InstList,rightStart,node.m_End),widths);\n}\n", "docstring": "splits a node into two based on the midpoint value of the dimension in which the node \"'\" s rectangle is widest . if after splitting one side is empty then it is slided towards the non - empty side until there is at least one point on the empty side . the two nodes created after the whole splitting are correctly initialised . and , node . left and node . right are set appropriately .", "partition": "test"}
{"idx": "1022", "code": "public Date modifiedDate(String path) throws IllegalStateException, IOException, FTPIllegalReplyException, FTPException {\nsynchronized (lock) {\n    if (!connected) {\n      throw new IllegalStateException(\"Client not connected\");\n    }\n    if (!authenticated) {\n      throw new IllegalStateException(\"Client not authenticated\");\n    }\n    communication.sendFTPCommand(\"MDTM \" + path);\n    FTPReply r=communication.readFTPReply();\n    touchAutoNoopTimer();\n    if (!r.isSuccessCode()) {\n      throw new FTPException(r);\n    }\n    String[] messages=r.getMessages();\n    if (messages.length != 1) {\n      throw new FTPIllegalReplyException();\n    }\n else {\n      try {\n        return MDTM_DATE_FORMAT.parse(messages[0]);\n      }\n catch (      ParseException e) {\n        throw new FTPIllegalReplyException();\n      }\n    }\n  }\n}\n", "docstring": "this method asks and returns the last modification date of a file or directory .", "partition": "test"}
{"idx": "1023", "code": "public boolean importPkcs8(){\n  return jrbPkcs8.isSelected();\n}\n", "docstring": "has the user chosen to import from pkcs # 8 private key and certificate file combination ?", "partition": "test"}
{"idx": "1024", "code": "public ControlFlowGraph run(CompilationUnitTree root,ProcessingEnvironment env,MethodTree tree,ClassTree classTree){\n  UnderlyingAST underlyingAST=new CFGMethod(tree,classTree);\n  return run(root,env,underlyingAST);\n}\n", "docstring": "build the control flow graph of a method .", "partition": "test"}
{"idx": "1025", "code": "private boolean isValidEngine(){\n  if (hasFlag(~(CLAN_ENGINE | TANK_ENGINE | LARGE_ENGINE| SUPERHEAVY_ENGINE| SUPPORT_VEE_ENGINE))) {\n    problem.append(\"Flags:\" + engineFlags);\n    return false;\n  }\n  if (hasFlag(SUPPORT_VEE_ENGINE) && (engineType != STEAM) && (engineType != COMBUSTION_ENGINE)&& (engineType != BATTERY)&& (engineType != FUEL_CELL)&& (engineType != SOLAR)&& (engineType != FISSION)&& (engineType != NORMAL_ENGINE)&& (engineType != NONE)) {\n    problem.append(\"Invalid Engine type for support vehicle engines!\");\n    return false;\n  }\n  if ((((int)Math.ceil(engineRating / 5) > ENGINE_RATINGS.length) || (engineRating < 0)) && !hasFlag(SUPPORT_VEE_ENGINE)) {\n    problem.append(\"Rating:\" + engineRating);\n    return false;\n  }\n  if ((engineRating > 400) && !hasFlag(SUPPORT_VEE_ENGINE)) {\n    engineFlags|=LARGE_ENGINE;\n  }\nswitch (engineType) {\ncase COMBUSTION_ENGINE:\ncase NORMAL_ENGINE:\ncase XL_ENGINE:\ncase XXL_ENGINE:\ncase FUEL_CELL:\ncase NONE:\ncase MAGLEV:\ncase BATTERY:\ncase SOLAR:\n    break;\ncase COMPACT_ENGINE:\n  if (hasFlag(LARGE_ENGINE)) {\n    problem.append(Messages.getString(\"Engine.invalidCompactLarge\"));\n    return false;\n  }\nbreak;\ncase LIGHT_ENGINE:\ncase FISSION:\nif (hasFlag(CLAN_ENGINE)) {\nproblem.append(Messages.getString(\"Engine.invalidSphereOnly\"));\nreturn false;\n}\nbreak;\ndefault :\nproblem.append(\"Type:\" + engineType);\nreturn false;\n}\nreturn true;\n}\n", "docstring": "sanity checks the engine , no negative ratings , and similar checks .", "partition": "test"}
{"idx": "1026", "code": "private void calculateD(double[] b){\n  int length=mExtremalIndices.size() - 1;\n  mD=new double[length];\n  for (int k=0; k < length; k++) {\n    mD[k]=b[k] * (mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(k)] - mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(length)]);\n  }\n}\n", "docstring": "calculates the set of d values for the current extremal index set . implements oppenheim / schafer discrete time signal processing , 3e , 2016 , equation 116c", "partition": "test"}
{"idx": "1027", "code": "public static byte[] base64decode(String coded){\n  if (null == coded)   return null;\n  byte[] src=coded.getBytes();\n  int len=src.length;\n  int dlen=len - (len / 77);\n  dlen=(dlen >>> 2) + (dlen >>> 1);\n  int rem=0;\n  if (61 == src[len - 1])   rem++;\n  if (61 == src[len - 2])   rem++;\n  dlen-=rem;\n  byte[] dst=new byte[dlen];\n  int pos=0;\n  int dpos=0;\n  int col=0;\n  len-=4;\n  while (pos < len) {\n    byte b0=_base64de[src[pos++]];\n    byte b1=_base64de[src[pos++]];\n    byte b2=_base64de[src[pos++]];\n    byte b3=_base64de[src[pos++]];\n    if (B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3)     throw new RuntimeException(\"Invalid character at or around position \" + pos);\n    dst[dpos++]=(byte)((b0 << 2) | ((b1 >>> 4) & 0x03));\n    dst[dpos++]=(byte)((b1 << 4) | ((b2 >>> 2) & 0x0f));\n    dst[dpos++]=(byte)((b2 << 6) | (b3 & 0x3f));\n    col+=4;\n    if (76 == col) {\n      if (10 != src[pos++])       throw new RuntimeException(\"No linefeed found at position \" + (pos - 1));\n      col=0;\n    }\n  }\n  byte b0=_base64de[src[pos++]];\n  byte b1=_base64de[src[pos++]];\n  byte b2=_base64de[src[pos++]];\n  byte b3=_base64de[src[pos++]];\n  if (B64INV == b0 || B64INV == b1 || B64INV == b2 || B64INV == b3)   throw new RuntimeException(\"Invalid character at or around position \" + pos);\n  dst[dpos++]=(byte)((b0 << 2) | ((b1 >>> 4) & 0x03));\n  if (2 == rem)   return dst;\n  dst[dpos++]=(byte)((b1 << 4) | ((b2 >>> 2) & 0x0f));\n  if (1 == rem)   return dst;\n  dst[dpos++]=(byte)((b2 << 6) | (b3 & 0x3f));\n  return dst;\n}\n", "docstring": "decodes a base64 encoded string . < br / > ( cf . rfc 1341 section 5 . 2 ) note : this decoder silently ignores all legal line breaks in the input and throws a runtimeexception on any illegal input . this impl slightly outperforms sun \"'\" s decoder on 1 . 3 and heavily outperforms it on 1 . 4 ( about a third faster ) .", "partition": "test"}
{"idx": "1028", "code": "private static Properties loadProperties(String propertiesFile){\n  Properties properties=new Properties();\n  try (InputStream is=new FileInputStream(propertiesFile)){\n    properties.load(is);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"failed to load properties\",e);\n  }\n  return properties;\n}\n", "docstring": "loads properties from a properties file on the local filesystem .", "partition": "test"}
{"idx": "1029", "code": "public Map<String,Map<String,String>> list(String serviceName){\n  Map<String,Map<String,String>> results=new HashMap<String,Map<String,String>>();\n  ServiceInfo[] infos=jmdns.list(\"_\" + serviceName + \"._tcp.local.\");\n  for (  ServiceInfo info : infos) {\n    _log.info(\"ServiceInfo:{}\",info);\n    final String[] hostAddrs=info.getHostAddresses();\n    final StringBuffer buf=new StringBuffer();\n    for (    String hostAddr : hostAddrs) {\n      buf.append(hostAddr);\n      buf.append(\';\');\n    }\n    final String key=buf.toString();\n    _log.info(\"\\tkey:{}\",key);\n    final Map<String,String> values=new HashMap<String,String>();\n    for (Enumeration<String> e=info.getPropertyNames(); e.hasMoreElements(); ) {\n      final String prop=e.nextElement();\n      final String value=new String(info.getPropertyBytes(prop));\n      _log.info(\"\\tprop:{}, value:{}\",prop,value);\n      values.put(prop,value);\n    }\n    if (values.isEmpty()) {\n      _log.warn(\"values are empty for key: {}\",key);\n    }\n    results.put(key,values.isEmpty() ? null : values);\n  }\n  return results;\n}\n", "docstring": "list published node ( s ) configuration in the network via multicast", "partition": "test"}
{"idx": "1030", "code": "@SuppressWarnings({\"unchecked\"}) @Override default LazyFutureStream<U> concat(final Stream<? extends U> other){\n  return fromStream(Stream.concat(StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(),Spliterator.ORDERED),false),StreamSupport.stream(Spliterators.spliteratorUnknownSize(other.iterator(),Spliterator.ORDERED),false)));\n}\n", "docstring": "concatenate two streams . / / ( 1 , 2 , 3 , 4 , 5 , 6 ) lazyfuturestream . of ( 1 , 2 , 3 ) . concat ( lazyfuturestream . of ( 4 , 5 , 6 ) )", "partition": "test"}
{"idx": "1031", "code": "private int moveComponents(Container target,int x,int y,int width,int height,int rowStart,int rowEnd,boolean ltr,boolean useBaseline,int[] ascent,int[] descent){\nswitch (newAlign) {\ncase LEFT:\n    x+=ltr ? 0 : width;\n  break;\ncase CENTER:\nx+=width / 2;\nbreak;\ncase RIGHT:\nx+=ltr ? width : 0;\nbreak;\ncase LEADING:\nbreak;\ncase TRAILING:\nx+=width;\nbreak;\n}\nint maxAscent=0;\nint nonbaselineHeight=0;\nint baselineOffset=0;\nif (useBaseline) {\nint maxDescent=0;\nfor (int i=rowStart; i < rowEnd; i++) {\nComponent m=target.getComponent(i);\nif (m.visible) {\nif (ascent[i] >= 0) {\nmaxAscent=Math.max(maxAscent,ascent[i]);\nmaxDescent=Math.max(maxDescent,descent[i]);\n}\n else {\nnonbaselineHeight=Math.max(m.getHeight(),nonbaselineHeight);\n}\n}\n}\nheight=Math.max(maxAscent + maxDescent,nonbaselineHeight);\nbaselineOffset=(height - maxAscent - maxDescent) / 2;\n}\nfor (int i=rowStart; i < rowEnd; i++) {\nComponent m=target.getComponent(i);\nif (m.isVisible()) {\nint cy;\nif (useBaseline && ascent[i] >= 0) {\ncy=y + baselineOffset + maxAscent - ascent[i];\n}\n else {\ncy=y + (height - m.height) / 2;\n}\nif (ltr) {\nm.setLocation(x,cy);\n}\n else {\nm.setLocation(target.width - x - m.width,cy);\n}\nx+=m.width + hgap;\n}\n}\nreturn height;\n}\n", "docstring": "centers the elements in the specified row , if there is any slack .", "partition": "test"}
{"idx": "1032", "code": "@Override public void readExternal(ObjectInput in) throws IOException {\n  path=IgfsUtils.readPath(in);\n  blockSize=in.readInt();\n  grpBlockSize=in.readLong();\n  len=in.readLong();\n  props=U.readStringMap(in);\n  accessTime=in.readLong();\n  modificationTime=in.readLong();\n  flags=in.readByte();\n}\n", "docstring": "reads object from data input .", "partition": "test"}
{"idx": "1033", "code": "public StandardXYItemLabelGenerator(){\n  this(DEFAULT_ITEM_LABEL_FORMAT,NumberFormat.getNumberInstance(),NumberFormat.getNumberInstance());\n}\n", "docstring": "creates an item label generator using default number formatters .", "partition": "test"}
{"idx": "1034", "code": "public double adjustedPow10(double val){\n  boolean negFlag=(val < 0.0);\n  if (negFlag) {\n    val=-val;\n  }\n  double res;\n  if (val < 1.0) {\n    res=(Math.pow(10,val + 1.0) - 10.0) / 9.0;\n  }\n else {\n    res=Math.pow(10,val);\n  }\n  return negFlag ? (-res) : res;\n}\n", "docstring": "returns an adjusted power of 10 value for graphing purposes . the first adjustment is that negative values are changed to positive during the calculations , and then the answer is negated at the end . the second is that , for values less than 1 , a progressive logarithmic offset is subtracted such that at 0 the returned result is also 0 .", "partition": "test"}
{"idx": "1035", "code": "public boolean isLastInvoice(){\n  String cm=getCostingMethod();\n  return cm != null && cm.equals(COSTINGMETHOD_LastInvoice);\n}\n", "docstring": "is last invoice costing method", "partition": "test"}
{"idx": "1036", "code": "public static String fetchClusterName(String clusterCgName){\n  String clusterName=null;\n  if (clusterCgName != null && !clusterCgName.isEmpty()) {\n    String[] tmp=clusterCgName.split(SPLITTER);\n    clusterName=tmp[0];\n  }\n  return clusterName;\n}\n", "docstring": "parses out the cluster name from the combined cluster / cg name .", "partition": "test"}
{"idx": "1037", "code": "private void fetchMyServiceCardsFromServer(){\n  RetroCallback retroCallback;\n  retroCallback=new RetroCallback(this);\n  retroCallback.setRequestId(HttpConstants.ApiResponseCodes.GET_MY_SERVICES);\n  retroCallbackList.add(retroCallback);\n  mYeloApi.getMyServiceCards(retroCallback);\n}\n", "docstring": "helper http function to get list of my service cards .", "partition": "test"}
{"idx": "1038", "code": "public DViewAsymmetricKeyFields(JDialog parent,String title,RSAPublicKey rsaPublicKey){\n  super(parent,title,Dialog.ModalityType.DOCUMENT_MODAL);\n  key=rsaPublicKey;\n  initFields();\n}\n", "docstring": "creates new dviewasymmetrickeyfields dialog .", "partition": "test"}
{"idx": "1039", "code": "public List<ColourChange> sampleConditionalMigrationEvents2(int parentColour,double parentHeight,int childColour,double childHeight,double[] m){\n  List<ColourChange> colourChanges=new ArrayList<ColourChange>();\n  if (parentHeight < childHeight) {\n    throw new IllegalArgumentException(\"sampleConditionalMigrationEvents: parentHeight=\" + parentHeight + \" childHeight=\"+ childHeight+ \", not good.\");\n  }\n  try {\n    int currentColour=parentColour;\n    double currentHeight=parentHeight;\n    while (true) {\n      ColourChange nextEvent=randomConditionalMigrationEvent(currentColour,currentHeight,childColour,childHeight,m);\n      currentHeight=nextEvent.getTime();\n      currentColour=nextEvent.getColourAbove();\n      colourChanges.add(nextEvent);\n    }\n  }\n catch (  NoEventException nee) {\n  }\n  reverseColourChangeList(colourChanges,parentColour);\n  return colourChanges;\n}\n", "docstring": "samples migration events on a two - coloured branch , conditional on colours at both ends migration process is forwards in ( natural ) time , so we are going down the tree . returns a list of events , ordered forward in time ( i . e . colour refers to branch * below * the event ) *", "partition": "test"}
{"idx": "1040", "code": "public static boolean isAttribute(Object objValue){\n  if (objValue instanceof String) {\n    String stringValue=(String)objValue;\n    if (stringValue.startsWith(ATTRIBUTE_START) && stringValue.endsWith(ATTRIBUTE_END)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if string is actually an attribute .", "partition": "test"}
{"idx": "1041", "code": "public static String decodeASCII(final byte[] key,final int off,final int len){\n  final byte[] b=new byte[len];\n  System.arraycopy(key,off,b,0,len);\n  for (int i=0; i < len; i++) {\n    b[i]=decodeByte(b[i]);\n  }\n  try {\n    return new String(b,\"US-ASCII\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "decodes an ascii string from a key .", "partition": "test"}
{"idx": "1042", "code": "@Override public void valueChanged(TreeSelectionEvent e){\n  if (preventEvent) {\n    return;\n  }\n  if (mainFrame != null) {\n    List<Operator> selectedOperators=getSelectedOperators();\n    if (selectedOperators != null && !selectedOperators.isEmpty()) {\n      mainFrame.selectOperators(selectedOperators);\n    }\n  }\n}\n", "docstring": "this method will be invoked after a user selection of an operator in the tree . causes a property table update and an update of the conditional action container .", "partition": "test"}
{"idx": "1043", "code": "public synchronized void removePropertyChangeListener(PropertyChangeListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "removes a property change listener .", "partition": "test"}
{"idx": "1044", "code": "private static Intent createShareIntent(Context context,final String shareText){\n  final Intent shareIntent=new Intent(Intent.ACTION_SEND);\n  shareIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,context.getString(R.string.share_subject));\n  shareIntent.putExtra(android.content.Intent.EXTRA_TEXT,shareText);\n  shareIntent.setType(\"text/plain\");\n  return shareIntent;\n}\n", "docstring": "creates a share intent", "partition": "test"}
{"idx": "1045", "code": "public static <U>AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass,String fieldName){\n  if (UnsafeHolder.isAvailable()) {\n    return new AtomicIntegerFieldUpdaterImpl<U>(tclass,fieldName);\n  }\n  return AtomicIntegerFieldUpdater.newUpdater(tclass,fieldName);\n}\n", "docstring": "creates an updater for objects with the given field . the class argument is needed to check that reflective types and generic types match .", "partition": "test"}
{"idx": "1046", "code": "private boolean tryStep(final double t0,final double[] y0,final double step,final int k,final double[] scale,final double[][] f,final double[] yMiddle,final double[] yEnd) throws MathIllegalArgumentException, MathIllegalStateException {\n  final int n=sequence[k];\n  final double subStep=step / n;\n  final double subStep2=2 * subStep;\n  double t=t0 + subStep;\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=y0[i] + subStep * f[0][i];\n  }\n  f[1]=computeDerivatives(t,yEnd);\n  final double[] yTmp=y0.clone();\n  for (int j=1; j < n; ++j) {\n    if (2 * j == n) {\n      System.arraycopy(yEnd,0,yMiddle,0,y0.length);\n    }\n    t+=subStep;\n    for (int i=0; i < y0.length; ++i) {\n      final double middle=yEnd[i];\n      yEnd[i]=yTmp[i] + subStep2 * f[j][i];\n      yTmp[i]=middle;\n    }\n    f[j + 1]=computeDerivatives(t,yEnd);\n    if (performTest && (j <= maxChecks) && (k < maxIter)) {\n      double initialNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=f[0][l] / scale[l];\n        initialNorm+=ratio * ratio;\n      }\n      double deltaNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=(f[j + 1][l] - f[0][l]) / scale[l];\n        deltaNorm+=ratio * ratio;\n      }\n      if (deltaNorm > 4 * FastMath.max(1.0e-15,initialNorm)) {\n        return false;\n      }\n    }\n  }\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n  }\n  return true;\n}\n", "docstring": "perform integration over one step using substeps of a modified midpoint method .", "partition": "test"}
{"idx": "1047", "code": "private static Pair<String,String> offsetLSR(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2,final String immediateNodeValue){\n  final String address=environment.getNextVariableString();\n  final String tmpVar1=environment.getNextVariableString();\n  final String tmpVar2=environment.getNextVariableString();\n  final String index=environment.getNextVariableString();\n  long baseOffset=offset;\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dw,registerNodeValue2,dw,\"-\" + immediateNodeValue,qw,tmpVar1));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,qw,tmpVar1,dw,dWordBitMask,dw,index));\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue1,dw,index,dw,tmpVar2));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dw,tmpVar2,dw,dWordBitMask,dw,address));\n  return new Pair<String,String>(address,registerNodeValue1);\n}\n", "docstring": "operation : [ < rn > , + / - < rm > , lsr # < shift_imm > ", "partition": "test"}
{"idx": "1048", "code": "public static RowLimitSpec buildRowLimitSpec(EsperEPL2GrammarParser.RowLimitContext ctx){\n  Object numRows;\n  Object offset;\n  if (ctx.o != null) {\n    numRows=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    offset=parseNumOrVariableIdent(ctx.n2,ctx.i2);\n  }\n else   if (ctx.c != null) {\n    offset=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    numRows=parseNumOrVariableIdent(ctx.n2,ctx.i2);\n  }\n else {\n    numRows=parseNumOrVariableIdent(ctx.n1,ctx.i1);\n    offset=null;\n  }\n  Integer numRowsInt=null;\n  String numRowsVariable=null;\n  if (numRows instanceof String) {\n    numRowsVariable=(String)numRows;\n  }\n else {\n    numRowsInt=(Integer)numRows;\n  }\n  Integer offsetInt=null;\n  String offsetVariable=null;\n  if (offset instanceof String) {\n    offsetVariable=(String)offset;\n  }\n else {\n    offsetInt=(Integer)offset;\n  }\n  return new RowLimitSpec(numRowsInt,offsetInt,numRowsVariable,offsetVariable);\n}\n", "docstring": "builds a row limit specification .", "partition": "test"}
{"idx": "1049", "code": "public final int first_common_layer(BrdItem p_other){\n  int max_first_layer=Math.max(first_layer(),p_other.first_layer());\n  int min_last_layer=Math.min(last_layer(),p_other.last_layer());\n  if (max_first_layer > min_last_layer) {\n    return -1;\n  }\n  return max_first_layer;\n}\n", "docstring": "returns the first layer , where both this item and p_other have a shape . returns - 1 , if such a layer does not exisr .", "partition": "test"}
{"idx": "1050", "code": "public ItemStack removeItems(ItemStack drive,ItemStack stack,int amountWanted){\n  if (getMaxKilobits(drive) == -1)   return null;\n  int stored=getAmountStored(drive,stack);\n  int amountGiven=Math.min(amountWanted,stored);\n  if (amountGiven > 0) {\n    setAmountStored(drive,stack,stored - amountGiven);\n    stack.stackSize+=amountGiven;\n    markDirty(drive);\n  }\n  return stack;\n}\n", "docstring": "take as many items as possible , up to the passed limit , from a drive into the given stack . < p > the stacksize of the passed stack will be affected . return value is for convenience .", "partition": "test"}
{"idx": "1051", "code": "public void saveIndexes(){\n  ArrayList toSave=new ArrayList();\nsynchronized (this) {\n    Object[] valueTable=this.indexes.valueTable;\n    for (int i=0, l=valueTable.length; i < l; i++) {\n      Index index=(Index)valueTable[i];\n      if (index != null)       toSave.add(index);\n    }\n  }\n  boolean allSaved=true;\n  for (int i=0, length=toSave.size(); i < length; i++) {\n    Index index=(Index)toSave.get(i);\n    ReadWriteMonitor monitor=index.monitor;\n    if (monitor == null)     continue;\n    try {\n      monitor.enterRead();\n      if (index.hasChanged()) {\n        if (monitor.exitReadEnterWrite()) {\n          try {\n            saveIndex(index);\n          }\n catch (          IOException e) {\n            if (JobManager.VERBOSE) {\n              Util.verbose(\"-> got the following exception while saving:\",System.err);\n              e.printStackTrace();\n            }\n            allSaved=false;\n          }\n finally {\n            monitor.exitWriteEnterRead();\n          }\n        }\n else {\n          allSaved=false;\n        }\n      }\n    }\n  finally {\n      monitor.exitRead();\n    }\n  }\n  if (this.participantsContainers != null && this.participantUpdated) {\n    writeParticipantsIndexNamesFile();\n    this.participantUpdated=false;\n  }\n  this.needToSave=!allSaved;\n}\n", "docstring": "commit all index memory changes to disk", "partition": "test"}
{"idx": "1052", "code": "public void addItem(Artist artist,int position){\n  if (artist == null)   throw new NullPointerException(\"The item cannot be null\");\n  if (position < getItemCount() || position > getItemCount())   throw new IllegalArgumentException(\"The position must be between 0 and lastIndex + 1\");\n  artists.add(position,artist);\n  notifyItemInserted(position);\n}\n", "docstring": "add item in determined index", "partition": "test"}
{"idx": "1053", "code": "public void expandAndSelectIfExists(RepositoryLocation location){\n  if (location.parent() != null) {\n    expandIfExists(location.parent(),location.getName());\n  }\n else {\n    expandIfExists(location,null);\n  }\n  scrollPathToVisible(getSelectionPath());\n}\n", "docstring": "expands the tree to select the given entry if it exists .", "partition": "test"}
{"idx": "1054", "code": "public static void saveProvisioningValidity(Context context,long validity){\n  if (validity <= 0L) {\n    return;\n  }\n  long next=System.currentTimeMillis() + validity;\n  SharedPreferences preferences=context.getSharedPreferences(AndroidRegistryFactory.RCS_PREFS_NAME,Activity.MODE_PRIVATE);\n  SharedPreferences.Editor editor=preferences.edit();\n  editor.putLong(REGISTRY_PROVISIONING_VALIDITY,validity);\n  editor.putLong(REGISTRY_PROVISIONING_EXPIRATION,next);\n  editor.commit();\n}\n", "docstring": "save the provisioning validity in shared preferences", "partition": "test"}
{"idx": "1055", "code": "public void encode(OutputStream out) throws IOException {\n  DerOutputStream tmp=new DerOutputStream();\n  if (this.extensionValue == null) {\n    this.extensionId=PKIXExtensions.ReasonCode_Id;\n    this.critical=false;\n    encodeThis();\n  }\n  super.encode(tmp);\n  out.write(tmp.toByteArray());\n}\n", "docstring": "write the extension to the deroutputstream .", "partition": "test"}
{"idx": "1056", "code": "public DriverTask unexportVolumesFromInitiators(List<Initiator> initiators,List<StorageVolume> volumes){\n  LOG.info(\"Unexporting volumes from initiators\");\n  DriverTask task=new DellSCDriverTask(\"unexportVolumes\");\n  ScServer server=null;\n  StringBuilder errBuffer=new StringBuilder();\n  int volumesUnmapped=0;\n  for (  StorageVolume volume : volumes) {\n    String ssn=volume.getStorageSystemId();\n    boolean isSnapshot=StringUtils.countMatches(volume.getNativeId(),\".\") == 2;\n    try {\n      StorageCenterAPI api=connectionManager.getConnection(ssn);\n      ScVolume scVol=null;\n      if (isSnapshot) {\n        scVol=api.findReplayView(volume.getNativeId());\n        if (scVol != null) {\n          api.deleteVolume(scVol.instanceId);\n          volumesUnmapped++;\n          continue;\n        }\n      }\n else {\n        scVol=api.getVolume(volume.getNativeId());\n      }\n      if (scVol == null) {\n        throw new DellSCDriverException(String.format(\"Unable to find volume %s\",volume.getNativeId()));\n      }\n      if (server == null) {\n        server=findScServer(api,ssn,initiators);\n      }\n      if (server == null) {\n        throw new DellSCDriverException(SERVER_CREATE_FAIL_MSG);\n      }\n      ScMappingProfile[] mappingProfiles=api.findMappingProfiles(server.instanceId,scVol.instanceId);\n      for (      ScMappingProfile mappingProfile : mappingProfiles) {\n        api.deleteMappingProfile(mappingProfile.instanceId);\n      }\n      volumesUnmapped++;\n      LOG.info(\"Volume \'{}\' unexported from server \'{}\'\",scVol.name,server.name);\n    }\n catch (    StorageCenterAPIException|DellSCDriverException dex) {\n      String error=String.format(\"Error unmapping volume %s: %s\",volume.getDisplayName(),dex);\n      LOG.error(error);\n      errBuffer.append(String.format(\"%s%n\",error));\n      if (SERVER_CREATE_FAIL_MSG.equals(dex.getMessage())) {\n        break;\n      }\n    }\n  }\n  task.setMessage(errBuffer.toString());\n  if (volumesUnmapped == volumes.size()) {\n    task.setStatus(TaskStatus.READY);\n  }\n else   if (volumesUnmapped == 0) {\n    task.setStatus(TaskStatus.FAILED);\n  }\n else {\n    task.setStatus(TaskStatus.PARTIALLY_FAILED);\n  }\n  return task;\n}\n", "docstring": "remove volume exports to initiators .", "partition": "test"}
{"idx": "1057", "code": "public void createClusterAsync(final String projectId,final ClusterCreateSpec clusterCreateSpec,final FutureCallback<Task> responseCallback) throws IOException {\n  String path=String.format(\"%s/%s/clusters\",getBasePath(),projectId);\n  createObjectAsync(path,serializeObjectAsJson(clusterCreateSpec),responseCallback);\n}\n", "docstring": "create a cluster in the specified project .", "partition": "test"}
{"idx": "1058", "code": "public static DereferenceAliasesPolicy valueOf(final int intValue){\n  if (intValue < 0 || intValue >= ELEMENTS.length) {\n    return null;\n  }\n  return ELEMENTS[intValue];\n}\n", "docstring": "returns the alias dereferencing policy having the specified integer value as defined in rfc 4511 section 4 . 5 . 1 .", "partition": "test"}
{"idx": "1059", "code": "public static void writeUnsafe(PacketOutputStream out,String value,boolean noBackslashEscapes) throws IOException {\n  byte[] bytes=value.getBytes(\"UTF-8\");\n  out.writeUnsafe(QUOTE);\n  writeBytesEscapedUnsafe(out,bytes,bytes.length,noBackslashEscapes);\n  out.writeUnsafe(QUOTE);\n}\n", "docstring": "write string in text format without checking buffer size .", "partition": "test"}
{"idx": "1060", "code": "public void add(final SAMRecord read,final int position){\n  recordAndOffsets.add(new RecordAndOffset(read,position));\n}\n", "docstring": "accumulate info for one read at the locus .", "partition": "test"}
{"idx": "1061", "code": "private Sha256Hash calculateHash(){\n  try {\n    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(HEADER_SIZE);\n    writeHeader(bos);\n    return new Sha256Hash(Utils.reverseBytes(doubleDigest(bos.toByteArray())));\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "calculates the block hash by serializing the block and hashing the resulting bytes .", "partition": "test"}
{"idx": "1062", "code": "private void addPropertyType(URI p,Resource t){\n  OwlProperty prop=getProperty(p);\n  if (t.equals(OWL.TRANSITIVEPROPERTY)) {\n    prop.setTransitive();\n  }\n else   if (t.equals(OWL.SYMMETRICPROPERTY)) {\n    prop.setSymmetric();\n  }\n else   if (t.equals(OWL2.ASYMMETRICPROPERTY)) {\n    prop.setAsymmetric();\n  }\n else   if (t.equals(OWL.FUNCTIONALPROPERTY)) {\n    prop.setFunctional();\n  }\n else   if (t.equals(OWL.INVERSEFUNCTIONALPROPERTY)) {\n    prop.setInverseFunctional();\n  }\n else   if (t.equals(OWL2.IRREFLEXIVEPROPERTY)) {\n    prop.setIrreflexive();\n  }\n}\n", "docstring": "add a particular characteristic to a property .", "partition": "test"}
{"idx": "1063", "code": "public static void equals(Object object1,Object object2){\n  checkAssertion(object1.equals(object2),null);\n}\n", "docstring": "asserts that given object1 equals object2 .", "partition": "test"}
{"idx": "1064", "code": "protected void preAddInterruptibly(Object o) throws InterruptedException {\n}\n", "docstring": "called before the specified object is added to this queue .", "partition": "test"}
{"idx": "1065", "code": "private ODataFeed readFeedLogPerf(String query,Map<String,String> params) throws IOException, ODataException {\n  long delta_time=System.currentTimeMillis();\n  ODataFeed feed=client.readFeed(query,params);\n  log(Level.DEBUG,\"query(\" + query + \") done in \"+ delta_time+ \"ms\");\n  return feed;\n}\n", "docstring": "logs how much time an odata command consumed .", "partition": "test"}
{"idx": "1066", "code": "public Dependencies resolveFromFile(File file,String className,SootClass sc){\n  DexlibWrapper wrapper=cache.get(file);\n  if (wrapper == null) {\n    wrapper=new DexlibWrapper(file);\n    cache.put(file,wrapper);\n    wrapper.initialize();\n  }\n  Dependencies deps=wrapper.makeSootClass(sc,className);\n  addSourceFileTag(sc,\"dalvik_source_\" + file.getName());\n  return deps;\n}\n", "docstring": "resolve the class contained in file into the passed soot class .", "partition": "test"}
{"idx": "1067", "code": "public static String buildResponseUrl(String tenant,LogoutState logoutState){\n  String retval=null;\n  LogoutResponse samlResponse=logoutState.generateResponseForTenant(tenant,logoutState.getMessageSource(),logoutState.getLocale());\n  if (samlResponse != null) {\n    log.info(\"SAML SLO Response is \" + samlResponse.toString());\n    retval=logoutState.generateResponseUrlForTenant(samlResponse,tenant);\n  }\n  return retval;\n}\n", "docstring": "helper method to generate logoutresponse redirect url", "partition": "test"}
{"idx": "1068", "code": "public static void assertLabel(int[] path,String text){\n  if (verbose) {\n    log(\"assertLabel(\" + toString(path) + \", \"+ text+ \")\");\n  }\n  Label l=(Label)getComponentByPath(path);\n  assertBool(l != null,\"Null label\" + text);\n  assertBool(text == l.getText() || text.equals(l.getText()),(\"\" + l.getText()) + \" != \" + text);\n}\n", "docstring": "asserts that we have a label with the given text baring the given name", "partition": "test"}
{"idx": "1069", "code": "private void interpolateResultList(ArrayList<PathParser.PathDataNode> list){\n  if (list == null || list.size() <= 2)   return;\n  float[][] listPenPos=PathNodeUtils.calculatePenPosition(list);\n  ArrayList<PathParser.PathDataNode> subList=new ArrayList<>();\n  int size=list.size();\n  PathParser.PathDataNode currentNode=null;\n  int i=0;\n  while (i < size - 1) {\n    currentNode=list.get(i);\n    if (!isInterpolatableCommand(currentNode.mType)) {\n      i++;\n      continue;\n    }\n    boolean validSequence=true;\n    int k=i;\n    for (int j=i; j < size && validSequence; j++) {\n      if (currentNode.mType == list.get(j).mType) {\n        k=j;\n        if (!Arrays.equals(currentNode.mParams,list.get(j).mParams))         break;\n      }\n else       validSequence=false;\n    }\n    if (k - i > 2) {\n      interpolateSubList(list.subList(i,k + 1));\n    }\n    i++;\n  }\n}\n", "docstring": "apply interpolation on the result list ( where possible )", "partition": "test"}
{"idx": "1070", "code": "private void initTokenizer(StreamTokenizer tokenizer){\n  tokenizer.resetSyntax();\n  tokenizer.whitespaceChars(0,(\' \' - 1));\n  tokenizer.wordChars(\' \',\'\\u00FF\');\n  tokenizer.whitespaceChars(\',\',\',\');\n  tokenizer.whitespaceChars(\':\',\':\');\n  tokenizer.commentChar(\'|\');\n  tokenizer.whitespaceChars(\'\\t\',\'\\t\');\n  tokenizer.quoteChar(\'\"\');\n  tokenizer.quoteChar(\'\\\'\');\n  tokenizer.eolIsSignificant(true);\n}\n", "docstring": "initializes the stream tokenizer", "partition": "test"}
{"idx": "1071", "code": "protected void run_ThreadSizeLoop() throws Exception {\n  for (int i=25; i <= 100; i+=25) {\n    setNumWorkers(i);\n    try {\n      Thread.sleep(60 * 1000);\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}\n", "docstring": "a simple method to do nothing very much . this is used in determining static memory consumption .", "partition": "test"}
{"idx": "1072", "code": "protected boolean read(){\n  if (!nReuseHeader) {\n    Debug.message(\"iso8211\",\"DDFRecord reusing header, calling readHeader()\");\n    return readHeader();\n  }\n  byte[] tempData=new byte[nDataSize - nFieldOffset];\n  int nReadBytes=poModule.read(tempData,0,tempData.length);\n  System.arraycopy(pachData,nFieldOffset,tempData,0,tempData.length);\n  if (nReadBytes != (int)(nDataSize - nFieldOffset) && nReadBytes == -1) {\n    return false;\n  }\n else   if (nReadBytes != (int)(nDataSize - nFieldOffset)) {\n    Debug.error(\"DDFRecord: Data record is short on DDF file.\");\n    return false;\n  }\n  return true;\n}\n", "docstring": "read a record of data from the file , and parse the header to build a field list for the record ( or reuse the existing one if reusing headers ) . it is expected that the file pointer will be positioned at the beginning of a data record . it is the ddfmodule \"'\" s responsibility to do so . this method should only be called by the ddfmodule class .", "partition": "test"}
{"idx": "1073", "code": "@Override public boolean lock(){\n  try {\n    if (!FileFactory.isFileExist(location,FileFactory.getFileType(tmpPath))) {\n      FileFactory.mkdirs(location,FileFactory.getFileType(tmpPath));\n    }\n    String lockFilePath=location + CarbonCommonConstants.FILE_SEPARATOR + lockFile;\n    if (!FileFactory.isFileExist(lockFilePath,FileFactory.getFileType(location))) {\n      FileFactory.createNewLockFile(lockFilePath,FileFactory.getFileType(location));\n    }\n    fileOutputStream=new FileOutputStream(lockFilePath);\n    channel=fileOutputStream.getChannel();\n    try {\n      fileLock=channel.tryLock();\n    }\n catch (    OverlappingFileLockException e) {\n      return false;\n    }\n    if (null != fileLock) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n", "docstring": "lock api for locking of the file channel of the lock file .", "partition": "test"}
{"idx": "1074", "code": "public String globalInfo(){\n  return \"A SplitEvaluator that produces results for a classification \" + \"scheme on a numeric class attribute.\";\n}\n", "docstring": "returns a string describing this split evaluator", "partition": "test"}
{"idx": "1075", "code": "public MLResults execute(Script script){\n  ScriptExecutor scriptExecutor=new ScriptExecutor(sparkMonitoringUtil);\n  scriptExecutor.setExplain(explain);\n  scriptExecutor.setExplainLevel(explainLevel);\n  scriptExecutor.setStatistics(statistics);\n  scriptExecutor.setInit(scriptHistoryStrings.isEmpty());\n  return execute(script,scriptExecutor);\n}\n", "docstring": "execute a dml or pydml script .", "partition": "test"}
{"idx": "1076", "code": "public void disable(RichFormatterFeature feature){\n  features.remove(feature);\n}\n", "docstring": "disable a specific feature on this rich formatter .", "partition": "test"}
{"idx": "1077", "code": "public void removeEventListener(ZWaveEventListener eventListener){\nsynchronized (zwaveEventListeners) {\n    zwaveEventListeners.remove(eventListener);\n  }\n}\n", "docstring": "remove a listener for zwave events to this controller .", "partition": "test"}
{"idx": "1078", "code": "private static double pythonTime(){\n  return System.currentTimeMillis() / 1000;\n}\n", "docstring": "returns the current millis the same way as python does since this is what \"'\" s stored in the replay files * yay * .", "partition": "test"}
{"idx": "1079", "code": "@SafeVarargs public final void add(T... newItems){\n  add(Arrays.asList(newItems));\n}\n", "docstring": "add new items to the table .", "partition": "test"}
{"idx": "1080", "code": "public static String quoteIfJavaKeyword(String name){\n  return JVMModuleUtil.quoteIfJavaKeyword(name);\n}\n", "docstring": "prefixes the given name with a dollar ( $ ) if it is a java keyword", "partition": "test"}
{"idx": "1081", "code": "private static <T,ID>void addDropTableStatements(DatabaseType databaseType,TableInfo<T,ID> tableInfo,List<String> statements){\n  List<String> statementsBefore=new ArrayList<String>();\n  List<String> statementsAfter=new ArrayList<String>();\n  for (  FieldType fieldType : tableInfo.getFieldTypes()) {\n    databaseType.dropColumnArg(fieldType,statementsBefore,statementsAfter);\n  }\n  StringBuilder sb=new StringBuilder(64);\n  sb.append(\"DROP TABLE \");\n  databaseType.appendEscapedEntityName(sb,tableInfo.getTableName());\n  sb.append(\' \');\n  statements.addAll(statementsBefore);\n  statements.add(sb.toString());\n  statements.addAll(statementsAfter);\n}\n", "docstring": "generate and return the list of statements to drop a database table .", "partition": "test"}
{"idx": "1082", "code": "private static ClassInfo findOrCreateClass(String t){\n  if (!t.endsWith(\"[]\")) {\n    return ClassInfo.findOrCreateClass(t);\n  }\n else {\n    String baseType=t.substring(0,t.indexOf(\"[]\"));\n    int level=(t.length() - t.indexOf(\"[]\")) / 2;\n    String s=\"\";\n    for (int i=0; i < level; ++i)     s+=\"[\";\n    if (baseType.equals(\"int\"))     s+=\"I\";\n else     if (baseType.equals(\"boolean\"))     s+=\"B\";\n else     s+=\"L\" + baseType + \";\";\n    return ClassInfo.findOrCreateClass(s);\n  }\n}\n", "docstring": "convert pscout - style type name to canonical form", "partition": "test"}
{"idx": "1083", "code": "@HLEFunction(nid=0x7ED29E40,version=150) public int sceRtcSetTick(TPointer timeAddr,TPointer64 ticksAddr){\n  long ticks=ticksAddr.getValue() - rtcMagicOffset;\n  ScePspDateTime time=ScePspDateTime.fromMicros(ticks);\n  time.write(timeAddr);\n  return 0;\n}\n", "docstring": "set a psptime struct based on ticks .", "partition": "test"}
{"idx": "1084", "code": "private void populateNavDrawer(){\n  mNavDrawerItems.clear();\n  mNavDrawerItems.add(NAVDRAWER_ITEM_HOME);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SEPARATOR);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_FOLLOWING);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_SHOTS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_BUCKETS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_PROJECTS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_TEAMS);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_MY_LIKES);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SEPARATOR_SPECIAL);\n  mNavDrawerItems.add(NAVDRAWER_ITEM_SETTINGS);\n  createNavDrawerItems();\n}\n", "docstring": "populates the navigation drawer with the appropriate items .", "partition": "test"}
{"idx": "1085", "code": "private BigInteger oddModPow(BigInteger y,BigInteger z){\n  if (y.equals(ONE))   return this;\n  if (signum == 0)   return ZERO;\n  int[] base=mag.clone();\n  int[] exp=y.mag;\n  int[] mod=z.mag;\n  int modLen=mod.length;\n  if ((modLen & 1) != 0) {\n    int[] x=new int[modLen + 1];\n    System.arraycopy(mod,0,x,1,modLen);\n    mod=x;\n    modLen++;\n  }\n  int wbits=0;\n  int ebits=bitLength(exp,exp.length);\n  if ((ebits != 17) || (exp[0] != 65537)) {\n    while (ebits > bnExpModThreshTable[wbits]) {\n      wbits++;\n    }\n  }\n  int tblmask=1 << wbits;\n  int[][] table=new int[tblmask][];\n  for (int i=0; i < tblmask; i++)   table[i]=new int[modLen];\n  long n0=(mod[modLen - 1] & LONG_MASK) + ((mod[modLen - 2] & LONG_MASK) << 32);\n  long inv=-MutableBigInteger.inverseMod64(n0);\n  int[] a=leftShift(base,base.length,modLen << 5);\n  MutableBigInteger q=new MutableBigInteger(), a2=new MutableBigInteger(a), b2=new MutableBigInteger(mod);\n  b2.normalize();\n  MutableBigInteger r=a2.divide(b2,q);\n  table[0]=r.toIntArray();\n  if (table[0].length < modLen) {\n    int offset=modLen - table[0].length;\n    int[] t2=new int[modLen];\n    System.arraycopy(table[0],0,t2,offset,table[0].length);\n    table[0]=t2;\n  }\n  int[] b=montgomerySquare(table[0],mod,modLen,inv,null);\n  int[] t=Arrays.copyOf(b,modLen);\n  for (int i=1; i < tblmask; i++) {\n    table[i]=montgomeryMultiply(t,table[i - 1],mod,modLen,inv,null);\n  }\n  int bitpos=1 << ((ebits - 1) & (32 - 1));\n  int buf=0;\n  int elen=exp.length;\n  int eIndex=0;\n  for (int i=0; i <= wbits; i++) {\n    buf=(buf << 1) | (((exp[eIndex] & bitpos) != 0) ? 1 : 0);\n    bitpos>>>=1;\n    if (bitpos == 0) {\n      eIndex++;\n      bitpos=1 << (32 - 1);\n      elen--;\n    }\n  }\n  int multpos=ebits;\n  ebits--;\n  boolean isone=true;\n  multpos=ebits - wbits;\n  while ((buf & 1) == 0) {\n    buf>>>=1;\n    multpos++;\n  }\n  int[] mult=table[buf >>> 1];\n  buf=0;\n  if (multpos == ebits)   isone=false;\n  while (true) {\n    ebits--;\n    buf<<=1;\n    if (elen != 0) {\n      buf|=((exp[eIndex] & bitpos) != 0) ? 1 : 0;\n      bitpos>>>=1;\n      if (bitpos == 0) {\n        eIndex++;\n        bitpos=1 << (32 - 1);\n        elen--;\n      }\n    }\n    if ((buf & tblmask) != 0) {\n      multpos=ebits - wbits;\n      while ((buf & 1) == 0) {\n        buf>>>=1;\n        multpos++;\n      }\n      mult=table[buf >>> 1];\n      buf=0;\n    }\n    if (ebits == multpos) {\n      if (isone) {\n        b=mult.clone();\n        isone=false;\n      }\n else {\n        t=b;\n        a=montgomeryMultiply(t,mult,mod,modLen,inv,a);\n        t=a;\n        a=b;\n        b=t;\n      }\n    }\n    if (ebits == 0)     break;\n    if (!isone) {\n      t=b;\n      a=montgomerySquare(t,mod,modLen,inv,a);\n      t=a;\n      a=b;\n      b=t;\n    }\n  }\n  int[] t2=new int[2 * modLen];\n  System.arraycopy(b,0,t2,modLen,modLen);\n  b=montReduce(t2,mod,modLen,(int)inv);\n  t2=Arrays.copyOf(b,modLen);\n  return new BigInteger(1,t2);\n}\n", "docstring": "returns a biginteger whose value is x to the power of y mod z . assumes : z is odd & & x < z .", "partition": "test"}
{"idx": "1086", "code": "public int nextToken(){\n  while (index < length && Character.isWhitespace(expr[index])) {\n    index++;\n  }\n  tokenVal=null;\n  if (index == length)   return TOKEN_END;\n  int start=index;\n  char currentChar=expr[index];\n  char nextChar=(char)0;\n  index++;\n  if (index < length)   nextChar=expr[index];\nswitch (currentChar) {\ncase \'(\':\n    return TOKEN_LBRACE;\ncase \')\':\n  return TOKEN_RBRACE;\ncase \'=\':\nreturn TOKEN_EQ;\ncase \'!\':\nif (nextChar == \'=\') {\nindex++;\nreturn TOKEN_NOT_EQ;\n}\nreturn TOKEN_NOT;\ncase \'|\':\nif (nextChar == \'|\') {\nindex++;\nreturn TOKEN_OR;\n}\nbreak;\ncase \'&\':\nif (nextChar == \'&\') {\nindex++;\nreturn TOKEN_AND;\n}\nbreak;\ncase \'>\':\nif (nextChar == \'=\') {\nindex++;\nreturn TOKEN_GE;\n}\nreturn TOKEN_GT;\ncase \'<\':\nif (nextChar == \'=\') {\nindex++;\nreturn TOKEN_LE;\n}\nreturn TOKEN_LT;\ndefault :\nbreak;\n}\nint end=index;\nif (currentChar == \'\"\' || currentChar == \'\\\'\') {\nchar endChar=currentChar;\nboolean escaped=false;\nstart++;\nfor (; index < length; index++) {\nif (expr[index] == \'\\\\\' && !escaped) {\nescaped=true;\ncontinue;\n}\nif (expr[index] == endChar && !escaped) break;\nescaped=false;\n}\nend=index;\nindex++;\n}\n else if (currentChar == \'/\') {\nchar endChar=currentChar;\nboolean escaped=false;\nfor (; index < length; index++) {\nif (expr[index] == \'\\\\\' && !escaped) {\nescaped=true;\ncontinue;\n}\nif (expr[index] == endChar && !escaped) break;\nescaped=false;\n}\nend=++index;\n}\n else {\nfor (; index < length; index++) {\nif (isMetaChar(expr[index])) break;\n}\nend=index;\n}\nthis.tokenVal=new String(expr,start,end - start);\nreturn TOKEN_STRING;\n}\n", "docstring": "returns the next token type and initializes any state variables accordingly .", "partition": "test"}
{"idx": "1087", "code": "public static Byte[] valuesOf(byte[] array){\n  Byte[] dest=new Byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Byte.valueOf(array[i]);\n  }\n  return dest;\n}\n", "docstring": "converts to object array .", "partition": "test"}
{"idx": "1088", "code": "public void auditCallhome(OperationTypeEnum auditType,String operationalStatus,String description,Object... descparams){\n  _auditMgr.recordAuditLog(null,null,EVENT_SERVICE_TYPE,auditType,System.currentTimeMillis(),operationalStatus,description,descparams);\n}\n", "docstring": "record audit log for callhome service", "partition": "test"}
{"idx": "1089", "code": "public static float mean(float[] data,int startIndex,int endIndex){\n  float mean=0;\n  int total=0;\n  startIndex=Math.max(startIndex,0);\n  startIndex=Math.min(startIndex,data.length - 1);\n  endIndex=Math.max(endIndex,0);\n  endIndex=Math.min(endIndex,data.length - 1);\n  if (startIndex > endIndex)   startIndex=endIndex;\n  for (int i=startIndex; i <= endIndex; i++) {\n    if (Float.isNaN(data[i]))     throw new IllegalArgumentException(\"NaN not allowed in mean calculation\");\n    mean+=data[i];\n    total++;\n  }\n  mean/=total;\n  return mean;\n}\n", "docstring": "compute the mean of all elements in the array . no missing values ( nan ) are allowed .", "partition": "test"}
{"idx": "1090", "code": "public static String constructNTPtime(long date){\n  long ntpTime=2208988800L;\n  long startTime=(date / SECONDS_TO_MILLISECONDS_CONVERSION_RATE) + ntpTime;\n  return String.valueOf(startTime);\n}\n", "docstring": "construct an ntp time from a date in milliseconds", "partition": "test"}
{"idx": "1091", "code": "protected MediaType selectMediaType(ServerWebExchange exchange,List<MediaType> producibleTypes){\n  List<MediaType> acceptableTypes=getAcceptableTypes(exchange);\n  producibleTypes=getProducibleTypes(exchange,producibleTypes);\n  Set<MediaType> compatibleMediaTypes=new LinkedHashSet<>();\n  for (  MediaType acceptable : acceptableTypes) {\n    for (    MediaType producible : producibleTypes) {\n      if (acceptable.isCompatibleWith(producible)) {\n        compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable,producible));\n      }\n    }\n  }\n  List<MediaType> result=new ArrayList<>(compatibleMediaTypes);\n  MediaType.sortBySpecificityAndQuality(result);\n  for (  MediaType mediaType : compatibleMediaTypes) {\n    if (mediaType.isConcrete()) {\n      return mediaType;\n    }\n else     if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n      return MediaType.APPLICATION_OCTET_STREAM;\n    }\n  }\n  return null;\n}\n", "docstring": "select the best media type for the current request through a content negotiation algorithm .", "partition": "test"}
{"idx": "1092", "code": "public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  if (!(c instanceof JPopupMenu)) {\n    return;\n  }\n  Font origFont=g.getFont();\n  Color origColor=g.getColor();\n  JPopupMenu popup=(JPopupMenu)c;\n  String title=popup.getLabel();\n  if (title == null) {\n    return;\n  }\n  g.setFont(font);\n  FontMetrics fm=SwingUtilities2.getFontMetrics(popup,g,font);\n  int fontHeight=fm.getHeight();\n  int descent=fm.getDescent();\n  int ascent=fm.getAscent();\n  Point textLoc=new Point();\n  int stringWidth=SwingUtilities2.stringWidth(popup,fm,title);\n  textLoc.y=y + ascent + TEXT_SPACING;\n  textLoc.x=x + ((width - stringWidth) / 2);\n  g.setColor(background);\n  g.fillRect(textLoc.x - TEXT_SPACING,textLoc.y - (fontHeight - descent),stringWidth + (2 * TEXT_SPACING),fontHeight - descent);\n  g.setColor(foreground);\n  SwingUtilities2.drawString(popup,g,title,textLoc.x,textLoc.y);\n  MotifGraphicsUtils.drawGroove(g,x,textLoc.y + TEXT_SPACING,width,GROOVE_HEIGHT,shadowColor,highlightColor);\n  g.setFont(origFont);\n  g.setColor(origColor);\n}\n", "docstring": "paints the border for the specified component with the specified position and size .", "partition": "test"}
{"idx": "1093", "code": "public void ensureCapacity(int mincap){\n  if (mincap > array.length) {\n    int newcap=((array.length * 3) >> 1) + 1;\n    int[] olddata=array;\n    array=new int[newcap < mincap ? mincap : newcap];\n    System.arraycopy(olddata,0,array,0,size);\n  }\n}\n", "docstring": "increases the capacity of this arraylist instance , if necessary , to ensure that it can hold at least the number of elements specified by the minimum capacity argument .", "partition": "test"}
{"idx": "1094", "code": "public void invalidateAndUnmap(ByteBuffer... bufs) throws IOException {\n  if (cleaner != null) {\n    invalidated=true;\n    barrier.lazySet(0);\n    Thread.yield();\n    for (    ByteBuffer b : bufs) {\n      cleaner.freeBuffer(resourceDescription,b);\n    }\n  }\n}\n", "docstring": "invalidates this guard and unmaps ( if supported ) .", "partition": "test"}
{"idx": "1095", "code": "public int addDir(File file){\n  if (!file.exists()) {\n    return 0;\n  }\n  String[] names=getNames(getFiles(file,\".class\"));\n  loadClass(file,names);\n  return 1;\n}\n", "docstring": "adds new locations for command classes", "partition": "test"}
{"idx": "1096", "code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof BubbleXYItemLabelGenerator)) {\n    return false;\n  }\n  if (!super.equals(obj)) {\n    return false;\n  }\n  BubbleXYItemLabelGenerator that=(BubbleXYItemLabelGenerator)obj;\n  if (!ObjectUtilities.equal(this.zFormat,that.zFormat)) {\n    return false;\n  }\n  if (!ObjectUtilities.equal(this.zDateFormat,that.zDateFormat)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "tests this object for equality with an arbitrary object .", "partition": "test"}
{"idx": "1097", "code": "public static boolean hasElementChild(Node node){\n  NodeList nl=node.getChildNodes();\n  Node child=null;\n  int length=nl.getLength();\n  for (int i=0; i < length; i++) {\n    child=nl.item(i);\n    if (child.getNodeType() == Node.ELEMENT_NODE) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if a node has a child of element type .", "partition": "test"}
{"idx": "1098", "code": "public void delItem(int index){\nsynchronized (getMenuTreeLock()) {\n    if (selectedIndex == index) {\n      selectItem(null,false);\n    }\n else     if (selectedIndex > index) {\n      selectedIndex--;\n    }\n    if (index < items.size()) {\n      items.remove(index);\n    }\n else {\n      if (log.isLoggable(PlatformLogger.Level.FINE)) {\n        log.fine(\"WARNING: Attempt to remove non-existing menu item, index : \" + index + \", item count : \"+ items.size());\n      }\n    }\n  }\n  updateSize();\n}\n", "docstring": "removes item at the specified index from items vector .", "partition": "test"}
{"idx": "1099", "code": "public static int countCSSPrimitiveNames(){\n  return ALL_PRIMITIVE_PROPERTY_NAMES.size();\n}\n", "docstring": "returns a count of all css primitive ( non - shorthand ) properties known to this class .", "partition": "test"}
{"idx": "1100", "code": "private void checkPermission(Object object,NamespacePermissionEnum[] permissions,List<AccessDeniedException> accessDeniedExceptions){\n  if (object != null) {\n    if (object instanceof Collection) {\n      Collection<?> collection=(Collection<?>)object;\n      for (      Object element : collection) {\n        checkPermission(element,permissions,accessDeniedExceptions);\n      }\n    }\n else     if (object instanceof String) {\n      try {\n        checkPermission((String)object,permissions);\n      }\n catch (      AccessDeniedException accessDeniedException) {\n        accessDeniedExceptions.add(accessDeniedException);\n      }\n    }\n else {\n      throw new IllegalStateException(String.format(\"Object must be of type %s or %s. Actual object.class = %s\",String.class,Collection.class,object.getClass()));\n    }\n  }\n}\n", "docstring": "checks the current user \"'\" s permissions against the given object which may represent a single or multiple namespaces . allowed types are string or collection of string .", "partition": "test"}
{"idx": "1101", "code": "private static Intent createMapActivityIntent(Context context,URLSpan[] urlSpans){\n  for (int span_i=0; span_i < urlSpans.length; span_i++) {\n    URLSpan urlSpan=urlSpans[span_i];\n    String urlString=urlSpan.getURL();\n    if (urlString.startsWith(GEO_PREFIX)) {\n      Intent geoIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(urlString));\n      geoIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n      return geoIntent;\n    }\n  }\n  return null;\n}\n", "docstring": "create an intent to take the user to maps , using the first map link available . if no links are found , return null .", "partition": "test"}
{"idx": "1102", "code": "private StringBuilder generateParameters(){\n  StringBuilder parameters=new StringBuilder();\n  if (filterMap == null && expandParameters == null) {\n    return parameters;\n  }\n  parameters.append(\'?\');\n  int filterParameterCounter=0;\n  if (filterMap != null && !filterMap.isEmpty()) {\n    parameters.append(FILTER_PREFIX);\n    for (    Map.Entry<String,String> filterEntry : filterMap.entrySet()) {\n      parameters.append(String.format(\"%s eq \'%s\'\",filterEntry.getKey(),filterEntry.getValue()));\n      if (++filterParameterCounter < filterMap.size()) {\n        parameters.append(\" and \");\n      }\n    }\n    if (expandParameters != null) {\n      parameters.append(\"&\");\n    }\n  }\n  if (expandParameters != null) {\n    parameters.append(EXPAND_PREFIX);\n    Iterator iterator=expandParameters.iterator();\n    parameters.append(String.format(\"%s\",iterator.next()));\n    while (iterator.hasNext()) {\n      parameters.append(String.format(\",%s\",iterator.next()));\n    }\n  }\n  return parameters;\n}\n", "docstring": "returns a stringbuilder that is consisted of filtering and expanding parameters that in turn are appended to the query string used for odata client . an odata client query can have either one of filter or expand parameters ( with multiple properties if desired ) or both . < p >", "partition": "test"}
{"idx": "1103", "code": "public static @CheckForNull @SlashedClassName String fromFieldSignature(String signature){\n  if (signature.charAt(0) != 'L') {\n    return null;\n  }\n  return signature.substring(1,signature.length() - 1);\n}\n", "docstring": "converts from signature to slashed class name ( e . g . , from ljava / lang / string ; to java / lang / string ) . returns null if it is the signature for an array or primitive type .", "partition": "test"}
{"idx": "1104", "code": "private void paintPreview(int dx,int dy,float zoomfactor){\n  if (image != null) {\n    Graphics2D g2=(Graphics2D)getGraphics();\n    UColor bg=renderer.getBackgroundColor();\n    g2.setBackground(new Color(bg.getRed(),bg.getGreen(),bg.getBlue(),bg.getAlpha()));\n    int newWidth=Math.round(image.getWidth(null) * zoomfactor);\n    int newHeight=(int)Math.round(image.getHeight(null) * zoomfactor);\n    g2.drawImage(image,dx,dy,newWidth,newHeight,null);\n    if (dx > 0)     g2.clearRect(0,0,dx,getHeight());\n else     g2.clearRect(getWidth() + dx,0,getWidth(),getHeight());\n    if (dy > 0)     g2.clearRect(0,0,getWidth(),dy);\n else     g2.clearRect(0,getHeight() + dy,getWidth(),getHeight());\n  }\n}\n", "docstring": "draws the off - screen image if exists at position ( dx , dy ) scaled by the specified factor .", "partition": "test"}
{"idx": "1105", "code": "public static List<List<Double>> partitionVariable(List<Double> arr,int chunk){\n  int count=0;\n  List<List<Double>> ret=new ArrayList<List<Double>>();\n  while (count < arr.size()) {\n    List<Double> sublist=arr.subList(count,count + chunk);\n    count+=chunk;\n    ret.add(sublist);\n  }\n  for (  List<Double> lists : ret) {\n    if (lists.size() < chunk)     ret.remove(lists);\n  }\n  return ret;\n}\n", "docstring": "this will partition the given whole variable data applytransformtodestination in to the specified chunk number .", "partition": "test"}
{"idx": "1106", "code": "private static void updateWindowUI(Window window){\n  SwingUtilities.updateComponentTreeUI(window);\n  Window ownedWins[]=window.getOwnedWindows();\n  for (  Window ownedWin : ownedWins) {\n    updateWindowUI(ownedWin);\n  }\n}\n", "docstring": "updates the ui of the passed in window and all its children .", "partition": "test"}
{"idx": "1107", "code": "public ArrayList<ConstraintWidget> findWidgets(WidgetContainer container,int x,int y,int width,int height){\n  ArrayList<ConstraintWidget> found=new ArrayList<>();\n  Rectangle area=new Rectangle(x,y,width,height);\n  for (  ConstraintWidget widget : container.getChildren()) {\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n    if (!decorator.isVisible()) {\n      continue;\n    }\n    Rectangle bounds=new Rectangle(widget.getDrawX(),widget.getDrawY(),widget.getWidth(),widget.getHeight());\n    if (area.intersects(bounds)) {\n      found.add(widget);\n    }\n  }\n  return found;\n}\n", "docstring": "gather all the widgets contained in the area specified and return them as an array , taking the decorator visibility in account", "partition": "test"}
{"idx": "1108", "code": "public final void printSymbol(CharSequence text) throws IOException {\n  if (text == null) {\n    appendAscii(\"null.symbol\");\n  }\n else   if (text.length() == 0) {\n    throw new EmptySymbolException();\n  }\n else   if (symbolNeedsQuoting(text,true)) {\n    appendAscii(\'\\\'\');\n    printCodePoints(text,SYMBOL_ESCAPE_CODES);\n    appendAscii(\'\\\'\');\n  }\n else {\n    appendAscii(text);\n  }\n}\n", "docstring": "print an ion symbol type . this method will check if symbol needs quoting", "partition": "test"}
{"idx": "1109", "code": "@Override public String toString(){\n  Map<Assignment,Double> sortedTable=InferenceUtils.getNBest(table,Math.max(table.size(),1));\n  String str=\"\";\n  for (  Entry<Assignment,Double> entry : sortedTable.entrySet()) {\n    String prob=StringUtils.getShortForm(entry.getValue());\n    str+=\"P(\" + entry.getKey() + \"):=\"+ prob+ \"\\n\";\n  }\n  return (str.length() > 0) ? str.substring(0,str.length() - 1) : str;\n}\n", "docstring": "returns a string representation of the probability table", "partition": "test"}
{"idx": "1110", "code": "protected final void updateBorderText(final String text){\n  Preconditions.checkNotNull(text,\"IE01842: Text argument can not be null\");\n  m_titledBorder.setTitle(text);\n  updateUI();\n}\n", "docstring": "updates the border text of the component .", "partition": "test"}
{"idx": "1111", "code": "private void addClasses(Class<?>[] classes,HashSet<Class<?>> result,String fieldName){\n  if (classes == null || classes.length == 0)   Error.classesAbsent(fieldName,configuredClass);\n  for (  Class<?> classe : classes)   result.add(classe);\n}\n", "docstring": "adds to the result parameter all classes that aren \"'\" t present in it", "partition": "test"}
{"idx": "1112", "code": "public void resetReferences(){\n  if (_refs != null)   _refs.clear();\n}\n", "docstring": "resets the references for streaming .", "partition": "test"}
{"idx": "1113", "code": "public void schemaChanged(String serviceName,String version){\nsynchronized (mapRealmToFormat) {\n    mapRealmToFormat.remove(ROOT);\n  }\n}\n", "docstring": "this method will be invoked when a service \"'\" s schema has been changed .", "partition": "test"}
{"idx": "1114", "code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  date.year=YEAR;\n  date.day=DAY;\n  if (str.charAt(0) != \'-\' || str.charAt(1) != \'-\') {\n    throw new SchemaDateTimeException(\"Invalid format for gMonth: \" + str);\n  }\n  int stop=4;\n  date.month=parseInt(str,2,stop);\n  if (str.length() >= stop + 2 && str.charAt(stop) == \'-\' && str.charAt(stop + 1) == \'-\') {\n    stop+=2;\n  }\n  if (stop < len) {\n    if (!isNextCharUTCSign(str,stop,len)) {\n      throw new SchemaDateTimeException(\"Error in month parsing: \" + str);\n    }\n else {\n      getTimeZone(str,date,stop,len);\n    }\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != \'Z\') {\n    normalize(date);\n  }\n  date.position=1;\n  return date;\n}\n", "docstring": "parses , validates and computes normalized version of gmonth object", "partition": "test"}
{"idx": "1115", "code": "private void addToQueue(SerialMessage serialMessage){\n  if (serialMessage == null) {\n    return;\n  }\n  if (!msgQueue.contains(serialMessage) && msgQueue.remainingCapacity() > 1) {\n    msgQueue.add(serialMessage);\n  }\n  sendMessage();\n}\n", "docstring": "move the messages to the queue", "partition": "test"}
{"idx": "1116", "code": "private DBID stringToDBID(String query){\n  return DBIDUtil.importInteger(Integer.valueOf(query));\n}\n", "docstring": "parse a string into a dbid .", "partition": "test"}
{"idx": "1117", "code": "@Override public final void writeShort(int v) throws IOException {\n  work[0]=(byte)v;\n  work[1]=(byte)(v >> 8);\n  dis.write(work,0,2);\n}\n", "docstring": "write short , 16 - bits . like dataoutputstream . writeshort . also acts as a writeunsignedshort", "partition": "test"}
{"idx": "1118", "code": "final public void println(long v){\n  Writer out=this.out;\n  if (out == null)   return;\n  print(v);\n  try {\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a long followed by a newline .", "partition": "test"}
{"idx": "1119", "code": "public ThriftServiceMetadata(Class<?> serviceType){\n  requireNonNull(serviceType,\"serviceType\");\n  interfaces=init(null,Collections.singleton(serviceType));\n}\n", "docstring": "creates a new instance from a single thrift service interface .", "partition": "test"}
{"idx": "1120", "code": "public WritableRaster createCompatibleWritableRaster(int w,int h){\n  if (w <= 0 || h <= 0) {\n    throw new RasterFormatException(\"negative \" + ((w <= 0) ? \"width\" : \"height\"));\n  }\n  SampleModel sm=sampleModel.createCompatibleSampleModel(w,h);\n  return new BytePackedRaster(sm,new Point(0,0));\n}\n", "docstring": "creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .", "partition": "test"}
{"idx": "1121", "code": "public static Response invalidEntity(ConstraintViolationException e){\n  StringBuilder errorMessage=new StringBuilder();\n  boolean firstPass=true;\n  for (  ConstraintViolation error : e.getConstraintViolations()) {\n    if (!firstPass) {\n      errorMessage.append(\", \");\n    }\n    errorMessage.append(String.format(\"%s %s (was %s)\",error.getPropertyPath(),error.getMessage(),error.getInvalidValue()));\n    firstPass=false;\n  }\n  ExternalException externalException=new ExternalException(ErrorCode.INVALID_ENTITY,errorMessage.toString(),null);\n  return externalException(externalException);\n}\n", "docstring": "return an error response generated by a validation failure , invalid json , etc .", "partition": "test"}
{"idx": "1122", "code": "public String checkStartBlock(int mode){\n  if (log.isDebugEnabled())   log.debug(\"checkStartBlock for warrant \\\"\" + getDisplayName() + \"\\\".\");\n  BlockOrder bo=_orders.get(0);\n  OBlock block=bo.getBlock();\n  String msg=block.allocate(this);\n  if (msg != null) {\n    return msg;\n  }\n  msg=bo.setPath(this);\n  if (msg != null) {\n    return msg;\n  }\n  int state=block.getState();\n  if ((state & OBlock.DARK) != 0 || _tempRunBlind) {\n    msg=Bundle.getMessage(\"BlockDark\",block.getDisplayName());\n  }\n else   if ((state & OBlock.OCCUPIED) == 0) {\n    if (mode == MODE_LEARN) {\n      msg=\"learnStart\";\n    }\n else {\n      msg=\"warnStart\";\n    }\n    msg=Bundle.getMessage(msg,getTrainName(),block.getDisplayName());\n  }\n else {\n    TrackerTableAction.stopTrackerIn(block);\n  }\n  return msg;\n}\n", "docstring": "check start block for occupied for start of run", "partition": "test"}
{"idx": "1123", "code": "private void parseSwitch(int indent,boolean firstContent,String header,Layout layout,List<Elem> elems){\n  TokenStream tokens=new TokenStream(header);\n  Elem selector=parseExpr(tokens);\n  tokens.checkAtEnd();\n  ImmutableList.Builder<Case> cases=ImmutableList.builder();\n  List<Elem> defaultElems=null;\n  boolean done;\n  String line=getNextLine();\n  Matcher matcher=COMMAND_LINE.matcher(line);\n  String command;\n  String rest;\n  if (matcher.find()) {\n    command=matcher.group(COMMAND_NAME_GROUP);\n    rest=line.substring(matcher.end());\n    done=false;\n  }\n else {\n    error(\"expected \'@end\', \'@case\' or \'@default\' command after \'switch\'\");\n    done=true;\n    command=null;\n    rest=null;\n  }\n  while (!done) {\nswitch (command) {\ncase END_COMMAND:\n      checkHeaderEmpty(command,rest);\n    done=true;\n  break;\ncase DEFAULT_COMMAND:\ncheckHeaderEmpty(command,rest);\nif (defaultElems != null) {\nerror(\"duplicate \'@default\' in @switch\");\n}\ndefaultElems=parseUntil(indent,layout,END_COMMAND);\ncommand=lastTerminator;\nrest=lastTerminatorHeader;\ndone=lastTerminator == null;\nbreak;\ncase CASE_COMMAND:\ntokens=new TokenStream(rest);\nElem value=parseExpr(tokens);\ntokens.checkAtEnd();\nList<Elem> caseElems=parseUntil(indent,layout,END_COMMAND,CASE_COMMAND,DEFAULT_COMMAND);\nif (value != null) {\ncases.add(Case.create(value,caseElems));\n}\ncommand=lastTerminator;\nrest=lastTerminatorHeader;\ndone=lastTerminator == null;\nbreak;\ndefault :\nunexpectedCommandError(command);\ndone=true;\nbreak;\n}\n}\nif (selector != null) {\nelems.add(Block.create(!firstContent,Switch.create(input.location(),selector,cases.build(),defaultElems)));\n}\n}\n", "docstring": "parse a switch command .", "partition": "test"}
{"idx": "1124", "code": "public void init(String prefix,java.net.URL url){\n  try {\n    java.io.InputStream in=url.openStream();\n    Properties props=new Properties();\n    props.load(in);\n    init(getLayers(prefix,props));\n  }\n catch (  java.net.MalformedURLException murle) {\n    logger.warning(\"LayerHandler.init(URL): \" + url + \" is not a valid URL\");\n  }\ncatch (  java.io.IOException e) {\n    logger.warning(\"LayerHandler.init(URL): Caught an IOException\");\n  }\n}\n", "docstring": "initialize the layerhandler by having it construct it \"'\" s layers from a url containing an openmap . properties file .", "partition": "test"}
{"idx": "1125", "code": "public static Properties createProperties(final Map<String,String> map){\n  Properties properties=new Properties();\n  if (!(map == null || map.isEmpty())) {\n    for (    Entry<String,String> entry : map.entrySet()) {\n      properties.setProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  return properties;\n}\n", "docstring": "creates an properties object initialized with the value from the given map . < p >", "partition": "test"}
{"idx": "1126", "code": "public Node selectFirst(String query){\n  List<Node> selectedNodes=select(query);\n  if (selectedNodes.isEmpty()) {\n    return null;\n  }\n  return selectedNodes.get(0);\n}\n", "docstring": "selects nodes using css3 selector query and returns the very first one .", "partition": "test"}
{"idx": "1127", "code": "public static String[] stringArrayFromProperties(Properties p,String propName,String tok){\n  String[] ret=null;\n  String raw=p.getProperty(propName);\n  if (raw != null && raw.length() > 0) {\n    try {\n      StringTokenizer token=new StringTokenizer(raw,tok);\n      int numPaths=token.countTokens();\n      ret=new String[numPaths];\n      for (int i=0; i < numPaths; i++) {\n        ret[i]=token.nextToken();\n      }\n      return ret;\n    }\n catch (    java.util.NoSuchElementException e) {\n      e.printStackTrace();\n    }\n  }\n  return ret;\n}\n", "docstring": "takes a string of representing token separated properties and returns an array of parsed strings . note : this method currently doesn \"'\" t support appropriate quoting of the token , although it probably should . . .", "partition": "test"}
{"idx": "1128", "code": "public void generate(int x1,int y1,int x2,int y2){\n  Point midPoint=new Point();\n  Point arcCenter=new Point();\n  Point2D peakPoint=new Point2D.Float();\n  double distance=Math.sqrt(Math.pow(Math.abs(y2 - y1),2.0) + Math.pow(Math.abs(x2 - x1),2.0));\n  double straightLineSlope=Math.atan((double)(y2 - y1) / (double)(x2 - x1));\n  double inverseSlope=straightLineSlope - (Math.PI / 2.0);\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: Slope is \" + Math.toDegrees(straightLineSlope) + \" degrees, distance = \"+ distance+ \" pixels.\");\n  }\n  midPoint.setLocation(x1 + ((x2 - x1) / 2),y1 + ((y2 - y1) / 2));\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: Center point for (\" + x1 + \", \"+ y1+ \") to (\"+ x2+ \", \"+ y2+ \") is (\"+ midPoint.x+ \", \"+ midPoint.y+ \")\");\n  }\n  double arccos=Math.cos(arcAngle);\n  double arcRadius;\n  if (arccos != 1.0) {\n    arcRadius=distance / Math.sqrt(2.0 * (1.0 - Math.cos(arcAngle)));\n  }\n else {\n    arcRadius=distance / Math.sqrt(2.0);\n  }\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: radius of arc = \" + arcRadius);\n  }\n  double x=arcRadius - arcRadius * Math.cos(arcAngle);\n  double rPrime=(distance / 2.0) * (Math.sqrt(1.0 - Math.pow(x / distance,2.0))) / Math.sin(arcAngle / 2.0);\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: rPrime = \" + rPrime);\n  }\n  int direction=1;\n  if (arcUp)   direction=-1;\n  arcCenter.x=midPoint.x + (direction * (int)(rPrime * Math.cos(inverseSlope)));\n  arcCenter.y=midPoint.y + (direction * (int)(rPrime * Math.sin(inverseSlope)));\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generateArc: creating supplimental graphics list\");\n    arcGraphics=new OMGraphicList();\n    double dist1=Math.sqrt(Math.pow((double)(arcCenter.x - x1),2.0) + Math.pow((double)(arcCenter.y - y1),2.0));\n    double dist2=Math.sqrt(Math.pow((double)(arcCenter.x - x2),2.0) + Math.pow((double)(arcCenter.y - y2),2.0));\n    Debug.output(\"ArcCalc.generate: Center focus for arc is (\" + arcCenter.x + \", \"+ arcCenter.y+ \") along slope line of \"+ Math.toDegrees(inverseSlope)+ \" degrees).\");\n    Debug.output(\"ArcCalc.generate: Distance to point 1 from arc focus = \" + dist1 + \"\\n                    Distance to point 2 from arc focus = \"+ dist2);\n    OMRect point1=new OMRect(x1 - 1,y1 - 1,x1 + 1,y1 + 1);\n    OMRect point2=new OMRect(x2 - 1,y2 - 1,x2 + 1,y2 + 1);\n    OMRect arcPoint=new OMRect(arcCenter.x - 1,arcCenter.y - 1,arcCenter.x + 1,arcCenter.y + 1);\n    point1.setLinePaint(OMColor.red);\n    point2.setLinePaint(OMColor.red);\n    arcPoint.setLinePaint(OMColor.blue);\n    arcGraphics.add(point1);\n    arcGraphics.add(point2);\n    arcGraphics.add(arcPoint);\n    OMLine line1=new OMLine(x1,y1,x2,y2);\n    OMLine line2=new OMLine(midPoint.x,midPoint.y,arcCenter.x,arcCenter.y);\n    arcGraphics.add(line1);\n    arcGraphics.add(line2);\n  }\n  int realCount=0;\n  double startSlope=getRealAngle((float)arcCenter.getX(),(float)arcCenter.getY(),x1,y1);\n  double endSlope=getRealAngle((float)arcCenter.getX(),(float)arcCenter.getY(),x2,y2);\n  double smallSlope, largeSlope;\n  double angleIncrement;\n  smallSlope=(startSlope > endSlope) ? endSlope : startSlope;\n  largeSlope=(smallSlope == startSlope) ? endSlope : startSlope;\n  while (Math.abs(smallSlope - largeSlope) > Math.PI) {\n    if (Math.abs(largeSlope - smallSlope - Math.PI) < .001) {\n      break;\n    }\n    Debug.message(\"arc\",\"ArcCalc.generate: Modifying the starting slope.\");\n    double tmpSlope=smallSlope + MoreMath.TWO_PI;\n    smallSlope=largeSlope;\n    largeSlope=tmpSlope;\n  }\n  if (MoreMath.approximately_equal(arcAngle,Math.PI) && arcUp) {\n    Debug.message(\"arc\",\"ArcCalc.generate: Modifying 180 angle points.\");\n    double tmpSlope=smallSlope + MoreMath.TWO_PI;\n    smallSlope=largeSlope;\n    largeSlope=tmpSlope;\n  }\n  if (Math.abs(y2 - y1) < Math.abs(x2 - x1)) {\n    angleIncrement=Math.PI / Math.abs(x2 - x1);\n  }\n else {\n    angleIncrement=Math.PI / Math.abs(y2 - y1);\n  }\n  int numPoints=(int)(Math.abs(smallSlope - largeSlope) / angleIncrement + 2);\n  float[] xPoints=new float[numPoints];\n  float[] yPoints=new float[numPoints];\n  if (Debug.debugging(\"arc\")) {\n    Debug.output(\"ArcCalc.generate: angle to x1, y1 is \" + startSlope + \" (\"+ Math.toDegrees(startSlope)+ \" degrees), angle to x2, y2 is \"+ endSlope+ \" (\"+ Math.toDegrees(endSlope)+ \" degrees)\");\n    Debug.output(\"ArcCalc.generate: Starting angle is \" + smallSlope + \"(\"+ Math.toDegrees(smallSlope)+ \" degrees), end angle is \"+ largeSlope+ \" (\"+ Math.toDegrees(largeSlope)+ \" degrees), incrementing by \"+ angleIncrement+ \" (\"+ Math.toDegrees(angleIncrement)+ \" degrees)\");\n  }\n  reversed=false;\n  while (smallSlope < largeSlope && realCount < numPoints) {\n    xPoints[realCount]=arcCenter.x + (int)(arcRadius * Math.cos(smallSlope));\n    yPoints[realCount]=arcCenter.y + (int)(arcRadius * Math.sin(smallSlope));\n    if (realCount == 0 && xPoints[realCount] == x2) {\n      Debug.message(\"arc\",\"ArcCalc: line reversed\");\n      reversed=true;\n    }\n    if (Debug.debugging(\"arc\") && realCount == 0) {\n      OMLine startLine=new OMLine(arcCenter.x,arcCenter.y,(int)xPoints[0],(int)yPoints[0]);\n      startLine.setLinePaint(OMColor.white);\n      arcGraphics.add(startLine);\n    }\n else     if (Debug.debugging(\"arcdetail\")) {\n      Debug.output(\"  angle \" + smallSlope + \" (\"+ smallSlope * 180 / Math.PI + \" degrees)  = \" + xPoints[realCount] + \", \" + yPoints[realCount]);\n    }\n    if (Math.abs(largeSlope - smallSlope - (arcAngle / 2.0)) < angleIncrement) {\n      peakPoint.setLocation(xPoints[realCount],yPoints[realCount]);\n      Debug.message(\"arc\",\"ArcCalc: Found a midpoint.\");\n    }\n    smallSlope+=angleIncrement;\n    realCount++;\n  }\n  xpoints=new float[realCount];\n  ypoints=new float[realCount];\n  System.arraycopy(xPoints,0,xpoints,0,realCount);\n  System.arraycopy(yPoints,0,ypoints,0,realCount);\n}\n", "docstring": "generate the points that will generate the curved line between two points . the arcangle is the number of radians of a circle that the arc should represent . math . pi is the max . the setarcangle should be called before this method is called , so that the method knows what to create .", "partition": "test"}
{"idx": "1129", "code": "private static int compareLocales(Locale primary,Locale other){\n  final String lang=primary.getLanguage();\n  if ((lang == null) || !lang.equals(other.getLanguage())) {\n    return 0;\n  }\n  final String country=primary.getCountry();\n  if ((country == null) || !country.equals(other.getCountry())) {\n    return 1;\n  }\n  final String variant=primary.getVariant();\n  if ((variant == null) || !variant.equals(other.getVariant())) {\n    return 2;\n  }\n  return 3;\n}\n", "docstring": "compares a locale against a primary locale . returns higher values for closer matches . a return value of 3 indicates that the locale is an exact match for the primary locale \"'\" s language , country , and variant .", "partition": "test"}
{"idx": "1130", "code": "void queryReadResult(PreparedStatement prep) throws SQLException {\n  ResultSet rs=prep.executeQuery();\n  ResultSetMetaData meta=rs.getMetaData();\n  int columnCount=meta.getColumnCount();\n  while (rs.next()) {\n    for (int i=0; i < columnCount; i++) {\n      rs.getString(i + 1);\n    }\n  }\n}\n", "docstring": "execute a query and read all rows .", "partition": "test"}
{"idx": "1131", "code": "public boolean equals(Object obj){\n  if (obj instanceof MSort) {\n    MSort ms=(MSort)obj;\n    if (data == ms.data)     return true;\n  }\n  return false;\n}\n", "docstring": "equal ( based on data , ignores index )", "partition": "test"}
{"idx": "1132", "code": "public static void endTransaction(final CConnection connection) throws SQLException {\n  endTransaction(connection.getConnection());\n}\n", "docstring": "commits and finishes a formerly started transaction .", "partition": "test"}
{"idx": "1133", "code": "public CCrossReferencesPanel(){\n  super(new BorderLayout());\n  m_table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  add(new JScrollPane(m_table));\n  m_table.addMouseListener(new InternalMouseListener());\n}\n", "docstring": "creates a new panel object .", "partition": "test"}
{"idx": "1134", "code": "private void changeOpenAMDebugFolder(String newOpenAMDebugFolder){\n  SystemPropertiesManager.initializeProperties(DebugConstants.CONFIG_DEBUG_DIRECTORY,newOpenAMDebugFolder);\n}\n", "docstring": "change the debug logs folder", "partition": "test"}
{"idx": "1135", "code": "protected String computeFullUrl(URL baseUrl,String link){\n  if (link == null || link.length() == 0) {\n    return null;\n  }\n  if (!link.startsWith(\"http\")) {\n    if (link.startsWith(\"/\")) {\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ link;\n    }\n else {\n      if (link.contains(\":\")) {\n        return null;\n      }\n      String path=baseUrl.getPath();\n      if (!path.endsWith(\"/\")) {\n        int sep=path.lastIndexOf(\"/\");\n        String file=path.substring(sep + 1);\n        if (file.contains(\".\") || file.contains(\"?\"))         path=path.substring(0,sep);\n      }\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ path+ \"/\"+ link;\n    }\n  }\n  link=normalizeUrlEnding(link);\n  String l=link.toLowerCase(Locale.ROOT);\n  if (l.endsWith(\".jpg\") || l.endsWith(\".jpeg\") || l.endsWith(\".png\")|| l.endsWith(\".gif\")) {\n    return null;\n  }\n  return link;\n}\n", "docstring": "computes the full url based on a base url and a possibly relative link found in the href param of an html anchor .", "partition": "test"}
{"idx": "1136", "code": "private void loadManifest(){\n  if (_isManifestRead)   return;\nsynchronized (this) {\n    if (_isManifestRead)     return;\n    try {\n      _manifest=_jarPath.getManifest();\n      if (_manifest == null)       return;\n      Attributes attr=_manifest.getMainAttributes();\n      if (attr != null)       addManifestPackage(\"\",attr);\n      Map<String,Attributes> entries=_manifest.getEntries();\n      for (      Map.Entry<String,Attributes> entry : entries.entrySet()) {\n        String pkg=entry.getKey();\n        attr=entry.getValue();\n        if (attr == null)         continue;\n        addManifestPackage(pkg,attr);\n      }\n    }\n catch (    IOException e) {\n      log.log(Level.WARNING,e.toString(),e);\n    }\n finally {\n      _isManifestRead=true;\n    }\n  }\n}\n", "docstring": "reads the jar \"'\" s manifest .", "partition": "test"}
{"idx": "1137", "code": "public ReferenceBinding[] convertToRawTypes(ReferenceBinding[] originalTypes,boolean forceErasure,boolean forceRawEnclosingType){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] convertedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    ReferenceBinding convertedType=(ReferenceBinding)convertToRawType(forceErasure ? originalType.erasure() : originalType,forceRawEnclosingType);\n    if (convertedType != originalType) {\n      if (convertedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,convertedTypes=new ReferenceBinding[length],0,i);\n      }\n      convertedTypes[i]=convertedType;\n    }\n else     if (convertedTypes != originalTypes) {\n      convertedTypes[i]=originalType;\n    }\n  }\n  return convertedTypes;\n}\n", "docstring": "convert an array of types in raw forms . only allocate an array if anything is different .", "partition": "test"}
{"idx": "1138", "code": "public void addColumn(int idx,Column column){\n  if (column != null) {\n    columns.add(idx,column);\n  }\n}\n", "docstring": "adds the given column at the specified position .", "partition": "test"}
{"idx": "1139", "code": "boolean removeDisplay(Display display){\n  return m_displays.remove(display);\n}\n", "docstring": "remove a display from this visualization .", "partition": "test"}
{"idx": "1140", "code": "public double nextGaussian(){\n  if (mHaveNextNextGaussian) {\n    mHaveNextNextGaussian=false;\n    return mNextNextGaussian;\n  }\n else {\n    double v1, v2, s;\n    do {\n      v1=2 * nextDouble() - 1;\n      v2=2 * nextDouble() - 1;\n      s=v1 * v1 + v2 * v2;\n    }\n while (s >= 1 || s == 0);\n    final double multiplier=StrictMath.sqrt(-2 * StrictMath.log(s) / s);\n    mNextNextGaussian=v2 * multiplier;\n    mHaveNextNextGaussian=true;\n    return v1 * multiplier;\n  }\n}\n", "docstring": "return the next gaussian see knuth , acp , section 3 . 4 . 1 algorithm c .", "partition": "test"}
{"idx": "1141", "code": "private void fireEvent(final IRunningQuery q){\n  if (q == null)   throw new IllegalArgumentException();\n  if (listeners.isEmpty()) {\n    return;\n  }\n  final IRunningQueryListener[] a=listeners.toArray(new IRunningQueryListener[0]);\n  for (  IRunningQueryListener l : a) {\n    final IRunningQueryListener listener=l;\n    try {\n      listener.notify(q);\n    }\n catch (    Throwable t) {\n      if (InnerCause.isInnerCause(t,InterruptedException.class)) {\n        throw new RuntimeException(t);\n      }\n      log.error(t,t);\n    }\n  }\n}\n", "docstring": "send an event to all registered listeners .", "partition": "test"}
{"idx": "1142", "code": "private void updateContactHeaderPort(int localPort,SIPMessage message){\n  if (message != null && message.getContactHeader() != null) {\n    ContactHeader contactHeader=message.getContactHeader();\n    Address contactAddress=contactHeader.getAddress();\n    contactAddress.setPort(localPort);\n  }\n}\n", "docstring": "update port of contact header to reflect local port", "partition": "test"}
{"idx": "1143", "code": "@Nullable GridCacheMvccCandidate addEntry(GridLocalCacheEntry entry) throws GridCacheEntryRemovedException {\n  GridCacheMvccCandidate c=entry.addLocal(threadId,lockVer,null,null,timeout,!inTx(),inTx(),implicitSingle(),true);\n  entries.add(entry);\n  if (c == null && timeout < 0) {\n    if (log.isDebugEnabled())     log.debug(\"Failed to acquire lock with negative timeout: \" + entry);\n    onFailed();\n    return null;\n  }\n  if (c != null) {\n    entry.readyLocal(c);\n  }\n  return c;\n}\n", "docstring": "adds entry to future .", "partition": "test"}
{"idx": "1144", "code": "@Override public void visitVertex(StreetRouter.State state){\n  Integer edgeIdx=state.backEdge;\n  if (!(edgeIdx == null || edgeIdx == -1)) {\n    EdgeStore.Edge edge=edgeStore.getCursor(edgeIdx);\n    GeoJsonFeature feature=new GeoJsonFeature(edge.getGeometry());\n    feature.addProperty(\"weight\",state.weight);\n    feature.addProperty(\"mode\",state.streetMode);\n    feature.addProperty(\"backEdge\",state.backEdge);\n    features.add(feature);\n  }\n}\n", "docstring": "saves current state geometry mode and weight as geojson feature properties in list of features . it is used in full state graph when debugging", "partition": "test"}
{"idx": "1145", "code": "public void test_BSBM_Q1_noSolutions() throws Exception {\n  final TestHelper helper=new TestHelper(\"rto/BSBM-Q1\",\"rto/BSBM-Q1.rq\",new String[]{},\"rto/BSBM-Q1-noSolutions.srx\");\n  assertSameJoinOrder(new int[]{2,1,3,4,5},helper);\n}\n", "docstring": "test of bsbm q1 against an empty data set . there are no solutions in the data .", "partition": "test"}
{"idx": "1146", "code": "public static void deleteFileOrLog(File file){\n  if (!file.delete()) {\n    logger.warn(FAILED_DELETING_FILE + file.getPath());\n  }\n}\n", "docstring": "delete a file from the file system or log the failure if unable to delete it .", "partition": "test"}
{"idx": "1147", "code": "public GitlabGroupMember addGroupMember(GitlabGroup group,GitlabUser user,GitlabAccessLevel accessLevel) throws IOException {\n  return addGroupMember(group.getId(),user.getId(),accessLevel);\n}\n", "docstring": "add a group member .", "partition": "test"}
{"idx": "1148", "code": "protected Logger(String name,String resourceBundleName){\n  super(name,resourceBundleName);\n}\n", "docstring": "protected method to construct a logger for a named subsystem . < p > the logger will be initially configured with a null level and with useparenthandlers true .", "partition": "test"}
{"idx": "1149", "code": "@Override public void increment(double coord,short val){\n  int bin=getBinNr(coord);\n  if (bin < 0) {\n    if (size - bin > data.length) {\n      short[] tmpdata=new short[growSize(data.length,size - bin)];\n      System.arraycopy(data,0,tmpdata,-bin,size);\n      data=tmpdata;\n    }\n else {\n      System.arraycopy(data,0,data,-bin,size);\n      Arrays.fill(data,0,-bin,(short)0);\n    }\n    data[0]=val;\n    assert (data.length >= size - bin);\n    offset-=bin;\n    size-=bin;\n  }\n else   if (bin >= data.length) {\n    short[] tmpdata=new short[growSize(data.length,bin + 1)];\n    System.arraycopy(data,0,tmpdata,0,size);\n    tmpdata[bin]=val;\n    data=tmpdata;\n    size=bin + 1;\n    max=Double.MAX_VALUE;\n  }\n else {\n    if (bin >= size) {\n      size=bin + 1;\n    }\n    data[bin]+=val;\n  }\n}\n", "docstring": "increment the value of a bin .", "partition": "test"}
{"idx": "1150", "code": "default Document putAll(Map<? extends CharSequence,Object> fields){\n  if (fields != null) {\n    for (    Map.Entry<? extends CharSequence,Object> entry : fields.entrySet()) {\n      set(entry.getKey(),entry.getValue());\n    }\n  }\n  return this;\n}\n", "docstring": "sets on this object all key / value pairs from the supplied map . if the supplied map is null , this method does nothing .", "partition": "test"}
{"idx": "1151", "code": "public static double computeMAD(double[] x,double median){\n  for (int i=0; i < x.length; i++) {\n    x[i]=Math.abs(x[i] - median);\n  }\n  double mad=QuickSelect.median(x);\n  if (!(mad > 0.)) {\n    double min=Double.POSITIVE_INFINITY;\n    for (    double xi : x) {\n      if (xi > 0. && xi < min) {\n        min=xi;\n      }\n    }\n    if (min < Double.POSITIVE_INFINITY) {\n      mad=min;\n    }\n else {\n      mad=1.0;\n    }\n  }\n  return mad;\n}\n", "docstring": "compute the median absolute deviation from median .", "partition": "test"}
{"idx": "1152", "code": "private static <T>void initializeKnownPlugins(final T pluginInterface,final IPluginRegistry<IPlugin<T>> registry,final List<PluginConfigItem> xmlPluginOrder,final List<Pair<IPlugin<T>,PluginStatus>> validatedPlugins,final List<Pair<IPlugin<T>,Exception>> initializedPlugins,final Set<Long> processedPlugins){\n  for (  final PluginConfigItem pt : xmlPluginOrder) {\n    processedPlugins.add(pt.getGUID());\n    final IPlugin<T> plugin=findPlugin(validatedPlugins,pt.getGUID());\n    if (plugin != null) {\n      if (pt.isLoad()) {\n        initializePlugin(plugin,pluginInterface,registry,initializedPlugins);\n      }\n else {\n        registry.addDisabledPlugin(plugin,DisabledPluginReason.NotLoaded);\n      }\n    }\n  }\n}\n", "docstring": "loads the plugins that are configured in the configuration file .", "partition": "test"}
{"idx": "1153", "code": "public static void sessionStop(){\n  if (mProcess == null)   return;\n  mProcess.destroy();\n  mProcess=null;\n}\n", "docstring": "stops the superuser session", "partition": "test"}
{"idx": "1154", "code": "public static Request newUploadVideoRequest(Session session,File file,Callback callback) throws FileNotFoundException {\n  ParcelFileDescriptor descriptor=ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);\n  Bundle parameters=new Bundle(1);\n  parameters.putParcelable(file.getName(),descriptor);\n  return new Request(session,MY_VIDEOS,parameters,HttpMethod.POST,callback);\n}\n", "docstring": "creates a new request configured to upload a photo to the user \"'\" s default photo album . the photo will be read from the specified file descriptor .", "partition": "test"}
{"idx": "1155", "code": "private MulticastSocket createSocket() throws IOException {\n  MulticastSocket sock=new MulticastSocket(mcastPort);\n  sock.setLoopbackMode(false);\n  if (sockItf != null)   sock.setInterface(sockItf);\n  if (sock.getLoopbackMode())   U.warn(log,\"Loopback mode is disabled which prevents nodes on the same machine from discovering \" + \"each other.\");\n  sock.joinGroup(mcastGrp);\n  if (ttl != -1)   sock.setTimeToLive(ttl);\n  return sock;\n}\n", "docstring": "creates multicast socket and joins multicast group .", "partition": "test"}
{"idx": "1156", "code": "void copyNodeStructure(ArrayList<Node> destination){\n  while (destination.size() < nodes.size())   destination.add(new Node());\n  while (destination.size() > nodes.size())   destination.remove(0);\n  int n=nodes.size();\n  for (int i=0; i < n; i++) {\n    Node node0=nodes.get(i);\n    Node node1=destination.get(i);\n    node1.heightParameter=node0.heightParameter;\n    node1.rateParameter=node0.rateParameter;\n    node1.traitParameter=node0.traitParameter;\n    node1.partitioning=node0.partitioning;\n    node1.taxon=node0.taxon;\n    node1.bifurcation=node0.bifurcation;\n    node1.number=node0.number;\n    node1.myHashCode=node0.myHashCode;\n    if (node0.leftParent != null) {\n      node1.leftParent=storedNodes.get(nodes.indexOf(node0.leftParent));\n    }\n else {\n      node1.leftParent=null;\n    }\n    if (node0.rightParent != null) {\n      node1.rightParent=storedNodes.get(nodes.indexOf(node0.rightParent));\n    }\n else {\n      node1.rightParent=null;\n    }\n    if (node0.leftChild != null) {\n      node1.leftChild=storedNodes.get(nodes.indexOf(node0.leftChild));\n    }\n else {\n      node1.leftChild=null;\n    }\n    if (node0.rightChild != null) {\n      node1.rightChild=storedNodes.get(nodes.indexOf(node0.rightChild));\n    }\n else {\n      node1.rightChild=null;\n    }\n  }\n}\n", "docstring": "copies the node connections from this argmodel \"'\" s nodes array to the destination array . basically it connects up the nodes in destination in the same way as this argmodel is set up . this method is package private .", "partition": "test"}
{"idx": "1157", "code": "protected void checkSelectedSubsetMetaData(ExampleSetMetaData subsetMetaData){\n}\n", "docstring": "can be overridden to check the selected attributes for compatibility .", "partition": "test"}
{"idx": "1158", "code": "private void validateWill(String dest,Object payload){\n  if ((dest == null) || (payload == null)) {\n    throw new IllegalArgumentException();\n  }\n  MqttTopic.validate(dest,false);\n}\n", "docstring": "validates the will fields .", "partition": "test"}
{"idx": "1159", "code": "private Member nextMember(Member.Type type){\n  return new TestMember(type,new Address(\"localhost\",++port),new Address(\"localhost\",port + 1000));\n}\n", "docstring": "returns the next server address .", "partition": "test"}
{"idx": "1160", "code": "boolean isSystemFont(){\n  return systemFont;\n}\n", "docstring": "checks if this is a system font", "partition": "test"}
{"idx": "1161", "code": "public void addToBeLoaded(final String url){\n  if (toBeLoaded == null) {\n    toBeLoaded=new ArrayList<String>();\n  }\n  if (StringUtils.isNotBlank(url)) {\n    toBeLoaded.add(url);\n  }\n}\n", "docstring": "this methods allows to indicate if the resource must be obtained . if this method has been invoked then only the provided url will be processed .", "partition": "test"}
{"idx": "1162", "code": "default Document putAll(Iterator<Field> fields){\n  while (fields.hasNext()) {\n    Field field=fields.next();\n    setValue(field.getName(),field.getValue());\n  }\n  return this;\n}\n", "docstring": "sets on this object all name / value pairs from the supplied object . if the supplied object is null , this method does nothing .", "partition": "test"}
{"idx": "1163", "code": "public AppraiseGitReviewClient(Repository repo){\n  this.repo=repo;\n  this.author=new PersonIdent(repo);\n}\n", "docstring": "creates a new client for the given git repository .", "partition": "test"}
{"idx": "1164", "code": "public RootBlockView(final boolean rootBlock0,final ByteBuffer buf,final ChecksumUtility checker) throws RootBlockException {\n  if (buf == null)   throw new IllegalArgumentException();\n  if (buf.remaining() != SIZEOF_ROOT_BLOCK) {\n    throw new IllegalArgumentException(\"Expecting \" + SIZEOF_ROOT_BLOCK + \" remaining, actual=\"+ buf.remaining());\n  }\n  this.buf=buf.asReadOnlyBuffer();\n  this.rootBlock0=rootBlock0;\nswitch (getStoreType()) {\ncase RW:\n{\n      am=new RWAddressManager(null);\n      break;\n    }\ncase WORM:\n{\n    final int offsetBits=getOffsetBits();\n    am=new WormAddressManager(offsetBits);\n    break;\n  }\ndefault :\nthrow new RootBlockException(\"Unknown storeType=\" + getStoreType());\n}\nif (checker == null) {\nlog.warn(\"Checksum will not be validated\");\n}\nthis.checker=checker;\nvalid();\n}\n", "docstring": "create a new read - only view from the supplied buffer .", "partition": "test"}
{"idx": "1165", "code": "protected SOAPRequest createSOAPRequest(final String methodName,final SOAPMethodRequestWriter requestWriter){\n  final PostMethod method=new PostMethod(endpoint.toString());\n  method.setContentChunked(false);\n  setRequestHeaders(method,methodName);\n  final SOAPRequestEntity requestEntity=buildRequestEntity(methodName,requestWriter);\n  requestEntity.setSOAPHeaderProvider(soapHeaderProvider);\n  final BufferedSOAPRequestEntity bufferedEntity=new BufferedSOAPRequestEntity(requestEntity);\n  method.setRequestEntity(bufferedEntity);\n  return new SOAPRequest(method,requestEntity);\n}\n", "docstring": "create a soap request for the given method name . the writing of the request body is delegated to the given request writer .", "partition": "test"}
{"idx": "1166", "code": "@SuppressWarnings(\"unchecked\") @Test public void innerEnum(){\n  Class<?> pc=PlayingCard.class;\n  List<Enum<?>> include=new ArrayList<>();\n  List<Enum<?>> exclude=new ArrayList<>();\n  for (  Class<?> c : pc.getDeclaredClasses()) {\n    int mods=c.getModifiers();\n    if (c.isEnum()) {\n      if (Modifier.isPublic(mods)) {\n        include.addAll(asList(c.getEnumConstants()));\n      }\n else {\n        exclude.addAll(asList(c.getEnumConstants()));\n      }\n    }\n  }\n  Set<TypedOperation> actual=getConcreteOperations(pc);\n  assertEquals(\"number of statements\",include.size() + 5,actual.size());\n  for (  Enum<?> e : include) {\n    assertTrue(\"enum constant \" + e.name() + \" should occur\",actual.contains(createEnumOperation(e)));\n  }\n  for (  Enum<?> e : exclude) {\n    assertFalse(\"enum constant \" + e.name() + \" should not occur\",actual.contains(createEnumOperation(e)));\n  }\n}\n", "docstring": "innerenum tests that reflection . getstatements is collecting simple enum constants from a class . uses randoop . test . playingcard , which has two public enums , one private enum , and one enum with package access .", "partition": "test"}
{"idx": "1167", "code": "public static boolean inTargetDir(File file){\n  return inTargetDir(file.toPath());\n}\n", "docstring": "verify that the supplied file or directory is within the target directory .", "partition": "test"}
{"idx": "1168", "code": "public final boolean skipAny(char c,CharSequence csq){\n  int i=index;\n  int n=csq.length();\n  for (; (i < n) && (csq.charAt(i) == c); i++) {\n  }\n  if (i == index)   return false;\n  index=i;\n  return true;\n}\n", "docstring": "moves this cursor forward until it points to a character different from the specified character .", "partition": "test"}
{"idx": "1169", "code": "private void generateUniformIntegerExamples(Instances format,int numInstances,SubspaceClusterDefinition cl,String cName){\n  Instance example=null;\n  int numAtts=m_NumAttributes;\n  if (getClassFlag()) {\n    numAtts++;\n  }\n  example=new DenseInstance(numAtts);\n  example.setDataset(format);\n  boolean[] attributes=cl.getAttributes();\n  double[] minValue=cl.getMinValue();\n  double[] maxValue=cl.getMaxValue();\n  int[] minInt=new int[minValue.length];\n  int[] maxInt=new int[maxValue.length];\n  int[] intValue=new int[maxValue.length];\n  int[] numInt=new int[minValue.length];\n  int num=1;\n  for (int i=0; i < minValue.length; i++) {\n    minInt[i]=(int)Math.ceil(minValue[i]);\n    maxInt[i]=(int)Math.floor(maxValue[i]);\n    numInt[i]=(maxInt[i] - minInt[i] + 1);\n    num=num * numInt[i];\n  }\n  int numEach=numInstances / num;\n  int rest=numInstances - numEach * num;\n  for (int i=0; i < m_NumAttributes; i++) {\n    if (attributes[i]) {\n      example.setValue(i,minInt[i]);\n      intValue[i]=minInt[i];\n    }\n else {\n      example.setMissing(i);\n    }\n  }\n  if (getClassFlag()) {\n    example.setClassValue(cName);\n  }\n  int added=0;\n  int attr=0;\n  do {\n    for (int k=0; k < numEach; k++) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n    }\n    if (rest > 0) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n      rest--;\n    }\n    if (added >= numInstances) {\n      break;\n    }\n    boolean done=false;\n    do {\n      if (attributes[attr] && (intValue[attr] + 1 <= maxInt[attr])) {\n        intValue[attr]++;\n        done=true;\n      }\n else {\n        attr++;\n      }\n    }\n while (!done);\n    example.setValue(attr,intValue[attr]);\n  }\n while (added < numInstances);\n}\n", "docstring": "generate examples for a uniform cluster dataset .", "partition": "test"}
{"idx": "1170", "code": "public synchronized boolean removeAll(Collection c){\n  Object[] elements=getArray();\n  int len=elements.length;\n  if (len != 0) {\n    int newlen=0;\n    Object[] temp=new Object[len];\n    for (int i=0; i < len; ++i) {\n      Object element=elements[i];\n      if (!c.contains(element))       temp[newlen++]=element;\n    }\n    if (newlen != len) {\n      setArray(copyOfRange(temp,0,newlen,Object[].class));\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "removes from this list all of its elements that are contained in the specified collection . this is a particularly expensive operation in this class because of the need for an internal temporary array .", "partition": "test"}
{"idx": "1171", "code": "public Phone createPhone(String value){\n  PhoneField phoneImpl=new PhoneField();\n  try {\n    phoneImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return phoneImpl;\n}\n", "docstring": "returns phone object with the specified value .", "partition": "test"}
{"idx": "1172", "code": "private String convertToHtml(final String string){\n  return \"<pre><br/>\" + string.replaceAll(\"\\n\",\"<br/>\") + \"<br/></pre>\";\n}\n", "docstring": "converts text to html , by transforming \\ n to < br / >", "partition": "test"}
{"idx": "1173", "code": "private void reloadModelWithNewValue(final Long newValue){\n  final long newValueAsPrimitive=newValue == null ? getModelUpdatePeriod() : newValue;\n  for (  final PropertyChangeListener listener : modelUpdatePeriodListeners) {\n    final PropertyChangeEvent event=new PropertyChangeEvent(this,\"model\",getModelUpdatePeriod(),newValueAsPrimitive);\n    listener.propertyChange(event);\n  }\n}\n", "docstring": "notify all listeners about cacheperiod property changed . if passed newvalue is null , the oldvalue is taken as new value . this is the case when the reloadmodel is invoked .", "partition": "test"}
{"idx": "1174", "code": "public static void writeStringToWriter(String string,Writer writer) throws IOException {\n  BufferedWriter bw=new BufferedWriter(writer);\n  try {\n    bw.write(string);\n  }\n  finally {\n    bw.close();\n  }\n}\n", "docstring": "writes given string to given writer . close writer afterwards .", "partition": "test"}
{"idx": "1175", "code": "public final void decRef() throws IOException {\n  ensureOpen();\n  final int rc=refCount.decrementAndGet();\n  if (rc == 0) {\n    boolean success=false;\n    try {\n      doClose();\n      closed=true;\n      success=true;\n    }\n  finally {\n      if (!success) {\n        refCount.incrementAndGet();\n      }\n    }\n  }\n else   if (rc < 0) {\n    throw new IllegalStateException(\"too many decRef calls: refCount is \" + rc + \" after decrement\");\n  }\n}\n", "docstring": "expert : decreases the refcount of this taxonomyreader instance . if the refcount drops to 0 this taxonomy reader is closed .", "partition": "test"}
{"idx": "1176", "code": "public static X500Name x500PrincipalToX500Name(X500Principal principal){\n  return X500Name.getInstance(KseX500NameStyle.INSTANCE,principal.getEncoded());\n}\n", "docstring": "convert an x . 500 principal to an x . 500 name .", "partition": "test"}
{"idx": "1177", "code": "private void assertDescribedResource(final BigdataValue describedResource,final IDescribeCache describeCache,final TestHelper h){\n  final Graph actualGraph=describeCache.lookup(describedResource.getIV());\n  assertNotNull(actualGraph);\n  final Set<Statement> expectedGraph=getExpectedDescription(describedResource,h);\n  h.compareGraphs(new HashSet<Statement>(actualGraph),expectedGraph);\n  for (  Statement stmt : actualGraph) {\n    assertTrue(stmt instanceof BigdataStatement);\n    final BigdataStatement st=(BigdataStatement)stmt;\n    assertNotNull(st.s());\n    assertNotNull(st.p());\n    assertNotNull(st.o());\n    if (st.getContext() != null) {\n      assertNotNull(st.c());\n    }\n  }\n}\n", "docstring": "assert that a resource is described by the cache .", "partition": "test"}
{"idx": "1178", "code": "public boolean isFlat(){\n  return TYPE_FLAT.equals(getType());\n}\n", "docstring": "flat background type ( default )", "partition": "test"}
{"idx": "1179", "code": "@Deprecated private List<CharSequence> buildLimitedNetworksList(){\n  final Context context=getActivity();\n  final ArrayList<CharSequence> limited=Lists.newArrayList();\n  if (hasSubscription(context)) {\n    final String subscriberId=getActiveSubscriberId(context);\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobileAll(subscriberId))) {\n      limited.add(getText(R.string.data_usage_list_mobile));\n    }\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobile3gLower(subscriberId))) {\n      limited.add(getText(R.string.data_usage_tab_3g));\n    }\n    if (mPolicyEditor.hasLimitedPolicy(buildTemplateMobile4g(subscriberId))) {\n      limited.add(getText(R.string.data_usage_tab_4g));\n    }\n  }\n  if (mPolicyEditor.hasLimitedPolicy(buildTemplateWifiWildcard())) {\n    limited.add(getText(R.string.data_usage_tab_wifi));\n  }\n  if (mPolicyEditor.hasLimitedPolicy(buildTemplateEthernet())) {\n    limited.add(getText(R.string.data_usage_tab_ethernet));\n  }\n  return limited;\n}\n", "docstring": "build list of currently limited networks , which defines when background data is restricted .", "partition": "test"}
{"idx": "1180", "code": "public int evalRPN(String[] tokens){\n  if (tokens == null || tokens.length == 0)   return 0;\n  Stack<String> s=new Stack<String>();\n  int len=tokens.length;\n  for (int i=0; i < len; i++) {\n    String cur=tokens[i];\n    if (isOperator(cur)) {\n      int t2=Integer.parseInt(s.pop());\n      int t1=Integer.parseInt(s.pop());\n      int res=calculate(t1,t2,cur);\n      s.push(Integer.toString(res));\n    }\n else     s.push(cur);\n  }\n  return Integer.valueOf(s.peek());\n}\n", "docstring": "assign a priority for each operators use a stack to store them note the numbers can be negative we evaluate the expression left - to - right and push operands onto the stack until we encounter an operator , which we pop the top two values from the stack . we then evaluate the operator , with the values as arguments and push the result back onto the stack .", "partition": "test"}
{"idx": "1181", "code": "private static void exit(String errMsg,Options options,int exitCode){\n  if (errMsg != null)   echo(\"ERROR: \" + errMsg);\n  String runner=System.getProperty(IGNITE_PROG_NAME,\"randignite.{sh|bat}\");\n  int space=runner.indexOf(\' \');\n  runner=runner.substring(0,space == -1 ? runner.length() : space);\n  if (options != null) {\n    HelpFormatter formatter=new HelpFormatter();\n    formatter.printHelp(runner,options);\n  }\n  System.exit(exitCode);\n}\n", "docstring": "exists with optional error message , usage show and exit code .", "partition": "test"}
{"idx": "1182", "code": "@Override public int compare(NewSplitEmittedTerm term1,NewSplitEmittedTerm term2){\n  return term1.compareTo(term2);\n}\n", "docstring": "compares term key 1 to term key 2 . note that terms are unique only in conjunction with their associated split and flush .", "partition": "test"}
{"idx": "1183", "code": "public AABB merge(AABB other){\n  minX=Math.min(minX,other.minX);\n  maxX=Math.max(maxX,other.maxX);\n  minY=Math.min(minY,other.minY);\n  maxY=Math.max(maxY,other.maxY);\n  minZ=Math.min(minZ,other.minZ);\n  maxZ=Math.max(maxZ,other.maxZ);\n  return this;\n}\n", "docstring": "computes an aabb that contains both this and other and stores it in this .", "partition": "test"}
{"idx": "1184", "code": "public static String generateAutoTag(int stackOffset){\n  StackTraceElement[] currentStack=getCurrentStack();\n  StackTraceElement element=currentStack[stackOffset];\n  String className=element.getClassName();\n  String pkgPath[]=className.split(\"\\\\.\");\n  if (pkgPath.length > 0) {\n    className=pkgPath[pkgPath.length - 1];\n  }\n  StringBuilder sbInnerClass=new StringBuilder();\n  int index;\n  String strLoop=className;\n  while ((index=strLoop.lastIndexOf(\"$\")) != -1) {\n    String piece=strLoop.substring(index + 1);\n    sbInnerClass.insert(0,piece);\n    if (!piece.matches(\"[0-9$]+\")) {\n      break;\n    }\n    sbInnerClass.insert(0,\"$\");\n    strLoop=strLoop.substring(0,index);\n  }\n  if (sbInnerClass.length() > 0 && sbInnerClass.charAt(0) == \'$\') {\n    sbInnerClass.deleteCharAt(0);\n  }\n  String innerClassName=sbInnerClass.toString();\n  if (TextUtils.isDigitsOnly(innerClassName)) {\n    innerClassName=null;\n  }\n  return TextUtils.isEmpty(innerClassName) ? className : innerClassName;\n}\n", "docstring": "generate auto tag for logs .", "partition": "test"}
{"idx": "1185", "code": "private void handleSubscribe(String[] args){\nswitch (args[1]) {\ncase \"rr\":\n    TestSubscriber<Payload> rrsub=new TestSubscriber<>(0L);\n  payloadSubscribers.put(args[2],rrsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rrclient=createClient.get();\nPublisher<Payload> rrpub=rrclient.requestResponse(new PayloadImpl(args[3],args[4]));\nrrpub.subscribe(rrsub);\nbreak;\ncase \"rs\":\nTestSubscriber<Payload> rssub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rssub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsclient=createClient.get();\nPublisher<Payload> rspub=rsclient.requestStream(new PayloadImpl(args[3],args[4]));\nrspub.subscribe(rssub);\nbreak;\ncase \"sub\":\nTestSubscriber<Payload> rsubsub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rsubsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsubclient=createClient.get();\nPublisher<Payload> rsubpub=rsubclient.requestSubscription(new PayloadImpl(args[3],args[4]));\nrsubpub.subscribe(rsubsub);\nbreak;\ncase \"fnf\":\nTestSubscriber<Void> fnfsub=new TestSubscriber<>(0L);\nfnfSubscribers.put(args[2],fnfsub);\nidToType.put(args[2],args[1]);\nReactiveSocket fnfclient=createClient.get();\nPublisher<Void> fnfpub=fnfclient.fireAndForget(new PayloadImpl(args[3],args[4]));\nfnfpub.subscribe(fnfsub);\nbreak;\ndefault :\nbreak;\n}\n}\n", "docstring": "this function takes in the arguments for the subscribe command , and subscribes an instance of testsubscriber with an initial request of 0 ( which means don \"'\" t immediately make a request ) to an instance of the corresponding publisher", "partition": "test"}
{"idx": "1186", "code": "@PostConstruct public void init(){\n  configurationViews.add(defaultDistributionSetTypeLayout);\n  configurationViews.add(authenticationConfigurationView);\n  configurationViews.add(pollingConfigurationView);\n}\n", "docstring": "init method adds all configuration views to the list of views .", "partition": "test"}
{"idx": "1187", "code": "@Override public void start(){\n  for (int i=0; i < threadCount; ++i) {\n    Set<SystemStreamPartition> threadSsps=new HashSet<SystemStreamPartition>();\n    for (    SystemStreamPartition ssp : ssps) {\n      if (Math.abs(ssp.hashCode()) % threadCount == i) {\n        threadSsps.add(ssp);\n      }\n    }\n    Thread thread=new Thread(new MockSystemConsumerRunnable(threadSsps),\"MockSystemConsumer-\" + i);\n    thread.setDaemon(true);\n    threads.add(thread);\n    thread.start();\n  }\n}\n", "docstring": "assign systemstreampartitions to all of the threads , and start them up to begin simulating consuming messages .", "partition": "test"}
{"idx": "1188", "code": "private List<double[]> initializeWeightsND(){\n  int N=50;\n  List<double[]> candidates=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfPoints * N; i++) {\n    double[] weight=new double[numberOfObjectives];\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]=PRNG.nextDouble();\n    }\n    double sum=StatUtils.sum(weight);\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]/=sum;\n    }\n    candidates.add(weight);\n  }\n  List<double[]> weights=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfObjectives; i++) {\n    double[] weight=new double[numberOfObjectives];\n    weight[i]=1.0;\n    weights.add(weight);\n  }\n  while (weights.size() < numberOfPoints) {\n    double[] weight=null;\n    double distance=Double.NEGATIVE_INFINITY;\n    for (int i=0; i < candidates.size(); i++) {\n      double d=Double.POSITIVE_INFINITY;\n      for (int j=0; j < weights.size(); j++) {\n        d=Math.min(d,MathArrays.distance(candidates.get(i),weights.get(j)));\n      }\n      if (d > distance) {\n        weight=candidates.get(i);\n        distance=d;\n      }\n    }\n    weights.add(weight);\n    candidates.remove(weight);\n  }\n  return weights;\n}\n", "docstring": "returns the weights for problems of arbitrary dimension .", "partition": "test"}
{"idx": "1189", "code": "public void removeColumn(Column column){\n  if (column != null) {\n    columns.remove(column);\n  }\n}\n", "docstring": "removes the given column .", "partition": "test"}
{"idx": "1190", "code": "public String info(){\n  StringBuilder sb=new StringBuilder(\"Report: size: \" + tableSize + \", elements: \"+ elements+ \", loadFactor: \"+ loadFactor+ \", threshold: \"+ threshold);\n  sb.append(\", empty bins:\" + numEmpty);\n  int size=0;\n  int min=elements;\n  int max=-1;\n  for (int i=0; i < tableSize; i++) {\n    LinkedList<String> list=bins[i];\n    if (list != null) {\n      int sz=list.size();\n      size+=sz;\n      if (sz < min) {\n        min=sz;\n      }\n      if (sz > max) {\n        max=sz;\n      }\n    }\n  }\n  float avg=size;\n  int base=(tableSize - numEmpty);\n  if (base == 0) {\n    sb.append(\", average:0\");\n    sb.append(\", minListSize:0\");\n    sb.append(\", maxListSize:0\");\n  }\n else {\n    avg/=base;\n    sb.append(\", average:\" + avg);\n    sb.append(\", minListSize:\" + min);\n    sb.append(\", maxListSize:\" + max);\n  }\n  return sb.toString();\n}\n", "docstring": "return single line of output .", "partition": "test"}
{"idx": "1191", "code": "public boolean peekSample(MediaCodec.BufferInfo out_bufferInfo){\n  update();\n  boolean result=false;\n  if (!mAvailableOutputBuffers.isEmpty()) {\n    int index=mAvailableOutputBuffers.peek();\n    MediaCodec.BufferInfo info=mOutputBufferInfo[index];\n    out_bufferInfo.set(info.offset,info.size,info.presentationTimeUs,info.flags);\n    result=true;\n  }\n  return result;\n}\n", "docstring": "performs a peek ( ) operation in the queue to extract media info for the buffer ready to be released i . e . the head element of the queue .", "partition": "test"}
{"idx": "1192", "code": "@Override public AbstractScannedResult scanBlocklet(BlocksChunkHolder blocksChunkHolder) throws QueryExecutionException {\n  try {\n    fillScannedResult(blocksChunkHolder);\n  }\n catch (  FilterUnsupportedException e) {\n    throw new QueryExecutionException(e.getMessage());\n  }\n  return scannedResult;\n}\n", "docstring": "below method will be used to process the block", "partition": "test"}
{"idx": "1193", "code": "@Override public int hashCode(){\n  return subconditions.hashCode() - operator.hashCode();\n}\n", "docstring": "returns the hashcode for the condition", "partition": "test"}
{"idx": "1194", "code": "public void balanceSegments(){\n  MAcctSchemaElement[] elements=m_acctSchema.getAcctSchemaElements();\n  for (int i=0; i < elements.length; i++) {\n    MAcctSchemaElement ase=elements[i];\n    if (ase.isBalanced())     balanceSegment(ase.getElementType());\n  }\n}\n", "docstring": "balance all segments . - for all balancing segments - for all segment values - if balance < > 0 create dueto / duefrom line overwriting the segment value", "partition": "test"}
{"idx": "1195", "code": "public AnnotationDrawer(final AnnotationsModel model,final ProcessRendererModel rendererModel){\n  this.model=model;\n  this.rendererModel=rendererModel;\n  this.displayCache=new HashMap<>();\n  this.cachedID=new HashMap<>();\n  pane=new JEditorPane(\"text/html\",\"\");\n  pane.setBorder(null);\n  pane.setOpaque(false);\n}\n", "docstring": "creates a new drawer for the specified model and decorator .", "partition": "test"}
{"idx": "1196", "code": "public boolean hasUserPartitions(){\n  return !userOutput.isEmpty();\n}\n", "docstring": "retrieves if user partitions are present", "partition": "test"}
{"idx": "1197", "code": "@Override public void insertString(final int offs,final String str,final AttributeSet attr){\n  if (offs < 0) {\n    return;\n  }\n  if (str.length() > 1) {\n    int i;\n    for (i=0; i < str.length(); i++) {\n      if (str.charAt(i) == \'\\n\') {\n        remainingTextString=str.substring(i + 1);\n        remainingTextAttr=attr;\n        inputKeyListener.keyPressed(new KeyEvent(new Container(),KeyEvent.KEY_PRESSED,0,0,KeyEvent.VK_ENTER,\'\\n\'));\n        break;\n      }\n else {\n        insertChar(offs + i,\"\" + str.charAt(i));\n      }\n    }\n  }\n else   if (str.length() == 1) {\n    insertChar(offs,str);\n  }\n}\n", "docstring": "insert a string of source code to be highlighted to the document . the string is then inserted character by character if longer than 1 char .", "partition": "test"}
{"idx": "1198", "code": "public static int putInt(byte[] bytes,int offset,int val){\n  if (littleEndian) {\n    val=Integer.reverseBytes(val);\n  }\n  theUnsafe.putInt(bytes,offset + BYTE_ARRAY_BASE_OFFSET,val);\n  return offset + Bytes.SIZEOF_INT;\n}\n", "docstring": "put an int value out to the specified byte array position in big - endian format .", "partition": "test"}
{"idx": "1199", "code": "public Item(Drawable symbol,String labelText,Font font){\n  double fontSize=font.getSize2D();\n  setLayout(new EdgeLayout(fontSize,0.0));\n  this.symbol=symbol;\n  add(symbol,Location.WEST);\n  label=new Label(labelText);\n  label.setFont(font);\n  label.setAlignmentX(0.0);\n  label.setAlignmentY(0.5);\n  add(label,Location.CENTER);\n}\n", "docstring": "creates a new item object with the specified data source and text .", "partition": "test"}
{"idx": "1200", "code": "void tag(String tag);\n", "docstring": "set a one - time tag for use on the next logging call .", "partition": "test"}
{"idx": "1201", "code": "private Delegate delegate() throws HadoopIgfsCommunicationException {\n  Exception errShmem=null;\n  Exception errTcp=null;\n  Delegate curDelegate=delegateRef.get();\n  if (curDelegate != null)   return curDelegate;\n  boolean skipInProc=parameter(conf,PARAM_IGFS_ENDPOINT_NO_EMBED,authority,false);\n  if (!skipInProc) {\n    IgfsEx igfs=getIgfsEx(endpoint.grid(),endpoint.igfs());\n    if (igfs != null) {\n      HadoopIgfsEx hadoop=null;\n      try {\n        hadoop=new HadoopIgfsInProc(igfs,log,userName);\n        curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n      }\n catch (      IOException|IgniteCheckedException e) {\n        if (e instanceof HadoopIgfsCommunicationException)         if (hadoop != null)         hadoop.close(true);\n        if (log.isDebugEnabled())         log.debug(\"Failed to connect to in-process IGFS, fallback to IPC mode.\",e);\n      }\n    }\n  }\n  boolean skipLocShmem=parameter(conf,PARAM_IGFS_ENDPOINT_NO_LOCAL_SHMEM,authority,false);\n  if (curDelegate == null && !skipLocShmem && !U.isWindows()) {\n    HadoopIgfsEx hadoop=null;\n    try {\n      hadoop=new HadoopIgfsOutProc(endpoint.port(),endpoint.grid(),endpoint.igfs(),log,userName);\n      curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n    }\n catch (    IOException|IgniteCheckedException e) {\n      if (e instanceof HadoopIgfsCommunicationException)       hadoop.close(true);\n      if (log.isDebugEnabled())       log.debug(\"Failed to connect to IGFS using shared memory [port=\" + endpoint.port() + \']\',e);\n      errShmem=e;\n    }\n  }\n  boolean skipLocTcp=parameter(conf,PARAM_IGFS_ENDPOINT_NO_LOCAL_TCP,authority,false);\n  if (curDelegate == null && !skipLocTcp) {\n    HadoopIgfsEx hadoop=null;\n    try {\n      hadoop=new HadoopIgfsOutProc(LOCALHOST,endpoint.port(),endpoint.grid(),endpoint.igfs(),log,userName);\n      curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n    }\n catch (    IOException|IgniteCheckedException e) {\n      if (e instanceof HadoopIgfsCommunicationException)       hadoop.close(true);\n      if (log.isDebugEnabled())       log.debug(\"Failed to connect to IGFS using TCP [host=\" + endpoint.host() + \", port=\"+ endpoint.port()+ \']\',e);\n      errTcp=e;\n    }\n  }\n  if (curDelegate == null && (skipLocTcp || !F.eq(LOCALHOST,endpoint.host()))) {\n    HadoopIgfsEx hadoop=null;\n    try {\n      hadoop=new HadoopIgfsOutProc(endpoint.host(),endpoint.port(),endpoint.grid(),endpoint.igfs(),log,userName);\n      curDelegate=new Delegate(hadoop,hadoop.handshake(logDir));\n    }\n catch (    IOException|IgniteCheckedException e) {\n      if (e instanceof HadoopIgfsCommunicationException)       hadoop.close(true);\n      if (log.isDebugEnabled())       log.debug(\"Failed to connect to IGFS using TCP [host=\" + endpoint.host() + \", port=\"+ endpoint.port()+ \']\',e);\n      errTcp=e;\n    }\n  }\n  if (curDelegate != null) {\n    if (!delegateRef.compareAndSet(null,curDelegate))     curDelegate.doomed=true;\n    return curDelegate;\n  }\n else {\n    SB errMsg=new SB(\"Failed to connect to IGFS [endpoint=igfs://\" + authority + \", attempts=[\");\n    if (errShmem != null)     errMsg.a(\"[type=SHMEM, port=\" + endpoint.port() + \", err=\"+ errShmem+ \"], \");\n    errMsg.a(\"[type=TCP, host=\" + endpoint.host() + \", port=\"+ endpoint.port()+ \", err=\"+ errTcp+ \"]] \");\n    errMsg.a(\"(ensure that IGFS is running and have IPC endpoint enabled; ensure that \" + \"ignite-shmem-1.0.0.jar is in Hadoop classpath if you use shared memory endpoint).\");\n    throw new HadoopIgfsCommunicationException(errMsg.toString());\n  }\n}\n", "docstring": "get delegate creating it if needed .", "partition": "test"}
{"idx": "1202", "code": "public FromClause add(OuterJoinQualifier outerJoinQualifier){\n  outerJoinQualifiers.add(outerJoinQualifier);\n  return this;\n}\n", "docstring": "adds an outer join descriptor that defines how the streams are related via outer joins . < p > for joining n streams , add n - 1 outer join qualifiers .", "partition": "test"}
{"idx": "1203", "code": "private static final File[] encode(String src){\n  if (src == null || src.length() == 0) {\n    return (new File[0]);\n  }\n  StringTokenizer tokenizer=new StringTokenizer(src,\";\");\n  File[] dirs=new File[tokenizer.countTokens()];\n  for (int i=0; i < dirs.length; i++) {\n    dirs[i]=new File(tokenizer.nextToken());\n  }\n  return dirs;\n}\n", "docstring": "splits the string into an array", "partition": "test"}
{"idx": "1204", "code": "public E poll(long timeout,TimeUnit unit) throws InterruptedException {\n  long nanos=unit.toNanos(timeout);\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null) {\n        if (nanos <= 0)         return null;\n else         nanos=available.awaitNanos(nanos);\n      }\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n        if (nanos <= 0)         return null;\n        if (nanos < delay || leader != null)         nanos=available.awaitNanos(nanos);\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            long timeLeft=available.awaitNanos(delay);\n            nanos-=delay - timeLeft;\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}\n", "docstring": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue , or the specified wait time expires .", "partition": "test"}
{"idx": "1205", "code": "public int size(){\n  return patterns.size();\n}\n", "docstring": "size of the cluster .", "partition": "test"}
{"idx": "1206", "code": "private SublimeBaseMenuItem addInternal(int pivotID,Positioned positioned,SublimeBaseMenuItem newItem){\n  int newItemGroupId=newItem.getGroupId();\n  checkExistenceOfGroup(newItemGroupId);\n  int pivotIndex=findItemIndex(pivotID);\n  SublimeBaseMenuItem pivot=mItems.get(pivotIndex);\n  if (newItem.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n    checkIfGroupHeaderAlreadyExistsForGroup(newItemGroupId);\n    int index=findGroupIndex(newItemGroupId);\n    if (index >= 0) {\n      mItems.add(index,newItem);\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivot.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(newItemGroupId)) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n else {\n    if (newItemGroupId != NO_GROUP_ID) {\n      int lastGroupIndex=findLastGroupIndex(newItemGroupId);\n      if (lastGroupIndex == mItems.size()) {\n        if (positioned == Positioned.BEFORE) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n else         if (positioned == Positioned.AFTER) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n      }\n else {\n        if (newItemGroupId == pivot.getGroupId()) {\n          if (positioned == Positioned.BEFORE) {\n            if (pivot.getItemType() != SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n              mItems.add(pivotIndex,newItem);\n            }\n else {\n              mItems.add(lastGroupIndex + 1,newItem);\n            }\n          }\n else           if (positioned == Positioned.AFTER) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n        }\n else {\n          mItems.add(lastGroupIndex + 1,newItem);\n        }\n      }\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || findGroupIndex(pivot.getGroupId()) == pivotIndex) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n  onItemsChanged();\n  return newItem;\n}\n", "docstring": "adds an item to the menu and positions it using the given ` pivot ` .", "partition": "test"}
{"idx": "1207", "code": "public static void writeUint8(OutputStream theOs,int theValue) throws IOException {\n  theOs.write(theValue);\n}\n", "docstring": "writes a \" uint8 \" in wsp format to the given output stream .", "partition": "test"}
{"idx": "1208", "code": "@Override public void addHeader(final String header,final String value){\n  mHeadersOptions.add(new HeaderOption(header,value));\n}\n", "docstring": "adds a header to this request .", "partition": "test"}
{"idx": "1209", "code": "public void store() throws SAMLException {\n  try {\n    keyProvider.store();\n  }\n catch (  KeyStoreException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  CertificateException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new SAMLException(e.getMessage());\n  }\ncatch (  IOException e) {\n    throw new SAMLException(e.getMessage());\n  }\n}\n", "docstring": "store the keystore changes", "partition": "test"}
{"idx": "1210", "code": "static void appendToPointerHierarchy(final BaseType type,final BaseType pointer){\n  Preconditions.checkNotNull(type,\"Error: type argument can not be null.\");\n  Preconditions.checkNotNull(pointer,\"Error: pointer argument can not be null.\");\n  Preconditions.checkArgument(type != pointer,\"Error: Can not establish pointer relation between identical types.\");\n  Preconditions.checkArgument(pointer.pointedToBy != type,\"Error: Can not establish circular pointer relation.\");\n  Preconditions.checkArgument(type.pointsTo != pointer,\"Error: Can not establish circular pointer relation.\");\n  pointer.pointsTo=type;\n  type.pointedToBy=pointer;\n}\n", "docstring": "appends a base type to the pointer hierarchy just below parent , e . g . if type is an int then pointer must be an int * . the \" bottom \" element in this hierarchy is the value type , followed by the pointer types .", "partition": "test"}
{"idx": "1211", "code": "public static void sort(long[] a){\n  doSort(a,0,a.length - 1);\n}\n", "docstring": "sorts the specified array into ascending numerical order .", "partition": "test"}
{"idx": "1212", "code": "public String toString(){\n  return \"Value: \" + String.format(\"%5.2f%%\",ValueSimilarity * 100.0) + \" Containment: \"+ String.format(\"%5.2f%%\",ContainmentSimilarity * 100.0)+ \" Size: \"+ String.format(\"%5.2f%%\",SizeSimilarity * 100.0);\n}\n", "docstring": "return a string representation of this object , describing all aspects of similarity .", "partition": "test"}
{"idx": "1213", "code": "public Optional<T> last(){\n  Iterator<T> iterator=iterator();\n  T value=null;\n  while (iterator.hasNext())   value=iterator.next();\n  return Optional.of(value);\n}\n", "docstring": "convert an iterable stream into one last item of the stream .", "partition": "test"}
{"idx": "1214", "code": "public static void threadSleep(long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  InterruptedException ex) {\n    Log.e(\"Exception\",StringUtils.exceptionStackTraceToString(ex));\n  }\n}\n", "docstring": "makes the thread sleep for some time", "partition": "test"}
{"idx": "1215", "code": "static boolean isPackageAccess(final int modifiers){\n  return (modifiers & ACCESS_TEST) == 0;\n}\n", "docstring": "returns whether a given set of modifiers implies package access .", "partition": "test"}
{"idx": "1216", "code": "ManagedWindowDecorator(Window window,String windowId){\n  this.window=window;\n  name=\"system.\" + windowId;\n}\n", "docstring": "create a managed window decorator with an identity for a window .", "partition": "test"}
{"idx": "1217", "code": "boolean handleRemoteCanRebalance(long size){\n  return false;\n}\n", "docstring": "checks if this partitionedregiondatastore has the capacity to handle the rebalancing size .", "partition": "test"}
{"idx": "1218", "code": "public static File toSLDFile(final File file){\n  final String path=file.getAbsolutePath();\n  final String base=path.substring(0,path.length() - 4);\n  String newPath=base + \".sld\";\n  File sld=new File(newPath);\n  if (sld.exists()) {\n    return sld;\n  }\n  newPath=base + \".SLD\";\n  sld=new File(newPath);\n  if (sld.exists()) {\n    return sld;\n  }\n  return null;\n}\n", "docstring": "figure out if a valid sld file is available .", "partition": "test"}
{"idx": "1219", "code": "private String insertProperties(String template,Map<String,String> properties){\n  for (  Entry<String,String> entry : properties.entrySet()) {\n    template=template.replace(entry.getKey(),entry.getValue());\n  }\n  return template;\n}\n", "docstring": "inserts properties to the template .", "partition": "test"}
{"idx": "1220", "code": "public static void changeFont(JComponent comp,int style){\n  Font font=comp.getFont();\n  comp.setFont(font.deriveFont(style));\n}\n", "docstring": "change the font style of a component", "partition": "test"}
{"idx": "1221", "code": "public void drawContours(Mat img,Color color){\n  Drawing.drawContours(img,contours,color);\n}\n", "docstring": "draw contours matched by the blob detector", "partition": "test"}
{"idx": "1222", "code": "public static void saveX509Cert(String certStr,File certFile) throws IOException {\n  BufferedWriter writer=new BufferedWriter(new FileWriter(certFile));\n  writer.write(BEGIN_CERT);\n  writer.newLine();\n  writer.write(certStr);\n  writer.newLine();\n  writer.write(END_CERT);\n  writer.newLine();\n  writer.close();\n}\n", "docstring": "save a certificate to a file in base 64 binary format with begin and end strings", "partition": "test"}
{"idx": "1223", "code": "public void clearOnCentralPositionChangedListener(){\n  mOnCentralPositionChangedListeners.clear();\n}\n", "docstring": "clear all listeners that listening the central item of the list changes event .", "partition": "test"}
{"idx": "1224", "code": "public static Object invokeStatic(Class clazz,String methodName) throws NoSuchMethodException {\n  try {\n    Method method=clazz.getMethod(methodName,new Class[0]);\n    Object result=method.invoke(null,new Object[0]);\n    return result;\n  }\n catch (  IllegalAccessException e) {\n    throw new NoSuchMethodException(methodName + \" is not accessible\");\n  }\ncatch (  InvocationTargetException e) {\n    throw new InternalError(e.getMessage());\n  }\n}\n", "docstring": "invokes the specified accessible parameterless method if it exists .", "partition": "test"}
{"idx": "1225", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return NOTE_ID;\ncase 2:\n  return CLASS_NAME;\ncase 3:\nreturn INTERPRETER_CONTEXT;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "1226", "code": "public static boolean isStanza(Packet packet){\n  if (packet instanceof Message)   return true;\n  if (packet instanceof IQ)   return true;\n  if (packet instanceof Presence)   return true;\n  return false;\n}\n", "docstring": "returns true if the packet is a stanza as defined in rfc - 6121 - a message , iq or presence packet .", "partition": "test"}
{"idx": "1227", "code": "@Override public int execute(final FormObject form,final int type,final String code,final int eventType,final char keyPressed){\n  int messageCode=ActionHandler.NOMESSAGE;\n  if (code instanceof String) {\n    final String js=code;\n    final String[] args=JSFunction.convertToArray(js);\n    final String command=args[0];\n    if (command.startsWith(\"AF\")) {\n      messageCode=handleAFCommands(form,command,js,args,eventType,keyPressed);\n    }\n  }\n  return messageCode;\n}\n", "docstring": "execute javascript and reset forms values", "partition": "test"}
{"idx": "1228", "code": "private boolean needsUpdate(Long bundleVersion,String beanVersion){\n  if (beanVersion.contains(\"OAD\")) {\n    Log.i(TAG,\"Bundle version: \" + bundleVersion);\n    Log.i(TAG,\"Bean version: \" + beanVersion);\n    return true;\n  }\n else {\n    try {\n      long parsedVersion=Long.parseLong(beanVersion.split(\" \")[0]);\n      Log.i(TAG,\"Bundle version: \" + bundleVersion);\n      Log.i(TAG,\"Bean version: \" + parsedVersion);\n      if (bundleVersion > parsedVersion) {\n        return true;\n      }\n else {\n        Log.i(TAG,\"No update required!\");\n      }\n    }\n catch (    NumberFormatException e) {\n      Log.e(TAG,\"Couldn\'t parse Bean Version: \" + beanVersion);\n      fail(BeanError.UNPARSABLE_FW_VERSION);\n    }\n  }\n  return false;\n}\n", "docstring": "helper function to determine whether a bean needs a fw update given a specific bundle version", "partition": "test"}
{"idx": "1229", "code": "public void clear(FacesContext facesContext,Map<String,Object> viewMap){\n  if (LOGGER.isLoggable(Level.FINEST)) {\n    LOGGER.log(Level.FINEST,\"Clearing @ViewScoped CDI beans for given view map: {0}\");\n  }\n  Map<String,ViewScopeContextObject> contextMap=getContextMap(facesContext,viewMap);\n  if (contextMap != null) {\n    destroyBeans(viewMap,contextMap);\n  }\n}\n", "docstring": "clear the given view map .", "partition": "test"}
{"idx": "1230", "code": "public void loadLogicalTablesWithGranularities(Map<String,TableGroup> nameGroupMap,Set<? extends Granularity> validGrains,ResourceDictionaries dictionaries){\n  for (  Map.Entry<String,TableGroup> entry : nameGroupMap.entrySet()) {\n    String logicalTableName=entry.getKey();\n    TableGroup group=entry.getValue();\n    loadLogicalTableWithGranularities(logicalTableName,group,validGrains,dictionaries);\n  }\n}\n", "docstring": "load several logical tables into the logicaldictionary . < p > note : this builds the logical tables as well .", "partition": "test"}
{"idx": "1231", "code": "public Process(final String xmlString) throws IOException, XMLException {\n  initContext();\n  StringReader in=new StringReader(xmlString);\n  readProcess(in);\n  in.close();\n}\n", "docstring": "reads an process configuration from an xml string .", "partition": "test"}
{"idx": "1232", "code": "public ConsulTopologyFraction(){\n  this.url=DEFAULT_URL;\n}\n", "docstring": "construct a default fraction using the default agent url of http : / / localhost : 8500 / .", "partition": "test"}
{"idx": "1233", "code": "protected String buildQualifierRegex(String qualifierValue){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"^\");\n  sb.append(qualifierValue);\n  sb.append(\"$\");\n  return sb.toString();\n}\n", "docstring": "just used for like and not_like", "partition": "test"}
{"idx": "1234", "code": "public String shortenName(String name,int desiredLength){\n  int originalLength=name.length();\n  if ((desiredLength <= 0) || (originalLength <= desiredLength)) {\n    return name;\n  }\n  int delta=originalLength - desiredLength;\n  int startCut=desiredLength / 2;\n  StringBuffer result=new StringBuffer();\n  result.append(name.substring(0,startCut));\n  if (((startCut == 0) || (name.charAt(startCut - 1) != \'_\')) && ((startCut + delta + 1 == originalLength) || (name.charAt(startCut + delta + 1) != \'_\'))) {\n    result.append(\"_\");\n  }\n  result.append(name.substring(startCut + delta + 1,originalLength));\n  return result.toString();\n}\n", "docstring": "generates a version of the name that has at most the specified length .", "partition": "test"}
{"idx": "1235", "code": "public static Color blend(Color color1,Color color2,double weight){\n  double w2=MathUtils.limit(weight,0.0,1.0);\n  double w1=1.0 - w2;\n  int r=(int)Math.round(w1 * color1.getRed() + w2 * color2.getRed());\n  int g=(int)Math.round(w1 * color1.getGreen() + w2 * color2.getGreen());\n  int b=(int)Math.round(w1 * color1.getBlue() + w2 * color2.getBlue());\n  int a=(int)Math.round(w1 * color1.getAlpha() + w2 * color2.getAlpha());\n  return new Color(r,g,b,a);\n}\n", "docstring": "linearly blends two colors with a defined weight .", "partition": "test"}
{"idx": "1236", "code": "private void decideUILookAndFeel(MainOptions options){\n  try {\n    boolean systemPlaf=false;\n    systemPlaf=options.system_plaf;\n    String systemPlafReq=System.getenv(\"systemplaf\");\n    if (systemPlafReq != null && systemPlafReq.equalsIgnoreCase(\"true\"))     systemPlaf=true;\n    if (systemPlaf)     UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n  }\n catch (  Exception exc) {\n    exc.printStackTrace();\n  }\n}\n", "docstring": "normally the look and feel should be the standard one , java , allow to set the systemplaf to have the system look and feel", "partition": "test"}
{"idx": "1237", "code": "public static BufferedImage toBufferedImage(Image img,int type){\n  if (img instanceof BufferedImage) {\n    return (BufferedImage)img;\n  }\n  BufferedImage bimage=new BufferedImage(img.getWidth(null),img.getHeight(null),type);\n  Graphics2D bGr=bimage.createGraphics();\n  bGr.drawImage(img,0,0,null);\n  bGr.dispose();\n  return bimage;\n}\n", "docstring": "converts a given image into a bufferedimage", "partition": "test"}
{"idx": "1238", "code": "public static byte[] hexStringToByteArray(String strA){\n  ByteArrayOutputStream result=new ByteArrayOutputStream();\n  byte sum=(byte)0x00;\n  boolean nextCharIsUpper=true;\n  for (int i=0; i < strA.length(); i++) {\n    char c=strA.charAt(i);\nswitch (Character.toUpperCase(c)) {\ncase \'0\':\n      if (nextCharIsUpper) {\n        sum=(byte)0x00;\n        nextCharIsUpper=false;\n      }\n else {\n        sum|=(byte)0x00;\n        result.write(sum);\n        nextCharIsUpper=true;\n      }\n    break;\ncase \'1\':\n  if (nextCharIsUpper) {\n    sum=(byte)0x10;\n    nextCharIsUpper=false;\n  }\n else {\n    sum|=(byte)0x01;\n    result.write(sum);\n    nextCharIsUpper=true;\n  }\nbreak;\ncase \'2\':\nif (nextCharIsUpper) {\nsum=(byte)0x20;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x02;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'3\':\nif (nextCharIsUpper) {\nsum=(byte)0x30;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x03;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'4\':\nif (nextCharIsUpper) {\nsum=(byte)0x40;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x04;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'5\':\nif (nextCharIsUpper) {\nsum=(byte)0x50;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x05;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'6\':\nif (nextCharIsUpper) {\nsum=(byte)0x60;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x06;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'7\':\nif (nextCharIsUpper) {\nsum=(byte)0x70;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x07;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'8\':\nif (nextCharIsUpper) {\nsum=(byte)0x80;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x08;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'9\':\nif (nextCharIsUpper) {\nsum=(byte)0x90;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x09;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'A\':\nif (nextCharIsUpper) {\nsum=(byte)0xA0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0A;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'B\':\nif (nextCharIsUpper) {\nsum=(byte)0xB0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0B;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'C\':\nif (nextCharIsUpper) {\nsum=(byte)0xC0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0C;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'D\':\nif (nextCharIsUpper) {\nsum=(byte)0xD0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0D;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'E\':\nif (nextCharIsUpper) {\nsum=(byte)0xE0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0E;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase \'F\':\nif (nextCharIsUpper) {\nsum=(byte)0xF0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0F;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ndefault :\nbreak;\n}\n}\nif (!nextCharIsUpper) {\nthrow new RuntimeException(\"The String did not contain an equal number of hex digits\");\n}\nreturn result.toByteArray();\n}\n", "docstring": "converts readable hex - string to bytearray", "partition": "test"}
{"idx": "1239", "code": "public void removeSensorSelectionListener(SensorSelectionListener listener){\n  listenerList.remove(SensorSelectionListener.class,listener);\n}\n", "docstring": "remove the specified sensor selection listener .", "partition": "test"}
{"idx": "1240", "code": "public void write(int c) throws IOException {\n  if (_output == null)   throw new IOException(\"Writer closed\");\n  _output.append((char)c);\n}\n", "docstring": "writes the 16 low - order bits of the given integer value ; the 16 high - order bits are ignored .", "partition": "test"}
{"idx": "1241", "code": "public void register(GridCacheTtlManager mgr){\nsynchronized (mux) {\n    if (cleanupWorker == null)     startCleanupWorker();\n    mgrs.add(mgr);\n  }\n}\n", "docstring": "register ttl manager of cache for periodical check on expired entries .", "partition": "test"}
{"idx": "1242", "code": "public void initializeKeyStore(){\n  try {\n    Logger logger=(com.sun.identity.log.Logger)Logger.getLogger(logName);\n    resetCurrentFileList(logName);\n    addToCurrentFileList(logName,logName,logName);\n    String logPath=lmanager.getProperty(LogConstants.LOG_LOCATION);\n    if (!logPath.endsWith(\"/\"))     logPath+=\"/\";\n    String fileName=logName;\n    String loggerFileName=logPath + PREFIX + \"log.\"+ fileName;\n    String verifierFileName=logPath + PREFIX + \"ver.\"+ fileName;\n    Debug.message(logName + \":Logger Keystore name = \" + loggerFileName);\n    Debug.message(logName + \":Verifier Keystore name= \" + verifierFileName);\n    helper.initializeSecureLogHelper(loggerFileName,logPassword,verifierFileName,logPassword);\n    Debug.message(logName + \":Initialized SecureLogHelper\");\n    helper.initializeVerifier(verifierFileName,logPassword,verPassword);\n    Debug.message(logName + \":Done init of SecureLogHelper and Verifier\");\n  }\n catch (  Exception e) {\n    Debug.error(logName + \":Logger: exception thrown while initializing secure logger\",e);\n  }\n}\n", "docstring": "initialize logger key store", "partition": "test"}
{"idx": "1243", "code": "private native byte[] imageDataToPlatformImageBytes(byte[] imageData,int width,int height,long format);\n", "docstring": "returns a byte array which contains data special for the given format and for the given image data .", "partition": "test"}
{"idx": "1244", "code": "public static String cleanFolderStackingMarkers(String filename){\n  if (!StringUtils.isEmpty(filename)) {\n    Matcher m=folderStackingPattern.matcher(filename);\n    if (m.matches()) {\n      return m.group(1) + m.group(3);\n    }\n  }\n  return filename;\n}\n", "docstring": "clean stacking markers . < br > same logic as detection , but just returning string w / o", "partition": "test"}
{"idx": "1245", "code": "public void discard(ServiceRegistrar reg){\nsynchronized (registrars) {\n    if (terminated) {\n      throw new IllegalStateException(\"discovery terminated\");\n    }\n    if (reg == null)     return;\n    sendDiscarded(reg,null);\n  }\n}\n", "docstring": "discard a registrar from the set of registrars already discovered . this does not prevent that registrar from being rediscovered ; it is intended to be used to clear unreachable entries from the set . < p > if the registrar has been discovered using this lookupdiscovery object , each listener registered with this object will have its discarded method called with the given registrar as parameter .", "partition": "test"}
{"idx": "1246", "code": "public boolean isFinalState(int state){\n  return (state < 0) ? false : fFinalStateFlags[state];\n}\n", "docstring": "check whether the given state is one of the final states", "partition": "test"}
{"idx": "1247", "code": "public static String generateScaleMarkers(int proteinLength,int maxNumScaleMarkers){\n  if (maxNumScaleMarkers < 2) {\n    maxNumScaleMarkers=2;\n  }\n  int scale=calcScale(proteinLength,maxNumScaleMarkers);\n  StringBuilder sb=new StringBuilder(\"0\");\n  int index=0;\n  int numRemaining=proteinLength;\n  while (index <= proteinLength) {\n    index+=scale;\n    numRemaining-=scale;\n    sb.append(\",\");\n    if ((numRemaining > 0) && (numRemaining < scale)) {\n      if (numRemaining < (scale / 2)) {\n        sb.append(proteinLength);\n        break;\n      }\n    }\n    if (index >= proteinLength) {\n      sb.append(proteinLength);\n    }\n else {\n      sb.append(index);\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "generate a string of comma - separated numbers that will be used to mark the scale of the match diagram .", "partition": "test"}
{"idx": "1248", "code": "public void writeFigTreeBlock(Map<String,Object> settings) throws IOException {\n  writer.println(\"\\nbegin figtree;\");\n  for (  String key : settings.keySet()) {\n    Object value=settings.get(key);\n    writer.println(\"\\tset \" + key + \"=\"+ createString(value)+ \";\");\n  }\n  writer.println(\"end;\\n\");\n}\n", "docstring": "writes a \"'\" figtree \"'\" block .", "partition": "test"}
{"idx": "1249", "code": "public int hashCode(){\n  return font.hashCode() ^ glyphs.length;\n}\n", "docstring": "as a concrete subclass of object that implements equality , this must implement hashcode .", "partition": "test"}
{"idx": "1250", "code": "@Override public void doctypeDecl(String rootElement,String publicId,String systemId,Augmentations augs) throws XNIException {\n  fInDTD=true;\n  try {\n    if (fLexicalHandler != null) {\n      fLexicalHandler.startDTD(rootElement,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n  if (fDeclHandler != null) {\n    fDeclaredAttrs=new SymbolHash();\n  }\n}\n", "docstring": "notifies of the presence of the doctype line in the document .", "partition": "test"}
{"idx": "1251", "code": "public void cleanStart(){\n  Connection conn=getConnection(true,true);\n  if (conn == null)   throw new IllegalStateException(\"No Database\");\n  dropDatabase(conn);\n  createUser(conn);\n  createDatabase(conn);\n  try {\n    if (conn != null)     conn.close();\n  }\n catch (  SQLException e2) {\n    log.log(Level.SEVERE,\"close connection\",e2);\n  }\n  conn=null;\n}\n", "docstring": "clean start - drop & re - create db", "partition": "test"}
{"idx": "1252", "code": "static TemplateModelException newMethodArgInvalidValueException(String methodName,int argIdx,Object... details){\n  return new _TemplateModelException(methodName,\"(...) argument #\",Integer.valueOf(argIdx + 1),\" had invalid value: \",details);\n}\n", "docstring": "the type of the argument was good , but it \"'\" s value wasn \"'\" t .", "partition": "test"}
{"idx": "1253", "code": "private void loadMap(String extension,String mimeType){\n  if (!mimeTypeToExtensionMap.containsKey(mimeType)) {\n    mimeTypeToExtensionMap.put(mimeType,extension);\n  }\n  extensionToMimeTypeMap.put(extension,mimeType);\n  if (isImageType(mimeType)) {\n    imageMimeTypeSet.add(mimeType);\n  }\n}\n", "docstring": "load an entry into the map .", "partition": "test"}
{"idx": "1254", "code": "private String convertTimestamp(){\n  String result=timestampFormat.replaceAll(VALID_DATEFORMAT_CHAR_PATTERN + \"+\",\"\\\\\\\\S+\");\n  result=result.replaceAll(Pattern.quote(\".\"),\"\\\\\\\\.\");\n  return result;\n}\n", "docstring": "helper method that will convert timestamp format to a pattern", "partition": "test"}
{"idx": "1255", "code": "public static String encode(byte[] bytes){\n  int len=bytes.length;\n  final StringBuffer encoded=new StringBuffer((len + 2) / 3 * 4);\n  int i=0;\n  int j=len;\n  while (j >= 3) {\n    encoded.append(to64((((bytes[i] & 0xff) << 16) | (int)((bytes[i + 1] & 0xff) << 8) | (int)(bytes[i + 2] & 0xff)),4));\n    i+=3;\n    j-=3;\n  }\n  if (j == 2) {\n    encoded.append(to64(((bytes[i] & 0xff) << 8) | ((bytes[i + 1] & 0xff)),3));\n  }\n  if (j == 1) {\n    encoded.append(to64(((bytes[i] & 0xff)),2));\n  }\n  return encoded.toString();\n}\n", "docstring": "encodes an array of byte into a string of printable ascii characters using a base - 64 encoding .", "partition": "test"}
{"idx": "1256", "code": "final public void print(double v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    String s=String.valueOf(v);\n    out.write(s,0,s.length());\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a double followed by a newline .", "partition": "test"}
{"idx": "1257", "code": "public String toString(){\n  StringBuffer result=new StringBuffer(ipAddress.toString());\n  result.append(\"/\");\n  result.append(extendedNetworkPrefix);\n  return result.toString();\n}\n", "docstring": "convert the ip range into a string representation .", "partition": "test"}
{"idx": "1258", "code": "private static boolean containsChroot(String zkHost){\n  return zkHost.contains(\"/\");\n}\n", "docstring": "validates if zkhost contains a chroot . see http : / / zookeeper . apache . org / doc / r3 . 2 . 2 / zookeeperprogrammers . html # ch_zksessions", "partition": "test"}
{"idx": "1259", "code": "public static void onDatabase(MongoClient client,String dbName,Consumer<MongoDatabase> dbOperation){\n  if (contains(client.listDatabaseNames(),dbName)) {\n    dbOperation.accept(client.getDatabase(dbName));\n  }\n}\n", "docstring": "perform the given operation on the database with the given name , only if that database exists .", "partition": "test"}
{"idx": "1260", "code": "protected int createHashCode(){\n  int result=uri.hashCode() ^ prefix.hashCode();\n  if (result == 0) {\n    result=0xbabe;\n  }\n  return result;\n}\n", "docstring": "factory method to create the hashcode allowing derived classes to change the behaviour", "partition": "test"}
{"idx": "1261", "code": "public String importTrl(String directory,int AD_Client_ID,String AD_Language,String Trl_Table){\n  String fileName=directory + File.separator + Trl_Table+ \"_\"+ AD_Language+ \".xml\";\n  log.info(fileName);\n  File in=new File(fileName);\n  if (!in.exists()) {\n    String msg=\"File does not exist: \" + fileName;\n    log.log(Level.SEVERE,msg);\n    return msg;\n  }\n  try {\n    TranslationHandler handler=new TranslationHandler(AD_Client_ID);\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(in,handler);\n    log.info(\"Updated=\" + handler.getUpdateCount());\n    return Msg.getMsg(m_ctx,\"Updated\") + \"=\" + handler.getUpdateCount();\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,\"importTrl\",e);\n    return e.toString();\n  }\n}\n", "docstring": "import translation . uses translationhandler to update translation", "partition": "test"}
{"idx": "1262", "code": "@Override public void onFailure(IMqttToken asyncActionToken,Throwable exception){\n  exception.printStackTrace();\n  Log.e(\"TrafficService\",\"Error connecting: \" + exception.getMessage());\n  onDisconnect(false);\n}\n", "docstring": "called when there was an error connecting", "partition": "test"}
{"idx": "1263", "code": "@Override public boolean exclude(String identifier){\n  return blacklist.contains(identifier);\n}\n", "docstring": "checks if the given identifier should be excluded .", "partition": "test"}
{"idx": "1264", "code": "static private String SHORT_Max_Plus(){\n  long tempValue=Short.MAX_VALUE + 1;\n  return String.valueOf(tempValue);\n}\n", "docstring": "get the max value plus one for a short", "partition": "test"}
{"idx": "1265", "code": "public static String encode(String value){\n  value=value.replace(\"&\",\"&amp;\");\n  value=value.replace(\"<\",\"&lt;\");\n  value=value.replace(\">\",\"&gt;\");\n  value=value.replace(\"\\\"\",\"&quot;\");\n  value=value.replace(\"\'\",\"&#x27;\");\n  value=value.replace(\"/\",\"&#x2F;\");\n  return value;\n}\n", "docstring": "html encodes value to avoid xss attacks . & = & amp ; < = & lt ; > = & gt ; \" = & quot ; \"'\" = & # x27 ; / = & # x2f ;", "partition": "test"}
{"idx": "1266", "code": "public void createDatabaseEntitiesForStoragePolicyTesting(){\n  createDatabaseEntitiesForStoragePolicyTesting(AbstractServiceTest.STORAGE_POLICY_NAMESPACE_CD,Arrays.asList(AbstractServiceTest.STORAGE_POLICY_RULE_TYPE),AbstractServiceTest.BDEF_NAMESPACE,AbstractServiceTest.BDEF_NAME,Arrays.asList(AbstractServiceTest.FORMAT_FILE_TYPE_CODE),Arrays.asList(AbstractServiceTest.STORAGE_NAME),Arrays.asList(AbstractServiceTest.STORAGE_NAME_2));\n}\n", "docstring": "create and persist database entities required for storage policy service testing .", "partition": "test"}
{"idx": "1267", "code": "private PDFPage createPage(int pagenum,PDFObject pageObj) throws IOException {\n  int rotation=0;\n  RectF mediabox=null;\n  RectF cropbox=null;\n  PDFObject mediaboxObj=getInheritedValue(pageObj,\"MediaBox\");\n  if (mediaboxObj != null) {\n    mediabox=parseRect(mediaboxObj);\n  }\n  PDFObject cropboxObj=getInheritedValue(pageObj,\"CropBox\");\n  if (cropboxObj != null) {\n    cropbox=parseRect(cropboxObj);\n  }\n  PDFObject rotateObj=getInheritedValue(pageObj,\"Rotate\");\n  if (rotateObj != null) {\n    rotation=rotateObj.getIntValue();\n  }\n  RectF bbox=((cropbox == null) ? mediabox : cropbox);\n  return new PDFPage(pagenum,bbox,rotation,cache);\n}\n", "docstring": "create a pdf page object by finding the relevant inherited properties", "partition": "test"}
{"idx": "1268", "code": "static Map addElementToMap(String key,Set values,Map toMap){\n  if ((key != null) && (toMap != null)) {\n    toMap.put(key,values);\n  }\n  return toMap;\n}\n", "docstring": "adds a key / value pair to a map", "partition": "test"}
{"idx": "1269", "code": "public void saveBootProp() throws IOException {\n  if (!bootProp.equals(bootPropOrg)) {\n    final String propFile=jarFolder + \"jar.properties\";\n    final OutputStream os=new FileOutputStream(propFile);\n    try {\n      bootProp.store(os,\"Stendhal Boot Configuration\");\n    }\n  finally {\n      os.close();\n    }\n  }\n}\n", "docstring": "saves modified boot properties to disk .", "partition": "test"}
{"idx": "1270", "code": "private int append(FileSystem fs,Configuration conf,Path src,PrintWriter writer,int currentRecordNumber) throws IOException {\n  BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(src)));\n  try {\n    String line=reader.readLine();\n    while (line != null) {\n      if (line.startsWith(\"Recno:: \")) {\n        line=\"Recno:: \" + currentRecordNumber++;\n      }\n      writer.println(line);\n      line=reader.readLine();\n    }\n    return currentRecordNumber;\n  }\n  finally {\n    reader.close();\n  }\n}\n", "docstring": "appends two files and updates the recno counter", "partition": "test"}
{"idx": "1271", "code": "public PacketOutputStream writeTimestampLength(final Calendar calendar,Timestamp ts,boolean fractionalSeconds){\n  assureBufferCapacity(fractionalSeconds ? 12 : 8);\n  buffer.put((byte)(fractionalSeconds ? 11 : 7));\n  buffer.putShort((short)calendar.get(Calendar.YEAR));\n  buffer.put((byte)((calendar.get(Calendar.MONTH) + 1) & 0xff));\n  buffer.put((byte)(calendar.get(Calendar.DAY_OF_MONTH) & 0xff));\n  buffer.put((byte)calendar.get(Calendar.HOUR_OF_DAY));\n  buffer.put((byte)calendar.get(Calendar.MINUTE));\n  buffer.put((byte)calendar.get(Calendar.SECOND));\n  if (fractionalSeconds) {\n    buffer.putInt(ts.getNanos() / 1000);\n  }\n  return this;\n}\n", "docstring": "write timestamp in binary format .", "partition": "test"}
{"idx": "1272", "code": "public static String morpha(String text,boolean tags){\n  if (text.isEmpty()) {\n    return \"\";\n  }\n  String[] textParts=whitespace.split(text);\n  StringBuilder result=new StringBuilder();\n  try {\n    for (    String textPart : textParts) {\n      Morpha morpha=new Morpha(new StringReader(textPart),tags);\n      if (result.length() != 0) {\n        result.append(\" \");\n      }\n      result.append(morpha.next());\n    }\n  }\n catch (  Error e) {\n    return text;\n  }\ncatch (  java.io.IOException e) {\n    return text;\n  }\n  return result.toString();\n}\n", "docstring": "run the morpha algorithm on the specified string .", "partition": "test"}
{"idx": "1273", "code": "public static void deleteFile(File file) throws AdeUsageException {\n  if (!file.delete()) {\n    throw new AdeUsageException(FAILED_DELETING_FILE + file.getPath());\n  }\n}\n", "docstring": "delete a file from file system .", "partition": "test"}
{"idx": "1274", "code": "public Shape createCheckMark(final int x,final int y,final int w,final int h){\n  double xf=w / 12.0;\n  double hf=h / 12.0;\n  path.reset();\n  path.moveTo(x,y + 7.0 * hf);\n  path.lineTo(x + 2.0 * xf,y + 7.0 * hf);\n  path.lineTo(x + 4.75 * xf,y + 10.0 * hf);\n  path.lineTo(x + 9.0 * xf,y);\n  path.lineTo(x + 11.0 * xf,y);\n  path.lineTo(x + 5.0 * xf,y + 12.0 * hf);\n  path.closePath();\n  return path;\n}\n", "docstring": "return a path for a check mark .", "partition": "test"}
{"idx": "1275", "code": "public TCPChannelClient(ExecutorService executor,TCPChannelEvents eventListener,String ip,int port){\n  this.executor=executor;\n  executorThreadCheck=new ThreadUtils.ThreadChecker();\n  executorThreadCheck.detachThread();\n  this.eventListener=eventListener;\n  InetAddress address;\n  try {\n    address=InetAddress.getByName(ip);\n  }\n catch (  UnknownHostException e) {\n    reportError(\"Invalid IP address.\");\n    return;\n  }\n  if (address.isAnyLocalAddress()) {\n    socket=new TCPSocketServer(address,port);\n  }\n else {\n    socket=new TCPSocketClient(address,port);\n  }\n  socket.start();\n}\n", "docstring": "initializes the tcpchannelclient . if ip is a local ip address , starts a listening server on that ip . if not , instead connects to the ip .", "partition": "test"}
{"idx": "1276", "code": "protected void cutSelectedBean(){\n  if (Debug.debugging(\"beanbox\"))   Debug.output(\"Enter> cutSelectedBean\");\n  if (selectedBean == null || selectedBeanLocation == null) {\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"selectedBean=\" + selectedBean);\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"selectedBeanLocation=\" + selectedBeanLocation);\n    clearSelection();\n    return;\n  }\n  try {\n    serBean=new ByteArrayOutputStream();\n    ObjectOutputStream oos=new ObjectOutputStream(serBean);\n    oos.writeObject(selectedBean);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    clearSelection();\n    if (Debug.debugging(\"beanbox\"))     Debug.output(\"Exit> copySelectedBean\");\n    return;\n  }\n  cutBean=selectedBean;\n  selectedBeanBox.showCut(selectedBean);\n  if (Debug.debugging(\"beanbox\"))   Debug.output(\"Exit> cutSelectedBean\");\n}\n", "docstring": "this method is called when the user chooses to cut a bean by some means such by by pressing ctrl - x . this method tries to serialize the selected bean . if no bean is selected or the bean is not serializable , this method is a no - op .", "partition": "test"}
{"idx": "1277", "code": "public void actionPerformed(java.awt.event.ActionEvent e){\n  Object source=e.getSource();\n  if (!(source instanceof JMenuItem))   return;\n  JMenuItem mi=(JMenuItem)source;\n  String name=mi.getText();\n  OMGraphicHandlerLayer targetLayer=(OMGraphicHandlerLayer)layers.get(name);\n  if (targetLayer == null) {\n    Debug.message(\"defaultdndcatcher\",\"ERROR> DefaultDnDCatcher::actionPerformed: \" + \"no layer found with name \" + name);\n    return;\n  }\n  targetLayer.doAction((OMGraphic)transferData,new OMAction(OMAction.UPDATE_GRAPHIC_MASK));\n}\n", "docstring": "invoked when an action from the popup menu occurs .", "partition": "test"}
{"idx": "1278", "code": "private void addEntry(){\n  model.addNewEntry();\n  removeButton.setEnabled(false);\n}\n", "docstring": "adds a new colour map entry .", "partition": "test"}
{"idx": "1279", "code": "private void ensureSize(){\n  if (children == EMPTY_CHILDREN) {\n    children=new FPNode[1];\n    return;\n  }\n  int newsize=children.length == 1 ? INITIAL_SIZE : (children.length << 1);\n  children=Arrays.copyOf(children,newsize);\n}\n", "docstring": "ensure we have enough storage .", "partition": "test"}
{"idx": "1280", "code": "public UUID(long mostSigBits,long leastSigBits){\n  this.mostSigBits=mostSigBits;\n  this.leastSigBits=leastSigBits;\n  init();\n}\n", "docstring": "< p > constructs an instance with the specified bits .", "partition": "test"}
{"idx": "1281", "code": "private static void renderHandler(FacesContext context,UIComponent component,Collection<ClientBehaviorContext.Parameter> params,String handlerName,Object handlerValue,String behaviorEventName,String submitTarget,boolean needsSubmit,boolean includeExec) throws IOException {\n  ResponseWriter writer=context.getResponseWriter();\n  String userHandler=getNonEmptyUserHandler(handlerValue);\n  List<ClientBehavior> behaviors=getClientBehaviors(component,behaviorEventName);\n  if ((null != behaviors) && (behaviors.size() > 0) && Util.componentIsDisabled(component)) {\n    behaviors=null;\n  }\n  if (params == null) {\n    params=Collections.emptyList();\n  }\n  String handler=null;\nswitch (getHandlerType(behaviors,params,userHandler,needsSubmit,includeExec)) {\ncase USER_HANDLER_ONLY:\n    handler=userHandler;\n  break;\ncase SINGLE_BEHAVIOR_ONLY:\nhandler=getSingleBehaviorHandler(context,component,behaviors.get(0),params,behaviorEventName,submitTarget,needsSubmit);\nbreak;\ncase SUBMIT_ONLY:\nhandler=getSubmitHandler(context,component,params,submitTarget,true);\nbreak;\ncase CHAIN:\nhandler=getChainedHandler(context,component,behaviors,params,behaviorEventName,userHandler,submitTarget,needsSubmit);\nbreak;\ndefault :\nassert (false);\n}\nwriter.writeAttribute(handlerName,handler,null);\n}\n", "docstring": "renders a handler script , which may require chaining together the user - specified event handler , any scripts required by attached behaviors , and also possibly the mojarra . jsfcljs ( ) \" submit \" script .", "partition": "test"}
{"idx": "1282", "code": "public String constructTSDBMetricName(){\n  StringBuilder sb=new StringBuilder(getScope());\n  if (_namespace != null && !_namespace.isEmpty()) {\n    sb.append(getNamespace());\n  }\n  return sb.toString();\n}\n", "docstring": "constructs a native tsdb metric name for this metric .", "partition": "test"}
{"idx": "1283", "code": "protected synchronized void received(int responseCode,String stream,String json){\n  FollowerInfo result=parseFollowers(stream,json);\n  if (result != null) {\n    noError(stream);\n    cached.put(stream,result);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(result);\n      if (hasNewFollowers(result.followers)) {\n        listener.newFollowers(result);\n      }\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(result);\n    }\n    requested.add(stream);\n  }\n else {\n    String errorMessage=\"\";\n    if (responseCode == 404) {\n      errorMessage=\"Channel not found.\";\n      error(stream,10);\n    }\n else     if (responseCode == 200) {\n      errorMessage=\"Parse error.\";\n      error(stream,1);\n    }\n else     if (responseCode == 401 || responseCode == 403) {\n      errorMessage=\"Access denied.\";\n      error(stream,1);\n    }\n else     if (responseCode == 422) {\n      errorMessage=\"No data for this channel.\";\n      error(stream,10);\n    }\n else {\n      errorMessage=\"Request error.\";\n      error(stream,1);\n    }\n    FollowerInfo errorResult=new FollowerInfo(type,stream,errorMessage);\n    cached.put(stream,errorResult);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(errorResult);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(errorResult);\n    }\n  }\n}\n", "docstring": "received data from the api , so parse it or handle a possible error , then give it to the listener .", "partition": "test"}
{"idx": "1284", "code": "public static <T>List<T> select(Connection connection,String rawSqlQuery,RowProcessor<T> rowProcessor,Object... parameters) throws IOException, SQLException {\n  PreparedStatement stmt=null;\n  ResultSet rs=null;\n  try {\n    stmt=connection.prepareStatement(rawSqlQuery);\n    for (int index=0; index < parameters.length; index++) {\n      JdbcUtils.bindParameter(stmt,index + 1,parameters[index]);\n    }\n    rs=stmt.executeQuery();\n    List<T> result=Lists.newLinkedList();\n    while (rs.next()) {\n      result.add(rowProcessor.process(rs));\n    }\n    return result;\n  }\n  finally {\n    JdbcUtils.closeResultSet(rs);\n    JdbcUtils.closeStatement(stmt);\n  }\n}\n", "docstring": "retrieve all the rows satisfying the given sql query .", "partition": "test"}
{"idx": "1285", "code": "public Future<SyncReply> sendRequest(int xid,SyncMessage request) throws RemoteStoreException {\n  ensureConnected();\n  RemoteSyncFuture future=new RemoteSyncFuture(xid,connectionGeneration);\n  futureMap.put(Integer.valueOf(xid),future);\n  if (futureMap.size() > MAX_PENDING_REQUESTS) {\nsynchronized (futureNotify) {\n      while (futureMap.size() > MAX_PENDING_REQUESTS) {\n        try {\n          futureNotify.wait();\n        }\n catch (        InterruptedException e) {\n          throw new RemoteStoreException(\"Could not send request\",e);\n        }\n      }\n    }\n  }\n  channel.writeAndFlush(request);\n  return future;\n}\n", "docstring": "send a request to the server and generate a future for the eventual reply . note that this call can block if there is no active connection while a new connection is re - established or if the maximum number of requests is already pending", "partition": "test"}
{"idx": "1286", "code": "public static boolean isEmpty(String str){\n  return (null == str || 0 == str.length());\n}\n", "docstring": "is null or its length is 0", "partition": "test"}
{"idx": "1287", "code": "public void enableDependency(Capability c){\n  if (doNotCheckCapabilities()) {\n    return;\n  }\n  if (c == Capability.NOMINAL_ATTRIBUTES) {\n    enableDependency(Capability.BINARY_ATTRIBUTES);\n  }\n else   if (c == Capability.BINARY_ATTRIBUTES) {\n    enableDependency(Capability.UNARY_ATTRIBUTES);\n  }\n else   if (c == Capability.UNARY_ATTRIBUTES) {\n    enableDependency(Capability.EMPTY_NOMINAL_ATTRIBUTES);\n  }\n else   if (c == Capability.NOMINAL_CLASS) {\n    enableDependency(Capability.BINARY_CLASS);\n  }\n  m_Dependencies.add(c);\n}\n", "docstring": "enables the dependency flag for the given capability enabling nominal_attributes also enables binary_attributes , unary_attributes and empty_nominal_attributes . enabling binary_attributes also enables unary_attributes and empty_nominal_attributes . enabling unary_attributes also enables empty_nominal_attributes . but nominal_class only enables binary_class , since normal schemes in weka don \"'\" t work with datasets that have only 1 class label ( or none ) .", "partition": "test"}
{"idx": "1288", "code": "public IVariable[] extractRobotDebugVariables(final int stackTraceId,final Map<String,Object> newVariables){\n  final RobotDebugVariablesContext currentVariablesContext=findCurrentVariablesContext(stackTraceId);\n  Map<String,IVariable> previousVariablesMap=initPreviousVariablesState(currentVariablesContext);\n  final Map<String,IVariable> nonGlobalVariablesMap=new LinkedHashMap<>();\n  if (previousVariablesMap == null) {\n    initNewNonGlobalVariables(newVariables,nonGlobalVariablesMap);\n  }\n else {\n    initVariablesComparingWithPreviousState(newVariables,previousVariablesMap,nonGlobalVariablesMap);\n  }\n  final LinkedList<IVariable> currentVariablesList=createCurrentVariablesList(nonGlobalVariablesMap);\n  saveCurrentVariablesState(stackTraceId,currentVariablesContext,nonGlobalVariablesMap);\n  return currentVariablesList.toArray(new IVariable[currentVariablesList.size()]);\n}\n", "docstring": "extract and sort variables for given stacktrace level . every level of stacktrace has its own context in previousvariables map . current variables are compared with previous state . if current level of stacktrace has not any previous state , then previous state will be variables from level below . this is for saving previous order of variables in higher levels .", "partition": "test"}
{"idx": "1289", "code": "public ResourcesPoet addInteger(String name,String value){\n  Element bool=document.createElement(\"integer\");\n  bool.setAttribute(\"name\",name);\n  bool.appendChild(document.createTextNode(String.valueOf(value)));\n  resourceElement.appendChild(bool);\n  return this;\n}\n", "docstring": "add an integer to the config", "partition": "test"}
{"idx": "1290", "code": "public int availableInProcess(){\n  return Math.max(0,maxInProcess - pending.size());\n}\n", "docstring": "a connection can only have so many things in process happening on it at once , where \" in process \" refers to the maximum number of in - process requests less the number of pending responses .", "partition": "test"}
{"idx": "1291", "code": "public boolean shouldExecuteAction(){\n  if (delay <= 0) {\n    return true;\n  }\n  long timePassed=System.currentTimeMillis() - lastActionExecuted;\n  if (timePassed > delay * 100) {\n    lastActionExecuted=System.currentTimeMillis();\n    return true;\n  }\n  return false;\n}\n", "docstring": "checks whether an action should currently be executed , based on the required delay . also assumes that an action was executed if this returns true and sets the time of the last action to the current time .", "partition": "test"}
{"idx": "1292", "code": "protected void handleOrDeferMessage(DistributionMessage msg){\nsynchronized (startupLock) {\n    if (beingSick || playingDead) {\n      if (msg.containsRegionContentChange() || msg instanceof PartitionMessageWithDirectReply) {\n        startupMessages.add(new StartupEvent(msg));\n        return;\n      }\n    }\n    if (!processingEvents) {\n      startupMessages.add(new StartupEvent(msg));\n      return;\n    }\n  }\n  dispatchMessage(msg);\n}\n", "docstring": "dispatch the distribution message , or place it on the startup queue .", "partition": "test"}
{"idx": "1293", "code": "public boolean zoneExportRemoveVolumes(List<NetworkZoningParam> zoningParams,Collection<URI> volumeURIs,String stepId){\n  NetworkZoningParam zoningParam=zoningParams.get(0);\n  _log.info(String.format(\"Entering zoneExportRemoveVolumes for ExportGroup: %s Volumes: %s\",zoningParam.getExportGroupDisplay(),volumeURIs.toString()));\n  return doZoneExportMasksDelete(zoningParams,volumeURIs,stepId);\n}\n", "docstring": "removes the indicated volumes from the zones given by the zoning parameters . if the fczonereferences for a zone are all removed ( and there are no existing volumes in the associated export mask ) , the zones will be removed from switch .", "partition": "test"}
{"idx": "1294", "code": "private void shutdown(){\n  if (nbestListWriter != null) {\n    logger.info(\"Closing n-best writer\");\n    nbestListWriter.close();\n  }\n  if (alignmentWriter != null) {\n    logger.info(\"Closing alignment writer\");\n    alignmentWriter.close();\n  }\n}\n", "docstring": "free resources and cleanup .", "partition": "test"}
{"idx": "1295", "code": "@Override public void paintIcon(Component c,Graphics g,int x,int y){\n  Painter painter=(Painter)UIManager.get(prefix + \"[Enabled].\" + key);\n  if (painter != null) {\n    JComponent jc=(c instanceof JComponent) ? (JComponent)c : null;\n    Graphics2D gfx=(Graphics2D)g;\n    gfx.translate(x,y);\n    painter.paint(gfx,jc,width,height);\n    gfx.translate(-x,-y);\n  }\n}\n", "docstring": "implements the standard icon interface \"'\" s painticon method as the standard synth stub passes null for the context and this will cause us to not paint any thing , so we override here so that we can paint the enabled state if no synth context is available", "partition": "test"}
{"idx": "1296", "code": "public List<Map<String,String>> list(Database conn) throws SQLException {\n  ResultSet rs=null;\n  Statement statement=conn.createStatement();\n  List<Map<String,String>> shardToChannels=new ArrayList<Map<String,String>>();\n  try {\n    rs=statement.executeQuery(select);\n    while (rs.next()) {\n      Map<String,String> shard=new HashMap<String,String>();\n      shard.put(ShardChannelTable.SHARD_ID_COL,rs.getString(ShardChannelTable.SHARD_ID_COL));\n      shard.put(ShardChannelTable.CHANNEL_COL,rs.getString(ShardChannelTable.CHANNEL_COL));\n      shardToChannels.add(shard);\n    }\n  }\n  finally {\n    close(rs);\n    close(statement);\n  }\n  return shardToChannels;\n}\n", "docstring": "return a list of currently known shard / channel assignments .", "partition": "test"}
{"idx": "1297", "code": "public Boolean isHidden(File f){\n  String name=f.getName();\n  if ((name != null) && !name.equals(\"\") && (name.charAt(0) == \'.\')) {\n    return Boolean.TRUE;\n  }\n else {\n    return Boolean.FALSE;\n  }\n}\n", "docstring": "whether the file is hidden or not . this implementation returns true if the filename starts with a \" . \"", "partition": "test"}
{"idx": "1298", "code": "private boolean scrollViewCanScrollVertically(ScrollView scrollView,int direction){\n  final int offset=Math.max(0,scrollView.getScrollY());\n  final int range=computeVerticalScrollRange(scrollView) - scrollView.getHeight();\n  if (range == 0)   return false;\n  if (direction < 0) {\n    return offset > 0;\n  }\n else {\n    return offset < range - 1;\n  }\n}\n", "docstring": "copy from scrollview ( api level > = 14 )", "partition": "test"}
{"idx": "1299", "code": "public JarInfo loadJar() throws IOException {\n  ZipInputStream zis=null;\n  Manifest mf=null;\n  boolean empty=true;\n  try {\n    zis=new ZipInputStream(jarStream);\n    ZipEntry ent=null;\n    while ((ent=zis.getNextEntry()) != null) {\n      empty=false;\n      String name=ent.getName();\n      if (Manifest.isManifestName(name)) {\n        ByteArrayOutputStream baos=new ByteArrayOutputStream();\n        byte buffer[]=new byte[1024];\n        for (; ; ) {\n          int len=zis.read(buffer);\n          if (len < 0) {\n            break;\n          }\n          baos.write(buffer,0,len);\n        }\n        byte[] buf=baos.toByteArray();\n        mf=new Manifest(buf);\n      }\n    }\n  }\n catch (  IOException ex) {\n    throw ex;\n  }\ncatch (  Throwable th) {\n    th.printStackTrace();\n    throw new IOException(\"loadJar caught: \" + th);\n  }\n finally {\n    if (zis != null) {\n      try {\n        zis.close();\n      }\n catch (      Exception ex) {\n      }\n    }\n  }\n  if (empty) {\n    throw new IOException(\"JAR file is corrupt or empty\");\n  }\n  JarInfo ji=createJarInfo(mf);\n  return ji;\n}\n", "docstring": "load the classes , resources , etc .", "partition": "test"}
{"idx": "1300", "code": "public void invalidateTitleSortable(){\n  for (  Movie movie : new ArrayList<>(movieList)) {\n    movie.clearTitleSortable();\n  }\n}\n", "docstring": "invalidate the title sortable upon changes to the sortable prefixes", "partition": "test"}
{"idx": "1301", "code": "public void addRow(Assignment head,double prob){\n  if (prob < 0.0f || prob > 1.02f) {\n    return;\n  }\n  headVars.addAll(head.getVariables());\n  table.put(head,prob);\n}\n", "docstring": "adds a new row to the probability table , assuming no conditional assignment . if the table already contains a probability , it is erased .", "partition": "test"}
{"idx": "1302", "code": "public byte[] createJarFromFileContent(final String fileName,final String content) throws IOException {\n  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\n  JarOutputStream jarOutputStream=new JarOutputStream(byteArrayOutputStream);\n  JarEntry entry=new JarEntry(fileName);\n  entry.setTime(System.currentTimeMillis());\n  jarOutputStream.putNextEntry(entry);\n  jarOutputStream.write(content.getBytes());\n  jarOutputStream.closeEntry();\n  jarOutputStream.close();\n  return byteArrayOutputStream.toByteArray();\n}\n", "docstring": "create a jar using the given file contents and with the given file name .", "partition": "test"}
{"idx": "1303", "code": "private boolean goTo(long day,boolean animate,boolean setSelected,boolean forceScroll){\n  if (setSelected) {\n    mSelectedDay.setTimeInMillis(day);\n  }\n  mTempDay.setTimeInMillis(day);\n  final int position=getPositionFromDay(day);\n  View child;\n  int i=0;\n  int top=0;\n  do {\n    child=getChildAt(i++);\n    if (child == null) {\n      break;\n    }\n    top=child.getTop();\n  }\n while (top < 0);\n  int selectedPosition;\n  if (child != null) {\n    selectedPosition=getPositionForView(child);\n  }\n else {\n    selectedPosition=0;\n  }\n  if (setSelected) {\n    mAdapter.setSelectedDay(mSelectedDay);\n  }\n  if (position != selectedPosition || forceScroll) {\n    setMonthDisplayed(mTempDay);\n    mPreviousScrollState=OnScrollListener.SCROLL_STATE_FLING;\n    if (animate) {\n      smoothScrollToPositionFromTop(position,LIST_TOP_OFFSET,GOTO_SCROLL_DURATION);\n      return true;\n    }\n else {\n      postSetSelection(position);\n    }\n  }\n else   if (setSelected) {\n    setMonthDisplayed(mSelectedDay);\n  }\n  return false;\n}\n", "docstring": "this moves to the specified time in the view . if the time is not already in range it will move the list so that the first of the month containing the time is at the top of the view . if the new time is already in view the list will not be scrolled unless forcescroll is true . this time may optionally be highlighted as selected as well .", "partition": "test"}
{"idx": "1304", "code": "public boolean search(V v){\n  int h=hashMethod.hash(v);\n  LinkedList<V> list=(LinkedList<V>)table[h];\n  if (list == null) {\n    return false;\n  }\n  return list.contains(v);\n}\n", "docstring": "search for the desired value in the hashtable . < p > only succeeds if v overrides the equals ( object o ) method", "partition": "test"}
{"idx": "1305", "code": "@Override public void messageItemDetails(String strClass,String item,String description,String[] msgOption,int[] msgNumber,int defaultOption){\n  HashMap<Integer,String> options=new HashMap<>(msgOption.length);\n  for (int i=0; i < msgOption.length; i++) {\n    options.put(msgNumber[i],msgOption[i]);\n  }\n  messageItemDetails(strClass,description,item,options,defaultOption);\n}\n", "docstring": "add descriptive details about a specific message box , so that if it needs to be reset in the preferences , then it is easily identifiable . displayed to the user in the preferences gui .", "partition": "test"}
{"idx": "1306", "code": "public void addListener(ColorMapListener listener){\n  listeners.add(listener);\n}\n", "docstring": "add a color map listener", "partition": "test"}
{"idx": "1307", "code": "protected void computePDists(Relation<O> relation,KNNQuery<O> knn,WritableDoubleDataStore pdists){\n  FiniteProgress prdsProgress=LOG.isVerbose() ? new FiniteProgress(\"pdists\",relation.size(),LOG) : null;\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    final KNNList neighbors=knn.getKNNForDBID(iditer,kreach + 1);\n    int ks=0;\n    double ssum=0.;\n    for (DoubleDBIDListIter neighbor=neighbors.iter(); neighbor.valid() && ks < kreach; neighbor.advance()) {\n      if (DBIDUtil.equal(neighbor,iditer)) {\n        continue;\n      }\n      final double d=neighbor.doubleValue();\n      ssum+=d * d;\n      ks++;\n    }\n    double pdist=ks > 0 ? Math.sqrt(ssum / ks) : 0.;\n    pdists.putDouble(iditer,pdist);\n    LOG.incrementProcessed(prdsProgress);\n  }\n  LOG.ensureCompleted(prdsProgress);\n}\n", "docstring": "compute the probabilistic distances used by loop .", "partition": "test"}
{"idx": "1308", "code": "ExternalProblem(Process process){\n  this(process.getInputStream(),process.getOutputStream());\n  RedirectStream.redirect(process.getErrorStream(),System.err);\n}\n", "docstring": "constructs an external problem using the specified process .", "partition": "test"}
{"idx": "1309", "code": "protected static boolean networkMonitorExist(String nwMonName){\n  String classMethod=\"OpenSSOMonitoringUtil.networkMonitorExist: \";\n  if (debug.messageEnabled()) {\n    debug.message(classMethod + \"checking \" + nwMonName);\n  }\n  if ((nwMonName == null) || (nwMonName.length() == 0)) {\n    if (debug.warningEnabled()) {\n      debug.warning(classMethod + \"isNull\");\n    }\n    return false;\n  }\n  Set<String> ntwStats=NetworkMonitor.getInstanceNames();\n  String ss=nwMonName.toLowerCase();\n  if (ntwStats.contains(ss)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "return whether the specified network monitor has been instantiated in the entitlements service yet", "partition": "test"}
{"idx": "1310", "code": "public void andWith(List<QueryPredicate> predicates){\n  children.addAll(predicates);\n}\n", "docstring": "adds multiple predicates that much be met by the vertices .", "partition": "test"}
{"idx": "1311", "code": "public void addRoll(MMRandom rng){\n  int result=rng.randomInt(this.faces) + this.min;\n  all.addElement(new Integer(result));\n  this.total+=result;\n  if (keep != -1 && all.size() >= keep) {\n    this.total=0;\n    Collections.sort(all,Collections.reverseOrder());\n    for (int i=0; i < keep; i++) {\n      this.total+=all.get(i);\n    }\n  }\n}\n", "docstring": "add the result from the given rng source .", "partition": "test"}
{"idx": "1312", "code": "public boolean checkCanonicalUserOptions(){\n  boolean result;\n  OptionHandler handler;\n  String[] userOptions;\n  String[] userOptionsCheck;\n  print(\"Canonical user options...\");\n  try {\n    handler=getDefaultHandler();\n    handler.setOptions(getUserOptions());\n    if (getDebug()) {\n      print(\"\\n  Getting canonical user options: \");\n    }\n    userOptions=handler.getOptions();\n    if (getDebug()) {\n      println(printOptions(userOptions));\n    }\n    if (getDebug()) {\n      println(\"  Setting canonical user options\");\n    }\n    handler.setOptions(userOptions.clone());\n    if (getDebug()) {\n      println(\"  Checking canonical user options\");\n    }\n    userOptionsCheck=handler.getOptions();\n    compareOptions(userOptions,userOptionsCheck);\n    println(\"yes\");\n    result=true;\n  }\n catch (  Exception e) {\n    println(\"no\");\n    result=false;\n    if (getDebug()) {\n      println(e);\n    }\n  }\n  return result;\n}\n", "docstring": "checks whether the user - supplied options stay the same after settting , getting and re - setting again", "partition": "test"}
{"idx": "1313", "code": "public static void closeQuietly(final Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    final RuntimeException rethrown) {\n      throw rethrown;\n    }\ncatch (    final Exception ignored) {\n    }\n  }\n}\n", "docstring": "closes \"'\" closeable \"'\" , ignoring any checked exceptions . does nothing if \"'\" closeable \"'\" is null .", "partition": "test"}
{"idx": "1314", "code": "public static void pushEncryptedMessage(final TextSecureEnvelope envelope){\n  while (true) {\n    try {\n      queue.put(envelope);\n      return;\n    }\n catch (    final InterruptedException e) {\n    }\n  }\n}\n", "docstring": "adds an encrypted message to the queue . it will be automatically decrypted .", "partition": "test"}
{"idx": "1315", "code": "public static int randomRangeInt(int min,int max){\n  return (int)(Math.random() < 0.5 ? ((1 - Math.random()) * (max - min) + min) : (Math.random() * (max - min) + min));\n}\n", "docstring": "returns a random integer between the value min and the value max .", "partition": "test"}
{"idx": "1316", "code": "public void test_simplePrematureClose(){\n  Striterator iter=new Striterator(m_data.iterator());\n  int i=0;\n  while (iter.hasNext()) {\n    iter.next();\n    if (++i == 10) {\n      iter.close();\n      assertTrue(!iter.hasNext());\n    }\n  }\n  assertTrue(!iter.isOpen());\n  assertTrue(i == 10);\n}\n", "docstring": "test that striterator returns false for hasnext ( ) after close ( )", "partition": "test"}
{"idx": "1317", "code": "public void pushDrawList(PspGeList list){\nsynchronized (drawListQueue) {\n    drawListQueue.add(list);\n  }\n}\n", "docstring": "called from pspge module", "partition": "test"}
{"idx": "1318", "code": "private void populateTaskList(Volume source,Map<BlockMirror,Volume> groupMirrorSourceMap,TaskList taskList,String taskId,ResourceOperationTypeEnum operationType){\n  Set<URI> groupSet=new HashSet<URI>();\n  addTask(taskList,source,taskId,operationType);\n  for (  Entry<BlockMirror,Volume> entry : groupMirrorSourceMap.entrySet()) {\n    BlockMirror mirror=entry.getKey();\n    Volume mirrorSource=entry.getValue();\n    if (source.isInCG() && null != taskList.getTaskList()) {\n      groupSet.add(mirrorSource.getConsistencyGroup());\n    }\n  }\n  List<BlockConsistencyGroup> groups=_dbClient.queryObject(BlockConsistencyGroup.class,groupSet);\n  for (  BlockConsistencyGroup group : groups) {\n    addTask(taskList,group,taskId,operationType);\n  }\n}\n", "docstring": "populate the given tasklist with tasks .", "partition": "test"}
{"idx": "1319", "code": "public String clusterDefinitionsTipText(){\n  return \"The clusters to use.\";\n}\n", "docstring": "returns the tip text for this property", "partition": "test"}
{"idx": "1320", "code": "public void addListener(NavigatorListener listener){\n  listeners.add(listener);\n}\n", "docstring": "add listener to listener list", "partition": "test"}
{"idx": "1321", "code": "public void closeStream(){\n  CarbonUtil.closeStreams(stream);\n  executorService.shutdown();\n}\n", "docstring": "below method will be used to close streams", "partition": "test"}
{"idx": "1322", "code": "public double patience(int k,F f,int N){\n  double pf=p(f);\n  BinomialDistribution dist=new BinomialDistribution(null,N,pf);\n  double p0=Math.pow(1 - pf,N);\n  return 1 - (dist.cumulativeProbability(k - 1) - p0) / (1 - p0);\n}\n", "docstring": "return the patience , i . e . , the penalization of having a number of items with the same feature in a recommendation list of a given size .", "partition": "test"}
{"idx": "1323", "code": "public static List seriesNameListFromDataArray(Object[][] data){\n  int seriesCount=data.length;\n  List seriesNameList=new java.util.ArrayList(seriesCount);\n  for (int i=0; i < seriesCount; i++) {\n    seriesNameList.add(\"Series \" + (i + 1));\n  }\n  return seriesNameList;\n}\n", "docstring": "utility method for automatically generating series names .", "partition": "test"}
{"idx": "1324", "code": "@Override public int read(char b[],int off,int len) throws IOException {\n  ensureOpen();\n  if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return 0;\n  }\n  if (pos >= count) {\n    return -1;\n  }\n  if (pos + len > count) {\n    len=count - pos;\n  }\n  if (len <= 0) {\n    return 0;\n  }\n  System.arraycopy(buf,pos,b,off,len);\n  pos+=len;\n  return len;\n}\n", "docstring": "reads characters into a portion of an array .", "partition": "test"}
{"idx": "1325", "code": "private static void expandNumberAt(String numberString,int startIndex,WordRelation wordRelation){\n  expandNumber(numberString.substring(startIndex,numberString.length()),wordRelation);\n}\n", "docstring": "returns the number string list of the given string starting at the given index . e . g . , expandnumberat ( \" 1100 \" , 1 ) gives \" one hundred \"", "partition": "test"}
{"idx": "1326", "code": "@Override public void run(){\n  MultipleObjectsBundle data=generator.loadData();\n  if (LOG.isVerbose()) {\n    LOG.verbose(\"Writing output ...\");\n  }\n  try {\n    if (outputFile.exists() && LOG.isVerbose()) {\n      LOG.verbose(\"The file \" + outputFile + \" already exists, \"+ \"the generator result will be APPENDED.\");\n    }\n    try (OutputStreamWriter outStream=new FileWriter(outputFile,true)){\n      writeClusters(outStream,data);\n    }\n   }\n catch (  IOException e) {\n    throw new AbortException(\"IO Error in data generator.\",e);\n  }\n  if (LOG.isVerbose()) {\n    LOG.verbose(\"Done.\");\n  }\n}\n", "docstring": "runs the wrapper with the specified arguments .", "partition": "test"}
{"idx": "1327", "code": "private boolean usedAllRule17Directors(Set<String> allocatedDirectors,PortAllocationContext context){\n  Set<String> rule17Directors=getRule17Directors(context);\n  for (  String director : allocatedDirectors) {\n    rule17Directors.remove(director);\n  }\n  return rule17Directors.isEmpty();\n}\n", "docstring": "returns true if already used all the rule17 directors .", "partition": "test"}
{"idx": "1328", "code": "public void stop(){\nsynchronized (privateInstanceLock) {\n    if (connectionAcceptThread == null) {\n      return;\n    }\n  }\n  isStopped.set(true);\n  try {\n    connectionAcceptThread.interrupt();\n    connectionAcceptThread.join();\n  }\n catch (  InterruptedException e) {\n  }\n  try {\n    serverSocket.close();\n  }\n catch (  IOException e) {\n  }\n}\n", "docstring": "stops the communicator . all open connections to the remote server will be terminated . once this method has been called , the communicator cannot be restarted .", "partition": "test"}
{"idx": "1329", "code": "private static String expandSystemIdStrictOn(String systemId,String baseSystemId) throws URI.MalformedURIException {\n  URI systemURI=new URI(systemId,true);\n  if (systemURI.isAbsoluteURI()) {\n    return systemId;\n  }\n  URI baseURI=null;\n  if (baseSystemId == null || baseSystemId.length() == 0) {\n    baseURI=getUserDir();\n  }\n else {\n    baseURI=new URI(baseSystemId,true);\n    if (!baseURI.isAbsoluteURI()) {\n      baseURI.absolutize(getUserDir());\n    }\n  }\n  systemURI.absolutize(baseURI);\n  return systemURI.toString();\n}\n", "docstring": "helper method for expandsystemid ( string , string , boolean ) : string", "partition": "test"}
{"idx": "1330", "code": "public static void free(DMessage msg){\n  int index=size2Index(msg.getSize());\n  msg.clear();\n  if (index < 0)   ;\n else   if (m_cache[index] != null)   ;\n else   m_cache[index]=msg;\n}\n", "docstring": "put a dmessage into the cache for reuse", "partition": "test"}
{"idx": "1331", "code": "public boolean equalsIgnoreCase(final StrBuilder other){\n  if (this == other) {\n    return true;\n  }\n  if (this.size != other.size) {\n    return false;\n  }\n  final char thisBuf[]=this.buffer;\n  final char otherBuf[]=other.buffer;\n  for (int i=size - 1; i >= 0; i--) {\n    final char c1=thisBuf[i];\n    final char c2=otherBuf[i];\n    if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "checks the contents of this builder against another to see if they contain the same character content ignoring case .", "partition": "test"}
{"idx": "1332", "code": "protected static Long convertUuidToLong(UUID uuid){\n  if (uuid == null) {\n    return null;\n  }\n  Long convertedUuid;\n  if (uuid.version() == 1) {\n    convertedUuid=uuid.timestamp();\n  }\n else {\n    convertedUuid=uuid.getMostSignificantBits();\n  }\n  return convertedUuid;\n}\n", "docstring": "converts a uuid to a long for bucketing purposes . order of input and output values is preserved as long .", "partition": "test"}
{"idx": "1333", "code": "public void addVMArguments(String vmArgumentName,String vmArgumentValue){\n  VmArgumentData vmArg=new VmArgumentData(vmArgumentName,vmArgumentValue);\n  vmSet.add(vmArg);\n}\n", "docstring": "adds the given vm argument .", "partition": "test"}
{"idx": "1334", "code": "private void applyTo(ClassVisitor v,Field f){\n  if (Log.isLoggingOn()) {\n    Log.logLine(String.format(\"Visiting field %s\",f.toGenericString()));\n  }\n  v.visit(f);\n}\n", "docstring": "apply a visitor to a field .", "partition": "test"}
{"idx": "1335", "code": "public void testCompareToEqualNeg(){\n  byte aBytes[]={12,56,100,-2,-76,89,45,91,3,-15,35,26,3,91};\n  byte bBytes[]={12,56,100,-2,-76,89,45,91,3,-15,35,26,3,91};\n  int aSign=-1;\n  int bSign=-1;\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  assertEquals(0,aNumber.compareTo(bNumber));\n}\n", "docstring": "compareto ( biginteger a ) . compare two equal negative numbers .", "partition": "test"}
{"idx": "1336", "code": "public void testScreenshot() throws Exception {\n  Log.d(LOG_TAG,\"starting testScreenshot\");\n  ScreenshotStubActivity activity=getActivity();\n  assertNotNull(activity);\n  File screenshotDir=getScreenshotDir();\n  NewScreenshotObserver observer=new NewScreenshotObserver(screenshotDir.getAbsolutePath());\n  observer.startWatching();\n  takeScreenshot();\n  if (observer.getCreatedPath() == null) {\nsynchronized (observer) {\n      observer.wait(SCREEN_WAIT_TIME_SEC * 1000);\n    }\n  }\n  assertNotNull(String.format(\"Could not find screenshot after %d seconds\",SCREEN_WAIT_TIME_SEC),observer.getCreatedPath());\n  File screenshotFile=new File(screenshotDir,observer.getCreatedPath());\n  try {\n    assertTrue(String.format(\"Detected new screenshot %s but its not a file\",screenshotFile.getName()),screenshotFile.isFile());\n    assertTrue(String.format(\"Detected new screenshot %s but its not an image\",screenshotFile.getName()),isValidImage(screenshotFile));\n  }\n  finally {\n    screenshotFile.delete();\n  }\n}\n", "docstring": "a simple test for screenshots that launches an activity , injects the key event combo to trigger the screenshot , and verifies the screenshot was taken successfully .", "partition": "test"}
{"idx": "1337", "code": "public TaskResourceRep unlinkTargetVolumesFromSnapshotSession(URI snapSessionURI,SnapshotSessionUnlinkTargetsParam param){\n  return unlinkTargetVolumesFromSnapshotSession(snapSessionURI,param,OperationTypeEnum.UNLINK_SNAPSHOT_SESSION_TARGET);\n}\n", "docstring": "implements a request to unlink the passed targets from the blocksnapshotsession instance with the passed uri .", "partition": "test"}
{"idx": "1338", "code": "private List reverse(List seq){\n  LinkedList newSeq=new LinkedList();\n  for (Iterator i=seq.iterator(); i.hasNext(); ) {\n    DirectedEdge de=(DirectedEdge)i.next();\n    newSeq.addFirst(de.getSym());\n  }\n  return newSeq;\n}\n", "docstring": "reverse the sequence . this requires reversing the order of the diredges , and flipping each diredge as well", "partition": "test"}
{"idx": "1339", "code": "@Deprecated @Override public String readLine() throws IOException {\n  StringBuilder b=new StringBuilder(0);\n  int chr;\n  while ((chr=read()) >= 0) {\n    if (chr != '\\n') {\n      b.append((char)chr);\n    }\n else {\n      return b.toString();\n    }\n  }\n  return b.toString();\n}\n", "docstring": "emulate the deprecated datainputstream . readline ( ) method . originally we used the method itself , but alan brighton suggested using a java . io . bufferedreader to eliminate the deprecation warning . this was used for a long time , but more recently we noted that this doesn \"'\" t work . we now use a simple method that largely ignores character encodings and only uses the \" \\ n \" as the line separator . this method is slow regardless . in the current version", "partition": "test"}
{"idx": "1340", "code": "private void addToScene(final Node items){\n  collection.add(items);\n}\n", "docstring": "adds items to scene , ensuring we are on the fx thread", "partition": "test"}
{"idx": "1341", "code": "public String documentationHomePageUrl(){\n  return properties.getProperty(\"doc.homepage.url\");\n}\n", "docstring": "returns the url of the product home page .", "partition": "test"}
{"idx": "1342", "code": "public static boolean hasTaxonomyInfo(SequencesReader reader){\n  final File taxonFile=new File(reader.path(),TAXONOMY_FILE);\n  final File mappingFile=new File(reader.path(),TAXONOMY_TO_SEQUENCE_FILE);\n  if (taxonFile.exists() && mappingFile.exists()) {\n    return true;\n  }\n else   if (taxonFile.exists() || mappingFile.exists()) {\n    throw new NoTalkbackSlimException(\"Reference SDF does not contain both taxonomy and sequences lookup\");\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "returns true if the supplied reader contains taxonomy information", "partition": "test"}
{"idx": "1343", "code": "public void removeSelectionListener(final SelectionListener listener){\n  checkWidget();\n  if (listener == null) {\n    SWT.error(SWT.ERROR_NULL_ARGUMENT);\n  }\n  listOfSelectionListeners.remove(listener);\n}\n", "docstring": "removes the listener from the collection of listeners who will be notified when the control is selected by the user .", "partition": "test"}
{"idx": "1344", "code": "public void replace(ClassNode type,int n){\n  remove(n);\n  push(type);\n}\n", "docstring": "replace n top level elements with new element of given type", "partition": "test"}
{"idx": "1345", "code": "public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  submitCycle=true;\n  EntitiesModel model=(EntitiesModel)getModel();\n  AMPropertySheet prop=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n  String universalId=(String)getPageSessionAttribute(UNIVERSAL_ID);\n  try {\n    Map oldValues=model.getAttributeValues(universalId,false);\n    Map values=prop.getAttributeValues(oldValues,true,model);\n    String curRealm=(String)getPageSessionAttribute(AMAdminConstants.CURRENT_REALM);\n    model.modifyEntity(curRealm,universalId,values);\n    setInlineAlertMessage(CCAlert.TYPE_INFO,\"message.information\",\"message.updated\");\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n  forwardTo();\n}\n", "docstring": "handles create realm request .", "partition": "test"}
{"idx": "1346", "code": "private static Boolean isInsidePolygon(final GeoPoint point,final List<GeoPoint> polyPoints){\n  final double latitude=point.getLatitude();\n  final double longitude=point.getLongitude();\n  final double sinLatitude=Math.sin(latitude);\n  final double cosLatitude=Math.cos(latitude);\n  final double sinLongitude=Math.sin(longitude);\n  final double cosLongitude=Math.cos(longitude);\n  double arcDistance=0.0;\n  Double prevAngle=null;\n  for (  final GeoPoint polyPoint : polyPoints) {\n    final Double angle=computeAngle(polyPoint,sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (angle == null) {\n      return null;\n    }\n    if (prevAngle != null) {\n      double angleDelta=angle - prevAngle;\n      if (angleDelta < -Math.PI) {\n        angleDelta+=Math.PI * 2.0;\n      }\n      if (angleDelta > Math.PI) {\n        angleDelta-=Math.PI * 2.0;\n      }\n      if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n        return null;\n      }\n      arcDistance+=angleDelta;\n    }\n    prevAngle=angle;\n  }\n  if (prevAngle != null) {\n    final Double lastAngle=computeAngle(polyPoints.get(0),sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (lastAngle == null) {\n      return null;\n    }\n    double angleDelta=lastAngle - prevAngle;\n    if (angleDelta < -Math.PI) {\n      angleDelta+=Math.PI * 2.0;\n    }\n    if (angleDelta > Math.PI) {\n      angleDelta-=Math.PI * 2.0;\n    }\n    if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n      return null;\n    }\n    arcDistance+=angleDelta;\n  }\n  if (Math.abs(arcDistance) < Vector.MINIMUM_RESOLUTION) {\n    return null;\n  }\n  return arcDistance > 0.0;\n}\n", "docstring": "for a specified point and a list of poly points , determine based on point order whether the point should be considered in or out of the polygon .", "partition": "test"}
{"idx": "1347", "code": "private Node deleteMax(Node x){\n  if (x.right == null)   return x.left;\n  x.right=deleteMax(x.right);\n  x.size=1 + size(x.left) + size(x.right);\n  x.height=1 + Math.max(height(x.left),height(x.right));\n  return balance(x);\n}\n", "docstring": "removes the largest key and associated value from the given subtree .", "partition": "test"}
{"idx": "1348", "code": "protected void onProgress(int itemcount,int size){\n}\n", "docstring": "called every time when command makes some little progress . can be mapped to async progress - bar", "partition": "test"}
{"idx": "1349", "code": "private TreeNode(long nodeValue,SnmpMibAgent agent,TreeNode sup){\n  this.nodeValue=nodeValue;\n  this.parent=sup;\n  agents.addElement(agent);\n}\n", "docstring": "only the treenode class can create an instance of treenode . the creation occurs when registering a new oid .", "partition": "test"}
{"idx": "1350", "code": "public Week(Date time){\n  this(time,TimeZone.getDefault(),Locale.getDefault());\n}\n", "docstring": "creates a time period for the week in which the specified date / time falls , using the default time zone and locale ( the locale can affect the day - of - the - week that marks the beginning of the week , as well as the minimal number of days in the first week of the year ) .", "partition": "test"}
{"idx": "1351", "code": "public CodeAttribute createCode(){\n  CodeAttribute code=new CodeAttribute();\n  for (int i=0; i < _attributes.size(); i++) {\n    Attribute attr=_attributes.get(i);\n    if (attr instanceof CodeAttribute)     return (CodeAttribute)attr;\n  }\n  return null;\n}\n", "docstring": "create the code attribute .", "partition": "test"}
{"idx": "1352", "code": "public BinaryOut(String filename){\n  try {\n    OutputStream os=new FileOutputStream(filename);\n    out=new BufferedOutputStream(os);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "initializes a binary output stream from a file .", "partition": "test"}
{"idx": "1353", "code": "public static boolean createNewFile(File targetFile){\n  if (targetFile.exists())   targetFile.delete();\n  try {\n    return targetFile.createNewFile();\n  }\n catch (  IOException e) {\n    return false;\n  }\n}\n", "docstring": "create a new file , if the file exists , delete and create again .", "partition": "test"}
{"idx": "1354", "code": "public void testZeroOne(){\n  byte aBytes[]={0};\n  byte bBytes[]={1};\n  int aSign=0;\n  int bSign=1;\n  byte rBytes[]={1};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.or(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "or for zero and one", "partition": "test"}
{"idx": "1355", "code": "protected int executePrepareStatement(List<Column> columns,PreparedStatement statement) throws SQLException {\n  int bindNo=1;\n  for (  Column c : columns) {\n    setColumnValue(statement,bindNo,c);\n    bindNo++;\n  }\n  return statement.executeUpdate();\n}\n", "docstring": "executes a prepared statement using values supplied as arguments .", "partition": "test"}
{"idx": "1356", "code": "public Config(SamlAuthorityConfiguration samlAuthorityConfig,TokenRestrictions tokenRestrictions,Collection<List<Certificate>> validCerts,long clockTolerance,Collection<IDPConfig> inExternalIdps){\n  Validate.notNull(samlAuthorityConfig);\n  Validate.notNull(tokenRestrictions);\n  Validate.notEmpty(validCerts);\n  List<Certificate> authorityCert=samlAuthorityConfig.getSigningCertificateChain();\n  boolean authorityCertInValidCerts=false;\n  for (  List<Certificate> currentChain : validCerts) {\n    Validate.notEmpty(currentChain);\n    Validate.noNullElements(currentChain);\n    if (!authorityCertInValidCerts && currentChain.equals(authorityCert)) {\n      authorityCertInValidCerts=true;\n    }\n  }\n  Validate.isTrue(authorityCertInValidCerts,\"signing certificate chain is not in valid chains.\");\n  Validate.isTrue(clockTolerance >= 0);\n  this.samlAuthorityConfig=samlAuthorityConfig;\n  this.validCerts=validCerts;\n  this.clockTolerance=clockTolerance;\n  this.tokenRestrictions=tokenRestrictions;\n  HashMap<String,IDPConfig> idpsSet=new HashMap<String,IDPConfig>();\n  if (inExternalIdps != null) {\n    for (    IDPConfig conf : inExternalIdps) {\n      if (conf != null) {\n        idpsSet.put(conf.getEntityID(),conf);\n      }\n    }\n  }\n  this.externalIdps=Collections.unmodifiableMap(idpsSet);\n}\n", "docstring": "creates a new configuration", "partition": "test"}
{"idx": "1357", "code": "public static void checkNotEmpty(String string){\n  if (string.isEmpty()) {\n    throw new NullPointerException();\n  }\n}\n", "docstring": "ensures that an string reference passed as a parameter to the calling method is not empty .", "partition": "test"}
{"idx": "1358", "code": "public void cancelUnnamedTasks(){\n  if (unnamedTaskExecutor != null) {\n    unnamedTaskExecutor.shutdownNow();\n  }\n}\n", "docstring": "cancel all open and running unnamed tasks", "partition": "test"}
{"idx": "1359", "code": "private char readEscapeCharacter() throws IOException {\n  if (pos == limit && !fillBuffer(1)) {\n    throw syntaxError(\"Unterminated escape sequence\");\n  }\n  char escaped=buffer[pos++];\nswitch (escaped) {\ncase \'u\':\n    if (pos + 4 > limit && !fillBuffer(4)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n  char result=0;\nfor (int i=pos, end=i + 4; i < end; i++) {\n  char c=buffer[i];\n  result<<=4;\n  if (c >= \'0\' && c <= \'9\') {\n    result+=(c - \'0\');\n  }\n else   if (c >= \'a\' && c <= \'f\') {\n    result+=(c - \'a\' + 10);\n  }\n else   if (c >= \'A\' && c <= \'F\') {\n    result+=(c - \'A\' + 10);\n  }\n else {\n    throw new NumberFormatException(\"\\\\u\" + new String(buffer,pos,4));\n  }\n}\npos+=4;\nreturn result;\ncase \'t\':\nreturn \'\\t\';\ncase \'b\':\nreturn \'\\b\';\ncase \'n\':\nreturn \'\\n\';\ncase \'r\':\nreturn \'\\r\';\ncase \'f\':\nreturn \'\\f\';\ncase \'\\n\':\nlineNumber++;\nlineStart=pos;\ncase \'\\\'\':\ncase \'\"\':\ncase \'\\\\\':\ncase \'/\':\nreturn escaped;\ndefault :\nthrow syntaxError(\"Invalid escape sequence\");\n}\n}\n", "docstring": "unescapes the character identified by the character or characters that immediately follow a backslash . the backslash \"'\" \\ \"'\" should have already been read . this supports both unicode escapes \" u000a \" and two - character escapes \" \\ n \" .", "partition": "test"}
{"idx": "1360", "code": "private void fixSpannedWithSpaces(SpannableStringBuilder builder,int widthMeasureSpec,int heightMeasureSpec){\n  long startFix=System.currentTimeMillis();\n  FixingResult result=addSpacesAroundSpansUntilFixed(builder,widthMeasureSpec,heightMeasureSpec);\n  if (result.fixed) {\n    removeUnneededSpaces(widthMeasureSpec,heightMeasureSpec,builder,result);\n  }\n else {\n    fallbackToString(widthMeasureSpec,heightMeasureSpec);\n  }\n  long fixDuration=System.currentTimeMillis() - startFix;\n  Logger.d(TAG,\"fixSpannedWithSpaces() duration in ms: \" + fixDuration);\n}\n", "docstring": "add spaces around spans until the text is fixed , and then removes the unneeded spaces", "partition": "test"}
{"idx": "1361", "code": "public EventsIntegrationTest(){\n  setResponseLogLengthLimit(1000);\n  dateFormat=new SimpleDateFormat(\"yyyy-MM-dd\");\n  Calendar cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,-1);\n  yesterday=dateFormat.format(cal.getTime());\n  yesterday+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,0);\n  today=dateFormat.format(cal.getTime());\n  today+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,1);\n  tomorrow=dateFormat.format(cal.getTime());\n  tomorrow+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,3);\n  tomorrowPlus3=dateFormat.format(cal.getTime());\n  tomorrowPlus3+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,-3);\n  yesterdayMinus3=dateFormat.format(cal.getTime());\n  yesterdayMinus3+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,5);\n  tomorrowPlus5=dateFormat.format(cal.getTime());\n  tomorrowPlus5+=\"T00:00:00+0000\";\n  cal=Calendar.getInstance();\n  cal.add(Calendar.DATE,-5);\n  yesterdayMinus5=dateFormat.format(cal.getTime());\n  yesterdayMinus5+=\"T00:00:00+0000\";\n  experiment=ExperimentFactory.createExperiment();\n  experiment.startTime=yesterdayMinus3;\n  experiment.endTime=tomorrowPlus3;\n  experiment.samplingPercent=1.0;\n  experiment.label=\"experiment\";\n  experiment.applicationName=QBO + UUID.randomUUID();\n  DefaultNameExclusionStrategy experimentComparisonStrategy=new DefaultNameExclusionStrategy(\"creationTime\",\"modificationTime\",\"ruleJson\");\n  experiment.setSerializationStrategy(experimentComparisonStrategy);\n}\n", "docstring": "initializes a default experiment .", "partition": "test"}
{"idx": "1362", "code": "public SimpleMetricGroup(GroupName name,Stream<? extends Metric> i){\n  this(name,i.collect(Collectors.<Metric>toList()));\n}\n", "docstring": "create a metric group with the given metrics .", "partition": "test"}
{"idx": "1363", "code": "public boolean isInside(Point point){\n  return bounds.contains(point);\n}\n", "docstring": "returns true if the point is inside this sprite . uses board coordinates , not screen coordinates . by default , just checks our bounding rectangle , though some sprites override this for a smaller sensitive area .", "partition": "test"}
{"idx": "1364", "code": "private void resolveProtocols(ClassLoader loader){\n  ServiceLoader<ProtocolManagerFactory> serviceLoader=ServiceLoader.load(ProtocolManagerFactory.class,loader);\n  loadProtocolManagerFactories(serviceLoader);\n}\n", "docstring": "finds protocol support from a given classloader .", "partition": "test"}
{"idx": "1365", "code": "public static List<InetAddress> hostAddresses(){\n  List<InetAddress> addrList=new ArrayList<>();\n  Enumeration<NetworkInterface> IFCs=null;\n  try {\n    IFCs=NetworkInterface.getNetworkInterfaces();\n  }\n catch (  SocketException ex) {\n    log.error(\"Unable to get network interfaces.\",ex);\n  }\n  if (IFCs != null) {\n    while (IFCs.hasMoreElements()) {\n      NetworkInterface IFC=IFCs.nextElement();\n      try {\n        if (IFC.isUp()) {\n          Enumeration<InetAddress> addresses=IFC.getInetAddresses();\n          while (addresses.hasMoreElements()) {\n            InetAddress address=addresses.nextElement();\n            if (!address.isLoopbackAddress() && !address.isLinkLocalAddress()) {\n              addrList.add(address);\n            }\n          }\n        }\n      }\n catch (      SocketException ex) {\n        log.error(\"Unable to read network interface {}.\",IFC.toString(),ex);\n      }\n    }\n  }\n  return addrList;\n}\n", "docstring": "a list of the non - loopback , non - link - local ip addresses of the host , or null if none found .", "partition": "test"}
{"idx": "1366", "code": "public final static int caculateInSampleSize(BitmapFactory.Options options,int rqsW,int rqsH){\n  final int height=options.outHeight;\n  final int width=options.outWidth;\n  int inSampleSize=1;\n  if (rqsW == 0 || rqsH == 0)   return 1;\n  if (height > rqsH || width > rqsW) {\n    final int heightRatio=Math.round((float)height / (float)rqsH);\n    final int widthRatio=Math.round((float)width / (float)rqsW);\n    inSampleSize=heightRatio < widthRatio ? heightRatio : widthRatio;\n  }\n  return inSampleSize;\n}\n", "docstring": "caculate the bitmap samplesize", "partition": "test"}
{"idx": "1367", "code": "public boolean hasStatus(final StatusID status){\n  return statuses.contains(status);\n}\n", "docstring": "check if the entity has a certain status .", "partition": "test"}
{"idx": "1368", "code": "@Override public String toString(){\n  return \"SparseFeatureStore{\" + \"instanceList=\" + instanceList + \", outcomeList=\"+ outcomeList+ \", weightList=\"+ weightList+ \", sequenceIds=\"+ sequenceIds+ \", sequencePositions=\"+ sequencePositions+ \", addingAnotherInstancesAllowed=\"+ addingAnotherInstancesAllowed+ \", totalNonNullFeaturesCount=\"+ totalNonNullFeaturesCount+ \'}\';\n}\n", "docstring": "primarily for debug purposes", "partition": "test"}
{"idx": "1369", "code": "public void addChannelMap(ChannelMap channelMap){\n  if (!mChannelMaps.contains(channelMap)) {\n    mChannelMaps.add(channelMap);\n    int index=mChannelMaps.indexOf(channelMap);\n    fireIntervalAdded(this,index,index);\n    broadcast(new ChannelMapEvent(channelMap,Event.ADD));\n  }\n}\n", "docstring": "adds the channel map to this model", "partition": "test"}
{"idx": "1370", "code": "@Override public boolean add(E o){\n  if (null == o) {\n    throw new NullPointerException();\n  }\n  if (offer(o)) {\n    return true;\n  }\n  throw new IllegalStateException();\n}\n", "docstring": "adds an element to the queue .", "partition": "test"}
{"idx": "1371", "code": "public Object putResource(Object key,Object value){\n  return (objectCache.put(key,value));\n}\n", "docstring": "return the resource for the specified key", "partition": "test"}
{"idx": "1372", "code": "public UidRange[] parseUidRange() throws DecodingException {\n  CharacterValidator validator=new MessageSetCharValidator();\n  String nextWord=consumeWord(validator,true);\n  int commaPos=nextWord.indexOf(',');\n  if (commaPos == -1) {\n    return new UidRange[]{parseUidRange(nextWord)};\n  }\n  ArrayList<UidRange> rangeList=new ArrayList<UidRange>();\n  int pos=0;\n  while (commaPos != -1) {\n    String range=nextWord.substring(pos,commaPos);\n    UidRange set=parseUidRange(range);\n    rangeList.add(set);\n    pos=commaPos + 1;\n    commaPos=nextWord.indexOf(',',pos);\n  }\n  String range=nextWord.substring(pos);\n  rangeList.add(parseUidRange(range));\n  List<UidRange> merged=UidRange.mergeRanges(rangeList);\n  return merged.toArray(new UidRange[merged.size()]);\n}\n", "docstring": "reads a \" message set \" argument , and parses into an idset . this also support the use of $ as sequence - set as stated in searchres rfc5182", "partition": "test"}
{"idx": "1373", "code": "private String replaceSuffix(String value,String toReplace,String changeTo){\n  String vvalue;\n  if ((value == null) || (toReplace == null) || (changeTo == null)) {\n    return value;\n  }\n  vvalue=removeSuffix(value,toReplace);\n  if (value.equals(vvalue)) {\n    return value;\n  }\n else {\n    return vvalue + changeTo;\n  }\n}\n", "docstring": "replace a string suffix by another", "partition": "test"}
{"idx": "1374", "code": "private void executeClaimedTask(ClaimedTask claimedTask){\n  if (!claimedTask.setStartTime(new Date())) {\n    _log.info(\"Claimed task is overdue; range not scanned: {}\",claimedTask.getTask());\n    return;\n  }\n  ScanRangeTask task=claimedTask.getTask();\n  boolean releaseTask=false;\n  try {\n    _scanWorkflow.renewScanRangeTasks(ImmutableList.of(task),QUEUE_RENEW_TTL);\n    releaseTask=asyncRangeScan(task);\n  }\n  finally {\n    unclaimTask(claimedTask,releaseTask);\n    _backgroundService.submit(_startScansIfAvailableRunnable);\n  }\n}\n", "docstring": "executes a previously claimed scan range task .", "partition": "test"}
{"idx": "1375", "code": "private static boolean createNaviDirectory(){\n  final File dir=new File(ConfigHelper.getConfigurationDirectory(Constants.COMPANY_NAME,Constants.PROJECT_NAME));\n  return dir.exists() || dir.mkdir();\n}\n", "docstring": "creates the configuration directory if it does not already exist .", "partition": "test"}
{"idx": "1376", "code": "public void updateButtonActionPerformed(){\n  if (!readReceiveDelay()) {\n    return;\n  }\n  if (!readPulseWidth()) {\n    return;\n  }\n  if (!checkConsistency()) {\n    return;\n  }\n  if (curNode.getNodeType() != nodeType) {\n    curNode.setNodeType(nodeType);\n  }\n  setNodeParameters();\n  changedNode=true;\n  editMode=false;\n  curNode=null;\n  addButton.setVisible(true);\n  editButton.setVisible(true);\n  deleteButton.setVisible(true);\n  doneButton.setVisible(true);\n  updateButton.setVisible(false);\n  cancelButton.setVisible(false);\n  nodeAddrField.setVisible(true);\n  nodeAddrStatic.setVisible(false);\n  statusText2.setText(stdStatus2);\n  statusText3.setText(stdStatus3);\n  statusText1.setText(rb.getString(\"FeedBackUpdate\") + \" \" + Integer.toString(nodeAddress));\n  errorInStatus1=true;\n}\n", "docstring": "method to handle update button", "partition": "test"}
{"idx": "1377", "code": "public Iterator<Target> targetIterator(){\n  return targetList.iterator();\n}\n", "docstring": "iterate over target objects representing control flow targets and their edge types .", "partition": "test"}
{"idx": "1378", "code": "private void fitSizeOfScrolledContent(){\n  Point p=scrollComposite.getSize();\n  main.setSize(main.computeSize(p.x,SWT.DEFAULT));\n}\n", "docstring": "fits the width of the main composite to the same width scrolled composite was given .", "partition": "test"}
{"idx": "1379", "code": "private static Map<String,SnmpOid> buildPoolIndexMap(SnmpCachedData cached){\n  if (cached == null)   return Collections.emptyMap();\n  final SnmpOid[] indexes=cached.indexes;\n  final Object[] datas=cached.datas;\n  final int len=indexes.length;\n  final Map<String,SnmpOid> m=new HashMap<>(len);\n  for (int i=0; i < len; i++) {\n    final SnmpOid index=indexes[i];\n    if (index == null)     continue;\n    final MemoryPoolMXBean mpm=(MemoryPoolMXBean)datas[i];\n    if (mpm == null)     continue;\n    final String name=mpm.getName();\n    if (name == null)     continue;\n    m.put(name,index);\n  }\n  return m;\n}\n", "docstring": "builds a map pool - name = > pool - index from the snmptablehandler of the jvmmempooltable . optimized algorithm .", "partition": "test"}
{"idx": "1380", "code": "public DCryptoStrength(JFrame parent) throws CryptoException {\n  super(parent,res.getString(\"DCryptoStrength.Title\"),ModalityType.DOCUMENT_MODAL);\n  initComponents();\n}\n", "docstring": "creates a new dcryptostrength dialog where the parent is a frame .", "partition": "test"}
{"idx": "1381", "code": "private Component createSeparator(){\n  JSeparator sep=new JSeparator(SwingConstants.VERTICAL);\n  sep.setPreferredSize(new Dimension(2,30));\n  sep.setMinimumSize(new Dimension(2,30));\n  return sep;\n}\n", "docstring": "creates a vertical separator for visually separating status bar elements", "partition": "test"}
{"idx": "1382", "code": "public void add(final T object){\nsynchronized (mLock) {\n    mList.add(object);\n  }\n  notifyDataSetChanged();\n}\n", "docstring": "adds the specified object at the end of the array .", "partition": "test"}
{"idx": "1383", "code": "public byte[] generateSignature() throws CryptoException, DataLengthException {\n  contentDigest.doFinal(mDash,mDash.length - hLen - sLen);\n  if (sLen != 0) {\n    random.nextBytes(salt);\n    System.arraycopy(salt,0,mDash,mDash.length - sLen,sLen);\n  }\n  byte[] h=new byte[hLen];\n  contentDigest.update(mDash,0,mDash.length);\n  contentDigest.doFinal(h,0);\n  block[block.length - sLen - 1- hLen- 1]=0x01;\n  System.arraycopy(salt,0,block,block.length - sLen - hLen- 1,sLen);\n  byte[] dbMask=maskGeneratorFunction1(h,0,h.length,block.length - hLen - 1);\n  for (int i=0; i != dbMask.length; i++) {\n    block[i]^=dbMask[i];\n  }\n  block[0]&=(0xff >> ((block.length * 8) - emBits));\n  System.arraycopy(h,0,block,block.length - hLen - 1,hLen);\n  block[block.length - 1]=trailer;\n  byte[] b=cipher.processBlock(block,0,block.length);\n  clearBlock(block);\n  return b;\n}\n", "docstring": "generate a signature for the message we \"'\" ve been loaded with using the key we were initialised with .", "partition": "test"}
{"idx": "1384", "code": "public static double[][] computeWeightMatrix(final int quanth,final int quants,final int quantb){\n  final int dim=quanth * quants * quantb;\n  assert (dim > 0);\n  final double[][] m=new double[dim][dim];\n  for (int x=0; x < dim; x++) {\n    final int hx=x / (quantb * quants);\n    final int sx=(x / quantb) % quants;\n    final int bx=x % quantb;\n    for (int y=x; y < dim; y++) {\n      final int hy=y / (quantb * quants);\n      final int sy=(y / quantb) % quants;\n      final int by=y % quantb;\n      final double chx=Math.cos((hx + .5) / quanth * MathUtil.TWOPI);\n      final double chy=Math.cos((hy + .5) / quanth * MathUtil.TWOPI);\n      final double shx=MathUtil.cosToSin((hx + .5) / quanth * MathUtil.TWOPI,chx);\n      final double shy=MathUtil.cosToSin((hy + .5) / quanth * MathUtil.TWOPI,chy);\n      final double cos=chx * (sx + .5) / quants - chy * (sy + .5) / quants;\n      final double sin=shx * (sx + .5) / quants - shy * (sy + .5) / quants;\n      final double db=(bx - by) / (double)quantb;\n      final double val=1. - Math.sqrt((db * db + sin * sin + cos * cos) / 5);\n      m[x][y]=m[y][x]=val;\n    }\n  }\n  return m;\n}\n", "docstring": "compute the weight matrix for hsb similarity .", "partition": "test"}
{"idx": "1385", "code": "public static void openFileIntent(Context context,File openFile){\n  if (context != null && openFile.exists()) {\n    try {\n      Intent intent=getFileIntent(context,openFile);\n      context.startActivity(intent);\n    }\n catch (    Exception e) {\n      GlobalUtils.logThis(TAG,\"openFileIntent Exception\",e);\n    }\n  }\n}\n", "docstring": "open file using intent", "partition": "test"}
{"idx": "1386", "code": "public static int round(final float value){\n  final int bits=Float.floatToRawIntBits(value);\n  final int biasedExp=bits >> 23 & 0xFF;\n  final int shift=23 - 1 + MAX_FLOAT_EXPONENT - biasedExp;\n  if ((shift & -32) == 0) {\n    int extendedMantissa=0x00800000 | bits & 0x007FFFFF;\n    if (bits < 0) {\n      extendedMantissa=-extendedMantissa;\n    }\n    return (extendedMantissa >> shift) + 1 >> 1;\n  }\n else {\n    return (int)value;\n  }\n}\n", "docstring": "might have different semantics than math . round ( float ) , see bugs 6430675 and 8010430 .", "partition": "test"}
{"idx": "1387", "code": "public static PlainText plain(short text){\n  return plain(Integer.toString(text));\n}\n", "docstring": "creates a new plaintext component with the given short", "partition": "test"}
{"idx": "1388", "code": "private String createComponentChanges(){\n  StringBuilder builder=new StringBuilder();\n  for (  ServiceCatalogDiff serviceCatalogDiff : diffList) {\n    builder.append(createApiChanges(serviceCatalogDiff));\n  }\n  return builder.toString();\n}\n", "docstring": "construct details of api changes by service and component name", "partition": "test"}
{"idx": "1389", "code": "public static synchronized void it(String description,UnsafeBlock block){\n  it(description,identity(),block);\n}\n", "docstring": "defines a new example .", "partition": "test"}
{"idx": "1390", "code": "public static boolean isWritable(final File file,final boolean makeDirs){\n  if (file == null) {\n    Log.e(FileUtils.class,\"isWritable(): Null or Empty parameter given\");\n    return false;\n  }\n  final String fileParentDir=file.getParent();\n  if (!TextUtils.isEmpty(fileParentDir)) {\n    final File fileDir=new File(fileParentDir);\n    if (!fileDir.exists()) {\n      if (makeDirs)       return makeDirsForFile(file);\n else       return false;\n    }\n  }\n  boolean isWritable=true;\n  if (file.exists())   isWritable=file.canWrite();\n else {\n    try {\n      isWritable=file.createNewFile();\n    }\n catch (    IOException e) {\n    }\n    if (isWritable)     isWritable=file.delete();\n  }\n  return isWritable;\n}\n", "docstring": "method checks if file could be written / deleted or created . method will create path / mkdirs if makedirs set to true and file \"'\" s path doesn \"'\" t exists .", "partition": "test"}
{"idx": "1391", "code": "public String toString(){\n  return oid.toString();\n}\n", "docstring": "returns a string representation of the oid \"'\" s integer components in dot separated notation .", "partition": "test"}
{"idx": "1392", "code": "private static void createOrgAuthConfig(String realmName) throws Exception {\n  String classMethod=\"UpgradeUtils:createOrgAuthConfig: \";\n  OrganizationConfigManager org=new OrganizationConfigManager(ssoToken,realmName);\n  ServiceConfig orgConfig=org.getServiceConfig(AUTH_SERVICE_NAME);\n  if (orgConfig != null) {\n    Map aa=orgConfig.getAttributes();\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"Org is :\" + realmName);\n      debug.message(classMethod + \"Attribute Map is :\" + aa);\n    }\n    String orgName=realmName;\n    if (LDAPUtils.isDN(realmName)) {\n      orgName=LDAPUtils.rdnValueFromDn(realmName);\n    }\n    String authConfigName=orgName + \"-authconfig\";\n    String adminAuthConfigName=orgName + \"-admin-authconfig\";\n    Set authConfigAttrValue=(Set)aa.get(ATTR_ORG_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"authConfigAttrValue : \" + authConfigAttrValue);\n    }\n    Set newVal=new HashSet();\n    if (authConfigAttrValue.size() != 1 && !authConfigAttrValue.contains(authConfigName)) {\n      newVal.add(authConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ORG_AUTH_MODULE,authConfigAttrValue,newVal);\n    }\n    Set adminConfigAttrValue=(Set)aa.get(ATTR_ADMIN_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(\"adminauthConfigAttrValue : \" + adminConfigAttrValue);\n    }\n    if (adminConfigAttrValue.size() != 1 && !adminConfigAttrValue.contains(adminAuthConfigName)) {\n      newVal.clear();\n      newVal.add(adminAuthConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ADMIN_AUTH_MODULE,adminConfigAttrValue,newVal);\n    }\n    aa=orgConfig.getAttributes();\n    ServiceConfig s=org.getServiceConfig(AUTH_CONFIG_SERVICE);\n    ServiceConfig authConfig=s.getSubConfig(NAMED_CONFIG);\n    if (authConfig == null) {\n      s.addSubConfig(NAMED_CONFIG,null,0,null);\n      authConfig=s.getSubConfig(NAMED_CONFIG);\n    }\n    Map aMap=new HashMap();\n    aMap.put(ATTR_AUTH_CONFIG,authConfigAttrValue);\n    authConfig.addSubConfig(authConfigName,SUB_NAMED_CONFIG,0,aMap);\n    aMap.clear();\n    aMap.put(ATTR_AUTH_CONFIG,adminConfigAttrValue);\n    authConfig.addSubConfig(adminAuthConfigName,SUB_NAMED_CONFIG,0,aMap);\n  }\n}\n", "docstring": "creates auth configurations for auth modules configuration in core auth service .", "partition": "test"}
{"idx": "1393", "code": "public void read(ByteCodeParser in) throws IOException {\n  int length=in.readInt();\n  _maxStack=in.readShort();\n  _maxLocals=in.readShort();\n  int codeLength=in.readInt();\n  _code=new byte[codeLength];\n  in.read(_code,0,codeLength);\n  int exnCount=in.readShort();\n  for (int i=0; i < exnCount; i++) {\n    ExceptionItem exn=new ExceptionItem();\n    exn.setStart(in.readShort() & 0xffff);\n    exn.setEnd(in.readShort() & 0xffff);\n    exn.setHandler(in.readShort() & 0xffff);\n    exn.setType(in.readShort() & 0xffff);\n    _exceptions.add(exn);\n  }\n  int attrCount=in.readShort();\n  for (int i=0; i < attrCount; i++) {\n    Attribute attr=in.parseAttribute();\n    _attributes.add(attr);\n  }\n}\n", "docstring": "writes the field to the output .", "partition": "test"}
{"idx": "1394", "code": "void addString(int c){\n  if (strpos == str.length) {\n    char newstr[]=new char[str.length + 128];\n    System.arraycopy(str,0,newstr,0,str.length);\n    str=newstr;\n  }\n  str[strpos++]=(char)c;\n}\n", "docstring": "add a char to the string buffer .", "partition": "test"}
{"idx": "1395", "code": "protected void findCandidateCrossings(S2Point a,S2Point b,List<Integer> candidateCrossings){\n  Preconditions.checkState(indexComputed);\n  ArrayList<S2CellId> cover=Lists.newArrayList();\n  getCovering(a,b,false,cover);\n  Set<Integer> uniqueSet=new HashSet<Integer>();\n  getEdgesInParentCells(cover,uniqueSet);\n  getEdgesInChildrenCells(a,b,cover,uniqueSet);\n  candidateCrossings.clear();\n  candidateCrossings.addAll(uniqueSet);\n}\n", "docstring": "appends to \" candidatecrossings \" all edge references which may cross the given edge . this is done by covering the edge and then finding all references of edges whose coverings overlap this covering . parent cells are checked level by level . child cells are checked all at once by taking advantage of the natural ordering of s2cellids .", "partition": "test"}
{"idx": "1396", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return TRUE_AS_OF_SECS;\ncase 2:\n  return SOURCE;\ncase 3:\nreturn SYSTEM;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "1397", "code": "public RepositoryLocation(String repositoryName,String[] pathComponents) throws MalformedRepositoryLocationException {\n  if (repositoryName == null || repositoryName.isEmpty()) {\n    throw new MalformedRepositoryLocationException(\"repositoryName must not contain null or empty!\");\n  }\n  if (pathComponents == null) {\n    throw new MalformedRepositoryLocationException(\"pathComponents must not be null!\");\n  }\n  for (  String pathComp : pathComponents) {\n    if (pathComp == null || pathComp.isEmpty()) {\n      throw new MalformedRepositoryLocationException(\"path must not contain null or empty strings!\");\n    }\n  }\n  this.repositoryName=repositoryName;\n  this.path=pathComponents;\n}\n", "docstring": "creates a repositorylocation for a given repository and a set of path components which will be concatenated by a / .", "partition": "test"}
{"idx": "1398", "code": "protected JavaElementDelta createDeltaTree(IJavaElement element,JavaElementDelta delta){\n  JavaElementDelta childDelta=delta;\n  ArrayList ancestors=getAncestors(element);\n  if (ancestors == null) {\n    if (equalsAndSameParent(delta.getElement(),getElement())) {\n      this.kind=delta.kind;\n      this.changeFlags=delta.changeFlags;\n      this.movedToHandle=delta.movedToHandle;\n      this.movedFromHandle=delta.movedFromHandle;\n    }\n  }\n else {\n    for (int i=0, size=ancestors.size(); i < size; i++) {\n      IJavaElement ancestor=(IJavaElement)ancestors.get(i);\n      JavaElementDelta ancestorDelta=new JavaElementDelta(ancestor);\n      ancestorDelta.addAffectedChild(childDelta);\n      childDelta=ancestorDelta;\n    }\n  }\n  return childDelta;\n}\n", "docstring": "creates the nested delta deltas based on the affected element its delta , and the root of this delta tree . returns the root of the created delta tree .", "partition": "test"}
{"idx": "1399", "code": "@Override public String toString(){\n  return getTitle();\n}\n", "docstring": "tostring . used for jcombobox in movie editor", "partition": "test"}
{"idx": "1400", "code": "public int size(){\n  if (hmap == null) {\n    return 0;\n  }\n  return hmap.size();\n}\n", "docstring": "return the size of the embedded map", "partition": "test"}
{"idx": "1401", "code": "public boolean coordinateInZone(Id<ActivityFacility> zoneID,Coord coordinate){\n  Point point=MGC.xy2Point(coordinate.getX(),coordinate.getY());\n  return pointInZone(zoneID,point);\n}\n", "docstring": "determines if a given coordinate lies within a selected zone . the shape of the zone is defined by the respective zone geometry in the shape file", "partition": "test"}
{"idx": "1402", "code": "public String associatorTipText(){\n  return \"The base associator to be used.\";\n}\n", "docstring": "returns the tip text for this property", "partition": "test"}
{"idx": "1403", "code": "public XwavesLabelfileReader(Reader reader) throws IOException {\n  this.reader=new BufferedReader(reader);\n  parseLabels();\n  reader.close();\n}\n", "docstring": "read data from a label file .", "partition": "test"}
{"idx": "1404", "code": "public static double parseDoubleDefault(String s,double def){\n  if (s == null) {\n    return def;\n  }\n  try {\n    return Double.parseDouble(s);\n  }\n catch (  NumberFormatException e) {\n    return def;\n  }\n}\n", "docstring": "parses a double safely , returning a default if nothing can be sanely parsed from it .", "partition": "test"}
{"idx": "1405", "code": "public boolean putProfile(Profile profile){\n  return putProfile(profile,false);\n}\n", "docstring": "create or update a profile for a remote counterpart .", "partition": "test"}
{"idx": "1406", "code": "public void print(char c){\n  writer.print(c);\n}\n", "docstring": "prints the given char . use println ( ) to print a \"'\" \\ n \"'\" .", "partition": "test"}
{"idx": "1407", "code": "public void initBlockViews(){\n  if (mWorkspaceView != null) {\n    List<Block> rootBlocks=mWorkspace.getRootBlocks();\n    ConnectionManager connManager=mWorkspace.getConnectionManager();\n    for (int i=0; i < rootBlocks.size(); i++) {\n      BlockGroup bg=mViewFactory.buildBlockGroupTree(rootBlocks.get(i),connManager,mTouchHandler);\n      mWorkspaceView.addView(bg);\n    }\n  }\n}\n", "docstring": "recursively initialize views for all the blocks in the model and add them to the view .", "partition": "test"}
{"idx": "1408", "code": "protected void clearAllTrails(SSOTokenID tokenID){\n  boolean removed=false;\n  String key=tokenID.toString();\nsynchronized (mapTokenIDs) {\n    removed=(mapTokenIDs.remove(key) != null);\n  }\n}\n", "docstring": "clears all registered page trails of a given single sign on token id", "partition": "test"}
{"idx": "1409", "code": "public DNetscapeCaRevocationUrl(JDialog parent,byte[] value) throws IOException {\n  super(parent);\n  setTitle(res.getString(\"DNetscapeCaRevocationUrl.Title\"));\n  initComponents();\n  prepopulateWithValue(value);\n}\n", "docstring": "creates a new dnetscapecarevocationurl dialog .", "partition": "test"}
{"idx": "1410", "code": "public DirectoryOrFileNotFoundException(String entity,String name){\n  super(String.format(_errorMessage,entity,name));\n}\n", "docstring": "constructs a new exception with detailed error message .", "partition": "test"}
{"idx": "1411", "code": "void scramble(){\n  initialSize=getSize();\n  int a[]=new int[initialSize.height / 2];\n  double f=initialSize.width / (double)a.length;\n  for (int i=a.length; --i >= 0; ) {\n    a[i]=(int)(i * f);\n  }\n  for (int i=a.length; --i >= 0; ) {\n    int j=(int)(i * Math.random());\n    int t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n  }\n  arr=a;\n}\n", "docstring": "fill the array with random numbers from 0 . . n - 1 .", "partition": "test"}
{"idx": "1412", "code": "public static SIPHeader parseSIPHeader(String header) throws ParseException {\n  int start=0;\n  int end=header.length() - 1;\n  try {\n    while (header.charAt(start) <= 0x20)     start++;\n    while (header.charAt(end) <= 0x20)     end--;\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    throw new ParseException(\"Empty header.\",0);\n  }\n  StringBuilder buffer=new StringBuilder(end + 1);\n  int i=start;\n  int lineStart=start;\n  boolean endOfLine=false;\n  while (i <= end) {\n    char c=header.charAt(i);\n    if (c == \'\\r\' || c == \'\\n\') {\n      if (!endOfLine) {\n        buffer.append(header.substring(lineStart,i));\n        endOfLine=true;\n      }\n    }\n else {\n      if (endOfLine) {\n        endOfLine=false;\n        if (c == \' \' || c == \'\\t\') {\n          buffer.append(\' \');\n          lineStart=i + 1;\n        }\n else {\n          lineStart=i;\n        }\n      }\n    }\n    i++;\n  }\n  buffer.append(header.substring(lineStart,i));\n  buffer.append(\'\\n\');\n  HeaderParser hp=ParserFactory.createParser(buffer.toString());\n  if (hp == null)   throw new ParseException(\"could not create parser\",0);\n  return hp.parse();\n}\n", "docstring": "parse an individual sip message header from a string .", "partition": "test"}
{"idx": "1413", "code": "private static int convertSRGBtoLinearRGB(int color){\n  float input, output;\n  input=color / 255.0f;\n  if (input <= 0.04045f) {\n    output=input / 12.92f;\n  }\n else {\n    output=(float)Math.pow((input + 0.055) / 1.055,2.4);\n  }\n  return Math.round(output * 255.0f);\n}\n", "docstring": "helper function to convert a color component in srgb space to linear rgb space . used to build a static lookup table .", "partition": "test"}
{"idx": "1414", "code": "public void recordBeginning(){\n  final String msg=\"Usage beginning module=\" + mModuleName + \" runId=\"+ mRunId;\n  mUsageMessages.add(msg);\n  Diagnostic.developerLog(msg);\n  mClient.recordBeginning(mModuleName,mRunId);\n}\n", "docstring": "records a start usage logging message to whichever logging endpoint is configured", "partition": "test"}
{"idx": "1415", "code": "static float rotateY(float pX,float pY,float cX,float cY,float angleInDegrees){\n  double angle=Math.toRadians(angleInDegrees);\n  return (float)(Math.sin(angle) * (pX - cX) + Math.cos(angle) * (pY - cY) + cY);\n}\n", "docstring": "rotate point p around center point c .", "partition": "test"}
{"idx": "1416", "code": "public boolean isPronounceable(String word){\n  String lowerCaseWord=word.toLowerCase();\n  return (prefixFSM.accept(lowerCaseWord) && suffixFSM.accept(lowerCaseWord));\n}\n", "docstring": "returns true if the given word is pronounceable . this method is originally called us_aswd ( ) in flite 1 . 1 .", "partition": "test"}
{"idx": "1417", "code": "public void addSplitEdges(List edgeList){\n  addEndpoints();\n  Iterator it=iterator();\n  EdgeIntersection eiPrev=(EdgeIntersection)it.next();\n  while (it.hasNext()) {\n    EdgeIntersection ei=(EdgeIntersection)it.next();\n    Edge newEdge=createSplitEdge(eiPrev,ei);\n    edgeList.add(newEdge);\n    eiPrev=ei;\n  }\n}\n", "docstring": "creates new edges for all the edges that the intersections in this list split the parent edge into . adds the edges to the input list ( this is so a single list can be used to accumulate all split edges for a geometry ) .", "partition": "test"}
{"idx": "1418", "code": "public MemBasedCache(int maxCacheSizeInBytes){\n  mMaxCacheSizeInBytes=maxCacheSizeInBytes;\n  mDataEntries=new LinkedHashMap<String,CacheHeader>(16,.75f,true);\n}\n", "docstring": "constructs an instance of the membasedcache .", "partition": "test"}
{"idx": "1419", "code": "public void updateMaxTextWidths(float requiredWidth,float matchContentsWidth){\n  mMaxRequiredWidth=Math.max(mMaxRequiredWidth,requiredWidth);\n  mMaxMatchContentsWidth=Math.max(mMaxMatchContentsWidth,matchContentsWidth);\n}\n", "docstring": "updates the max text width values for the suggestions .", "partition": "test"}
{"idx": "1420", "code": "public void enableOverview(boolean b){\n  if (overviewItem != null) {\n    overviewItem.setEnabled(b);\n  }\n}\n", "docstring": "enable / disable the overview menu .", "partition": "test"}
{"idx": "1421", "code": "public void mouseEntered(MouseEvent e){\n  if (Debug.debugging(\"mousemodedetail\")) {\n    Debug.output(getID() + \"|NavMouseMode.mouseEntered()\");\n  }\n  super.mouseEntered(e);\n  autoZoom=true;\n}\n", "docstring": "handle a mouseentered mouselistener event . the boolean autozoom is set to true , which will make the delegate ask the map to zoom in to a box that is drawn .", "partition": "test"}
{"idx": "1422", "code": "public PageOfCollections fetchPage(PageOfCollections page,SolrZkClient zkClient) throws KeeperException, InterruptedException {\n  List<String> children=getCollections(zkClient);\n  page.selected=children;\n  if (page.start == 0 && page.rows == -1 && page.filter == null && children.size() > 10) {\n    page.rows=20;\n    page.start=0;\n  }\n  if (page.filterType == FilterType.name && page.filter != null)   children=page.applyNameFilter(children);\n  if (page.filterType != FilterType.status)   page.selectPage(children);\n  return page;\n}\n", "docstring": "gets the requested page of collections after applying filters and offsets .", "partition": "test"}
{"idx": "1423", "code": "public IdsQueryBuilder addIds(String... ids){\n  values.addAll(Arrays.asList(ids));\n  return this;\n}\n", "docstring": "adds ids to the filter .", "partition": "test"}
{"idx": "1424", "code": "private void stop(HttpServletRequest request,HttpServletResponse response) throws IOException {\n  PrintWriter out=response.getWriter();\n  String label=request.getParameter(\"stop\");\n  Monitor mon=removeMon(label,null,DEFAULT_UNITS);\n  if (mon == null) {\n    out.println(ERROR + \": stop requires that an existing label is passed in.  For example: curl http://localhost:8080/jamon/Mon?stop=mylabel\");\n  }\n else {\n    mon.stop();\n    out.println(OK + \": stop successfully called on - \" + mon);\n  }\n}\n", "docstring": "stop a previously started monitor if it exists .", "partition": "test"}
{"idx": "1425", "code": "public static String normalizeUrl(String requestUrl) throws OAuthException {\n  if ((requestUrl == null) || (requestUrl.length() == 0)) {\n    throw new OAuthException(\"Request Url cannot be empty\");\n  }\n  URI uri;\n  try {\n    uri=new URI(requestUrl);\n  }\n catch (  URISyntaxException e) {\n    throw new OAuthException(e);\n  }\n  String authority=uri.getAuthority();\n  String scheme=uri.getScheme();\n  if (authority == null || scheme == null) {\n    throw new OAuthException(\"Invalid Request Url\");\n  }\n  authority=authority.toLowerCase();\n  scheme=scheme.toLowerCase();\n  if ((scheme.equals(\"http\") && uri.getPort() == 80) || (scheme.equals(\"https\") && uri.getPort() == 443)) {\n    int index=authority.lastIndexOf(\":\");\n    if (index >= 0) {\n      authority=authority.substring(0,index);\n    }\n  }\n  return scheme + \"://\" + authority+ uri.getRawPath();\n}\n", "docstring": "calculates the normalized request url , as per section 9 . 1 . 2 of the oauth spec . this removes the querystring from the url and the port ( if it is the standard http or https port ) .", "partition": "test"}
{"idx": "1426", "code": "public void invoke(InputStream is,OutputStream os,SerializerFactory serializerFactory) throws Exception {\n  boolean isDebug=false;\n  if (isDebugInvoke()) {\n    isDebug=true;\n    PrintWriter dbg=createDebugPrintWriter();\n    HessianDebugInputStream dIs=new HessianDebugInputStream(is,dbg);\n    dIs.startTop2();\n    is=dIs;\n    HessianDebugOutputStream dOs=new HessianDebugOutputStream(os,dbg);\n    dOs.startTop2();\n    os=dOs;\n  }\n  HessianInputFactory.HeaderType header=_inputFactory.readHeader(is);\n  AbstractHessianInput in;\n  AbstractHessianOutput out;\nswitch (header) {\ncase CALL_1_REPLY_1:\n    in=_hessianFactory.createHessianInput(is);\n  out=_hessianFactory.createHessianOutput(os);\nbreak;\ncase CALL_1_REPLY_2:\nin=_hessianFactory.createHessianInput(is);\nout=_hessianFactory.createHessian2Output(os);\nbreak;\ncase HESSIAN_2:\nin=_hessianFactory.createHessian2Input(is);\nin.readCall();\nout=_hessianFactory.createHessian2Output(os);\nbreak;\ndefault :\nthrow new IllegalStateException(header + \" is an unknown Hessian call\");\n}\nif (serializerFactory != null) {\nin.setSerializerFactory(serializerFactory);\nout.setSerializerFactory(serializerFactory);\n}\ntry {\ninvoke(_service,in,out);\n}\n  finally {\nin.close();\nout.close();\nif (isDebug) os.close();\n}\n}\n", "docstring": "invoke the object with the request from the input stream .", "partition": "test"}
{"idx": "1427", "code": "private void commitLocalTransaction() throws CommitFailedException {\n  if (_tx == null) {\n    return;\n  }\n  if (_logger.isLoggable(Level.FINEST)) {\n    _logger.log(Level.FINEST,\"Committing local transaction: \" + _tx);\n  }\n  try {\n    _tx.commit();\n  }\n catch (  Exception e) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,\"Failed to commit local transaction: \" + _tx,e);\n    }\n    throw new CommitFailedException(e);\n  }\n}\n", "docstring": "commits the local transaction .", "partition": "test"}
{"idx": "1428", "code": "public static Entry addObjectClass(Entry entry){\n  Attribute attribute=entry.getAttribute(CoreTokenConstants.OBJECT_CLASS);\n  if (attribute == null) {\n    entry.addAttribute(CoreTokenConstants.OBJECT_CLASS,CoreTokenConstants.FR_CORE_TOKEN);\n  }\n  return entry;\n}\n", "docstring": "only adds the objectclass if it hasn \"'\" t already been added .", "partition": "test"}
{"idx": "1429", "code": "@SuppressWarnings(\"unchecked\") public List<Boundary> populateArea(final Long wardId){\n  HierarchyType hType=heirarchyTypeService.getHierarchyTypeByName(hierarchyTypeName);\n  ;\n  List<Boundary> areaList=new LinkedList<Boundary>();\n  final BoundaryType childBoundaryType=boundaryTypeService.getBoundaryTypeByNameAndHierarchyType(\"Area\",hType);\n  final Boundary parentBoundary=boundaryService.getBoundaryById(wardId);\n  areaList=new LinkedList(crossHeirarchyService.getCrossHierarchyChildrens(parentBoundary,childBoundaryType));\n  LOGGER.info(\"***********Ajax AreaList: \" + areaList.toString());\n  return areaList;\n}\n", "docstring": "populate the area list by ward", "partition": "test"}
{"idx": "1430", "code": "private static String readName(DataInputStream dis,byte data[]) throws IOException {\n  int c=dis.readUnsignedByte();\n  if ((c & 0xc0) == 0xc0) {\n    c=((c & 0x3f) << 8) + dis.readUnsignedByte();\n    HashSet<Integer> jumps=new HashSet<Integer>();\n    jumps.add(c);\n    return readName(data,c,jumps);\n  }\n  if (c == 0) {\n    return \"\";\n  }\n  byte b[]=new byte[c];\n  dis.readFully(b);\n  String s=IDN.toUnicode(new String(b));\n  String t=readName(dis,data);\n  if (t.length() > 0) {\n    s=s + \".\" + t;\n  }\n  return s;\n}\n", "docstring": "parse a domain name starting at the current offset and moving the input stream pointer past this domain name ( even if cross references occure ) .", "partition": "test"}
{"idx": "1431", "code": "public SimpleString concat(final char c){\n  byte[] bytes=new byte[data.length + 2];\n  System.arraycopy(data,0,bytes,0,data.length);\n  bytes[data.length]=(byte)(c & 0xFF);\n  bytes[data.length + 1]=(byte)(c >> 8 & 0xFF);\n  return new SimpleString(bytes);\n}\n", "docstring": "concatenates a simplestring and a char", "partition": "test"}
{"idx": "1432", "code": "public void deepFill(MaryNode specTree){\n  tree=specTree;\n  numberOfLeaves=0;\n  sortNode(0,tree);\n}\n", "docstring": "fill a tree which specifies a feature hierarchy but no corresponding units .", "partition": "test"}
{"idx": "1433", "code": "public int nodeCount(){\n  return nodes == null ? 0 : nodes.size();\n}\n", "docstring": "return the number of nodes in the is way", "partition": "test"}
{"idx": "1434", "code": "public void addToGlobalBlacklist(String host){\n  addToGlobalBlacklist(host,System.currentTimeMillis() + this.globalBlacklistTimeout);\n}\n", "docstring": "adds a host to the blacklist .", "partition": "test"}
{"idx": "1435", "code": "public boolean addNode(Lop node){\n  if (nodes.contains(node))   return false;\n  nodes.add(node);\n  return true;\n}\n", "docstring": "method to add a node to the dag .", "partition": "test"}
{"idx": "1436", "code": "public static final double sigma(double a){\n  return 1.0 / (1.0 + Math.exp(-a));\n}\n", "docstring": "sigmoid / logistic function", "partition": "test"}
{"idx": "1437", "code": "public void insertOrRefresh(final KBucketEntry newEntry){\n  if (newEntry == null)   return;\n  List<KBucketEntry> entriesRef=entries;\n  for (  KBucketEntry existing : entriesRef) {\n    if (existing.equals(newEntry)) {\n      existing.mergeInTimestamps(newEntry);\n      return;\n    }\n    if (existing.matchIPorID(newEntry)) {\n      DHT.logInfo(\"new node \" + newEntry + \" claims same ID or IP as \"+ existing+ \", might be impersonation attack or IP change. ignoring until old entry times out\");\n      return;\n    }\n  }\n  if (newEntry.verifiedReachable()) {\n    if (entriesRef.size() < DHTConstants.MAX_ENTRIES_PER_BUCKET) {\n      modifyMainBucket(null,newEntry);\n      return;\n    }\n    if (replaceBadEntry(newEntry))     return;\n    KBucketEntry youngest=entriesRef.get(entriesRef.size() - 1);\n    if (youngest.getCreationTime() > newEntry.getCreationTime() || newEntry.getRTT() * 2.5 < youngest.getRTT()) {\n      modifyMainBucket(youngest,newEntry);\n      insertInReplacementBucket(youngest);\n      return;\n    }\n  }\n  insertInReplacementBucket(newEntry);\n}\n", "docstring": "notify bucket of new incoming packet from a node , perform update or insert existing nodes where appropriate", "partition": "test"}
{"idx": "1438", "code": "public void translate(double x,double y){\n  currentTransform.translate(x,y);\n  try {\n    writeTransform(new AffineTransform(1,0,0,1,x,y));\n  }\n catch (  IOException e) {\n    handleException(e);\n  }\n}\n", "docstring": "translates the current transform . calls writetransform ( transform )", "partition": "test"}
{"idx": "1439", "code": "public static boolean isSupportedAddRPProtectionVirtualPoolChange(Volume volume,VirtualPool currentVpool,VirtualPool newVpool,DbClient dbClient,StringBuffer notSuppReasonBuff){\n  s_logger.info(String.format(\"Checking isSupportedAddRPProtectionVirtualPoolChange from [%s] to [%s]...\",currentVpool.getLabel(),newVpool.getLabel()));\n  if (isSameVirtualPool(currentVpool,newVpool,notSuppReasonBuff)) {\n    return false;\n  }\n  if (volume.checkForRp() || VirtualPool.vPoolSpecifiesProtection(currentVpool)) {\n    notSuppReasonBuff.append(\"Can\'t add RecoverPoint Protection since it already exists.\");\n    return false;\n  }\n  if (!VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && VirtualPool.vPoolSpecifiesRPVPlex(newVpool)) {\n    notSuppReasonBuff.append(\"Can\'t add RecoverPoint+VPLEX Protection directly to non-VPLEX volume. Import to VPLEX first.\");\n    return false;\n  }\n  if (VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && !VirtualPool.vPoolSpecifiesHighAvailabilityDistributed(currentVpool) && VirtualPool.vPoolSpecifiesMetroPoint(newVpool)) {\n    notSuppReasonBuff.append(\"Can\'t add MetroPoint Protection directly to VPLEX Local volume. \" + \"Upgrade from VPLEX Local to VPLEX Distributed first.\");\n    return false;\n  }\n  String[] include=new String[]{TYPE,VARRAYS,REF_VPOOL,MIRROR_VPOOL,FAST_EXPANSION,ACLS,INACTIVE,PROTOCOLS,PROVISIONING_TYPE,USE_MATCHED_POOLS,ARRAY_INFO,DRIVE_TYPE,AUTO_TIER_POLICY_NAME,HOST_IO_LIMIT_IOPS,HOST_IO_LIMIT_BANDWIDTH,VMAX_COMPRESSION_ENABLED,IS_THIN_VOLUME_PRE_ALLOCATION_ENABLED,ASSIGNED_STORAGE_POOLS};\n  Map<String,Change> changes=analyzeChanges(currentVpool,newVpool,include,null,null);\n  if (!changes.isEmpty()) {\n    notSuppReasonBuff.append(\"These target virtual pool differences are invalid: \");\n    fillInNotSupportedReasons(changes,notSuppReasonBuff);\n    return false;\n  }\n  include=new String[]{PROTECTION_VARRAY_SETTINGS};\n  changes=analyzeChanges(currentVpool,newVpool,include,null,null);\n  if (changes.isEmpty()) {\n    notSuppReasonBuff.append(\"These target virtual pool differences are required: \");\n    fillInNotSupportedReasons(changes,notSuppReasonBuff);\n    return false;\n  }\n  if (VirtualPool.vPoolSpecifiesHighAvailability(currentVpool) && (VirtualPool.vPoolSpecifiesRPVPlex(newVpool) || VirtualPool.vPoolSpecifiesMetroPoint(newVpool))) {\n    VirtualPoolChangeOperationEnum op=vplexCommonChecks(volume,currentVpool,newVpool,dbClient,notSuppReasonBuff,include);\n    if (op == null || !op.equals(VirtualPoolChangeOperationEnum.RP_PROTECTED)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "determines if the volume qualifies for rp protection . ( and if not , why not )", "partition": "test"}
{"idx": "1440", "code": "private void writeObject(ObjectOutputStream oos) throws IOException {\n  oos.defaultWriteObject();\n  boolean writeFont=(f != OMText.DEFAULT_FONT);\n  oos.writeBoolean(writeFont);\n  if (writeFont) {\n    oos.writeObject(f.getName());\n    oos.writeInt(f.getSize());\n    oos.writeInt(f.getStyle());\n  }\n  writeStroke(oos,stroke,OMGraphic.BASIC_STROKE);\n  writeStroke(oos,textMatteStroke,DEFAULT_TEXT_MATTE_STROKE);\n}\n", "docstring": "write this object to a stream .", "partition": "test"}
{"idx": "1441", "code": "private static void writeSpaces(Writer out,int amt) throws IOException {\n  while (amt > 0) {\n    out.write(' ');\n    amt--;\n  }\n}\n", "docstring": "writes the given number of spaces to the given writer .", "partition": "test"}
{"idx": "1442", "code": "public static double relativeOverlap(SpatialComparable box1,SpatialComparable box2){\n  final int dim=assertSameDimensionality(box1,box2);\n  double overlap=1.;\n  double vol1=1.;\n  double vol2=1.;\n  for (int i=0; i < dim; i++) {\n    final double box1min=box1.getMin(i);\n    final double box1max=box1.getMax(i);\n    final double box2min=box2.getMin(i);\n    final double box2max=box2.getMax(i);\n    final double omax=Math.min(box1max,box2max);\n    final double omin=Math.max(box1min,box2min);\n    if (omax <= omin) {\n      return 0.;\n    }\n    overlap*=omax - omin;\n    vol1*=box1max - box1min;\n    vol2*=box2max - box2min;\n  }\n  return overlap / (vol1 + vol2);\n}\n", "docstring": "computes the volume of the overlapping box between two spatialcomparables and return the relation between the volume of the overlapping box and the volume of both spatialcomparable .", "partition": "test"}
{"idx": "1443", "code": "protected void handleAutoDraw(){\n  if (isToolItemSelected(ToolBarItemKey.AUTO_DRAW)) {\n    onAutoDraw();\n  }\n}\n", "docstring": "if auto draw is enabled , a draw request is sent . this method should be invoked when receiving a move and right after sending one . in the future this will become smarter and only draw when the game shows a draw by three times in the same position or 50 move draw rule .", "partition": "test"}
{"idx": "1444", "code": "protected final void _loadToHaveAtLeast(int minAvailable) throws IOException {\n  if (_inputStream == null) {\n    throw _constructError(\"Needed to read \" + minAvailable + \" bytes, reached end-of-input\");\n  }\n  int amount=_inputEnd - _inputPtr;\n  _currInputProcessed+=_inputPtr;\n  if (amount > 0 && _inputPtr > 0) {\n    System.arraycopy(_inputBuffer,_inputPtr,_inputBuffer,0,amount);\n    _inputEnd=amount;\n  }\n else {\n    _inputEnd=0;\n  }\n  _inputPtr=0;\n  while (_inputEnd < minAvailable) {\n    int count=_inputStream.read(_inputBuffer,_inputEnd,_inputBuffer.length - _inputEnd);\n    if (count < 1) {\n      _closeInput();\n      if (count == 0) {\n        throw new IOException(\"InputStream.read() returned 0 characters when trying to read \" + amount + \" bytes\");\n      }\n      throw _constructError(\"Needed to read \" + minAvailable + \" bytes, missed \"+ minAvailable+ \" before end-of-input\");\n    }\n    _inputEnd+=count;\n  }\n}\n", "docstring": "helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary", "partition": "test"}
{"idx": "1445", "code": "public Z21Message(byte[] a,int l){\n  super(String.valueOf(a));\n  setBinary(true);\n}\n", "docstring": "this ctor interprets the byte array as a sequence of characters to send .", "partition": "test"}
{"idx": "1446", "code": "private MethodDescriptor[] sortMethodDescriptors(MethodDescriptor[] methodDescriptors){\n  return methodSorter != null ? methodSorter.sortMethodDescriptors(methodDescriptors) : methodDescriptors;\n}\n", "docstring": "as of this writing , this is only used for testing if method order really doesn \"'\" t mater .", "partition": "test"}
{"idx": "1447", "code": "public static Properties parsePropertyList(String list) throws PropertyStringFormatException {\n  return parsePropertyList(list,propertySeparators,keyValueSeparators);\n}\n", "docstring": "take a property list , defined in a single string , and return a properties object . the properties , as key - value pairs , are separated by another type of symbol . in this method , the key - values are assumed to be separated from other key - value pairs by proputils . propertyseparators string characters , and each key is separated from its value by any character in the proputils . keyvalueseparators list .", "partition": "test"}
{"idx": "1448", "code": "public boolean packageHasAnnotation(Annotation annotation){\n  try {\n    Package pkg=type.getPackage();\n    if (pkg == null) {\n      return false;\n    }\n    String className=pkg.getName() + \".package-info\";\n    Class<?> packageType=Class.forName(className);\n    AnnotationAccessor accessor=new AnnotationAccessor(supportedAnnotations,packageType,ignoreAnnotationFailure);\n    return accessor.typeHas(annotation);\n  }\n catch (  ClassNotFoundException e) {\n    return false;\n  }\n}\n", "docstring": "determines whether the package in which t resides has a particular annotation .", "partition": "test"}
{"idx": "1449", "code": "private String buildToolTip(final CTaggedGraphNodesContainerNode node){\n  final StringBuilder tooltip=new StringBuilder(\"<html>\");\n  boolean first=true;\n  for (  final NaviNode graphnode : node.getGraphNodes()) {\n    if (!first) {\n      tooltip.append(\"<br>\");\n    }\n    tooltip.append(CNodesDisplayString.getDisplayString(graphnode));\n    first=false;\n  }\n  return tooltip + \"</html>\";\n}\n", "docstring": "generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes .", "partition": "test"}
{"idx": "1450", "code": "public void makeGraph(File linkGraph) throws Exception {\n  String temp212;\n  int rowNum=0;\n  BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(linkGraph)));\n  while ((temp212=br.readLine()) != null) {\n    String[] strs=temp212.split(\" \");\n    for (int i=0; i < strs.length; i++) {\n      graph[rowNum][i]=Double.parseDouble(strs[i]);\n    }\n    rowNum++;\n  }\n  for (int i=0; i < dataNum; i++) {\n    for (int j=0; j < dimension; j++) {\n      W[i][j]=r.nextDouble();\n      H[j][i]=r.nextDouble();\n    }\n  }\n  for (int i=0; i < dataNum; i++) {\n    double sumW=0;\n    double sumH=0;\n    for (int j=0; j < dimension; j++) {\n      sumW+=W[i][j] * W[i][j];\n      sumH+=H[j][i] * H[j][i];\n    }\n    sumW=Math.sqrt(sumW);\n    sumH=Math.sqrt(sumH);\n    for (int j=0; j < dimension; j++) {\n      W[i][j]/=sumW;\n      H[j][i]/=sumH;\n    }\n  }\n  trainW();\n  init=false;\n}\n", "docstring": "read in the normalized category file .", "partition": "test"}
{"idx": "1451", "code": "public boolean removeOnItemClickListener(OnItemClickListener itemClickListener){\n  return clickListeners.remove(itemClickListener);\n}\n", "docstring": "remove item click listener from this view", "partition": "test"}
{"idx": "1452", "code": "@Override protected int lookForSelectablePosition(int position,boolean lookDown){\n  final ListAdapter adapter=mAdapter;\n  if (adapter == null || isInTouchMode()) {\n    return INVALID_POSITION;\n  }\n  final int count=adapter.getCount();\n  if (!mAreAllItemsSelectable) {\n    if (lookDown) {\n      position=Math.max(0,position);\n      while (position < count && !adapter.isEnabled(position)) {\n        position++;\n      }\n    }\n else {\n      position=Math.min(position,count - 1);\n      while (position >= 0 && !adapter.isEnabled(position)) {\n        position--;\n      }\n    }\n    if (position < 0 || position >= count) {\n      return INVALID_POSITION;\n    }\n    return position;\n  }\n else {\n    if (position < 0 || position >= count) {\n      return INVALID_POSITION;\n    }\n    return position;\n  }\n}\n", "docstring": "find a position that can be selected ( i . e . , is not a separator ) .", "partition": "test"}
{"idx": "1453", "code": "public static String padRight(final String s,final int length){\n  final int pad=length - s.length();\n  return pad > 0 ? s + getSpaceString(pad) : s;\n}\n", "docstring": "pad a string on the right with spaces till it is at least the specified length .", "partition": "test"}
{"idx": "1454", "code": "private static String[] collationMatchingRuleNames(final List<String> localeNames,final int numSuffix,final String symbolicSuffix){\n  final List<String> names=new ArrayList<>();\n  for (  String localeName : localeNames) {\n    if (symbolicSuffix.isEmpty()) {\n      names.add(localeName);\n    }\n else {\n      names.add(localeName + \".\" + numSuffix);\n      names.add(localeName + \".\" + symbolicSuffix);\n    }\n  }\n  return names.toArray(new String[names.size()]);\n}\n", "docstring": "build the complete list of names for a collation matching rule .", "partition": "test"}
{"idx": "1455", "code": "public static boolean isCacheSafe(Class<?> clazz,ClassLoader classLoader){\n  Assert.notNull(clazz,\"Class must not be null\");\n  ClassLoader target=clazz.getClassLoader();\n  if (target == null) {\n    return false;\n  }\n  ClassLoader cur=classLoader;\n  if (cur == target) {\n    return true;\n  }\n  while (cur != null) {\n    cur=cur.getParent();\n    if (cur == target) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "check whether the given class is cache - safe in the given context , i . e . whether it is loaded by the given classloader or a parent of it .", "partition": "test"}
{"idx": "1456", "code": "public void write(PrintStream out){\n  write(out,table);\n}\n", "docstring": "writes the algorithm \"'\" s internal representation as text .", "partition": "test"}
{"idx": "1457", "code": "private int[] createEpochMonths(int epochDay,int minYear,int maxYear,Map<Integer,int[]> years){\n  int numMonths=(maxYear - minYear + 1) * 12 + 1;\n  int epochMonth=0;\n  int[] epochMonths=new int[numMonths];\n  minMonthLength=Integer.MAX_VALUE;\n  maxMonthLength=Integer.MIN_VALUE;\n  for (int year=minYear; year <= maxYear; year++) {\n    int[] months=years.get(year);\n    for (int month=0; month < 12; month++) {\n      int length=months[month];\n      epochMonths[epochMonth++]=epochDay;\n      if (length < 29 || length > 32) {\n        throw new IllegalArgumentException(\"Invalid month length in year: \" + minYear);\n      }\n      epochDay+=length;\n      minMonthLength=Math.min(minMonthLength,length);\n      maxMonthLength=Math.max(maxMonthLength,length);\n    }\n  }\n  epochMonths[epochMonth++]=epochDay;\n  if (epochMonth != epochMonths.length) {\n    throw new IllegalStateException(\"Did not fill epochMonths exactly: ndx = \" + epochMonth + \" should be \"+ epochMonths.length);\n  }\n  return epochMonths;\n}\n", "docstring": "converts the map of year to month lengths ranging from minyear to maxyear into a linear contiguous array of epochdays . the index is the hijrahmonth computed from year and month and offset by minyear . the value of each entry is the epochday corresponding to the first day of the month .", "partition": "test"}
{"idx": "1458", "code": "private static String descriptorToInternalName(String descriptor){\nswitch (descriptor.charAt(0)) {\ncase \'B\':\ncase \'C\':\ncase \'D\':\ncase \'F\':\ncase \'I\':\ncase \'J\':\ncase \'S\':\ncase \'Z\':\ncase \'V\':\ncase \'[\':\n    return descriptor;\ncase \'L\':\n  return classDescriptorToInternalName(descriptor);\ndefault :\nthrow new IllegalArgumentException(\"bad descriptor:\" + descriptor);\n}\n}\n", "docstring": "convert a non - method type descriptor into an internal type .", "partition": "test"}
{"idx": "1459", "code": "public Subscription register(Object mBean,MBeanDescription description){\n  return register(mBean,description.getMBeanName(getNextId()));\n}\n", "docstring": "register the given mbean based on the given description", "partition": "test"}
{"idx": "1460", "code": "void checkAfterUnmarshalled(){\n  assertEquals(shortVal.shortValue(),0x1122);\n  assertEquals(longVal,0x8877665544332211L);\n  assertNull(aArr);\n  assertNull(strVal);\n  assertEquals(doubleVal,123.456);\n}\n", "docstring": "checks correctness of the state after unmarshalling .", "partition": "test"}
{"idx": "1461", "code": "@Override public <R>CompletableFuture<R> collect(final Supplier<R> supplier,final BiConsumer<R,? super T> accumulator,final BiConsumer<R,R> combiner){\n  return CompletableFuture.supplyAsync(null,exec);\n}\n", "docstring": "asynchronously perform a stream collection", "partition": "test"}
{"idx": "1462", "code": "@SuppressWarnings(\"unchecked\") protected Object fromReflectionType(final Object value){\n  FieldDescriptor descriptor=getDescriptor();\n  if (descriptor.isRepeated()) {\n    if (descriptor.getJavaType() == FieldDescriptor.JavaType.MESSAGE || descriptor.getJavaType() == FieldDescriptor.JavaType.ENUM) {\n      final List result=new ArrayList();\n      for (      final Object element : (List)value) {\n        result.add(singularFromReflectionType(element));\n      }\n      return result;\n    }\n else {\n      return value;\n    }\n  }\n else {\n    return singularFromReflectionType(value);\n  }\n}\n", "docstring": "convert from the type used by the reflection accessors to the type used by native accessors . e . g . , for enums , the reflection accessors use enumvaluedescriptors but the native accessors use the generated enum type .", "partition": "test"}
{"idx": "1463", "code": "public void registerManufacturerSpecificBuilder(int companyId,ADManufacturerSpecificBuilder builder){\n  if (companyId < 0 || 0xFFFF < companyId) {\n    String message=String.format(\"\'companyId\' is out of the valid range: %d\",companyId);\n    throw new IllegalArgumentException(message);\n  }\n  if (builder == null) {\n    return;\n  }\n  Integer key=Integer.valueOf(companyId);\n  List<ADManufacturerSpecificBuilder> builders=mMSBuilders.get(key);\n  if (builders == null) {\n    builders=new ArrayList<ADManufacturerSpecificBuilder>();\n    mMSBuilders.put(key,builders);\n  }\n  builders.add(0,builder);\n}\n", "docstring": "register a builder for the company id . the given builder is added at the beginning of the list of the builders for the company id .", "partition": "test"}
{"idx": "1464", "code": "public static ReilGraph copyReilCode(final Window parent,final INaviCodeNode node){\n  final ReilTranslator<INaviInstruction> translator=new ReilTranslator<INaviInstruction>();\n  try {\n    return translator.translate(new StandardEnvironment(),node);\n  }\n catch (  final InternalTranslationException e) {\n    CUtilityFunctions.logException(e);\n    final String message=\"E000XXX: \" + \"Could not show REIL code for node\";\n    final String description=CUtilityFunctions.createDescription(String.format(\"BinNavi could not show the REIL code for basic block at \'%X\'.\",node.getAddress()),new String[]{\"The instructions could not be converted to REIL code.\"},new String[]{\"You can not fix this problem yourself. Please contact \" + \"the BinNavi support.\"});\n    NaviErrorDialog.show(parent,message,description,e);\n  }\n  return null;\n}\n", "docstring": "copy reil code for node", "partition": "test"}
{"idx": "1465", "code": "public static String toString(Reader reader,long timeout) throws IOException {\n  StringWriter sw=new StringWriter(512);\n  copy(toBufferedReader(reader),sw,timeout);\n  sw.close();\n  return sw.toString();\n}\n", "docstring": "reads string data from a reader", "partition": "test"}
{"idx": "1466", "code": "private static float computeSimilarity(Lane a,Lane b){\n  int same=0;\n  int diff=0;\n  int firstCoordinate=Math.max(a.getFirstNonGapPosition(),b.getFirstNonGapPosition());\n  int lastCoordinate=Math.min(a.getLastNonGapPosition(),b.getLastNonGapPosition());\n  for (int i=firstCoordinate; i <= lastCoordinate; i++) {\n    char cha=a.charAt(i);\n    char chb=b.charAt(i);\n    if (Character.isLetter(cha) && Character.isLetter(chb)) {\n      if (Character.toLowerCase(cha) == Character.toLowerCase((chb)))       same++;\n else       diff++;\n    }\n  }\n  return Math.max(same > 0 ? 1 : 0,same - 3 * diff);\n}\n", "docstring": "computes the similarity of two sequences", "partition": "test"}
{"idx": "1467", "code": "private void forceOverflow(){\n  forceOverflow();\n}\n", "docstring": "gratuitous and stupid recursion", "partition": "test"}
{"idx": "1468", "code": "public String prepOperand(String label,DataType dt,ValueType vt,boolean literal){\n  StringBuilder sb=new StringBuilder();\n  sb.append(label);\n  sb.append(Lop.DATATYPE_PREFIX);\n  sb.append(dt);\n  sb.append(Lop.VALUETYPE_PREFIX);\n  sb.append(vt);\n  sb.append(Lop.LITERAL_PREFIX);\n  sb.append(literal);\n  return sb.toString();\n}\n", "docstring": "method to prepare instruction operand with given parameters .", "partition": "test"}
{"idx": "1469", "code": "public static List<SpaceTime> divideConquerBrownianBridge(MultivariateNormalDistribution normal,SpaceTime start,SpaceTime end,int depth,int maxTries,SpaceTimeRejector rejector){\n  List<SpaceTime> points=new LinkedList<SpaceTime>();\n  points.add(start);\n  points.add(end);\n  stop=false;\n  if (divideConquerBrownianBridge(normal,0,points,depth,maxTries,rejector) == (2 << (depth - 1))) {\n    return points;\n  }\n  stop=false;\n  return null;\n}\n", "docstring": "divide and conquer brownian bridge ; not thread - safe ! ! ! ! !", "partition": "test"}
{"idx": "1470", "code": "public static EjbJarXmlVersion valueOf(DocumentType docType) throws NullPointerException {\n  return valueOf(docType.getPublicId());\n}\n", "docstring": "returns the version corresponding to the given document type .", "partition": "test"}
{"idx": "1471", "code": "public static List<Double> mergeCoords(List<Double> x,List<Double> y){\n  if (x.size() != y.size())   throw new IllegalArgumentException(\"Sample sizes must be the same for each data applyTransformToDestination.\");\n  List<Double> ret=new ArrayList<>();\n  for (int i=0; i < x.size(); i++) {\n    ret.add(x.get(i));\n    ret.add(y.get(i));\n  }\n  return ret;\n}\n", "docstring": "this will merge the coordinates of the given coordinate system .", "partition": "test"}
{"idx": "1472", "code": "public void copyText(){\n  int end, start;\n  end=selectedCharField.getSelectionEnd();\n  start=selectedCharField.getSelectionStart();\n  selectedCharField.selectAll();\n  selectedCharField.copy();\n  selectedCharField.select(start,end);\n}\n", "docstring": "copy text . copy all sample text to the system clipboard . remember the current caret position ( selection ) and restore that afterwards .", "partition": "test"}
{"idx": "1473", "code": "public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    AuthPropertiesModel model=(AuthPropertiesModel)getModel();\n    Map original=model.getValues();\n    AMPropertySheet ps=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n    model.setValues(ps.getAttributeValues(original,true,model));\n    setInlineAlertMessage(CCAlert.TYPE_INFO,\"message.information\",\"authentication.profile.updated\");\n  }\n catch (  AMConsoleException a) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",a.getMessage());\n  }\n  forwardTo();\n}\n", "docstring": "handles save button request .", "partition": "test"}
{"idx": "1474", "code": "private void buildDescriptionPanel(final Composite parent){\n  descriptionLabel=new StyledText(parent,SWT.READ_ONLY);\n  descriptionLabel.setText(\"\");\n  descriptionLabel.setLayoutData(new GridData(GridData.FILL,GridData.FILL,true,true,1,1));\n}\n", "docstring": "build the description panel", "partition": "test"}
{"idx": "1475", "code": "public HttpMethodClient(){\n  this(5000,10000,3 * 60000);\n}\n", "docstring": "creates a new http method client with default timeouts .", "partition": "test"}
{"idx": "1476", "code": "public ISO9796d2PSSSigner(AsymmetricBlockCipher cipher,Digest digest,int saltLength,boolean implicit){\n  this.cipher=cipher;\n  this.digest=digest;\n  this.hLen=digest.getDigestSize();\n  this.saltLength=saltLength;\n  if (implicit) {\n    trailer=TRAILER_IMPLICIT;\n  }\n else {\n    Integer trailerObj=(Integer)trailerMap.get(digest.getAlgorithmName());\n    if (trailerObj != null) {\n      trailer=trailerObj.intValue();\n    }\n else {\n      throw new IllegalArgumentException(\"no valid trailer for digest\");\n    }\n  }\n}\n", "docstring": "generate a signer for the with either implicit or explicit trailers for iso9796 - 2 , scheme 2 or 3 .", "partition": "test"}
{"idx": "1477", "code": "String decodeTextValue(byte[] data) throws IOException {\n  boolean isCompressed=((data.length > 1) && (data[0] == TEXT_COMPRESSION_HEADER[0]) && (data[1] == TEXT_COMPRESSION_HEADER[1]));\n  if (isCompressed) {\n    StringBuilder textBuf=new StringBuilder(data.length);\n    int dataStart=TEXT_COMPRESSION_HEADER.length;\n    int dataEnd=dataStart;\n    boolean inCompressedMode=true;\n    while (dataEnd < data.length) {\n      if (data[dataEnd] == (byte)0x00) {\n        decodeTextSegment(data,dataStart,dataEnd,inCompressedMode,textBuf);\n        inCompressedMode=!inCompressedMode;\n        ++dataEnd;\n        dataStart=dataEnd;\n      }\n else {\n        ++dataEnd;\n      }\n    }\n    decodeTextSegment(data,dataStart,dataEnd,inCompressedMode,textBuf);\n    return textBuf.toString();\n  }\n  return decodeUncompressedText(data,getCharset());\n}\n", "docstring": "decodes a compressed or uncompressed text value .", "partition": "test"}
{"idx": "1478", "code": "private <S,T>Set<T> extract(final Collection<S> collection,final Extractor<S,T> extractor){\n  final Set<T> values=new HashSet<T>(collection.size());\n  for (  final S instance : collection) {\n    values.add(extractor.getValue(instance));\n  }\n  return values;\n}\n", "docstring": "extract a set of a defined type from the passed collection using the given extractor .", "partition": "test"}
{"idx": "1479", "code": "public static boolean isZTE(){\n  return sBuildModel.startsWith(\"zte\");\n}\n", "docstring": "whether the stack is running on a zte device", "partition": "test"}
{"idx": "1480", "code": "static public String normalizeToEncoding(String origString_,Charset encoding_){\n  String normString=origString_;\n  CharsetEncoder encoder=encoding_.newEncoder();\n  if (!encoder.canEncode(origString_)) {\n    final int length=origString_.length();\n    char[] normSeq=new char[(origString_.length())];\n    int charNum=0;\n    for (int offset=0; offset < length; ) {\n      Pair<Character,Integer> replacement=normalizeCodepoint(origString_,encoding_,offset);\n      Character replacedChar=replacement.getFirst();\n      int codepoint=replacement.getSecond();\n      if (null != replacedChar) {\n        normSeq[charNum]=replacedChar;\n        charNum++;\n      }\n      offset+=Character.charCount(codepoint);\n    }\n    normString=new String(normSeq);\n  }\n  return normString;\n}\n", "docstring": "tries to normalize string to specified encoding . the number of characters returned should be the same , and tokens should remain contiguous in the output ; non - recognized characters will be substituted for * something * .", "partition": "test"}
{"idx": "1481", "code": "private FastConcurrentSkipListMap.Node<K,V> loNode(){\n  if (lo == null)   return m.findFirst();\n else   if (loInclusive)   return m.findNear(lo,m.GT | m.EQ);\n else   return m.findNear(lo,m.GT);\n}\n", "docstring": "returns lowest node . this node might not be in range , so most usages need to check bounds", "partition": "test"}
{"idx": "1482", "code": "public int size(){\n  return m_sets.size();\n}\n", "docstring": "get the number of item sets .", "partition": "test"}
{"idx": "1483", "code": "public static float approximateLength(float controlPoints[][]){\n  float length=0;\n  for (int i=0; i < controlPoints.length - 1; i++) {\n    float xDif=controlPoints[i + 1][0] - controlPoints[i][0];\n    float yDif=controlPoints[i + 1][1] - controlPoints[i][1];\n    float zDif=controlPoints[i + 1][2] - controlPoints[i][2];\n    length+=Math.sqrt(xDif * xDif + yDif * yDif + zDif * zDif);\n  }\n  return length;\n}\n", "docstring": "compute an approximate length of a bezier curve given the control points .", "partition": "test"}
{"idx": "1484", "code": "protected int mapDragOperationFromModifiers(MouseEvent e){\n  int mods=e.getModifiersEx();\n  int btns=mods & ButtonMask;\n  if (!(btns == InputEvent.BUTTON1_DOWN_MASK || btns == InputEvent.BUTTON2_DOWN_MASK)) {\n    return DnDConstants.ACTION_NONE;\n  }\n  return SunDragSourceContextPeer.convertModifiersToDropAction(mods,getSourceActions());\n}\n", "docstring": "determine the drop action from the event", "partition": "test"}
{"idx": "1485", "code": "public UpdateClause addAssignment(Expression expression){\n  assignments.add(new Assignment(expression));\n  return this;\n}\n", "docstring": "adds a property to set to the clause .", "partition": "test"}
{"idx": "1486", "code": "private ArrayList<IconMarker> createIconMarkers(){\n  final ArrayList<IconMarker> iconMarkers=new ArrayList<>(LOCATIONS.length);\n  iconMarkers.add(new IconMarker(LOCATIONS[0],R.drawable.bread,R.drawable.bread_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[1],R.drawable.butcher,R.drawable.butcher_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[2],R.drawable.fruits,R.drawable.fruits_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[3],R.drawable.grocery,R.drawable.grocery_c));\n  iconMarkers.add(new IconMarker(LOCATIONS[4],R.drawable.patisserie,R.drawable.patisserie_c));\n  return iconMarkers;\n}\n", "docstring": "icons courtesy of https : / / mapicons . mapsmarker . com /", "partition": "test"}
{"idx": "1487", "code": "public void hasNetworkConnection(NetworkRequestCheckListener listener){\n  if (hasNetworkConnection()) {\n    testNetworkRequest(listener);\n  }\n else {\n    listener.onNoResponse();\n  }\n}\n", "docstring": "utility method which checks current network connection state , but will also try to perform test network request , in order to determine if user can actually perform any network operation .", "partition": "test"}
{"idx": "1488", "code": "public void assignThreadForSubscriber(@NonNull Object subscriber){\n  Looper looper=Looper.myLooper();\n  if (looper != null) {\n    mSubscribersDefaultThreads.put(new IdentityWeakReferenceKey<>(subscriber),looper != Looper.getMainLooper() ? new Handler(looper) : mUiThreadHandler);\n  }\n else {\n    mSubscribersDefaultThreads.remove(new IdentityWeakReferenceKey<>(subscriber));\n  }\n}\n", "docstring": "assign current thread to the subscriber object . to make it work , the thread have to have a looper ( looper . mylooper ( ) ! = null ) . if current thread have no looper , all event handlers marked with deliver_in_default_thread , it will be executed as deliver_in_background_thread . < p / > this method can be used to re - assign the default thread for already registered object .", "partition": "test"}
{"idx": "1489", "code": "private void validateDynamicAttribute(Set dynamicSet) throws PolicyException {\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"entering with dynamicSet=\" + dynamicSet);\n  }\n  responseAttrNames=new HashSet();\n  repoAttrNames=new HashSet();\n  responseAttrToRepoAttr=new HashMap();\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"valid dynamic attributes:\" + validDynamicAttrNames);\n  }\n  Set dynamicAttrs=((Set)properties.get(DYNAMIC_ATTRIBUTE));\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"selected dynamic attributes:\" + dynamicAttrs);\n  }\n  Iterator dynamicAttrsIter=dynamicAttrs.iterator();\n  while (dynamicAttrsIter.hasNext()) {\n    String attr=(String)dynamicAttrsIter.next();\n    if (!validDynamicAttrNames.contains(attr)) {\n      if (DEBUG.warningEnabled()) {\n        DEBUG.warning(\"IDReporesponseProvider.\" + \"validateDynamicAttribute():Invalid dynamic property \" + \"encountered:\"+ attr);\n      }\n      continue;\n    }\n    String[] attrNames=parseDynamicAttrName(attr);\n    String responseAttrName=attrNames[0];\n    String repoAttrName=attrNames[1];\n    responseAttrNames.add(responseAttrName);\n    repoAttrNames.add(repoAttrName);\n    addToResponseAttrToRepoAttrMap(responseAttrName,repoAttrName);\n    if (DEBUG.messageEnabled()) {\n      DEBUG.message(\"IDRepoResponseProvider.\" + \"validateDynamicAttribute():\" + \"responseAttrName=\" + responseAttrName + \", repoAttrName=\"+ repoAttrName);\n    }\n  }\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"responseAttrToRepoAttr=\" + responseAttrToRepoAttr);\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"returning\");\n  }\n}\n", "docstring": "this method validates the dynamic_attribute data for format and caches parsed responseattrnames , repoattrnames strings in the set need to be in \" responseattr = repoattr \" format else , throws policyexception", "partition": "test"}
{"idx": "1490", "code": "public synchronized void init(){\n  ArrayList<Warrant> tempList=new ArrayList<Warrant>();\n  List<String> systemNameList=_manager.getSystemNameList();\n  Iterator<String> iter=systemNameList.iterator();\n  while (iter.hasNext()) {\n    Warrant w=_manager.getBySystemName(iter.next());\n    if (!_warList.contains(w)) {\n      w.addPropertyChangeListener(this);\n    }\n else {\n      _warList.remove(w);\n    }\n    tempList.add(w);\n  }\n  for (int i=0; i < _warList.size(); i++) {\n    Warrant w=_warList.get(i);\n    if (!_warNX.contains(w)) {\n      w.removePropertyChangeListener(this);\n    }\n  }\n  for (int i=0; i < _warNX.size(); i++) {\n    tempList.add(_warNX.get(i));\n  }\n  _warList=tempList;\n}\n", "docstring": "preserve current listeners so that there is no gap to miss a propertychange", "partition": "test"}
{"idx": "1491", "code": "public void addCommand(Command cmd,int offset){\n  menuBar.addCommand(cmd,offset);\n}\n", "docstring": "adds a command to the menu bar softkeys or into the menu dialog , this version of add allows us to place a command in an arbitrary location . this allows us to force a command into the softkeys when order of command addition can \"'\" t be changed .", "partition": "test"}
{"idx": "1492", "code": "public boolean connect(final String address){\n  if (mBluetoothAdapter == null || address == null) {\n    Log.w(TAG,\"BluetoothAdapter not initialized or unspecified address.\");\n    return false;\n  }\n  if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress) && mBluetoothGatt != null) {\n    Log.d(TAG,\"Trying to use an existing mBluetoothGatt for connection.\");\n    if (mBluetoothGatt.connect()) {\n      mConnectionState=STATE_CONNECTING;\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n  final BluetoothDevice device=mBluetoothAdapter.getRemoteDevice(address);\n  if (device == null) {\n    Log.w(TAG,\"Device not found.  Unable to connect.\");\n    return false;\n  }\n  mBluetoothGatt=device.connectGatt(this,false,mGattCallback);\n  Log.d(TAG,\"Trying to create a new connection.\");\n  mBluetoothDeviceAddress=address;\n  mConnectionState=STATE_CONNECTING;\n  return true;\n}\n", "docstring": "connects to the gatt server hosted on the bluetooth le device .", "partition": "test"}
{"idx": "1493", "code": "private double normalDens(double x,double mean,double stdDev){\n  double diff=x - mean;\n  return (1 / (m_normConst * stdDev)) * Math.exp(-(diff * diff / (2 * stdDev * stdDev)));\n}\n", "docstring": "density function of normal distribution .", "partition": "test"}
{"idx": "1494", "code": "private static void drawShape(GL2 gl,Shape s){\n  PathIterator it=s.getPathIterator(new AffineTransform(),shapeFlatness);\n  float[] lastMoveTo=new float[6];\n  float[] f=new float[6];\n  while (!it.isDone()) {\n    int res=it.currentSegment(f);\nswitch (res) {\ncase PathIterator.SEG_CLOSE:\n      GLPanel.V(gl,lastMoveTo[0],lastMoveTo[1]);\n    break;\ncase PathIterator.SEG_MOVETO:\n  GLPanel.V(gl,f[0],f[1]);\nSystem.arraycopy(f,0,lastMoveTo,0,6);\nbreak;\ncase PathIterator.SEG_LINETO:\nGLPanel.V(gl,f[0],f[1]);\nbreak;\ncase PathIterator.SEG_CUBICTO:\nCubicCurve2D c=new CubicCurve2D.Float(lastMoveTo[0],lastMoveTo[1],f[0],f[1],f[2],f[3],f[4],f[5]);\ndrawShape(gl,c);\nbreak;\ndefault :\nthrow new Error(\"Error while drawing AWT shape. \" + \"Path iterator setment not handled:\" + res);\n}\nit.next();\n}\n}\n", "docstring": "draw the given shape on the given opengl object .", "partition": "test"}
{"idx": "1495", "code": "@Override protected void tearDown() throws NamingException, JMSException {\n  NamingEnumeration<Binding> iter=context.listBindings(\"\");\n  while (iter.hasMore()) {\n    Binding binding=iter.next();\n    Object connFactory=binding.getObject();\n    if (connFactory instanceof ActiveMQConnectionFactory) {\n    }\n  }\n}\n", "docstring": "stops all existing activemqconnectionfactory in context .", "partition": "test"}
{"idx": "1496", "code": "protected List<URI> load(final InputStream in) throws SAXException, IOException {\n  SAXParser saxParser;\n  final SAXParserFactory factory=SAXParserFactory.newInstance();\n  try {\n    saxParser=factory.newSAXParser();\n  }\n catch (  final ParserConfigurationException ex) {\n    throw new SAXException(ex);\n  }\n  groups=new LinkedList<URI>();\n  saxParser.parse(in,this);\n  return groups;\n}\n", "docstring": "load and returns the list of files .", "partition": "test"}
{"idx": "1497", "code": "@Deprecated public static String Collection2String(Collection<?> in,String separator){\n  if (in == null) {\n    return null;\n  }\n  return Iterator2String(in.iterator(),separator);\n}\n", "docstring": "this concatenates the elements of a collection in a string", "partition": "test"}
{"idx": "1498", "code": "public static byte[] decodeBase64(String base64Str){\n  return DatatypeConverter.parseBase64Binary(base64Str);\n}\n", "docstring": "decodes a base 64 encoded string into byte array .", "partition": "test"}
{"idx": "1499", "code": "protected void removeAllPremoveDrops(){\n  for (  PremoveInfo info : premoves.toArray(new PremoveInfo[0])) {\n    if (info.isPremoveDrop) {\n      premoves.remove(info);\n    }\n  }\n}\n", "docstring": "removes all of the premove drops from premoves .", "partition": "test"}
{"idx": "1500", "code": "public static String sayNumber(StringBuffer appendTo,double number) throws IllegalArgumentException {\n  if (number == Double.MIN_VALUE) {\n    throw new IllegalArgumentException(\"Out of range\");\n  }\n  if (number < 0) {\n    appendTo.append(\"Minus \");\n  }\n  double abs=Math.abs(number);\n  if (abs < POWER_THREE) {\n    saySimpleNumber(appendTo,(int)abs);\n  }\n else   if (abs < 2000) {\n    int thousand=(int)(abs % POWER_THREE);\n    appendTo.append(\"Seribu \");\n    saySimpleNumber(appendTo,thousand);\n  }\n else   if (abs < POWER_SIX) {\n    int thousand=(int)(abs % POWER_SIX / POWER_THREE);\n    saySimpleNumber(appendTo,thousand);\n    appendTo.append(\" Ribu\");\n    double remainder=abs - thousand * POWER_THREE;\n    if (remainder > 0) {\n      appendTo.append(\' \');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else   if (abs < POWER_NINE) {\n    int million=(int)(abs % POWER_NINE / POWER_SIX);\n    saySimpleNumber(appendTo,million);\n    appendTo.append(\" Juta\");\n    double remainder=abs - million * POWER_SIX;\n    if (remainder > 0) {\n      appendTo.append(\' \');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else   if (abs < POWER_TWELVE) {\n    int billion=(int)(abs % POWER_TWELVE / POWER_NINE);\n    saySimpleNumber(appendTo,billion);\n    appendTo.append(\" Milyar\");\n    double remainder=abs - billion * POWER_NINE;\n    if (remainder > 0) {\n      appendTo.append(\' \');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else   if (abs < POWER_FIFTEEN) {\n    int trillion=(int)(abs % POWER_FIFTEEN / POWER_TWELVE);\n    saySimpleNumber(appendTo,trillion);\n    appendTo.append(\" Trilyun\");\n    double remainder=abs - trillion * POWER_TWELVE;\n    if (remainder > 0) {\n      appendTo.append(\' \');\n      sayNumber(appendTo,remainder);\n    }\n  }\n else {\n    appendTo.append(\"Lebih Dari Seribu Triliun\");\n  }\n  return appendTo.toString();\n}\n", "docstring": "say a number . this method will append the result to the given string buffer .", "partition": "test"}
{"idx": "1501", "code": "public void stop(){\n  _throttle.setSpeedSetting(-0.5F);\n  _throttle.setSpeedSetting(0.0F);\n  stopLabel.setIcon(stopIcon);\n  stopLabel.setIconTextGap(_gap);\n  pack();\n}\n", "docstring": "perform an emergency stop", "partition": "test"}
{"idx": "1502", "code": "public void makeDirty(){\n  betaChanged=true;\n  newMode=true;\n  precisionChanged=true;\n  regressionInterface.makeDirty(instance);\n}\n", "docstring": "forces a complete recalculation of the likelihood next time getlikelihood is called", "partition": "test"}
{"idx": "1503", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(3);\n  newVector.addElement(new Option(\"\\tSets the attribute index.\",\"C\",1,\"-C <col>\"));\n  newVector.addElement(new Option(\"\\tSpecify the list of values to indicate. First and last are\\n\" + \"\\tvalid indexes (default last)\",\"V\",1,\"-V <index1,index2-index4,...>\"));\n  newVector.addElement(new Option(\"\\tSet if new boolean attribute nominal.\",\"N\",0,\"-N <index>\"));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "1504", "code": "private List<String> split(String prefix){\n  List<String> parts=new ArrayList<String>();\n  int bracketCount=0;\n  boolean inquotes=false;\n  int lastIndex=0;\n  for (int i=0; i < prefix.length(); i++) {\n    char c=prefix.charAt(i);\n    if (c == \'[\') {\n      bracketCount++;\n      continue;\n    }\n else     if (c == \'\"\') {\n      inquotes=!inquotes;\n      continue;\n    }\n else     if (c == \']\') {\n      bracketCount--;\n      if (bracketCount < 0) {\n        throw new RuntimeException(\"Malformed prefix: \" + prefix);\n      }\n      continue;\n    }\n    if (c == \':\' && !inquotes && bracketCount == 0) {\n      parts.add(prefix.substring(lastIndex,i));\n      lastIndex=i + 1;\n    }\n  }\n  if (lastIndex < prefix.length() - 1 && !inquotes && bracketCount == 0) {\n    parts.add(prefix.substring(lastIndex));\n  }\n  return parts;\n}\n", "docstring": "given some dot separated prefix , split on the colons that are not within quotes , and not within brackets .", "partition": "test"}
{"idx": "1505", "code": "public static long lowerHexToUnsignedLong(String lowerHex){\n  int length=lowerHex.length();\n  if (length < 1 || length > 32)   throw isntLowerHexLong(lowerHex);\n  int i=length > 16 ? length - 16 : 0;\n  long result=0;\n  for (; i < length; i++) {\n    char c=lowerHex.charAt(i);\n    result<<=4;\n    if (c >= '0' && c <= '9') {\n      result|=c - '0';\n    }\n else     if (c >= 'a' && c <= 'f') {\n      result|=c - 'a' + 10;\n    }\n else {\n      throw isntLowerHexLong(lowerHex);\n    }\n  }\n  return result;\n}\n", "docstring": "parses a 1 to 32 character lower - hex string with no prefix into an unsigned long , tossing any bits higher than 64 .", "partition": "test"}
{"idx": "1506", "code": "public static double sampleSkewStandardError(int size){\n  int n=size;\n  return Math.sqrt(6.0 * n * (n - 1) / ((n - 2) * (n + 1) * (n + 3)));\n}\n", "docstring": "return the standard error of the sample skew . ref : r . r . sokal , f . j . rohlf , biometry : the principles and practice of statistics in biological research ( w . h . freeman and company , new york , 1998 , 3rd edition ) p . 138 .", "partition": "test"}
{"idx": "1507", "code": "public void load(List<PolicyQualifierInfo> policyQualifierInfo){\n  PolicyQualifierInfo[] policyQualifierInfoArray=policyQualifierInfo.toArray(new PolicyQualifierInfo[policyQualifierInfo.size()]);\n  Arrays.sort(policyQualifierInfoArray,new PolicyQualifierInfoComparator());\n  data=new Object[policyQualifierInfoArray.length][1];\n  int i=0;\n  for (  PolicyQualifierInfo policyQualInfo : policyQualifierInfoArray) {\n    data[i][0]=policyQualInfo;\n    i++;\n  }\n  fireTableDataChanged();\n}\n", "docstring": "load the policyqualifierinfotablemodel with policy qualifier info .", "partition": "test"}
{"idx": "1508", "code": "public void runScript(Reader reader) throws IOException, SQLException {\n  try {\n    boolean originalAutoCommit=connection.getAutoCommit();\n    try {\n      if (originalAutoCommit != this.autoCommit) {\n        connection.setAutoCommit(this.autoCommit);\n      }\n      runScript(connection,reader);\n    }\n  finally {\n      connection.setAutoCommit(originalAutoCommit);\n    }\n  }\n catch (  IOException|SQLException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error running script.  Cause: \" + e,e);\n  }\n}\n", "docstring": "runs an sql script ( read in using the reader parameter )", "partition": "test"}
{"idx": "1509", "code": "public double doOperation() throws OperatorFailedException {\n  double logq;\n  final NodeRef root=tree.getRoot();\n  final double oldTreeHeight=tree.getNodeHeight(root);\n  NodeRef i;\n  do {\n    i=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n  }\n while (root == i);\n  final NodeRef iP=tree.getParent(i);\n  final NodeRef CiP=getOtherChild(tree,iP,i);\n  final NodeRef PiP=tree.getParent(iP);\n  final double delta=getDelta();\n  final double oldHeight=tree.getNodeHeight(iP);\n  final double newHeight=oldHeight + delta;\n  if (delta > 0) {\n    if (PiP != null && tree.getNodeHeight(PiP) < newHeight) {\n      NodeRef newParent=PiP;\n      NodeRef newChild=iP;\n      while (tree.getNodeHeight(newParent) < newHeight) {\n        newChild=newParent;\n        newParent=tree.getParent(newParent);\n        if (newParent == null)         break;\n      }\n      tree.beginTreeEdit();\n      if (tree.isRoot(newChild)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.setRoot(iP);\n        if (tree.hasNodeTraits()) {\n          tree.swapAllTraits(newChild,iP);\n        }\n        if (tree.hasRates()) {\n          final double rootNodeRate=tree.getNodeRate(newChild);\n          tree.setNodeRate(newChild,tree.getNodeRate(iP));\n          tree.setNodeRate(iP,rootNodeRate);\n        }\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      final int possibleSources=intersectingEdges(tree,newChild,oldHeight,null);\n      logq=-Math.log(possibleSources);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logq=0.0;\n    }\n  }\n else {\n    if (tree.getNodeHeight(i) > newHeight) {\n      return Double.NEGATIVE_INFINITY;\n    }\n    if (tree.getNodeHeight(CiP) > newHeight) {\n      List<NodeRef> newChildren=new ArrayList<NodeRef>();\n      final int possibleDestinations=intersectingEdges(tree,CiP,newHeight,newChildren);\n      if (newChildren.size() == 0) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      final int childIndex=MathUtils.nextInt(newChildren.size());\n      NodeRef newChild=newChildren.get(childIndex);\n      NodeRef newParent=tree.getParent(newChild);\n      tree.beginTreeEdit();\n      if (tree.isRoot(iP)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(newParent,iP);\n        tree.setRoot(CiP);\n        if (tree.hasNodeTraits()) {\n          tree.swapAllTraits(iP,CiP);\n        }\n        if (tree.hasRates()) {\n          final double rootNodeRate=tree.getNodeRate(iP);\n          tree.setNodeRate(iP,tree.getNodeRate(CiP));\n          tree.setNodeRate(CiP,rootNodeRate);\n        }\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      logq=Math.log(possibleDestinations);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logq=0.0;\n    }\n  }\n  if (swapInRandomRate) {\n    final NodeRef j=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n    if (j != i) {\n      final double tmp=tree.getNodeRate(i);\n      tree.setNodeRate(i,tree.getNodeRate(j));\n      tree.setNodeRate(j,tmp);\n    }\n  }\n  if (swapInRandomTrait) {\n    final NodeRef j=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n    if (j != i) {\n      tree.swapAllTraits(i,j);\n    }\n  }\n  if (logq == Double.NEGATIVE_INFINITY)   throw new OperatorFailedException(\"invalid slide\");\n  if (scaledDirichletBranches) {\n    if (oldTreeHeight != tree.getNodeHeight(tree.getRoot()))     throw new OperatorFailedException(\"Temporarily disabled.\");\n  }\n  return logq;\n}\n", "docstring": "do a probablistic subtree slide move .", "partition": "test"}
{"idx": "1510", "code": "MarkerSegment findMarkerSegment(Class cls,boolean first){\n  if (first) {\n    Iterator iter=markerSequence.iterator();\n    while (iter.hasNext()) {\n      MarkerSegment seg=(MarkerSegment)iter.next();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n else {\n    ListIterator iter=markerSequence.listIterator(markerSequence.size());\n    while (iter.hasPrevious()) {\n      MarkerSegment seg=(MarkerSegment)iter.previous();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "returns the first or last markersegment object in the list of the given class , or null if none is found .", "partition": "test"}
{"idx": "1511", "code": "default Filterable<T> removeAll(final T... values){\n  return removeAll(Stream.of(values));\n}\n", "docstring": "remove all supplied elements from this filterable", "partition": "test"}
{"idx": "1512", "code": "public void reset(boolean clear){\n  gotVersion=false;\n  gotHeaderLength=false;\n  gotHeader=false;\n  gotBody=false;\n  gotBodyBoundary=false;\n  headerLength=0;\n  bodyLength=0;\n  bodyBytesReceived=0;\n  if (clear) {\n    bufferOffset=0;\n    buffer.clear();\n    bodyFile=null;\n    if (bodyStream != null) {\n      try {\n        bodyStream.close();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n      bodyStream=null;\n    }\n  }\n}\n", "docstring": "reset the state of the receiver in preparation for a new sessionmessage .", "partition": "test"}
{"idx": "1513", "code": "private void saveAndClose(boolean save){\n  content.setEnabled(false);\n  if (timer != null) {\n    timer.cancel();\n    timer=null;\n  }\n  if (timerNextSync != null) {\n    timerNextSync.cancel();\n    timerNextSync=null;\n  }\n  if (save) {\n    Log.d(LOG_TAG,\"saveAndClose with SAVE\");\n    saveData(null);\n  }\n else {\n    Log.d(LOG_TAG,\"saveAndClose WITHOUT save\");\n  }\n  Intent data=new Intent();\n  data.setAction(Intent.ACTION_VIEW);\n  data.putExtra(PARAM_NOTE,note);\n  data.putExtra(PARAM_NOTE_POSITION,notePosition);\n  setResult(RESULT_OK,data);\n  finish();\n}\n", "docstring": "saves all changes and closes the activity", "partition": "test"}
{"idx": "1514", "code": "public static Uri addMessage(ContentResolver resolver,String address,String body,String subject,Long date,boolean deliveryReport,long threadId){\n  final Uri CONTENT_URI=Uri.parse(\"content://sms/outbox\");\n  return addMessageToUri(resolver,CONTENT_URI,address,body,subject,date,true,deliveryReport,threadId);\n}\n", "docstring": "add an sms to the out box .", "partition": "test"}
{"idx": "1515", "code": "public static final double calcNiceNumber(final double RANGE,final boolean ROUND){\n  double niceFraction;\n  double exponent=Math.floor(Math.log10(RANGE));\n  double fraction=RANGE / Math.pow(10,exponent);\n  if (ROUND) {\n    if (Double.compare(fraction,1.5) < 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,3) < 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,7) < 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n else {\n    if (Double.compare(fraction,1) <= 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,2) <= 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,5) <= 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n  return niceFraction * Math.pow(10,exponent);\n}\n", "docstring": "returns a \" nicescaling \" number approximately equal to the range . rounds the number if round = = true . takes the ceiling if round = false .", "partition": "test"}
{"idx": "1516", "code": "private final Object internalReplace(Object k,Object v,Object cv){\n  int h=spread(k.hashCode());\n  Object oldVal=null;\n  for (Node[] tab=table; ; ) {\n    Node f;\n    int i, fh;\n    Object fk;\n    if (tab == null || (f=tabAt(tab,i=(tab.length - 1) & h)) == null)     break;\n else     if ((fh=f.hash) == MOVED) {\n      if ((fk=f.key) instanceof TreeBin) {\n        TreeBin t=(TreeBin)fk;\n        boolean validated=false;\n        boolean deleted=false;\n        t.acquire(0);\n        try {\n          if (tabAt(tab,i) == f) {\n            validated=true;\n            TreeNode p=t.getTreeNode(h,k,t.root);\n            if (p != null) {\n              Object pv=p.val;\n              if (cv == null || cv == pv || cv.equals(pv)) {\n                oldVal=pv;\n                if ((p.val=v) == null) {\n                  deleted=true;\n                  t.deleteTreeNode(p);\n                }\n              }\n            }\n          }\n        }\n  finally {\n          t.release(0);\n        }\n        if (validated) {\n          if (deleted)           counter.add(-1L);\n          break;\n        }\n      }\n else       tab=(Node[])fk;\n    }\n else     if ((fh & HASH_BITS) != h && f.next == null)     break;\n else     if ((fh & LOCKED) != 0) {\n      checkForResize();\n      f.tryAwaitLock(tab,i);\n    }\n else     if (f.casHash(fh,fh | LOCKED)) {\n      boolean validated=false;\n      boolean deleted=false;\n      try {\n        if (tabAt(tab,i) == f) {\n          validated=true;\n          for (Node e=f, pred=null; ; ) {\n            Object ek, ev;\n            if ((e.hash & HASH_BITS) == h && ((ev=e.val) != null) && ((ek=e.key) == k || k.equals(ek))) {\n              if (cv == null || cv == ev || cv.equals(ev)) {\n                oldVal=ev;\n                if ((e.val=v) == null) {\n                  deleted=true;\n                  Node en=e.next;\n                  if (pred != null)                   pred.next=en;\n else                   setTabAt(tab,i,en);\n                }\n              }\n              break;\n            }\n            pred=e;\n            if ((e=e.next) == null)             break;\n          }\n        }\n      }\n  finally {\n        if (!f.casHash(fh | LOCKED,fh)) {\n          f.hash=fh;\nsynchronized (f) {\n            f.notifyAll();\n          }\n          ;\n        }\n      }\n      if (validated) {\n        if (deleted)         counter.add(-1L);\n        break;\n      }\n    }\n  }\n  return oldVal;\n}\n", "docstring": "implementation for the four public remove / replace methods : replaces node value with v , conditional upon match of cv if non - null . if resulting value is null , delete .", "partition": "test"}
{"idx": "1517", "code": "private static final boolean copyHeader(String name,String fromReq,StringBuffer buf){\n  int start=fromReq.indexOf(name);\n  if (start != -1) {\n    int end=fromReq.indexOf(\"\\r\\n\",start);\n    if (end != -1) {\n      buf.append(fromReq.subSequence(start - 2,end));\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "copies a header from a request", "partition": "test"}
{"idx": "1518", "code": "public void sendMetric(final String name,final double value){\n  logger.debug(String.format(\"sendMetric(%s, %f)\",name,value));\n  if (telemetryClient != null) {\n    telemetryClient.trackMetric(name,value);\n  }\n}\n", "docstring": "call sendmetric to track the new value of the named metric .", "partition": "test"}
{"idx": "1519", "code": "default Document putAll(Iterable<Field> fields,Predicate<CharSequence> acceptableFieldNames){\n  for (  Field field : fields) {\n    if (acceptableFieldNames.test(field.getName())) {\n      setValue(field.getName(),field.getValue());\n    }\n  }\n  return this;\n}\n", "docstring": "attempts to copy all of the acceptable fields from the source and set on this document , overwriting any existing values .", "partition": "test"}
{"idx": "1520", "code": "public static URL findResourceBase(String baseResource,ClassLoader loader){\n  URL url=loader.getResource(baseResource);\n  return findResourceBase(url,baseResource);\n}\n", "docstring": "find the classpath url for a specific classpath resource . the classpath url is extracted from loader . getresource ( ) using the baseresource .", "partition": "test"}
{"idx": "1521", "code": "public String toEPL(EPStatementFormatter formatter){\n  StringWriter writer=new StringWriter();\n  toEPL(formatter,writer);\n  return writer.toString();\n}\n", "docstring": "rendering using the provided formatter .", "partition": "test"}
{"idx": "1522", "code": "public boolean isSpecified(int index){\n  if ((index < 0) || (index >= mLength)) {\n    throw new ArrayIndexOutOfBoundsException(\"\");\n  }\n  String str=mItems[(index << 3) + 5];\n  return ((str != null) ? (str.charAt(0) == \'d\') : true);\n}\n", "docstring": "returns true unless the attribute value was provided by dtd defaulting .", "partition": "test"}
{"idx": "1523", "code": "public StatArchiveReader(String archiveName) throws IOException {\n  this(new File[]{new File(archiveName)},null,false);\n}\n", "docstring": "creates a statarchivereader that will read the named archive file .", "partition": "test"}
{"idx": "1524", "code": "private static void initAdbSocketAddr(){\n  try {\n    sAdbServerPort=getAdbServerPort();\n    InetAddress hostAddr=InetAddress.getByName(DEFAULT_ADB_HOST);\n    sSocketAddr=new InetSocketAddress(hostAddr,sAdbServerPort);\n  }\n catch (  UnknownHostException e) {\n  }\n}\n", "docstring": "instantiates ssocketaddr with the address of the host \"'\" s adb process .", "partition": "test"}
{"idx": "1525", "code": "public int read(long fileOffset,byte[] buffer,int offset,int length) throws IOException {\n  _file.seek(fileOffset);\n  return _file.read(buffer,offset,length);\n}\n", "docstring": "reads a block from a given location .", "partition": "test"}
{"idx": "1526", "code": "private boolean matchesAnyTag(String tagName){\n  return tagNames.contains(tagName);\n}\n", "docstring": "tries to match tagname to known tag names .", "partition": "test"}
{"idx": "1527", "code": "default void shutdown(){\n  Platform.exit();\n}\n", "docstring": "shuts down the application by delegating service cleanups to the application thread .", "partition": "test"}
{"idx": "1528", "code": "public boolean isExpanded(int row){\n  TreeUI tree=getUI();\n  if (tree != null) {\n    TreePath path=tree.getPathForRow(this,row);\n    if (path != null) {\n      Boolean value=expandedState.get(path);\n      return (value != null && value.booleanValue());\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the node at the specified display row is currently expanded .", "partition": "test"}
{"idx": "1529", "code": "private static int labelEnd(String s){\n  int colonIndex=s.indexOf(\":\");\n  int semicolonIndex=s.indexOf(\";\");\n  if ((semicolonIndex == -1) || (colonIndex < semicolonIndex)) {\n    return colonIndex;\n  }\n else {\n    return -1;\n  }\n}\n", "docstring": "determines the position in the string where a label that might be contained ends", "partition": "test"}
{"idx": "1530", "code": "public HttpMethodInfo(Method method,Object handler,Object[] args,MultivaluedMap<String,Object> formParameters,Response responder){\n  this.method=method;\n  this.handler=handler;\n  this.args=Arrays.copyOf(args,args.length);\n  this.formParameters=formParameters;\n  this.responder=responder;\n}\n", "docstring": "construct httpmethodinfo object for a handler method that does not support streaming .", "partition": "test"}
{"idx": "1531", "code": "private void drawText(int x1,int y1,int s,boolean e_or_n,Graphics g){\n  Color oldColor=g.getColor();\n  g.setPaintMode();\n  if (m_FontColor == null) {\n    g.setColor(Color.black);\n  }\n else {\n    g.setColor(m_FontColor);\n  }\n  String st;\n  if (e_or_n) {\n    Edge e=m_edges[s].m_edge;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_edges[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n else {\n    Node e=m_nodes[s].m_node;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_nodes[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n  g.setColor(oldColor);\n}\n", "docstring": "draws the text for either an edge or a node .", "partition": "test"}
{"idx": "1532", "code": "public void update(List<Race> races){\n  if (currentRace == null) {\n    return;\n  }\n  if (races.contains(currentRace)) {\n    setRace(races.get(races.indexOf(currentRace)));\n  }\n}\n", "docstring": "give this list of races , whereas the dialog picks out the one it currently has open ( if present ) .", "partition": "test"}
{"idx": "1533", "code": "public boolean required(){\n  return _parameterMetadata.contains(Metadata.REQUIRED);\n}\n", "docstring": "indicates whether the parameter is required . if the required parameter is not set , then the extension is not negotiated during the handshake .", "partition": "test"}
{"idx": "1534", "code": "protected void sendDataToReceiver(ResultReceiver receiver,Intent originalIntent,Serializable data){\n  if (receiver != null && data != null) {\n    Bundle bundle=new Bundle();\n    bundle.putParcelable(ServiceReceiver.EXTRA_ORIGINAL_INTENT,originalIntent);\n    bundle.putSerializable(ServiceReceiver.EXTRA_DATA,data);\n    receiver.send(ServiceReceiver.STATUS_DATA,bundle);\n  }\n}\n", "docstring": "sends data to the receiver , usually the creator of the service intent .", "partition": "test"}
{"idx": "1535", "code": "private static Object matchOrReplace(Context cx,Scriptable scope,Scriptable thisObj,Object[] args,RegExpImpl reImpl,GlobData data,boolean forceFlat){\n  NativeRegExp re;\n  String str=ScriptRuntime.toString(thisObj);\n  data.str=str;\n  Scriptable topScope=ScriptableObject.getTopLevelScope(scope);\n  if (args.length == 0) {\n    Object compiled=NativeRegExp.compileRE(cx,\"\",\"\",false);\n    re=new NativeRegExp(topScope,compiled);\n  }\n else   if (args[0] instanceof NativeRegExp) {\n    re=(NativeRegExp)args[0];\n  }\n else {\n    String src=ScriptRuntime.toString(args[0]);\n    String opt;\n    if (data.optarg < args.length) {\n      args[0]=src;\n      opt=ScriptRuntime.toString(args[data.optarg]);\n    }\n else {\n      opt=null;\n    }\n    Object compiled=NativeRegExp.compileRE(cx,src,opt,forceFlat);\n    re=new NativeRegExp(topScope,compiled);\n  }\n  data.global=(re.getFlags() & NativeRegExp.JSREG_GLOB) != 0;\n  int[] indexp={0};\n  Object result=null;\n  if (data.mode == RA_SEARCH) {\n    result=re.executeRegExp(cx,scope,reImpl,str,indexp,NativeRegExp.TEST);\n    if (result != null && result.equals(Boolean.TRUE))     result=Integer.valueOf(reImpl.leftContext.length);\n else     result=Integer.valueOf(-1);\n  }\n else   if (data.global) {\n    re.lastIndex=0;\n    for (int count=0; indexp[0] <= str.length(); count++) {\n      result=re.executeRegExp(cx,scope,reImpl,str,indexp,NativeRegExp.TEST);\n      if (result == null || !result.equals(Boolean.TRUE))       break;\n      if (data.mode == RA_MATCH) {\n        match_glob(data,cx,scope,count,reImpl);\n      }\n else {\n        if (data.mode != RA_REPLACE)         Kit.codeBug();\n        SubString lastMatch=reImpl.lastMatch;\n        int leftIndex=data.leftIndex;\n        int leftlen=lastMatch.index - leftIndex;\n        data.leftIndex=lastMatch.index + lastMatch.length;\n        replace_glob(data,cx,scope,reImpl,leftIndex,leftlen);\n      }\n      if (reImpl.lastMatch.length == 0) {\n        if (indexp[0] == str.length())         break;\n        indexp[0]++;\n      }\n    }\n  }\n else {\n    result=re.executeRegExp(cx,scope,reImpl,str,indexp,((data.mode == RA_REPLACE) ? NativeRegExp.TEST : NativeRegExp.MATCH));\n  }\n  return result;\n}\n", "docstring": "analog of c match_or_replace .", "partition": "test"}
{"idx": "1536", "code": "public void removeBiomeType(BiomeDictionary.Type type){\n  ArrayList<BiomeGenBase> entryList=new ArrayList<BiomeGenBase>();\n  entryList.addAll(Arrays.asList(BiomeDictionary.getBiomesForType(type)));\n  for (  BiomeGenBase biome : entryList) {\n    Iterator<BiomeEntry> iterator=allowedBiomes.iterator();\n    while (iterator.hasNext()) {\n      if (BiomeDictionary.areBiomesEquivalent(iterator.next().biome,biome))       iterator.remove();\n    }\n  }\n}\n", "docstring": "removes all biomes of this type from the list of biomes allowed to generate", "partition": "test"}
{"idx": "1537", "code": "static SizeRequirements calculateTiledRequirements(LayoutIterator iter,SizeRequirements r){\n  long minimum=0;\n  long maximum=0;\n  long preferred=0;\n  int lastMargin=0;\n  int totalSpacing=0;\n  int n=iter.getCount();\n  for (int i=0; i < n; i++) {\n    iter.setIndex(i);\n    int margin0=lastMargin;\n    int margin1=(int)iter.getLeadingCollapseSpan();\n    totalSpacing+=Math.max(margin0,margin1);\n    preferred+=(int)iter.getPreferredSpan(0);\n    minimum+=iter.getMinimumSpan(0);\n    maximum+=iter.getMaximumSpan(0);\n    lastMargin=(int)iter.getTrailingCollapseSpan();\n  }\n  totalSpacing+=lastMargin;\n  totalSpacing+=2 * iter.getBorderWidth();\n  minimum+=totalSpacing;\n  preferred+=totalSpacing;\n  maximum+=totalSpacing;\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  r.minimum=(minimum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)minimum;\n  r.preferred=(preferred > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)preferred;\n  r.maximum=(maximum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)maximum;\n  return r;\n}\n", "docstring": "calculate the requirements needed to tile the requirements given by the iterator that would be tiled . the calculation takes into consideration margin and border spacing .", "partition": "test"}
{"idx": "1538", "code": "public static void writePaddedInteger(Writer out,long value,int size) throws IOException {\n  int intValue=(int)value;\n  if (intValue == value) {\n    writePaddedInteger(out,intValue,size);\n  }\n else   if (size <= 19) {\n    out.write(Long.toString(value));\n  }\n else {\n    if (value < 0) {\n      out.write(\'-\');\n      if (value != Long.MIN_VALUE) {\n        value=-value;\n      }\n else {\n        for (; size > 19; size--) {\n          out.write(\'0\');\n        }\n        out.write(\"9223372036854775808\");\n        return;\n      }\n    }\n    int digits=(int)(Math.log(value) / LOG_10) + 1;\n    for (; size > digits; size--) {\n      out.write(\'0\');\n    }\n    out.write(Long.toString(value));\n  }\n}\n", "docstring": "converts an integer to a string , prepended with a variable amount of \"'\" 0 \"'\" pad characters , and writes it to the given writer . < p > this method is optimized for converting small values to strings .", "partition": "test"}
{"idx": "1539", "code": "private static LDAPFilter createORFilter(FilterSet filterSet) throws LDAPException, IOException {\n  List<JAXBElement<?>> list=filterSet.getFilterGroup();\n  ArrayList<RawFilter> filters=new ArrayList<>(list.size());\n  for (  JAXBElement<?> filter : list) {\n    filters.add(createFilter(filter));\n  }\n  return LDAPFilter.createORFilter(filters);\n}\n", "docstring": "returns a new or search filter with the provided filter components .", "partition": "test"}
{"idx": "1540", "code": "private void sendBlob(String index,byte[] blob){\n  sendInstruction(new GuacamoleInstruction(\"blob\",index,DatatypeConverter.printBase64Binary(blob)));\n}\n", "docstring": "injects a \" blob \" instruction into the outbound guacamole protocol stream , as if sent by the connected client . \" blob \" instructions are used to send chunks of data along a stream .", "partition": "test"}
{"idx": "1541", "code": "protected void defineLabels(){\n  labelsValues=calcLabels();\n  if (handleValues)   labels=getLabelsFromValues();\n else   labels=getLabelsFromData();\n  nLabels=labels.size();\n}\n", "docstring": "defines what will be the axis labels", "partition": "test"}
{"idx": "1542", "code": "public static Set<Interval> mergeIntervalToSet(Set<Interval> intervals,Interval intervalToMerge){\n  LinkedHashSet<Interval> copyOfOriginalSet=new LinkedHashSet<>(intervals);\n  copyOfOriginalSet.add(intervalToMerge);\n  return mergeIntervalSet(copyOfOriginalSet);\n}\n", "docstring": "merge an interval into the given interval set .", "partition": "test"}
{"idx": "1543", "code": "public static String dropWhile(GString self,@ClosureParams(value=FromString.class,conflictResolutionStrategy=PickFirstResolver.class,options={\"String\",\"Character\"}) Closure condition){\n  return dropWhile(self.toString(),condition);\n}\n", "docstring": "a gstring variant of the equivalent charsequence method .", "partition": "test"}
{"idx": "1544", "code": "public void addNode(TopologicalNode node){\n  nodeList.add(node);\n}\n", "docstring": "adds an topological node to this graph .", "partition": "test"}
{"idx": "1545", "code": "public void printText(String text){\n  view.print(text,text.endsWith(\"\\r\"));\n  for (  ActionDelegate actionDelegate : actionDelegates) {\n    actionDelegate.onConsoleOutput(this);\n  }\n}\n", "docstring": "print text in the console .", "partition": "test"}
{"idx": "1546", "code": "@Override public void trim(){\n  if (counter < x.length) {\n    int[] y=new int[counter];\n    System.arraycopy(x,0,y,0,counter);\n    x=y;\n    resizeValues(counter);\n  }\n}\n", "docstring": "trims the data row to the number of actually used elements .", "partition": "test"}
{"idx": "1547", "code": "private void divide(int[] idx,double[] data,ArrayList<int[]> ret,int start,int end,int depth){\n  if (depth == 0) {\n    int[] a=Arrays.copyOfRange(idx,start,end);\n    Arrays.sort(a);\n    ret.add(a);\n    return;\n  }\n  final int count=end - start;\n  if (count == 0) {\n    for (int j=1 << depth; j > 0; --j) {\n      ret.add(new int[0]);\n    }\n    return;\n  }\n  double m=0.;\n  for (int i=start; i < end; i++) {\n    m+=data[i];\n  }\n  m/=count;\n  int pos=Arrays.binarySearch(data,start,end,m);\n  if (pos >= 0) {\n    final int opt=(start + end) >> 1;\n    while (data[pos] == m) {\n      if (pos < opt) {\n        pos++;\n      }\n else       if (pos > opt) {\n        pos--;\n      }\n else {\n        break;\n      }\n    }\n  }\n else {\n    pos=(-pos - 1);\n  }\n  divide(idx,data,ret,start,pos,depth - 1);\n  divide(idx,data,ret,pos,end,depth - 1);\n}\n", "docstring": "recursive call to further subdivide the array .", "partition": "test"}
{"idx": "1548", "code": "void assertThreadsStayAlive(long millis,Thread... threads){\n  try {\n    delay(millis);\n    for (    Thread thread : threads)     assertTrue(thread.isAlive());\n  }\n catch (  InterruptedException fail) {\n    threadFail(\"Unexpected InterruptedException\");\n  }\n}\n", "docstring": "checks that the threads do not terminate within the given millisecond delay .", "partition": "test"}
{"idx": "1549", "code": "public AbstractWorkerManager(String id){\n  _id=id;\n  _status=new WorkerManagerStatus();\n  setExecutionMode(EXECUTION_MODE.NON_SERIAL);\n  setupExecutor();\n}\n", "docstring": "set the identifier of the process", "partition": "test"}
{"idx": "1550", "code": "@Override public void applyInline(double[] data,int pos,int len){\n  int i;\n  double[] dataOut=new double[len];\n  if (len > real.length) {\n    throw new IllegalArgumentException(\"Length must not be larger than FFT size\");\n  }\n  int middle=len / 2 + len % 2;\n  System.arraycopy(data,0,dataOut,0,len);\n  System.arraycopy(dataOut,pos + middle,real,0,len - middle);\n  System.arraycopy(dataOut,pos,real,real.length - middle,middle);\n  if (real.length > len)   Arrays.fill(real,len - middle,real.length - middle,0);\n  Arrays.fill(imag,0,imag.length,0.);\n  FFT.transform(real,imag,false);\n  process(real,imag);\n  FFT.transform(real,imag,true);\n  System.arraycopy(real,0,dataOut,pos + middle,len - middle);\n  System.arraycopy(real,real.length - middle,dataOut,pos,middle);\n  double origAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  for (i=0; i < len; i++)   data[i]=amount * dataOut[i] + oneMinusAmount * data[i];\n  double newAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  double scale=origAvgEnergy / newAvgEnergy;\n  for (i=0; i < len; i++)   data[i]*=0.8 * scale;\n}\n", "docstring": "apply this frequency domain processor to the given data , and return the processing result in - place .", "partition": "test"}
{"idx": "1551", "code": "public final boolean insert_via(BrdViaInfo p_via_info,PlaPointInt p_location,NetNosList p_net_no_arr,int p_trace_clearance_class_no,int[] p_trace_pen_halfwidth_arr,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_pull_tight_accuracy,int p_pull_tight_time_limit){\n  shove_fail_clear();\n  changed_area_clear();\n  boolean r_ok=shove_via_algo.shove_via_insert(p_via_info,p_location,p_net_no_arr,p_trace_clearance_class_no,p_trace_pen_halfwidth_arr,p_max_recursion_depth,p_max_via_recursion_depth);\n  if (!r_ok)   return false;\n  NetNosList opt_net_no_arr=p_max_recursion_depth <= 0 ? p_net_no_arr : NetNosList.EMPTY;\n  TimeLimitStoppable t_limit=new TimeLimitStoppable(s_PREVENT_ENDLESS_LOOP);\n  changed_area_optimize(opt_net_no_arr,p_pull_tight_accuracy,null,t_limit,null);\n  return true;\n}\n", "docstring": "shoves aside traces , so that a via with the input parameters can be inserted without clearance violations . if the shove failed , the database may be damaged , so that an undo becomes necessesary .", "partition": "test"}
{"idx": "1552", "code": "public static byte[] toByteArray(String str){\n  int len=str.length();\n  StringTokenizer st=new StringTokenizer(str,\":\");\n  String[] newStrArray=new String[st.countTokens()];\n  int j=0;\n  while (st.hasMoreTokens()) {\n    newStrArray[j]=st.nextToken();\n    j++;\n  }\n  byte[] ret=new byte[newStrArray.length];\n  int tmp;\n  for (int i=0; i < newStrArray.length; i++) {\n    tmp=Integer.parseInt(newStrArray[i],16);\n    ret[i]=(byte)(tmp - 128);\n  }\n  return ret;\n}\n", "docstring": "converts a given hex string separated by colons to a byte array .", "partition": "test"}
{"idx": "1553", "code": "private char[] fFormatDigits(final double x){\n  String sx;\n  int i, j, k;\n  final int n1In;\n  final int n2In;\n  int expon=0;\n  boolean minusSign=false;\n  if (x > 0.0) {\n    sx=Double.toString(x);\n  }\n else   if (x < 0.0) {\n    sx=Double.toString(-x);\n    minusSign=true;\n  }\n else {\n    sx=Double.toString(x);\n    if (sx.charAt(0) == '-') {\n      minusSign=true;\n      sx=sx.substring(1);\n    }\n  }\n  final int ePos=sx.indexOf('E');\n  final int rPos=sx.indexOf('.');\n  if (rPos != -1) {\n    n1In=rPos;\n  }\n else   if (ePos != -1) {\n    n1In=ePos;\n  }\n else {\n    n1In=sx.length();\n  }\n  if (rPos != -1) {\n    if (ePos != -1) {\n      n2In=ePos - rPos - 1;\n    }\n else {\n      n2In=sx.length() - rPos - 1;\n    }\n  }\n else {\n    n2In=0;\n  }\n  if (ePos != -1) {\n    int ie=ePos + 1;\n    expon=0;\n    if (sx.charAt(ie) == '-') {\n      for (++ie; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=-Integer.parseInt(sx.substring(ie));\n      }\n    }\n else {\n      if (sx.charAt(ie) == '+') {\n        ++ie;\n      }\n      for (; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=Integer.parseInt(sx.substring(ie));\n      }\n    }\n  }\n  final int p;\n  if (precisionSet) {\n    p=precision;\n  }\n else {\n    p=defaultDigits - 1;\n  }\n  final char[] ca1=sx.toCharArray();\n  final char[] ca2=new char[n1In + n2In];\n  final char[] ca3;\n  final char[] ca4;\n  final char[] ca5;\n  for (j=0; j < n1In; j++) {\n    ca2[j]=ca1[j];\n  }\n  i=j + 1;\n  for (k=0; k < n2In; j++, i++, k++) {\n    ca2[j]=ca1[i];\n  }\n  if (n1In + expon <= 0) {\n    ca3=new char[-expon + n2In];\n    for (j=0, k=0; k < (-n1In - expon); k++, j++) {\n      ca3[j]='0';\n    }\n    for (i=0; i < (n1In + n2In); i++, j++) {\n      ca3[j]=ca2[i];\n    }\n  }\n else {\n    ca3=ca2;\n  }\n  boolean carry=false;\n  if (p < -expon + n2In) {\n    if (expon < 0) {\n      i=p;\n    }\n else {\n      i=p + n1In;\n    }\n    carry=checkForCarry(ca3,i);\n    if (carry) {\n      carry=startSymbolicCarry(ca3,i - 1,0);\n    }\n  }\n  if (n1In + expon <= 0) {\n    ca4=new char[2 + p];\n    if (!carry) {\n      ca4[0]='0';\n    }\n else {\n      ca4[0]='1';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[1]='.';\n      for (i=0, j=2; i < Math.min(p,ca3.length); i++, j++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n else {\n    if (!carry) {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 1];\n      }\n else {\n        ca4=new char[n1In + expon];\n      }\n      j=0;\n    }\n else {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 2];\n      }\n else {\n        ca4=new char[n1In + expon + 1];\n      }\n      ca4[0]='1';\n      j=1;\n    }\n    for (i=0; i < Math.min(n1In + expon,ca3.length); i++, j++) {\n      ca4[j]=ca3[i];\n    }\n    for (; i < n1In + expon; i++, j++) {\n      ca4[j]='0';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[j]='.';\n      j++;\n      for (k=0; i < ca3.length && k < p; i++, j++, k++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n  int nZeros=0;\n  if (!leftJustify && leadingZeros) {\n    int xThousands=0;\n    if (thousands) {\n      int xlead=0;\n      if (ca4[0] == '+' || ca4[0] == '-' || ca4[0] == ' ') {\n        xlead=1;\n      }\n      int xdp=xlead;\n      for (; xdp < ca4.length; xdp++) {\n        if (ca4[xdp] == '.') {\n          break;\n        }\n      }\n      xThousands=(xdp - xlead) / 3;\n    }\n    if (fieldWidthSet) {\n      nZeros=fieldWidth - ca4.length;\n    }\n    if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n      nZeros--;\n    }\n    nZeros-=xThousands;\n    if (nZeros < 0) {\n      nZeros=0;\n    }\n  }\n  j=0;\n  if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n    ca5=new char[ca4.length + nZeros + 1];\n    j++;\n  }\n else {\n    ca5=new char[ca4.length + nZeros];\n  }\n  if (!minusSign) {\n    if (leadingSign) {\n      ca5[0]='+';\n    }\n    if (leadingSpace) {\n      ca5[0]=' ';\n    }\n  }\n else {\n    ca5[0]='-';\n  }\n  for (i=0; i < nZeros; i++, j++) {\n    ca5[j]='0';\n  }\n  for (i=0; i < ca4.length; i++, j++) {\n    ca5[j]=ca4[i];\n  }\n  int lead=0;\n  if (ca5[0] == '+' || ca5[0] == '-' || ca5[0] == ' ') {\n    lead=1;\n  }\n  int dp=lead;\n  for (; dp < ca5.length; dp++) {\n    if (ca5[dp] == '.') {\n      break;\n    }\n  }\n  final int nThousands=(dp - lead) / 3;\n  if (dp < ca5.length) {\n    ca5[dp]=dfs.getDecimalSeparator();\n  }\n  char[] ca6=ca5;\n  if (thousands && nThousands > 0) {\n    ca6=new char[ca5.length + nThousands + lead];\n    ca6[0]=ca5[0];\n    for (i=lead, k=lead; i < dp; i++) {\n      if (i > 0 && (dp - i) % 3 == 0) {\n        ca6[k]=dfs.getGroupingSeparator();\n        ca6[k + 1]=ca5[i];\n        k+=2;\n      }\n else {\n        ca6[k]=ca5[i];\n        k++;\n      }\n    }\n    for (; i < ca5.length; i++, k++) {\n      ca6[k]=ca5[i];\n    }\n  }\n  return ca6;\n}\n", "docstring": "for f format , the flag character \"'\" - \"'\" , means that the output should be left justified within the field . the default is to pad with blanks on the left . \"'\" + \"'\" character means that the conversion will always begin with a sign ( + or - ) . the blank flag character means that a non - negative input will be preceded with a blank . if both a \"'\" + \"'\" and a \"'\" \"'\" are specified , the blank flag is ignored . the \"'\" 0 \"'\" flag character implies that padding to the field width will be done with zeros instead of blanks . the field width is treated as the minimum number of characters to be printed . the default is to add no padding . padding is with blanks by default . the precision , if set , is the number of digits to appear after the radix character . padding is with trailing 0s .", "partition": "test"}
{"idx": "1554", "code": "int maxLength(){\n  FontMetrics fm=getFontMetrics(getFont());\n  int m=0;\n  int end=items.size();\n  for (int i=0; i < end; i++) {\n    int l=fm.stringWidth(((String)items.elementAt(i)));\n    m=Math.max(m,l);\n  }\n  return m;\n}\n", "docstring": "return the length of the largest item in the list", "partition": "test"}
{"idx": "1555", "code": "public PlaPointInt round_to_the_left(PlaDirection p_dir){\n  PlaPointFloat dir=p_dir.to_float();\n  double rounded_x;\n  if (dir.v_y > 0) {\n    rounded_x=Math.floor(v_x);\n  }\n else   if (dir.v_y < 0) {\n    rounded_x=Math.ceil(v_x);\n  }\n else {\n    rounded_x=Math.round(v_x);\n  }\n  double rounded_y;\n  if (dir.v_x > 0) {\n    rounded_y=Math.ceil(v_y);\n  }\n else   if (dir.v_x < 0) {\n    rounded_y=Math.floor(v_y);\n  }\n else {\n    rounded_y=Math.round(v_y);\n  }\n  return new PlaPointInt(rounded_x,rounded_y);\n}\n", "docstring": "rounds this point , so that if this point is on the left side of any directed line with direction p_dir , the result point will also be on the left side .", "partition": "test"}
{"idx": "1556", "code": "public static byte[] unwrapVCF(File sourceFile,File tmpFile) throws FileNotFoundException, IOException {\n  ZipArchiveInputStream in=null;\n  FileOutputStream fos=null;\n  String hmacString=null;\n  try {\n    in=new ZipArchiveInputStream(new FileInputStream(sourceFile));\n    ArchiveEntry entry;\n    in.getNextEntry();\n    fos=new FileOutputStream(tmpFile);\n    IOUtils.copy(in,fos);\n    entry=in.getNextEntry();\n    hmacString=entry.getName();\n    return Utils.hexToBytes(hmacString);\n  }\n catch (  StringIndexOutOfBoundsException e) {\n    logger.error(\"Error parsing hmac: \" + hmacString + \" is no valid hex String\",e);\n    throw e;\n  }\ncatch (  Exception e) {\n    logger.error(\"Error unwrapping VCF file\",e);\n    throw e;\n  }\n finally {\n    if (fos != null) {\n      fos.flush();\n      fos.close();\n    }\n    if (in != null) {\n      in.close();\n    }\n  }\n}\n", "docstring": "method extracts the vcf file stored within the zipped import file to the given destination file . it further returns the corresponding hmac stored within the archive .", "partition": "test"}
{"idx": "1557", "code": "public boolean registerUser(String username,String password,String uri) throws DataAccessException {\n  if (checkUsernameExists(username)) {\n    return false;\n  }\n  storeUser(username,password,uri);\n  return true;\n}\n", "docstring": "attempts to register the username , password combination . checks if username not already exist . returns true if successful , false otherwise .", "partition": "test"}
{"idx": "1558", "code": "public SELECT(@NonNull String... columns){\n  if (columns == null) {\n    throw new NullPointerException(\"SELECT: Columns are null\");\n  }\n  if (columns.length == 0)   throw new IllegalArgumentException(\"At least on column is required\");\n  StringBuilder builder=new StringBuilder(\"SELECT \");\n  for (int i=0; i < columns.length; i++) {\n    builder.append(columns[i]);\n    if (i != (columns.length - 1))     builder.append(\", \");\n  }\n  sql=builder.toString();\n}\n", "docstring": "create a < code > select column1 , column2 , . . . from tablename", "partition": "test"}
{"idx": "1559", "code": "public static synchronized MBeanInfo testCompliance(final Class<?> baseClass,Class<?> mbeanInterface) throws NotCompliantMBeanException {\n  if (mbeanInterface == null)   mbeanInterface=getStandardMBeanInterface(baseClass);\n  ReflectUtil.checkPackageAccess(mbeanInterface);\n  MBeanIntrospector<?> introspector=StandardMBeanIntrospector.getInstance();\n  return getClassMBeanInfo(introspector,baseClass,mbeanInterface);\n}\n", "docstring": "basic method for testing if a given class is a jmx compliant standard mbean . this method is only called by the legacy code in com . sun . management . jmx .", "partition": "test"}
{"idx": "1560", "code": "public static Set<String> toStringSet(TemplateSequenceModel seqModel) throws TemplateModelException {\n  Set<String> set=new HashSet<String>();\n  for (int i=0; i < seqModel.size(); i++) {\n    set.add(getAsStringNonEscaping((TemplateScalarModel)seqModel.get(i)));\n  }\n  return set;\n}\n", "docstring": "to string set . < p > warn : bypasses auto - escaping , caller handles . ( e . g . the object wrapper used to rewrap the result ) .", "partition": "test"}
{"idx": "1561", "code": "public JKSSignatureToken(InputStream ksStream,String ksPassword){\n  try {\n    keyStore=KeyStore.getInstance(KeyStore.getDefaultType());\n    password=(ksPassword == null) ? null : ksPassword.toCharArray();\n    keyStore.load(ksStream,password);\n  }\n catch (  Exception e) {\n    throw new DSSException(e);\n  }\n finally {\n    if (ksStream != null) {\n      try {\n        ksStream.close();\n      }\n catch (      IOException e) {\n        logger.error(e.getMessage(),e);\n      }\n    }\n  }\n}\n", "docstring": "creates a signaturetokenconnection with the provided inputstream to java keystore file and password .", "partition": "test"}
{"idx": "1562", "code": "protected void writeLocation(String loc) throws IOException {\n  hadAnnotations|=(loc != null);\n  locOut.writeObject(loc);\n}\n", "docstring": "overrides marshaloutputstream . writelocation implementation to write annotations to the location stream .", "partition": "test"}
{"idx": "1563", "code": "protected int __offset(int vtable_offset){\n  int vtable=bb_pos - bb.getInt(bb_pos);\n  return vtable_offset < bb.getShort(vtable) ? bb.getShort(vtable + vtable_offset) : 0;\n}\n", "docstring": "look up a field in the vtable .", "partition": "test"}
{"idx": "1564", "code": "public static String selectText(XPathExpression expr,Node context){\n  try {\n    return (String)expr.evaluate(context,XPathConstants.STRING);\n  }\n catch (  XPathExpressionException e) {\n    throw new XmlException(e);\n  }\n}\n", "docstring": "evaluates the xpath expression as text .", "partition": "test"}
{"idx": "1565", "code": "public static HttpHeaders toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders){\n  if (inHeaders.isEmpty()) {\n    return HttpHeaders.EMPTY_HEADERS;\n  }\n  final HttpHeaders out=new DefaultHttpHeaders(true,inHeaders.size());\n  toArmeria(inHeaders,out);\n  return out;\n}\n", "docstring": "converts the specified netty http / 1 headers into armeria http / 2 headers .", "partition": "test"}
{"idx": "1566", "code": "public static int calculateRMSLevel(short[] audioData,int numframes){\n  long lSum=0;\n  int numread=0;\n  for (  short s : audioData) {\n    lSum=lSum + s;\n    numread++;\n    if (numread == numframes)     break;\n  }\n  double dAvg=lSum / numframes;\n  double sumMeanSquare=0d;\n  numread=0;\n  for (  short anAudioData : audioData) {\n    sumMeanSquare=sumMeanSquare + Math.pow(anAudioData - dAvg,2d);\n    numread++;\n    if (numread == numframes)     break;\n  }\n  double averageMeanSquare=sumMeanSquare / numframes;\n  return (int)(Math.pow(averageMeanSquare,0.5d) + 0.5);\n}\n", "docstring": "calculates the rms audio level from the provided short sample extract", "partition": "test"}
{"idx": "1567", "code": "private void initProgram(){\n  glUseProgram(this.program);\n  vec3ArrayUniform=glGetUniformLocation(this.program,\"cols\");\n  chosenUniform=glGetUniformLocation(this.program,\"chosen\");\n  glUseProgram(0);\n}\n", "docstring": "initialize the shader program .", "partition": "test"}
{"idx": "1568", "code": "public void testFloatValueNeg(){\n  String a=\"-1238096483923847.6356789029578E+21\";\n  BigDecimal aNumber=new BigDecimal(a);\n  float result=-1.2380965E36F;\n  assertTrue(\"incorrect value\",aNumber.floatValue() == result);\n}\n", "docstring": "float value of a negative bigdecimal", "partition": "test"}
{"idx": "1569", "code": "public void bindKeyStore(final KeyStoreService keyStoreService){\n  this.keyStore=keyStoreService;\n}\n", "docstring": "binds the keystore to the truststore service . this method is needed to prevent compilation errors .", "partition": "test"}
{"idx": "1570", "code": "protected void drawConnectorCenters(Canvas c){\n  List<Connection> connections=mBlock.getAllConnections();\n  Paint paint=new Paint();\n  paint.setStyle(Paint.Style.FILL);\n  for (int i=0; i < connections.size(); i++) {\n    Connection conn=connections.get(i);\n    if (conn.inDragMode()) {\n      if (conn.isConnected()) {\n        paint.setColor(Color.RED);\n      }\n else {\n        paint.setColor(Color.MAGENTA);\n      }\n    }\n else {\n      if (conn.isConnected()) {\n        paint.setColor(Color.GREEN);\n      }\n else {\n        paint.setColor(Color.CYAN);\n      }\n    }\n    mTempWorkspacePoint.set(conn.getPosition().x - mBlock.getPosition().x,conn.getPosition().y - mBlock.getPosition().y);\n    mHelper.workspaceToVirtualViewDelta(mTempWorkspacePoint,mTempConnectionPosition);\n    if (mHelper.useRtl()) {\n      mTempConnectionPosition.x+=mBlockViewSize.x;\n    }\n    c.drawCircle(mTempConnectionPosition.x,mTempConnectionPosition.y,10,paint);\n  }\n}\n", "docstring": "this is a developer testing function subclasses can call to draw dots at the model \"'\" s location of all connections on this block . never called by default .", "partition": "test"}
{"idx": "1571", "code": "private static boolean isMerge(InstructionHandle handle){\n  if (handle.hasTargeters()) {\n    InstructionTargeter[] targeterList=handle.getTargeters();\n    for (    InstructionTargeter targeter : targeterList) {\n      if (targeter instanceof BranchInstruction) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "determine whether or not the given instruction is a control flow merge .", "partition": "test"}
{"idx": "1572", "code": "private synchronized void loadTrustManager(){\n  try {\n    TrustManagerFactory tmf=TrustManagerFactory.getInstance(X509_ALGORITHM);\n    tmf.init(keystore);\n    for (    TrustManager trustManager : tmf.getTrustManagers()) {\n      if (trustManager instanceof X509TrustManager) {\n        defaultViPRTrustManager=(X509TrustManager)trustManager;\n        log.debug(\"found a X509TrustManager instance\");\n        break;\n      }\n    }\n    log.info(\"renew trust manager. the # of certificates in trust store is {}\",defaultViPRTrustManager.getAcceptedIssuers().length);\n  }\n catch (  GeneralSecurityException e) {\n    log.error(e.getMessage(),e);\n  }\n}\n", "docstring": "loads the trust manager using the vipr keystore .", "partition": "test"}
{"idx": "1573", "code": "public ThreadPool(String name,int poolSize){\n  this.poolSize=poolSize;\n  this.poolName=name;\n  taskList=new LinkedList<Runnable>();\n  threads=new WorkerThread[poolSize];\n  createThreads();\n}\n", "docstring": "constructs a thread pool with given parameters .", "partition": "test"}
{"idx": "1574", "code": "public final void addHelperTextColor(@ColorInt final int color){\n  if (!helperTextColors.contains(color)) {\n    helperTextColors.add(color);\n    verifyPasswordStrength();\n  }\n}\n", "docstring": "adds a new helper text color , which should be used to highlight the helper text , which indicates the password strength .", "partition": "test"}
{"idx": "1575", "code": "public void advanceToNextMinute(){\n}\n", "docstring": "hook function overridden in instrumentedraptorworker b / efore advancing to the next minute", "partition": "test"}
{"idx": "1576", "code": "ListBasedTokenStream(AttributeSource attributeSource,List<AttributeSource> tokens){\n  super(attributeSource.getAttributeFactory());\n  this.tokens=tokens;\n  addAttributes(attributeSource);\n}\n", "docstring": "creates a new listbasedtokenstream which uses the given tokens as its token source .", "partition": "test"}
{"idx": "1577", "code": "@SuppressWarnings(\"rawtypes\") protected Class resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n  String cname=classDesc.getName();\n  return ClassFinder.resolveClass(cname,this.loader);\n}\n", "docstring": "use the given classloader rather than using the system class", "partition": "test"}
{"idx": "1578", "code": "public static int find(byte[] a,int fromIndex,int toIndex,byte[] key){\n  int result=-1;\n  int sublen=key.length;\n  int maxpos, first, sp=0;\n  maxpos=Math.min(toIndex,a.length) - sublen;\n  for (first=fromIndex; sp != sublen && first <= maxpos; first++) {\n    first=find(a,first,maxpos,key[0]);\n    if ((first < 0) || (first > maxpos)) {\n      break;\n    }\n    for (sp=1; sp < sublen; sp++) {\n      if (a[first + sp] != key[sp]) {\n        sp=sublen;\n      }\n    }\n  }\n  if (sublen == 0) {\n    result=0;\n  }\n else   if (sp == sublen) {\n    result=(first - 1);\n  }\n  return result;\n}\n", "docstring": "look for a sequence of bytes in a byte array .", "partition": "test"}
{"idx": "1579", "code": "private void addSyntheticEdge(Collection<GraphEdge> result,GraphEdge original,GraphNode head,GraphNode tail){\n  result.add(new GraphEdge(head,tail,original.getRelation()));\n}\n", "docstring": "synthesize a new edge , and add it to the result . the new edge goes from head to tail , and it \"'\" s relationship type is obtained from the original edge .", "partition": "test"}
{"idx": "1580", "code": "public void addStates(State[] s){\n  for (int i=0; i < s.length; i++)   states.addElement(s[i]);\n}\n", "docstring": "append states to the state vector .", "partition": "test"}
{"idx": "1581", "code": "private static byte[] WindowsRegEnumKeyEx1(int hKey,int subKeyIndex,int maxKeyLength){\n  byte[] result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "retries regenumkeyex ( ) max_attempts times before giving up .", "partition": "test"}
{"idx": "1582", "code": "public Tasker addTask(Task task){\n  tasks.add(task);\n  lastAddedTask=task;\n  return this;\n}\n", "docstring": "add a new task", "partition": "test"}
{"idx": "1583", "code": "private void initComputeProgram(){\n  glUseProgram(computeProgram);\n  IntBuffer workGroupSize=BufferUtils.createIntBuffer(3);\n  glGetProgramiv(computeProgram,GL_COMPUTE_WORK_GROUP_SIZE,workGroupSize);\n  workGroupSizeX=workGroupSize.get(0);\n  workGroupSizeY=workGroupSize.get(1);\n  timeUniform=glGetUniformLocation(computeProgram,\"time\");\n  blendFactorUniform=glGetUniformLocation(computeProgram,\"blendFactor\");\n  bounceCountUniform=glGetUniformLocation(computeProgram,\"bounceCount\");\n  IntBuffer params=BufferUtils.createIntBuffer(1);\n  int loc=glGetUniformLocation(computeProgram,\"framebufferImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  framebufferImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldPositionImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldPositionImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldNormalImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldNormalImageBinding=params.get(0);\n  glUseProgram(0);\n}\n", "docstring": "initialize the compute shader .", "partition": "test"}
{"idx": "1584", "code": "public void sort(){\n  throwIfImmutable();\n  if (!sorted) {\n    Arrays.sort(values,0,size);\n    sorted=true;\n  }\n}\n", "docstring": "sorts the elements in the list in - place .", "partition": "test"}
{"idx": "1585", "code": "public static Object objectFromByteBuffer(byte[] buffer) throws Exception {\n  if (buffer == null)   return null;\n  ByteArrayInputStream inStream=new ByteArrayInputStream(buffer);\n  ObjectInputStream in=new ObjectInputStreamExt(inStream);\n  Object retval=in.readObject();\n  in.close();\n  return retval;\n}\n", "docstring": "creates an object from a byte buffer .", "partition": "test"}
{"idx": "1586", "code": "public String generateGroupName(String policyName,Set<String> existingGroupNames,String parentGroupName){\n  int count=0;\n  String format=null;\n  while (count <= existingGroupNames.size()) {\n    if (0 == count) {\n      format=String.format(\"SG_%s\",policyName);\n    }\n else {\n      format=String.format(\"SG_%s_%d\",policyName,count);\n    }\n    String generatedGroupName=generate(parentGroupName,format,SmisConstants.MASK_NAME_DELIMITER,SmisConstants.MAX_STORAGE_GROUP_NAME_LENGTH);\n    if (!existingGroupNames.contains(generatedGroupName)) {\n      return generatedGroupName;\n    }\n    count++;\n  }\n  return generate(parentGroupName,String.format(\"SG1_%s\",policyName),SmisConstants.MASK_NAME_DELIMITER,SmisConstants.MAX_STORAGE_GROUP_NAME_LENGTH);\n}\n", "docstring": "todo : vmax3 customized names generate group names which doesn \"'\" t exist in array already .", "partition": "test"}
{"idx": "1587", "code": "public DefaultActionGroup(@NotNull AnAction... actions){\n  this(Arrays.asList(actions));\n}\n", "docstring": "creates an action group containing the specified actions .", "partition": "test"}
{"idx": "1588", "code": "public int add(T dl,int row){\n  _list.add(row,dl);\n  fireTableRowsInserted(row,row);\n  return row;\n}\n", "docstring": "adds a dataline to the list at a row . all forms of add ( . . ) eventually end up here . extending classes should override this if they want to maintain a hashmap of any type for speedier access .", "partition": "test"}
{"idx": "1589", "code": "@SuppressLint(\"DrawAllocation\") @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int maxWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int maxHeight=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.UNSPECIFIED)   maxWidth=Integer.MAX_VALUE;\n  if (heightMode == MeasureSpec.UNSPECIFIED)   maxHeight=Integer.MAX_VALUE;\n  int paddingLeft=getPaddingLeft();\n  int paddingTop=getPaddingTop();\n  int paddingRight=getPaddingRight();\n  int paddingBottom=getPaddingBottom();\n  int maxRightBound=maxWidth - paddingRight;\n  int maxBottomBound=maxHeight - paddingBottom;\n  int left;\n  int top;\n  int right;\n  int bottom;\n  int rightBound=paddingLeft;\n  int maxRightNoPadding=rightBound;\n  int bottomBound;\n  int lastMaxBottom=paddingTop;\n  int maxBottom=lastMaxBottom;\n  int childWidth;\n  int childHeight;\n  int lineStartIndex=0;\n  int lineEndIndex;\n  rectList.clear();\n  int childCount=getChildCount();\n  for (int index=0; index < childCount; index++) {\n    final View child=getChildAt(index);\n    child.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);\n    if (child.getVisibility() == View.GONE)     continue;\n    final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n    childWidth=child.getMeasuredWidth();\n    childHeight=child.getMeasuredHeight();\n    left=rightBound + lp.leftMargin;\n    right=left + childWidth;\n    rightBound=right + lp.rightMargin;\n    if (rightBound > maxRightBound) {\n      lineEndIndex=index;\n      adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,lineEndIndex);\n      if (maxBottom >= maxBottomBound)       break;\n      if (lineEndIndex == lineStartIndex) {\n        child.measure(MeasureSpec.makeMeasureSpec(maxWidth - paddingLeft - paddingRight- lp.leftMargin- lp.rightMargin,MeasureSpec.AT_MOST),MeasureSpec.UNSPECIFIED);\n        childWidth=child.getMeasuredWidth();\n        childHeight=child.getMeasuredHeight();\n      }\n      left=paddingLeft + lp.leftMargin;\n      right=left + childWidth;\n      rightBound=right + lp.rightMargin;\n      lastMaxBottom=maxBottom;\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n      lineStartIndex=index;\n    }\n else {\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n    }\n    if (rightBound > maxRightNoPadding)     maxRightNoPadding=rightBound;\n    if (bottomBound > maxBottom)     maxBottom=bottomBound;\n    Rect rect=new Rect();\n    rect.left=left;\n    rect.top=top;\n    rect.right=right;\n    rect.bottom=bottom;\n    rectList.add(rect);\n  }\n  adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,rectList.size());\n  int measuredWidth;\n  int measuredHeight;\n  if (widthMode == MeasureSpec.EXACTLY)   measuredWidth=maxWidth;\n else   measuredWidth=maxRightNoPadding + paddingRight;\n  if (heightMode == MeasureSpec.EXACTLY)   measuredHeight=maxHeight;\n else {\n    measuredHeight=maxBottom + paddingBottom;\n    if (heightMode == MeasureSpec.AT_MOST)     measuredHeight=measuredHeight > maxHeight ? maxHeight : measuredHeight;\n  }\n  setMeasuredDimension(measuredWidth,measuredHeight);\n}\n", "docstring": "each row or line at least show one child horizontal only show child can show or partly show in parent", "partition": "test"}
{"idx": "1590", "code": "private void ensureBufferCapacity(int desiredCapacity){\n  int capacity=pixelBuffer.length;\n  while (capacity < desiredCapacity) {\n    capacity*=2;\n  }\n  if (capacity > pixelBuffer.length) {\n    pixelBuffer=new byte[capacity];\n  }\n}\n", "docstring": "grow the pixel buffer if necessary . using this method instead of allocating a new buffer every time a frame is grabbed improves performance by reducing the frequency of garbage collections . in a simple test , the unmodified version of ipcameraframegrabber caused about 200mb of allocations within 13 seconds . in this version , almost no additional heap space is typically allocated per frame . the downside to this is that the returned frames can \"'\" t really be modified , so this probably won \"'\" t go upstream , but it \"'\" s useful for us because in grip we don \"'\" t operate on images in - place .", "partition": "test"}
{"idx": "1591", "code": "public static <K,V>ConcurrentMap<K,V> newConcurrentMapWithAggressiveConcurrency(){\n  return new ConcurrentHashMap<>(16,0.75f,aggressiveConcurrencyLevel);\n}\n", "docstring": "creates a new chm with an aggressive concurrency level , aimed at high concurrent update rate long living maps .", "partition": "test"}
{"idx": "1592", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenee != null || !eventName.equals(\"instance\")) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection with respect to the named event", "partition": "test"}
{"idx": "1593", "code": "protected char skipAllWhitespace(Reader r) throws IOException {\n  char c;\n  do {\n    c=(char)r.read();\n  }\n while (Character.isWhitespace(c) && c != (char)-1);\n  return c;\n}\n", "docstring": "skips all consecutive whitespace characters from reader", "partition": "test"}
{"idx": "1594", "code": "public Map<String,String> parse(final String str,char separator){\n  if (str == null) {\n    return new HashMap<>();\n  }\n  return parse(str.toCharArray(),separator);\n}\n", "docstring": "extracts a map of name / value pairs from the given string . names are expected to be unique .", "partition": "test"}
{"idx": "1595", "code": "private String resourceId(){\n  return subSchemaPath.isEmpty() ? null : lastSchemaNodeName();\n}\n", "docstring": "gets the resource id . for root schema config , this will be null . otherwise , it will be the name of the schema type this provider addresses .", "partition": "test"}
{"idx": "1596", "code": "private long acquireWrite(boolean interruptible,long deadline){\n  WNode node=null, p;\n  for (int spins=-1; ; ) {\n    long m, s, ns;\n    if ((m=(s=state) & ABITS) == 0L) {\n      if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT))       return ns;\n    }\n else     if (spins < 0)     spins=(m == WBIT && wtail == whead) ? SPINS : 0;\n else     if (spins > 0) {\n      if (LockSupport.nextSecondarySeed() >= 0)       --spins;\n    }\n else     if ((p=wtail) == null) {\n      WNode hd=new WNode(WMODE,null);\n      if (U.compareAndSwapObject(this,WHEAD,null,hd))       wtail=hd;\n    }\n else     if (node == null)     node=new WNode(WMODE,p);\n else     if (node.prev != p)     node.prev=p;\n else     if (U.compareAndSwapObject(this,WTAIL,p,node)) {\n      p.next=node;\n      break;\n    }\n  }\n  for (int spins=-1; ; ) {\n    WNode h, np, pp;\n    int ps;\n    if ((h=whead) == p) {\n      if (spins < 0)       spins=HEAD_SPINS;\n else       if (spins < MAX_HEAD_SPINS)       spins<<=1;\n      for (int k=spins; ; ) {\n        long s, ns;\n        if (((s=state) & ABITS) == 0L) {\n          if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT)) {\n            whead=node;\n            node.prev=null;\n            return ns;\n          }\n        }\n else         if (LockSupport.nextSecondarySeed() >= 0 && --k <= 0)         break;\n      }\n    }\n else     if (h != null) {\n      WNode c;\n      Thread w;\n      while ((c=h.cowait) != null) {\n        if (U.compareAndSwapObject(h,WCOWAIT,c,c.cowait) && (w=c.thread) != null)         U.unpark(w);\n      }\n    }\n    if (whead == h) {\n      if ((np=node.prev) != p) {\n        if (np != null)         (p=np).next=node;\n      }\n else       if ((ps=p.status) == 0)       U.compareAndSwapInt(p,WSTATUS,0,WAITING);\n else       if (ps == CANCELLED) {\n        if ((pp=p.prev) != null) {\n          node.prev=pp;\n          pp.next=node;\n        }\n      }\n else {\n        long time;\n        if (deadline == 0L)         time=0L;\n else         if ((time=deadline - System.nanoTime()) <= 0L)         return cancelWaiter(node,node,false);\n        Thread wt=Thread.currentThread();\n        U.putObject(wt,PARKBLOCKER,this);\n        node.thread=wt;\n        if (p.status < 0 && (p != h || (state & ABITS) != 0L) && whead == h && node.prev == p)         U.park(false,time);\n        node.thread=null;\n        U.putObject(wt,PARKBLOCKER,null);\n        if (interruptible && Thread.interrupted())         return cancelWaiter(node,node,true);\n      }\n    }\n  }\n}\n", "docstring": "see above for explanation .", "partition": "test"}
{"idx": "1597", "code": "@Override public boolean isInitial(){\n  return init;\n}\n", "docstring": "returns a boolean flag indicating if the state is initial ( just starting )", "partition": "test"}
{"idx": "1598", "code": "public static String denormalize(final CharSequence self){\n  if (lineSeparator == null) {\n    final StringWriter sw=new StringWriter(2);\n    try {\n      final BufferedWriter bw=new BufferedWriter(sw);\n      bw.newLine();\n      bw.flush();\n      lineSeparator=sw.toString();\n    }\n catch (    IOException ioe) {\n      lineSeparator=\"\\n\";\n    }\n  }\n  final int len=self.length();\n  if (len < 1) {\n    return self.toString();\n  }\n  final StringBuilder sb=new StringBuilder((110 * len) / 100);\n  int i=0;\n  CharSequence cs=(self instanceof GString) ? self.toString() : self;\n  while (i < len) {\n    final char ch=cs.charAt(i++);\nswitch (ch) {\ncase \'\\r\':\n      sb.append(lineSeparator);\n    if ((i < len) && (cs.charAt(i) == \'\\n\')) {\n      ++i;\n    }\n  break;\ncase \'\\n\':\nsb.append(lineSeparator);\nbreak;\ndefault :\nsb.append(ch);\nbreak;\n}\n}\nreturn sb.toString();\n}\n", "docstring": "return a charsequence with lines ( separated by lf , cr / lf , or cr ) terminated by the platform specific line separator .", "partition": "test"}
{"idx": "1599", "code": "public static void performSaveAs(String schemaPrefixFileName,String selFilePath,ContainerConfig containerConfig){\n  try {\n    File fileWithDefaultConfiguration=createContainerSchemaFile(schemaPrefixFileName,selFilePath);\n    updateFile(containerConfig,fileWithDefaultConfiguration.getPath(),schemaPrefixFileName);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "save content of containerconfig instance into xml file ( schema or configuration ) .", "partition": "test"}
{"idx": "1600", "code": "public boolean isAborted(){\n  return isAborted.get();\n}\n", "docstring": "returns whether the printng was aborted using this printingstatus", "partition": "test"}
{"idx": "1601", "code": "public void append(int key,E value){\n  if (mSize != 0 && key <= mKeys[mSize - 1]) {\n    put(key,value);\n    return;\n  }\n  if (mGarbage && mSize >= mKeys.length) {\n    gc();\n  }\n  int pos=mSize;\n  if (pos >= mKeys.length) {\n    int n=idealIntArraySize(pos + 1);\n    int[] nkeys=new int[n];\n    Object[] nvalues=new Object[n];\n    System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n    System.arraycopy(mValues,0,nvalues,0,mValues.length);\n    mKeys=nkeys;\n    mValues=nvalues;\n  }\n  mKeys[pos]=key;\n  mValues[pos]=value;\n  mSize=pos + 1;\n}\n", "docstring": "puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .", "partition": "test"}
{"idx": "1602", "code": "public IpcSharedMemorySpace(String tokFileName,int writerPid,int readerPid,int size,boolean reader,IgniteLogger parent) throws IgniteCheckedException {\n  assert size > 0 : \"Size cannot be less than 1 byte\";\n  log=parent.getLogger(IpcSharedMemorySpace.class);\n  opSize=size;\n  shmemPtr=IpcSharedMemoryUtils.allocateSystemResources(tokFileName,size,DEBUG && log.isDebugEnabled());\n  shmemId=IpcSharedMemoryUtils.sharedMemoryId(shmemPtr);\n  semId=IpcSharedMemoryUtils.semaphoreId(shmemPtr);\n  isReader=reader;\n  this.tokFileName=tokFileName;\n  this.readerPid=readerPid;\n  this.writerPid=writerPid;\n  if (DEBUG && log.isDebugEnabled())   log.debug(\"Shared memory space has been created: \" + this);\n}\n", "docstring": "this will allocate system resources for the space .", "partition": "test"}
{"idx": "1603", "code": "@Override public void close(){\n  try {\n    if (connection != null) {\n      connection.close();\n    }\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "close the jdbc connection", "partition": "test"}
{"idx": "1604", "code": "public Version addQualifier(String qualifier){\n  List<String> newQualifiers=new ArrayList<>(this.qualifiers);\n  newQualifiers.add(qualifier);\n  return new Version(major,minor,patch,newQualifiers.toArray(new String[newQualifiers.size()]));\n}\n", "docstring": "creates a new version object from the current one , but append a new qualifier to it .", "partition": "test"}
{"idx": "1605", "code": "public int loadSigned16(int addr){\n  return loadSigned16(addr,AccessSource.CODE);\n}\n", "docstring": "perform a 16bit load where the sign extended result fills the return value", "partition": "test"}
{"idx": "1606", "code": "public static String arrayToHexString(byte[] array){\n  return arrayToHexString(array,0,array.length);\n}\n", "docstring": "helper method to convert a byte [ ", "partition": "test"}
{"idx": "1607", "code": "public static void unregisterBaggageHandler(BaggageHandler handler){\n  handlers.remove(handler);\n}\n", "docstring": "remove an existing baggage handler that was previously registered . method does nothing if the handler isn \"'\" t currently registered .", "partition": "test"}
{"idx": "1608", "code": "public DefaultHeatMapDataset(int xSamples,int ySamples,double minX,double maxX,double minY,double maxY){\n  if (xSamples < 1) {\n    throw new IllegalArgumentException(\"Requires \'xSamples\' > 0\");\n  }\n  if (ySamples < 1) {\n    throw new IllegalArgumentException(\"Requires \'ySamples\' > 0\");\n  }\n  if (Double.isInfinite(minX) || Double.isNaN(minX)) {\n    throw new IllegalArgumentException(\"\'minX\' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(maxX) || Double.isNaN(maxX)) {\n    throw new IllegalArgumentException(\"\'maxX\' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(minY) || Double.isNaN(minY)) {\n    throw new IllegalArgumentException(\"\'minY\' cannot be INF or NaN.\");\n  }\n  if (Double.isInfinite(maxY) || Double.isNaN(maxY)) {\n    throw new IllegalArgumentException(\"\'maxY\' cannot be INF or NaN.\");\n  }\n  this.xSamples=xSamples;\n  this.ySamples=ySamples;\n  this.minX=minX;\n  this.maxX=maxX;\n  this.minY=minY;\n  this.maxY=maxY;\n  this.zValues=new double[xSamples][];\n  for (int x=0; x < xSamples; x++) {\n    this.zValues[x]=new double[ySamples];\n  }\n}\n", "docstring": "creates a new dataset where all the z - values are initially 0 . this is a fixed size array of z - values .", "partition": "test"}
{"idx": "1609", "code": "public static void assertEqualsAnyOrder(EventBean[][] expected,EventBean[][] actual){\n  if (compareArraySize(expected,actual)) {\n    return;\n  }\n  int numMatches=0;\n  boolean[] foundReceived=new boolean[actual.length];\n  for (  EventBean[] expectedObject : expected) {\n    boolean found=false;\n    for (int i=0; i < actual.length; i++) {\n      if (foundReceived[i]) {\n        continue;\n      }\n      boolean match=compareEqualsExactOrder(actual[i],expectedObject);\n      if (match) {\n        found=true;\n        numMatches++;\n        foundReceived[i]=true;\n        break;\n      }\n    }\n    if (!found) {\n      log.error(\".assertEqualsAnyOrder Not found in received results is expected=\" + Arrays.toString(expectedObject));\n      log.error(\".assertEqualsAnyOrder received=\" + Arrays.toString(actual));\n    }\n    ScopeTestHelper.assertTrue(found);\n  }\n  ScopeTestHelper.assertEquals(numMatches,expected.length);\n}\n", "docstring": "compare two 2 - dimensional event arrays .", "partition": "test"}
{"idx": "1610", "code": "private void collectText(){\n  if (textNodeCount > 1) {\n    firstTextNode.setText(textBuffer.toString());\n  }\n  textNodeCount=0;\n}\n", "docstring": "this method breaks concatenation mode . as a side effect it copies the concatenated string to the first text node", "partition": "test"}
{"idx": "1611", "code": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) public static <T extends Annotation>T unproxy(T annotation){\n  Function unproxyFunction=getUnproxyFunction(annotation.annotationType());\n  return (T)unproxyFunction.apply(annotation);\n}\n", "docstring": "convert java proxy annotation to specialized implementation , used to speedup equals / hashcode / tostring methods .", "partition": "test"}
{"idx": "1612", "code": "public static List<Node> parseExpression(Context context,HashSet<String> configNamespaces,String text){\n  return parseExpression(context,configNamespaces,text,0,false);\n}\n", "docstring": "this method should be used to parse an expression , like \" a = b \" . it differs from the parse ( ) methods in it \"'\" s handling of expressions like \" [ a , b ", "partition": "test"}
{"idx": "1613", "code": "public void addTickMarkSection(final Section SECTION){\n  if (null == SECTION)   return;\n  tickMarkSections.add(SECTION);\n  Collections.sort(tickMarkSections,new SectionComparator());\n  fireUpdateEvent(REDRAW_EVENT);\n}\n", "docstring": "adds the given section to the list of tickmark sections .", "partition": "test"}
{"idx": "1614", "code": "protected static double calcQ_i(double f,double lambda){\n  return lambda * Math.exp(-lambda * f);\n}\n", "docstring": "compute q_i ( exponential distribution , inliers )", "partition": "test"}
{"idx": "1615", "code": "void flush(){\n  printStream.flush();\n}\n", "docstring": "flush any io to disk . for testing purposes .", "partition": "test"}
{"idx": "1616", "code": "public CharBuffer delete(int start,int end){\n  int length=length();\n  if (start < 0 || end < start || length < start)   throw new StringIndexOutOfBoundsException();\n  end=Math.min(length,end);\n  int tail=length - end;\n  char[] buffer=buffer();\n  for (int i=0; i < tail; i++) {\n    buffer[start + i]=buffer[end + i];\n  }\n  length(length - (end - start));\n  return this;\n}\n", "docstring": "deletes characters from the buffer .", "partition": "test"}
{"idx": "1617", "code": "public void addListener(SpeedrunsLiveListener listener){\n  listeners.add(listener);\n}\n", "docstring": "adds a listener that receives the data and error messages .", "partition": "test"}
{"idx": "1618", "code": "public int action(String fault,String action){\n  Integer current=get(fault);\n  if (current == null)   throw new IllegalArgumentException(fault);\n  boolean no=action.startsWith(\"no\");\n  if (no)   action=action.substring(2);\n  Integer bit=getAction(action);\n  if (bit == null)   throw new IllegalArgumentException(action);\n  int old=current.intValue();\n  int mask=bit.intValue();\n  int n=(old & (~mask));\n  n=(no) ? n : (n | mask);\n  put(fault,new Integer(n));\n  return n;\n}\n", "docstring": "sets the action bits as appropriate for the given fault and action", "partition": "test"}
{"idx": "1619", "code": "public static <T>T decodeFromBase64(Coder<T> coder,String encodedValue) throws CoderException {\n  return decodeFromSafeStream(coder,new ByteArrayInputStream(Base64.decodeBase64(encodedValue)),Coder.Context.OUTER);\n}\n", "docstring": "parses a value from a base64 - encoded string using the given coder .", "partition": "test"}
{"idx": "1620", "code": "public void validate(Set setData) throws ValidationException {\n  for (Iterator iter=setData.iterator(); iter.hasNext(); ) {\n    performValidation((String)iter.next());\n  }\n}\n", "docstring": "performs validation on a set of string .", "partition": "test"}
{"idx": "1621", "code": "public String add(Object... values){\n  double result=0;\n  for (int i=0; i < values.length; i++) {\n    result+=FunctionHandler.getDouble(values[i]);\n  }\n  return Double.toString(result);\n}\n", "docstring": "adds all values together", "partition": "test"}
{"idx": "1622", "code": "public List<String> listMyDBs(String owner,boolean restricted){\n  Connection conn=null;\n  try {\n    conn=getConnection();\n    return listMyDBs(conn,owner,restricted);\n  }\n catch (  Exception ex) {\n    logger.log(Level.SEVERE,\"Exception\",ex);\n  }\n finally {\n    DBUtils.close(conn);\n  }\n  return null;\n}\n", "docstring": "list database groups the specific user has provided passwords", "partition": "test"}
{"idx": "1623", "code": "protected void doFunction(float[] inputs,int inputOffset,float[] outputs,int outputOffset){\n  float input=inputs[inputOffset];\n  for (int i=0; i < getNumOutputs(); i++) {\n    outputs[i + outputOffset]=getC0(i) + (float)(Math.pow(input,getN()) * (getC1(i) - getC0(i)));\n  }\n}\n", "docstring": "calculate the function value for the input . for each output ( j ) , the function value is : c0 ( j ) + x ^ n * ( c1 ( j ) - c0 ( j ) )", "partition": "test"}
{"idx": "1624", "code": "public int compare(Object o1,Object o2){\n  return comparator.compare(o1,o2);\n}\n", "docstring": "call the comparator on the column", "partition": "test"}
{"idx": "1625", "code": "public void addCheckBoxActionListener(ActionListener al){\n  m_enableDistributedExperiment.addActionListener(al);\n}\n", "docstring": "enable objects to listen for changes to the check box", "partition": "test"}
{"idx": "1626", "code": "GF256Poly addOrSubtract(GF256Poly other){\n  if (!field.equals(other.field)) {\n    throw new IllegalArgumentException(\"GF256Polys do not have same GF256 field\");\n  }\n  if (isZero()) {\n    return other;\n  }\n  if (other.isZero()) {\n    return this;\n  }\n  int[] smallerCoefficients=this.coefficients;\n  int[] largerCoefficients=other.coefficients;\n  if (smallerCoefficients.length > largerCoefficients.length) {\n    int[] temp=smallerCoefficients;\n    smallerCoefficients=largerCoefficients;\n    largerCoefficients=temp;\n  }\n  int[] sumDiff=new int[largerCoefficients.length];\n  int lengthDiff=largerCoefficients.length - smallerCoefficients.length;\n  System.arraycopy(largerCoefficients,0,sumDiff,0,lengthDiff);\n  for (int i=lengthDiff; i < largerCoefficients.length; i++) {\n    sumDiff[i]=GF256.addOrSubtract(smallerCoefficients[i - lengthDiff],largerCoefficients[i]);\n  }\n  return new GF256Poly(field,sumDiff);\n}\n", "docstring": "gf addition or subtraction ( they are identical for a gf ( 2 ^ n )", "partition": "test"}
{"idx": "1627", "code": "@Override public String toString(){\n  StringBuffer sb=new StringBuffer();\n  sb.append(type);\n  sb.append(\"/\");\n  sb.append(subType);\n  for (  String name : attributes.keySet()) {\n    if (inferredCharset && ATTR_CHARSET.equals(name)) {\n      continue;\n    }\n    sb.append(\";\");\n    sb.append(name);\n    sb.append(\"=\");\n    String value=attributes.get(name);\n    Matcher tokenMatcher=TOKEN_PATTERN.matcher(value);\n    if (tokenMatcher.matches()) {\n      sb.append(value);\n    }\n else {\n      sb.append(\"\\\"\" + value + \"\\\"\");\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "generates the content - type value", "partition": "test"}
{"idx": "1628", "code": "public static long firstFieldOffset(Class clazz){\n  long minSize=roundUpTo8(headerSize(clazz));\n  while (clazz != Object.class) {\n    for (    Field f : clazz.getDeclaredFields()) {\n      if ((f.getModifiers() & Modifier.STATIC) == 0) {\n        long offset=unsafe.objectFieldOffset(f);\n        if (offset < minSize) {\n          minSize=offset;\n        }\n      }\n    }\n    clazz=clazz.getSuperclass();\n  }\n  return minSize;\n}\n", "docstring": "returns the offset of the first field in the range [ headersize , sizeof ", "partition": "test"}
{"idx": "1629", "code": "public final V extractFirst(){\n  if (size() > 0) {\n    if (GWT.isScript()) {\n      V ret=jsArray.get(0);\n      jsArray.remove(0);\n      return ret;\n    }\n else {\n      return javaArray.remove(0);\n    }\n  }\n  return null;\n}\n", "docstring": "retrieve the first element and remove it from the list", "partition": "test"}
{"idx": "1630", "code": "@Override public void actionPerformed(ActionEvent event){\n  String command=event.getActionCommand();\n  if (command.equals(\"SelectLabelFont\")) {\n    attemptLabelFontSelection();\n  }\n else   if (command.equals(\"SelectLabelPaint\")) {\n    attemptModifyLabelPaint();\n  }\n else   if (command.equals(\"SelectTickLabelFont\")) {\n    attemptTickLabelFontSelection();\n  }\n}\n", "docstring": "handles user interaction with the property panel .", "partition": "test"}
{"idx": "1631", "code": "public static void upgradeServerInstance(SSOToken ssoToken,String instanceName,String instanceId,Map<String,String> upgradedValues) throws SMSException, SSOException, ConfigurationException, IOException {\n  ServiceConfig sc=getServerConfig(ssoToken,instanceName);\n  if (sc != null) {\n    Map map=sc.getAttributes();\n    map.remove(ATTR_PARENT_SITE_ID);\n    Set newSet=getPropertiesSet(upgradedValues);\n    map.put(ATTR_SERVER_CONFIG,newSet);\n    sc.setAttributes(map);\n  }\n else {\n    throw new ConfigurationException(\"Unable to upgrade server \" + \"default properties: no properties found!\");\n  }\n}\n", "docstring": "upgrades a server instance .", "partition": "test"}
{"idx": "1632", "code": "public static <T>T instance(Class<T> clazz){\n  try {\n    return clazz.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "docstring": "creates a new instance of the class represented by the given class object", "partition": "test"}
{"idx": "1633", "code": "public GenericSipMsrpSession createMsrpSession(ContactId contact,String featureTag,String[] acceptTypes,String[] acceptWrappedTypes){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Initiate a MSRP session with contact \" + contact);\n  }\n  return new OriginatingSipMsrpSession(this,contact,featureTag,mRcsSettings,System.currentTimeMillis(),mContactManager,acceptTypes,acceptWrappedTypes);\n}\n", "docstring": "initiate a msrp session", "partition": "test"}
{"idx": "1634", "code": "protected void drawMark(Graphics2D g2,float x,float y,Color color){\n  Rectangle2D bounds=mark.getBounds2D();\n  float w=(float)bounds.getWidth();\n  float h=(float)bounds.getHeight();\n  x=x - (w / 2);\n  y=y - (h / 2);\n  g2.translate(x,y);\n  if (color == null) {\n    if (markFillPaint != null) {\n      g2.setPaint(markFillPaint);\n      g2.fill(mark);\n    }\n  }\n else {\n    g2.setPaint(color);\n    g2.fill(mark);\n  }\n  g2.setPaint(markPaint);\n  g2.setStroke(markStroke);\n  g2.draw(mark);\n  g2.translate(-x,-y);\n  Rectangle2D rect=new Rectangle2D.Float(x,y,w,h);\n  markBounds.add(rect);\n}\n", "docstring": "draw a mark transforming co - ordinates to each axis", "partition": "test"}
{"idx": "1635", "code": "public void componentResized(ComponentEvent e){\n  if (logger.isLoggable(Level.FINE)) {\n    logger.fine(\"Size changed: \" + getWidth() + \" x \"+ getHeight());\n  }\n  projection.setWidth(getWidth());\n  projection.setHeight(getHeight());\n  fireProjectionChanged();\n}\n", "docstring": "componentlistener interface method . should not be called directly . invoked when component has been resized , and kicks off a projection change .", "partition": "test"}
{"idx": "1636", "code": "public static String byteArrayToHexString(byte[] block,int offset,int length){\n  StringBuffer buf=new StringBuffer();\n  int len=block.length;\n  length=length + offset;\n  if ((len < length)) {\n    length=len;\n  }\n  for (int i=0 + offset; i < length; i++) {\n    byte2hex(block[i],buf);\n    if (i < length - 1) {\n      buf.append(':');\n    }\n  }\n  return buf.toString();\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "1637", "code": "private void changeValue(AbstractStorageLabel<Object> label,Object newValue){\n  if (!Objects.equals(label.getValue(),newValue)) {\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.preLabelValueChange(label);\n      }\n    }\n    label.setValue(newValue);\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.postLabelValueChange(label);\n      }\n    }\n  }\n}\n", "docstring": "reforms the value change and informs the listeners .", "partition": "test"}
{"idx": "1638", "code": "public void write(byte[] b,int offset,int length) throws IOException {\n  if (entry.getMethod() == DEFLATED) {\n    if (length > 0) {\n      if (!def.finished()) {\n        def.setInput(b,offset,length);\n        while (!def.needsInput()) {\n          deflate();\n        }\n      }\n    }\n  }\n else {\n    writeOut(b,offset,length);\n    written+=length;\n  }\n  crc.update(b,offset,length);\n}\n", "docstring": "writes bytes to zip entry .", "partition": "test"}
{"idx": "1639", "code": "public void updatePoint(float x,float y){\n  if (Math.sqrt(x * x + y * y) > 1.5)   if (listener != null) {\n    listener.onAngleChangedListener(getAngle(x,-y));\n  }\n}\n", "docstring": "update the gravity point only if a the gravity vector is longer than the threshold", "partition": "test"}
{"idx": "1640", "code": "@Override public int clampViewPositionHorizontal(View child,int left,int dx){\n  if (mDraggedView == null) {\n    return 0;\n  }\n  final int leftBound=0 - MAX_OVERFLOW - (mColumnSizeSide / 2);\n  final int rightBound=getWidth() + MAX_OVERFLOW + (mColumnSizeSide / 2);\n  return Math.min(Math.max(left,leftBound),rightBound);\n}\n", "docstring": "override method used to configure the horizontal drag . restrict the motion of the dragged child view along the horizontal axis .", "partition": "test"}
{"idx": "1641", "code": "HttpRequestWrapper(HttpServletRequest request){\n  super(request);\n}\n", "docstring": "constructs a request object wrapping the given request .", "partition": "test"}
{"idx": "1642", "code": "private int convertToPanelX(double xval){\n  double temp=(xval - m_minX) / m_rangeX;\n  temp=temp * m_panelWidth;\n  return (int)temp;\n}\n", "docstring": "convert an x coordinate from the instance space to the panel space .", "partition": "test"}
{"idx": "1643", "code": "public void forward(HttpServerRequest request){\n  forward(request,null);\n}\n", "docstring": "handles the request and forwards it to the hook specific destination .", "partition": "test"}
{"idx": "1644", "code": "private Set<String> primaryKeys(PreparedStatement stmt,String owner,String tbl) throws SQLException {\n  Set<String> pkCols=new HashSet<>();\n  stmt.setString(1,owner);\n  stmt.setString(2,tbl);\n  try (ResultSet pkRs=stmt.executeQuery()){\n    while (pkRs.next())     pkCols.add(pkRs.getString(1));\n  }\n   return pkCols;\n}\n", "docstring": "retrieve primary key columns .", "partition": "test"}
{"idx": "1645", "code": "public static long readUINT32(InputStream stream) throws IOException {\n  long result=0;\n  for (int i=0; i <= 24; i+=8) {\n    result|=(long)stream.read() << i;\n  }\n  return result;\n}\n", "docstring": "reads 4 bytes from stream and interprets them as uint32 . < br >", "partition": "test"}
{"idx": "1646", "code": "private Token toPrefixToken(ILeafNode leaf){\n  Lexer lexer=new InternalN4JSLexer();\n  String text=leaf.getText();\n  String prefix=text.substring(0,endOffset - leaf.getTotalOffset());\n  ANTLRStringStream stream=new ANTLRStringStream(prefix);\n  lexer.setCharStream(stream);\n  Token nextToken=lexer.nextToken();\n  return new CommonToken(nextToken.getType(),nextToken.getText());\n}\n", "docstring": "produce an antlr token for the prefix of the given leaf that overlaps the requested region", "partition": "test"}
{"idx": "1647", "code": "protected void add(CSVRecord record){\n  records.add(Objects.requireNonNull(record));\n}\n", "docstring": "adds the given record to this data .", "partition": "test"}
{"idx": "1648", "code": "private void scheduledEnqueueSend(){\n  schedulerQueueSize.decrementAndGet();\n  scheduled.set(false);\n  enqueueSendWithErrorLogging();\n}\n", "docstring": "decrements the scheduled queue counter and enqueues the request .", "partition": "test"}
{"idx": "1649", "code": "public static String join(char[] self,String separator){\n  StringBuilder buffer=new StringBuilder();\n  boolean first=true;\n  if (separator == null)   separator=\"\";\n  for (  char next : self) {\n    if (first) {\n      first=false;\n    }\n else {\n      buffer.append(separator);\n    }\n    buffer.append(next);\n  }\n  return buffer.toString();\n}\n", "docstring": "concatenates the string representation of each items in this array , with the given string as a separator between each item .", "partition": "test"}
{"idx": "1650", "code": "private <T>BindingAmp<T> findObjectBinding(Key<T> key){\n  Objects.requireNonNull(key);\n  if (key.qualifiers().length != 1) {\n    throw new IllegalArgumentException();\n  }\n  return (BindingAmp)findBinding(Key.of(Object.class,key.qualifiers()[0]));\n}\n", "docstring": "returns an object producer .", "partition": "test"}
{"idx": "1651", "code": "private void initComputeProgram(){\n  glUseProgram(computeProgram);\n  IntBuffer workGroupSize=BufferUtils.createIntBuffer(3);\n  glGetProgramiv(computeProgram,GL_COMPUTE_WORK_GROUP_SIZE,workGroupSize);\n  workGroupSizeX=workGroupSize.get(0);\n  workGroupSizeY=workGroupSize.get(1);\n  timeUniform=glGetUniformLocation(computeProgram,\"time\");\n  blendFactorUniform=glGetUniformLocation(computeProgram,\"blendFactor\");\n  lightRadiusUniform=glGetUniformLocation(computeProgram,\"lightRadius\");\n  IntBuffer props=BufferUtils.createIntBuffer(1);\n  IntBuffer params=BufferUtils.createIntBuffer(1);\n  props.put(0,GL_BUFFER_BINDING);\n  int objectsResourceIndex=glGetProgramResourceIndex(computeProgram,GL_SHADER_STORAGE_BLOCK,\"Objects\");\n  glGetProgramResourceiv(computeProgram,GL_SHADER_STORAGE_BLOCK,objectsResourceIndex,props,null,params);\n  objectsSsboBinding=params.get(0);\n  int trianglesResourceIndex=glGetProgramResourceIndex(computeProgram,GL_SHADER_STORAGE_BLOCK,\"Triangles\");\n  glGetProgramResourceiv(computeProgram,GL_SHADER_STORAGE_BLOCK,trianglesResourceIndex,props,null,params);\n  trianglesSsboBinding=params.get(0);\n  int loc=glGetUniformLocation(computeProgram,\"framebufferImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  framebufferImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldPositionImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldPositionImageBinding=params.get(0);\n  loc=glGetUniformLocation(computeProgram,\"worldNormalImage\");\n  glGetUniformiv(computeProgram,loc,params);\n  worldNormalImageBinding=params.get(0);\n  glUseProgram(0);\n}\n", "docstring": "initialize the compute shader .", "partition": "test"}
{"idx": "1652", "code": "public boolean ifTaskCompletedSuccessOrFailureFromResponse(ResponseOnSingeRequest myResponse){\n  boolean isCompleted=false;\n  try {\n    if (myResponse == null || myResponse.isFailObtainResponse()) {\n      return isCompleted;\n    }\n    String responseBody=myResponse.getResponseBody();\n    if (responseBody.matches(successRegex) || responseBody.matches(failureRegex)) {\n      isCompleted=true;\n    }\n  }\n catch (  Exception t) {\n    logger.error(\"fail\" + t);\n  }\n  return isCompleted;\n}\n", "docstring": "if task completed success or failure from response .", "partition": "test"}
{"idx": "1653", "code": "public void centerHorizontal(ArrayList<Integer> nodes){\n  if (m_bNeedsUndoAction) {\n    addUndoAction(new centerHorizontalAction(nodes));\n  }\n  int nMinY=-1;\n  int nMaxY=-1;\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nY=getPositionY(nodes.get(iNode));\n    if (nY < nMinY || iNode == 0) {\n      nMinY=nY;\n    }\n    if (nY > nMaxY || iNode == 0) {\n      nMaxY=nY;\n    }\n  }\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nNode=nodes.get(iNode);\n    m_nPositionY.set(nNode,(nMinY + nMaxY) / 2);\n  }\n}\n", "docstring": "center set of nodes half way between left and right most node in the list", "partition": "test"}
{"idx": "1654", "code": "protected void appendText(final String text){\n  if (text != null) {\n    textBody.append(text);\n  }\n}\n", "docstring": "append text to the outgoing email body .", "partition": "test"}
{"idx": "1655", "code": "public void onRestoreInstanceState(Bundle savedInstanceState){\n  mSelectedPositions.addAll(savedInstanceState.getIntegerArrayList(TAG));\n  Log.d(TAG,\"Restore selection \" + mSelectedPositions);\n}\n", "docstring": "restores the previous state of the selection on the items .", "partition": "test"}
{"idx": "1656", "code": "public Hour(int hour,Day day){\n  ParamChecks.nullNotPermitted(day,\"day\");\n  this.hour=(byte)hour;\n  this.day=day;\n  peg(Calendar.getInstance());\n}\n", "docstring": "constructs a new hour .", "partition": "test"}
{"idx": "1657", "code": "public void undo(){\n  if (--m_tempUndoIndex < 0) {\n    m_tempUndoIndex=m_tempUndoFiles.length - 1;\n  }\n  if (m_tempUndoFiles[m_tempUndoIndex] != null) {\n    AbstractFileLoader loader=ConverterUtils.getLoaderForFile(m_tempUndoFiles[m_tempUndoIndex]);\n    try {\n      loader.setFile(m_tempUndoFiles[m_tempUndoIndex]);\n      setInstancesFromFile(loader);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      m_Log.logMessage(e.toString());\n      JOptionPane.showMessageDialog(PreprocessPanel.this,\"Cannot perform undo operation!\\n\" + e.toString(),\"Undo\",JOptionPane.ERROR_MESSAGE);\n    }\n    m_tempUndoFiles[m_tempUndoIndex]=null;\n  }\n  int temp=m_tempUndoIndex - 1;\n  if (temp < 0) {\n    temp=m_tempUndoFiles.length - 1;\n  }\n  m_UndoBut.setEnabled(m_tempUndoFiles[temp] != null);\n}\n", "docstring": "reverts to the last backed up version of the dataset .", "partition": "test"}
{"idx": "1658", "code": "public static boolean isConnectedUsingWifi(){\n  Context context=FeApp.getAppContext();\n  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo ni=cm.getActiveNetworkInfo();\n  return ni != null && ni.isConnected() == true && ni.getType() == ConnectivityManager.TYPE_WIFI;\n}\n", "docstring": "checks to see if we are connected using wifi", "partition": "test"}
{"idx": "1659", "code": "public void close() throws IOException {\n  if (writer != null)   writer.flushBuffer();\n}\n", "docstring": "done with this responsewriter . . . make sure any buffers are flushed to writer", "partition": "test"}
{"idx": "1660", "code": "public Process(final File file,final ProgressListener progressListener) throws IOException, XMLException {\n  this.processLocation=new FileProcessLocation(file);\n  initContext();\n  Reader in=null;\n  try {\n    in=new InputStreamReader(new FileInputStream(file),\"UTF-8\");\n    readProcess(in,progressListener);\n  }\n catch (  IOException e) {\n    throw e;\n  }\n finally {\n    if (in != null) {\n      in.close();\n    }\n  }\n}\n", "docstring": "creates a new process from the given process file . this might have been created with the gui beforehand .", "partition": "test"}
{"idx": "1661", "code": "public static String extractMusicIDFromMediaID(@NonNull String mediaID){\n  int pos=mediaID.indexOf(LEAF_SEPARATOR);\n  if (pos >= 0) {\n    return mediaID.substring(pos + 1);\n  }\n  return null;\n}\n", "docstring": "extracts unique musicid from the mediaid . mediaid is , by this sample \"'\" s convention , a concatenation of category ( eg \" by_genre \" ) , categoryvalue ( eg \" classical \" ) and unique musicid . this is necessary so we know where the user selected the music from , when the music exists in more than one music list , and thus we are able to correctly build the playing queue .", "partition": "test"}
{"idx": "1662", "code": "public static long[] values(Long[] array){\n  long[] dest=new long[array.length];\n  for (int i=0; i < array.length; i++) {\n    Long v=array[i];\n    if (v != null) {\n      dest[i]=v.longValue();\n    }\n  }\n  return dest;\n}\n", "docstring": "converts to primitive array .", "partition": "test"}
{"idx": "1663", "code": "@Override public void processNewLines(String[] lines){\n  for (  String line : lines) {\n    if (line.startsWith(\"idx\")) {\n      continue;\n    }\n    if (line.contains(\"No such file\")) {\n      myIsFileMissing=true;\n      return;\n    }\n    String[] values=line.split(LINE_SPLIT_REGEX);\n    if (values.length < INDEX_OF_TX_BYTES) {\n      continue;\n    }\n    try {\n      int lineUid=Integer.parseInt(values[INDEX_OF_UID]);\n      if (myUid == lineUid) {\n        int tempRxBytes=Integer.parseInt(values[INDEX_OF_RX_BYTES]);\n        int tempTxBytes=Integer.parseInt(values[INDEX_OF_TX_BYTES]);\n        if (tempRxBytes < 0 || tempTxBytes < 0) {\n          LOG.warning(String.format(\"Negative rxBytes %1$d and/or txBytes %2$d in %3$s\",tempRxBytes,tempTxBytes,line));\n          continue;\n        }\n        myRxBytes+=tempRxBytes;\n        myTxBytes+=tempTxBytes;\n      }\n    }\n catch (    NumberFormatException e) {\n      LOG.warning(String.format(\"Expected int value, instead got uid %1$s, rxBytes %2$s, txBytes %3$s in %4$s\",values[INDEX_OF_UID],values[INDEX_OF_RX_BYTES],values[INDEX_OF_TX_BYTES],line));\n    }\n  }\n}\n", "docstring": "processes the stats line to sum up all network stats belonging to the uid .", "partition": "test"}
{"idx": "1664", "code": "public String toString(){\n  String str=\"\";\n  String followedBy=\"\";\n  int lastType=-1;\n  String lastString=\"\";\n  int singlesCount=0;\n  for (Enumeration e=formatConstraints.elements(); e.hasMoreElements(); ) {\n    FormatConstraint constraint=(FormatConstraint)e.nextElement();\n    if (constraint.count == FormatConstraint.COUNT_EXACTLY_ONE) {\n      if (lastType != -1) {\n        if (lastType != constraint.type) {\n          str+=followedBy + singlesCount + lastString;\n          followedBy=\" followed by \";\n          singlesCount=1;\n          lastType=constraint.type;\n          lastString=constraint.toString();\n        }\n else {\n          singlesCount++;\n        }\n      }\n else {\n        lastType=constraint.type;\n        lastString=constraint.toString();\n        singlesCount=1;\n      }\n    }\n else {\n      if (lastType != -1) {\n        str+=followedBy + singlesCount + lastString;\n        followedBy=\" followed by \";\n        lastType=-1;\n        singlesCount=0;\n        lastString=\"\";\n      }\n      str+=followedBy + constraint.toString();\n      followedBy=\" followed by \";\n    }\n  }\n  if (lastType != -1) {\n    str+=followedBy + singlesCount + lastString;\n  }\n  return str;\n}\n", "docstring": "a printout of a user - friendly string describing the format", "partition": "test"}
{"idx": "1665", "code": "public void readData(DataInput din) throws IOException {\n  din.readShort();\n  count=din.readUnsignedShort();\n  registers=new InputRegister[count];\n  for (int i=0; i < count; i++) {\n    registers[i]=new SimpleInputRegister(din.readShort());\n  }\n}\n", "docstring": "readdata - - input the modbus message from din . if there was a header , such as for modbus / tcp , it will have been read already .", "partition": "test"}
{"idx": "1666", "code": "public void adjustIndentation(int delta){\n  if (delta < 0) {\n    indentationLevel=Math.max(0,indentationLevel + delta);\n  }\n else {\n    indentationLevel+=delta;\n  }\n}\n", "docstring": "adjusts the current indentation level of this log stream .", "partition": "test"}
{"idx": "1667", "code": "public int capacity(){\n  return capacity.get();\n}\n", "docstring": "retrieves the maximum capacity of the map .", "partition": "test"}
{"idx": "1668", "code": "protected static token do_code_string() throws java.io.IOException {\n  StringBuffer result=new StringBuffer();\n  advance();\n  advance();\n  while (!(next_char == \':\' && next_char2 == \'}\')) {\n    if (next_char == EOF_CHAR) {\n      emit_error(\"Specification file ends inside a code string\");\n      break;\n    }\n    result.append(new Character((char)next_char));\n    advance();\n  }\n  advance();\n  advance();\n  return new str_token(sym.CODE_STRING,result.toString());\n}\n", "docstring": "swallow up a code string . code strings begin with \" { : \" and include all characters up to the first occurrence of \" : } \" ( there is no way to include \" : } \" inside a code string ) . the routine returns an str_token object suitable for return by the scanner .", "partition": "test"}
{"idx": "1669", "code": "public String random(Object omin,Object omax){\n  int min=FunctionHandler.getInt(omin);\n  int max=FunctionHandler.getInt(omax);\n  if (max > min) {\n    return Integer.toString(rnd.nextInt(max - min) + min);\n  }\n  return \"0\";\n}\n", "docstring": "returns a random number between min ( inclusive ) and max ( exclusive )", "partition": "test"}
{"idx": "1670", "code": "public void test_reopen01(){\n  final IRawStore store=new SimpleMemoryRawStore();\n  final BTree btree;\n{\n    IndexMetadata md=new IndexMetadata(UUID.randomUUID());\n    md.setBranchingFactor(3);\n    btree=BTree.create(store,md);\n  }\n  assertTrue(btree.isOpen());\n  btree.close();\n  assertFalse(btree.isOpen());\n  try {\n    btree.close();\n    fail(\"Expecting: \" + IllegalStateException.class);\n  }\n catch (  IllegalStateException ex) {\n    if (log.isInfoEnabled())     log.info(\"Ignoring expected exception: \" + ex);\n  }\n  assertNotNull(btree.getRoot());\n  assertTrue(btree.isOpen());\n}\n", "docstring": "test close on a new tree - should force the root to the store since a new root is dirty ( if empty ) . reopen should then reload the empty root and on life goes .", "partition": "test"}
{"idx": "1671", "code": "public static File searchPaths(Iterable<? extends File> paths,String relFile){\n  for (  File path : paths) {\n    File f=new File(path,relFile);\n    if (f.exists()) {\n      return path;\n    }\n  }\n  return null;\n}\n", "docstring": "given a relative file path and a list of \" search paths \" returns the search path where the file was located", "partition": "test"}
{"idx": "1672", "code": "private void loadConfigurationFromJvmParameters(){\n  String repositoryProperty=System.getProperty(REPOSITORY_PROPERTY);\n  if (null != repositoryProperty) {\n    String[] repositoryIpHost=repositoryProperty.split(\":\");\n    if (repositoryIpHost.length == 2) {\n      String repositoryIp=repositoryIpHost[0];\n      String repositoryPort=repositoryIpHost[1];\n      if (StringUtils.isNotBlank(repositoryIp) && StringUtils.isNotBlank(repositoryPort)) {\n        log.info(\"Repository information found in the JVM parameters: IP=\" + repositoryIp + \" Port=\"+ repositoryPort);\n        try {\n          int port=Integer.parseInt(repositoryPort);\n          setRepository(repositoryIp,port);\n        }\n catch (        Exception e) {\n          log.warn(\"Repository could not be defined from the data in the JVM parameters\",e);\n        }\n      }\n    }\n  }\n  String agentName=System.getProperty(AGENT_NAME_PROPERTY);\n  if (StringUtils.isNotBlank(agentName)) {\n    try {\n      log.info(\"Agent name found in the JVM parameters: AgentName=\" + agentName);\n      setAgentName(agentName);\n    }\n catch (    Exception e) {\n      log.warn(\"Agent name could not be defined from the data in the JVM parameters\",e);\n    }\n  }\n else {\n    try {\n      setAgentName(DEFAULT_AGENT_NAME);\n    }\n catch (    StorageException e) {\n      log.warn(\"Agent name could not be defined from default agent name\",e);\n    }\n  }\n}\n", "docstring": "checks if the jvm parameters have the repository and agent information .", "partition": "test"}
{"idx": "1673", "code": "public boolean softSignin() throws IOException {\n  if (url == null) {\n    throw new IllegalStateException(\"Null host\");\n  }\n  checkResolveHost();\n  if (sessionId != null) {\n    if (checkAuthorized(getAuthCheckUrl(sessionId))) {\n      LOGGER.fine(\"Skipping soft init; session ID already exists - \" + sessionId);\n      return true;\n    }\n else {\n      sessionId=null;\n    }\n  }\n  long id=loadSessionId();\n  if (id == 0) {\n    return false;\n  }\n  boolean authorized=checkAuthorized(getAuthCheckUrl(id));\n  if (authorized) {\n    LOGGER.info(\"Authorized with session ID: \" + id);\n    this.sessionId=id;\n  }\n  return authorized;\n}\n", "docstring": "if the user can be authenticated due to an existing session id , do so", "partition": "test"}
{"idx": "1674", "code": "private void testViewAlterAndCommandCache() throws SQLException {\n  deleteDb(\"view\");\n  Connection conn=getConnection(\"view\");\n  Statement stat=conn.createStatement();\n  stat.execute(\"create table t0(id int primary key)\");\n  stat.execute(\"create table t1(id int primary key)\");\n  stat.execute(\"insert into t0 values(0)\");\n  stat.execute(\"insert into t1 values(1)\");\n  stat.execute(\"create view v1 as select * from t0\");\n  ResultSet rs=stat.executeQuery(\"select * from v1\");\n  assertTrue(rs.next());\n  assertEquals(0,rs.getInt(1));\n  stat.execute(\"create or replace view v1 as select * from t1\");\n  rs=stat.executeQuery(\"select * from v1\");\n  assertTrue(rs.next());\n  assertEquals(1,rs.getInt(1));\n  conn.close();\n  deleteDb(\"view\");\n}\n", "docstring": "make sure that when we change a view , that change in reflected in other sessions command cache .", "partition": "test"}
{"idx": "1675", "code": "protected static boolean approxUnit(final StringBuilder sbuf,final int amount,final int size,final String name){\n  int count=amount / size;\n  int remainder;\n  if (count == 0) {\n    return false;\n  }\n  remainder=amount - (count * size);\n  if (remainder >= (size * 95 / 100)) {\n    count++;\n    sbuf.append(count);\n  }\n else   if (remainder >= (size * 3 / 4)) {\n    count++;\n    sbuf.append(\"just under \");\n    sbuf.append(count);\n  }\n else   if (remainder >= (size * 1 / 4)) {\n    sbuf.append(\"about \");\n    sbuf.append(count);\n    sbuf.append(\" and a half\");\n    count=2;\n  }\n else   if (remainder >= (size * 5 / 100)) {\n    sbuf.append(\"just over \");\n    sbuf.append(count);\n  }\n else {\n    sbuf.append(count);\n  }\n  sbuf.append(\' \');\n  sbuf.append(Grammar.plnoun(count,name));\n  return true;\n}\n", "docstring": "for a given amount and unit size , generate the approximate value .", "partition": "test"}
{"idx": "1676", "code": "public static Element createElement(Document doc,String tag,String nsURI,String prefix){\n  String qName=(prefix == null || prefix.length() == 0) ? tag : prefix + \":\" + tag;\n  return doc.createElementNS(nsURI,qName);\n}\n", "docstring": "creates an element in the specified namespace , with the specified tag and namespace prefix .", "partition": "test"}
{"idx": "1677", "code": "public static void modifyFile(File file,Function<String,String> modifier) throws IOException {\n  String content=new String(Files.toByteArray(file),StandardCharsets.UTF_8);\n  String result=modifier.apply(content);\n  Files.write(result.getBytes(StandardCharsets.UTF_8),file);\n}\n", "docstring": "modifies the given file in place .", "partition": "test"}
{"idx": "1678", "code": "protected double LLToWorldReturningLon(double lat,double lon,Point2D lp){\n  double phi_deg=lat;\n  double phi=ProjMath.degToRad(phi_deg);\n  double lamba_deg=lon;\n  double lamba=ProjMath.degToRad(lamba_deg);\n  double dlamda=lamba - lamdaf;\n  if (dlamda > Math.PI) {\n    dlamda-=MoreMath.TWO_PI_D;\n  }\n else   if (dlamda < -Math.PI) {\n    dlamda+=MoreMath.TWO_PI_D;\n  }\n  double e=ellps.ecc;\n  double r=0.0d;\n  if (!MoreMath.approximately_equal(Math.abs(phi),MoreMath.HALF_PI,EPS10)) {\n    double t=lambTsfn(phi,Math.sin(phi),e);\n    r=ellps.radius * F * Math.pow(t,n);\n  }\n  double theta=n * dlamda;\n  double easting=falseEasting + r * Math.sin(theta - alpha);\n  double northing=falseNorthing + rf - r * Math.cos(theta - alpha);\n  lp.setLocation(easting,northing);\n  return dlamda;\n}\n", "docstring": "lltoworld that returns normalized longitude in radians , to be used for more calculations in some methods . do not provide a null lp here if you want the world coordinates provided back to you .", "partition": "test"}
{"idx": "1679", "code": "protected boolean removeTurntable(LayoutTurntable o){\n  if (!noWarnTurntable) {\n    int selectedValue=JOptionPane.showOptionDialog(this,rb.getString(\"Question4r\"),Bundle.getMessage(\"WarningTitle\"),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,new Object[]{Bundle.getMessage(\"ButtonYes\"),Bundle.getMessage(\"ButtonNo\"),rb.getString(\"ButtonYesPlus\")},Bundle.getMessage(\"ButtonNo\"));\n    if (selectedValue == 1) {\n      return (false);\n    }\n    if (selectedValue == 2) {\n      noWarnTurntable=true;\n    }\n  }\n  if (selectedObject == o) {\n    selectedObject=null;\n  }\n  if (prevSelectedObject == o) {\n    prevSelectedObject=null;\n  }\n  for (int j=0; j < o.getNumberRays(); j++) {\n    TrackSegment t=o.getRayConnectOrdered(j);\n    if (t != null) {\n      substituteAnchor(o.getRayCoordsIndexed(j),o,t);\n    }\n  }\n  for (int i=0; i < turntableList.size(); i++) {\n    LayoutTurntable lx=turntableList.get(i);\n    if (lx == o) {\n      turntableList.remove(i);\n      o.remove();\n      setDirty(true);\n      repaint();\n      return (true);\n    }\n  }\n  return (false);\n}\n", "docstring": "remove a layout turntable", "partition": "test"}
{"idx": "1680", "code": "public INDArray asMatrix(BufferedImage image){\n  if (channels == 3) {\n    return toBgr(image);\n  }\n else {\n    image=scalingIfNeed(image,true);\n    int w=image.getWidth();\n    int h=image.getHeight();\n    INDArray ret=Nd4j.create(h,w);\n    for (int i=0; i < h; i++) {\n      for (int j=0; j < w; j++) {\n        ret.putScalar(new int[]{i,j},image.getRGB(i,j));\n      }\n    }\n    return ret;\n  }\n}\n", "docstring": "convert an bufferedimage to a matrix", "partition": "test"}
{"idx": "1681", "code": "public int scheduledQueueSize(){\n  return schedulerQueueSize.get();\n}\n", "docstring": "get the total number of scheduled requests .", "partition": "test"}
{"idx": "1682", "code": "public DGeneralNameChooser(JFrame parent,String title,GeneralName generalName){\n  super(parent,title,ModalityType.DOCUMENT_MODAL);\n  initComponents(generalName);\n}\n", "docstring": "constructs a new dgeneralnamechooser dialog .", "partition": "test"}
{"idx": "1683", "code": "private void addLimitedMitreJoin(LineSegment offset0,LineSegment offset1,double distance,double mitreLimit){\n  Coordinate basePt=seg0.p1;\n  double ang0=Angle.angle(basePt,seg0.p0);\n  double ang1=Angle.angle(basePt,seg1.p1);\n  double angDiff=Angle.angleBetweenOriented(seg0.p0,basePt,seg1.p1);\n  double angDiffHalf=angDiff / 2;\n  double midAng=Angle.normalize(ang0 + angDiffHalf);\n  double mitreMidAng=Angle.normalize(midAng + Math.PI);\n  double mitreDist=mitreLimit * distance;\n  double bevelDelta=mitreDist * Math.abs(Math.sin(angDiffHalf));\n  double bevelHalfLen=distance - bevelDelta;\n  double bevelMidX=basePt.x + mitreDist * Math.cos(mitreMidAng);\n  double bevelMidY=basePt.y + mitreDist * Math.sin(mitreMidAng);\n  Coordinate bevelMidPt=new Coordinate(bevelMidX,bevelMidY);\n  LineSegment mitreMidLine=new LineSegment(basePt,bevelMidPt);\n  Coordinate bevelEndLeft=mitreMidLine.pointAlongOffset(1.0,bevelHalfLen);\n  Coordinate bevelEndRight=mitreMidLine.pointAlongOffset(1.0,-bevelHalfLen);\n  if (side == Position.LEFT) {\n    segList.addPt(bevelEndLeft);\n    segList.addPt(bevelEndRight);\n  }\n else {\n    segList.addPt(bevelEndRight);\n    segList.addPt(bevelEndLeft);\n  }\n}\n", "docstring": "adds a limited mitre join connecting the two reflex offset segments . a limited mitre is a mitre which is beveled at the distance determined by the mitre ratio limit .", "partition": "test"}
{"idx": "1684", "code": "public void testMultiplyDiffScalePosNeg(){\n  String a=\"1231212478987482988429808779810457634781384756794987\";\n  int aScale=10;\n  String b=\"747233429293018787918347987234564568\";\n  int bScale=-10;\n  String c=\"920003122862175749786430095741145455670101391569026662845893091880727173060570190220616\";\n  int cScale=0;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  BigDecimal result=aNumber.multiply(bNumber);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",cScale,result.scale());\n}\n", "docstring": "multiply two numbers of different scales", "partition": "test"}
{"idx": "1685", "code": "public static String formatSimpleDecimal(double d){\n  return simpleFormat.format(d);\n}\n", "docstring": "returns string from double formatted to decimalformat ( \" # # # . # # \" )", "partition": "test"}
{"idx": "1686", "code": "protected AbstractCategoryItemLabelGenerator(String labelFormat,DateFormat formatter){\n  ParamChecks.nullNotPermitted(labelFormat,\"labelFormat\");\n  ParamChecks.nullNotPermitted(formatter,\"formatter\");\n  this.labelFormat=labelFormat;\n  this.numberFormat=null;\n  this.percentFormat=NumberFormat.getPercentInstance();\n  this.dateFormat=formatter;\n  this.nullValueString=\"-\";\n}\n", "docstring": "creates a label generator with the specified date formatter .", "partition": "test"}
{"idx": "1687", "code": "public void delItems(int s,int e){\n  boolean hsbWasVisible=hsbVis;\n  boolean vsbWasVisible=vsbVis;\n  int oldLastDisplayed=lastItemDisplayed();\n  if (log.isLoggable(PlatformLogger.Level.FINE)) {\n    log.fine(\"Deleting from \" + s + \" to \"+ e);\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Last displayed item: \" + oldLastDisplayed + \", items in window \"+ itemsInWindow()+ \", size \"+ items.size());\n  }\n  if (items.size() == 0) {\n    return;\n  }\n  if (s > e) {\n    int tmp=s;\n    s=e;\n    e=tmp;\n  }\n  if (s < 0) {\n    s=0;\n  }\n  if (e >= items.size()) {\n    e=items.size() - 1;\n  }\n  boolean repaintNeeded=(s >= getFirstVisibleItem() && s <= getLastVisibleItem());\n  for (int i=s; i <= e; i++) {\n    items.removeElementAt(s);\n    int j=posInSel(i);\n    if (j != -1) {\n      int newsel[]=new int[selected.length - 1];\n      System.arraycopy(selected,0,newsel,0,j);\n      System.arraycopy(selected,j + 1,newsel,j,selected.length - (j + 1));\n      selected=newsel;\n    }\n  }\n  int diff=(e - s) + 1;\n  for (int i=0; i < selected.length; i++) {\n    if (selected[i] > e) {\n      selected[i]-=diff;\n    }\n  }\n  int options=PAINT_VSCROLL;\n  if (getFocusIndex() > e) {\n    setFocusIndex(getFocusIndex() - (e - s + 1));\n    options|=PAINT_FOCUS;\n  }\n else   if (getFocusIndex() >= s && getFocusIndex() <= e) {\n    int focusBound=(items.size() > 0) ? 0 : -1;\n    setFocusIndex(Math.max(s - 1,focusBound));\n    options|=PAINT_FOCUS;\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Multiple selections: \" + multipleSelections);\n  }\n  if (vsb.getValue() >= s) {\n    if (vsb.getValue() <= e) {\n      vsb.setValue(e + 1 - diff);\n    }\n else {\n      vsb.setValue(vsb.getValue() - diff);\n    }\n  }\n  int oldMaxLength=maxLength;\n  maxLength=maxLength();\n  if (maxLength != oldMaxLength) {\n    options|=PAINT_HSCROLL;\n  }\n  layout();\n  repaintNeeded|=(vsbWasVisible ^ vsbVis) || (hsbWasVisible ^ hsbVis);\n  if (repaintNeeded) {\n    options|=PAINT_ALL;\n  }\n  repaint(s,oldLastDisplayed,options);\n}\n", "docstring": "delete items starting with s ( start position ) to e ( end position ) including s and e if s < 0 then s = 0 if e > = items . size ( ) then e = items . size ( ) - 1", "partition": "test"}
{"idx": "1688", "code": "static long makeId(SnmpOid oid){\n  long id=0;\n  long[] arcs=oid.longValue(false);\n  id|=arcs[0] << 56;\n  id|=arcs[1] << 48;\n  id|=arcs[2] << 40;\n  id|=arcs[3] << 32;\n  id|=arcs[4] << 24;\n  id|=arcs[5] << 16;\n  id|=arcs[6] << 8;\n  id|=arcs[7];\n  return id;\n}\n", "docstring": "translate an oid to a thread id . arc follow the long big - endian order .", "partition": "test"}
{"idx": "1689", "code": "private void cacheAttribute(String attrId,byte[][] values){\n  String cacheKey=name + \"|\" + attrId;\n  valueCache.put(cacheKey,values);\n}\n", "docstring": "add the values to the cache .", "partition": "test"}
{"idx": "1690", "code": "void read(Reader policy) throws ParsingException, IOException {\n  if (!(policy instanceof BufferedReader)) {\n    policy=new BufferedReader(policy);\n  }\n  st=new StreamTokenizer(policy);\n  st.resetSyntax();\n  st.wordChars(\'a\',\'z\');\n  st.wordChars(\'A\',\'Z\');\n  st.wordChars(\'.\',\'.\');\n  st.wordChars(\'0\',\'9\');\n  st.wordChars(\'_\',\'_\');\n  st.wordChars(\'$\',\'$\');\n  st.wordChars(128 + 32,255);\n  st.whitespaceChars(0,\' \');\n  st.commentChar(\'/\');\n  st.quoteChar(\'\\\'\');\n  st.quoteChar(\'\"\');\n  st.lowerCaseMode(false);\n  st.ordinaryChar(\'/\');\n  st.slashSlashComments(true);\n  st.slashStarComments(true);\n  st.parseNumbers();\n  Hashtable<String,Vector<String>> processedPermissions=null;\n  lookahead=st.nextToken();\n  while (lookahead != StreamTokenizer.TT_EOF) {\n    if (peek(\"grant\")) {\n      GrantEntry ge=parseGrantEntry(processedPermissions);\n      if (ge != null)       grantEntries.addElement(ge);\n    }\n else {\n      throw new ParsingException(st.lineno(),\"expected grant \" + \"statement\");\n    }\n    match(\";\");\n  }\n}\n", "docstring": "reads a policy configuration using a reader object . < p >", "partition": "test"}
{"idx": "1691", "code": "protected void injectIntoVolumeInformationContainer(Map<String,StringSet> volumeInformation,String infoKey,String altKey,CIMInstance volumeInstance){\n  Object value=getCIMPropertyValue(volumeInstance,infoKey);\n  if (null == value) {\n    value=getCIMPropertyValue(volumeInstance,altKey);\n  }\n  String charactersticName=SupportedVolumeInformation.getVolumeInformation(infoKey);\n  if (null != value && null != charactersticName) {\n    StringSet valueSet=new StringSet();\n    if (value instanceof String) {\n      valueSet.add(value.toString());\n    }\n else     if (value instanceof String[]) {\n      valueSet.addAll(Arrays.asList((String[])value));\n    }\n    volumeInformation.put(charactersticName,valueSet);\n  }\n}\n", "docstring": "extract value from provider for given volume info key , and then get its name and use that to inject to map .", "partition": "test"}
{"idx": "1692", "code": "@Override public void onDetachedFromRecyclerView(RecyclerView recyclerView){\n  super.onDetachedFromRecyclerView(recyclerView);\n  mAttachedRecyclerViewPool.remove(recyclerView);\n}\n", "docstring": "implementation of adapter . ondetachedfromrecyclerview ( recyclerview ) < p > called when this expandablerecycleradapter is detached from a recyclerview .", "partition": "test"}
{"idx": "1693", "code": "private void loadFile(String filename,AbstractFileLoader... loaders){\n  ArffSortedTableModel model;\n  this.m_Filename=filename;\n  createTitle();\n  if (filename.equals(\"\")) {\n    model=null;\n  }\n else {\n    model=new ArffSortedTableModel(filename,loaders);\n    model.setShowAttributeIndex(getShowAttributeIndex());\n  }\n  m_TableArff.setModel(model);\n  setChanged(false);\n  createName();\n}\n", "docstring": "loads the specified file into the table", "partition": "test"}
{"idx": "1694", "code": "private void destinationTypeChanged(){\n  if (m_Exp == null)   return;\n  String str=\"\";\n  if (m_ResultsDestinationCBox.getSelectedItem() == DEST_DATABASE_TEXT) {\n    m_ResultsDestinationPathLabel.setText(\"URL:\");\n    str=m_destinationDatabaseURL;\n    m_BrowseDestinationButton.setEnabled(true);\n    m_BrowseDestinationButton.setText(\"User...\");\n  }\n else {\n    m_ResultsDestinationPathLabel.setText(\"Filename:\");\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      int ind=m_destinationFilename.lastIndexOf(\".csv\");\n      if (ind > -1) {\n        m_destinationFilename=m_destinationFilename.substring(0,ind) + \".arff\";\n      }\n    }\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      int ind=m_destinationFilename.lastIndexOf(\".arff\");\n      if (ind > -1) {\n        m_destinationFilename=m_destinationFilename.substring(0,ind) + \".csv\";\n      }\n    }\n    str=m_destinationFilename;\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      int ind=str.lastIndexOf(\".csv\");\n      if (ind > -1) {\n        str=str.substring(0,ind) + \".arff\";\n      }\n    }\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      int ind=str.lastIndexOf(\".arff\");\n      if (ind > -1) {\n        str=str.substring(0,ind) + \".csv\";\n      }\n    }\n    m_BrowseDestinationButton.setEnabled(true);\n    m_BrowseDestinationButton.setText(\"Browse...\");\n  }\n  if (m_ResultsDestinationCBox.getSelectedItem() == DEST_DATABASE_TEXT) {\n    DatabaseResultListener drl=null;\n    try {\n      drl=new DatabaseResultListener();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n    drl.setDatabaseURL(m_destinationDatabaseURL);\n    m_Exp.setResultListener(drl);\n  }\n else {\n    if (m_ResultsDestinationCBox.getSelectedItem() == DEST_ARFF_TEXT) {\n      InstancesResultListener irl=new InstancesResultListener();\n      if (!m_destinationFilename.equals(\"\")) {\n        irl.setOutputFile(new File(m_destinationFilename));\n      }\n      m_Exp.setResultListener(irl);\n    }\n else     if (m_ResultsDestinationCBox.getSelectedItem() == DEST_CSV_TEXT) {\n      CSVResultListener crl=new CSVResultListener();\n      if (!m_destinationFilename.equals(\"\")) {\n        crl.setOutputFile(new File(m_destinationFilename));\n      }\n      m_Exp.setResultListener(crl);\n    }\n  }\n  m_ResultsDestinationPathTField.setText(str);\n  m_Support.firePropertyChange(\"\",null,null);\n}\n", "docstring": "responds to a change in the destination type .", "partition": "test"}
{"idx": "1695", "code": "public static InputStream tryGzipInput(InputStream in) throws IOException {\n  if (!in.markSupported()) {\n    PushbackInputStream pb=new PushbackInputStream(in,16);\n    in=pb;\n    byte[] magic={0,0};\n    pb.read(magic);\n    pb.unread(magic);\n    if (magic[0] == 31 && magic[1] == -117) {\n      return new GZIPInputStream(pb);\n    }\n    return in;\n  }\n  in.mark(16);\n  boolean isgzip=(in.read() == 31 && in.read() == -117);\n  in.reset();\n  if (isgzip) {\n    in=new GZIPInputStream(in);\n  }\n  return in;\n}\n", "docstring": "try to open a stream as gzip , if it starts with the gzip magic . todo : move to utils package .", "partition": "test"}
{"idx": "1696", "code": "@Override public int hashCode(){\n  if (location != null)   return location.hashCode();\n else   return 0;\n}\n", "docstring": "returns the hash code value for this object .", "partition": "test"}
{"idx": "1697", "code": "public static Query newPrefixQuery(String field,InetAddress value,int prefixLength){\n  if (value == null) {\n    throw new IllegalArgumentException(\"InetAddress must not be null\");\n  }\n  if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {\n    throw new IllegalArgumentException(\"illegal prefixLength \'\" + prefixLength + \"\'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges\");\n  }\n  byte lower[]=value.getAddress();\n  byte upper[]=value.getAddress();\n  for (int i=prefixLength; i < 8 * lower.length; i++) {\n    int m=1 << (7 - (i & 7));\n    lower[i >> 3]&=~m;\n    upper[i >> 3]|=m;\n  }\n  try {\n    return newRangeQuery(field,InetAddress.getByAddress(lower),InetAddress.getByAddress(upper));\n  }\n catch (  UnknownHostException e) {\n    throw new AssertionError(e);\n  }\n}\n", "docstring": "create a prefix query for matching a cidr network range .", "partition": "test"}
{"idx": "1698", "code": "public static Subject createAMIdentitySubject(PolicyManager pm,AMIdentity user) throws PolicyException {\n  SubjectTypeManager mgr=pm.getSubjectTypeManager();\n  Subject subject=mgr.getSubject(\"AMIdentitySubject\");\n  Set<String> set=new HashSet<String>();\n  set.add(user.getUniversalId());\n  subject.setValues(set);\n  return subject;\n}\n", "docstring": "returns a subject for the given amidentity .", "partition": "test"}
{"idx": "1699", "code": "protected void expandFor(int index,double d){\n  if (index < size)   return;\n  int oldSize=size, capacity=vector.length;\n  size=index + 1;\n  if (capacity >= size)   return;\n  while (capacity < size)   capacity*=2;\n  double[] t=new double[capacity];\n  System.arraycopy(vector,0,t,0,oldSize);\n  if (d != 0)   Arrays.fill(t,oldSize,size,d);\n  vector=t;\n}\n", "docstring": "makes sure the capacity and size of the vector can accomodate the given index . the capacity of the vector is simply doubled until it can accomodate its size .", "partition": "test"}
{"idx": "1700", "code": "private void doNormalCommandLineList(List<String> commandLineList,List<String> jointOptions,Path classpath){\n  commandLineList.add(\"--classpath\");\n  commandLineList.add(classpath.toString());\n  if (jointCompilation) {\n    commandLineList.add(\"-j\");\n    commandLineList.addAll(jointOptions);\n  }\n  if (destDir != null) {\n    commandLineList.add(\"-d\");\n    commandLineList.add(destDir.getPath());\n  }\n  if (encoding != null) {\n    commandLineList.add(\"--encoding\");\n    commandLineList.add(encoding);\n  }\n  if (stacktrace) {\n    commandLineList.add(\"-e\");\n  }\n  if (parameters) {\n    commandLineList.add(\"--parameters\");\n  }\n  if (useIndy) {\n    commandLineList.add(\"--indy\");\n  }\n  if (scriptBaseClass != null) {\n    commandLineList.add(\"-b\");\n    commandLineList.add(scriptBaseClass);\n  }\n  if (configscript != null) {\n    commandLineList.add(\"--configscript\");\n    commandLineList.add(configscript);\n  }\n}\n", "docstring": "add \" groovyc \" parameters to the commandlinelist , based on the ant configuration .", "partition": "test"}
{"idx": "1701", "code": "private synchronized void loadHexImage(IHex hex){\n  hexTileset.assignMatch(hex,boardview);\n  hexTileset.trackHexImages(hex,tracker);\n}\n", "docstring": "loads the image ( s ) for this hex into the tracker .", "partition": "test"}
{"idx": "1702", "code": "public String base64UrlEncode(byte[] data){\n  String encodedData=new String(Base64.encode(data,Base64.URL_SAFE));\n  encodedData=encodedData.replace(\"=\",\"\");\n  encodedData=encodedData.replace(\"\\n\",\"\");\n  return encodedData;\n}\n", "docstring": "encodes a string with base64url encoding it also removes characters which must be removed according to the jose spec : http : / / tools . ietf . org / html / draft - ietf - jose - json - web - signature - 29 # appendix - c", "partition": "test"}
{"idx": "1703", "code": "private void writeJavaFieldSpec(JavaFieldSpec spec,Document document,Element parentElement){\n  Element parameter=document.createElement(\"parameter\");\n  parameter.appendChild(parentElement);\n  parameter.setAttribute(\"package\",spec.getPackageName());\n  parameter.setAttribute(\"class\",spec.getClassName());\n  parameter.setAttribute(\"field\",spec.getFieldName());\n}\n", "docstring": "writes out a source / sink specification object for java static fields", "partition": "test"}
{"idx": "1704", "code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getMask(actions));\n}\n", "docstring": "readobject is called to restore the state of the filepermission from a stream .", "partition": "test"}
{"idx": "1705", "code": "@Override public synchronized void parse(Reader reader,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (reader == null) {\n    throw new IllegalArgumentException(\"Reader cannot be \'null\'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be \'null\'\");\n  }\n  InputSource inputSource=new InputSource(reader);\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}\n", "docstring": "parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .", "partition": "test"}
{"idx": "1706", "code": "private String excludeDestinationStatement(String text){\n  int idx=-1;\n  if ((idx=text.indexOf(\"Destination will be\")) != -1) {\n    text=text.substring(0,idx);\n  }\n  return text;\n}\n", "docstring": "parses the specified string to return the portion not containing the destination statement . this is needed so that the main text which when parsed , indicates the direction icon that will be used ; will be the only determiner of the associated directions icon . the destination text has other directions which will confuse the parsing which determines the icon . ( i . e . the destination will be on the right ) .", "partition": "test"}
{"idx": "1707", "code": "public static void addFile(String s) throws IOException {\n  File f=new File(s);\n  addFile(f);\n}\n", "docstring": "adds a file to the classpath .", "partition": "test"}
{"idx": "1708", "code": "@SafeVarargs public final void insert(int rowIndex,T... newItems){\n  insert(rowIndex,Arrays.asList(newItems));\n}\n", "docstring": "insert new records at a specified index .", "partition": "test"}
{"idx": "1709", "code": "@Deprecated public void put(Collection<Integer> data){\n  for (  Integer value : data) {\n    final int val=value.intValue();\n    min=val < min ? val : min;\n    max=val > max ? val : max;\n  }\n}\n", "docstring": "process a whole collection of integer values . if any of the values is smaller than the current minimum , it will become the new minimum . if any of the values is larger than the current maximum , it will become the new maximum .", "partition": "test"}
{"idx": "1710", "code": "public IntBuffer majorVersionBuffer(){\n  int[] holder=new int[1];\n  holder[0]=getMajorVersion();\n  IntBuffer ib=IntBuffer.wrap(holder);\n  ib.limit(1);\n  return ib;\n}\n", "docstring": "return an intbuffer that accesses the major version number . this is used to create a monitor object for this value .", "partition": "test"}
{"idx": "1711", "code": "public CreateIndexRequest source(XContentBuilder source){\n  return source(source.bytes());\n}\n", "docstring": "sets the settings and mappings as a single source .", "partition": "test"}
{"idx": "1712", "code": "public static byte[] createDataToSign(byte[] digest){\n  byte[] prefix=getDigestInfoPrefix(digest);\n  byte[] digestInfo=new byte[prefix.length + digest.length];\n  System.arraycopy(prefix,0,digestInfo,0,prefix.length);\n  System.arraycopy(digest,0,digestInfo,prefix.length,digest.length);\n  return digestInfo;\n}\n", "docstring": "creates data to be signed from the digest .", "partition": "test"}
{"idx": "1713", "code": "public HttpRequest ifModifiedSince(final long value){\n  connection.setIfModifiedSince(value);\n  return this;\n}\n", "docstring": "set the \"'\" if - modified - since \"'\" request header to the given value", "partition": "test"}
{"idx": "1714", "code": "public static String tmpJournal(){\n  final File file=Code.wrapThrow(null);\n  file.deleteOnExit();\n  return file.getAbsolutePath();\n}\n", "docstring": "create a tmp journal file for test cases .", "partition": "test"}
{"idx": "1715", "code": "public static Object newInstance(Class<?> cl,int[] dims){\n  if (dims.length == 0) {\n    dims=new int[]{1};\n  }\n  return Array.newInstance(cl,dims);\n}\n", "docstring": "allocate an array dynamically . the array . newinstance method does not throw an error and silently returns a null . throws an outofmemoryerror if insufficient space is available .", "partition": "test"}
{"idx": "1716", "code": "protected static void printErrorMessage(Exception e){\n  if (e instanceof AbortException) {\n    LoggingConfiguration.setVerbose(Level.VERBOSE);\n    LOG.verbose(e.getMessage());\n  }\n else   if (e instanceof UnspecifiedParameterException) {\n    LOG.error(e.getMessage());\n  }\n else   if (e instanceof ParameterException) {\n    LOG.error(e.getMessage());\n  }\n else {\n    LOG.exception(e);\n  }\n}\n", "docstring": "print an error message for the given error .", "partition": "test"}
{"idx": "1717", "code": "public String requestStatistics(){\n  sb.setLength(0);\n  makeStringBuffer(sb);\n  return sb.toString();\n}\n", "docstring": "a method for other parts of the application to get stats the command processor uses this to report stats on request", "partition": "test"}
{"idx": "1718", "code": "private void applyL1Reg(final double eta_t,Vec x){\n  if (lambda1 > 0) {\n    l1U+=eta_t * lambda1;\n    for (int k=0; k < ws.length; k++) {\n      final Vec w_k=ws[k];\n      final double[] l1Q_k=l1Q[k];\n      for (      IndexValue iv : x) {\n        final int i=iv.getIndex();\n        final double z=w_k.get(i);\n        double newW_i=0;\n        if (z > 0)         newW_i=Math.max(0,z - (l1U + l1Q_k[i]));\n else         if (z < 0)         newW_i=Math.min(0,z + (l1U - l1Q_k[i]));\n        l1Q_k[i]+=(newW_i - z);\n        w_k.set(i,newW_i);\n      }\n    }\n  }\n}\n", "docstring": "applies l1 regularization to the model", "partition": "test"}
{"idx": "1719", "code": "@Override public void keyPressed(KeyEvent e){\nsynchronized (keyLock) {\n    keysDown.add(e.getKeyCode());\n  }\n}\n", "docstring": "this method cannot be called directly .", "partition": "test"}
{"idx": "1720", "code": "public static String slurpURLNoExceptions(URL u,String encoding){\n  try {\n    return slurpURL(u,encoding);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return null;\n  }\n}\n", "docstring": "returns all the text at the given url .", "partition": "test"}
{"idx": "1721", "code": "public static MoveParticipant[] loadMoveParticipants(RefactoringStatus status,RefactoringProcessor processor,Object element,MoveArguments arguments,IParticipantDescriptorFilter filter,String[] affectedNatures,SharableParticipants shared){\n  RefactoringParticipant[] participants=fgMoveExtensions.getParticipants(status,processor,element,arguments,filter,affectedNatures,shared);\n  MoveParticipant[] result=new MoveParticipant[participants.length];\n  System.arraycopy(participants,0,result,0,participants.length);\n  return result;\n}\n", "docstring": "loads the move participants for the given element .", "partition": "test"}
{"idx": "1722", "code": "private long[] determinePreferenceVector(Relation<V> relation,ModifiableDBIDs[] neighborIDs,StringBuilder msg){\n  if (strategy.equals(Strategy.APRIORI)) {\n    return determinePreferenceVectorByApriori(relation,neighborIDs,msg);\n  }\n else   if (strategy.equals(Strategy.MAX_INTERSECTION)) {\n    return determinePreferenceVectorByMaxIntersection(neighborIDs,msg);\n  }\n else {\n    throw new IllegalStateException(\"Should never happen!\");\n  }\n}\n", "docstring": "determines the preference vector according to the specified neighbor ids .", "partition": "test"}
{"idx": "1723", "code": "private void paintForegroundDisabled(Graphics2D g,int width,int height){\n  Shape s=decodeArrowPath(width,height);\n  g.setPaint(disabledColor);\n  g.fill(s);\n}\n", "docstring": "paint the arrow in disabled state .", "partition": "test"}
{"idx": "1724", "code": "private void onUser(@NotNull TLAbsUser absUser){\n  User currentUser=null;\n  User user=null;\n  if (absUser instanceof TLUser) {\n    final TLUser tlUser=(TLUser)absUser;\n    if (tlUser.isMutualContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserContact(currentUser,tlUser);\n    }\n else     if (tlUser.isDeleted()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserDelete(currentUser,tlUser);\n    }\n else     if (tlUser.isContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserRequest(currentUser,tlUser);\n    }\n else     if (tlUser.isSelf() || !tlUser.isBot()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserForeign(currentUser,tlUser);\n    }\n else {\n      BotLogger.info(LOGTAG,\"Bot received\");\n    }\n  }\n  if ((currentUser == null) && (user != null)) {\n    databaseManager.addUser(user);\n  }\n else   if (user != null) {\n    databaseManager.updateUser(user);\n  }\n}\n", "docstring": "add a user to database", "partition": "test"}
{"idx": "1725", "code": "@Override public boolean hasNext(){\n  log.log(Level.FINE,\"hasNext()\");\n  boolean result=(nextEvent != null);\n  log.log(Level.FINE,\"hasNext(): {0}\",result);\n  return result;\n}\n", "docstring": "check if there are more events . returns true if there are more events and false otherwise .", "partition": "test"}
{"idx": "1726", "code": "private void initialize(ModelValidator validator,MClient client){\n  if (client == null)   m_globalValidators.add(validator);\n  m_validators.add(validator);\n  validator.initialize(this,client);\n}\n", "docstring": "initialize and add validator", "partition": "test"}
{"idx": "1727", "code": "void crossOver(BayesNetRepresentation other){\n  boolean[] bits=new boolean[m_bits.length];\n  for (int i=0; i < m_bits.length; i++) {\n    bits[i]=m_bits[i];\n  }\n  int iCrossOverPoint=m_bits.length;\n  do {\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=bits[i];\n    }\n    iCrossOverPoint=m_random.nextInt(m_bits.length);\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=other.m_bits[i];\n    }\n  }\n while (hasCycles());\n  calcGlobalScore();\n}\n", "docstring": "apply cross - over operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .", "partition": "test"}
{"idx": "1728", "code": "public void reset(){\n  engineReset();\n  state=INITIAL;\n}\n", "docstring": "resets the digest for further use .", "partition": "test"}
{"idx": "1729", "code": "public Perspective createUserPerspective(final String name,final boolean show){\n  Perspective perspective=model.addPerspective(name,true);\n  perspective.store(context);\n  if (show) {\n    showPerspective(name);\n  }\n  return perspective;\n}\n", "docstring": "creates a user - defined perspectives , and possibly switches to this new perspective immediately . the new perspective will be a copy of the current one .", "partition": "test"}
{"idx": "1730", "code": "public static double phred(double error){\n  return -10 * Math.log10(error);\n}\n", "docstring": "get a phred - scaled quality value corresponding to the supplied error rate .", "partition": "test"}
{"idx": "1731", "code": "@SafeVarargs public final Token<TokenType> expect(TokenType... expected) throws SimpleParserException {\n  if (hasType(expected))   return this;\n  throw new SimpleParserException(line,column,\"Expected \" + Arrays.toString(expected) + \", but got \"+ toString());\n}\n", "docstring": "ensures that this token has one of the given expected types .", "partition": "test"}
{"idx": "1732", "code": "public void testSetNull() throws Exception {\n  PreparedStatement stmt=connection.prepareStatement(\"INSERT INTO test_blob(id, bin_data) VALUES(?, ?)\");\n  try {\n    stmt.setInt(1,1);\n    stmt.setBytes(2,null);\n    stmt.executeUpdate();\n    stmt.setInt(1,2);\n    stmt.setBinaryStream(2,null,0);\n    stmt.executeUpdate();\n    stmt.setInt(1,3);\n    stmt.setString(2,null);\n    stmt.executeUpdate();\n  }\n  finally {\n    stmt.close();\n  }\n}\n", "docstring": "this method checks if we correctly handle assigning null values to blobs .", "partition": "test"}
{"idx": "1733", "code": "EgDemandDetails insertPenalty(final BigDecimal chqBouncePenalty,final Module module){\n  EgDemandDetails demandDetail=null;\n  if (chqBouncePenalty != null && chqBouncePenalty.compareTo(BigDecimal.ZERO) > 0) {\n    final Installment currInstallment=getCurrentInstallment(module);\n    final EgDemandReasonMaster egDemandReasonMaster=demandGenericDao.getDemandReasonMasterByCode(DEMANDRSN_CODE_CHQ_BOUNCE_PENALTY,module);\n    if (egDemandReasonMaster == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason Master is null in method  insertPenalty\");\n    final EgDemandReason egDemandReason=demandGenericDao.getDmdReasonByDmdReasonMsterInstallAndMod(egDemandReasonMaster,currInstallment,module);\n    if (egDemandReason == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason is null in method  insertPenalty \");\n    demandDetail=EgDemandDetails.fromReasonAndAmounts(chqBouncePenalty,egDemandReason,BigDecimal.ZERO);\n  }\n  return demandDetail;\n}\n", "docstring": "method used to insert penalty in egdemanddetail table . penalty amount will be calculated depending upon the cheque amount .", "partition": "test"}
{"idx": "1734", "code": "public SampleInfo(ByteBuffer bb) throws IOException {\n  numberOfChannels=bb.getInt();\n  sampleRate=bb.getInt();\n  coeffMin=bb.getFloat();\n  coeffRange=bb.getFloat();\n  postEmphasis=bb.getFloat();\n  residualFold=bb.getInt();\n}\n", "docstring": "constructs a sample info from the given byte buffer .", "partition": "test"}
{"idx": "1735", "code": "public void handleMaintenance(Operation maintOp){\n  performPendingRequestMaintenance();\n  checkAndScheduleSynchronization(this.cachedGroupState.membershipUpdateTimeMicros);\n  maintOp.complete();\n}\n", "docstring": "invoked by parent during its maintenance interval", "partition": "test"}
{"idx": "1736", "code": "public <T>T time(Callable<T> event) throws Exception {\n  final long startTime=clock.tick();\n  try {\n    return event.call();\n  }\n  finally {\n    update(clock.tick() - startTime);\n  }\n}\n", "docstring": "times and records the duration of event .", "partition": "test"}
{"idx": "1737", "code": "public static boolean isPostJDK7(String bytecodeVersion){\n  return JDK7.equals(bytecodeVersion) || JDK8.equals(bytecodeVersion);\n}\n", "docstring": "checks if the specified bytecode version string represents a jdk 1 . 7 + compatible bytecode version .", "partition": "test"}
{"idx": "1738", "code": "public PutIndexTemplateRequest mapping(String type,Object... source){\n  mapping(type,PutMappingRequest.buildFromSimplifiedDef(type,source));\n  return this;\n}\n", "docstring": "a specialized simplified mapping source method , takes the form of simple properties definition : ( \" field1 \" , \" type = string , store = true \" ) .", "partition": "test"}
{"idx": "1739", "code": "private InputStream findTemplate(String path,String template){\n  try {\n    File file=new File(path,template);\n    if (file.canRead()) {\n      return new BufferedInputStream(new FileInputStream(file.getAbsolutePath()));\n    }\n else {\n      return null;\n    }\n  }\n catch (  FileNotFoundException fnfe) {\n    return null;\n  }\n}\n", "docstring": "try to find a template given a normalized path .", "partition": "test"}
{"idx": "1740", "code": "public void addListener(CircularProgressViewListener listener){\n  if (listener != null)   listeners.add(listener);\n}\n", "docstring": "register a circularprogressviewlistener with this view", "partition": "test"}
{"idx": "1741", "code": "public SiteStatusCheckThreadImpl(){\n  super();\n  urlCheckers=new HashMap();\n}\n", "docstring": "constructs a sitestatuscheckthreadimpl object based on the configured parameter com . sun . identity . sitemonitor . sitestatuscheck . class .", "partition": "test"}
{"idx": "1742", "code": "@Override public void render(final int type,final Graphics2D g2,final float scaling,final boolean isFormGlyph){\n  glyphDisplay.setScalingValues(0,0,scaling);\n  final float OLDglyphScale=glyphScale;\n  if (isFormGlyph) {\n    glyphScale=scaling * glyphScale;\n  }\n  AffineTransform aff=null;\n  if (glyphScale != 1f) {\n    aff=g2.getTransform();\n    g2.scale(glyphScale,glyphScale);\n  }\n  glyphDisplay.setG2(g2);\n  glyphDisplay.paint(null,null,null);\n  if (aff != null) {\n    g2.setTransform(aff);\n  }\n  glyphScale=OLDglyphScale;\n}\n", "docstring": "draw the t3 glyph", "partition": "test"}
{"idx": "1743", "code": "public List<String> reset(List<String> replace){\n  ArrayList<String> copy=new ArrayList<String>(retainedVars.size());\n  copy.addAll(retainedVars);\n  retainedVars.clear();\n  if (replace != null) {\n    retainedVars.addAll(replace);\n  }\n  return copy;\n}\n", "docstring": "replaces the list of retained vars with the specified list , returning the old list . if no list is specified then a new empty one is used .", "partition": "test"}
{"idx": "1744", "code": "protected void release(){\n  AppContext tempAppContext=null;\nsynchronized (grabReleaseSynchronizer) {\n    if (usageCount > 1) {\n      --usageCount;\n    }\n else {\nsynchronized (threadGroupSynchronizer) {\n        tempAppContext=resetAppContext();\n      }\n    }\n  }\n  if (tempAppContext != null) {\n    try {\n      tempAppContext.dispose();\n    }\n catch (    IllegalThreadStateException e) {\n    }\n  }\n}\n", "docstring": "release this appletclassloader and its threadgroup / appcontext . if nothing else has grabbed this appletclassloader , its threadgroup and appcontext will be destroyed . because this method may destroy the appletclassloader \"'\" s threadgroup , this method should not be called from within the appletclassloader \"'\" s threadgroup . changed modifier to protected in order to be able to overwrite this function in pluginclassloader . java", "partition": "test"}
{"idx": "1745", "code": "public synchronized void deleteAllTables(){\n  List<String> tableNames=new ArrayList<String>(tableLookup.keySet());\n  for (  String s : tableNames) {\n    deleteTable(s);\n  }\n}\n", "docstring": "delete all tables from this database .", "partition": "test"}
{"idx": "1746", "code": "public PetCategory findOne(String id){\n  log.debug(\"Request to get PetCategory : {}\",id);\n  PetCategory petCategory=petCategoryRepository.findOne(UUID.fromString(id));\n  return petCategory;\n}\n", "docstring": "get one petcategory by id .", "partition": "test"}
{"idx": "1747", "code": "private void markRemovedDefaultSessionToken(String site,String token){\n  if (removedDefaultTokens == null)   removedDefaultTokens=new HashMap<>(1);\n  HashSet<String> removedSet=removedDefaultTokens.get(site);\n  if (removedSet == null) {\n    removedSet=new HashSet<>(1);\n    removedDefaultTokens.put(site,removedSet);\n  }\n  removedSet.add(token);\n}\n", "docstring": "marks a default session token as removed for a particular site .", "partition": "test"}
{"idx": "1748", "code": "private Map<URI,Map<URI,Map<String,List<URI>>>> createDeviceToCGMapFromDescriptors(List<VolumeDescriptor> addDescriptors,List<VolumeDescriptor> removeDescriptors){\n  Map<URI,Map<URI,Map<String,List<URI>>>> deviceToCGMap=new HashMap<URI,Map<URI,Map<String,List<URI>>>>();\n  for (  VolumeDescriptor descr : addDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToAdd=volumesToUpdate.get(ADD_VOLUMES_TO_CG_KEY);\n    if (volumesToAdd == null) {\n      volumesToAdd=new ArrayList<URI>();\n      volumesToUpdate.put(ADD_VOLUMES_TO_CG_KEY,volumesToAdd);\n    }\n    volumesToAdd.add(descr.getVolumeURI());\n  }\n  for (  VolumeDescriptor descr : removeDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToRemove=volumesToUpdate.get(REMOVE_VOLUMES_FROM_CG_KEY);\n    if (volumesToRemove == null) {\n      volumesToRemove=new ArrayList<URI>();\n      volumesToUpdate.put(REMOVE_VOLUMES_FROM_CG_KEY,volumesToRemove);\n    }\n    volumesToRemove.add(descr.getVolumeURI());\n  }\n  return deviceToCGMap;\n}\n", "docstring": "convenience method to create a map device to cg to volume to add and remove . we want the map to contain both the volumes to add and remove segregated by device and also by cg . the map will look like the below : device uri - - > cg uri - - - - > add - > list of volumes to add from this cg for this device - - - - > remove - > list of volumes to remove from this cg for this device", "partition": "test"}
{"idx": "1749", "code": "public Exchange(final Request request,final Origin origin){\n  this.currentRequest=request;\n  this.origin=origin;\n  this.timestamp=System.currentTimeMillis();\n}\n", "docstring": "creates a new exchange with the specified request and origin .", "partition": "test"}
{"idx": "1750", "code": "public static final FileTime unixTimeToFileTime(long utime){\n  return FileTime.from(utime,TimeUnit.SECONDS);\n}\n", "docstring": "converts \" standard unix time \" ( in seconds , utc / gmt ) to filetime", "partition": "test"}
{"idx": "1751", "code": "public void removeAddress(AddressEntity address){\n  addresses.remove(address);\n}\n", "docstring": "removes the given address from this user", "partition": "test"}
{"idx": "1752", "code": "private boolean verifyMigrateFromProductHome(String migrateFromProductHome) throws InstallException {\n  if (migrateFromProductHome == null || migrateFromProductHome.length() == 0) {\n    Debug.log(\"MultipleMigrateDriver.verifyMigrateFromProductHome() :\" + \"empty product home by the user\");\n    Console.println(LocalizedMessage.get(LOC_HR_MSG_MIGRATE_NONE_FOUND));\n    return false;\n  }\n  if (!migrateFromProductHome.equals(ConfigUtil.getHomePath())) {\n    Debug.log(\"MultipleMigrateDriver.verifyMigrateFromProductHome() : \" + \"Migrate from product home: \" + migrateFromProductHome + \", New product home: \"+ ConfigUtil.getHomePath());\n    String translateFile=migrateFromProductHome + MigrateFromInstFinderStore.getRelativeTranslateFile();\n    if (!FileUtils.isFileValid(translateFile)) {\n      Console.println(LocalizedMessage.get(LOC_HR_MSG_MIGRATE_NONE_FOUND));\n      return false;\n    }\n  }\n else {\n    Debug.log(\"MultipleMigrateDriver - Error:\" + \"This product has been already migrated!\");\n    throw new InstallException(LocalizedMessage.get(LOC_DR_ERR_PRODUCT_ALREADY_MIGRATED));\n  }\n  return true;\n}\n", "docstring": "check if the product home input by the user has the locator file of the product to be migrated from .", "partition": "test"}
{"idx": "1753", "code": "public static String format(String message,Object[] arguments){\n  return MessageFormat.format(message,arguments);\n}\n", "docstring": "formats the given string with the given argument .", "partition": "test"}
{"idx": "1754", "code": "private void insertProsodySettings(Utterance utterance,Element element){\n  Element prosody=(Element)DomUtils.getAncestor(element,MaryXML.PROSODY);\n  if (prosody == null) {\n    return;\n  }\n  Element voice=(Element)DomUtils.getAncestor(element,MaryXML.VOICE);\n  if (voice != null && DomUtils.isAncestor(prosody,voice)) {\n    return;\n  }\n  Element paragraph=(Element)DomUtils.getAncestor(element,MaryXML.PARAGRAPH);\n  if (paragraph != null && DomUtils.isAncestor(prosody,paragraph)) {\n    return;\n  }\n  for (  String att : PROSODY_ATTRIBUTES) {\n    String val=prosody.getAttribute(att);\n    if (!val.equals(\"\")) {\n      utterance.setString(att,val);\n    }\n  }\n}\n", "docstring": "for a given element , extract essential settings defined by the closest ancestor prosody element and save them into the utterance . note that prosody settings outside of a paragraph or voice element , are not to be stored here , since they are dealt with elsewhere or are not relevant .", "partition": "test"}
{"idx": "1755", "code": "public static boolean createFolder(@SuppressWarnings(\"UnusedParameters\") Context mContext,String path,String folderName){\n  File SDCardRoot=new File(path,folderName);\n  if (!SDCardRoot.exists()) {\n    return SDCardRoot.mkdir();\n  }\n  return false;\n}\n", "docstring": "use to create folder in your directory", "partition": "test"}
{"idx": "1756", "code": "private void addProtocolIfNotExists(Set<String> protocols,String protocolType){\n  if (!protocols.contains(protocolType)) {\n    protocols.add(protocolType);\n  }\n}\n", "docstring": "verify whether protocoltype already exists or not . if it doesn \"'\" t exist then add .", "partition": "test"}
{"idx": "1757", "code": "void add(Object key){\n  table.put(key,key);\n}\n", "docstring": "adds an object to this set .", "partition": "test"}
{"idx": "1758", "code": "public Configuration loadConfigFromResource(Resource resource){\n  PropertiesConfiguration result=new PropertiesConfiguration();\n  try {\n    result.load(resource.getInputStream());\n    return result;\n  }\n catch (  ConfigurationException|IOException e) {\n    LOG.error(CONFIGURATION_LOAD_ERROR.format(resource.getFilename()),e);\n    throw new SystemConfigException(CONFIGURATION_LOAD_ERROR.format(resource.getFilename()),e);\n  }\n}\n", "docstring": "build a configuration object from a resource , processing it as a properties file .", "partition": "test"}
{"idx": "1759", "code": "public final void log(String filename,int lineNumber,String method,String tag,int level,String message){\n  final LogMessage lm=new LogMessage(LogMessage.LOGMSG_TYPE_LOG,nextSequenceNumber.getAndIncrement());\n  lm.addInt16(level,LogMessage.PART_KEY_LEVEL);\n  if (filename != null) {\n    lm.addString(filename,LogMessage.PART_KEY_FILENAME);\n    if (lineNumber != 0)     lm.addInt32(lineNumber,LogMessage.PART_KEY_LINENUMBER);\n  }\n  if (method != null)   lm.addString(method,LogMessage.PART_KEY_FUNCTIONNAME);\n  if (tag != null && !tag.isEmpty())   lm.addString(tag,LogMessage.PART_KEY_TAG);\n  lm.addString(message,LogMessage.PART_KEY_MESSAGE);\n  log(lm);\n}\n", "docstring": "log a message with full information ( if provided )", "partition": "test"}
{"idx": "1760", "code": "protected Size2D drawVertical(Graphics2D g2,Rectangle2D chartArea){\n  double startX;\n  double topSpace=0.0;\n  double bottomSpace=0.0;\n  double leftSpace=0.0;\n  double rightSpace=0.0;\n  double w=getWidth();\n  double h=getHeight();\n  RectangleInsets padding=getPadding();\n  if (padding != null) {\n    topSpace=padding.calculateTopOutset(h);\n    bottomSpace=padding.calculateBottomOutset(h);\n    leftSpace=padding.calculateLeftOutset(w);\n    rightSpace=padding.calculateRightOutset(w);\n  }\n  if (getPosition() == RectangleEdge.LEFT) {\n    startX=chartArea.getX() + leftSpace;\n  }\n else {\n    startX=chartArea.getMaxX() - rightSpace - w;\n  }\n  VerticalAlignment alignment=getVerticalAlignment();\n  double startY=0.0;\n  if (alignment == VerticalAlignment.CENTER) {\n    startY=chartArea.getMinY() + topSpace + chartArea.getHeight() / 2.0 - h / 2.0;\n  }\n else   if (alignment == VerticalAlignment.TOP) {\n    startY=chartArea.getMinY() + topSpace;\n  }\n else   if (alignment == VerticalAlignment.BOTTOM) {\n    startY=chartArea.getMaxY() - bottomSpace - h;\n  }\n  g2.drawImage(this.image,(int)startX,(int)startY,(int)w,(int)h,null);\n  return new Size2D(chartArea.getWidth() + leftSpace + rightSpace,h + topSpace + bottomSpace);\n}\n", "docstring": "draws the title on a java 2d graphics device ( such as the screen or a printer ) .", "partition": "test"}
{"idx": "1761", "code": "private static final PublicKey constructPublicKey(byte[] encodedKey,String encodedKeyAlgorithm) throws InvalidKeyException, NoSuchAlgorithmException {\n  PublicKey key=null;\n  try {\n    KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm,SunJCE.getInstance());\n    X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n    key=keyFactory.generatePublic(keySpec);\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    try {\n      KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm);\n      X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n      key=keyFactory.generatePublic(keySpec);\n    }\n catch (    NoSuchAlgorithmException nsae2) {\n      throw new NoSuchAlgorithmException(\"No installed providers \" + \"can create keys for the \" + encodedKeyAlgorithm + \"algorithm\");\n    }\ncatch (    InvalidKeySpecException ikse2) {\n      InvalidKeyException ike=new InvalidKeyException(\"Cannot construct public key\");\n      ike.initCause(ikse2);\n      throw ike;\n    }\n  }\ncatch (  InvalidKeySpecException ikse) {\n    InvalidKeyException ike=new InvalidKeyException(\"Cannot construct public key\");\n    ike.initCause(ikse);\n    throw ike;\n  }\n  return key;\n}\n", "docstring": "construct a public key from its encoding .", "partition": "test"}
{"idx": "1762", "code": "public static boolean expressionIsTrue(double leftSide,Operator operator,double rightSide){\n  final String expression=leftSide + operator.getMathematicalOperator() + rightSide;\n  return expressionIsTrue(expression);\n}\n", "docstring": "evaluates whether an expression is true or false .", "partition": "test"}
{"idx": "1763", "code": "@Override public CompletableFuture<Optional<T>> max(final Comparator<? super T> comparator){\n  return CompletableFuture.supplyAsync(null,exec);\n}\n", "docstring": "perform an asyncrhonous min operation", "partition": "test"}
{"idx": "1764", "code": "final public void println(char v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    out.write(v);\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a character followed by a newline .", "partition": "test"}
{"idx": "1765", "code": "public void test_write_correctRejection_emptyRecord(){\n  final IRawStore store=getStore();\n  try {\n    try {\n      store.write(ByteBuffer.wrap(new byte[]{}));\n      fail(\"Expecting: \" + IllegalArgumentException.class);\n    }\n catch (    IllegalArgumentException ex) {\n      if (log.isInfoEnabled())       log.info(\"Ignoring expected exception: \" + ex);\n    }\n    try {\n      final ByteBuffer buf=ByteBuffer.wrap(new byte[2]);\n      buf.position(buf.limit());\n      store.write(buf);\n      fail(\"Expecting: \" + IllegalArgumentException.class);\n    }\n catch (    IllegalArgumentException ex) {\n      if (log.isInfoEnabled())       log.info(\"Ignoring expected exception: \" + ex);\n    }\n  }\n  finally {\n    store.destroy();\n  }\n}\n", "docstring": "test verifies correct rejection of a write operation when the caller supplies an empty buffer ( no bytes remaining ) .", "partition": "test"}
{"idx": "1766", "code": "public synchronized void commit(){\nsynchronized (mutex) {\n    Map<Column,Set<Interval>> temp=workingIntervals;\n    workingIntervals=Collections.synchronizedMap(new LinkedHashMap<>());\n    availableIntervalsRef.set(Collections.unmodifiableMap(new LinkedHashMap<>(temp)));\n    super.columns=new LinkedHashSet<>(temp.keySet());\n  }\n}\n", "docstring": "swaps the actual cache with the built - up temporary cache and creates a fresh , empty temporary cache .", "partition": "test"}
{"idx": "1767", "code": "public static String extractIndentString(String line,int tabWidth,int indentWidth){\n  if (tabWidth < 0 || indentWidth < 0 || line == null) {\n    throw new IllegalArgumentException();\n  }\n  int size=line.length();\n  int end=0;\n  int spaceEquivs=0;\n  int characters=0;\n  for (int i=0; i < size; i++) {\n    char c=line.charAt(i);\n    if (c == '\\t') {\n      spaceEquivs=calculateSpaceEquivalents(tabWidth,spaceEquivs);\n      characters++;\n    }\n else     if (isIndentChar(c)) {\n      spaceEquivs++;\n      characters++;\n    }\n else {\n      break;\n    }\n    if (spaceEquivs >= indentWidth) {\n      end+=characters;\n      characters=0;\n      if (indentWidth == 0) {\n        spaceEquivs=0;\n      }\n else {\n        spaceEquivs=spaceEquivs % indentWidth;\n      }\n    }\n  }\n  if (end == 0) {\n    return Util.EMPTY_STRING;\n  }\n else   if (end == size) {\n    return line;\n  }\n else {\n    return line.substring(0,end);\n  }\n}\n", "docstring": "returns the leading indentation string of the given line . note that the returned string need not be equal to the leading whitespace as odd spaces are not considered part of the indentation .", "partition": "test"}
{"idx": "1768", "code": "private void preInsert(MkMaxEntry q,MkMaxEntry nodeEntry,KNNHeap knns_q){\n  if (LOG.isDebugging()) {\n    LOG.debugFine(\"preInsert \" + q + \" - \"+ nodeEntry+ \"\\n\");\n  }\n  double knnDist_q=knns_q.getKNNDistance();\n  MkMaxTreeNode<O> node=getNode(nodeEntry);\n  double knnDist_node=0.;\n  if (node.isLeaf()) {\n    for (int i=0; i < node.getNumEntries(); i++) {\n      MkMaxEntry p=node.getEntry(i);\n      double dist_pq=distance(p.getRoutingObjectID(),q.getRoutingObjectID());\n      if (dist_pq <= knnDist_q) {\n        knns_q.insert(dist_pq,p.getRoutingObjectID());\n        if (knns_q.size() >= getKmax()) {\n          knnDist_q=knns_q.getKNNDistance();\n          q.setKnnDistance(knnDist_q);\n        }\n      }\n      if (dist_pq <= p.getKnnDistance()) {\n        KNNList knns_p=knnq.getKNNForDBID(p.getRoutingObjectID(),getKmax() - 1);\n        if (knns_p.size() + 1 < getKmax()) {\n          p.setKnnDistance(Double.NaN);\n        }\n else {\n          double knnDist_p=Math.max(dist_pq,knns_p.getKNNDistance());\n          p.setKnnDistance(knnDist_p);\n        }\n      }\n      knnDist_node=Math.max(knnDist_node,p.getKnnDistance());\n    }\n  }\n else {\n    List<DoubleIntPair> entries=getSortedEntries(node,q.getRoutingObjectID());\n    for (    DoubleIntPair distEntry : entries) {\n      MkMaxEntry dirEntry=node.getEntry(distEntry.second);\n      double entry_knnDist=dirEntry.getKnnDistance();\n      if (distEntry.second < entry_knnDist || distEntry.second < knnDist_q) {\n        preInsert(q,dirEntry,knns_q);\n        knnDist_q=knns_q.getKNNDistance();\n      }\n      knnDist_node=Math.max(knnDist_node,dirEntry.getKnnDistance());\n    }\n  }\n  if (LOG.isDebugging()) {\n    LOG.debugFine(nodeEntry + \"set knn dist \" + knnDist_node);\n  }\n  nodeEntry.setKnnDistance(knnDist_node);\n}\n", "docstring": "adapts the knn distances before insertion of entry q .", "partition": "test"}
{"idx": "1769", "code": "private static boolean addIfMatches(List<String> container,String statusLine,char x,char y){\n  if (matches(statusLine,x,y)) {\n    final String filename=statusLine.substring(3);\n    if (!container.contains(filename)) {\n      container.add(filename);\n    }\n    return true;\n  }\n  return false;\n}\n", "docstring": "adds files to container if they matched to template .", "partition": "test"}
{"idx": "1770", "code": "public static String encodeFromString(String plain,String charset) throws CoderException, UnsupportedEncodingException {\n  return encode(plain.getBytes(charset));\n}\n", "docstring": "encodes a string to base64 string", "partition": "test"}
{"idx": "1771", "code": "public void slide(SLIDE slide){\n  if (slide == SLIDE.UP) {\n    if (!isPanelShown()) {\n      int position=0;\n      if (items != null) {\n        position=items.size() / 2;\n      }\n      slideUp(position);\n    }\n  }\n else {\n    hidePanelPickerUI();\n  }\n}\n", "docstring": "slide the panel to the desired direction .", "partition": "test"}
{"idx": "1772", "code": "public boolean isDebuggingFinest(){\n  return logger.isLoggable(Level.FINEST);\n}\n", "docstring": "test whether to log \"'\" debug \"'\" at \"'\" finest \"'\" level", "partition": "test"}
{"idx": "1773", "code": "private static void sort1(int[] x,int off,int len){\n  if (len < 7) {\n    for (int i=off; i < len + off; i++)     for (int j=i; j > off && x[j - 1] > x[j]; j--)     swap(x,j,j - 1);\n    return;\n  }\n  int m=off + (len >> 1);\n  if (len > 7) {\n    int l=off;\n    int n=off + len - 1;\n    if (len > 40) {\n      int s=len / 8;\n      l=med3(x,l,l + s,l + 2 * s);\n      m=med3(x,m - s,m,m + s);\n      n=med3(x,n - 2 * s,n - s,n);\n    }\n    m=med3(x,l,m,n);\n  }\n  int v=x[m];\n  int a=off, b=a, c=off + len - 1, d=c;\n  while (true) {\n    while (b <= c && x[b] <= v) {\n      if (x[b] == v)       swap(x,a++,b);\n      b++;\n    }\n    while (c >= b && x[c] >= v) {\n      if (x[c] == v)       swap(x,c,d--);\n      c--;\n    }\n    if (b > c)     break;\n    swap(x,b++,c--);\n  }\n  int s, n=off + len;\n  s=Math.min(a - off,b - a);\n  vecswap(x,off,b - s,s);\n  s=Math.min(d - c,n - d - 1);\n  vecswap(x,b,n - s,s);\n  if ((s=b - a) > 1)   sort1(x,off,s);\n  if ((s=d - c) > 1)   sort1(x,n - s,s);\n}\n", "docstring": "sorts the specified sub - array of integers into ascending order .", "partition": "test"}
{"idx": "1774", "code": "public void reset(){\n  ns.removeAllElements();\n  ks.setLength(0);\n  cur=tt.root;\n  run();\n}\n", "docstring": "resets the iterator to its initial state .", "partition": "test"}
{"idx": "1775", "code": "@LayoutlibDelegate static float sin(float angle){\n  return (float)Math.sin(angle);\n}\n", "docstring": "returns the closest float approximation of the sine of the argument .", "partition": "test"}
{"idx": "1776", "code": "public static void renderFlattenedAnnotation(final PdfObject form,final DynamicVectorRenderer current,final int pageNumber,final int rotation){\n  final BufferedImage image=AnnotationFactory.getIcon(form);\n  if (image != null) {\n    final GraphicsState gs=new GraphicsState();\n    final int iconHeight=image.getHeight();\n    final int iconWidth=image.getWidth();\n    final float[] rect=form.getFloatArray(PdfDictionary.Rect);\n    if (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Text) {\n      rect[2]=rect[0] + iconWidth;\n      rect[1]=rect[3] - iconHeight;\n      form.setFloatArray(PdfDictionary.Rect,rect);\n    }\nswitch (rotation % 360) {\ncase 0:\n      gs.CTM=new float[][]{{iconWidth,0,1},{0,iconHeight,1},{0,0,0}};\n    gs.x=rect[0];\n  gs.y=rect[3] - iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] - iconHeight;\nbreak;\ncase 90:\ngs.CTM=new float[][]{{0,iconWidth,1},{-iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] + iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] + iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\ncase 180:\ngs.CTM=new float[][]{{-iconWidth,0,1},{0,-iconHeight,1},{0,0,0}};\ngs.x=rect[0];\ngs.y=rect[3] + iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] + iconHeight;\nbreak;\ncase 270:\ngs.CTM=new float[][]{{0,-iconWidth,1},{iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] - iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] - iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\n}\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Darken);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Darken);\n}\ncurrent.drawImage(pageNumber,image,gs,false,form.getObjectRefAsString(),-1);\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Normal);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Normal);\n}\n}\n}\n", "docstring": "method to create an icon to represent the annotation and render it .", "partition": "test"}
{"idx": "1777", "code": "public byte[] extractData(byte[] stegoData,String stegoFileName,byte[] origSigData) throws OpenStegoException {\n  return null;\n}\n", "docstring": "method to extract the message from the stego data", "partition": "test"}
{"idx": "1778", "code": "public static String makeRelatedSessionID(String encryptedID,SessionID prototype) throws SessionException {\n  prototype.parseSessionString();\n  return makeSessionID(encryptedID,prototype.getExtension(),prototype.tail);\n}\n", "docstring": "generates encoded session id string which uses the same extensions and tail part as prototype session id , but a different encrypted id . this method is used to generate session handle and restricted token id for a given master session id . related session ids must share extensions and tail information in order for session failover to work properly", "partition": "test"}
{"idx": "1779", "code": "public static Automaton determinize(Automaton a,int maxDeterminizedStates){\n  if (a.isDeterministic()) {\n    return a;\n  }\n  if (a.getNumStates() <= 1) {\n    return a;\n  }\n  Automaton.Builder b=new Automaton.Builder();\n  SortedIntSet.FrozenIntSet initialset=new SortedIntSet.FrozenIntSet(0,0);\n  b.createState();\n  LinkedList<SortedIntSet.FrozenIntSet> worklist=new LinkedList<>();\n  Map<SortedIntSet.FrozenIntSet,Integer> newstate=new HashMap<>();\n  worklist.add(initialset);\n  b.setAccept(0,a.isAccept(0));\n  newstate.put(initialset,0);\n  final PointTransitionSet points=new PointTransitionSet();\n  final SortedIntSet statesSet=new SortedIntSet(5);\n  Transition t=new Transition();\n  while (worklist.size() > 0) {\n    SortedIntSet.FrozenIntSet s=worklist.removeFirst();\n    for (int i=0; i < s.values.length; i++) {\n      final int s0=s.values[i];\n      int numTransitions=a.getNumTransitions(s0);\n      a.initTransition(s0,t);\n      for (int j=0; j < numTransitions; j++) {\n        a.getNextTransition(t);\n        points.add(t);\n      }\n    }\n    if (points.count == 0) {\n      continue;\n    }\n    points.sort();\n    int lastPoint=-1;\n    int accCount=0;\n    final int r=s.state;\n    for (int i=0; i < points.count; i++) {\n      final int point=points.points[i].point;\n      if (statesSet.upto > 0) {\n        assert lastPoint != -1;\n        statesSet.computeHash();\n        Integer q=newstate.get(statesSet);\n        if (q == null) {\n          q=b.createState();\n          if (q >= maxDeterminizedStates) {\n            throw new TooComplexToDeterminizeException(a,maxDeterminizedStates);\n          }\n          final SortedIntSet.FrozenIntSet p=statesSet.freeze(q);\n          worklist.add(p);\n          b.setAccept(q,accCount > 0);\n          newstate.put(p,q);\n        }\n else {\n          assert (accCount > 0 ? true : false) == b.isAccept(q) : \"accCount=\" + accCount + \" vs existing accept=\"+ b.isAccept(q)+ \" states=\"+ statesSet;\n        }\n        b.addTransition(r,q,lastPoint,point - 1);\n      }\n      int[] transitions=points.points[i].ends.transitions;\n      int limit=points.points[i].ends.next;\n      for (int j=0; j < limit; j+=3) {\n        int dest=transitions[j];\n        statesSet.decr(dest);\n        accCount-=a.isAccept(dest) ? 1 : 0;\n      }\n      points.points[i].ends.next=0;\n      transitions=points.points[i].starts.transitions;\n      limit=points.points[i].starts.next;\n      for (int j=0; j < limit; j+=3) {\n        int dest=transitions[j];\n        statesSet.incr(dest);\n        accCount+=a.isAccept(dest) ? 1 : 0;\n      }\n      lastPoint=point;\n      points.points[i].starts.next=0;\n    }\n    points.reset();\n    assert statesSet.upto == 0 : \"upto=\" + statesSet.upto;\n  }\n  Automaton result=b.finish();\n  assert result.isDeterministic();\n  return result;\n}\n", "docstring": "determinizes the given automaton . < p > worst case complexity : exponential in number of states .", "partition": "test"}
{"idx": "1780", "code": "private boolean findRoot(final ODEStateInterpolator interpolator,final double ta,final double ga,final double tb,final double gb){\n  check(ga == 0.0 || gb == 0.0 || (ga > 0.0 && gb < 0.0) || (ga < 0.0 && gb > 0.0));\n  final UnivariateFunction f=null;\n  double beforeRootT=Double.NaN, beforeRootG=Double.NaN;\n  double afterRootT=ta, afterRootG=0.0;\n  if (ta == tb) {\n    beforeRootT=ta;\n    beforeRootG=ga;\n    afterRootT=shiftedBy(beforeRootT,convergence);\n    afterRootG=f.value(afterRootT);\n  }\n else   if (ga != 0.0 && gb == 0.0) {\n    beforeRootT=tb;\n    beforeRootG=gb;\n    afterRootT=shiftedBy(beforeRootT,convergence);\n    afterRootG=f.value(afterRootT);\n  }\n else   if (ga != 0.0) {\n    final double newGa=f.value(ta);\n    if (ga > 0 != newGa > 0) {\n      beforeRootT=ta;\n      beforeRootG=newGa;\n      afterRootT=minTime(shiftedBy(beforeRootT,convergence),tb);\n      afterRootG=f.value(afterRootT);\n    }\n  }\n  double loopT=ta, loopG=ga;\n  while ((afterRootG == 0.0 || afterRootG > 0.0 == g0Positive) && strictlyAfter(afterRootT,tb)) {\n    if (loopG == 0.0) {\n      beforeRootT=loopT;\n      beforeRootG=loopG;\n      afterRootT=minTime(shiftedBy(beforeRootT,convergence),tb);\n      afterRootG=f.value(afterRootT);\n    }\n else {\n      if (forward) {\n        final Interval interval=solver.solveInterval(maxIterationCount,f,loopT,tb);\n        beforeRootT=interval.getLeftAbscissa();\n        beforeRootG=interval.getLeftValue();\n        afterRootT=interval.getRightAbscissa();\n        afterRootG=interval.getRightValue();\n      }\n else {\n        final Interval interval=solver.solveInterval(maxIterationCount,f,tb,loopT);\n        beforeRootT=interval.getRightAbscissa();\n        beforeRootG=interval.getRightValue();\n        afterRootT=interval.getLeftAbscissa();\n        afterRootG=interval.getLeftValue();\n      }\n    }\n    if (beforeRootT == afterRootT) {\n      afterRootT=nextAfter(afterRootT);\n      afterRootG=f.value(afterRootT);\n    }\n    check((forward && afterRootT > beforeRootT) || (!forward && afterRootT < beforeRootT));\n    loopT=afterRootT;\n    loopG=afterRootG;\n  }\n  if (afterRootG == 0.0 || afterRootG > 0.0 == g0Positive) {\n    return false;\n  }\n else {\n    check(!Double.isNaN(beforeRootT) && !Double.isNaN(beforeRootG));\n    increasing=!g0Positive;\n    pendingEventTime=beforeRootT;\n    stopTime=beforeRootG == 0.0 ? beforeRootT : afterRootT;\n    pendingEvent=true;\n    afterEvent=afterRootT;\n    afterG=afterRootG;\n    check(afterG > 0 == increasing);\n    check(increasing == gb >= ga);\n    return true;\n  }\n}\n", "docstring": "find a root in a bracketing interval . < p > when calling this method one of the following must be true . either ga = = 0 , gb = = 0 , ( ga < 0 and gb > 0 ) , or ( ga > 0 and gb < 0 ) .", "partition": "test"}
{"idx": "1781", "code": "public static int compare(Comparable c1,Comparable c2,boolean nullGreater){\n  if (c1 == c2) {\n    return 0;\n  }\n else   if (c1 == null) {\n    return (nullGreater ? 1 : -1);\n  }\n else   if (c2 == null) {\n    return (nullGreater ? -1 : 1);\n  }\n  return c1.compareTo(c2);\n}\n", "docstring": "null safe comparison of comparables .", "partition": "test"}
{"idx": "1782", "code": "public boolean checkRootBySuperUserApk(){\n  File suApk=new File(SU_APK);\n  if (suApk != null && suApk.exists()) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "returns true if the device contains superuser . apk which is stored into the device in the rooting process .", "partition": "test"}
{"idx": "1783", "code": "int addExpression(Expression expression);\n", "docstring": "adds a new expression to the database .", "partition": "test"}
{"idx": "1784", "code": "public static <E>E syncRest(final Iterator<? extends Object> iterator,final Callable<E> task) throws Exception {\n  if (iterator.hasNext()) {\nsynchronized (iterator.next()) {\n      return syncRest(iterator,task);\n    }\n  }\n else {\n    return task.call();\n  }\n}\n", "docstring": "recursively synchronizes on the components in the provided iterator and executes the provided task if there are no more components .", "partition": "test"}
{"idx": "1785", "code": "private static Component findByName(Container root,String componentName){\n  if (verbose) {\n    log(\"findByName(\" + root + \", \"+ componentName+ \")\");\n  }\n  int count=root.getComponentCount();\n  for (int iter=0; iter < count; iter++) {\n    Component c=root.getComponentAt(iter);\n    String n=c.getName();\n    if (n != null && n.equals(componentName)) {\n      return c;\n    }\n    if (c instanceof Container) {\n      c=findByName((Container)c,componentName);\n      if (c != null) {\n        return c;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "finds a component with the given name , works even with ui \"'\" s that weren \"'\" t created with the gui builder", "partition": "test"}
{"idx": "1786", "code": "public boolean isFingerprint(ClassTemplate classTemplate){\n  return fingerprintClass.equals(classTemplate.getImplementingClass());\n}\n", "docstring": "tests if a template contains methods with signatures that are required by the filter object . the filter object is meant to be a \" self reflecting \" object . meaning it can be cast to usable interfaces without explicitly reflecting the classes .", "partition": "test"}
{"idx": "1787", "code": "public void writeField(final String name,final float value) throws java.io.IOException {\n  writeField(name,Float.toString(value));\n}\n", "docstring": "writes an float field value .", "partition": "test"}
{"idx": "1788", "code": "private List extractColumnKeys(String line){\n  List keys=new java.util.ArrayList();\n  int fieldIndex=0;\n  int start=0;\n  for (int i=0; i < line.length(); i++) {\n    if (line.charAt(i) == this.fieldDelimiter) {\n      if (fieldIndex > 0) {\n        String key=line.substring(start,i);\n        keys.add(removeStringDelimiters(key));\n      }\n      start=i + 1;\n      fieldIndex++;\n    }\n  }\n  String key=line.substring(start,line.length());\n  keys.add(removeStringDelimiters(key));\n  return keys;\n}\n", "docstring": "extracts the column keys from a string .", "partition": "test"}
{"idx": "1789", "code": "protected void drawRhombus(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  int halfWidth=w / 2;\n  int halfHeight=h / 2;\n  Polygon rhombus=new Polygon();\n  rhombus.addPoint(x + halfWidth,y);\n  rhombus.addPoint(x + w,y + halfHeight);\n  rhombus.addPoint(x + halfWidth,y + h);\n  rhombus.addPoint(x,y + halfHeight);\n  drawPolygon(rhombus,fillColor,fillPaint,penColor,shadow);\n}\n", "docstring": "draws a rhombus ( aka . diamond ) for the given parameters .", "partition": "test"}
{"idx": "1790", "code": "static Object instantiate(Class<?> sibling,String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n  ClassLoader cl=sibling.getClassLoader();\n  Class<?> cls=ClassFinder.findClass(className,cl);\n  return cls.newInstance();\n}\n", "docstring": "try to create an instance of a named class . first try the classloader of \" sibling \" , then try the system classloader then the class loader of the current thread .", "partition": "test"}
{"idx": "1791", "code": "public synchronized void show(Bundle options){\n  if (DEBUG)   Log.d(TAG,\"show(); mKeyguardView==\" + mKeyguardView);\n  boolean enableScreenRotation=shouldEnableScreenRotation();\n  maybeCreateKeyguardLocked(enableScreenRotation,false,options);\n  maybeEnableScreenRotation(enableScreenRotation);\n  final int visFlags=View.STATUS_BAR_DISABLE_HOME;\n  if (DEBUG)   Log.v(TAG,\"show:setSystemUiVisibility(\" + Integer.toHexString(visFlags) + \")\");\n  mKeyguardHost.setSystemUiVisibility(visFlags);\n  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);\n  mKeyguardHost.setVisibility(View.VISIBLE);\n  mKeyguardView.show();\n  mKeyguardView.requestFocus();\n}\n", "docstring": "show the keyguard . will handle creating and attaching to the view manager lazily .", "partition": "test"}
{"idx": "1792", "code": "public static int computeStringWidth(FontMetrics fm,String str){\n  return SwingUtilities2.stringWidth(null,fm,str);\n}\n", "docstring": "compute the width of the string using a font with the specified \" metrics \" ( sizes ) .", "partition": "test"}
{"idx": "1793", "code": "private boolean passesSanityCheck(AccessibilityEvent event){\n  final CharSequence afterText=getEventText(event);\n  final CharSequence beforeText=event.getBeforeText();\n  if ((event.getAddedCount() == 0) && (event.getRemovedCount() == beforeText.length())) {\n    return true;\n  }\n  if (afterText == null || beforeText == null) {\n    return false;\n  }\n  final int diff=(event.getAddedCount() - event.getRemovedCount());\n  return ((beforeText.length() + diff) == afterText.length());\n}\n", "docstring": "checks whether the event \"'\" s reported properties match its actual properties , e . g . does the added count minus the removed count reflect the actual change in length between the current and previous text contents .", "partition": "test"}
{"idx": "1794", "code": "public void actionPerformed(ActionEvent ae){\n  String command=ae.getActionCommand();\n  if (command == DisplayPaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" displaying palette\");\n    }\n    showPalette();\n  }\n else   if (command == HidePaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" hiding palette\");\n    }\n    hidePalette();\n  }\n else   if (command == DisplayPropertiesCmd) {\n    Inspector inspector=new Inspector();\n    inspector.inspectPropertyConsumer(this);\n  }\n}\n", "docstring": "the default actionperformed method for layer . make sure you call super . actionperformed if you care about receiving palette show / hide commands . this method is also set up to receive the displaypropertiescmd , and will bring up the inspector for the layer .", "partition": "test"}
{"idx": "1795", "code": "public static String toString(LocalDate data){\n  return data == null ? \"\" : data.format(formatter(\"dd/MM/yyyy\"));\n}\n", "docstring": "converte localdatetime para string no formato dd / mm / yyyy", "partition": "test"}
{"idx": "1796", "code": "@JsonCreator public DataSourceMetadata(@JsonProperty(\"name\") String name,@JsonProperty(\"properties\") Map<String,String> properties,@JsonProperty(\"segments\") List<DataSegment> segments){\n  this.name=name;\n  this.properties=Collections.unmodifiableMap(properties);\n  this.segments=Collections.unmodifiableList(segments);\n}\n", "docstring": "store the full metadata for a druid data source , mainly as a list of segments .", "partition": "test"}
{"idx": "1797", "code": "public EMail createEMail(String value){\n  EmailField emailImpl=new EmailField();\n  try {\n    emailImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return emailImpl;\n}\n", "docstring": "returns email object with the specified value .", "partition": "test"}
{"idx": "1798", "code": "public AddressLookup(String serverUrl,String serialNo,String password){\n  this.serverUrl=serverUrl.trim();\n  this.clientID=serialNo.trim();\n  this.accessCode=password.trim();\n}\n", "docstring": "creates a new instance of addresslookup .", "partition": "test"}
{"idx": "1799", "code": "public Node(String permission,boolean value,boolean override,long expireAt,String server,String world,ContextSet contexts){\n  if (permission == null || permission.equals(\"\")) {\n    throw new IllegalArgumentException(\"Empty permission\");\n  }\n  if (server != null && (server.equalsIgnoreCase(\"global\") || server.equals(\"\"))) {\n    server=null;\n  }\n  if (world != null && world.equals(\"\")) {\n    world=null;\n  }\n  if (world != null && server == null) {\n    server=\"global\";\n  }\n  this.permission=permission;\n  this.value=value;\n  this.override=override;\n  this.expireAt=expireAt;\n  this.server=server;\n  this.world=world;\n  this.contexts=contexts == null ? ContextSet.empty() : contexts.makeImmutable();\n}\n", "docstring": "make an immutable node instance", "partition": "test"}
{"idx": "1800", "code": "public Cell(int rowspan,int colspan){\n  this.rowspan=Math.max(rowspan,1);\n  this.colspan=Math.max(colspan,1);\n}\n", "docstring": "creates a cell which takes a custom amount of cell spaces in the table .", "partition": "test"}
{"idx": "1801", "code": "private void initializeLocalAndTargetInfo() throws Exception {\n  targetSiteInfo=coordinator.getTargetInfo(SiteInfo.class);\n  if (targetSiteInfo == null) {\n    targetSiteInfo=new SiteInfo();\n    try {\n      coordinator.setTargetInfo(targetSiteInfo,false);\n      log.info(\"Step1b: Target site info set to: {}\",targetSiteInfo);\n    }\n catch (    CoordinatorClientException e) {\n      log.info(\"Step1b: Wait another control node to set target\");\n      retrySleep();\n      throw e;\n    }\n  }\n  localVdcPropInfo=localRepository.getVdcPropertyInfo();\n  String localConfigVersion=localVdcPropInfo.getProperty(VdcConfigUtil.VDC_CONFIG_VERSION);\n  coordinator.setNodeSessionScopeInfo(new VdcConfigVersion(localConfigVersion));\n  targetVdcPropInfo=loadVdcConfig();\n  if (isGeoUpgradeFromPreYoda()) {\n    log.info(\"Detect vdc properties from preyoda. Keep local vdc config properties unchanged until all vdc configs are migrated to zk\");\n    localVdcPropInfo.addProperty(VdcConfigUtil.VDC_CONFIG_VERSION,String.valueOf(targetSiteInfo.getVdcConfigVersion()));\n    localRepository.setVdcPropertyInfo(localVdcPropInfo);\n  }\n else {\n    if (localVdcPropInfo.getProperty(VdcConfigUtil.VDC_CONFIG_VERSION) == null) {\n      localVdcPropInfo=new PropertyInfoExt(targetVdcPropInfo.getAllProperties());\n      localVdcPropInfo.addProperty(VdcConfigUtil.VDC_CONFIG_VERSION,String.valueOf(targetSiteInfo.getVdcConfigVersion()));\n      localRepository.setVdcPropertyInfo(localVdcPropInfo);\n      String vdc_ids=targetVdcPropInfo.getProperty(VdcConfigUtil.VDC_IDS);\n      String[] vdcIds=vdc_ids.split(\",\");\n      if (vdcIds.length > 1) {\n        log.info(\"More than one Vdc, rebooting\");\n        reboot();\n      }\n    }\n  }\n  targetPowerOffState=coordinator.getTargetInfo(PowerOffState.class);\n  if (targetPowerOffState == null) {\n    try {\n      coordinator.setTargetInfo(new PowerOffState(PowerOffState.State.NONE));\n      targetPowerOffState=coordinator.getTargetInfo(PowerOffState.class);\n      log.info(\"Step1b: Target poweroff state set to: {}\",PowerOffState.State.NONE);\n    }\n catch (    CoordinatorClientException e) {\n      log.info(\"Step1b: Wait another control node to set target\");\n      retrySleep();\n      throw e;\n    }\n  }\n}\n", "docstring": "initialize local and target info", "partition": "test"}
{"idx": "1802", "code": "@Override public void openElement(String tagName){\n  XMLElement newElement=new XMLElement();\n  newElement.setName(tagName);\n  current.addChild(newElement);\n  stack.push(current);\n  current=newElement;\n}\n", "docstring": "puts a new element into the dom document . the new element is added as a child to the current element in the dom document . then it becomes the current element . the element must be closed using closeelement .", "partition": "test"}
{"idx": "1803", "code": "public Format(String pFormatString){\n  String formatVars[]=pFormatString.split(\"/\");\n  mId=Integer.parseInt(formatVars[0]);\n}\n", "docstring": "construct this object from one of the strings in the \" fmt_list \" parameter", "partition": "test"}
{"idx": "1804", "code": "public boolean equals(Object interval){\n  if (intervals == null) {\n    return false;\n  }\n  return intervals.contains(interval);\n}\n", "docstring": "determine the matching test . defaults to equality of the node based upon the interval . subclasses can override , for example , to determine if the interval is contained within the node \"'\" s information .", "partition": "test"}
{"idx": "1805", "code": "public static String relativeToAbsolute(String baseURL,String relativeURL){\n  if (relativeURL.startsWith(\"/\")) {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ relativeURL;\n  }\n else {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ getURLBasePath(baseURL)+ relativeURL;\n  }\n}\n", "docstring": "converts a relative url e . g . : / myfile . html to an absolute url", "partition": "test"}
{"idx": "1806", "code": "public void start(){\n  if (setState(EnumSet.of(TaskState.INITIAL,TaskState.QUEUED),TaskState.RUNNING)) {\n    DHT.logDebug(\"Starting Task: \" + toString());\n    startTime=System.currentTimeMillis();\n    try {\n      serializedUpdate.run();\n    }\n catch (    Exception e) {\n      DHT.log(e,LogLevel.Error);\n    }\n  }\n}\n", "docstring": "start the task , to be used when a task is queued .", "partition": "test"}
{"idx": "1807", "code": "public JournalIndex(final IRawStore store,final Checkpoint checkpoint,final IndexMetadata metadata,final boolean readOnly){\n  super(store,checkpoint,metadata,readOnly);\n}\n", "docstring": "load from the store .", "partition": "test"}
{"idx": "1808", "code": "private void accesBreakpointInstruction(ArrayList<Instruction> instructions,int lineNumber,int op,BPINSTRUCTION_STATUS status){\n  for (int i=0; i < instructions.size(); i++) {\n    Instruction currInst=instructions.get(i);\n    if (op == 0) {\n      if (currInst instanceof MRJobInstruction) {\n        MRJobInstruction currMRInst=(MRJobInstruction)currInst;\n        if (currMRInst.findMRInstructions(lineNumber)) {\n          BreakPointInstruction breakpoint=new BreakPointInstruction();\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(instID++);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.add(i,breakpoint);\n          DMLBreakpointManager.insertBreakpoint(breakpoint,lineNumber);\n          return;\n        }\n      }\n else       if (currInst instanceof CPInstruction || currInst instanceof SPInstruction) {\n        if (currInst.getLineNum() == lineNumber) {\n          BreakPointInstruction breakpoint=new BreakPointInstruction();\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(instID++);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.add(i,breakpoint);\n          DMLBreakpointManager.insertBreakpoint(breakpoint,lineNumber);\n          return;\n        }\n      }\n else       if (currInst instanceof BreakPointInstruction && currInst.getLineNum() == lineNumber) {\n        BreakPointInstruction breakpoint=(BreakPointInstruction)currInst;\n        breakpoint.setBPInstructionStatus(BPINSTRUCTION_STATUS.ENABLED);\n        breakpoint.setBPInstructionLocation(location);\n        instructions.set(i,breakpoint);\n        DMLBreakpointManager.updateBreakpoint(lineNumber,status);\n        return;\n      }\n    }\n else {\n      if (currInst instanceof BreakPointInstruction && currInst.getLineNum() == lineNumber) {\n        if (op == 1) {\n          BreakPointInstruction breakpoint=(BreakPointInstruction)currInst;\n          breakpoint.setLocation(currInst);\n          breakpoint.setInstID(currInst.getInstID());\n          breakpoint.setBPInstructionStatus(status);\n          breakpoint.setBPInstructionLocation(location);\n          instructions.set(i,breakpoint);\n          DMLBreakpointManager.updateBreakpoint(lineNumber,status);\n        }\n else {\n          instructions.remove(i);\n          DMLBreakpointManager.removeBreakpoint(lineNumber,status);\n        }\n        return;\n      }\n    }\n  }\n}\n", "docstring": "access breakpoint instruction at specified line number in set of instructions ( if valid )", "partition": "test"}
{"idx": "1809", "code": "private void closeFile(){\n  if (plogStream != null) {\n    try {\n      plogStream.close();\n      logger.info(\"File \" + plogFilename + \" closed.\");\n    }\n catch (    IOException e) {\n      logger.warn(\"Unable to close file cleanly: \" + plogFilename);\n    }\n finally {\n      plogStream=null;\n    }\n  }\n}\n", "docstring": "close plog file . this operation is idempotent to allow convenient cleanup at thread exit .", "partition": "test"}
{"idx": "1810", "code": "private void parseFirstConsonant(){\n  Iterator iter=alFirstConsonants.iterator();\n  while (iter.hasNext()) {\n    String strFirstCon=(String)iter.next();\n    if (strSyllable.startsWith(strFirstCon,iCurPos)) {\n      strFirstConsonant=strFirstCon;\n      iCurPos+=strFirstCon.length();\n      return;\n    }\n  }\n  strFirstConsonant=ZERO;\n}\n", "docstring": "parses the first consonant .", "partition": "test"}
{"idx": "1811", "code": "private BuddyPanelController(){\n  buddyPanel=new JPanel();\n  buddyPanel.setLayout(new SBoxLayout(SBoxLayout.VERTICAL));\n  model=new BuddyListModel();\n  JList<Buddy> list=new BuddyPanel(model);\n  buddyPanel.add(list,SLayout.EXPAND_X);\n}\n", "docstring": "creates a new buddypanelcontroller .", "partition": "test"}
{"idx": "1812", "code": "private void removeGapsWithEdgeConcentration(int nodesLevel[]){\n  final int temp=m_nodes.size(), temp2=graphMatrix[0].length;\n  int tempCnt=1;\n  for (int n=0; n < temp; n++) {\n    for (int i=0; i < temp2; i++) {\n      if (graphMatrix[n][i] > 0) {\n        if (nodesLevel[i] > nodesLevel[n] + 1) {\n          int tempLevel=nodesLevel[n];\n          boolean tempNodePresent=false;\n          int k=temp;\n          int tempnode=n;\n          while (tempLevel < nodesLevel[i] - 1) {\n            tempNodePresent=false;\n            for (; k < graphMatrix.length; k++) {\n              if (graphMatrix[tempnode][k] > 0) {\n                tempNodePresent=true;\n                break;\n              }\n            }\n            if (tempNodePresent) {\n              tempnode=k;\n              k=k + 1;\n              tempLevel++;\n            }\n else {\n              if (tempnode != n) {\n                tempnode=k - 1;\n              }\n              break;\n            }\n          }\n          if (m_nodes.get(tempnode).nodeType == SINGULAR_DUMMY) {\n            m_nodes.get(tempnode).nodeType=PLURAL_DUMMY;\n          }\n          if (tempNodePresent) {\n            graphMatrix[tempnode][i]=graphMatrix[n][i];\n            graphMatrix[i][tempnode]=-graphMatrix[n][i];\n            graphMatrix[n][i]=0;\n            graphMatrix[i][n]=0;\n            continue;\n          }\n          int len=graphMatrix.length;\n          int tempMatrix[][]=new int[graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)][graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)];\n          int level=nodesLevel[tempnode] + 1;\n          copyMatrix(graphMatrix,tempMatrix);\n          String s1=new String(\"S\" + tempCnt++);\n          m_nodes.add(new GraphNode(s1,s1,SINGULAR_DUMMY));\n          int temp3[]=new int[nodeLevels[level].length + 1];\n          System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);\n          temp3[temp3.length - 1]=m_nodes.size() - 1;\n          nodeLevels[level]=temp3;\n          temp3=new int[m_nodes.size() + 1];\n          System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);\n          temp3[m_nodes.size() - 1]=level;\n          nodesLevel=temp3;\n          level++;\n          int m;\n          for (m=len; m < len + nodesLevel[i] - nodesLevel[tempnode] - 1 - 1; m++) {\n            String s2=new String(\"S\" + tempCnt++);\n            m_nodes.add(new GraphNode(s2,s2,SINGULAR_DUMMY));\n            temp3=new int[nodeLevels[level].length + 1];\n            System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);\n            temp3[temp3.length - 1]=m_nodes.size() - 1;\n            nodeLevels[level]=temp3;\n            temp3=new int[m_nodes.size() + 1];\n            System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);\n            temp3[m_nodes.size() - 1]=level;\n            nodesLevel=temp3;\n            level++;\n            tempMatrix[m][m + 1]=tempMatrix[n][i];\n            if (m > len) {\n              tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];\n            }\n          }\n          tempMatrix[m][i]=tempMatrix[n][i];\n          tempMatrix[tempnode][len]=tempMatrix[n][i];\n          tempMatrix[len][tempnode]=-1 * tempMatrix[n][i];\n          tempMatrix[i][m]=-1 * tempMatrix[n][i];\n          if (m > len) {\n            tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];\n          }\n          tempMatrix[n][i]=0;\n          tempMatrix[i][n]=0;\n          graphMatrix=tempMatrix;\n        }\n else {\n          graphMatrix[i][n]=-1 * graphMatrix[n][i];\n        }\n      }\n    }\n  }\n}\n", "docstring": "this method removes gaps from the graph . it tries to minimise the number of edges by concentrating multiple dummy nodes from the same parent and on the same vertical level into one . it takes as an argument of int [ ", "partition": "test"}
{"idx": "1813", "code": "public static TestResult execJavac(String toCompile,File dir,String jflexTestVersion){\n  Project p=new Project();\n  Javac javac=new Javac();\n  Path path=new Path(p,dir.toString());\n  javac.setProject(p);\n  javac.setSrcdir(path);\n  javac.setDestdir(dir);\n  javac.setTarget(javaVersion);\n  javac.setSource(javaVersion);\n  javac.setSourcepath(new Path(p,\"\"));\n  javac.setIncludes(toCompile);\n  Path classPath=javac.createClasspath();\n  classPath.setPath(System.getProperty(\"user.home\") + \"/.m2/repository/de/jflex/jflex/\" + jflexTestVersion+ \"/jflex-\"+ jflexTestVersion+ \".jar\");\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  PrintStream outSafe=System.err;\n  System.setErr(new PrintStream(out));\n  try {\n    javac.execute();\n    return new TestResult(out.toString(),true);\n  }\n catch (  BuildException e) {\n    return new TestResult(e + System.getProperty(\"line.separator\") + out.toString(),false);\n  }\n finally {\n    System.setErr(outSafe);\n  }\n}\n", "docstring": "call javac on tocompile in input dir . if tocompile is null , all * . java files below dir will be compiled .", "partition": "test"}
{"idx": "1814", "code": "public static CLPlatform[] listGPUPoweredPlatforms(){\n  CLPlatform[] platforms=listPlatforms();\n  List<CLPlatform> out=new ArrayList<CLPlatform>(platforms.length);\n  for (  CLPlatform platform : platforms) {\n    if (platform.listGPUDevices(true).length > 0)     out.add(platform);\n  }\n  return out.toArray(new CLPlatform[out.size()]);\n}\n", "docstring": "list the opencl implementations that contain at least one gpu device .", "partition": "test"}
{"idx": "1815", "code": "public ActionRequestHelper dependsOn(ActionRequestHelper dependency){\n  mDependencies.add(dependency);\n  return this;\n}\n", "docstring": "this request will execute after the dependency completes .", "partition": "test"}
{"idx": "1816", "code": "static boolean isDate(Object obj){\n  return obj instanceof Date && obj.getClass() == Date.class;\n}\n", "docstring": "check whether this object is a date .", "partition": "test"}
{"idx": "1817", "code": "public static String toXml(final Config toConvert,Boolean prettyXml) throws JAXBException, IOException {\n  String retVal=\"\";\n  try (StringWriter writer=new StringWriter()){\n    toXml(toConvert,writer,prettyXml);\n    retVal=writer.toString();\n    return retVal;\n  }\n }\n", "docstring": "converts config to xml ,", "partition": "test"}
{"idx": "1818", "code": "private static List<Vector2D> buildQuadrilateral(final Vector2D... points){\n  List<Vector2D> quadrilateral=new ArrayList<Vector2D>();\n  for (  Vector2D p : points) {\n    if (!quadrilateral.contains(p)) {\n      quadrilateral.add(p);\n    }\n  }\n  return quadrilateral;\n}\n", "docstring": "build the convex quadrilateral with the found corner points ( with min / max x / y coordinates ) .", "partition": "test"}
{"idx": "1819", "code": "private void heapifyUp(int twopos,Comparable<Object> cur){\n  while (twopos > 0) {\n    final int parent=(twopos - 1) >>> 1;\n    Comparable<Object> par=twoheap[parent];\n    if (cur.compareTo(par) <= 0) {\n      break;\n    }\n    twoheap[twopos]=par;\n    twopos=parent;\n  }\n  twoheap[twopos]=cur;\n}\n", "docstring": "heapify - up method for 2 - ary heap .", "partition": "test"}
{"idx": "1820", "code": "public void insert(String key,char val){\n  int len=key.length() + 1;\n  if (freenode + len > eq.length) {\n    redimNodeArrays(eq.length + BLOCK_SIZE);\n  }\n  char strkey[]=new char[len--];\n  key.getChars(0,len,strkey,0);\n  strkey[len]=0;\n  root=insert(root,strkey,0,val);\n}\n", "docstring": "branches are initially compressed , needing one node per key plus the size of the string key . they are decompressed as needed when another key with same prefix is inserted . this saves a lot of space , specially for long keys .", "partition": "test"}
{"idx": "1821", "code": "void write(Environment env,DataOutputStream out,ConstantPool tab) throws IOException {\n  out.writeByte(CONSTANT_NAMEANDTYPE);\n  out.writeShort(tab.index(name));\n  out.writeShort(tab.index(type));\n}\n", "docstring": "write the constant to the output stream", "partition": "test"}
{"idx": "1822", "code": "public static void initializeProperties(Properties properties,boolean reset,boolean withDefaults){\n  Properties defaultProp=null;\n  if (withDefaults) {\n    SSOToken appToken=AccessController.doPrivileged(AdminTokenAction.getInstance());\n    defaultProp=ServerConfiguration.getDefaults(appToken);\n  }\n  PropertiesHolder oldProps;\n  PropertiesHolder newProps;\n  do {\n    oldProps=propertiesHolderRef.get();\n    final Properties combined=new Properties();\n    if (defaultProp != null) {\n      combined.putAll(defaultProp);\n    }\n    if (!reset) {\n      combined.putAll(oldProps.properties);\n    }\n    combined.putAll(properties);\n    newProps=new PropertiesHolder(Maps.fromProperties(combined));\n  }\n while (!propertiesHolderRef.compareAndSet(oldProps,newProps));\n}\n", "docstring": "initializes the properties to be used by openam . ideally this must be called first before any other method is called within openam . this method provides a programmatic way to set the properties , and will override similar properties if loaded for a properties file .", "partition": "test"}
{"idx": "1823", "code": "public void addNetworkListener(final NetworkListener listener){\n  networkListeners.add(listener);\n}\n", "docstring": "register a network listener .", "partition": "test"}
{"idx": "1824", "code": "public static void appendContentPrefix(HttpServletRequest request,Appendable urlBuffer) throws IOException {\n  appendContentPrefix(request,urlBuffer,null);\n}\n", "docstring": "appends content prefix to buffer . < p > scipio : note : orig ofbiz signature .", "partition": "test"}
{"idx": "1825", "code": "public void addErrorListener(final ErrorListener errorListener){\n  if (errorListeners == null) {\n    errorListeners=new ArrayList<ErrorListener>();\n  }\n  errorListeners.add(errorListener);\n}\n", "docstring": "add an error listener .", "partition": "test"}
{"idx": "1826", "code": "private void validateClassName(String className){\n  String nvalue=className.trim();\n  if (!nvalue.matches(CLASS_RE)) {\n    throw PropertyException.illegalPropertyValueException(this,className);\n  }\n}\n", "docstring": "do some basic checks to make sure the string representation is valid .", "partition": "test"}
{"idx": "1827", "code": "public static void importBaseTypes(final CConnection connection,final int rawModuleId,final int moduleId) throws SQLException {\n  final String query=\"INSERT INTO \" + CTableNames.BASE_TYPES_TABLE + \" SELECT \"+ moduleId+ \", id, name, size, pointer, signed \"+ \"FROM \"+ String.format(CTableNames.RAW_BASE_TYPES,rawModuleId);\n  connection.executeUpdate(query,true);\n  final String updateSequence=String.format(\"SELECT setval(\'bn_base_types_id_seq\', \" + \"COALESCE((SELECT MAX(id) + 1 FROM %s), 1), false) from %s\",CTableNames.BASE_TYPES_TABLE,CTableNames.BASE_TYPES_TABLE);\n  connection.executeQuery(updateSequence,true);\n}\n", "docstring": "imports the base types .", "partition": "test"}
{"idx": "1828", "code": "@SuppressWarnings(\"deprecation\") public Object readMatrixOld(Element node) throws Exception {\n  weka.core.Matrix matrix;\n  weka.core.matrix.Matrix matrixNew;\n  if (DEBUG) {\n    trace(new Throwable(),node.getAttribute(ATT_NAME));\n  }\n  m_CurrentNode=node;\n  matrixNew=(weka.core.matrix.Matrix)readMatrix(node);\n  matrix=new weka.core.Matrix(matrixNew.getArrayCopy());\n  return matrix;\n}\n", "docstring": "builds the matrix ( old ) from the given dom node .", "partition": "test"}
{"idx": "1829", "code": "public void recordFileSystemOperation(DbClient dbClient,OperationTypeEnum opType,Operation.Status status,Object... extParam){\n  try {\n    boolean opStatus=(Operation.Status.ready == status) ? true : false;\n    String evType;\n    evType=opType.getEvType(opStatus);\n    String evDesc=opType.getDescription();\n    String opStage=AuditLogManager.AUDITOP_END;\n    _logger.info(\"opType: {} detail: {}\",opType.toString(),evType.toString() + \':\' + evDesc);\n    URI uri=(URI)extParam[0];\n    recordBourneFileSystemEvent(dbClient,evType,status,evDesc,uri);\n    auditFile(dbClient,opType,opStatus,opStage,uri.toString());\n  }\n catch (  Exception e) {\n    _logger.error(\"Failed to record filesystem operation {}, err:\",opType.toString(),e);\n  }\n}\n", "docstring": "record filesystem related event and audit", "partition": "test"}
{"idx": "1830", "code": "public CoreTokenException(int errorCode){\n  this.errorCode=errorCode;\n  this.message=getLocalizedMessage(Locale.getDefault());\n}\n", "docstring": "creates a core token service exception .", "partition": "test"}
{"idx": "1831", "code": "public DExamineSsl(JFrame parent,KseFrame kseFrame){\n  super(parent,res.getString(\"DExamineSsl.Title\"),Dialog.ModalityType.DOCUMENT_MODAL);\n  this.kseFrame=kseFrame;\n  initComponents();\n}\n", "docstring": "creates new dexaminessl dialog .", "partition": "test"}
{"idx": "1832", "code": "private static List<String> computeDynamicVMArgs(IJavaProject javaProject){\n  ArrayList<String> out=new ArrayList<String>();\n  String devJarPath=maybeGetDevJarPath(javaProject);\n  if (devJarPath.length() > 0) {\n    out.add(\"-Dgwt.devjar=\\\"\" + devJarPath + \'\"\');\n  }\n  return out;\n}\n", "docstring": "dynamic vm args common to both computejunitdynamicvmargsaslist and computecompiledynamicvmargsaslist .", "partition": "test"}
{"idx": "1833", "code": "static void normalize(StringBuilder number){\n  String normalizedNumber=normalize(number.toString());\n  number.replace(0,number.length(),normalizedNumber);\n}\n", "docstring": "normalizes a string of characters representing a phone number . this is a wrapper for normalize ( string number ) but does in - place normalization of the stringbuilder provided .", "partition": "test"}
{"idx": "1834", "code": "public double[] skipTo(final int index) throws MathIllegalArgumentException {\n  if (index == 0) {\n    Arrays.fill(x,0);\n  }\n else {\n    final int i=index - 1;\n    final long grayCode=i ^ (i >> 1);\n    for (int j=0; j < dimension; j++) {\n      long result=0;\n      for (int k=1; k <= BITS; k++) {\n        final long shift=grayCode >> (k - 1);\n        if (shift == 0) {\n          break;\n        }\n        final long ik=shift & 1;\n        result^=ik * direction[j][k];\n      }\n      x[j]=result;\n    }\n  }\n  count=index;\n  return nextVector();\n}\n", "docstring": "skip to the i - th point in the sobol sequence . < p > this operation can be performed in o ( 1 ) .", "partition": "test"}
{"idx": "1835", "code": "public void removeOrganizationConfiguration(String orgName,String groupName,boolean checkLegacyMode) throws SMSException, SSOException {\n  if ((groupName == null) || groupName.length() == 0) {\n    groupName=SMSUtils.DEFAULT;\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  validateSCM();\n  String odn=scm.constructServiceConfigDN(groupName,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,odn);\n  if (cEntry.isNewEntry()) {\n    return;\n  }\n  if (checkLegacyMode && ServiceManager.isCoexistenceMode() && groupName.equalsIgnoreCase(SMSUtils.DEFAULT)) {\n    OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(orgdn),orgdn);\n    amsdk.unassignService(serviceName);\n  }\n  if (!cEntry.isNewEntry()) {\n    SMSEntry entry=cEntry.getClonedSMSEntry();\n    entry.delete(token);\n    cEntry.refresh(entry);\n  }\n}\n", "docstring": "deletes the organization \"'\" s group configuration data .", "partition": "test"}
{"idx": "1836", "code": "public void removeGroupListener(final GroupListener listener){\n  groupListeners.remove(listener);\n}\n", "docstring": "remove a group listener .", "partition": "test"}
{"idx": "1837", "code": "public SetChangelogMapping(String source,String taskName,int changelogPartitionNumber){\n  super(source);\n  setType(TYPE);\n  setKey(taskName);\n  putMessageValue(CHANGELOG_VALUE_KEY,String.valueOf(changelogPartitionNumber));\n}\n", "docstring": "the change log mapping message is used to store changelog partition information for a given task name .", "partition": "test"}
{"idx": "1838", "code": "@Override protected String extractKey(final String name){\n  final String key=unescape(name.substring(0,name.length() - 4));\n  return key.equals(\"\\0\") ? null : key;\n}\n", "docstring": "given a filename , the unescape method returns the key which originated it .", "partition": "test"}
{"idx": "1839", "code": "@SuppressWarnings(\"unchecked\") public static <K,V>void transformStringMap(Map<String,String> original,Map<K,V> map,Class<K> keyClass,Class<V> valueClass) throws PreferenceException {\n  Method parseKeyMethod=findParseMethod(keyClass);\n  Method parseValueMethod=findParseMethod(valueClass);\n  if ((null != parseKeyMethod) && (null != parseValueMethod)) {\n    for (    Map.Entry<String,String> toTransformEntry : original.entrySet()) {\n      try {\n        Object transformedKey=parseKeyMethod.invoke(null,toTransformEntry.getKey());\n        Object transformedValue=parseValueMethod.invoke(null,toTransformEntry.getValue());\n        if (keyClass.isAssignableFrom(transformedKey.getClass()) && valueClass.isAssignableFrom(transformedValue.getClass())) {\n          map.put((K)transformedKey,(V)transformedValue);\n        }\n      }\n catch (      Exception e) {\n        throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\",e);\n      }\n    }\n  }\n else   if (null == parseKeyMethod) {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ keyClass.getName()+ \".\");\n  }\n else {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ valueClass.getName()+ \".\");\n  }\n}\n", "docstring": "transforms all the strings key / value pairs in the original map to the given class key / value pairs and adds them to the given resulting map .", "partition": "test"}
{"idx": "1840", "code": "public boolean grabInput(){\n  if (grabLog.isLoggable(PlatformLogger.Level.FINE)) {\n    grabLog.fine(\"Grab input on {0}\",this);\n  }\n  XToolkit.awtLock();\n  try {\n    if (XAwtState.getGrabWindow() == this && XAwtState.isManualGrab()) {\n      grabLog.fine(\"    Already Grabbed\");\n      return true;\n    }\n    XBaseWindow prevGrabWindow=XAwtState.getGrabWindow();\n    final int eventMask=(int)(XConstants.ButtonPressMask | XConstants.ButtonReleaseMask | XConstants.EnterWindowMask| XConstants.LeaveWindowMask| XConstants.PointerMotionMask| XConstants.ButtonMotionMask);\n    final int ownerEvents=1;\n    if (!XToolkit.getSunAwtDisableGrab()) {\n      int ptrGrab=XlibWrapper.XGrabPointer(XToolkit.getDisplay(),getContentWindow(),ownerEvents,eventMask,XConstants.GrabModeAsync,XConstants.GrabModeAsync,XConstants.None,(XWM.isMotif() ? XToolkit.arrowCursor : XConstants.None),XConstants.CurrentTime);\n      if (ptrGrab != XConstants.GrabSuccess) {\n        XlibWrapper.XUngrabPointer(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XAwtState.setGrabWindow(null);\n        grabLog.fine(\"    Grab Failure - mouse\");\n        return false;\n      }\n      int keyGrab=XlibWrapper.XGrabKeyboard(XToolkit.getDisplay(),getContentWindow(),ownerEvents,XConstants.GrabModeAsync,XConstants.GrabModeAsync,XConstants.CurrentTime);\n      if (keyGrab != XConstants.GrabSuccess) {\n        XlibWrapper.XUngrabPointer(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XlibWrapper.XUngrabKeyboard(XToolkit.getDisplay(),XConstants.CurrentTime);\n        XAwtState.setGrabWindow(null);\n        grabLog.fine(\"    Grab Failure - keyboard\");\n        return false;\n      }\n    }\n    if (prevGrabWindow != null) {\n      prevGrabWindow.ungrabInputImpl();\n    }\n    XAwtState.setGrabWindow(this);\n    grabLog.fine(\"    Grab - success\");\n    return true;\n  }\n  finally {\n    XToolkit.awtUnlock();\n  }\n}\n", "docstring": "we should always grab both keyboard and pointer to control event flow on popups . this also simplifies synthetic grab implementation . the active grab overrides activated automatic grab .", "partition": "test"}
{"idx": "1841", "code": "public ComponentManager(Collection<Sequence> generalSeeds){\n  Set<Sequence> seedSet=new LinkedHashSet<>(generalSeeds.size());\n  seedSet.addAll(generalSeeds);\n  this.gralSeeds=Collections.unmodifiableSet(seedSet);\n  gralComponents=new SequenceCollection(seedSet);\n}\n", "docstring": "create a component manager , initially populated with the given sequences , which are considered seed sequences .", "partition": "test"}
{"idx": "1842", "code": "public static byte[] unsynchronize(byte[] abySource){\n  ByteArrayInputStream input=new ByteArrayInputStream(abySource);\n  ByteArrayOutputStream output=new ByteArrayOutputStream(abySource.length);\n  int count=0;\n  while (input.available() > 0) {\n    int firstByte=input.read();\n    count++;\n    output.write(firstByte);\n    if ((firstByte & MPEGFrameHeader.SYNC_BYTE1) == MPEGFrameHeader.SYNC_BYTE1) {\n      if (input.available() > 0) {\n        input.mark(1);\n        int secondByte=input.read();\n        if ((secondByte & MPEGFrameHeader.SYNC_BYTE2) == MPEGFrameHeader.SYNC_BYTE2) {\n          if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Writing unsynchronisation bit at:\" + count);\n          }\n          output.write(0);\n        }\n else         if (secondByte == 0) {\n          if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Inserting zero unsynchronisation bit at:\" + count);\n          }\n          output.write(0);\n        }\n        input.reset();\n      }\n    }\n  }\n  if ((abySource[abySource.length - 1] & MPEGFrameHeader.SYNC_BYTE1) == MPEGFrameHeader.SYNC_BYTE1) {\n    logger.finest(\"Adding unsynchronisation bit at end of stream\");\n    output.write(0);\n  }\n  return output.toByteArray();\n}\n", "docstring": "unsynchronize an array of bytes , this should only be called if the decision has already been made to unsynchronize the byte array in order to prevent a media player from incorrectly interpreting the contents of a tag , all $ ff bytes followed by a byte with value > = 224 must be followed by a $ 00 byte ( thus , $ ff $ f0 sequences become $ ff $ 00 $ f0 ) . additionally because unsynchronisation is being applied any existing $ ff $ 00 have to be converted to $ ff $ 00 $ 00", "partition": "test"}
{"idx": "1843", "code": "private byte[] calculateGeneralEncryptionKey(byte[] userPassword,byte[] firstDocIdValue,int keyBitLength,int revision,byte[] oValue,int pValue,boolean encryptMetadata) throws GeneralSecurityException {\n  final byte[] paddedPassword=padPassword(userPassword);\n  MessageDigest md5=createMD5Digest();\n  md5.reset();\n  md5.update(paddedPassword);\n  md5.update(oValue);\n  md5.update((byte)(pValue & 0xFF));\n  md5.update((byte)((pValue >> 8) & 0xFF));\n  md5.update((byte)((pValue >> 16) & 0xFF));\n  md5.update((byte)(pValue >> 24));\n  if (firstDocIdValue != null) {\n    md5.update(firstDocIdValue);\n  }\n  if (revision >= 4 && !encryptMetadata) {\n    for (int i=0; i < 4; ++i) {\n      md5.update((byte)0xFF);\n    }\n  }\n  byte[] hash=md5.digest();\n  final int keyLen=revision == 2 ? 5 : (keyBitLength / 8);\n  final byte[] key=new byte[keyLen];\n  if (revision >= 3) {\n    for (int i=0; i < 50; ++i) {\n      md5.update(hash,0,key.length);\n      digestTo(md5,hash);\n    }\n  }\n  System.arraycopy(hash,0,key,0,key.length);\n  return key;\n}\n", "docstring": "determine what the general encryption key is , given a configuration . this corresponds to algorithm 3 . 2 of pdf reference version 1 . 7 .", "partition": "test"}
{"idx": "1844", "code": "public MessageCapture(final Logger logger,final boolean captureEntity){\n  this(logger,captureEntity,false);\n}\n", "docstring": "builds a new messagecapture .", "partition": "test"}
{"idx": "1845", "code": "public static final byte[] unzip(byte[] in) throws IOException {\n  ByteArrayOutputStream outStream=new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);\n  GZIPInputStream inStream=new GZIPInputStream(new ByteArrayInputStream(in));\n  byte[] buf=new byte[BUF_SIZE];\n  while (true) {\n    int size=inStream.read(buf);\n    if (size <= 0)     break;\n    outStream.write(buf,0,size);\n  }\n  outStream.close();\n  return outStream.toByteArray();\n}\n", "docstring": "returns an gunzipped copy of the input array .", "partition": "test"}
{"idx": "1846", "code": "public static void insertIntoCombo(JComboBox combo,Object item){\n  MutableComboBoxModel model=(MutableComboBoxModel)combo.getModel();\n  if (model.getSize() == 0) {\n    model.insertElementAt(item,0);\n    return;\n  }\n  Object o=model.getElementAt(0);\n  if (o.equals(item)) {\n    return;\n  }\n  model.removeElement(item);\n  model.insertElementAt(item,0);\n  combo.setSelectedIndex(0);\n}\n", "docstring": "insert the given item into the combo box , and set it as first selected item . if the item already exists , it is removed , so there are no duplicates .", "partition": "test"}
{"idx": "1847", "code": "private boolean pythonErrorIn(String output){\n  boolean isError=false;\n  String[] outputMultiline=output.split(\"\\n\");\n  Matcher errorMatcher;\n  for (  String row : outputMultiline) {\n    errorMatcher=errorInLastLine.matcher(row);\n    if (errorMatcher.find() == true) {\n      isError=true;\n      break;\n    }\n  }\n  return isError;\n}\n", "docstring": "checks if there is a syntax error or an exception", "partition": "test"}
{"idx": "1848", "code": "public void doStressTest(TempTripleStore tmp,InferenceEngine inf,int ntrials,int D,int N){\n  AbstractTripleStore store=inf.database;\n  assertSameGraphs(tmp,store);\n  for (int trial=0; trial < ntrials; trial++) {\n    MDC.put(\"trial\",\"trial=\" + trial);\n    retractAndAssert(inf,store,0,D,N);\n    assertSameGraphs(tmp,store);\n    MDC.remove(\"trial\");\n  }\n}\n", "docstring": "a stress test for truth maintenance using an arbitrary data set . the test scans the statement indices in some order , selecting n explicit statement to retract . it then retracts them , updates the closure , and then re - asserts them and verifies that original closure was restored . < p > note : this test by itself does not guarentee that any entailments of those explicit statements were removed - we need to write other tests for that . repeat several times on the dataset , potentially doing multiple retractions before we back out of them .", "partition": "test"}
{"idx": "1849", "code": "public Set<T> keySet(){\n  return Collections.unmodifiableSet(map.keySet());\n}\n", "docstring": "the item keys contained in the map .", "partition": "test"}
{"idx": "1850", "code": "public void onStart(){\n  if (mAudioMirrorBuffer == null) {\n    mAudioMirrorBuffer=new byte[262144];\n  }\n  if (mStreamer != null) {\n    mStreamer.start();\n  }\n  if (mInsecureStreamer != null) {\n    mInsecureStreamer.start();\n  }\n}\n", "docstring": "called when the playback service starts", "partition": "test"}
{"idx": "1851", "code": "@SuppressWarnings(\"unchecked\") public PropagationImp(Stack<CompositeTransaction> lineage,boolean serial,long timeout){\n  serial_=serial;\n  lineage_=(Stack<CompositeTransaction>)lineage.clone();\n  timeout_=timeout;\n}\n", "docstring": "construct a new instance .", "partition": "test"}
{"idx": "1852", "code": "public NativeRunner(File eclipsec){\n  this.eclipsec=Objects.requireNonNull(eclipsec);\n}\n", "docstring": "pass it the location of the launcher file .", "partition": "test"}
{"idx": "1853", "code": "private static String indent(final int height){\n  return CoreBaseBOp.indent(height);\n}\n", "docstring": "returns a string that may be used to indent a dump of the nodes in the tree .", "partition": "test"}
{"idx": "1854", "code": "public static Calendar reduceCalendar(Calendar calendar){\n  calendar.set(Calendar.MILLISECOND,0);\n  calendar.set(Calendar.SECOND,0);\n  calendar.set(Calendar.MINUTE,0);\n  calendar.set(Calendar.HOUR,0);\n  calendar.set(Calendar.HOUR_OF_DAY,0);\n  return calendar;\n}\n", "docstring": "sets the supplied calendar object with 0 values for fields lower than days", "partition": "test"}
{"idx": "1855", "code": "public static String surround(String string,String prefix,String suffix){\n  if (string.startsWith(prefix) == false) {\n    string=prefix + string;\n  }\n  if (string.endsWith(suffix) == false) {\n    string+=suffix;\n  }\n  return string;\n}\n", "docstring": "surrounds the string with provided prefix and suffix if such missing from string .", "partition": "test"}
{"idx": "1856", "code": "public static Coordinate ptNotInList(Coordinate[] testPts,Coordinate[] pts){\n  for (int i=0; i < testPts.length; i++) {\n    Coordinate testPt=testPts[i];\n    if (!isInList(testPt,pts))     return testPt;\n  }\n  return null;\n}\n", "docstring": "finds a point in a list of points which is not contained in another list of points", "partition": "test"}
{"idx": "1857", "code": "public static String trimOrPad(String str,int length,char padChar){\n  String result;\n  if (str == null) {\n    result=\"\";\n  }\n else {\n    result=str;\n  }\n  if (result.length() > length) {\n    return result.substring(0,length);\n  }\n  while (result.length() < length) {\n    result+=padChar;\n  }\n  return result;\n}\n", "docstring": "trims or pads this string , so it has this exact length .", "partition": "test"}
{"idx": "1858", "code": "void scheduleToTimerPool(){\n  if (sessionPollerPool.isPollingEnabled()) {\n    long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxIdleTime() * 60)) * 1000;\n    if (sessionPollerPool.getCacheBasedPolling()) {\n      timeoutTime=Math.min((session.getLatestRefreshTime() + (session.getMaxCachingTime() * 60)) * 1000,timeoutTime);\n    }\n    rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n  }\n else {\n    if ((sessionPollerPool.isSessionCleanupEnabled()) && willExpire(session.getMaxSessionTime())) {\n      long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxSessionTime() * 60)) * 1000;\n      rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n    }\n  }\n}\n", "docstring": "schedule this culler to be run , based on the state of the session .", "partition": "test"}
{"idx": "1859", "code": "public CipherParameters decrypt(byte[] in,int keyLen){\n  return decrypt(in,0,in.length,keyLen);\n}\n", "docstring": "decrypt an encapsulated session key .", "partition": "test"}
{"idx": "1860", "code": "private static void logOsInfo(){\n  Logger.appendLog(\"[Main][I]User Os is \" + Cfg.getOs());\n  Logger.appendLog(\"[Main][I]Os name : \" + Os.getOsName());\n  Logger.appendLog(\"[Main][I]User Platform is : \" + Os.platform());\n  Logger.appendLog(\"[Main][I]JAVA version : \" + System.getProperty(\"java.version\"));\n  Logger.appendLog(\"[Main][I]Available cores (cpu) = \" + HostInfo.availableCpus());\n  Logger.appendLog(\"[Main][I]Max allocated memory = \" + HostInfo.getMaxMemory() + \" bytes\");\n}\n", "docstring": "log system informations to the log file this have no effect on the software it \"'\" s here for logging purpose", "partition": "test"}
{"idx": "1861", "code": "public static byte[] hash(String input){\n  if (!TextUtils.isEmpty(input)) {\n    try {\n      byte[] inputBytes=input.getBytes(\"UTF-8\");\n      return hash(inputBytes);\n    }\n catch (    UnsupportedEncodingException e) {\n      Log.e(TAG,\"problem hashing \\\"\" + input + \"\\\" \"+ e.getMessage(),e);\n    }\n  }\n  return null;\n}\n", "docstring": "created sha256 of input", "partition": "test"}
{"idx": "1862", "code": "public static String generateTransportZoneNativeGuid(String transportType,String deviceType,String fabricId){\n  return String.format(\"%s+%s+%s\",transportType,_deviceTypeMap.get(deviceType),fabricId);\n}\n", "docstring": "the format of this native guid is transporttype + devicetype + fabricwwn . transporttype is fc , devicetype is mds or brocade and fabricwwn is the unique wwn assigned to the fabric .", "partition": "test"}
{"idx": "1863", "code": "public void testAddServletWithNameAndJspFile() throws Exception {\n  String xml=WEBAPP_TEST_HEADER + \"\" + \"</web-app>\";\n  WebXml webXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(xml.getBytes(\"UTF-8\")),getEntityResolver());\n  WebXmlUtils.addJspFile(webXml,\"s1\",\"s1.jsp\");\n  assertTrue(WebXmlUtils.hasServlet(webXml,\"s1\"));\n}\n", "docstring": "tests whether a single servlet can be added using the method that takes a string for the servlet name and a string for the jsp file .", "partition": "test"}
{"idx": "1864", "code": "@Override public boolean equalsValue(final Object other){\n  return Objects.equals(this.value,other);\n}\n", "docstring": "indicates whether some other object is \" equal to \" the value . the other value is equal if object . equals ( value , other ) returns true .", "partition": "test"}
{"idx": "1865", "code": "public static void error(String msg,Throwable t){\n  debugInst.debug(IDebug.ERROR,msg,t);\n}\n", "docstring": "error level debug message", "partition": "test"}
{"idx": "1866", "code": "public void removeEventListener(SIPTransactionEventListener oldListener){\n  eventListeners.remove(oldListener);\n}\n", "docstring": "removed an event listener from this transaction .", "partition": "test"}
{"idx": "1867", "code": "public static ExecutionSystem newExecutionSystem(URI uri,Map<String,?> env) throws IOException {\n  return newExecutionSystem(uri,env,null);\n}\n", "docstring": "creates a new execution system for the specified uri . the number of execution systems with a given uri that may open at the same time is implementation dependent .", "partition": "test"}
{"idx": "1868", "code": "public static boolean isCommand(IElementType type){\n  return type == SQFTypes.COMMAND_TOKEN || type == SQFTypes.COMMAND || type == SQFTypes.CASE || type == SQFTypes.CASE_COMMAND;\n}\n", "docstring": "return true if the given type refers to a command , false otherwise", "partition": "test"}
{"idx": "1869", "code": "public void send(XTraceReport report){\n  outgoing.offer(report);\n}\n", "docstring": "enqueues the provided report to be sent by the reporting thread", "partition": "test"}
{"idx": "1870", "code": "@Contract(pure=true) public static boolean startsWithConcatenation(@NotNull String string,@NotNull String... prefixes){\n  int offset=0;\n  for (  String prefix : prefixes) {\n    int prefixLen=prefix.length();\n    if (!string.regionMatches(offset,prefix,0,prefixLen)) {\n      return false;\n    }\n    offset+=prefixLen;\n  }\n  return true;\n}\n", "docstring": "equivalent to string . startswith ( prefixes [ 0 ", "partition": "test"}
{"idx": "1871", "code": "public void testOrderedByDatatype() throws Exception {\n  int lastType=Integer.MIN_VALUE;\n  while (typeInfoRs.next()) {\n    String name=typeInfoRs.getString(\"TYPE_NAME\");\n    int type=typeInfoRs.getInt(\"DATA_TYPE\");\n    assertTrue(\"type \" + type + \" (\"+ name+ \") less than last type \"+ lastType,type >= lastType);\n    lastType=type;\n  }\n}\n", "docstring": "check types ordered by data type .", "partition": "test"}
{"idx": "1872", "code": "public boolean fireMapMouseClicked(MouseEvent evt){\n  if (DEBUG) {\n    logger.fine(\"MapMouseSupport: fireMapMouseClicked\");\n  }\n  clickHappened=true;\n  boolean consumed=false;\n  evt=new MapMouseEvent(getParentMode(),evt);\n  if (priorityListener != null && evt.getClickCount() > 1) {\n    priorityListener.mouseClicked(evt);\n    consumed=true;\n  }\n  priorityListener=null;\n  if (proxy == null || evt.isShiftDown() || (proxyDistributionMask & PROXY_DISTRIB_MOUSE_CLICKED) > 0) {\n    Iterator<MapMouseListener> it=iterator();\n    while (it.hasNext() && !consumed) {\n      MapMouseListener target=it.next();\n      consumed=target.mouseClicked(evt) && consumeEvents;\n      if (consumed) {\n        priorityListener=target;\n      }\n    }\n  }\n  boolean ignoreConsumed=!consumed || (consumed && ((proxyDistributionMask & PROXY_ACK_CONSUMED_MOUSE_CLICKED) == 0));\n  if (proxy != null && ignoreConsumed && !evt.isShiftDown()) {\n    proxy.mouseClicked(evt);\n    consumed=true;\n  }\n  return consumed;\n}\n", "docstring": "handle a mouseclicked mouselistener event . if the prioritylistener is set , it automatically gets the clicked event . if it is not set , the other listeners get a shot at the event according to the consumeevent mode .", "partition": "test"}
{"idx": "1873", "code": "public static String formatSqlValues(String... values){\n  StringBuilder builder=new StringBuilder(\"(\");\n  for (int i=0; i < values.length; i++) {\n    if (i > 0) {\n      builder.append(\',\');\n    }\n    builder.append(\'\\\'\');\n    builder.append(escapeSqlString(values[i]));\n    builder.append(\'\\\'\');\n  }\n  builder.append(\")\");\n  return builder.toString();\n}\n", "docstring": "formats an array of values as a sql values like ( \"'\" value1 \"'\" , \"'\" value2 \"'\" , . . . , \"'\" value_n \"'\" ) . escapes single quotes with two single quotes .", "partition": "test"}
{"idx": "1874", "code": "private void emitClass(DocComment comment){\n  String tagName=(comment.getType() == DocComment.CLASS) ? \"classRec\" : \"interfaceRec\";\n  xml.append(\"\\n<\");\n  xml.append(tagName);\n  xml.append(\" name=\'\");\n  xml.append(comment.getName());\n  xml.append(\"\' fullname=\'\");\n  xml.append(comment.getFullname());\n  String sourcefile=comment.getSourceFile();\n  if (sourcefile != null) {\n    xml.append(\"\' sourcefile=\'\");\n    xml.append(sourcefile);\n  }\n  xml.append(\"\' namespace=\'\");\n  xml.append(comment.getNamespace());\n  xml.append(\"\' access=\'\");\n  xml.append(comment.getAccess());\n  xml.append(\"\' \");\n  if (comment.getType() == DocComment.INTERFACE) {\n    String[] baseClasses=comment.getBaseclasses();\n    if (baseClasses != null) {\n      xml.append(\"baseClasses=\'\");\n      for (int i=0; i < baseClasses.length; i++) {\n        String baseclass=baseClasses[i];\n        if (baseclass != null) {\n          if (i != 0)           xml.append(\";\");\n          xml.append(baseclass);\n        }\n      }\n      xml.append(\"\' \");\n    }\n  }\n else {\n    xml.append(\"baseclass=\'\");\n    xml.append(comment.getBaseClass());\n    xml.append(\"\' \");\n    String[] interfaces=comment.getInterfaces();\n    if (interfaces != null) {\n      xml.append(\"interfaces=\'\");\n      for (int i=0; i < interfaces.length; i++) {\n        String inter=interfaces[i];\n        if (inter != null) {\n          if (i != 0)           xml.append(\";\");\n          xml.append(inter);\n        }\n      }\n      xml.append(\"\' \");\n    }\n  }\n  xml.append(\"isFinal=\'\");\n  xml.append(comment.isFinal());\n  xml.append(\"\' \");\n  xml.append(\"isDynamic=\'\");\n  xml.append(comment.isDynamic());\n  xml.append(\"\' \");\n  xml.append(\">\");\n  String desc=comment.getDescription();\n  if (desc != null)   appendTag(\"description\",comment.getDescription());\n  emitTags(comment.getAllTags());\n  if (comment.getMetadata() != null)   emitMetadata(comment.getMetadata());\n  xml.append(\"\\n</\");\n  xml.append(tagName);\n  xml.append(\">\");\n}\n", "docstring": "appends a class or interface", "partition": "test"}
{"idx": "1875", "code": "protected void paintContentBorderTopEdge(Graphics g,int x,int y,int w,int h,boolean drawBroken,Rectangle selRect,boolean isContentBorderPainted){\n  if (isContentBorderPainted) {\n    g.setColor(selectHighlight);\n    g.fillRect(x,y,w - 1,1);\n  }\n}\n", "docstring": "draws the top edge of the border around the content area . draw unbroken line for tabs are not on top override where appropriate .", "partition": "test"}
{"idx": "1876", "code": "public void analyzeAllItAndWriteResults(){\n  RunResultsLoader runDir=new RunResultsLoader(runDirectory,null);\n  PrintStream stream;\n  try {\n    stream=new PrintStream(new File(outputDir + \"routesAndTTs.txt\"));\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n    return;\n  }\n  String header=\"it\\ttotal tt[s]\\t#users up\\t#users mid\\t#users low\\tavg tt[s] up\\tavg tt[s] mid\\tavg tt[s] low\";\n  stream.println(header);\n  double totalTTIt;\n  double[] avgRouteTTsIt;\n  int[] routeUsersIt;\n  for (int i=0; i <= lastIteration; i++) {\n    log.info(\"Starting to analyze iteration \" + i + \" of \"+ lastIteration+ \" iterations.\");\n    String eventsFilename=runDir.getEventsFilename(i);\n    EventsManager eventsManager=new EventsManagerImpl();\n    TtAnalyzeBraess handler=new TtAnalyzeBraess();\n    eventsManager.addHandler(handler);\n    MatsimEventsReader reader=new MatsimEventsReader(eventsManager);\n    reader.readFile(eventsFilename);\n    totalTTIt=handler.getTotalTT();\n    avgRouteTTsIt=handler.calculateAvgRouteTTs();\n    routeUsersIt=handler.getRouteUsers();\n    StringBuffer line=new StringBuffer();\n    line.append(i + \"\\t\" + totalTTIt);\n    for (int j=0; j < 3; j++) {\n      line.append(\"\\t\" + routeUsersIt[j]);\n    }\n    for (int j=0; j < 3; j++) {\n      line.append(\"\\t\" + avgRouteTTsIt[j]);\n    }\n    stream.println(line.toString());\n  }\n  stream.close();\n  log.info(lastIteration + \" Iterations analyzed.\");\n}\n", "docstring": "analyzes all iterations in terms of route choice and travel time", "partition": "test"}
{"idx": "1877", "code": "public int executeUpdate(String sql) throws SQLException {\n  return Util.truncateAndConvertToInt(executeLargeUpdate(sql));\n}\n", "docstring": "execute a sql insert , update or delete statement . in addition sql statements that return nothing such as sql ddl statements can be executed .", "partition": "test"}
{"idx": "1878", "code": "@LayoutlibDelegate static long currentThreadTimeMillis(){\n  return System.currentTimeMillis();\n}\n", "docstring": "returns milliseconds running in the current thread .", "partition": "test"}
{"idx": "1879", "code": "public static Entry makeEntry(List<String> ldifLines){\n  return makeEntry(ldifLines.toArray(new String[ldifLines.size()]));\n}\n", "docstring": "builds an entry from the provided lines of ldif .", "partition": "test"}
{"idx": "1880", "code": "public int format(int val,byte[] buf,int off,int len){\n  if (val == Integer.MIN_VALUE) {\n    if (len > ByteFormatter.NUMBER_BASE) {\n      return format(\"-2147483648\",buf,off,len);\n    }\n else {\n      truncationFiller(buf,off,len);\n      return off + len;\n    }\n  }\n  int pos=Math.abs(val);\n  int ndig=1;\n  int dmax=ByteFormatter.NUMBER_BASE;\n  while (ndig < ByteFormatter.NUMBER_BASE && pos >= dmax) {\n    ndig++;\n    dmax*=ByteFormatter.NUMBER_BASE;\n  }\n  if (val < 0) {\n    ndig++;\n  }\n  if (ndig > len || ndig > buf.length - off) {\n    truncationFiller(buf,off,len);\n    return off + len;\n  }\n  off+=ndig;\n  int xoff=off - 1;\n  do {\n    buf[xoff]=ByteFormatter.DIGITS[pos % ByteFormatter.NUMBER_BASE];\n    xoff--;\n    pos/=ByteFormatter.NUMBER_BASE;\n  }\n while (pos > 0);\n  if (val < 0) {\n    buf[xoff]=(byte)\'-\';\n  }\n  return off;\n}\n", "docstring": "format an int into an existing array .", "partition": "test"}
{"idx": "1881", "code": "public void append(char c[]){\n  int maxlength=buffer.length - pos;\n  if (c.length < maxlength) {\n    System.arraycopy(c,0,buffer,pos,c.length);\n    pos+=c.length;\n  }\n else {\n    System.arraycopy(c,0,buffer,pos,maxlength);\n    curr.next=new Entity(buffer);\n    curr=curr.next;\n    length+=buffer.length;\n    buffer=new char[(buffer.length > c.length - maxlength) ? buffer.length : c.length - maxlength];\n    if (c.length > maxlength) {\n      System.arraycopy(c,maxlength,buffer,0,c.length - maxlength);\n      pos=c.length - maxlength;\n    }\n else {\n      pos=0;\n    }\n  }\n}\n", "docstring": "method to appennd a charr array to the buffer", "partition": "test"}
{"idx": "1882", "code": "private boolean isAnnotation(){\n  return implInterfaces.contains(\"java.lang.annotation.Annotation\");\n}\n", "docstring": "sees if the class under test is actually an annotation .", "partition": "test"}
{"idx": "1883", "code": "public final boolean isExceptionHandlerEquivalent(BasicBlock other){\n  if (exceptionHandlers != other.exceptionHandlers) {\n    Enumeration<BasicBlock> e1=getExceptionHandlers();\n    Enumeration<BasicBlock> e2=other.getExceptionHandlers();\n    while (e1.hasMoreElements()) {\n      if (!e2.hasMoreElements())       return false;\n      if (e1.nextElement() != e2.nextElement())       return false;\n    }\n    if (e2.hasMoreElements())     return false;\n  }\n  return true;\n}\n", "docstring": "compare the in scope exception handlers of two blocks .", "partition": "test"}
{"idx": "1884", "code": "public int checksum(){\n  return calculateChecksum(compile_checksum.toString());\n}\n", "docstring": "this value is good for naming the cache file .", "partition": "test"}
{"idx": "1885", "code": "public boolean longLabel(){\n  return fState.longLabel;\n}\n", "docstring": "returns true if long labels are uses in the indicator display .", "partition": "test"}
{"idx": "1886", "code": "public SecretBlock(Mario player,Group parent,int stageZone,float xPos,float yPos,float yoloWidth,Image... hitState){\n  super(BLOCK_COLLISION_DATA,xPos,yPos,0,0,(Image)null);\n  this.hitState=hitState[0];\n  yoloView=new ImageView(hitState[1]);\n  yoloView.setFitWidth(yoloWidth);\n  this.parent=parent;\n  zone=stageZone;\n}\n", "docstring": "constructs a single secretblock ( tile which generates one - ups in original game , but \" yolo \" image in this game ) .", "partition": "test"}
{"idx": "1887", "code": "private Socket openDataConnection(String cmd) throws sun.net.ftp.FtpProtocolException, IOException {\n  Socket clientSocket;\n  if (passiveMode) {\n    try {\n      return openPassiveDataConnection(cmd);\n    }\n catch (    sun.net.ftp.FtpProtocolException e) {\n      String errmsg=e.getMessage();\n      if (!errmsg.startsWith(\"PASV\") && !errmsg.startsWith(\"EPSV\")) {\n        throw e;\n      }\n    }\n  }\n  ServerSocket portSocket;\n  InetAddress myAddress;\n  String portCmd;\n  if (proxy != null && proxy.type() == Proxy.Type.SOCKS) {\n    throw new sun.net.ftp.FtpProtocolException(\"Passive mode failed\");\n  }\n  portSocket=new ServerSocket(0,1,server.getLocalAddress());\n  try {\n    myAddress=portSocket.getInetAddress();\n    if (myAddress.isAnyLocalAddress()) {\n      myAddress=server.getLocalAddress();\n    }\n    portCmd=\"EPRT |\" + ((myAddress instanceof Inet6Address) ? \"2\" : \"1\") + \"|\"+ myAddress.getHostAddress()+ \"|\"+ portSocket.getLocalPort()+ \"|\";\n    if (!issueCommand(portCmd) || !issueCommand(cmd)) {\n      portCmd=\"PORT \";\n      byte[] addr=myAddress.getAddress();\n      for (int i=0; i < addr.length; i++) {\n        portCmd=portCmd + (addr[i] & 0xFF) + \",\";\n      }\n      portCmd=portCmd + ((portSocket.getLocalPort() >>> 8) & 0xff) + \",\"+ (portSocket.getLocalPort() & 0xff);\n      issueCommandCheck(portCmd);\n      issueCommandCheck(cmd);\n    }\n    if (connectTimeout >= 0) {\n      portSocket.setSoTimeout(connectTimeout);\n    }\n else {\n      if (defaultConnectTimeout > 0) {\n        portSocket.setSoTimeout(defaultConnectTimeout);\n      }\n    }\n    clientSocket=portSocket.accept();\n    if (readTimeout >= 0) {\n      clientSocket.setSoTimeout(readTimeout);\n    }\n else {\n      if (defaultSoTimeout > 0) {\n        clientSocket.setSoTimeout(defaultSoTimeout);\n      }\n    }\n  }\n  finally {\n    portSocket.close();\n  }\n  if (useCrypto) {\n    try {\n      clientSocket=sslFact.createSocket(clientSocket,serverAddr.getHostName(),serverAddr.getPort(),true);\n    }\n catch (    Exception ex) {\n      throw new IOException(ex.getLocalizedMessage());\n    }\n  }\n  return clientSocket;\n}\n", "docstring": "opens a data connection with the server according to the set mode ( active or passive ) then send the command passed as an argument .", "partition": "test"}
{"idx": "1888", "code": "public static boolean installNormal(Context context,String filePath){\n  Intent i=new Intent(Intent.ACTION_VIEW);\n  File file=new File(filePath);\n  if (!file.exists() || !file.isFile() || file.length() <= 0) {\n    return false;\n  }\n  i.setDataAndType(Uri.parse(\"file://\" + filePath),\"application/vnd.android.package-archive\");\n  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  context.startActivity(i);\n  return true;\n}\n", "docstring": "install package normal by system intent", "partition": "test"}
{"idx": "1889", "code": "private void createInsertList(final IItem item,List<IItem> tempList,List<IItem> insertList,int depth,int removed){\n  if (!tempList.contains(item)) {\n    tempList.add(item);\n    if (depth == 0) {\n      insertList.add(item);\n    }\n    if (item.getItems() != null) {\n      depth++;\n      for (      IItem child : item.getItems()) {\n        createInsertList(child,tempList,insertList,depth,removed);\n      }\n    }\n  }\n else {\n    insertList.remove(item);\n    removed++;\n  }\n}\n", "docstring": "recursive helper method for createinsertlist", "partition": "test"}
{"idx": "1890", "code": "@SuppressWarnings(\"UnusedReturnValue\") public int readOutlineFileMetadata(final PdfObject OutlinesObj,final PdfObjectReader currentPdfFile){\n  final int count=OutlinesObj.getInt(PdfDictionary.Count);\n  final PdfObject FirstObj=OutlinesObj.getDictionary(PdfDictionary.First);\n  currentPdfFile.checkResolved(FirstObj);\n  if (FirstObj != null) {\n    final Element root=OutlineDataXML.createElement(\"root\");\n    OutlineDataXML.appendChild(root);\n    final int level=0;\n    readOutlineLevel(root,currentPdfFile,FirstObj,level,false);\n  }\n  return count;\n}\n", "docstring": "read the outline data", "partition": "test"}
{"idx": "1891", "code": "private int decodeRunLength(int k){\n  if ((k & 1) == 1) {\n    return ((k >>> 1) & 63) ^ 63;\n  }\n else {\n    return Integer.numberOfLeadingZeros(k << p + (31 - sp)) + 1;\n  }\n}\n", "docstring": "more of less the opposite of the encoding function but just for getting out run lengths .", "partition": "test"}
{"idx": "1892", "code": "public NoDuplicateValueGlobalConstraint(AbstractParameter<?,?>... parameters){\n  this.parameters=Arrays.asList(parameters);\n}\n", "docstring": "constructs a not - equal - value global parameter constraint . that is , the elements of a list of number parameters are not allowed to have equal values .", "partition": "test"}
{"idx": "1893", "code": "@SuppressWarnings(\"unchecked\") public RhythmOverlay inflateOverlay(String configString){\n  List<String> configStrings=Arrays.asList(configString.split(\"\\\\r?\\\\n\"));\n  return inflateOverlayInternal(configStrings,Collections.EMPTY_MAP,0);\n}\n", "docstring": "inflate a single overlay from overlay configuration string according to the syntax spec .", "partition": "test"}
{"idx": "1894", "code": "public boolean isSourceModified(Resource resource){\n  boolean modified=true;\n  String fileName=resource.getName();\n  String path=(String)templatePaths.get(fileName);\n  File currentFile=null;\n  for (int i=0; currentFile == null && i < paths.size(); i++) {\n    String testPath=(String)paths.get(i);\n    File testFile=new File(testPath,fileName);\n    if (testFile.canRead()) {\n      currentFile=testFile;\n    }\n  }\n  File file=new File(path,fileName);\n  if (currentFile == null || !file.exists()) {\n  }\n else   if (currentFile.equals(file) && file.canRead()) {\n    modified=(file.lastModified() != resource.getLastModified());\n  }\n  return modified;\n}\n", "docstring": "how to keep track of all the modified times across the paths . note that a file might have appeared in a directory which is earlier in the path ; so we should search the path and see if the file we find that way is the same as the one that we have cached .", "partition": "test"}
{"idx": "1895", "code": "protected void flip(BufferCapabilities.FlipContents flipAction){\n  if (peer != null) {\n    Image backBuffer=getBackBuffer();\n    if (backBuffer != null) {\n      peer.flip(0,0,backBuffer.getWidth(null),backBuffer.getHeight(null),flipAction);\n    }\n  }\n else {\n    throw new IllegalStateException(\"Component must have a valid peer\");\n  }\n}\n", "docstring": "flipping moves the contents of the back buffer to the front buffer , either by copying or by moving the video pointer .", "partition": "test"}
{"idx": "1896", "code": "protected void loadValue(String sValue){\n  try {\n    value=Byte.parseByte(sValue.trim());\n  }\n catch (  NumberFormatException nfe) {\n    revertToDefault();\n  }\n}\n", "docstring": "load value from property string value", "partition": "test"}
{"idx": "1897", "code": "public static Map<String,String> allNamespaces(SOAPElement ele){\n  Map<String,String> nsList=new TreeMap<String,String>();\n  log.trace(\"Starting Namespace Lookup in \" + ele.getNodeName());\n  allNamespaces(ele,nsList);\n  log.trace(\"Namespace Lookup done: \" + nsList);\n  return nsList;\n}\n", "docstring": "returns a list of all namespaces below an element ( recursive )", "partition": "test"}
{"idx": "1898", "code": "private void drawHook(Canvas canvas){\n  Path hookPath=new Path();\n  double sweepAngle=Math.PI / 180 * 180;\n  float y=(float)Math.sin(sweepAngle) * (getBigCircleRadius()) + rectF.height() / 2;\n  float x=(float)Math.cos(sweepAngle) * (getBigCircleRadius()) + rectF.width() / 2;\n  float i=getBigCircleRadius() / 2;\n  hookPath.addRoundRect(new RectF(i + i / 2,i + i / 2,i + i / 2 + 6,i + i + i / 2),3f,3f,Path.Direction.CCW);\n  hookPath.addRoundRect(new RectF(i + i / 2,(i + i + i / 2) - 3f,i + i / 2 + i + i,i + i + i / 2 + 3f),3f,3f,Path.Direction.CCW);\n  Matrix matrix=new Matrix();\n  matrix.reset();\n  int restoreCount=canvas.getSaveCount();\n  hookPath.close();\n  canvas.rotate(-45,rectF.centerX(),rectF.centerY());\n  canvas.drawPath(hookPath,mHookPaint);\n  canvas.restoreToCount(restoreCount);\n}\n", "docstring": "there is some bug and it \"'\" s not perfect . so we should improve this path for our projection", "partition": "test"}
{"idx": "1899", "code": "public void continueButtonActionPerformed(java.awt.event.ActionEvent e){\n  if (testRunning && testSuspended) {\n    testSuspended=false;\n    if (wrapTest) {\n      statusText1.setText(\"Running Wraparound Test\");\n      statusText1.setVisible(true);\n    }\n  }\n}\n", "docstring": "method to handle continue button in diagnostic frame", "partition": "test"}
{"idx": "1900", "code": "@HLEFunction(nid=0x9AC2EEAC,version=150) public int sceNetAdhocPtpFlush(@CheckArgument(\"checkPtpId\") int id,int timeout,int nonblock){\n  return 0;\n}\n", "docstring": "wait for data in the buffer to be sent", "partition": "test"}
{"idx": "1901", "code": "public void reset(){\n  displayCache.clear();\n  cachedID.clear();\n}\n", "docstring": "resets the drawer and its caches .", "partition": "test"}
{"idx": "1902", "code": "private void copyDirectory(File source,File dest) throws IOException {\n  for (  File f : source.listFiles()) {\n    File sourceFile=new File(source,f.getName());\n    File destFile=new File(dest,f.getName());\n    if (f.isDirectory()) {\n      destFile.mkdirs();\n      copyDirectory(sourceFile,destFile);\n    }\n else     copyFile(sourceFile,destFile);\n  }\n}\n", "docstring": "copy an entire directory from one location to another . this is used in file dumping .", "partition": "test"}
{"idx": "1903", "code": "private synchronized void rebuildJournal() throws IOException {\n  if (mJournalWriter != null) {\n    mJournalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new FileWriter(mJournalFileTmp),IO_BUFFER_SIZE);\n  writer.write(MAGIC);\n  writer.write(\"\\n\");\n  writer.write(VERSION_1);\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(mAppVersion));\n  writer.write(\"\\n\");\n  writer.write(\"\\n\");\n  for (  CacheEntry cacheEntry : mLruEntries.values()) {\n    if (cacheEntry.isUnderEdit()) {\n      writer.write(sACTION_LIST[ACTION_DIRTY] + \' \' + cacheEntry.getKey()+ \" \"+ cacheEntry.getSize()+ \'\\n\');\n    }\n else {\n      writer.write(sACTION_LIST[ACTION_CLEAN] + \' \' + cacheEntry.getKey()+ \" \"+ cacheEntry.getSize()+ \'\\n\');\n    }\n  }\n  writer.close();\n  mJournalFileTmp.renameTo(mJournalFile);\n  mJournalWriter=new BufferedWriter(new FileWriter(mJournalFile,true),IO_BUFFER_SIZE);\n}\n", "docstring": "creates a new journal that omits redundant information . this replaces the current journal if it exists .", "partition": "test"}
{"idx": "1904", "code": "private void recordLogData(){\n  try {\n    int size=mRecordingData.size();\n    if (size == 0) {\n      return;\n    }\n    Vector<String> recordingData=new Vector<>(mRecordingData);\n    File logDir=Constants.getRecordDir(this);\n    logDir.mkdirs();\n    File logFile=new File(logDir,mRecordingFilename);\n    FileWriter logFileWriter=new FileWriter(logFile,true);\n    for (int i=0; i < size; i++) {\n      logFileWriter.append(recordingData.elementAt(i) + \"\\n\");\n      mRecordingData.removeElementAt(0);\n    }\n    recordingData.removeAllElements();\n    logFileWriter.close();\n  }\n catch (  Exception e) {\n    Log.e(LOG_TAG,\"recordLogData:Error writing the log to file. Exception: \" + e.toString());\n  }\n}\n", "docstring": "save log data to file", "partition": "test"}
{"idx": "1905", "code": "private static List<Command> loadRewrites(String str){\n  assert str != null;\n  List<Command> commands=new ArrayList<>();\n  for (  String line : str.split(\"\\n\")) {\n    addLine(commands,line);\n  }\n  return commands;\n}\n", "docstring": "loads the rewrites from tab - separated values .", "partition": "test"}
{"idx": "1906", "code": "@Override public StateConnection onCloseRead(){\n  ConnectionProtocol request=request();\n  if (request != null) {\n    request.onCloseRead();\n  }\n  _sequenceClose.set(_sequenceRead.get());\n  if (_sequenceFlush.get() < _sequenceClose.get()) {\n    _isClosePending.set(true);\n    if (_sequenceFlush.get() < _sequenceClose.get()) {\n      return StateConnection.CLOSE_READ_S;\n    }\n else {\n      _isClosePending.set(false);\n      return StateConnection.CLOSE;\n    }\n  }\n else {\n    return StateConnection.CLOSE;\n  }\n}\n", "docstring": "called by reader thread on reader end of file .", "partition": "test"}
{"idx": "1907", "code": "private Map<UUID,int[]> reducers(Collection<ClusterNode> top,Map<UUID,Collection<HadoopInputSplit>> mappers,int reducerCnt){\n  int totalWeight=0;\n  List<WeightedNode> nodes=new ArrayList<>(top.size());\n  for (  ClusterNode node : top) {\n    Collection<HadoopInputSplit> split=mappers.get(node.id());\n    int weight=reducerNodeWeight(node,split != null ? split.size() : 0);\n    nodes.add(new WeightedNode(node.id(),weight,weight));\n    totalWeight+=weight;\n  }\n  int totalAdjustedWeight=0;\n  for (  WeightedNode node : nodes) {\n    node.floatWeight=((float)node.weight * reducerCnt) / totalWeight;\n    node.weight=Math.round(node.floatWeight);\n    totalAdjustedWeight+=node.weight;\n  }\n  Collections.sort(nodes);\n  if (totalAdjustedWeight > reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(nodes.size() - 1);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasPrevious())       iter=nodes.listIterator(nodes.size() - 1);\n      WeightedNode node=iter.previous();\n      if (node.weight > 0) {\n        node.weight-=1;\n        totalAdjustedWeight--;\n      }\n    }\n  }\n else   if (totalAdjustedWeight < reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(0);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasNext())       iter=nodes.listIterator(0);\n      WeightedNode node=iter.next();\n      if (node.floatWeight > 0.0f) {\n        node.weight+=1;\n        totalAdjustedWeight++;\n      }\n    }\n  }\n  int idx=0;\n  Map<UUID,int[]> reducers=new HashMap<>(nodes.size(),1.0f);\n  for (  WeightedNode node : nodes) {\n    if (node.weight > 0) {\n      int[] arr=new int[node.weight];\n      for (int i=0; i < arr.length; i++)       arr[i]=idx++;\n      reducers.put(node.nodeId,arr);\n    }\n  }\n  return reducers;\n}\n", "docstring": "create plan for reducers .", "partition": "test"}
{"idx": "1908", "code": "public void httpRequest(HttpRequestEvent e) throws java.io.IOException {\n  String request=e.getRequest();\n  if (Debug.debugging(\"shis\")) {\n    Debug.output(\"SHIS: Handling request - \\\"\" + request + \"\\\"\");\n  }\n  if (request.charAt(0) == \'/\') {\n    request=request.substring(0,request.length());\n  }\n  int index=0;\n  index=request.indexOf(\'?\');\n  if (index != -1) {\n    request=request.substring(index + 1,request.length());\n    Debug.message(\"shis\",\"SHIS: GET Request received\");\n  }\n else {\n    Debug.message(\"shis\",\"SHIS: Probably a POST Request received\");\n  }\n  try {\n    iServer.handleRequest(request,e.getOutputStream());\n  }\n catch (  IOException ioe) {\n    Debug.error(\"SHIS: caught IOException - \\n\" + ioe.getMessage());\n  }\ncatch (  MapRequestFormatException exception) {\n    String message=\"OpenMap SimpleHttpImageServer encountered an problem with your request:\\n\\n\" + exception.getMessage() + \"\\n\\n\"+ ErrorMessage;\n    HttpConnection.writeHttpResponse(e.getOutputStream(),HttpConnection.CONTENT_PLAIN,message);\n  }\n}\n", "docstring": "invoked when an http request is received .", "partition": "test"}
{"idx": "1909", "code": "public String format(double val){\n  DecimalFormat df=getDoubleFormat();\n  if (df != null) {\n    return df.format(val);\n  }\n  return Double.toString(val);\n}\n", "docstring": "formats the given double values .", "partition": "test"}
{"idx": "1910", "code": "public void removePositions(Collection<Integer> positions){\n  ArrayList<Integer> positionsList=new ArrayList<Integer>(positions);\n  Collections.sort(positionsList);\n  Collections.reverse(positionsList);\n  for (  int position : positionsList) {\n    mItems.remove(position);\n  }\n  notifyDataSetChanged();\n}\n", "docstring": "removes all elements at the specified positions in the list", "partition": "test"}
{"idx": "1911", "code": "private void resetShapeBounds(){\n  RoundRectangle2D.Double rrect=(RoundRectangle2D.Double)shape;\n  rrect.setRoundRect(0,0,getBounds().width - 1,getBounds().height - 1,10,10);\n}\n", "docstring": "rests the boundaries of the shape which is drawn as the rubberband . the boundaries of the shape need to be set so that when drawn they lie just inside the boundaries of the component on all four sides .", "partition": "test"}
{"idx": "1912", "code": "public static Colour attemptToGetAsColour(String part){\n  Colour col=null;\n  try {\n    col=Colour.valueOf(part.toUpperCase());\n  }\n catch (  Exception e) {\n  }\n  return col;\n}\n", "docstring": "attempt to parse string as a colour", "partition": "test"}
{"idx": "1913", "code": "public final ArrayList<Move> removeNonOptimal(Position pos,ArrayList<Move> moveList){\n  ArrayList<Move> optimalMoves=new ArrayList<Move>();\n  ArrayList<Move> unknownMoves=new ArrayList<Move>();\n  final int MATE0=100000;\n  int bestScore=-1000000;\n  UndoInfo ui=new UndoInfo();\n  for (  Move m : moveList) {\n    pos.makeMove(m,ui);\n    int pliesToDraw=Math.max(100 - pos.halfMoveClock,1);\n    GtbProbeResult res=gtbProbe(pos);\n    pos.unMakeMove(m,ui);\n    if (res.result == GtbProbeResult.UNKNOWN) {\n      unknownMoves.add(m);\n    }\n else {\n      int wScore;\n      if (res.result == GtbProbeResult.WMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=MATE0 - res.pliesToMate;\n else         wScore=1;\n      }\n else       if (res.result == GtbProbeResult.BMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=-(MATE0 - res.pliesToMate);\n else         wScore=-1;\n      }\n else {\n        wScore=0;\n      }\n      int score=pos.whiteMove ? wScore : -wScore;\n      if (score > bestScore) {\n        optimalMoves.clear();\n        optimalMoves.add(m);\n        bestScore=score;\n      }\n else       if (score == bestScore) {\n        optimalMoves.add(m);\n      }\n else {\n      }\n    }\n  }\n  for (  Move m : unknownMoves)   optimalMoves.add(m);\n  return (optimalMoves.size() < moveList.size()) ? optimalMoves : null;\n}\n", "docstring": "return a list of all moves in movelist that are not known to be non - optimal . returns null if no legal move could be excluded .", "partition": "test"}
{"idx": "1914", "code": "public static void executeRandomModifiableVariableModification(ModifiableVariableHolder object){\n  Field field=object.getRandomModifiableVariableField();\n  executeModifiableVariableModification(object,field);\n}\n", "docstring": "picks a random modifiable variable and executes a random modification on this variable .", "partition": "test"}
{"idx": "1915", "code": "public static boolean save(File file,String content){\n  boolean result;\n  BufferedWriter writer;\n  writer=null;\n  try {\n    writer=new BufferedWriter(new FileWriter(file));\n    writer.write(content);\n    writer.flush();\n    result=true;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    result=false;\n  }\n finally {\n    if (writer != null) {\n      try {\n        writer.close();\n      }\n catch (      Exception e) {\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "saves the content to a file .", "partition": "test"}
{"idx": "1916", "code": "private void deleteOldTemp(File fileCfg){\n  BufferedReader reader=null;\n  try {\n    int count=0;\n    reader=new BufferedReader(new FileReader(fileCfg));\n    String sLine;\n    while ((sLine=reader.readLine()) != null) {\n      File file=new File(sLine);\n      if (!file.exists()) {\n        continue;\n      }\n      if (file.delete()) {\n        count++;\n      }\n else {\n        hsDeleteOnExit.add(file);\n      }\n    }\n    logDebug(LogArea.CONFIG,\"Deleted %d old temp files listed in %s\",count,fileCfg.getAbsolutePath());\n  }\n catch (  IOException e) {\n  }\n finally {\n    if (reader != null) {\n      try {\n        reader.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n}\n", "docstring": "deletes temporary files listed in the file . the method is called on shutdown ( ) .", "partition": "test"}
{"idx": "1917", "code": "public void proposeTree() throws OperatorFailedException {\n  NodeRef i;\n  double oldMinAge, newMinAge, newRange, oldRange, newAge, q;\n  final int nodeCount=tree.getNodeCount();\n  do {\n    i=tree.getNode(MathUtils.nextInt(nodeCount));\n  }\n while (tree.getRoot() == i);\n  final NodeRef iP=tree.getParent(i);\n  NodeRef j=tree.getNode(MathUtils.nextInt(nodeCount));\n  NodeRef k=tree.getParent(j);\n  while ((k != null && tree.getNodeHeight(k) <= tree.getNodeHeight(i)) || (i == j)) {\n    j=tree.getNode(MathUtils.nextInt(nodeCount));\n    k=tree.getParent(j);\n  }\n  if (j == tree.getRoot() || iP == tree.getRoot()) {\n    throw new OperatorFailedException(\"Root changes not allowed!\");\n  }\n  if (k == iP || j == iP || k == i)   throw new OperatorFailedException(\"move failed\");\n  final NodeRef CiP=getOtherChild(tree,iP,i);\n  NodeRef PiP=tree.getParent(iP);\n  newMinAge=Math.max(tree.getNodeHeight(i),tree.getNodeHeight(j));\n  newRange=tree.getNodeHeight(k) - newMinAge;\n  newAge=newMinAge + (MathUtils.nextDouble() * newRange);\n  oldMinAge=Math.max(tree.getNodeHeight(i),tree.getNodeHeight(CiP));\n  oldRange=tree.getNodeHeight(PiP) - oldMinAge;\n  q=newRange / Math.abs(oldRange);\n  tree.beginTreeEdit();\n  if (j == tree.getRoot()) {\n    tree.removeChild(iP,CiP);\n    tree.removeChild(PiP,iP);\n    tree.addChild(iP,j);\n    tree.addChild(PiP,CiP);\n    tree.setRoot(iP);\n  }\n else   if (iP == tree.getRoot()) {\n    tree.removeChild(k,j);\n    tree.removeChild(iP,CiP);\n    tree.addChild(iP,j);\n    tree.addChild(k,iP);\n    tree.setRoot(CiP);\n  }\n else {\n    tree.removeChild(k,j);\n    tree.removeChild(iP,CiP);\n    tree.removeChild(PiP,iP);\n    tree.addChild(iP,j);\n    tree.addChild(k,iP);\n    tree.addChild(PiP,CiP);\n  }\n  tree.setNodeHeight(iP,newAge);\n  tree.endTreeEdit();\n  logq=Math.log(q);\n}\n", "docstring": "warning : assumes strictly bifurcating tree .", "partition": "test"}
{"idx": "1918", "code": "public void flush(){\n  final BigdataSailRepositoryConnection cxn=tlTx.get();\n  if (cxn != null) {\n    Code.wrapThrow(null);\n  }\n}\n", "docstring": "flush the statement buffers to the indices without committing .", "partition": "test"}
{"idx": "1919", "code": "@Override public BufferedImage JPEGToRGBImage(final byte[] data,final int ww,final int hh,final int pX,final int pY){\n  BufferedImage image=null;\n  Raster ras=JPEGDecoder.getRasterFromJPEG(data,\"JPEG\");\n  if (ras != null) {\n    ras=cleanupRaster(ras,pX,pY,componentCount);\n    final int w=ras.getWidth();\n    final int h=ras.getHeight();\n    final DataBufferByte rgb=(DataBufferByte)ras.getDataBuffer();\n    image=createImage(w,h,rgb.getData());\n  }\n  return image;\n}\n", "docstring": "convert data stream to srgb image", "partition": "test"}
{"idx": "1920", "code": "public void despawn(VisibleObject object){\n  despawn(object,true);\n}\n", "docstring": "despawn visibleobject , object will become invisible and object position will become invalid . all others objects will be noticed that this object is no longer visible .", "partition": "test"}
{"idx": "1921", "code": "@SuppressWarnings(\"rawtypes\") public static void createProjectConstraint(ZipFile zip,Project aProject,RepositoryService aRepository) throws IOException {\n  for (Enumeration zipEnumerate=zip.entries(); zipEnumerate.hasMoreElements(); ) {\n    ZipEntry entry=(ZipEntry)zipEnumerate.nextElement();\n    String entryName=normalizeEntryName(entry);\n    if (entryName.startsWith(CONSTRAINTS)) {\n      String filename=FilenameUtils.getName(entry.getName());\n      ConstraintSet constraintSet=new ConstraintSet();\n      constraintSet.setProject(aProject);\n      constraintSet.setName(filename);\n      aRepository.createConstraintSet(constraintSet);\n      aRepository.writeConstraintSet(constraintSet,zip.getInputStream(entry));\n      LOG.info(\"Imported constraint [\" + filename + \"] for project [\"+ aProject.getName()+ \"] with id [\"+ aProject.getId()+ \"]\");\n    }\n  }\n}\n", "docstring": "copy constraints from the exported project", "partition": "test"}
{"idx": "1922", "code": "public Operation copyTo(Extent target){\n  BlockTransformExtent extent=new BlockTransformExtent(original,transform,worldData.getBlockRegistry());\n  ForwardExtentCopy copy=new ForwardExtentCopy(extent,original.getRegion(),original.getOrigin(),target,original.getOrigin());\n  copy.setTransform(transform);\n  return copy;\n}\n", "docstring": "create an operation to copy from the original clipboard to the given extent .", "partition": "test"}
{"idx": "1923", "code": "@CallerSensitive public Class<?> forClass(){\n  if (cl == null) {\n    return null;\n  }\n  requireInitialized();\n  if (System.getSecurityManager() != null) {\n    Class<?> caller=Reflection.getCallerClass();\n    if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),cl.getClassLoader())) {\n      ReflectUtil.checkPackageAccess(cl);\n    }\n  }\n  return cl;\n}\n", "docstring": "return the class in the local vm that this version is mapped to . null is returned if there is no corresponding local class .", "partition": "test"}
{"idx": "1924", "code": "private void pathStyleHelper(String style,String offset){\n  if (style == null) {\n    return;\n  }\n  if (style.equals(\"none\")) {\n    strokePaint.setPathEffect(null);\n    return;\n  }\n  StringTokenizer st=new StringTokenizer(style,\" ,\");\n  int count=st.countTokens();\n  float[] intervals=new float[(count & 1) == 1 ? count * 2 : count];\n  float max=0;\n  float current=1f;\n  int i=0;\n  while (st.hasMoreTokens()) {\n    intervals[i++]=current=toFloat(st.nextToken(),current);\n    max+=current;\n  }\n  for (int start=0; i < intervals.length; i++, start++) {\n    max+=intervals[i]=intervals[start];\n  }\n  float off=0f;\n  if (offset != null) {\n    try {\n      off=Float.parseFloat(offset) % max;\n    }\n catch (    NumberFormatException e) {\n    }\n  }\n  strokePaint.setPathEffect(new DashPathEffect(intervals,off));\n}\n", "docstring": "set the path style ( if any ) stroke - dasharray = \" n1 , n2 , . . . \" stroke - dashoffset = n", "partition": "test"}
{"idx": "1925", "code": "private Size parseOldBoundedSize(String token,boolean setMax){\n  int semicolonIndex=token.indexOf(\';\');\n  String sizeToken1=token.substring(4,semicolonIndex);\n  String sizeToken2=token.substring(semicolonIndex + 1,token.length() - 1);\n  Size size1=parseAtomicSize(sizeToken1);\n  Size size2=parseAtomicSize(sizeToken2);\n  if (isConstant(size1)) {\n    if (size2 instanceof Sizes.ComponentSize) {\n      return new BoundedSize(size2,setMax ? null : size1,setMax ? size1 : null);\n    }\n    throw new IllegalArgumentException(\"Bounded sizes must not be both constants.\");\n  }\n  if (isConstant(size2)) {\n    return new BoundedSize(size1,setMax ? null : size2,setMax ? size2 : null);\n  }\n  throw new IllegalArgumentException(\"Bounded sizes must not be both logical.\");\n}\n", "docstring": "parses an encoded compound size and sets the size fields . the compound size has format : max ( & lt ; atomic size & gt ; ; & lt ; atomic size2 & gt ; ) | min ( & lt ; atomic size1 & gt ; ; & lt ; atomic size2 & gt ; ) one of the two atomic sizes must be a logical size , the other must be a size constant .", "partition": "test"}
{"idx": "1926", "code": "Builder addEncodedQueryParameter(String encodedName,String encodedValue){\n  if (encodedName == null)   throw new IllegalArgumentException(\"encodedName == null\");\n  if (encodedQueryNamesAndValues == null)   encodedQueryNamesAndValues=new ArrayList<>();\n  encodedQueryNamesAndValues.add(canonicalize(encodedName,QUERY_COMPONENT_ENCODE_SET,true,true));\n  encodedQueryNamesAndValues.add(encodedValue != null ? canonicalize(encodedValue,QUERY_COMPONENT_ENCODE_SET,true,true) : null);\n  return this;\n}\n", "docstring": "adds the pre - encoded query parameter to this url \"'\" s query string .", "partition": "test"}
{"idx": "1927", "code": "private static a createImageLink(String AD_Language,String name,String js_command,boolean enabled,boolean pressed){\n  a img=new a(\"#\",createImage(AD_Language,name));\n  if (!pressed || !enabled)   img.setID(\"imgButtonLink\");\n else   img.setID(\"imgButtonPressedLink\");\n  if (js_command == null)   js_command=\"\'Submit\'\";\n  if (js_command.length() > 0 && enabled) {\n    if (js_command.startsWith(\"startPopup\"))     img.setOnClick(js_command);\n else     img.setOnClick(\"SubmitForm(\'\" + name + \"\', \"+ js_command+ \",\'toolbar\');return false;\");\n  }\n  img.setClass(\"ToolbarButton\");\n  img.setOnMouseOver(\"window.status=\'\" + name + \"\';return true;\");\n  img.setOnMouseOut(\"window.status=\'\';return true;\");\n  img.setOnBlur(\"this.hideFocus=false\");\n  return img;\n}\n", "docstring": "create image with name , id of button_name and set p_command onclick", "partition": "test"}
{"idx": "1928", "code": "public Namespace(PrincipalUser creator,String qualifier,PrincipalUser owner,Set<PrincipalUser> users){\n  super(creator);\n  setQualifier(qualifier);\n  setOwner(owner);\n  if (users != null && !users.isEmpty()) {\n    setUsers(users);\n  }\n  addUser(owner);\n}\n", "docstring": "creates a new namespace object .", "partition": "test"}
{"idx": "1929", "code": "public final int decrementAndGet(){\n  return unsafe.getAndAddInt(this,valueOffset,-1) - 1;\n}\n", "docstring": "atomically decrements by one the current value .", "partition": "test"}
{"idx": "1930", "code": "public void update(long dt,float ratioY){\n  double step=2 * Math.PI / POINTS_PER_CIRCLE;\n  angle+=dt * BUBBLE_D_ANGLE;\n  float fromX=startX + (float)(0.05f * Math.sin(angle));\n  float toX=fromX + size;\n  float fromY=this.fromY + dt * speed;\n  float toY=fromY + size;\n  centerY+=dt * virtualSpeed;\n  getColor()[3]=(TOP_Y - centerY / TOP_Y);\n  vertexBuffer.put(0,Utils.normalizeGl(0,fromX,toX));\n  vertexBuffer.put(1,Utils.normalizeGl(centerY * ratioY,fromY,toY));\n  for (int i=1; i <= POINTS_PER_CIRCLE; i++) {\n    vertexBuffer.put(COORDS_PER_VERTEX * i,Utils.normalizeGl((float)Math.sin(-Math.PI + step * i),fromX,toX));\n    vertexBuffer.put(COORDS_PER_VERTEX * i + 1,Utils.normalizeGl((float)Math.cos(-Math.PI + step * i) * ratioY,fromY,toY));\n  }\n  this.fromY=fromY;\n}\n", "docstring": "update position of bubble .", "partition": "test"}
{"idx": "1931", "code": "public final void clear(){\n  if (GWT.isScript()) {\n    jsArray.clear();\n  }\n else {\n    javaArray.clear();\n  }\n}\n", "docstring": "remove all elements on this list", "partition": "test"}
{"idx": "1932", "code": "@Override public synchronized void clear(){\n  File[] files=mRootDirectory.listFiles();\n  if (files != null) {\n    for (    File file : files) {\n      file.delete();\n    }\n  }\n  mEntries.clear();\n  VolleyLog.d(\"Cache cleared.\");\n}\n", "docstring": "clears the cache . deletes all cached files from disk .", "partition": "test"}
{"idx": "1933", "code": "private void updatePodcastPublicationDateAndLastMediaUrl(Episode episode,Podcast podcast){\n  Date podcastPublicationDate=podcast.getPublicationDate();\n  boolean episodePubDateIsMoreRecent=episode.getPublicationDate() != null && (podcastPublicationDate == null || podcastPublicationDate.before(episode.getPublicationDate()));\n  if (episodePubDateIsMoreRecent) {\n    podcast.setPublicationDate(episode.getPublicationDate());\n    podcast.setLastEpisodeMediaUrl(episode.getMediaUrl());\n  }\n}\n", "docstring": "set the podcast \"'\" s publication date to the episode \"'\" s if it is more recent", "partition": "test"}
{"idx": "1934", "code": "private void removeOurUIs(){\n  for (  String uiName : UI_LIST) {\n    uiDefaults.remove(uiName + \"UI\");\n  }\n}\n", "docstring": "use our ui delegate for the specified ui control type .", "partition": "test"}
{"idx": "1935", "code": "public void makeImmutable(){\n}\n", "docstring": "makes the object immutable", "partition": "test"}
{"idx": "1936", "code": "public static <O>KNNQuery<O> precomputedKNNQuery(Database database,Relation<O> relation,DistanceQuery<O> dq,int k){\n  KNNQuery<O> knnq=database.getKNNQuery(dq,k,DatabaseQuery.HINT_HEAVY_USE,DatabaseQuery.HINT_OPTIMIZED_ONLY,DatabaseQuery.HINT_NO_CACHE);\n  if (knnq instanceof PreprocessorKNNQuery) {\n    return knnq;\n  }\n  MaterializeKNNPreprocessor<O> preproc=new MaterializeKNNPreprocessor<>(relation,dq.getDistanceFunction(),k);\n  preproc.initialize();\n  return preproc.getKNNQuery(dq,k);\n}\n", "docstring": "get ( or create ) a precomputed knn query for the database .", "partition": "test"}
{"idx": "1937", "code": "public static SortedSet<Integer> adjustPosition(Set<Integer> positions,int startPosition,int endPosition,int adjustBy){\n  SortedSet<Integer> newPositions=new TreeSet<>();\n  for (  Integer entry : positions) {\n    int position=entry;\n    if (position < startPosition || position > endPosition) {\n      newPositions.add(position);\n    }\n else     if (adjustBy > 0) {\n      newPositions.add(position + adjustBy);\n    }\n else     if (adjustBy < 0) {\n      if (position > startPosition + adjustBy && position <= startPosition) {\n        ;\n      }\n else {\n        newPositions.add(position + adjustBy);\n      }\n    }\n  }\n  return newPositions;\n}\n", "docstring": "internal method to handle the selections if items are added / removed", "partition": "test"}
{"idx": "1938", "code": "private ResolvedMigration createAvailableMigration(int version){\n  ResolvedMigration migration=new ResolvedMigration();\n  migration.setVersion(MigrationVersion.fromVersion(Integer.toString(version)));\n  migration.setDescription(\"abc\");\n  migration.setScript(\"x\");\n  migration.setType(MigrationType.CQL);\n  return migration;\n}\n", "docstring": "creates a new available migration with this version .", "partition": "test"}
{"idx": "1939", "code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver observer){\n  if (img == null) {\n    return true;\n  }\n  if (xform == null || xform.isIdentity()) {\n    return drawImage(img,0,0,null,observer);\n  }\n  if (isHiDPIImage(img)) {\n    final int w=img.getWidth(null);\n    final int h=img.getHeight(null);\n    final AffineTransform tx=new AffineTransform(transform);\n    transform(xform);\n    boolean result=drawHiDPIImage(img,0,0,w,h,0,0,w,h,null,observer);\n    transform.setTransform(tx);\n    invalidateTransform();\n    return result;\n  }\n  try {\n    return imagepipe.transformImage(this,img,xform,observer);\n  }\n catch (  InvalidPipeException e) {\n    try {\n      revalidateAll();\n      return imagepipe.transformImage(this,img,xform,observer);\n    }\n catch (    InvalidPipeException e2) {\n      return false;\n    }\n  }\n finally {\n    surfaceData.markDirty();\n  }\n}\n", "docstring": "draw an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics2d . the given transformation is applied to the image before the transform attribute in the graphics2d state is applied . the rendering attributes applied include the clip , transform , paint or color and composite attributes . note that the result is undefined , if the given transform is non - invertible .", "partition": "test"}
{"idx": "1940", "code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  super.beginDisplay(event,false);\n  resetButtonState(TBL_BUTTON_DELETE);\n  AgentsModel model=(AgentsModel)getModel();\n  String agentType=getDisplayIDType();\n  Object[] param={agentType};\n  ptModel.setPageTitleText(model.getLocalizedString(\"agenttype.\" + agentType));\n  ptModel.setPageTitleHelpMessage(model.getLocalizedString(\"agenttype.\" + agentType + \".help\"));\n  tblModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agents.title.name\"),param));\n  tblModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblGroupModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.title.name\"),param));\n  tblGroupModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  tblGroupModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  getAgentNames();\n  CCButton b=(CCButton)getChild(TBL_BUTTON_DELETE);\n  b.setDisabled(true);\n  b=(CCButton)getChild(TBL_BUTTON_DELETE_GROUP);\n  b.setDisabled(true);\n}\n", "docstring": "sets the agent title and populates the agent and agent group action table .", "partition": "test"}
{"idx": "1941", "code": "public void select_all(){\n  Arrays.fill(sel_array,true);\n}\n", "docstring": "selects all item types .", "partition": "test"}
{"idx": "1942", "code": "public NvpBuilder addRaw(final String name,final String value){\n  npv.put(name,value);\n  return this;\n}\n", "docstring": "add raw name value pair .", "partition": "test"}
{"idx": "1943", "code": "@Override public int length(){\n  return set.size();\n}\n", "docstring": "returns the set length", "partition": "test"}
{"idx": "1944", "code": "public List<CountryRO> viewAddressCountryOptions(final ShoppingCart cart,final Shop shop,final String addressType){\n  final List<Country> countries=addressBookFacade.getAllCountries(shop.getCode(),addressType);\n  return map(countries,CountryRO.class,Country.class);\n}\n", "docstring": "common address book function .", "partition": "test"}
{"idx": "1945", "code": "public void addPauseListener(AnimatorPauseListener listener){\n  if (mPauseListeners == null) {\n    mPauseListeners=new ArrayList<AnimatorPauseListener>();\n  }\n  mPauseListeners.add(listener);\n}\n", "docstring": "adds a pause listener to this animator .", "partition": "test"}
{"idx": "1946", "code": "@Override public void makeImmutable(){\n  if (mutable) {\n    if (attrs != null) {\n      Iterator iter=attrs.iterator();\n      while (iter.hasNext()) {\n        Attribute attr=(Attribute)iter.next();\n        attr.makeImmutable();\n      }\n      attrs=Collections.unmodifiableList(attrs);\n    }\n    if (encAttrs != null) {\n      encAttrs=Collections.unmodifiableList(encAttrs);\n    }\n    mutable=false;\n  }\n}\n", "docstring": "makes the object immutable .", "partition": "test"}
{"idx": "1947", "code": "@Override public boolean batchFinished() throws Exception {\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  Instances toFilter=getInputFormat();\n  if (!isFirstBatchDone()) {\n    Instances toFilterIgnoringAttributes=removeIgnored(toFilter);\n    File file=getSerializedClustererFile();\n    if (!file.isDirectory()) {\n      ObjectInputStream ois=new ObjectInputStream(new FileInputStream(file));\n      m_ActualClusterer=(Clusterer)ois.readObject();\n      Instances header=null;\n      try {\n        header=(Instances)ois.readObject();\n      }\n catch (      Exception e) {\n      }\n      ois.close();\n      if ((header != null) && (!header.equalHeaders(toFilterIgnoringAttributes))) {\n        throw new WekaException(\"Training header of clusterer and filter dataset don\'t match:\\n\" + header.equalHeadersMsg(toFilterIgnoringAttributes));\n      }\n    }\n else {\n      m_ActualClusterer=AbstractClusterer.makeCopy(m_Clusterer);\n      m_ActualClusterer.buildClusterer(toFilterIgnoringAttributes);\n    }\n    Instances filtered=new Instances(toFilter,0);\n    ArrayList<String> nominal_values=new ArrayList<String>(m_ActualClusterer.numberOfClusters());\n    for (int i=0; i < m_ActualClusterer.numberOfClusters(); i++) {\n      nominal_values.add(\"cluster\" + (i + 1));\n    }\n    filtered.insertAttributeAt(new Attribute(\"cluster\",nominal_values),filtered.numAttributes());\n    setOutputFormat(filtered);\n  }\n  for (int i=0; i < toFilter.numInstances(); i++) {\n    convertInstance(toFilter.instance(i));\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}\n", "docstring": "signify that this batch of input to the filter is finished .", "partition": "test"}
{"idx": "1948", "code": "public void addComponent(T component){\n  components.add(component);\n}\n", "docstring": "adds a component to the composite .", "partition": "test"}
{"idx": "1949", "code": "public static UiResult openUrl(URI uri){\n  return openUrl(uri.toString());\n}\n", "docstring": "launch url in a new window .", "partition": "test"}
{"idx": "1950", "code": "public ByteBandedRaster(SampleModel sampleModel,Point origin){\n  this(sampleModel,sampleModel.createDataBuffer(),new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}\n", "docstring": "constructs a bytebandedraster with the given samplemodel . the raster \"'\" s upper left corner is origin and it is the same size as the samplemodel . a databuffer large enough to describe the raster is automatically created . samplemodel must be of type bandedsamplemodel .", "partition": "test"}
{"idx": "1951", "code": "static boolean isRefreshNotificationRegistered(NotificationListener client,RefreshNotificationType type){\n  boolean isRegistered=false;\n  Map<RefreshNotificationType,Integer> notifications=null;\nsynchronized (refreshClients) {\n    notifications=(Map<RefreshNotificationType,Integer>)refreshClients.get(client);\n  }\n  if (notifications != null) {\n    Integer timerNotificationId=notifications.get(type);\n    if (timerNotificationId != null) {\n      isRegistered=true;\n    }\n  }\n  return isRegistered;\n}\n", "docstring": "verifies a refresh notification for the specified client mbean . if notification is not registered , then returns a false", "partition": "test"}
{"idx": "1952", "code": "private Collection<String> readProcessOutput(Process proc) throws IOException {\n  BufferedReader rdr=new BufferedReader(new InputStreamReader(proc.getInputStream()));\n  Collection<String> res=new ArrayList<>();\n  String s;\n  while ((s=rdr.readLine()) != null)   res.add(s);\n  return res;\n}\n", "docstring": "reads process output line - by - line .", "partition": "test"}
{"idx": "1953", "code": "public void fillHeaderAndFooter(final HttpServletRequest request,final HttpServletResponse response,final Map<String,Object> dataModel) throws Exception {\n  fillHeader(request,response,dataModel);\n  fillFooter(dataModel);\n}\n", "docstring": "fills header and footer .", "partition": "test"}
{"idx": "1954", "code": "public void addOperand(ISpacePredicate operand){\n  if (_operandsList == null)   _operandsList=new ArrayList<ISpacePredicate>();\n  _operandsList.add(operand);\n}\n", "docstring": "adds an operand at the end of the current operands list .", "partition": "test"}
{"idx": "1955", "code": "public static String decode(String s,Type t){\n  if (s == null) {\n    throw new IllegalArgumentException();\n  }\n  final int n=s.length();\n  if (n == 0) {\n    return s;\n  }\n  if (s.indexOf(\'%\') < 0) {\n    if (t == Type.QUERY_PARAM) {\n      if (s.indexOf(\'+\') < 0) {\n        return s;\n      }\n    }\n else {\n      return s;\n    }\n  }\n else {\n    if (n < 2) {\n      throw new IllegalArgumentException(\"Malformed percent-encoded octet at index 1\");\n    }\n    if (s.charAt(n - 2) == \'%\') {\n      throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + (n - 2));\n    }\n  }\n  if (t == null) {\n    return decode(s,n);\n  }\nswitch (t) {\ncase HOST:\n    return decodeHost(s,n);\ncase QUERY_PARAM:\n  return decodeQueryParam(s,n);\ndefault :\nreturn decode(s,n);\n}\n}\n", "docstring": "decodes characters of a string that are percent - encoded octets using utf - 8 decoding ( if needed ) . < p > it is assumed that the string is valid according to an ( unspecified ) uri component type . if a sequence of contiguous percent - encoded octets is not a valid utf - 8 character then the octets are replaced with \"'\" \\ ufffd \"'\" . < p > if the uri component is of type host then any \" % \" found between \" [ ", "partition": "test"}
{"idx": "1956", "code": "public BigDecimal calculateTotalCollectedAmt(final BillReceiptInfo bri,final List<EgBillDetails> billDetList) throws InvalidAccountHeadException {\n  return bri.getTotalAmount();\n}\n", "docstring": "called to calculate the total receipt amount i , e the amount which has been paid for the bill from the billreceiptinfo the amount will be calculated . if the glcode which exists in egbilldetails is not matching with the glcode the erpcollection send , then an exception will be raised ( invalidaccountheadexception ) .", "partition": "test"}
{"idx": "1957", "code": "public void skip(int count) throws IOException {\n  int skipCount=Math.min(limit - position,count);\n  while (true) {\n    position+=skipCount;\n    count-=skipCount;\n    if (count == 0)     break;\n    skipCount=Math.min(count,capacity);\n    require(skipCount);\n  }\n}\n", "docstring": "discards the specified number of bytes .", "partition": "test"}
{"idx": "1958", "code": "public void test_concurrent_modification_insert(){\n  final BTree btree;\n{\n    IndexMetadata md=new IndexMetadata(UUID.randomUUID());\n    md.setBranchingFactor(20);\n    btree=BTree.create(new SimpleMemoryRawStore(),md);\n    btree.insert(10,\"Bryan\");\n    btree.insert(20,\"Mike\");\n    btree.insert(30,\"James\");\n  }\n{\n    ITupleCursor2<String> cursor=newCursor(btree);\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.seek(20));\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.tuple());\n    btree.insert(15,\"Paul\");\n    assertEquals(TestKeyBuilder.asSortKey(20),cursor.currentKey());\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.tuple());\n    assertEquals(new TestTuple<String>(15,\"Paul\"),cursor.prior());\n    assertEquals(new TestTuple<String>(15,\"Paul\"),cursor.tuple());\n    btree.remove(15);\n    assertEquals(null,cursor.tuple());\n    assertEquals(TestKeyBuilder.asSortKey(15),cursor.currentKey());\n    assertEquals(new TestTuple<String>(20,\"Mike\"),cursor.next());\n    btree.remove(20);\n    assertEquals(null,cursor.tuple());\n    assertEquals(TestKeyBuilder.asSortKey(20),cursor.currentKey());\n    btree.insert(25,\"Allen\");\n    assertEquals(TestKeyBuilder.asSortKey(20),cursor.currentKey());\n    assertEquals(null,cursor.tuple());\n    assertEquals(new TestTuple<String>(25,\"Allen\"),cursor.next());\n    assertEquals(new TestTuple<String>(25,\"Allen\"),cursor.tuple());\n  }\n}\n", "docstring": "unit test for concurrent modification resulting from insert ( ) and remove ( ) .", "partition": "test"}
{"idx": "1959", "code": "public void removeAllIms(){\n  ims.clear();\n}\n", "docstring": "removes all im \"'\" s from this user", "partition": "test"}
{"idx": "1960", "code": "public void copyReader(String encoding,Reader r) throws IOException {\n  super.setContentEncoding(encoding);\n  String s=readString(r);\n  content=s.getBytes(encoding);\n}\n", "docstring": "set the content by copying characters from the given reader and converting them into bytes using the specified encoding .", "partition": "test"}
{"idx": "1961", "code": "private void clearDictionaryCache(){\n  Map<String,Dictionary> dictionaryCaches=surrogateKeyGen.getDictionaryCaches();\n  List<Dictionary> reverseDictionaries=new ArrayList<>(dictionaryCaches.values());\n  for (int i=0; i < reverseDictionaries.size(); i++) {\n    Dictionary dictionary=reverseDictionaries.get(i);\n    dictionary.clear();\n  }\n}\n", "docstring": "this method will clear the dictionary access count so that any unused column can be removed from the cache", "partition": "test"}
{"idx": "1962", "code": "public static String toTypeString(Object[] arguments,int maxSize){\n  if (arguments == null) {\n    return \"null\";\n  }\n  StringBuilder argBuf=new StringBuilder();\n  for (int i=0; i < arguments.length; i++) {\n    if (maxSize != -1 && argBuf.length() > maxSize) {\n      argBuf.append(\"...\");\n      break;\n    }\n else {\n      if (i > 0) {\n        argBuf.append(\", \");\n      }\n      argBuf.append(arguments[i] != null ? typeName(arguments[i]) : \"null\");\n    }\n  }\n  return argBuf.toString();\n}\n", "docstring": "a helper method to format the arguments types as a comma - separated list .", "partition": "test"}
{"idx": "1963", "code": "public boolean renameFile(File oldFile,File newFile){\nsynchronized (fileCache) {\n    if (oldFile.renameTo(newFile)) {\n      validateFileCache();\n      return true;\n    }\n    return false;\n  }\n}\n", "docstring": "renames a file in the underlying file system .", "partition": "test"}
{"idx": "1964", "code": "public Future<?> execute(CameraCommand command){\n  if (mClosed) {\n    return Futures.immediateFuture(null);\n  }\nsynchronized (mLock) {\n    if (mExecutor == null) {\n      mExecutor=mExecutorProvider.get();\n    }\n    checkNotNull(mExecutor);\n    return mExecutor.submit(new CommandRunnable(command));\n  }\n}\n", "docstring": "executes the given command , returning a future to indicate its status and allow ( interruptible ) cancellation .", "partition": "test"}
{"idx": "1965", "code": "public int length(){\n  return text.length();\n}\n", "docstring": "retruns the length of the text . alternativ you can use gettext ( ) . length ( )", "partition": "test"}
{"idx": "1966", "code": "public static String serializeDigestResponse(Map<String,String> paramMap){\n  StringBuilder sb=new StringBuilder(\"Digest \");\n  boolean prefixComma=false;\n  for (  Map.Entry<String,String> entry : paramMap.entrySet()) {\n    if (!prefixComma) {\n      prefixComma=true;\n    }\n else {\n      sb.append(\", \");\n    }\n    sb.append(entry.getKey());\n    sb.append(\"=\");\n    sb.append(entry.getValue());\n  }\n  return sb.toString();\n}\n", "docstring": "serialize a parameter map into a digest response . this is used as the \" authorization \" header in the request . all parameters in the supplied map will be added to the header .", "partition": "test"}
{"idx": "1967", "code": "protected JsonEncoding findEncoding(MediaType mediaType,MultivaluedMap<String,Object> httpHeaders){\n  return JsonEncoding.UTF8;\n}\n", "docstring": "helper method to use for determining desired output encoding . for now , will always just use utf - 8 . . .", "partition": "test"}
{"idx": "1968", "code": "static BufferedImage convertImage(BufferedImage image){\nswitch (image.getType()) {\ncase BufferedImage.TYPE_INT_ARGB_PRE:\n    return image;\ncase BufferedImage.TYPE_4BYTE_ABGR:\n  image.coerceData(true);\nreturn image;\n}\nBufferedImage convertedImage=new BufferedImage(image.getWidth(),image.getHeight(),BufferedImage.TYPE_INT_ARGB_PRE);\nGraphics2D g=convertedImage.createGraphics();\ng.setColor(new java.awt.Color(0f,0f,0f,0f));\ng.fillRect(0,0,image.getWidth(),image.getHeight());\ng.drawImage(image,0,0,null);\ng.dispose();\nreturn convertedImage;\n}\n", "docstring": "converts the given image into a format for quick upload to the gpu .", "partition": "test"}
{"idx": "1969", "code": "public long start(){\n  startTime=System.currentTimeMillis();\n  return startTime;\n}\n", "docstring": "start the stop watch .", "partition": "test"}
{"idx": "1970", "code": "public void next(){\n  if (iterator.hasNext()) {\n    View currentView=iterator.next();\n    if (isUsingDefaultListener())     currentView.setOnClickListener(null);\n    if (iterator.nextIndex() < mViews.size()) {\n      View nextView=mViews.get(iterator.nextIndex());\n      if (isUsingDefaultListener())       nextView.setOnClickListener(listener);\n      ControllerAnimator animator=getDefaultForwardAnimation();\n      animator.setOldView(currentView);\n      animator.setNewView(nextView);\n      currentView.startAnimation(animator);\n      if (iterator.nextIndex() == mViews.size() - 1)       if (hasControllerListener())       mListener.onEndReached();\n    }\n else {\n      if (mLoop) {\n        iterator=mViews.listIterator();\n        View nextView=mViews.get(0);\n        if (mUseDefaultListener)         nextView.setOnClickListener(listener);\n        ControllerAnimator animator=getDefaultForwardAnimation();\n        animator.setOldView(currentView);\n        animator.setNewView(nextView);\n        currentView.startAnimation(animator);\n      }\n    }\n  }\n}\n", "docstring": "go to the next view", "partition": "test"}
{"idx": "1971", "code": "public void cacheResolvedMethod(Class clas,Class[] types,Method method){\n  if (Interpreter.DEBUG)   Interpreter.debug(\"cacheResolvedMethod putting: \" + clas + \" \"+ method);\n  SignatureKey sk=new SignatureKey(clas,method.getName(),types);\n  if (Modifier.isStatic(method.getModifiers()))   resolvedStaticMethods.put(sk,method);\n else   resolvedObjectMethods.put(sk,method);\n}\n", "docstring": "cache a resolved ( possibly overloaded ) method based on the argument types used to invoke it , subject to classloader change . static and object methods are cached separately to support fast lookup in the general case where either will do .", "partition": "test"}
{"idx": "1972", "code": "private void destroyBeans(Map<String,Object> viewMap,Map<String,ViewScopeContextObject> contextMap){\n  ArrayList<String> removalNameList=new ArrayList<>();\n  if (contextMap != null) {\n    for (    Map.Entry<String,ViewScopeContextObject> entry : contextMap.entrySet()) {\n      String passivationCapableId=entry.getKey();\n      Contextual contextual=beanManager.getPassivationCapableBean(passivationCapableId);\n      ViewScopeContextObject contextObject=entry.getValue();\n      CreationalContext creationalContext=beanManager.createCreationalContext(contextual);\n      contextual.destroy(viewMap.get(contextObject.getName()),creationalContext);\n      removalNameList.add(contextObject.getName());\n    }\n    Iterator<String> removalNames=removalNameList.iterator();\n    while (removalNames.hasNext()) {\n      String name=removalNames.next();\n      viewMap.remove(name);\n    }\n    contextMap.clear();\n  }\n}\n", "docstring": "destroy the view scoped beans for the given view and context map .", "partition": "test"}
{"idx": "1973", "code": "public static void close(@CheckForNull OutputStream outputStream){\n  if (outputStream == null) {\n    return;\n  }\n  try {\n    outputStream.close();\n  }\n catch (  IOException e) {\n  }\n}\n", "docstring": "close given outputstream , ignoring any resulting exception .", "partition": "test"}
{"idx": "1974", "code": "@Override public Node item(int index){\n  return (nodes != null && index < nodes.size()) ? (Node)(nodes.get(index)) : null;\n}\n", "docstring": "retrieve an item from the map by 0 - based index .", "partition": "test"}
{"idx": "1975", "code": "private int charToVisibleWidth(char c,@JdkConstants.FontStyle int fontType,int currentX){\n  if (c == '\\n') {\n    return 0;\n  }\n  if (c == '\\t') {\n    return EditorUtil.nextTabStop(currentX,this) - currentX;\n  }\n  return EditorUtil.charWidth(c,fontType,this);\n}\n", "docstring": "allows to answer how much width requires given char to be represented on a screen .", "partition": "test"}
{"idx": "1976", "code": "public GTSEncoder(long baseTimestamp){\n  this.baseTimestamp=baseTimestamp;\n  this.stream=new ByteArrayOutputStream();\n  this.wrappingKey=null;\n}\n", "docstring": "create an encoder using the given timestamp as its base . base timestamp may be used to encode value timestamps as deltas .", "partition": "test"}
{"idx": "1977", "code": "public static String encode(final Coordinate[] coords){\n  long lastLat=0;\n  long lastLng=0;\n  final StringBuffer result=new StringBuffer();\n  for (  final Coordinate point : coords) {\n    long lat=Math.round(point.y * 1e5);\n    long lng=Math.round(point.x * 1e5);\n    long dLat=lat - lastLat;\n    long dLng=lng - lastLng;\n    encode(dLat,result);\n    encode(dLng,result);\n    lastLat=lat;\n    lastLng=lng;\n  }\n  return result.toString();\n}\n", "docstring": "encodes a sequence of latlngs into an encoded path string .", "partition": "test"}
{"idx": "1978", "code": "private void extractWeightValues(List<Synapse> synapses){\n  int exWeights=0;\n  int inWeights=0;\n  for (  Synapse s : synapses) {\n    double w=s.getStrength();\n    if (w > 0) {\n      exWeights++;\n    }\n else {\n      inWeights++;\n    }\n  }\n  weights[0]=new double[exWeights];\n  weights[1]=new double[inWeights];\n  exWeights=0;\n  inWeights=0;\n  if (weights[0].length != 0) {\n    for (    Synapse s : synapses) {\n      double w=s.getStrength();\n      if (w > 0) {\n        weights[0][exWeights++]=w;\n      }\n else {\n        weights[1][inWeights++]=w;\n      }\n    }\n  }\n}\n", "docstring": "extracts weight values and organizes them by synapse type ( inhibitory or excitatory ) . inhibitory values are represented by their absolute value .", "partition": "test"}
{"idx": "1979", "code": "@Override public void close(){\n  try {\n    flush();\n  }\n catch (  AMLogException ale) {\n    Debug.error(tableName + \":DBHandler:close/flush error: \" + ale.getMessage());\n  }\n  if (conn != null) {\n    try {\n      conn.close();\n    }\n catch (    SQLException ce) {\n      Debug.error(tableName + \":DBHandler: Unable To Close Connection\",ce);\n    }\n  }\n  stopBufferTimer();\n}\n", "docstring": "flush any buffered messages and close the current output stream .", "partition": "test"}
{"idx": "1980", "code": "public boolean contains(List<Integer> hashes){\n  Iterator<Integer> ni=hashes.iterator();\n  for (int i=0; i < hashFunctions; ++i) {\n    if (!testBit((int)((ni.next() & 0xFFFFFFFFL) % (filter.length * 8)))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "check if the filter contains data with precomputed hashes .", "partition": "test"}
{"idx": "1981", "code": "private void ensureCapacity(int additionalData){\n  if ((this.position + additionalData) > this.byteBuffer.length) {\n    int newLength=(int)(this.byteBuffer.length * 1.25);\n    if (newLength < (this.byteBuffer.length + additionalData)) {\n      newLength=this.byteBuffer.length + (int)(additionalData * 1.25);\n    }\n    if (newLength < this.byteBuffer.length) {\n      newLength=this.byteBuffer.length + additionalData;\n    }\n    byte[] newBytes=new byte[newLength];\n    System.arraycopy(this.byteBuffer,0,newBytes,0,this.byteBuffer.length);\n    this.byteBuffer=newBytes;\n  }\n}\n", "docstring": "ensure that there are additionaldata bytes available in the buffer . if not realocate the buffer .", "partition": "test"}
{"idx": "1982", "code": "public boolean isValidNumber(PhoneNumber number){\n  String regionCode=getRegionCodeForNumber(number);\n  return isValidNumberForRegion(number,regionCode);\n}\n", "docstring": "tests whether a phone number matches a valid pattern . note this doesn \"'\" t verify the number is actually in use , which is impossible to tell by just looking at a number itself .", "partition": "test"}
{"idx": "1983", "code": "private String trimUrl(String uri){\n  if (uri == null)   return \"\";\n  if (uri.endsWith(\"/\"))   uri=uri.substring(0,uri.length() - 1);\n  return uri;\n}\n", "docstring": "trim the url , by removing an extra \"'\" / \"'\" at the end of the url and also make it lowercase < p >", "partition": "test"}
{"idx": "1984", "code": "public Pair<Integer,List<Long>> next(){\n  try {\n    classesProcessed++;\n    Integer key=iterator.next();\n    long pos=classificationBlockRMA2.getPos(key);\n    int count=classificationBlockRMA2.getSum(key);\n    classDumpReader.seek(pos);\n    List<Long> list=new LinkedList<>();\n    for (int i=0; i < count; i++)     list.add(classDumpReader.readLong());\n    return new Pair<>(key,list);\n  }\n catch (  Exception e) {\n    Basic.caught(e);\n    error=true;\n    return null;\n  }\n}\n", "docstring": "returns the next element in the iteration .", "partition": "test"}
{"idx": "1985", "code": "public static String addAlpha(String originalColor,double alpha){\n  long alphaFixed=Math.round(alpha * 255);\n  String alphaHex=Long.toHexString(alphaFixed);\n  if (alphaHex.length() == 1) {\n    alphaHex=\"0\" + alphaHex;\n  }\n  originalColor=originalColor.replace(\"#\",\"#\" + alphaHex);\n  return originalColor;\n}\n", "docstring": "adds alpha to a hex color", "partition": "test"}
{"idx": "1986", "code": "public void stop(){\n  server.stop(0);\n}\n", "docstring": "stop the web server .", "partition": "test"}
{"idx": "1987", "code": "protected DateTimeData parse(String str,int durationType) throws SchemaDateTimeException {\n  int len=str.length();\n  DateTimeData date=new DateTimeData(str,this);\n  int start=0;\n  char c=str.charAt(start++);\n  if (c != 'P' && c != '-') {\n    throw new SchemaDateTimeException();\n  }\n else {\n    date.utc=(c == '-') ? '-' : 0;\n    if (c == '-' && str.charAt(start++) != 'P') {\n      throw new SchemaDateTimeException();\n    }\n  }\n  int negate=1;\n  if (date.utc == '-') {\n    negate=-1;\n  }\n  boolean designator=false;\n  int endDate=indexOf(str,start,len,'T');\n  if (endDate == -1) {\n    endDate=len;\n  }\n else   if (durationType == YEARMONTHDURATION_TYPE) {\n    throw new SchemaDateTimeException();\n  }\n  int end=indexOf(str,start,endDate,'Y');\n  if (end != -1) {\n    if (durationType == DAYTIMEDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.year=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  end=indexOf(str,start,endDate,'M');\n  if (end != -1) {\n    if (durationType == DAYTIMEDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.month=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  end=indexOf(str,start,endDate,'D');\n  if (end != -1) {\n    if (durationType == YEARMONTHDURATION_TYPE) {\n      throw new SchemaDateTimeException();\n    }\n    date.day=negate * parseInt(str,start,end);\n    start=end + 1;\n    designator=true;\n  }\n  if (len == endDate && start != len) {\n    throw new SchemaDateTimeException();\n  }\n  if (len != endDate) {\n    end=indexOf(str,++start,len,'H');\n    if (end != -1) {\n      date.hour=negate * parseInt(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    end=indexOf(str,start,len,'M');\n    if (end != -1) {\n      date.minute=negate * parseInt(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    end=indexOf(str,start,len,'S');\n    if (end != -1) {\n      date.second=negate * parseSecond(str,start,end);\n      start=end + 1;\n      designator=true;\n    }\n    if (start != len || str.charAt(--start) == 'T') {\n      throw new SchemaDateTimeException();\n    }\n  }\n  if (!designator) {\n    throw new SchemaDateTimeException();\n  }\n  return date;\n}\n", "docstring": "parses , validates and computes normalized version of duration object", "partition": "test"}
{"idx": "1988", "code": "final void copyIntoLocalState(Operand[] _localState){\n  localState=new Operand[_localState.length];\n  System.arraycopy(_localState,0,localState,0,_localState.length);\n  setLocalKnown();\n}\n", "docstring": "save a shallow copy of the given local variable state into this .", "partition": "test"}
{"idx": "1989", "code": "@SuppressWarnings(\"unchecked\") private HashMap<String,DBObject> loadDBObjects(Class objectClass){\n  HashMap<String,DBObject> objectMap=new HashMap<String,DBObject>();\n  DBObject dbObject=new DBObject(this,objectClass);\n  String objectToLoad=s_logger.localizeMessage(\"object\");\n  String objectsToLoad=s_logger.localizeMessage(\"objects\");\n  String sqlLoadHeaders=null;\n  String sqlLoadContents=null;\n  if (dbObject != null) {\n    objectToLoad=dbObject.getObjectType();\n    objectsToLoad=dbObject.getObjectTypes();\n    sqlLoadHeaders=dbObject.getLoadHeaderSQL();\n    sqlLoadContents=dbObject.getLoadContentSQL();\n  }\n  s_logger.log(Level.FINE,\"loadDBObjects\",new Object[]{objectsToLoad,getDirection()});\n  PreparedStatementWrapper stmtLoadHeaders=setPreparedStatement(sqlLoadHeaders);\n  PreparedStatementWrapper stmtLoadContents=setPreparedStatement(sqlLoadContents);\n  int counter=0;\n  if (dbObject != null) {\n    String sql=dbObject.getLoadObjectSQL();\n    Statement stmt=setStatement();\n    ResultSet rs=executeQuery(stmt,sql);\n    while (getResultSetNext(rs)) {\n      String s=getResultSetString(rs,\"OBJECT_NAME\");\n      if (!objectMap.containsKey(s)) {\n        DBObject obj=new DBObject(this,objectClass,s);\n        obj.populate(stmtLoadHeaders,stmtLoadContents);\n        if (obj.isPopulated()) {\n          objectMap.put(s.toUpperCase(),obj);\n          counter++;\n        }\n      }\n    }\n    releaseResultSet(rs);\n    releaseStatement(stmt);\n  }\n  releasePreparedStatement(stmtLoadHeaders);\n  releasePreparedStatement(stmtLoadContents);\n  if (counter == 1)   s_logger.log(Level.FINE,\"dbObjectsLoaded\",new Object[]{Integer.toString(counter),objectToLoad});\n else   s_logger.log(Level.FINE,\"dbObjectsLoaded\",new Object[]{Integer.toString(counter),objectsToLoad});\n  s_logger.flush();\n  return objectMap;\n}\n", "docstring": "load objects defined in the database", "partition": "test"}
{"idx": "1990", "code": "protected Object attemptReadResponse(Connection cnx) throws Exception {\n  Message msg=createResponseMessage();\n  if (msg != null) {\n    msg.setComms(cnx.getSocket(),cnx.getInputStream(),cnx.getOutputStream(),cnx.getCommBuffer(),cnx.getStats());\n    if (msg instanceof ChunkedMessage) {\n      try {\n        return processResponse(msg,cnx);\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n    }\n else {\n      try {\n        msg.recv();\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n      return processResponse(msg,cnx);\n    }\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "attempts to read a response to this operation by reading it from the given connection , and returning it .", "partition": "test"}
{"idx": "1991", "code": "public synchronized boolean add(E e,boolean hasNext){\n  while (mInternalQueue.size() >= mMaxSize && !mClosed) {\n    notifyAll();\n    try {\n      wait(TIMEOUT);\n    }\n catch (    InterruptedException e1) {\n      mClosed=true;\n      ProgramState.checkAbort();\n      throw new IllegalStateException(\"Interrupted but program not aborting?\",e1);\n    }\n    ProgramState.checkAbort();\n  }\n  if (mClosed) {\n    return true;\n  }\n  final boolean wasEmpty=mInternalQueue.isEmpty();\n  mHasNext=hasNext;\n  mInternalQueue.add(e);\n  if (wasEmpty) {\n    notifyAll();\n  }\n  return true;\n}\n", "docstring": "add method which also set whether there is a next value", "partition": "test"}
{"idx": "1992", "code": "public TranslatableComponent(){\n}\n", "docstring": "construct new empty translatablecomponent .", "partition": "test"}
{"idx": "1993", "code": "public StrBuilder insert(int index,boolean value){\n  validateIndex(index);\n  if (value) {\n    ensureCapacity(size + 4);\n    System.arraycopy(buffer,index,buffer,index + 4,size - index);\n    buffer[index++]='t';\n    buffer[index++]='r';\n    buffer[index++]='u';\n    buffer[index]='e';\n    size+=4;\n  }\n else {\n    ensureCapacity(size + 5);\n    System.arraycopy(buffer,index,buffer,index + 5,size - index);\n    buffer[index++]='f';\n    buffer[index++]='a';\n    buffer[index++]='l';\n    buffer[index++]='s';\n    buffer[index]='e';\n    size+=5;\n  }\n  return this;\n}\n", "docstring": "inserts the value into this builder .", "partition": "test"}
{"idx": "1994", "code": "public boolean hasNatureAndWeapon(Nature nature,String weapon){\n  return this.nature == nature && ((weapon == null && this.weapon == null) || (weapon != null && weapon.equals(this.weapon)));\n}\n", "docstring": "check if this painter has the given nature an weapon .", "partition": "test"}
{"idx": "1995", "code": "public void dump(String infoMsg){\n  storage.getOnlineMembers();\n  storage.getOfflineMembers();\n  storage.getOfflineAndEqualMembers();\n  storage.getMyInitializingID();\n  storage.getMyPersistentID();\n  final StringBuilder buf=new StringBuilder(2000);\n  if (infoMsg != null) {\n    buf.append(infoMsg);\n    buf.append(\": \");\n  }\n  buf.append(\"\\nMY PERSISTENT ID:\\n\");\n  buf.append(storage.getMyPersistentID());\n  buf.append(\"\\nMY INITIALIZING ID:\\n\");\n  buf.append(storage.getMyInitializingID());\n  buf.append(\"\\nONLINE MEMBERS:\\n\");\n  for (  PersistentMemberID id : storage.getOnlineMembers()) {\n    buf.append(\"\\t\");\n    buf.append(id);\n    buf.append(\"\\n\");\n  }\n  buf.append(\"\\nOFFLINE MEMBERS:\\n\");\n  for (  PersistentMemberID id : storage.getOfflineMembers()) {\n    buf.append(\"\\t\");\n    buf.append(id);\n    buf.append(\"\\n\");\n  }\n  buf.append(\"\\nOFFLINE AND EQUAL MEMBERS:\\n\");\n  for (  PersistentMemberID id : storage.getOfflineAndEqualMembers()) {\n    buf.append(\"\\t\");\n    buf.append(id);\n    buf.append(\"\\n\");\n  }\n  logger.debug(buf.toString());\n}\n", "docstring": "callers should have already verified that debug output is enabled .", "partition": "test"}
{"idx": "1996", "code": "private Node<K,V> findNode(Object key){\n  if (key == null)   throw new NullPointerException();\n  Comparator<? super K> cmp=comparator;\n  outer:   for (; ; ) {\n    for (Node<K,V> b=findPredecessor(key,cmp), n=b.next; ; ) {\n      Object v;\n      int c;\n      if (n == null)       break outer;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      if ((v=n.value) == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (b.value == null || v == n)       break;\n      if ((c=cpr(cmp,key,n.key)) == 0)       return n;\n      if (c < 0)       break outer;\n      b=n;\n      n=f;\n    }\n  }\n  return null;\n}\n", "docstring": "returns node holding key or null if no such , clearing out any deleted nodes seen along the way . repeatedly traverses at base - level looking for key starting at predecessor returned from findpredecessor , processing base - level deletions as encountered . some callers rely on this side - effect of clearing deleted nodes . restarts occur , at traversal step centered on node n , if : ( 1 ) after reading n \"'\" s next field , n is no longer assumed predecessor b \"'\" s current successor , which means that we don \"'\" t have a consistent 3 - node snapshot and so cannot unlink any subsequent deleted nodes encountered . ( 2 ) n \"'\" s value field is null , indicating n is deleted , in which case we help out an ongoing structural deletion before retrying . even though there are cases where such unlinking doesn \"'\" t require restart , they aren \"'\" t sorted out here because doing so would not usually outweigh cost of restarting . ( 3 ) n is a marker or n \"'\" s predecessor \"'\" s value field is null , indicating ( among other possibilities ) that findpredecessor returned a deleted node . we can \"'\" t unlink the node because we don \"'\" t know its predecessor , so rely on another call to findpredecessor to notice and return some earlier predecessor , which it will do . this check is only strictly needed at beginning of loop , ( and the b . value check isn \"'\" t strictly needed at all ) but is done each iteration to help avoid contention with other threads by callers that will fail to be able to change links , and so will retry anyway . the traversal loops in doput , doremove , and findnear all include the same three kinds of checks . and specialized versions appear in findfirst , and findlast and their variants . they can \"'\" t easily share code because each uses the reads of fields held in locals occurring in the orders they were performed .", "partition": "test"}
{"idx": "1997", "code": "static Sort parseSort(long timestampSec,IndexState state,List<Object> fields,List<String> sortFieldNames,Map<String,FieldDef> dynamicFields){\n  List<SortField> sortFields=new ArrayList<SortField>();\n  for (  Object _sub : fields) {\n    Request sub=(Request)_sub;\n    String fieldName=sub.getString(\"field\");\n    SortField sf;\n    if (sortFieldNames != null) {\n      sortFieldNames.add(fieldName);\n    }\n    if (fieldName.equals(\"docid\")) {\n      sf=SortField.FIELD_DOC;\n    }\n else     if (fieldName.equals(\"score\")) {\n      sf=SortField.FIELD_SCORE;\n    }\n else {\n      FieldDef fd;\n      if (dynamicFields != null) {\n        fd=dynamicFields.get(fieldName);\n      }\n else {\n        fd=null;\n      }\n      if (fd == null) {\n        fd=state.getField(fieldName);\n      }\n      if (fd == null) {\n        sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered and was not specified as a dynamicField\");\n        fd=null;\n      }\n      if (fd.valueSource != null) {\n        sf=fd.valueSource.getSortField(sub.getBoolean(\"reverse\"));\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.LAT_LON) {\n        if (fd.fieldType.docValuesType() == DocValuesType.NONE) {\n          sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered with sort=true\");\n        }\n        Request sub2=sub.getStruct(\"origin\");\n        sf=LatLonDocValuesField.newDistanceSort(fieldName,sub2.getDouble(\"latitude\"),sub2.getDouble(\"longitude\"));\n      }\n else {\n        if ((fd.fieldType != null && fd.fieldType.docValuesType() == DocValuesType.NONE) || (fd.fieldType == null && fd.valueSource == null)) {\n          sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered with sort=true\");\n        }\n        if (fd.multiValued) {\n          String selectorString=sub.getEnum(\"selector\");\n          if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n            SortedSetSelector.Type selector;\n            if (selectorString.equals(\"min\")) {\n              selector=SortedSetSelector.Type.MIN;\n            }\n else             if (selectorString.equals(\"max\")) {\n              selector=SortedSetSelector.Type.MAX;\n            }\n else             if (selectorString.equals(\"middle_min\")) {\n              selector=SortedSetSelector.Type.MIDDLE_MIN;\n            }\n else             if (selectorString.equals(\"middle_max\")) {\n              selector=SortedSetSelector.Type.MIDDLE_MAX;\n            }\n else {\n              assert false;\n              selector=null;\n            }\n            sf=new SortedSetSortField(fieldName,sub.getBoolean(\"reverse\"),selector);\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.INT) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.INT,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.LONG) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.LONG,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.FLOAT,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.DOUBLE,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else {\n            sub.fail(\"field\",\"cannot sort by multiValued field \\\"\" + fieldName + \"\\\": type is \"+ fd.valueType);\n            assert false;\n            sf=null;\n          }\n        }\n else {\n          SortField.Type sortType;\n          if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n            sortType=SortField.Type.STRING;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.LONG || fd.valueType == FieldDef.FieldValueType.DATE_TIME) {\n            sortType=SortField.Type.LONG;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.INT) {\n            sortType=SortField.Type.INT;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n            sortType=SortField.Type.DOUBLE;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n            sortType=SortField.Type.FLOAT;\n          }\n else {\n            sub.fail(\"field\",\"cannot sort by field \\\"\" + fieldName + \"\\\": type is \"+ fd.valueType);\n            assert false;\n            sortType=null;\n          }\n          sf=new SortField(fieldName,sortType,sub.getBoolean(\"reverse\"));\n        }\n      }\n      boolean hasMissingLast=sub.hasParam(\"missingLast\");\n      boolean missingLast=sub.getBoolean(\"missingLast\");\n      if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n        if (missingLast) {\n          sf.setMissingValue(SortField.STRING_LAST);\n        }\n else {\n          sf.setMissingValue(SortField.STRING_FIRST);\n        }\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.INT) {\n        sf.setMissingValue(missingLast ? Integer.MAX_VALUE : Integer.MIN_VALUE);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.LONG) {\n        sf.setMissingValue(missingLast ? Long.MAX_VALUE : Long.MIN_VALUE);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n        sf.setMissingValue(missingLast ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n        sf.setMissingValue(missingLast ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\n      }\n else       if (hasMissingLast) {\n        sub.fail(\"missingLast\",\"field=\" + fieldName + \": can only specify missingLast for string and numeric field types: got SortField type \"+ sf.getType());\n      }\n    }\n    sortFields.add(sf);\n  }\n  return new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n}\n", "docstring": "decodes a list of request into the corresponding sort .", "partition": "test"}
{"idx": "1998", "code": "public synchronized void open(){\n}\n", "docstring": "open the device ( done automatically )", "partition": "test"}
{"idx": "1999", "code": "@NotNull private Optional<TypeConversion> findConversionFromDbValue(@NotNull Type source,@NotNull Type target){\n  if (isAssignable(target,source))   return Optional.of(TypeConversion.identity());\n  Optional<TypeConversion> directConversion=typeConversionRegistry.findConversionFromDbValue(source,target);\n  if (directConversion.isPresent())   return directConversion;\n  Optional<TypeConversion> arrayConversion=findArrayConversion(source,target);\n  if (arrayConversion.isPresent())   return arrayConversion;\n  Optional<TypeConversion> optionalConversion=findOptionalConversion(source,target);\n  if (optionalConversion.isPresent())   return optionalConversion;\n  Optional<TypeConversion> enumConversion=findEnumConversion(target);\n  if (enumConversion.isPresent())   return enumConversion;\n  return Optional.empty();\n}\n", "docstring": "returns conversion for converting value of source to target , or returns null if there \"'\" s no such conversion .", "partition": "test"}
{"idx": "2000", "code": "private boolean advanceApiUpTo(TreeSet<AreaPanelInfo> sortedApiTree,AreaPanelInfo api,int time){\n  AreaPanel ap=api.ap();\n  TimeTree rootTt=ap.getTimeTree();\n  TimeTree tt=rootTt.getEncompassigTimeTreeOrMaxTimeTreeBeforeTime(time,true);\n  if (tt == null || tt.id == api.currTtId)   return false;\n  sortedApiTree.remove(api);\n  if (api.setTt(tt,Integer.MAX_VALUE))   sortedApiTree.add(api);\n  return true;\n}\n", "docstring": "moves api to the latest value before time .", "partition": "test"}
{"idx": "2001", "code": "@RequestMapping(value={\"/\",\"\"},method=RequestMethod.POST) @ResponseBody public RestWrapper update(@ModelAttribute(\"userroles\") @Valid UserRoles userRoles,BindingResult bindingResult,Principal principal){\n  RestWrapper restWrapper=null;\n  if (bindingResult.hasErrors()) {\n    BindingResultError bindingResultError=new BindingResultError();\n    return bindingResultError.errorMessage(bindingResult);\n  }\n  try {\n    com.wipro.ats.bdre.md.dao.jpa.UserRoles jpaUserRoles=new com.wipro.ats.bdre.md.dao.jpa.UserRoles();\n    jpaUserRoles.setUserRoleId(userRoles.getUserRoleId());\n    jpaUserRoles.setRole(userRoles.getRole());\n    Users users=new Users();\n    users.setUsername(userRoles.getUsername());\n    jpaUserRoles.setUsers(users);\n    userRolesDAO.update(jpaUserRoles);\n    restWrapper=new RestWrapper(userRoles,RestWrapper.OK);\n    LOGGER.info(\"Record with ID:\" + userRoles.getUserRoleId() + \" updated in UserRoles by User:\"+ principal.getName()+ userRoles);\n  }\n catch (  Exception e) {\n    LOGGER.error(e);\n    restWrapper=new RestWrapper(e.getMessage(),RestWrapper.ERROR);\n  }\n  return restWrapper;\n}\n", "docstring": "this method calls proc updateuserroles and updates the values . it also validates the values passed .", "partition": "test"}
{"idx": "2002", "code": "private void sendRequestOption() throws IOException {\n  String request=\"OPTIONS rtsp://\" + mParameters.host + \":\"+ mParameters.port+ mParameters.path+ \" RTSP/1.0\\r\\n\"+ addHeaders();\n  Log.i(TAG,request.substring(0,request.indexOf(\"\\r\\n\")));\n  mOutputStream.write(request.getBytes(\"UTF-8\"));\n  Response.parseResponse(mBufferedReader);\n}\n", "docstring": "forges and sends the options request", "partition": "test"}
{"idx": "2003", "code": "@Override public Result doComparisonTest(final Properties properties) throws Exception {\n  final long timeout=Long.parseLong(properties.getProperty(TestOptions.TIMEOUT));\n  final int nresources=Integer.parseInt(properties.getProperty(TestOptions.NRESOURCES));\n  final int minLocks=Integer.parseInt(properties.getProperty(TestOptions.MIN_LOCKS));\n  final int maxLocks=Integer.parseInt(properties.getProperty(TestOptions.MAX_LOCKS));\n  final int ntrials=Integer.parseInt(properties.getProperty(TestOptions.NTRIALS));\n  final int keyLen=Integer.parseInt(properties.getProperty(TestOptions.KEYLEN));\n  final int nops=Integer.parseInt(properties.getProperty(TestOptions.NOPS));\n  final double failureRate=Double.parseDouble(properties.getProperty(TestOptions.FAILURE_RATE));\n  Result result=doConcurrentClientTest(journal,timeout,nresources,minLocks,maxLocks,ntrials,keyLen,nops,failureRate);\n  return result;\n}\n", "docstring": "setup and run a test .", "partition": "test"}
{"idx": "2004", "code": "public static void printThreadInfo(PrintWriter stream,String title){\n  final int STACK_DEPTH=20;\n  boolean contention=threadBean.isThreadContentionMonitoringEnabled();\n  long[] threadIds=threadBean.getAllThreadIds();\n  stream.println(\"Process Thread Dump: \" + title);\n  stream.println(threadIds.length + \" active threads\");\n  for (  long tid : threadIds) {\n    ThreadInfo info=threadBean.getThreadInfo(tid,STACK_DEPTH);\n    if (info == null) {\n      stream.println(\"  Inactive\");\n      continue;\n    }\n    stream.println(\"Thread \" + getTaskName(info.getThreadId(),info.getThreadName()) + \":\");\n    Thread.State state=info.getThreadState();\n    stream.println(\"  State: \" + state);\n    stream.println(\"  Blocked count: \" + info.getBlockedCount());\n    stream.println(\"  Waited count: \" + info.getWaitedCount());\n    if (contention) {\n      stream.println(\"  Blocked time: \" + info.getBlockedTime());\n      stream.println(\"  Waited time: \" + info.getWaitedTime());\n    }\n    if (state == Thread.State.WAITING) {\n      stream.println(\"  Waiting on \" + info.getLockName());\n    }\n else     if (state == Thread.State.BLOCKED) {\n      stream.println(\"  Blocked on \" + info.getLockName());\n      stream.println(\"  Blocked by \" + getTaskName(info.getLockOwnerId(),info.getLockOwnerName()));\n    }\n    stream.println(\"  Stack:\");\n    for (    StackTraceElement frame : info.getStackTrace()) {\n      stream.println(\"    \" + frame.toString());\n    }\n  }\n  stream.flush();\n}\n", "docstring": "print all of the thread \"'\" s information and stack traces .", "partition": "test"}
{"idx": "2005", "code": "public void addDelete(IResource delete){\n  if (fDelete == null)   fDelete=new ArrayList<IResource>(2);\n  fDelete.add(delete);\n  if (fIgnoreCount == 0) {\n    internalAdd(new DeleteDescription(delete));\n  }\n}\n", "docstring": "adds the given resource to the list of resources to be deleted .", "partition": "test"}
{"idx": "2006", "code": "public static double max(final double a,final double b){\n  if (a > b) {\n    return a;\n  }\n  if (a < b) {\n    return b;\n  }\n  if (a != b) {\n    return Double.NaN;\n  }\n  long bits=Double.doubleToRawLongBits(a);\n  if (bits == 0x8000000000000000L) {\n    return b;\n  }\n  return a;\n}\n", "docstring": "compute the maximum of two values", "partition": "test"}
{"idx": "2007", "code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeObject(approximation);\n}\n", "docstring": "calls the super method and writes the polynomial approximation of the knn distances of this entry to the specified stream .", "partition": "test"}
{"idx": "2008", "code": "public void add(String methodName,List<Expression> parameters){\n  chain.add(new DotExpressionItem(methodName,parameters,false));\n}\n", "docstring": "add a method to the chain of methods after the dot .", "partition": "test"}
{"idx": "2009", "code": "public static Request request(){\n  return threadLocal.get();\n}\n", "docstring": "get the current request , which is specific to the current thread .", "partition": "test"}
{"idx": "2010", "code": "private void scheduleCommercial(int length){\n  Long delay=commercialDelay.getSettingValue();\n  if (delay == null) {\n    setCommercialResult(\"Invalid delay specified.\");\n    clearCommercialButtonsSelection();\n  }\n else {\n    scheduledCommercialTime=System.currentTimeMillis() + delay * 1000;\n    scheduledCommercialLength=length;\n    update();\n  }\n}\n", "docstring": "schedules a commercial of the given length to be run after the delay currently set in the delay input field .", "partition": "test"}
{"idx": "2011", "code": "public int hashCode(){\n  long bits=Double.doubleToLongBits(m00);\n  bits=bits * 31 + Double.doubleToLongBits(m01);\n  bits=bits * 31 + Double.doubleToLongBits(m02);\n  bits=bits * 31 + Double.doubleToLongBits(m10);\n  bits=bits * 31 + Double.doubleToLongBits(m11);\n  bits=bits * 31 + Double.doubleToLongBits(m12);\n  return (((int)bits) ^ ((int)(bits >> 32)));\n}\n", "docstring": "returns the hashcode for this transform .", "partition": "test"}
{"idx": "2012", "code": "public void unsubscribe(AWSIotMessage message) throws AWSIotException {\n  try {\n    unsubscribeTopic(message);\n  }\n catch (  AwsIotRetryableException e) {\n    if (client.getMaxOfflineQueueSize() > 0 && unsubscribeQueue.size() < client.getMaxOfflineQueueSize()) {\n      unsubscribeQueue.add(message);\n    }\n else {\n      LOGGER.info(\"Failed to unsubscribe to \" + message.getTopic());\n      throw new AWSIotException(e);\n    }\n  }\n}\n", "docstring": "the actual unsubscribe method exposed by this class .", "partition": "test"}
{"idx": "2013", "code": "public static boolean isDigitalUnix(){\n  return osName.indexOf(\"Digital Unix\") > -1;\n}\n", "docstring": "is operating system digital unix ?", "partition": "test"}
{"idx": "2014", "code": "public void clientDisconnect(){\n  try {\n    OutHttpApp responseStream=_responseStream;\n    if (responseStream != null) {\n      responseStream.close();\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.FINER,e.toString(),e);\n  }\n  ConnectionTcp conn=connTcp();\n  if (conn != null) {\n    conn.clientDisconnect();\n  }\n  killKeepalive(\"client disconnect\");\n}\n", "docstring": "called when the client has disconnected", "partition": "test"}
{"idx": "2015", "code": "public boolean endsWith(Name n){\n  if (n instanceof CompoundName) {\n    return (impl.endsWith(n.size(),n.getAll()));\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "determines whether a compound name is a suffix of this compound name . a compound name \"'\" n \"'\" is a suffix if it it is equal to getsuffix ( size ( ) - n . size ( ) ) - - in other words , this compound name ends with \"'\" n \"'\" . if n is null or not a compound name , false is returned . < p > implementation note : currently the syntax properties of n are not used when doing the comparison . they might be in the future .", "partition": "test"}
{"idx": "2016", "code": "private int calculateTotalHeight(float starSize,int numberOfStars,float starsSeparation,boolean padding){\n  return Math.round(starSize) + (padding ? getPaddingTop() + getPaddingBottom() : 0);\n}\n", "docstring": "calculates total height to occupy based on several parameters", "partition": "test"}
{"idx": "2017", "code": "@SuppressWarnings(\"purity\") private static boolean isRegex(String s){\n  try {\n    Pattern.compile(s);\n  }\n catch (  PatternSyntaxException e) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "this method is a copy of regexutil . isregex . we cannot directly use regexutil , because it uses type annotations which cannot be used in ides ( yet ) .", "partition": "test"}
{"idx": "2018", "code": "public static void flush(){\n  clearBuffer();\n  try {\n    out.flush();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "flush standard output , padding 0s if number of bits written so far is not a multiple of 8 .", "partition": "test"}
{"idx": "2019", "code": "private String attachFooterToText(String content) throws MessagingException, IOException {\n  StringBuilder builder=new StringBuilder(content);\n  ensureTrailingCarriageReturn(content,builder);\n  builder.append(getFooterText());\n  return builder.toString();\n}\n", "docstring": "prepends the content of the mimepart as text to the existing footer", "partition": "test"}
{"idx": "2020", "code": "public static Sentence make(final Connective connective,final Sentence... children2){\n  return make(connective,Arrays.asList(children2));\n}\n", "docstring": "conjoin a list of sentences . for convenience , these are allowed to be null ( null sentences are ignored from the conjunction . ) there must be at least one non - null argument .", "partition": "test"}
{"idx": "2021", "code": "public synchronized void init(){\n  init=true;\n  for (  String mapName : store.getMapNames()) {\n    if (mapName.startsWith(\"temp.\")) {\n      MVMap<Object,Integer> temp=openTempMap(mapName);\n      store.removeMap(temp);\n    }\n  }\nsynchronized (undoLog) {\n    if (undoLog.size() > 0) {\n      for (      Long key : undoLog.keySet()) {\n        int transactionId=getTransactionId(key);\n        openTransactions.set(transactionId);\n      }\n    }\n  }\n}\n", "docstring": "initialize the store . this is needed before a transaction can be opened . if the transaction store is corrupt , this method can throw an exception , in which case the store can only be used for reading .", "partition": "test"}
{"idx": "2022", "code": "public static TDoubleDoubleHashMap createCumulativeHistogram(TDoubleDoubleHashMap histogram){\n  double[] keys=histogram.keys();\n  Arrays.sort(keys);\n  double sum=0;\n  for (  double key : keys) {\n    double val=histogram.get(key);\n    sum+=val;\n    histogram.put(key,sum);\n  }\n  return histogram;\n}\n", "docstring": "creates a cumulative histogram where each bin height is the sum of the previous bin \"'\" s height and the current bin \"'\" s height .", "partition": "test"}
{"idx": "2023", "code": "protected DateTimeData parse(String str) throws SchemaDateTimeException {\n  DateTimeData date=new DateTimeData(str,this);\n  int len=str.length();\n  int end=indexOf(str,0,len,\'T\');\n  int dateEnd=getDate(str,0,end,date);\n  getTime(str,end + 1,len,date);\n  if (dateEnd != end) {\n    throw new RuntimeException(str + \" is an invalid dateTime dataype value. \" + \"Invalid character(s) seprating date and time values.\");\n  }\n  validateDateTime(date);\n  saveUnnormalized(date);\n  if (date.utc != 0 && date.utc != \'Z\') {\n    normalize(date);\n  }\n  return date;\n}\n", "docstring": "parses , validates and computes normalized version of datetime object", "partition": "test"}
{"idx": "2024", "code": "void addAttributeValues(String attrName,Set values) throws SMSException {\n  if (attrName != null && values != null && !values.isEmpty()) {\n    Map attrs=getAttributes();\n    Set origValues=(Set)attrs.get(attrName);\n    Set newValues=new HashSet(values);\n    if (origValues != null && !origValues.isEmpty()) {\n      newValues.addAll(origValues);\n    }\n    Map newAttrs=new HashMap();\n    newAttrs.put(attrName,newValues);\n    setAttributes(newAttrs);\n  }\n}\n", "docstring": "adds attributes to amsdk organization . the organziation attribute names are defined in the idrepo service .", "partition": "test"}
{"idx": "2025", "code": "SegmentManager commitIndex(long commitIndex){\n  this.commitIndex=Math.max(this.commitIndex,commitIndex);\n  return this;\n}\n", "docstring": "sets the log commit index .", "partition": "test"}
{"idx": "2026", "code": "public void finishFragments(){\n  for (  Fragment comment : closingFragments) {\n    finishFragment(comment);\n  }\n  closingFragments.clear();\n}\n", "docstring": "sets all the closing fragments into finished state .", "partition": "test"}
{"idx": "2027", "code": "private final void _writeUTF8Segments(byte[] utf8,int offset,int totalLen) throws IOException, JsonGenerationException {\n  do {\n    int len=Math.min(_outputMaxContiguous,totalLen);\n    _writeUTF8Segment(utf8,offset,len);\n    offset+=len;\n    totalLen-=len;\n  }\n while (totalLen > 0);\n}\n", "docstring": "method called when utf - 8 encoded ( but not yet escaped ! ) content is not guaranteed to fit in the output buffer after escaping ; as such , we just need to chunk writes .", "partition": "test"}
{"idx": "2028", "code": "public Collection<Node> matchingScenariosAndExamples(final Feature feature){\n  final List<ScenarioDefinition> allScenarios=feature.getScenarioDefinitions();\n  final List<Node> matchingScenariosAndExamples=new LinkedList<Node>();\n  for (  final ScenarioDefinition scenario : allScenarios) {\n    final Set<Tag> allTagsForScenario=new HashSet<Tag>(scenario.getTags());\n    allTagsForScenario.addAll(feature.getTags());\n    if (scenario instanceof ScenarioOutline) {\n      matchingScenariosAndExamples.addAll(matchingExamples((ScenarioOutline)scenario,allTagsForScenario));\n    }\n else {\n      if (matches(allTagsForScenario)) {\n        matchingScenariosAndExamples.add(scenario);\n      }\n    }\n  }\n  return matchingScenariosAndExamples;\n}\n", "docstring": "find the scenarios that match the required tags in the feature .", "partition": "test"}
{"idx": "2029", "code": "private boolean traverse(Tree tree,NodeRef node,int[] operatorNumber,boolean flip){\n  boolean update=false;\n  int nodeNum=node.getNumber();\n  NodeRef parent=tree.getParent(node);\n  if (operatorNumber != null) {\n    operatorNumber[0]=-1;\n  }\n  if (parent != null && updateNode[nodeNum]) {\n    final double branchRate=branchRateModel.getBranchRate(tree,node);\n    final double branchTime=branchRate * (tree.getNodeHeight(parent) - tree.getNodeHeight(node));\n    if (branchTime < 0.0) {\n      throw new RuntimeException(\"Negative branch length: \" + branchTime);\n    }\n    if (flip) {\n      matrixBufferHelper.flipOffset(nodeNum);\n    }\n    final int eigenIndex=0;\n    final int updateCount=branchUpdateCount[eigenIndex];\n    matrixUpdateIndices[eigenIndex][updateCount]=matrixBufferHelper.getOffsetIndex(nodeNum);\n    branchLengths[eigenIndex][updateCount]=branchTime;\n    branchUpdateCount[eigenIndex]++;\n    update=true;\n  }\n  if (!tree.isExternal(node)) {\n    NodeRef child1=tree.getChild(node,0);\n    final int[] op1={-1};\n    final boolean update1=traverse(tree,child1,op1,flip);\n    NodeRef child2=tree.getChild(node,1);\n    final int[] op2={-1};\n    final boolean update2=traverse(tree,child2,op2,flip);\n    if (update1 || update2) {\n      int x=operationCount[operationListCount] * Beagle.OPERATION_TUPLE_SIZE;\n      if (flip) {\n        partialBufferHelper.flipOffset(nodeNum);\n      }\n      final int[] operations=this.operations[operationListCount];\n      operations[x]=partialBufferHelper.getOffsetIndex(nodeNum);\n      if (useScaleFactors) {\n        int n=nodeNum - tipCount;\n        if (recomputeScaleFactors) {\n          scaleBufferHelper.flipOffset(n);\n          scaleBufferIndices[n]=scaleBufferHelper.getOffsetIndex(n);\n          operations[x + 1]=scaleBufferIndices[n];\n          operations[x + 2]=Beagle.NONE;\n        }\n else {\n          operations[x + 1]=Beagle.NONE;\n          operations[x + 2]=scaleBufferIndices[n];\n        }\n      }\n else {\n        if (useAutoScaling) {\n          scaleBufferIndices[nodeNum - tipCount]=partialBufferHelper.getOffsetIndex(nodeNum);\n        }\n        operations[x + 1]=Beagle.NONE;\n        operations[x + 2]=Beagle.NONE;\n      }\n      operations[x + 3]=partialBufferHelper.getOffsetIndex(child1.getNumber());\n      operations[x + 4]=matrixBufferHelper.getOffsetIndex(child1.getNumber());\n      operations[x + 5]=partialBufferHelper.getOffsetIndex(child2.getNumber());\n      operations[x + 6]=matrixBufferHelper.getOffsetIndex(child2.getNumber());\n      operationCount[operationListCount]++;\n      update=true;\n    }\n  }\n  return update;\n}\n", "docstring": "traverse the tree calculating partial likelihoods .", "partition": "test"}
{"idx": "2030", "code": "public long next(){\n  long result=-1l;\n  if (cache < 0L && bufferElements > 0) {\n    result=getNextFromBuffer();\n    bufferElements--;\n  }\n else {\n    result=cache;\n    cache=-1L;\n  }\n  if (!cs.isEmpty()) {\n    long first=cs.first();\n    if (result > first || result == -1L) {\n      cs.remove(first);\n      cache=result;\n      result=first;\n    }\n  }\n  if (result == -1L) {\n    throw new NoSuchElementException();\n  }\n  Assert.check(previous < result,EC.GENERAL);\n  previous=result;\n  readElements++;\n  return result;\n}\n", "docstring": "returns the next element in the iteration .", "partition": "test"}
{"idx": "2031", "code": "public boolean isSetQueueSize(){\n  return __isset_bit_vector.get(__QUEUESIZE_ISSET_ID);\n}\n", "docstring": "returns true if field queuesize is set ( has been assigned a value ) and false otherwise", "partition": "test"}
{"idx": "2032", "code": "public void requestContactCapabilities(Set<ContactId> contacts) throws RcsServiceNotRegisteredException, RcsServiceNotAvailableException, RcsGenericException {\n  if (mApi == null) {\n    throw new RcsServiceNotAvailableException();\n  }\n  if (contacts == null || contacts.isEmpty()) {\n    throw new RcsIllegalArgumentException(\"contacts must not be null or empty!\");\n  }\n  try {\n    mApi.requestContactCapabilities2(new ArrayList<>(contacts));\n  }\n catch (  Exception e) {\n    RcsIllegalArgumentException.assertException(e);\n    RcsServiceNotRegisteredException.assertException(e);\n    throw new RcsGenericException(e);\n  }\n}\n", "docstring": "requests capabilities for a group of remote contacts . this method initiates in background new capability requests to the remote contact by sending a sip options . the result of the capability request is sent asynchronously via callback method of the capabilities listener . the parameter contacts supports the following formats : msisdn in national or international format , sip address , sip - uri or tel - uri . if the format of the contact is not supported an exception is thrown . the result of the capability refresh request is provided to all the clients that have registered the listener for this event .", "partition": "test"}
{"idx": "2033", "code": "private static String toString(double coeff){\n  final String c=Double.toString(coeff);\n  if (c.endsWith(\".0\")) {\n    return c.substring(0,c.length() - 2);\n  }\n else {\n    return c;\n  }\n}\n", "docstring": "creates a string representing a coefficient , removing \" . 0 \" endings .", "partition": "test"}
{"idx": "2034", "code": "public static final IndexCreatedEvent createTestIndexCreationStatusWithBulkDataHit(){\n  IndexCreatedEvent toReturn=new IndexCreatedEvent(UUID.randomUUID(),new Date(),new Date(),createTestIndexWithBulkDataHit(),1000,0);\n  toReturn.calculateValues();\n  return toReturn;\n}\n", "docstring": "creates at test indexcreatedevent .", "partition": "test"}
{"idx": "2035", "code": "public boolean validate(String value,String rule){\n  return (value.equalsIgnoreCase(rule));\n}\n", "docstring": "determines whether the specified string is a valid boolean value", "partition": "test"}
{"idx": "2036", "code": "public boolean offer(E event,int taskId) throws InterruptedException {\n  assertNotDone();\n  if (predicate.match(event)) {\n    this.matched[taskId]=true;\n    for (    boolean match : matched) {\n      if (!match)       return true;\n    }\n    responseQueue.put(new EventHolder(event));\n    done=true;\n    return true;\n  }\n else   return false;\n}\n", "docstring": "offer an event to this watch instance . if it accepts the event we note the task id and return true .", "partition": "test"}
{"idx": "2037", "code": "private static AlgorithmParameterSpec algorithmParameterSpec(){\n  final SecureRandom random=new SecureRandom();\n  final byte[] bytes=new byte[CcAes.BLOCK];\n  random.nextBytes(bytes);\n  return new IvParameterSpec(bytes);\n}\n", "docstring": "create algorithmparameterspec with the block size .", "partition": "test"}
{"idx": "2038", "code": "static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {\n  int data=in.readInt();\n  Month month=Month.of(data >>> 28);\n  int dom=((data & (63 << 22)) >>> 22) - 32;\n  int dowByte=(data & (7 << 19)) >>> 19;\n  DayOfWeek dow=dowByte == 0 ? null : DayOfWeek.of(dowByte);\n  int timeByte=(data & (31 << 14)) >>> 14;\n  TimeDefinition defn=TimeDefinition.values()[(data & (3 << 12)) >>> 12];\n  int stdByte=(data & (255 << 4)) >>> 4;\n  int beforeByte=(data & (3 << 2)) >>> 2;\n  int afterByte=(data & 3);\n  LocalTime time=(timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24,0));\n  ZoneOffset std=(stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));\n  ZoneOffset before=(beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));\n  ZoneOffset after=(afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));\n  return ZoneOffsetTransitionRule.of(month,dom,dow,time,timeByte == 24,defn,std,before,after);\n}\n", "docstring": "reads the state from the stream .", "partition": "test"}
{"idx": "2039", "code": "public void drawLinesAndPoints(Graphics2D g2d,ArrayList<ComparableLabel> orderedDateSet,HashMap<ComparableLabel,Integer> dataPoints,long yMaxMark){\n  int sectionWidth=this.graphWidth / orderedDateSet.size();\n  int xOffset=sectionWidth / 2;\n  int yPrevValue;\n  int yCurrentValue;\n  float prevOffsetPerc;\n  float currentOffsetPerc;\n  g2d.setColor(this.lineColor);\n  for (int i=0; i < orderedDateSet.size(); i++) {\n    if (i != 0) {\n      yPrevValue=dataPoints.get(orderedDateSet.get(i - 1));\n      yCurrentValue=dataPoints.get(orderedDateSet.get(i));\n      prevOffsetPerc=yPrevValue / (float)yMaxMark;\n      currentOffsetPerc=yCurrentValue / (float)yMaxMark;\n      g2d.drawLine(this.graphLeft + (i - 1) * sectionWidth + xOffset,this.graphBottom - Math.round(prevOffsetPerc * this.graphHeight),this.graphLeft + i * sectionWidth + xOffset,Math.round(this.graphBottom - currentOffsetPerc * this.graphHeight));\n    }\n else {\n      yCurrentValue=dataPoints.get(orderedDateSet.get(i));\n      currentOffsetPerc=yCurrentValue / (float)yMaxMark;\n      g2d.fillOval(this.graphLeft + (i) * sectionWidth + xOffset - this.pointRadius,this.graphBottom - Math.round(currentOffsetPerc * this.graphHeight) - this.pointRadius,this.pointRadius * 2,this.pointRadius * 2);\n    }\n  }\n}\n", "docstring": "draws the datapoints and the lines connecting the datapoints on the line graph", "partition": "test"}
{"idx": "2040", "code": "final public void println(String s){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    if (s == null)     out.write(_nullChars,0,_nullChars.length);\n else     out.write(s,0,s.length());\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "writes a string followed by a newline .", "partition": "test"}
{"idx": "2041", "code": "private static URI refragUri(URI uri,String frag) throws URISyntaxException {\n  return new URI(uri.getScheme(),uri.getSchemeSpecificPart(),frag);\n}\n", "docstring": "return a new uri with a different fragment .", "partition": "test"}
{"idx": "2042", "code": "@Override public void paint(final PPaintContext ppc){\n  final Paint paint=getPaint();\n  if (paint != null) {\n    final Graphics2D g2=ppc.getGraphics();\n    final PBounds bounds=getUnionOfChildrenBounds(null);\n    if (fillBackground) {\n      g2.setPaint(backgroundColor);\n      g2.fillRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding);\n    }\n    if (drawOutline) {\n      g2.setPaint(lineColor);\n      g2.drawRoundRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding,ROUNDING_WIDTH_HEIGHT,ROUNDING_WIDTH_HEIGHT);\n    }\n  }\n}\n", "docstring": "change the default paint to fill an expanded bounding box based on its children \"'\" s bounds .", "partition": "test"}
{"idx": "2043", "code": "public final synchronized byte[] toByteArray(){\n  ByteArrayOutputStream baos=null;\n  DataOutputStream dos=null;\n  try {\n    baos=new ByteArrayOutputStream(32768);\n    dos=new DataOutputStream(baos);\n    game.writeToStream(dos);\n    dos.flush();\n    return baos.toByteArray();\n  }\n catch (  IOException e) {\n    return null;\n  }\n finally {\n    if (dos != null)     try {\n      dos.close();\n    }\n catch (    IOException ex) {\n    }\n    if (baos != null)     try {\n      baos.close();\n    }\n catch (    IOException ex) {\n    }\n  }\n}\n", "docstring": "serialize to byte array .", "partition": "test"}
{"idx": "2044", "code": "public void addImport(@NotNull PsiElement importable,@NotNull PsiFile file,@Nullable PyImportElement importElement){\n  myImports.add(new ImportCandidateHolder(importable,file,importElement,null));\n}\n", "docstring": "adds another import source .", "partition": "test"}
{"idx": "2045", "code": "protected final void drawArrowHead(Graphics2D g,int x,int y,int sgn){\n  g.setStroke(Strokes.getStroke(StrokeType.SOLID,1));\n  int size=diagram().arrowSize;\nswitch (headType) {\ncase CLOSED:\n    Polygon p=new Polygon(new int[]{x,x + sgn * size,x + sgn * size,x},new int[]{y,y - size,y + size,y},4);\n  g.fillPolygon(p);\nbreak;\ncase OPEN:\ng.drawLine(x,y,x + sgn * size,y - size);\ng.drawLine(x,y,x + sgn * size,y + size);\nbreak;\ncase ROUNDED:\nint left=sgn == -1 ? x - 2 * size : x;\nint top=y - size;\ng.fillArc(left,top,size * 2,size * 2,90,sgn * 180);\n}\n}\n", "docstring": "draws the head of a message arrow onto the diagram display .", "partition": "test"}
{"idx": "2046", "code": "public void classLoaderInit(DynamicClassLoader loader){\n  EnvLoaderListener listener=_listenerRef.get();\n  if (listener != null)   listener.classLoaderInit(loader);\n}\n", "docstring": "handles the case where a class loader is activated .", "partition": "test"}
{"idx": "2047", "code": "private Object[] unmarshalParametersChecked(DeserializationChecker checker,Method method,MarshalInputStream in) throws IOException, ClassNotFoundException {\n  int callID=methodCallIDCount.getAndIncrement();\n  MyChecker myChecker=new MyChecker(checker,method,callID);\n  in.setStreamChecker(myChecker);\n  try {\n    Class<?>[] types=method.getParameterTypes();\n    Object[] values=new Object[types.length];\n    for (int i=0; i < types.length; i++) {\n      myChecker.setIndex(i);\n      values[i]=unmarshalValue(types[i],in);\n    }\n    myChecker.end(callID);\n    return values;\n  }\n  finally {\n    in.setStreamChecker(null);\n  }\n}\n", "docstring": "unmarshal parameters for the given method of the given instance over the given marshalinputstream . do perform all additional checks .", "partition": "test"}
{"idx": "2048", "code": "private void loadDataFromService(){\n  List<ExceptionSensorData> exData=null;\n  if ((null != fromDate) && (null != toDate)) {\n    exData=dataAccessService.getUngroupedExceptionOverview(template,limit,fromDate,toDate,resultComparator);\n  }\n else {\n    exData=dataAccessService.getUngroupedExceptionOverview(template,limit,resultComparator);\n  }\n  exceptionSensorData.clear();\n  if (null != exData) {\n    exceptionSensorData.addAll(exData);\n  }\n}\n", "docstring": "reloads the data from the service .", "partition": "test"}
{"idx": "2049", "code": "void drawIcon(Graphics g,int ax,int ay,int aw,int ah,float align,Component c){\n  int gap=isLeftToRight ? -(img.getIconWidth() + bulletgap) : (aw + bulletgap);\n  int x=ax + gap;\n  int y=Math.max(ay,ay + (int)(align * ah) - img.getIconHeight());\n  img.paintIcon(c,g,x,y);\n}\n", "docstring": "draws the bullet icon specified by the list - style - image argument .", "partition": "test"}
{"idx": "2050", "code": "public int syncQuery(String query){\n  long start=System.currentTimeMillis();\n  int modified=execute(\"update\",UPDATE_COUNT_RESPONSE,query);\n  log.debug(\"Update query took {} millis and modified {} statements\",System.currentTimeMillis() - start,modified);\n  return modified;\n}\n", "docstring": "synchronizes the rdf repository \"'\" s representation of an entity to be exactly the provided statements .", "partition": "test"}
{"idx": "2051", "code": "public static void fullReset(){\n  resetRuntime();\nsynchronized (readProperties) {\n    readProperties.clear();\n  }\n}\n", "docstring": "fully reset the state , not only the one related to latest test case execution", "partition": "test"}
{"idx": "2052", "code": "private BufferedImage toBufferedImage(final Image image){\n  if (image instanceof BufferedImage) {\n    return (BufferedImage)image;\n  }\n  if (image instanceof VolatileImage) {\n    VolatileImage volatileImage=(VolatileImage)image;\n    return volatileImage.getSnapshot();\n  }\n  GraphicsEnvironment graphicsEnvironment=GraphicsEnvironment.getLocalGraphicsEnvironment();\n  GraphicsDevice graphicsDevice=graphicsEnvironment.getDefaultScreenDevice();\n  GraphicsConfiguration graphicsConfiguration=graphicsDevice.getDefaultConfiguration();\n  BufferedImage bufferedImage=graphicsConfiguration.createCompatibleImage(image.getWidth(null),image.getHeight(null));\n  Graphics2D g=bufferedImage.createGraphics();\n  g.drawImage(image,0,0,null);\n  g.dispose();\n  return bufferedImage;\n}\n", "docstring": "convert the specified image to a bufferedimage , if necessary .", "partition": "test"}
{"idx": "2053", "code": "public final boolean isCancelled(){\n  if (cancelled) {\n    pass(\"cancelled\",cancelled);\n  }\n else {\n    fail(\"cancelled\");\n  }\n  return cancelled;\n}\n", "docstring": "returns true if this testsubscriber has been cancelled .", "partition": "test"}
{"idx": "2054", "code": "public void remove(DirectedEdge de){\n  outEdges.remove(de);\n}\n", "docstring": "drops a member of this directededgestar .", "partition": "test"}
{"idx": "2055", "code": "@Override protected void onMessageOnProducerThread(T msg){\n  _lock.lock();\n  try {\n    if (_pending.isEmpty()) {\n      _queue.schedule(_flushRunnable,_interval,_timeUnit);\n    }\n    _pending.add(msg);\n  }\n  finally {\n    _lock.unlock();\n  }\n}\n", "docstring": "receives message and batches as needed .", "partition": "test"}
{"idx": "2056", "code": "public Builder untilDate(Date date){\n  untilDate=QUERY_DATE.format(date);\n  return this;\n}\n", "docstring": "returns tweets generated before the given date . date should be formatted as yyyy - mm - dd . keep in mind that the search index may not go back as far as the date you specify here .", "partition": "test"}
{"idx": "2057", "code": "private boolean isInThumbRange(float touchX,double normalizedThumbValue){\n  return Math.abs(touchX - normalizedToScreen(normalizedThumbValue)) <= mThumbHalfWidth;\n}\n", "docstring": "decides if given x - coordinate in screen space needs to be interpreted as \" within \" the normalized thumb x - coordinate .", "partition": "test"}
{"idx": "2058", "code": "public static void cleanupAllFiles(FileSystem fileSystem,String BaseUri) throws IOException {\n  try {\n    if (fileSystem != null) {\n      Path rootDir=new Path(BaseUri);\n      FileStatus[] files=fileSystem.listStatus(rootDir);\n      for (      FileStatus file : files) {\n        fileSystem.delete(file.getPath(),false);\n      }\n    }\n  }\n catch (  Exception e) {\n    LOG.error(\"Error in deleting all files.\");\n  }\n}\n", "docstring": "deletes all files in a container", "partition": "test"}
{"idx": "2059", "code": "@Override public boolean canBeCollidedWith(){\n  return true;\n}\n", "docstring": "returns true if other entities should be prevented from moving through this entity .", "partition": "test"}
{"idx": "2060", "code": "public void submit(String queueName,DispatcherTask dispatcherTask){\nsynchronized (syncRoot) {\n    DispatcherTaskRunner currentTaskRunner=currentTasksMap.get(queueName);\n    if (currentTaskRunner == null) {\n      currentTaskRunner=new DispatcherTaskRunner(queueName,dispatcherTask);\n      currentTasksMap.put(queueName,currentTaskRunner);\n      executorService.execute(currentTaskRunner);\n    }\n else {\n      enqueueNextTask(queueName,dispatcherTask);\n    }\n  }\n}\n", "docstring": "submits task to the specific queue", "partition": "test"}
{"idx": "2061", "code": "public void dump(Writer writer){\n  PrintWriter pw=new PrintWriter(new BufferedWriter(writer));\n  pw.println(\"#========== Wave ==========\");\n  pw.println(\"#Type: NULL\");\n  pw.println(\"#Sample_Rate: \" + (int)audioFormat.getSampleRate());\n  pw.println(\"#Num_of_Samples: \" + samples.length / 2);\n  pw.println(\"#Num_of_Channels: \" + audioFormat.getChannels());\n  if (samples != null) {\n    for (int i=0; i < samples.length; i+=2) {\n      pw.println(WaveUtils.bytesToShort(samples[i],samples[i + 1]));\n    }\n  }\n  pw.flush();\n}\n", "docstring": "dumps the wave out to the given stream", "partition": "test"}
{"idx": "2062", "code": "public void addFieldBuffered(VEditor editor,GridField mField){\n  wrap=mField != null ? !mField.isSameLine() : false;\n  if (prevEditor != null && prevField != null)   addField(prevEditor,prevField);\n  prevEditor=editor;\n  prevField=mField;\n}\n", "docstring": "add field and label to buffer and push buffered field to panel", "partition": "test"}
{"idx": "2063", "code": "public ExpandRoomFreespaceIncomplete add_incomplete_expansion_room(ShapeTile p_shape,int p_layer,ShapeTile p_contained_shape){\n  ExpandRoomFreespaceIncomplete new_room=new ExpandRoomFreespaceIncomplete(p_shape,p_layer,p_contained_shape);\n  incomplete_expansion_rooms.add(new_room);\n  return new_room;\n}\n", "docstring": "creates a new freespaceexpansionroom and adds it to the room list . its shape is normally unbounded at construction time of the room . the final ( completed ) shape will be a subshape of the start shape , which does not overlap with any obstacle , and it is as big as possible . p_contained_points will remain contained in the shape , after it is completed .", "partition": "test"}
{"idx": "2064", "code": "static double computeDesiredEllipsoidMagnitude(final PlanetModel planetModel,final double x,final double y,final double z){\n  return 1.0 / Math.sqrt(x * x * planetModel.inverseAbSquared + y * y * planetModel.inverseAbSquared + z * z * planetModel.inverseCSquared);\n}\n", "docstring": "compute the desired magnitude of a unit vector projected to a given planet model .", "partition": "test"}
{"idx": "2065", "code": "private void validateVNXFileSMISProviderMandatoryDetails(StorageSystemRequestParam param){\n  ArgValidator.checkFieldValidIP(param.getSmisProviderIP(),\"smis_provider_ip\");\n  ArgValidator.checkFieldNotNull(param.getSmisPortNumber(),\"smis_port_number\");\n  ArgValidator.checkFieldRange(param.getSmisPortNumber(),1,65535,\"smis_port_number\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisUserName(),\"smis_user_name\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisPassword(),\"smis_password\");\n}\n", "docstring": "validates smi - s provider attributes of the vnxfile as it is a mandatory fields for indications", "partition": "test"}
{"idx": "2066", "code": "public void createAccrualBasedJournalEntriesAndReversalsForLoanCharges(final Office office,final String currencyCode,final Integer accountTypeToBeDebited,final Integer accountTypeToBeCredited,final Long loanProductId,final Long loanId,final String transactionId,final Date transactionDate,final BigDecimal totalAmount,final Boolean isReversal,final List<ChargePaymentDTO> chargePaymentDTOs){\n  GLAccount receivableAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeDebited,null);\n  final Map<GLAccount,BigDecimal> creditDetailsMap=new LinkedHashMap<>();\n  for (  final ChargePaymentDTO chargePaymentDTO : chargePaymentDTOs) {\n    final Long chargeId=chargePaymentDTO.getChargeId();\n    final GLAccount chargeSpecificAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeCredited,chargeId);\n    BigDecimal chargeSpecificAmount=chargePaymentDTO.getAmount();\n    if (creditDetailsMap.containsKey(chargeSpecificAccount)) {\n      final BigDecimal existingAmount=creditDetailsMap.get(chargeSpecificAccount);\n      chargeSpecificAmount=chargeSpecificAmount.add(existingAmount);\n    }\n    creditDetailsMap.put(chargeSpecificAccount,chargeSpecificAmount);\n  }\n  BigDecimal totalCreditedAmount=BigDecimal.ZERO;\n  for (  final Map.Entry<GLAccount,BigDecimal> entry : creditDetailsMap.entrySet()) {\n    final GLAccount account=entry.getKey();\n    final BigDecimal amount=entry.getValue();\n    totalCreditedAmount=totalCreditedAmount.add(amount);\n    if (isReversal) {\n      createDebitJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n    }\n else {\n      createDebitJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n    }\n  }\n  if (totalAmount.compareTo(totalCreditedAmount) != 0) {\n    throw new PlatformDataIntegrityException(\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",totalCreditedAmount,totalAmount);\n  }\n}\n", "docstring": "convenience method that creates a pair of related debits and credits for accrual based accounting . the target accounts for debits and credits are switched in case of a reversal", "partition": "test"}
{"idx": "2067", "code": "private ArtLocateResult calculate_next_trace(boolean p_layer_changed,boolean p_at_fanout_end){\n  Collection<PlaPointFloat> corner_list=new LinkedList<PlaPointFloat>();\n  corner_list.add(current_from_point);\n  if (!p_at_fanout_end) {\n    PlaPointFloat adjusted_start_corner=adjust_start_corner();\n    if (adjusted_start_corner != current_from_point) {\n      PlaPointFloat add_corner=calculate_additional_corner(current_from_point,adjusted_start_corner,true,angle_restriction);\n      corner_list.add(add_corner);\n      corner_list.add(adjusted_start_corner);\n      previous_from_point=current_from_point;\n      current_from_point=adjusted_start_corner;\n    }\n  }\n  PlaPointFloat prev_corner=current_from_point;\n  for (int c_limit=0; c_limit < 1000; c_limit++) {\n    Collection<PlaPointFloat> next_corners=calculate_next_trace_corners();\n    if (next_corners.isEmpty())     break;\n    for (    PlaPointFloat curr_next_corner : next_corners) {\n      if (curr_next_corner == prev_corner)       continue;\n      corner_list.add(curr_next_corner);\n      previous_from_point=current_from_point;\n      current_from_point=curr_next_corner;\n      prev_corner=curr_next_corner;\n    }\n  }\n  int next_layer=current_trace_layer;\n  if (p_layer_changed) {\n    current_from_door_index=current_target_door_index + 1;\n    ExpandRoomComplete next_room=backtrack_array[current_from_door_index].next_room;\n    if (next_room != null) {\n      next_layer=next_room.get_layer();\n    }\n  }\n  PlaPointIntAlist rounded_corner_list=new PlaPointIntAlist(corner_list.size());\n  PlaPointInt prev_point=null;\n  for (  PlaPointFloat a_float : corner_list) {\n    PlaPointInt curr_point=a_float.round();\n    if (curr_point.equals(prev_point))     continue;\n    rounded_corner_list.add(curr_point);\n    prev_point=curr_point;\n  }\n  ArtLocateResult result=new ArtLocateResult(rounded_corner_list,current_trace_layer);\n  current_trace_layer=next_layer;\n  return result;\n}\n", "docstring": "calculates the next trace trace of the connection under construction .", "partition": "test"}
{"idx": "2068", "code": "@Override protected Sensor createNewSensor(String systemName,String userName){\n  if (log.isDebugEnabled()) {\n    log.debug(\"createNewSensor \" + systemName + \" \"+ userName);\n  }\n  Sensor s;\n  String sName=SerialAddress.normalizeSystemName(systemName);\n  if (sName.equals(\"\")) {\n    log.error(\"Invalid Sensor system name - \" + systemName);\n    return null;\n  }\n  s=getBySystemName(sName);\n  if (s != null) {\n    log.error(\"Sensor with this name already exists - \" + systemName);\n    return null;\n  }\n  String altName=SerialAddress.convertSystemNameToAlternate(sName);\n  s=getBySystemName(altName);\n  if (s != null) {\n    log.error(\"Sensor with name \'\" + systemName + \"\' already exists as \'\"+ altName+ \"\'\");\n    return null;\n  }\n  int bit=SerialAddress.getBitFromSystemName(sName);\n  if ((bit <= 0) || (bit >= SENSORSPERNODE)) {\n    log.error(\"Sensor bit number, \" + Integer.toString(bit) + \", is outside the supported range, 1-\"+ Integer.toString(SENSORSPERNODE - 1));\n    return null;\n  }\n  if (userName == null) {\n    s=new SerialSensor(sName);\n  }\n else {\n    s=new SerialSensor(sName,userName);\n  }\n  SerialNode node=SerialAddress.getNodeFromSystemName(sName);\n  if (node == null) {\n    log.warn(\"Sensor \" + sName + \" refers to an undefined Serial Node.\");\n    return s;\n  }\n  node.registerSensor(s,bit);\n  if (log.isDebugEnabled()) {\n    log.debug(\"register \" + s.getSystemName() + \" in node \"+ node);\n  }\n  return s;\n}\n", "docstring": "create a new sensor if all checks are passed system name is normalized to ensure uniqueness .", "partition": "test"}
{"idx": "2069", "code": "private double[] max(double[] distances1,double[] distances2){\n  if (distances1.length != distances2.length) {\n    throw new RuntimeException(\"different lengths!\");\n  }\n  double[] result=new double[distances1.length];\n  for (int i=0; i < distances1.length; i++) {\n    result[i]=Math.max(distances1[i],distances2[i]);\n  }\n  return result;\n}\n", "docstring": "returns an array that holds the maximum values of the both specified arrays in each index .", "partition": "test"}
{"idx": "2070", "code": "public void fill_shape(PlaPointFloat[] p_points,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  Graphics2D g2=(Graphics2D)p_g;\n  Polygon draw_polygon=new Polygon();\n  for (int index=0; index < p_points.length; index++) {\n    Point2D curr_corner=coordinate_transform.board_to_screen(p_points[index]);\n    draw_polygon.addPoint((int)Math.round(curr_corner.getX()),(int)Math.round(curr_corner.getY()));\n  }\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_polygon);\n}\n", "docstring": "fill the interior of the polygon shape represented by p_points .", "partition": "test"}
{"idx": "2071", "code": "public void goToCurrentDay(){\n  int monthDifference=FlexibleCalendarHelper.getMonthDifference(displayYear,displayMonth);\n  Calendar cal=Calendar.getInstance();\n  selectedDateItem.setDay(cal.get(Calendar.DAY_OF_MONTH));\n  selectedDateItem.setMonth(cal.get(Calendar.MONTH));\n  selectedDateItem.setYear(cal.get(Calendar.YEAR));\n  if (disableAutoDateSelection) {\n    this.userSelectedItem=selectedDateItem.clone();\n  }\n  if (monthDifference != 0) {\n    resetAdapters=true;\n    if (monthDifference < 0) {\n      monthInfPagerAdapter.setFakeCount(lastPosition);\n      monthInfPagerAdapter.notifyDataSetChanged();\n    }\n    shouldOverrideComputedDate=true;\n    moveToPosition(monthDifference);\n  }\n else {\n    FlexibleCalendarGridAdapter currentlyVisibleAdapter=monthViewPagerAdapter.getMonthAdapterAtPosition(lastPosition % MonthViewPagerAdapter.VIEWS_IN_PAGER);\n    currentlyVisibleAdapter.notifyDataSetChanged();\n  }\n}\n", "docstring": "move the position to today \"'\" s date", "partition": "test"}
{"idx": "2072", "code": "public boolean isValidTemplate(){\n  return isValidTemplate(template);\n}\n", "docstring": "validates this template to see if its valid for plugin v3 . 10 or higher .", "partition": "test"}
{"idx": "2073", "code": "public Object take() throws InterruptedException, ForceReattemptException {\n  throw new UnsupportedOperationException();\n}\n", "docstring": "it removes the first key from the queue .", "partition": "test"}
{"idx": "2074", "code": "@SuppressWarnings({\"SuspiciousNameCombination\"}) public static double normalCdf(double y){\n  double f, h;\n  int j;\n  double dcphi, x, z, f1, f2, f3, f4, f5;\n  x=y;\n  if (Math.abs(x) > 15.) {\n    dcphi=0.;\n  }\n else {\n    j=(int)Math.floor(Math.abs(x) * 16. + .5);\n    z=j * .0625;\n    h=Math.abs(x) - z;\n    f=r[j];\n    f1=f * z - 1;\n    f2=f + z * f1;\n    f3=f1 * 2. + z * f2;\n    f4=f2 * 3 + z * f3;\n    f5=f3 * 4 + z * f4;\n    dcphi=f + h * (f1 * 120. + h * (f2 * 60. + h * (f3 * 20. + h * (f4 * 5. + h * f5)))) / 120.;\n    dcphi=dcphi * .3989422804014326779 * Math.exp(x * -.5 * x);\n  }\n  if (x < 0.) {\n    return dcphi;\n  }\n else {\n    return (1.0 - dcphi);\n  }\n}\n", "docstring": "normal cumulative distribution function ( the value which results by integrating the normal distribution function from negative infinity up to y ) .", "partition": "test"}
{"idx": "2075", "code": "private void destroy(){\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(this + \" destroying connection\");\n  }\n  try {\n    _socket.forceShutdown();\n  }\n catch (  Throwable e) {\n  }\n  try {\n    closeConnection();\n  }\n catch (  Throwable e) {\n    log.log(Level.FINER,e.toString(),e);\n  }\n  _port.removeConnection(this);\n}\n", "docstring": "destroy kills the connection and drops it from the connection pool . destroy should only occur if the connection state machine has failed or", "partition": "test"}
{"idx": "2076", "code": "int atom() throws RESyntaxException {\n  int ret=node(RE.OP_ATOM,0);\n  int lenAtom=0;\n  atomLoop:   while (idx < len) {\n    if ((idx + 1) < len) {\n      char c=pattern.charAt(idx + 1);\n      if (pattern.charAt(idx) == \'\\\\\') {\n        int idxEscape=idx;\n        escape();\n        if (idx < len) {\n          c=pattern.charAt(idx);\n        }\n        idx=idxEscape;\n      }\nswitch (c) {\ncase \'{\':\ncase \'?\':\ncase \'*\':\ncase \'+\':\n        if (lenAtom != 0) {\n          break atomLoop;\n        }\n    }\n  }\nswitch (pattern.charAt(idx)) {\ncase \']\':\ncase \'^\':\ncase \'$\':\ncase \'.\':\ncase \'[\':\ncase \'(\':\ncase \')\':\ncase \'|\':\n    break atomLoop;\ncase \'{\':\ncase \'?\':\ncase \'*\':\ncase \'+\':\n  if (lenAtom == 0) {\n    syntaxError(\"Missing operand to closure\");\n  }\nbreak atomLoop;\ncase \'\\\\\':\n{\nint idxBeforeEscape=idx;\nint c=escape();\nif ((c & ESC_MASK) == ESC_MASK) {\n  idx=idxBeforeEscape;\n  break atomLoop;\n}\nemit((char)c);\nlenAtom++;\n}\nbreak;\ndefault :\nemit(pattern.charAt(idx++));\nlenAtom++;\nbreak;\n}\n}\nif (lenAtom == 0) {\ninternalError();\n}\ninstruction[ret + RE.offsetOpdata]=(char)lenAtom;\nreturn ret;\n}\n", "docstring": "absorb an atomic character string . this method is a little tricky because it can un - include the last character of string if a closure operator follows . this is correct because * + ? have higher precedence than concatentation ( thus abc * means ab ( c * ) and not ( abc ) * ) .", "partition": "test"}
{"idx": "2077", "code": "@Override public void drawItem(Graphics2D g2,CategoryItemRendererState state,Rectangle2D dataArea,CategoryPlot plot,CategoryAxis domainAxis,ValueAxis rangeAxis,CategoryDataset dataset,int row,int column,int pass){\n  int visibleRow=state.getVisibleSeriesIndex(row);\n  if (visibleRow < 0) {\n    return;\n  }\n  Number dataValue=dataset.getValue(row,column);\n  if (dataValue == null) {\n    return;\n  }\n  double value=dataValue.doubleValue();\n  PlotOrientation orientation=plot.getOrientation();\n  double barW0=calculateBarW0(plot,orientation,dataArea,domainAxis,state,visibleRow,column);\n  RectangleEdge edge=plot.getRangeAxisEdge();\n  double barL=rangeAxis.valueToJava2D(value,dataArea,edge);\n  Line2D line;\n  double x, y;\n  if (orientation.isHorizontal()) {\n    x=barL;\n    y=barW0 + state.getBarWidth() / 2.0;\n    line=new Line2D.Double(barL,barW0,barL,barW0 + state.getBarWidth());\n  }\n else {\n    x=barW0 + state.getBarWidth() / 2.0;\n    y=barL;\n    line=new Line2D.Double(barW0,barL,barW0 + state.getBarWidth(),barL);\n  }\n  if (state.getElementHinting()) {\n    beginElementGroup(g2,dataset.getRowKey(row),dataset.getColumnKey(column));\n  }\n  Stroke itemStroke=getItemStroke(row,column);\n  Paint itemPaint=getItemPaint(row,column);\n  g2.setStroke(itemStroke);\n  g2.setPaint(itemPaint);\n  g2.draw(line);\n  if (state.getElementHinting()) {\n    endElementGroup(g2);\n  }\n  CategoryItemLabelGenerator generator=getItemLabelGenerator(row,column);\n  if (generator != null && isItemLabelVisible(row,column)) {\n    drawItemLabel(g2,orientation,dataset,row,column,x,y,(value < 0.0));\n  }\n  int datasetIndex=plot.indexOf(dataset);\n  updateCrosshairValues(state.getCrosshairState(),dataset.getRowKey(row),dataset.getColumnKey(column),value,datasetIndex,barW0,barL,orientation);\n  EntityCollection entities=state.getEntityCollection();\n  if (entities != null) {\n    addItemEntity(entities,dataset,row,column,line.getBounds());\n  }\n}\n", "docstring": "draws the bar for a single ( series , category ) data item .", "partition": "test"}
{"idx": "2078", "code": "public static <T>UnaryOperator<List<T>> from(Collection<String> commandLineUdids,Function<T,ICloud.MBSBackup> mbsBackup,Function<ICloud.MBSBackup,String> formatter,Printer out,InputStream in){\n  return commandLineUdids.isEmpty() ? new User(mbsBackup,out,in,formatter) : new Udid(mbsBackup,out,in,new ArrayList<>(commandLineUdids));\n}\n", "docstring": "returns a new instance . < p > the from udids will be fully or partially matched against the supplied udids , case - insensitive . if the supplied udids list is empty , the user will be prompted for a selection .", "partition": "test"}
{"idx": "2079", "code": "public boolean isNetworkConnected(){\n  ConnectivityManager connectivityManager=(ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE);\n  NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo();\n  return networkInfo != null && networkInfo.isConnectedOrConnecting();\n}\n", "docstring": "check the current active network is available .", "partition": "test"}
{"idx": "2080", "code": "public void put(String name,String supported,String authScheme,String level,boolean isDefault){\n  SAMLv2AuthContext c=new SAMLv2AuthContext();\n  c.name=name;\n  c.supported=supported;\n  if (authScheme.length() != 0 && authScheme != null) {\n    int index=authScheme.lastIndexOf(\"=\");\n    c.value=authScheme.substring(index + 1);\n    c.key=authScheme.substring(0,index);\n  }\n else {\n    c.value=\"\";\n    c.key=\"\";\n  }\n  c.level=level;\n  c.isDefault=isDefault;\n  collections.put(name,c);\n}\n", "docstring": "adds samlv2authcontext to the collection .", "partition": "test"}
{"idx": "2081", "code": "public final void close(LsServerPacket closePacket,boolean forced){\nsynchronized (guard) {\n    if (isWriteDisabled()) {\n      return;\n    }\n    log.debug(\"sending packet: \" + closePacket + \" and closing connection after that.\");\n    pendingClose=true;\n    isForcedClosing=forced;\n    sendMsgQueue.clear();\n    sendMsgQueue.addLast(closePacket);\n    enableWriteInterest();\n  }\n}\n", "docstring": "its guaranted that closepacket will be sent before closing connection , but all past and future packets wont . connection will be closed [ by dispatcher thread ", "partition": "test"}
{"idx": "2082", "code": "private void replaceCollapsedEdges(){\n  List newEdges=new ArrayList();\n  for (Iterator it=edgeList.iterator(); it.hasNext(); ) {\n    Edge e=(Edge)it.next();\n    if (e.isCollapsed()) {\n      it.remove();\n      newEdges.add(e.getCollapsedEdge());\n    }\n  }\n  edgeList.addAll(newEdges);\n}\n", "docstring": "if edges which have undergone dimensional collapse are found , replace them with a new edge which is a l edge", "partition": "test"}
{"idx": "2083", "code": "public SeaGlassTitlePane(JRootPane rootPane,SeaGlassRootPaneUI ui){\n  this.rootPane=rootPane;\n  this.rootPaneUI=ui;\n  rootParent=(RootPaneContainer)rootPane.getParent();\n  installTitlePane();\n}\n", "docstring": "creates a new seaglasstitlepane object .", "partition": "test"}
{"idx": "2084", "code": "public void writeLong(long value) throws IOException {\n  checkWritePrimitiveTypes();\n  primitiveTypes.writeLong(value);\n}\n", "docstring": "writes a long ( 64 bit ) to the target stream .", "partition": "test"}
{"idx": "2085", "code": "static public URL findContainerXML(String _containerName){\n  URL _containerNameURL=null;\n  String _containerNameFilePath=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + _containerName+ \".xml\";\n  _containerNameURL=getResourceURL(_containerNameFilePath);\n  if (_containerNameURL != null) {\n    if (_logger.isLoggable(Level.INFO)) {\n      _logger.info(\"Loaded the container xml file < \" + _containerNameURL + \" >.\");\n    }\n  }\n  return _containerNameURL;\n}\n", "docstring": "look for the requested container xml file in the classpath ( resource ) under < some root dir > / config / < reqested_container_name > . xml . if the classpath contains < some root dir > first in classpath , it will attempt to look for the container xml file first in the file system under < some root dir > / config / < requested_container_name > . xml . container xml file contains the list of the spaces which are part of this container . fixed bug 26 / 06 / 06 gershon - http : / / 62 . 90 . 11 . 164 : 8080 / browse / app - 90 container . xml location mechanism must use getresource ( ) and load the container xml from resource according to the classpath", "partition": "test"}
{"idx": "2086", "code": "public static List<String> expandWildcards(Iterable<File> dirs,List<String> names,Backend forBackend){\n  List<String> result=new ArrayList<String>(names.size());\n  for (  String name : names) {\n    expandWildcard(result,dirs,name,forBackend);\n  }\n  return result;\n}\n", "docstring": "given a list of source directories and a list of module names that possibly contain wildcards it returns a expanded list of module names of modules that were actually found in the given source directories . module names that didn \"'\" t contain wildcards are left alone ( it \"'\" s not checked if they exist or not ) . if a backend is passed expanded modules will be checked if they support it ( they either don \"'\" t have a native annotation or it is for the correct backend ) .", "partition": "test"}
{"idx": "2087", "code": "public static Charset forName(String charsetName){\n  return forName(charsetName,null);\n}\n", "docstring": "safely gets charset for the specified name", "partition": "test"}
{"idx": "2088", "code": "public NSNumber(int i){\n  doubleValue=longValue=i;\n  type=INTEGER;\n}\n", "docstring": "creates an integer number .", "partition": "test"}
{"idx": "2089", "code": "public static void dump(String message,StackTraceElement[] stackTrace){\n  dump(message,Arrays.asList(stackTrace));\n}\n", "docstring": "dumps the given message and stack to the system error console .", "partition": "test"}
{"idx": "2090", "code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase EipPackage.CONDITIONAL_ROUTE__CONDITION:\n    return CONDITION_EDEFAULT == null ? condition != null : !CONDITION_EDEFAULT.equals(condition);\ncase EipPackage.CONDITIONAL_ROUTE__CHANNEL:\n  return channel != null;\n}\nreturn super.eIsSet(featureID);\n}\n", "docstring": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "2091", "code": "public static native String mapLibraryName(String libname);\n", "docstring": "maps a library name into a platform - specific string representing a native library .", "partition": "test"}
{"idx": "2092", "code": "public Matcher next() throws IOException {\n  readahead();\n  if (matches == null) {\n    throw new NoSuchElementException();\n  }\n  Matcher matcher=matches.next();\n  if (discard) {\n    Pattern pattern=matcher.pattern();\n    for (int n=0; n < patterns.length; n++) {\n      if (patterns[n] == pattern) {\n        patterns[n]=null;\n        break;\n      }\n    }\n  }\n  return matcher;\n}\n", "docstring": "returns the next match from the character stream . matches are returned in the order they are encountered in the character stream , then by the order they are expressed in the supplied patterns collection .", "partition": "test"}
{"idx": "2093", "code": "@CalledOnlyBy(AmidstThread.FRAGMENT_LOADER) public void processQueues(){\n  Dimension dimension=dimensionSetting.get();\n  updateLayerManager(dimension);\n  processRecycleQueue();\n  Fragment fragment;\n  while ((fragment=loadingQueue.poll()) != null) {\n    loadFragment(dimension,fragment);\n    dimension=dimensionSetting.get();\n    updateLayerManager(dimension);\n    processRecycleQueue();\n  }\n  layerManager.clearInvalidatedLayers();\n}\n", "docstring": "it is important that the dimension setting is the same while a fragment is loaded by different fragment loaders . this is why the dimension setting is read by the fragment loader thread .", "partition": "test"}
{"idx": "2094", "code": "default FieldDeclaration addPrivateField(Class<?> typeClass,String name){\n  return addField(typeClass,name,Modifier.PRIVATE);\n}\n", "docstring": "add a private field to this", "partition": "test"}
{"idx": "2095", "code": "void ReconstructPrivateSubrs(int Font,IndexBaseItem[] fdPrivateBase,OffsetItem[] fdSubrs){\n  for (int i=0; i < fonts[Font].fdprivateLengths.length; i++) {\n    if (fdSubrs[i] != null && fonts[Font].PrivateSubrsOffset[i] >= 0) {\n      OutputList.addLast(new SubrMarkerItem(fdSubrs[i],fdPrivateBase[i]));\n      if (NewLSubrsIndex[i] != null)       OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(rasFactory.createSource(NewLSubrsIndex[i])),0,NewLSubrsIndex[i].length));\n    }\n  }\n}\n", "docstring": "function adds the new lsubrs dicts ( only for the fds used ) to the list", "partition": "test"}
{"idx": "2096", "code": "public void initGL(){\n  mEglCore=new EglCore(null,EglCore.FLAG_RECORDABLE | EglCore.FLAG_TRY_GLES3);\n  mWindowSurface=new WindowSurface(mEglCore,mSurfaceTexture);\n  mWindowSurface.makeCurrent();\n  mRecordSurface=new WindowSurface(mEglCore,mMediaRecorder.getSurface(),false);\n  initGLComponents();\n}\n", "docstring": "initialize all necessary components for gles rendering , creating window surfaces for drawing the preview as well as the surface that will be used by mediarecorder for recording", "partition": "test"}
{"idx": "2097", "code": "protected void contributeTokenRequestParameters(final QueryString bodyParameters){\n}\n", "docstring": "allows subclasses to augment the request to the token endpoint with additional parameters .", "partition": "test"}
{"idx": "2098", "code": "Builder addLenient(String line){\n  int index=line.indexOf(\":\",1);\n  if (index != -1) {\n    return addLenient(line.substring(0,index),line.substring(index + 1));\n  }\n else   if (line.startsWith(\":\")) {\n    return addLenient(\"\",line.substring(1));\n  }\n else {\n    return addLenient(\"\",line);\n  }\n}\n", "docstring": "add a header line without any validation . only appropriate for headers from the remote peer or cache .", "partition": "test"}
{"idx": "2099", "code": "public static void mergeNodeChildren(TreeNode node){\n  DefaultMutableTreeNode masterNode=(DefaultMutableTreeNode)node;\n  for (int i=0; i < masterNode.getChildCount(); i++) {\n    DefaultMutableTreeNode child=(DefaultMutableTreeNode)masterNode.getChildAt(i);\n    if (!child.isLeaf()) {\n      MergeHelpUtilities.mergeNodeChildren(DEFAULT_MERGE_TYPE,child);\n    }\n  }\n}\n", "docstring": "merge node children . merge the children of a node according to the merging rules of the parent . each subclass must implement this method", "partition": "test"}
{"idx": "2100", "code": "public void testNegateNegative(){\n  String a=\"-92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=41;\n  String c=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int cScale=41;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal cNumber=new BigDecimal(new BigInteger(c),cScale);\n  assertEquals(\"incorrect value\",cNumber,aNumber.negate());\n}\n", "docstring": "negate ( ) for a negative bigdecimal", "partition": "test"}
{"idx": "2101", "code": "private static Object createAndBindItem(ParameterAccess parameters,Class<?> itemType){\n  try {\n    Object value=itemType.newInstance();\n    bind(value,parameters);\n    return value;\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new BindingException(\"Failed to instantiate new instance of \" + itemType,e);\n  }\n}\n", "docstring": "creates and binds the parameters to a new item .", "partition": "test"}
{"idx": "2102", "code": "public SimpleSetupPanel(Experiment exp){\n  this();\n  setExperiment(exp);\n}\n", "docstring": "creates the setup panel with the supplied initial experiment .", "partition": "test"}
{"idx": "2103", "code": "private static void processArgs(String[] args){\n  for (int i=0; i < args.length; i++) {\n    String arg=args[i];\n    if (arg.equals(\"-o\")) {\n      outputDir=args[++i];\n    }\n else     if (arg.equals(\"-spec\")) {\n      unicodeData=args[++i];\n    }\n else     if (arg.equals(\"-language\")) {\n      language=args[++i];\n    }\n else     if (arg.equals(\"-country\")) {\n      country=args[++i];\n    }\n else     if (arg.equals(\"-valiant\")) {\n      valiant=args[++i];\n    }\n else {\n      usage();\n    }\n  }\n  localeName=getLocaleName();\n}\n", "docstring": "parses the specified arguments and sets up the variables .", "partition": "test"}
{"idx": "2104", "code": "public static boolean isZoningRequired(DbClient dbClient,VirtualArray nh){\n  if (nh.getAutoSanZoning() == false) {\n    _log.info(\"SAN Zoning is not enabled for Neighborhood: \" + nh.getLabel());\n    return false;\n  }\n  return NetworkUtil.areNetworkSystemDiscovered(dbClient);\n}\n", "docstring": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "partition": "test"}
{"idx": "2105", "code": "private void initXMLTree() throws Exception {\n  updateFilteredTokens();\n  ArrayList elements=getElements(getFilteredTokens());\n  if (elements.size() > 1) {\n    throw new Exception(\"More than one root elements encountered\");\n  }\n  setRootElement((XMLElement)elements.get(0));\n}\n", "docstring": "creats an in - memory xml tree based on the parsed tokens in this document .", "partition": "test"}
{"idx": "2106", "code": "public boolean hasNameValue(String name){\n  return nameValueMap.containsKey(name.toLowerCase());\n}\n", "docstring": "returns a boolean telling if this namevaluelist has a record with this name", "partition": "test"}
{"idx": "2107", "code": "public boolean startsWith(CharSeq prefix){\n  return str.startsWith(prefix.str);\n}\n", "docstring": "tests whether this charseq starts with the specified prefix", "partition": "test"}
{"idx": "2108", "code": "public boolean containsWindow(Class<?> windowClass){\n  return (getWindow(windowClass) != null);\n}\n", "docstring": "checks , whether an instance of the given window class is already in the window list .", "partition": "test"}
{"idx": "2109", "code": "protected final void firePropertyChange(String propertyName,long oldValue,long newValue){\n  firePropertyChange(propertyName,Long.valueOf(oldValue),Long.valueOf(newValue));\n}\n", "docstring": "support for reporting bound property changes for integer properties . this method can be called when a bound property has changed and it will send the appropriate propertychangeevent to any registered propertychangelisteners .", "partition": "test"}
{"idx": "2110", "code": "public AbstractSurfaceObject(AbstractSurfaceObject source){\n  super(source);\n  this.visible=source.visible;\n  this.uniqueId=nextUniqueId();\n  this.lastModifiedTime=System.currentTimeMillis();\n  this.enableBatchPicking=source.enableBatchPicking;\n}\n", "docstring": "creates a shallow copy of the specified source shape .", "partition": "test"}
{"idx": "2111", "code": "public SootMethodAndClass parseSootMethodString(String parseString){\n  if (!parseString.startsWith(\"<\") || !parseString.endsWith(\">\")) {\n    throw new IllegalArgumentException(\"Illegal format of \" + parseString + \" (should use soot method representation)\");\n  }\n  String name=\"\";\n  String className=\"\";\n  String returnType=\"\";\n  Pattern pattern=Pattern.compile(\"<(.*?):\");\n  Matcher matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    className=matcher.group(1);\n  }\n  pattern=Pattern.compile(\": (.*?) \");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    returnType=matcher.group(1);\n    parseString=parseString.substring(matcher.end(1));\n  }\n  pattern=Pattern.compile(\" (.*?)\\\\(\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    name=matcher.group(1);\n  }\n  List<String> paramList=new ArrayList<String>();\n  pattern=Pattern.compile(\"\\\\((.*?)\\\\)\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    String params=matcher.group(1);\n    for (    String param : params.split(\",\"))     paramList.add(param.trim());\n  }\n  return new SootMethodAndClass(name,className,returnType,paramList);\n}\n", "docstring": "parses a string in soot representation , for example : < soot . jimple . infoflow . test . testnomain : java . lang . string function1 ( ) > < soot . jimple . infoflow . test . testnomain : void functioncallonobject ( ) > < soot . jimple . infoflow . test . testnomain : java . lang . string function2 ( java . lang . string , java . lang . string ) >", "partition": "test"}
{"idx": "2112", "code": "private void createNewReviewTask(TaskRepository repository,TaskData taskData) throws CoreException {\n  Repository repo=AppraisePluginUtils.getGitRepoForRepository(repository);\n  AppraisePluginReviewClient client;\n  try {\n    client=new AppraisePluginReviewClient(repository);\n  }\n catch (  GitClientException e1) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Failed to initialize git client\"));\n  }\n  String currentBranch;\n  try {\n    currentBranch=repo.getFullBranch();\n  }\n catch (  IOException e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Error retrieving current branch\",e));\n  }\n  if (MASTER_REF.equals(currentBranch)) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Cannot create review on master branch\"));\n  }\n  setAttributeValue(taskData,schema.REQUESTER,repository.getUserName());\n  setAttributeValue(taskData,schema.TARGET_REF,MASTER_REF);\n  setAttributeValue(taskData,schema.REVIEW_REF,currentBranch);\n  RevCommit reviewCommit;\n  try {\n    reviewCommit=client.getReviewCommit(currentBranch,MASTER_REF);\n  }\n catch (  GitClientException e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Cannot find a merge base\",e));\n  }\n  if (reviewCommit == null) {\n    throw new CoreException(new Status(IStatus.INFO,AppraiseConnectorPlugin.PLUGIN_ID,\"No commits to review on \" + currentBranch));\n  }\n  setAttributeValue(taskData,schema.DESCRIPTION,reviewCommit.getFullMessage());\n  setAttributeValue(taskData,schema.REVIEW_COMMIT,reviewCommit.getName());\n  try {\n    List<DiffEntry> diffs=client.getReviewDiffs(currentBranch,MASTER_REF);\n    populateDiffs(repository,diffs,taskData);\n  }\n catch (  Exception e) {\n    throw new CoreException(new Status(IStatus.ERROR,AppraiseConnectorPlugin.PLUGIN_ID,\"Failed to load review diffs\",e));\n  }\n}\n", "docstring": "sets up a new review on the current branch , as a task .", "partition": "test"}
{"idx": "2113", "code": "@Override public void startup() throws Exception {\n  Log.d(Mary.LOG,\"Register UnitSelection voices:\");\n  List<String> voiceNames=MaryProperties.getList(\"unitselection.voices.list\");\n  for (  String voiceName : voiceNames) {\n    long time=System.currentTimeMillis();\n    Voice unitSelVoice=new UnitSelectionVoice(voiceName,this);\n    Log.d(Mary.LOG,\"Voice \'\" + unitSelVoice + \"\'\");\n    Voice.registerVoice(unitSelVoice);\n    long newtime=System.currentTimeMillis() - time;\n    Log.i(Mary.LOG,\"Loading of voice \" + voiceName + \" took \"+ newtime+ \" milliseconds\");\n  }\n  Log.i(Mary.LOG,\"started.\");\n}\n", "docstring": "start up the waveform synthesizer . this must be called once before calling synthesize ( ) .", "partition": "test"}
{"idx": "2114", "code": "public int findStartOfColumn(int column){\n  if (column == mColumns)   return getSpaceUsed();\n  int currentColumn=0;\n  int currentCharIndex=0;\n  while (true) {\n    int newCharIndex=currentCharIndex;\n    char c=mText[newCharIndex++];\n    boolean isHigh=Character.isHighSurrogate(c);\n    int codePoint=isHigh ? Character.toCodePoint(c,mText[newCharIndex++]) : c;\n    int wcwidth=WcWidth.width(codePoint);\n    if (wcwidth > 0) {\n      currentColumn+=wcwidth;\n      if (currentColumn == column) {\n        while (newCharIndex < mSpaceUsed) {\n          if (Character.isHighSurrogate(mText[newCharIndex])) {\n            if (WcWidth.width(Character.toCodePoint(mText[newCharIndex],mText[newCharIndex + 1])) <= 0) {\n              newCharIndex+=2;\n            }\n else {\n              break;\n            }\n          }\n else           if (WcWidth.width(mText[newCharIndex]) <= 0) {\n            newCharIndex++;\n          }\n else {\n            break;\n          }\n        }\n        return newCharIndex;\n      }\n else       if (currentColumn > column) {\n        return currentCharIndex;\n      }\n    }\n    currentCharIndex=newCharIndex;\n  }\n}\n", "docstring": "note that the column may end of second half of wide character .", "partition": "test"}
{"idx": "2115", "code": "private TripSchedule rerouteTripSchedule(TripSchedule originalSchedule){\n  TripSchedule schedule=originalSchedule.clone();\n  schedule.arrivals=new int[newPatternLength];\n  schedule.departures=new int[newPatternLength];\n  int prevOutputDeparture=0;\n  for (int ss=0, ts=0; ts < newPatternLength; ss++, ts++) {\n    if ((ss == insertBeginIndex - 1) || (ss == 0 && insertBeginIndex == 0)) {\n      int hopTime=originalSchedule.arrivals[ss];\n      if (ss > 0)       hopTime-=originalSchedule.departures[ss - 1];\n      schedule.arrivals[ts]=prevOutputDeparture + hopTime;\n      schedule.departures[ts]=schedule.arrivals[ts] + dwellTimes[0];\n      prevOutputDeparture=schedule.departures[ts];\n      ts++;\n      for (int hop=0, dwell=1; dwell < dwellTimes.length; hop++, dwell++) {\n        schedule.arrivals[ts]=prevOutputDeparture + hopTimes[hop];\n        schedule.departures[ts]=schedule.arrivals[ts] + dwellTimes[dwell];\n        prevOutputDeparture=schedule.departures[ts];\n        ts++;\n      }\n      ss=insertEndIndex + 1;\n      if (ts == newPatternLength)       break;\n    }\n    int hopTime=originalSchedule.arrivals[ss];\n    if (ss > 0)     hopTime-=originalSchedule.departures[ss - 1];\n    schedule.arrivals[ts]=prevOutputDeparture + hopTime;\n    int dwellTime=originalSchedule.departures[ss] - originalSchedule.arrivals[ss];\n    schedule.departures[ts]=schedule.arrivals[ts] + dwellTime;\n    prevOutputDeparture=schedule.departures[ts];\n  }\n  int timeShift=originalSchedule.arrivals[originalFixedPointStopIndex] - schedule.arrivals[newFixedPointStopIndex];\n  for (int i=0; i < newPatternLength; i++) {\n    schedule.arrivals[i]+=timeShift;\n    schedule.departures[i]+=timeShift;\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Original arrivals:   {}\",originalSchedule.arrivals);\n    LOG.debug(\"Original departures: {}\",originalSchedule.departures);\n    LOG.debug(\"Modified arrivals:   {}\",schedule.arrivals);\n    LOG.debug(\"Modified departures: {}\",schedule.departures);\n  }\n  return schedule;\n}\n", "docstring": "todo calculate all arrivals and departures zero - based , and then shift them at the end to maintain fixed - point stop . the fixed - point stop should be different depending on whether we are splicing onto the beginning or end of the route .", "partition": "test"}
{"idx": "2116", "code": "public static Color decode(String color,Color defaultColor){\n  if (color == null) {\n    return defaultColor;\n  }\n  Color c=getNamedColor(color);\n  if (c == null) {\n    try {\n      c=Color.decode(color);\n    }\n catch (    NumberFormatException ex) {\n      return defaultColor;\n    }\n  }\n  return c;\n}\n", "docstring": "decodes an html color and turns it into a color object . supports some named colors and string formats that are supported by color . decode ( ) . if no color can be decoded , returns the defaultcolor specified by the caller .", "partition": "test"}
{"idx": "2117", "code": "public static LinkedList<MaryModule> modulesRequiredForProcessing(MaryDataType sourceType,MaryDataType targetType,Locale locale,Voice voice){\n  if (!registrationComplete)   throw new IllegalStateException(\"Cannot inquire about modules while registration is ongoing\");\n  if (sourceType == null)   throw new NullPointerException(\"Received null source type\");\n  if (targetType == null)   throw new NullPointerException(\"Received null target type\");\n  LinkedList<MaryDataType> seenTypes=new LinkedList<MaryDataType>();\n  seenTypes.add(sourceType);\n  return modulesRequiredForProcessing(sourceType,targetType,locale,voice,seenTypes);\n}\n", "docstring": "a method for determining the list of modules required to transform the given source data type into the requested target data type . if the voice given is not null , any preferred modules it may have are taken into account .", "partition": "test"}
{"idx": "2118", "code": "public double distance(Vector o){\n  return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));\n}\n", "docstring": "get the distance between this vector and another . the value of this method is not cached and uses a costly square - root function , so do not repeatedly call this method to get the vector \"'\" s magnitude . nan will be returned if the inner result of the sqrt ( ) function overflows , which will be caused if the distance is too long .", "partition": "test"}
{"idx": "2119", "code": "public static long calculateElapsedGC(){\n  long timeMillis=0;\n  for (  GarbageCollectorMXBean gcbean : gcbeans) {\n    timeMillis+=gcbean.getCollectionTime();\n  }\n  return timeMillis;\n}\n", "docstring": "ask each gc bean for its elapsed collection time", "partition": "test"}
{"idx": "2120", "code": "public void startObject(int numfields){\n  notNested();\n  if (vtable == null || vtable.length < numfields)   vtable=new int[numfields];\n  vtable_in_use=numfields;\n  Arrays.fill(vtable,0,vtable_in_use,0);\n  nested=true;\n  object_start=offset();\n}\n", "docstring": "start encoding a new object in the buffer . users will not usually need to call this directly . the ` flatbuffers ` compiler will generate helper methods that call this method internally . < p > for example , using the \" monster \" code found on the", "partition": "test"}
{"idx": "2121", "code": "private Map<String,String> produceStream(String topic){\n  List<ProducerRecord<String,String>> messages=new ArrayList<>(EVENT_CNT);\n  Map<String,String> keyValMap=new HashMap<>();\n  for (int evt=0; evt < EVENT_CNT; evt++) {\n    long runtime=System.currentTimeMillis();\n    String key=topic + \"_\" + String.valueOf(evt);\n    String msg=runtime + String.valueOf(evt);\n    messages.add(new ProducerRecord<>(topic,key,msg));\n    keyValMap.put(key,msg);\n  }\n  kafkaBroker.sendMessages(messages);\n  return keyValMap;\n}\n", "docstring": "sends messages to kafka .", "partition": "test"}
{"idx": "2122", "code": "public static String stringOfChar(char ch,int count){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < count; i++) {\n    buf.append(ch);\n  }\n  return buf.toString();\n}\n", "docstring": "returns a string of the given length consisting entirely of the given character", "partition": "test"}
{"idx": "2123", "code": "private void addConnectionView(Connection connection){\n  PlatformImpl.runAndWait(null);\n}\n", "docstring": "add a view for the given connection to the pipeline view . this method figures out the positioning and other details of adding the connection .", "partition": "test"}
{"idx": "2124", "code": "public static void trim(CharSequence aText,int[] aSpan){\n  int begin=aSpan[0];\n  int end=aSpan[1] - 1;\n  CharSequence data=aText;\n  while ((begin < (data.length() - 1)) && trimChar(data.charAt(begin))) {\n    begin++;\n  }\n  while ((end > 0) && trimChar(data.charAt(end))) {\n    end--;\n  }\n  end++;\n  aSpan[0]=begin;\n  aSpan[1]=end;\n}\n", "docstring": "remove trailing or leading whitespace from the annotation .", "partition": "test"}
{"idx": "2125", "code": "public void addScriptFinishedListener(ScriptExecutionListener l){\n  m_FinishedListeners.add(l);\n}\n", "docstring": "adds the given listener to its internal list .", "partition": "test"}
{"idx": "2126", "code": "public void test_getPutByteArray(){\n  final int size=200;\n  final IDataRecord buf=new FixedByteArrayBuffer(size);\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(size - 1));\n  final int pos=1;\n  for (int i=0; i < LIMIT; i++) {\n    final byte[] expected=new byte[r.nextInt(size - 2)];\n    r.nextBytes(expected);\n    buf.put(pos,expected);\n    assertEquals(0,BytesUtil.compareBytesWithLenAndOffset(0,expected.length,expected,pos,expected.length,buf.array()));\n    final byte[] actual=new byte[expected.length];\n    buf.get(pos,actual);\n    assertTrue(BytesUtil.bytesEqual(expected,actual));\n  }\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(pos + size - 2));\n}\n", "docstring": "test of the simple forms of the bulk get / put methods .", "partition": "test"}
{"idx": "2127", "code": "private T[] ensureCapacity(int minCapacity){\n  if (tmp.length < minCapacity) {\n    int newSize=minCapacity;\n    newSize|=newSize >> 1;\n    newSize|=newSize >> 2;\n    newSize|=newSize >> 4;\n    newSize|=newSize >> 8;\n    newSize|=newSize >> 16;\n    newSize++;\n    if (newSize < 0)     newSize=minCapacity;\n else     newSize=Math.min(newSize,a.length >>> 1);\n    T[] newArray=(T[])new Object[newSize];\n    tmp=newArray;\n  }\n  return tmp;\n}\n", "docstring": "ensures that the external array tmp has at least the specified number of elements , increasing its size if necessary . the size increases exponentially to ensure amortized linear time complexity .", "partition": "test"}
{"idx": "2128", "code": "public void CONT(int sessionNumber) throws Exception {\n  this.maxSessionNumber=Math.max(this.maxSessionNumber,sessionNumber);\n  testElements.add(new ContinuationElement(sessionNumber));\n}\n", "docstring": "adds a continuation . to allow one thread to be used for testing .", "partition": "test"}
{"idx": "2129", "code": "public static double calcRotationAngleInDegrees(PointF centerPt,PointF targetPt){\n  double theta=Math.atan2(targetPt.y - centerPt.y,targetPt.x - centerPt.x);\n  double angle=Math.toDegrees(theta);\n  if (angle < 0) {\n    angle+=360;\n  }\n  return angle;\n}\n", "docstring": "calculates the angle from centerpt to targetpt in degrees . the return should range from [ 0 , 360 ) , rotating clockwise , 0 and 360 degrees represents east , 90 degrees represents south , etc . . . < p / > assumes all points are in the same coordinate space . if they are not , you will need to call swingutilities . convertpointtoscreen or equivalent on all arguments before passing them to this function .", "partition": "test"}
{"idx": "2130", "code": "public int countIn(CharSequence sequence){\n  int count=0;\n  for (int i=0; i < sequence.length(); i++) {\n    if (matches(sequence.charAt(i))) {\n      count++;\n    }\n  }\n  return count;\n}\n", "docstring": "returns the number of matching characters found in a character sequence .", "partition": "test"}
{"idx": "2131", "code": "public DeltaCRLIndicatorExtension(int crlNum) throws IOException {\n  super(PKIXExtensions.DeltaCRLIndicator_Id,true,BigInteger.valueOf(crlNum),NAME,LABEL);\n}\n", "docstring": "creates a delta crl indicator extension with the integer value . the criticality is set to true .", "partition": "test"}
{"idx": "2132", "code": "static private double calcLogProb(int numAppear,double mu){\n  final double sigma=calcSigmaFromMu(mu);\n  final double logNumAppear=Math.log(numAppear);\n  final double overMu=Math.max(logNumAppear - mu,0.0);\n  final double res=-(1.0 / 2) * (overMu * overMu) / (sigma * sigma) - s_logSqrtTwoPi - Math.log(sigma);\n  assert (res <= 0);\n  return res;\n}\n", "docstring": "calculate the log probability given the message \"'\" s logarithm is normally distributed . note , here we take the natural logarithm of the normal distribution ( lognormal distribution ) which using log properties and rules turns into the equation whose value gets stored in res .", "partition": "test"}
{"idx": "2133", "code": "@Override public SoftwarePIDController withTolerance(double tolerance){\n  target=target.withTolerance(Math.abs(tolerance));\n  return this;\n}\n", "docstring": "sets the absolute tolerance for this controller .", "partition": "test"}
{"idx": "2134", "code": "protected final void dragDropFinished(final boolean success,final int operations,final int x,final int y){\n  DragSourceEvent event=new DragSourceDropEvent(getDragSourceContext(),operations & sourceActions,success,x,y);\n  EventDispatcher dispatcher=new EventDispatcher(DISPATCH_FINISH,event);\n  SunToolkit.invokeLaterOnAppContext(SunToolkit.targetToAppContext(getComponent()),dispatcher);\n  startSecondaryEventLoop();\n  setNativeContext(0);\n  dragImage=null;\n  dragImageOffset=null;\n}\n", "docstring": "upcall from native code via implemented class ( do )", "partition": "test"}
{"idx": "2135", "code": "protected static String extractSecretAccessKey(String s3uri){\n  return s3uri.substring(s3uri.indexOf(\':\',s3uri.indexOf(\"://\") + 1) + 1,s3uri.indexOf(\'@\'));\n}\n", "docstring": "extracts the secretaccesskey from the given uri", "partition": "test"}
{"idx": "2136", "code": "private void dial(String contactInformation,boolean makeTheCall,boolean usePhoneSpeaker){\n  if (contactInformation.equals(\"\")) {\n    String lastRecipient=RecipientCmd.getLastRecipientNumber();\n    String lastRecipientName=RecipientCmd.getLastRecipientName();\n    if (lastRecipient != null) {\n      doDial(lastRecipientName,lastRecipient,makeTheCall,usePhoneSpeaker);\n    }\n else {\n      send(\"error: last recipient not set\");\n    }\n  }\n else {\n    ResolvedContact resolvedContact=mContactsResolver.resolveContact(contactInformation,ContactsResolver.TYPE_ALL);\n    if (resolvedContact == null) {\n      send(R.string.chat_no_match_for,contactInformation);\n    }\n else     if (resolvedContact.isDistinct()) {\n      doDial(resolvedContact.getName(),resolvedContact.getNumber(),makeTheCall,usePhoneSpeaker);\n    }\n else {\n      askForMoreDetails(resolvedContact.getCandidates());\n    }\n  }\n}\n", "docstring": "dial the specified contact", "partition": "test"}
{"idx": "2137", "code": "public void addSafeClass(SootClass clz){\n  safeClasses.add(clz.getName());\n}\n", "docstring": "denote that all methods of a class are safe .", "partition": "test"}
{"idx": "2138", "code": "private boolean activeListHasRoom(){\n  int maxDownloads=1;\n  return mActiveList.size() < maxDownloads;\n}\n", "docstring": "check if there is room in the active list .", "partition": "test"}
{"idx": "2139", "code": "public boolean isRunning(){\n  return this.running;\n}\n", "docstring": "return whether the stop watch is currently running .", "partition": "test"}
{"idx": "2140", "code": "protected static Map<String,Step> parse(Class<? extends RSLPStemmerBase> clazz,String resource){\n  try {\n    InputStream is=clazz.getResourceAsStream(resource);\n    LineNumberReader r=new LineNumberReader(new InputStreamReader(is,StandardCharsets.UTF_8));\n    Map<String,Step> steps=new HashMap<>();\n    String step;\n    while ((step=readLine(r)) != null) {\n      Step s=parseStep(r,step);\n      steps.put(s.name,s);\n    }\n    r.close();\n    return steps;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "parse a resource file into an rslp stemmer description .", "partition": "test"}
{"idx": "2141", "code": "public String betToString(){\n  final StringBuilder sb=new StringBuilder();\n  sb.append(amount);\n  sb.append(\" \");\n  sb.append(itemName);\n  sb.append(\" on \");\n  sb.append(target);\n  return sb.toString();\n}\n", "docstring": "converts the bet into a string .", "partition": "test"}
{"idx": "2142", "code": "public void test_nonEmptyJournal() throws IOException, InterruptedException, ExecutionException {\n  final File out=File.createTempFile(getName(),Options.JNL);\n  try {\n    final Journal src=getStore(getProperties());\n    try {\n      if (!(src.getBufferStrategy() instanceof IHABufferStrategy)) {\n        return;\n      }\n      src.write(getRandomData(128));\n      src.commit();\n      try {\n        final ISnapshotFactory snapshotFactory=new MySnapshotFactory(getName(),false);\n        final Future<ISnapshotResult> f=src.snapshot(snapshotFactory);\n        final ISnapshotResult snapshotResult=f.get();\n        final File snapshotFile=snapshotResult.getFile();\n        try {\n          final Journal tmp=openSnapshot(snapshotResult);\n          assertEquals(src.getRootBlockView(),tmp.getRootBlockView());\n          tmp.destroy();\n        }\n  finally {\n          if (snapshotFile.exists()) {\n            snapshotFile.delete();\n          }\n        }\n      }\n catch (      IllegalArgumentException ex) {\n        log.info(\"Ignoring expected exception: \" + ex);\n      }\n    }\n  finally {\n      src.destroy();\n    }\n  }\n  finally {\n    out.delete();\n  }\n}\n", "docstring": "verifies exception if there are no commits on the journal ( the lastcommittime will be zero which does not identify a valid commit point ) .", "partition": "test"}
{"idx": "2143", "code": "private boolean checkMatchIp(Map<String,Object> rows){\n  boolean matchEther=false;\n  String val=(String)rows.get(StaticFlowEntryPusher.COLUMN_DL_TYPE);\n  if (val != null) {\n    int type=0;\n    if (val.startsWith(\"0x\")) {\n      type=Integer.parseInt(val.substring(2),16);\n    }\n else {\n      try {\n        type=Integer.parseInt(val);\n      }\n catch (      NumberFormatException e) {\n      }\n    }\n    if (type == 2048)     matchEther=true;\n  }\n  if ((rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_DST) || rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_SRC) || rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_PROTO)|| rows.containsKey(StaticFlowEntryPusher.COLUMN_NW_TOS)) && (matchEther == false))   return false;\n  return true;\n}\n", "docstring": "checks to see if the user matches ip information without checking for the correct ether - type ( 2048 ) .", "partition": "test"}
{"idx": "2144", "code": "public static double powQuick(double value,double power){\n  if (USE_JDK_MATH) {\n    return STRICT_MATH ? StrictMath.pow(value,power) : Math.pow(value,power);\n  }\n  return FastMath.exp(power * FastMath.logQuick(value));\n}\n", "docstring": "quick pow , with a max relative error of about 3 . 5e - 2 for | a ^ b | & lt ; 1e10 , of about 0 . 17 for | a ^ b | & lt ; 1e50 , and worse accuracy above .", "partition": "test"}
{"idx": "2145", "code": "private String classToEntryPath(Class<?> clazz){\n  String name=\"\";\n  Class<?> parent;\n  while ((parent=clazz.getEnclosingClass()) != null) {\n    name=\"$\" + clazz.getSimpleName() + name;\n    clazz=parent;\n  }\n  return classNameToEntryPath(clazz.getCanonicalName() + name);\n}\n", "docstring": "utility method to get the jar entry path from a class name . e . g . it returns someting like \" com / foo / outerclass $ innerclass1 $ innerclass2 . class \"", "partition": "test"}
{"idx": "2146", "code": "public static String write(POSMikheevCounter counter){\n  return POSBaseLineCounter.write(counter);\n}\n", "docstring": "write an instance of posmikheevcounter class to json format", "partition": "test"}
{"idx": "2147", "code": "private Map<String,AnnotationMirror> annosInPackage(PackageElement packageElement){\n  return createImportedAnnotationsMap(ElementFilter.typesIn(packageElement.getEnclosedElements()));\n}\n", "docstring": "all annotations defined in the package . keys are simple names .", "partition": "test"}
{"idx": "2148", "code": "public OsmElement pasteFrom(){\n  List<Way> ways=storage.getWays();\n  List<Node> nodes=storage.getNodes();\n  if (mode == Mode.CUT) {\n    reset();\n    if (ways != null && ways.size() == 1) {\n      Way w=ways.get(0);\n      w.setState(savedState);\n      for (      Node nd : w.getNodes()) {\n        Log.d(\"PasteFrom\",\"Restoring state for \" + nd.getOsmId());\n        nd.setState(savedNdState.get(nd));\n      }\n      return w;\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      Node n=nodes.get(0);\n      n.setState(savedState);\n      return n;\n    }\n  }\n else {\n    if (ways != null && ways.size() == 1) {\n      return ways.get(0);\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      return nodes.get(0);\n    }\n  }\n  return null;\n}\n", "docstring": "returns whatever is in the clipboard", "partition": "test"}
{"idx": "2149", "code": "public final void updateCursor(){\n  updatePending.set(false);\n  updateCursorImpl();\n}\n", "docstring": "sets the cursor to correspond the component currently under mouse . this method should not be executed on the toolkit thread as it calls to user code ( e . g . container . findcomponentat ) .", "partition": "test"}
{"idx": "2150", "code": "public static boolean isMiddleMouseButton(MouseEvent anEvent){\n  return ((anEvent.getModifiersEx() & InputEvent.BUTTON2_DOWN_MASK) != 0 || anEvent.getButton() == MouseEvent.BUTTON2);\n}\n", "docstring": "returns true if the mouse event specifies the middle mouse button .", "partition": "test"}
{"idx": "2151", "code": "public void addSuccessMessage(final String successMessage){\n  successMessageList.add(successMessage);\n}\n", "docstring": "adds a success message into the list .", "partition": "test"}
{"idx": "2152", "code": "private void startStoppedChanged(){\n  clock.setStartStopped(startStoppedCheckBox.isSelected());\n  changed=true;\n}\n", "docstring": "method to handle start stopped check box change", "partition": "test"}
{"idx": "2153", "code": "public void close() throws IOException {\n  try {\n    Debug.message(\"binaryfile\",\"StreamInputReader.close()\");\n    if (Debug.debugging(\"connection_problems\")) {\n      Thread.sleep(1000);\n    }\n    if (inputStream != null)     inputStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  inputStream=null;\n}\n", "docstring": "closes the underlying file", "partition": "test"}
{"idx": "2154", "code": "private void readBinary(final LittleEndianDataInputStream dis) throws IOException {\n  RajLog.i(\"StlPaser: Reading Binary\");\n  dis.skip(80);\n  int facetCount=dis.readInt();\n  float[] verticesArr=new float[facetCount * 9];\n  float[] normalsArr=new float[facetCount * 9];\n  int[] indicesArr=new int[facetCount * 3];\n  float[] tempNorms=new float[3];\n  int vertPos=0, normPos=0;\n  for (int i=0; i < indicesArr.length; i++)   indicesArr[i]=i;\n  while (dis.available() > 0) {\n    for (int j=0; j < 3; j++) {\n      tempNorms[j]=dis.readFloat();\n      if (Float.isNaN(tempNorms[j]) || Float.isInfinite(tempNorms[j])) {\n        RajLog.w(\"STL contains bad normals of NaN or Infinite!\");\n        tempNorms[0]=0;\n        tempNorms[1]=0;\n        tempNorms[2]=0;\n        break;\n      }\n    }\n    for (int j=0; j < 3; j++) {\n      normalsArr[normPos++]=tempNorms[0];\n      normalsArr[normPos++]=tempNorms[1];\n      normalsArr[normPos++]=tempNorms[2];\n    }\n    for (int j=0; j < 9; j++)     verticesArr[vertPos++]=dis.readFloat();\n    dis.skip(2);\n  }\n  mRootObject.setData(verticesArr,normalsArr,null,null,indicesArr,false);\n}\n", "docstring": "read stream as binary stl . this is significantly faster than ascii parsing . additionally binary files are much more compressed allowing smaller file sizes for larger models compared to ascii .", "partition": "test"}
{"idx": "2155", "code": "public static void assertSpecificLang(String specificLang) throws XMPException {\n  if (specificLang == null || specificLang.length() == 0) {\n    throw new XMPException(\"Empty specific language\",XMPError.BADPARAM);\n  }\n}\n", "docstring": "asserts that a specific language is set .", "partition": "test"}
{"idx": "2156", "code": "public int onBlockExploded(){\n  return (int)(fuseTime / 2 + Math.random() * fuseTime / 4);\n}\n", "docstring": "called when the block for of this explosive is destroy by an explosion", "partition": "test"}
{"idx": "2157", "code": "@Override public boolean hasQueuedReaderThreads(){\n  return readerLock.hasQueuedThreads();\n}\n", "docstring": "returns whether there are threads waiting for read access to the guacamole instruction stream .", "partition": "test"}
{"idx": "2158", "code": "public long inactiveTimeMillis(){\n  return System.currentTimeMillis() - lastTimeMillis;\n}\n", "docstring": "returns the number of milliseconds this session has been inactive .", "partition": "test"}
{"idx": "2159", "code": "public void addDefinition(ICOSDefinition cosDef) throws UMSException {\n  if (!(cosDef instanceof DirectCOSDefinition)) {\n    String msg=i18n.getString(IUMSConstants.INVALID_COSDEFINITION);\n    throw new UMSException(msg);\n  }\n  String[] cosAttributes=cosDef.getCOSAttributes();\n  AbstractCollection aList=(AbstractCollection)Arrays.asList(ICOSDefinition.qualifiers);\n  for (int i=0; i < cosAttributes.length; i++) {\n    String cosAttribute=null;\n    String qualifier=null;\n    StringTokenizer st=new StringTokenizer(cosAttributes[i]);\n    if (st.hasMoreTokens()) {\n      cosAttribute=st.nextToken();\n    }\n    if (cosAttribute == null) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n    if (st.hasMoreTokens())     qualifier=st.nextToken();\n    if (qualifier == null) {\n      qualifier=ICOSDefinition.qualifiers[ICOSDefinition.DEFAULT];\n      cosDef.removeCOSAttribute(cosAttribute);\n      cosDef.addCOSAttribute(cosAttribute,ICOSDefinition.DEFAULT);\n    }\n    if (!aList.contains(qualifier)) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n  }\n  PersistentObject po=(PersistentObject)cosDef;\n  _parentObject.addChild(po);\n}\n", "docstring": "this method adds a cos definition to the persistent store . the definition is added under the specified \" guid \" parameter .", "partition": "test"}
{"idx": "2160", "code": "public static SourceDataQuality fromXML(Element domElement){\n  NodeList fields=domElement.getChildNodes();\n  int fieldsCount=fields.getLength();\n  String fieldName;\n  String fieldValueString;\n  Node fieldNode;\n  SourceDataQuality result=new SourceDataQuality();\n  for (int i=0; i != fieldsCount; i++) {\n    fieldNode=fields.item(i);\n    if (fieldNode.getNodeType() == Node.ELEMENT_NODE) {\n      fieldName=fieldNode.getNodeName();\n      Node fieldValueNode=fieldNode.getFirstChild();\n      if (fieldValueNode != null) {\n        fieldValueString=fieldValueNode.getNodeValue();\n      }\n else {\n        fieldValueString=\"\";\n      }\n      if (fieldName.equals(XML_ELEMENT_QUALITY_CODE)) {\n        result.qualityCode=Short.parseShort(fieldValueString);\n      }\n else       if (fieldName.equals(XML_ELEMENT_QUALITY_DESC)) {\n        result.description=fieldValueString;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "create a sourcedataquality object from its xml representation . the format of the xml required is determined by the output of the toxml ( ) method .", "partition": "test"}
{"idx": "2161", "code": "QName toQName(Class<?> outputClass){\n  String localPart;\n  String namespaceUri;\n  if (outputClass.isAnnotationPresent(XmlRootElement.class)) {\n    XmlRootElement annotation=outputClass.getAnnotation(XmlRootElement.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else   if (outputClass.isAnnotationPresent(XmlType.class)) {\n    XmlType annotation=outputClass.getAnnotation(XmlType.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else {\n    throw new IllegalArgumentException(\"Outputclass [\" + outputClass + \"] is \"+ \"neither annotated with @XmlRootElement nor @XmlType\");\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {\n    localPart=ClassUtils.getShortNameAsProperty(outputClass);\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {\n    Package outputClassPackage=outputClass.getPackage();\n    if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {\n      XmlSchema annotation=outputClassPackage.getAnnotation(XmlSchema.class);\n      namespaceUri=annotation.namespace();\n    }\n else {\n      namespaceUri=XMLConstants.NULL_NS_URI;\n    }\n  }\n  return new QName(namespaceUri,localPart);\n}\n", "docstring": "returns the qualified name for the given class , according to the mapping rules in the jaxb specification .", "partition": "test"}
{"idx": "2162", "code": "private static String generateJWT(String secret,String jwtID,String iss,Integer ttl,Map<String,String> claims) throws HmacException {\n  try {\n    return signJWT(secret,jwtID,ttl,iss,claims);\n  }\n catch (  JOSEException e) {\n    e.printStackTrace();\n    throw new HmacException(\"Cannot generate JWT\",e);\n  }\n}\n", "docstring": "generate a new signed jwt", "partition": "test"}
{"idx": "2163", "code": "public void exportSymbols(String[] exportNames,Symbol[] symbols){\n  if (exportedSymbols == null) {\n    exportedSymbols=new ArrayList();\n  }\n  for (int i=0; i < exportNames.length && i < symbols.length; i++) {\n    exportedSymbols.add(new ExportedSymbol(symbols[i],exportNames[i]));\n  }\n}\n", "docstring": "export a number of symbols with the given names so that other movies can import and use them . flash version 5 only .", "partition": "test"}
{"idx": "2164", "code": "@Override public synchronized void addDataSourceListener(DataSourceListener dsl){\n  m_dataSourceListeners.addElement(dsl);\n  if (m_format != null) {\n    DataSetEvent e=new DataSetEvent(this,m_format);\n    dsl.acceptDataSet(e);\n  }\n}\n", "docstring": "add a datasource listener", "partition": "test"}
{"idx": "2165", "code": "public static AnnotationMirror findEffectiveAnnotationInHierarchy(final QualifierHierarchy qualifierHierarchy,final AnnotatedTypeMirror toSearch,final AnnotationMirror top){\n  return findEffectiveAnnotationInHierarchy(qualifierHierarchy,toSearch,top,false);\n}\n", "docstring": "when comparing types against the bounds of a type variable , we may encounter other type variables , wildcards , and intersections in those bounds . this method traverses the bounds until it finds a concrete type from which it can pull an annotation .", "partition": "test"}
{"idx": "2166", "code": "public boolean toFail(){\n  LifecycleState state;\nsynchronized (this) {\n    state=_state;\n    if (state.isAfterDestroying()) {\n      return false;\n    }\n    _state=FAILED;\n    _lastChangeTime=CurrentTime.currentTime();\n  }\n  if (_log != null && _log.isLoggable(_level))   _log.log(_level,\"fail \" + _name);\n  notifyListeners(state,FAILED);\n  _failCount++;\n  return true;\n}\n", "docstring": "changes to the failed state .", "partition": "test"}
{"idx": "2167", "code": "private static void read(InputStream in,byte[] buf,int pos,int n) throws IOException {\n  int read=0;\n  int res=0;\n  while (read < n) {\n    res=in.read(buf,read + pos,n - read);\n    if (res > 0) {\n      read+=res;\n    }\n else {\n      throw new IOException(\"Read failed, got \" + read + \" of \"+ n);\n    }\n  }\n}\n", "docstring": "read at least the specified amount of bytes , and place them in the input buffer .", "partition": "test"}
{"idx": "2168", "code": "public double evaluate(VectorInstance x,VectorInstance y) throws Exception {\n  VectorInstance diff=x.subtract(y);\n  double result=-m_gamma * diff.dotProduct(diff);\n  return Math.exp(result);\n}\n", "docstring": "compute the result of the kernel evaluation on the supplied vectors", "partition": "test"}
{"idx": "2169", "code": "void cancelIncludedOnly(){\n  if (!_showAllInput) {\n    _inputAllButton.doClick();\n  }\n  if (!_showAllOutput) {\n    _outputAllButton.doClick();\n  }\n  if (!_showAllAlign) {\n    _alignAllButton.doClick();\n  }\n}\n", "docstring": "cancels included only option", "partition": "test"}
{"idx": "2170", "code": "List<Entry> killAll(boolean rootIncluded){\n  List<Entry> killed=new ArrayList<>(rootIncluded ? entries.size() : entries.size() - 1);\n  Entry entry;\n  for (int i=entries.size() - 1; i > (rootIncluded ? -1 : 0); i--) {\n    entry=entries.get(i);\n    if (entry.dead)     continue;\n    entry.dead=true;\n    if (i != 0) {\n      killed.add(entry);\n    }\n  }\n  return killed;\n}\n", "docstring": "kill all , including root or not the returned entries don \"'\" t include the root entry though", "partition": "test"}
{"idx": "2171", "code": "public static String checkIndexHeaderSuffix(DataInput in,String expectedSuffix) throws IOException {\n  int suffixLength=in.readByte() & 0xFF;\n  byte suffixBytes[]=new byte[suffixLength];\n  in.readBytes(suffixBytes,0,suffixBytes.length);\n  String suffix=new String(suffixBytes,0,suffixBytes.length,StandardCharsets.UTF_8);\n  if (!suffix.equals(expectedSuffix)) {\n    throw new CorruptIndexException(\"file mismatch, expected suffix=\" + expectedSuffix + \", got=\"+ suffix,in);\n  }\n  return suffix;\n}\n", "docstring": "expert : just reads and verifies the suffix of an index header", "partition": "test"}
{"idx": "2172", "code": "public static String parseDiskString(String input){\n  String delims=\"[ ]+\";\n  String[] tokens=input.split(delims);\n  return tokens[0];\n}\n", "docstring": "get the disk name out from the input string .", "partition": "test"}
{"idx": "2173", "code": "protected void drawCloud(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  GeneralPath path=new GeneralPath();\n  path.moveTo((float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.curveTo((float)(x + 0.05 * w),(float)(y + 0.25 * h),(float)x,(float)(y + 0.5 * h),(float)(x + 0.16 * w),(float)(y + 0.55 * h));\n  path.curveTo((float)x,(float)(y + 0.66 * h),(float)(x + 0.18 * w),(float)(y + 0.9 * h),(float)(x + 0.31 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + 0.4 * w),(float)(y + h),(float)(x + 0.7 * w),(float)(y + h),(float)(x + 0.8 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.8 * h),(float)(x + w),(float)(y + 0.6 * h),(float)(x + 0.875 * w),(float)(y + 0.5 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.3 * h),(float)(x + 0.8 * w),(float)(y + 0.1 * h),(float)(x + 0.625 * w),(float)(y + 0.2 * h));\n  path.curveTo((float)(x + 0.5 * w),(float)(y + 0.05 * h),(float)(x + 0.3 * w),(float)(y + 0.05 * h),(float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.closePath();\n  drawPath(path,fillColor,fillPaint,penColor,shadow);\n}\n", "docstring": "draws a cloud shape for the given parameters .", "partition": "test"}
{"idx": "2174", "code": "private static boolean isTrusted(Object obj,TrustVerifier.Context ctx) throws RemoteException {\n  Object saved=state.get();\n  try {\n    state.set(obj);\n    return ctx.isTrustedObject(obj);\n  }\n  finally {\n    state.set(saved);\n  }\n}\n", "docstring": "returns result of calling ctx . istrustedobject ( obj ) with thread - local state set to obj .", "partition": "test"}
{"idx": "2175", "code": "public static PersistentSearchRequestControl newControl(final boolean isCritical,final boolean changesOnly,final boolean returnECs,final PersistentSearchChangeType... changeTypes){\n  Reject.ifNull((Object)changeTypes);\n  return newControl(isCritical,changesOnly,returnECs,Arrays.asList(changeTypes));\n}\n", "docstring": "creates a new persistent search request control .", "partition": "test"}
{"idx": "2176", "code": "private void connectEqualized(SynapseGroup synapseGroup){\n  currentOrderingIndices=new int[sourceNeurons.length];\n  int numConnectsPerSrc;\n  int expectedNumSyns;\n  if (synapseGroup.isRecurrent() && !selfConnectionAllowed) {\n    numConnectsPerSrc=(int)(connectionDensity * (sourceNeurons.length - 1));\n  }\n else {\n    numConnectsPerSrc=(int)(connectionDensity * targetNeurons.length);\n  }\n  expectedNumSyns=numConnectsPerSrc * sourceNeurons.length;\n  synapseGroup.preAllocateSynapses(expectedNumSyns);\n  for (int i=0, n=sourceNeurons.length; i < n; i++) {\n    currentOrderingIndices[i]=numConnectsPerSrc;\n    Neuron src=sourceNeurons[i];\n    Neuron tar;\n    for (int j=0; j < numConnectsPerSrc; j++) {\n      tar=targetNeurons[sparseOrdering[i][j]];\n      Synapse s=new Synapse(src,tar);\n      synapseGroup.addNewSynapse(s);\n    }\n  }\n}\n", "docstring": "populates the synapse group with synapses by making individual synaptic connections between the neurons in the synapse group \"'\" s source and target groups . these synapses are initialized with default attributes and zero strength . each source neuron will have exactly the same number of efferent synapses . this number being whichever satisfies the constraints given by the sparsity and whether or not the synapse group is recurrent and self connections are allowed .", "partition": "test"}
{"idx": "2177", "code": "public static Number multiply(Character left,Character right){\n  return multiply(Integer.valueOf(left),right);\n}\n", "docstring": "multiply two characters . the ordinal values of the characters are used in the multiplication ( the ordinal value is the unicode value which for simple character sets is the ascii value ) .", "partition": "test"}
{"idx": "2178", "code": "public static String normalize(final CharSequence self){\n  final String s=self.toString();\n  int nx=s.indexOf('\\r');\n  if (nx < 0) {\n    return s;\n  }\n  final int len=s.length();\n  final StringBuilder sb=new StringBuilder(len);\n  int i=0;\n  do {\n    sb.append(s,i,nx);\n    sb.append('\\n');\n    if ((i=nx + 1) >= len)     break;\n    if (s.charAt(i) == '\\n') {\n      if (++i >= len)       break;\n    }\n    nx=s.indexOf('\\r',i);\n  }\n while (nx > 0);\n  sb.append(s,i,len);\n  return sb.toString();\n}\n", "docstring": "return a string with linefeeds and carriage returns normalized to linefeeds .", "partition": "test"}
{"idx": "2179", "code": "public void addZoneChangeListener(ZoneChangeListener listener){\n  zoneChangeListeners.add(listener);\n}\n", "docstring": "add a listener to be called when the player changes zone .", "partition": "test"}
{"idx": "2180", "code": "public void write(final int b) throws IOException {\n  if (m_store == null) {\n    throw new IllegalStateException(ERR_NO_STORE);\n  }\n  if (m_isSaved) {\n    throw new IllegalStateException(ERR_ALREADY_SAVED);\n  }\n  if (m_count == m_blobThreshold && !m_writingHdr) {\n    if (m_blobHeader == null) {\n      m_blobHeader=new ArrayList<Integer>();\n    }\n    final int curAddr=(int)m_store.alloc(m_buf,m_count,m_context);\n    m_blobHeader.add(curAddr);\n    m_count=0;\n  }\n  m_buf[m_count++]=(byte)b;\n  m_bytesWritten++;\n}\n", "docstring": "write a single byte this is the one place where the blob threshold is handled and its done one byte at a time so should be easy enough , we no longer store continuation addresses , instead we allocate blob allocations via a blob header block .", "partition": "test"}
{"idx": "2181", "code": "public StartListener(Object resource){\n  _resource=resource;\n}\n", "docstring": "creates the new start listener .", "partition": "test"}
{"idx": "2182", "code": "public List<T> asFlatList(){\n  List<T> list=new ArrayList<T>();\n  for (int i=0; i < getRowCount(); i++) {\n    for (int j=0; j < getColumnCount(); j++) {\n      list.add(getLogicalValueAt(i,j));\n    }\n  }\n  return list;\n}\n", "docstring": "returns the contents of the table as a flat list .", "partition": "test"}
{"idx": "2183", "code": "public void recordTimestamp(){\n  long curTimestamp=System.currentTimeMillis();\n  if (usedFields > 0) {\n    long diff=curTimestamp - lastValue;\n    if (usedFields == diffs.length) {\n      long removedValue=diffs[curPosition];\n      diffs[curPosition]=diff;\n      calculateNewAverage(removedValue,diff,false);\n      shiftEnd();\n    }\n else {\n      calculateNewAverage(0,diff,true);\n      diffs[curPosition]=diff;\n      shiftEnd();\n    }\n  }\n else   if (lastValue != -1) {\n    long diff=curTimestamp - lastValue;\n    currentAverage=0;\n    diffs[curPosition]=diff;\n    calculateNewAverage(0,diff,true);\n    shiftEnd();\n  }\n  lastValue=curTimestamp;\n}\n", "docstring": "adds a value and calculates the new average of differences between the values within the window size provided at creation .", "partition": "test"}
{"idx": "2184", "code": "@AfterMethod public void tearDown() throws Exception {\n  Throwable t=threadFailure.getAndSet(null);\n  if (t != null) {\n    if (t instanceof Error)     throw (Error)t;\n else     if (t instanceof RuntimeException)     throw (RuntimeException)t;\n else     if (t instanceof Exception)     throw (Exception)t;\n else {\n      AssertionFailedError afe=new AssertionFailedError(t.toString());\n      afe.initCause(t);\n      throw afe;\n    }\n  }\n  if (Thread.interrupted())   tearDownFail(\"interrupt status set in main thread\");\n  checkForkJoinPoolThreadLeaks();\n}\n", "docstring": "extra checks that get done for all test cases . triggers test case failure if any thread assertions have failed , by rethrowing , in the test harness thread , any exception recorded earlier by threadrecordfailure . triggers test case failure if interrupt status is set in the main thread .", "partition": "test"}
{"idx": "2185", "code": "protected double defaultMaxRadius(){\n  return Math.sqrt(2.0);\n}\n", "docstring": "returns the default max radius", "partition": "test"}
{"idx": "2186", "code": "public char[] toCharArray(){\n  char[] newValue=new char[count];\n  System.arraycopy(buf,0,newValue,0,count);\n  return newValue;\n}\n", "docstring": "returns a copy of the input data .", "partition": "test"}
{"idx": "2187", "code": "public void insert(Component component,int index){\n  if (index < 0) {\n    throw new IllegalArgumentException(\"index less than zero.\");\n  }\n  int nitems=getComponentCount();\n  Vector<Component> tempItems=new Vector<Component>();\n  for (int i=index; i < nitems; i++) {\n    tempItems.addElement(getComponent(index));\n    remove(index);\n  }\n  add(component);\n  for (  Component tempItem : tempItems) {\n    add(tempItem);\n  }\n}\n", "docstring": "inserts the specified component into the menu at a given position .", "partition": "test"}
{"idx": "2188", "code": "public static List<String> unescape(String source,char escapeChar,char[] specialCharacters,char splitCharacter,int splitLimit){\n  List<String> result=new LinkedList<>();\n  StringBuilder b=new StringBuilder();\n  boolean readEscape=false;\n  int indexCount=-1;\n  for (  char c : source.toCharArray()) {\n    indexCount++;\n    if (readEscape) {\n      boolean found=false;\n      if (c == splitCharacter) {\n        found=true;\n        b.append(c);\n      }\n else       if (c == escapeChar) {\n        found=true;\n        b.append(c);\n      }\n else {\n        for (        char s : specialCharacters) {\n          if (s == c) {\n            found=true;\n            b.append(c);\n            break;\n          }\n        }\n      }\n      if (!found) {\n        throw new IllegalArgumentException(\"String \'\" + source + \"\' contains illegal escaped character \'\"+ c+ \"\'.\");\n      }\n      readEscape=false;\n    }\n else     if (c == escapeChar) {\n      readEscape=true;\n    }\n else     if (c == splitCharacter) {\n      readEscape=false;\n      result.add(b.toString());\n      if (splitLimit != -1) {\n        if (result.size() == splitLimit - 1) {\n          result.add(source.substring(indexCount + 1));\n          return result;\n        }\n      }\n      b=new StringBuilder();\n    }\n else {\n      readEscape=false;\n      b.append(c);\n    }\n  }\n  result.add(b.toString());\n  return result;\n}\n", "docstring": "splits the string at every split character unless escaped . if the split limit is not - 1 , at most so many tokens will be returned . no more escaping is performed in the last token !", "partition": "test"}
{"idx": "2189", "code": "@Override public String append(String path,InputStream is) throws MalformedURLException, IOException, AuthenticationException {\n  String resp=null;\n  ensureValidToken();\n  String spec=MessageFormat.format(\"/webhdfs/v1/{0}?op=APPEND&user.name={1}\",URLUtil.encodePath(path),this.principal);\n  String redirectUrl=null;\n  HttpURLConnection conn=authenticatedURL.openConnection(new URL(new URL(httpfsUrl),spec),token);\n  conn.setRequestMethod(\"POST\");\n  conn.setInstanceFollowRedirects(false);\n  conn.connect();\n  logger.info(\"Location:\" + conn.getHeaderField(\"Location\"));\n  resp=result(conn,true);\n  if (conn.getResponseCode() == 307)   redirectUrl=conn.getHeaderField(\"Location\");\n  conn.disconnect();\n  if (redirectUrl != null) {\n    conn=authenticatedURL.openConnection(new URL(redirectUrl),token);\n    conn.setRequestMethod(\"POST\");\n    conn.setDoOutput(true);\n    conn.setDoInput(true);\n    conn.setUseCaches(false);\n    conn.setRequestProperty(\"Content-Type\",\"application/octet-stream\");\n    final int _SIZE=is.available();\n    conn.setRequestProperty(\"Content-Length\",\"\" + _SIZE);\n    conn.setFixedLengthStreamingMode(_SIZE);\n    conn.connect();\n    OutputStream os=conn.getOutputStream();\n    copy(is,os);\n    is.close();\n    os.close();\n    resp=result(conn,true);\n    conn.disconnect();\n  }\n  return resp;\n}\n", "docstring": "curl - i - x post \" http : / / < host > : < port > / webhdfs / v1 / < path > ? op = append [ & buffersize = < int > ", "partition": "test"}
{"idx": "2190", "code": "public EconomyConcurrentHashMap(Map<? extends K,? extends V> m,IHashEntryHandler<K,V> handler){\n  this(Math.max((int)(m.size() / DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY),DEFAULT_LOAD_FACTOR,DEFAULT_CONCURRENCY_LEVEL,handler);\n  putAll(m);\n}\n", "docstring": "creates a new map with the same mappings as the given map . the map is created with a capacity of 1 . 5 times the number of mappings in the given map or 16 ( whichever is greater ) , and a default load factor ( 0 . 75 ) and concurrencylevel ( 16 ) .", "partition": "test"}
{"idx": "2191", "code": "void addRule(String[] selector,AttributeSet declaration,boolean isLinked){\n  int n=selector.length;\n  StringBuilder sb=new StringBuilder();\n  sb.append(selector[0]);\n  for (int counter=1; counter < n; counter++) {\n    sb.append(' ');\n    sb.append(selector[counter]);\n  }\n  String selectorName=sb.toString();\n  Style rule=getStyle(selectorName);\n  if (rule == null) {\n    Style altRule=addStyle(selectorName,null);\nsynchronized (this) {\n      SelectorMapping mapping=getRootSelectorMapping();\n      for (int i=n - 1; i >= 0; i--) {\n        mapping=mapping.getChildSelectorMapping(selector[i],true);\n      }\n      rule=mapping.getStyle();\n      if (rule == null) {\n        rule=altRule;\n        mapping.setStyle(rule);\n        refreshResolvedRules(selectorName,selector,rule,mapping.getSpecificity());\n      }\n    }\n  }\n  if (isLinked) {\n    rule=getLinkedStyle(rule);\n  }\n  rule.addAttributes(declaration);\n}\n", "docstring": "adds a rule into the stylesheet .", "partition": "test"}
{"idx": "2192", "code": "public Builder appendReadData(byte[] data){\n  Assertions.checkState(data != null && data.length > 0);\n  segments.add(new Segment(data,null));\n  return this;\n}\n", "docstring": "appends to the underlying data .", "partition": "test"}
{"idx": "2193", "code": "private boolean isLatestDssKeystore(TSLParserResult parseResult){\n  List<String> englishSchemeInformationURIs=parseResult.getEnglishSchemeInformationURIs();\n  return englishSchemeInformationURIs.contains(ojUrl);\n}\n", "docstring": "this method checks if the oj url is still correct . if not , the dss keystore is outdated .", "partition": "test"}
{"idx": "2194", "code": "public LayerGraphicWarehouseSupport(){\n  initDrawingAttributes();\n  graphics=new OMGraphicList();\n  graphics.setTraverseMode(OMGraphicList.LAST_ADDED_ON_TOP);\n}\n", "docstring": "construct an object , initializes graphiclist", "partition": "test"}
{"idx": "2195", "code": "public boolean matchesNamingConvension(){\n  return packageName.matches(JAVA_PACKAGE_CONVENSION);\n}\n", "docstring": "check whether the package name match standard java package name conventions .", "partition": "test"}
{"idx": "2196", "code": "void rememberFactory(String host,RMISocketFactory factory){\nsynchronized (successTable) {\n    while (hostList.size() >= MaxRememberedHosts) {\n      successTable.remove(hostList.elementAt(0));\n      hostList.removeElementAt(0);\n    }\n    hostList.addElement(host);\n    successTable.put(host,factory);\n  }\n}\n", "docstring": "remember a successful factory for connecting to host . currently , excess hosts are removed from the remembered list using a least recently created strategy .", "partition": "test"}
{"idx": "2197", "code": "private Map.Entry<K,V> doRemoveFirstEntry(){\n  for (Node<K,V> b, n; ; ) {\n    if ((n=(b=head.node).next) == null)     return null;\n    Node<K,V> f=n.next;\n    if (n != b.next)     continue;\n    Object v=n.value;\n    if (v == null) {\n      n.helpDelete(b,f);\n      continue;\n    }\n    if (!n.casValue(v,null))     continue;\n    if (!n.appendMarker(f) || !b.casNext(n,f))     findFirst();\n    clearIndexToFirst();\n    @SuppressWarnings(\"unchecked\") V vv=(V)v;\n    return new AbstractMap.SimpleImmutableEntry<K,V>(n.key,vv);\n  }\n}\n", "docstring": "removes first entry ; returns its snapshot .", "partition": "test"}
{"idx": "2198", "code": "public ComputeTaskCancelledException(Throwable cause){\n  this(cause.getMessage(),cause);\n}\n", "docstring": "creates new task cancellation exception given throwable as a cause and source of error message .", "partition": "test"}
{"idx": "2199", "code": "public static int normalize(char[] src,int srcStart,int srcLimit,char[] dest,int destStart,int destLimit,Mode mode,int options){\n  int length=mode.normalize(src,srcStart,srcLimit,dest,destStart,destLimit,options);\n  if (length <= (destLimit - destStart)) {\n    return length;\n  }\n else {\n    throw new IndexOutOfBoundsException(Integer.toString(length));\n  }\n}\n", "docstring": "normalize a string . the string will be normalized according the the specified normalization mode and options .", "partition": "test"}
{"idx": "2200", "code": "private void removeObsoleteElements(List<String> names,Map<String,View> sharedElements,List<String> elementsToRemove){\n  if (elementsToRemove.size() > 0) {\n    names.removeAll(elementsToRemove);\n    for (    String elementToRemove : elementsToRemove) {\n      sharedElements.remove(elementToRemove);\n    }\n  }\n}\n", "docstring": "removes obsolete elements from names and shared elements .", "partition": "test"}
{"idx": "2201", "code": "public void removeAction(NetworkUpdateAction action){\n  actionList.remove(action);\n  for (  UpdateManagerListener listener : listeners) {\n    listener.actionRemoved(action);\n  }\n}\n", "docstring": "completely remove an action .", "partition": "test"}
{"idx": "2202", "code": "public static double bufferDistanceError(int quadSegs){\n  double alpha=Math.PI / 2.0 / quadSegs;\n  return 1 - Math.cos(alpha / 2.0);\n}\n", "docstring": "computes the maximum distance error due to a given level of approximation to a true arc .", "partition": "test"}
{"idx": "2203", "code": "public Pair<String,String> next(){\n  try {\n    currentHeaderPosition=nextHeaderPosition;\n    String readHeader=nextLine;\n    nextHeaderPosition+=readHeader.length() + endOfLineBytes;\n    readHeader=\">\" + readHeader.substring(1);\n    String readSequence=r.readLine();\n    nextHeaderPosition+=readSequence.length() + endOfLineBytes;\n    String comments=r.readLine();\n    nextHeaderPosition+=comments.length() + endOfLineBytes;\n    if (comments.startsWith(\"+\")) {\n      String qualityValues=r.readLine();\n      nextHeaderPosition+=qualityValues.length() + endOfLineBytes;\n    }\n    nextLine=r.readLine();\n    return new Pair<>(readHeader,readSequence);\n  }\n catch (  IOException e) {\n    Basic.caught(e);\n  }\n  return null;\n}\n", "docstring": "gets next fasta record", "partition": "test"}
{"idx": "2204", "code": "public void add(Character character){\n  elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n}\n", "docstring": "adds the specified character to self .", "partition": "test"}
{"idx": "2205", "code": "public void removeChild(Group theGroup){\n  mChildren.remove(theGroup);\n}\n", "docstring": "remove a child from this group", "partition": "test"}
{"idx": "2206", "code": "protected StoragePort checkPortExistsInDB(String nativeGuid) throws IOException {\n  StoragePort port=null;\n  List<StoragePort> portInDB=CustomQueryUtility.getActiveStoragePortByNativeGuid(_dbClient,nativeGuid);\n  if (portInDB != null && !portInDB.isEmpty()) {\n    port=portInDB.get(0);\n  }\n  return port;\n}\n", "docstring": "check if port exists in db .", "partition": "test"}
{"idx": "2207", "code": "public void appendSplitElement(Fragment aSplit){\n  splits.add(aSplit);\n}\n", "docstring": "adds a split element at the end", "partition": "test"}
{"idx": "2208", "code": "public OsmHandler(MapBuilder meConsumer){\n  osmElementProcessor=new OsmElementProcessor(null,meConsumer);\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "2209", "code": "public void close() throws IOException {\n  flushBits();\n  out.close();\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2210", "code": "public RespokeDirectConnection directConnection(){\n  if (null != directConnectionReference) {\n    return directConnectionReference.get();\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "get the active direct connection with this endpoint ( if any )", "partition": "test"}
{"idx": "2211", "code": "private String appendNationalNumber(String nationalNumber){\n  int prefixBeforeNationalNumberLength=prefixBeforeNationalNumber.length();\n  if (shouldAddSpaceAfterNationalPrefix && prefixBeforeNationalNumberLength > 0 && prefixBeforeNationalNumber.charAt(prefixBeforeNationalNumberLength - 1) != SEPARATOR_BEFORE_NATIONAL_NUMBER) {\n    return new String(prefixBeforeNationalNumber) + SEPARATOR_BEFORE_NATIONAL_NUMBER + nationalNumber;\n  }\n else {\n    return prefixBeforeNationalNumber + nationalNumber;\n  }\n}\n", "docstring": "combines the national number with any prefix ( idd / + and country code or national prefix ) that was collected . a space will be inserted between them if the current formatting template indicates this to be suitable .", "partition": "test"}
{"idx": "2212", "code": "public void cut(){\n  copy();\n  deleteSelectedObjects();\n}\n", "docstring": "cut to the clipboard .", "partition": "test"}
{"idx": "2213", "code": "public void stop(){\n  setLedOn(false);\n  if (null != blinkFuture) {\n    blinkFuture.cancel(true);\n  }\n  if (null != blinkService) {\n    blinkService.shutdownNow();\n  }\n}\n", "docstring": "calling this method will stop all threads . this is needed when using javafx on mobile devices when the device goes to sleep mode .", "partition": "test"}
{"idx": "2214", "code": "public synchronized void release(){\n  index.clear();\n}\n", "docstring": "releases resources in the index .", "partition": "test"}
{"idx": "2215", "code": "public void configure(){\n  if (cmdPrefix != null) {\n    prefix=cmdPrefix.split(\" \");\n  }\n}\n", "docstring": "configure the helper . this must called before executing any commands .", "partition": "test"}
{"idx": "2216", "code": "protected void writeTransform(AffineTransform t) throws IOException {\n  pageStream.matrix(t);\n}\n", "docstring": "write the given transformation matrix to the file .", "partition": "test"}
{"idx": "2217", "code": "public void testSignumPositive(){\n  String a=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=41;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  assertEquals(\"incorrect value\",1,aNumber.signum());\n}\n", "docstring": "signum ( ) for a positive bigdecimal", "partition": "test"}
{"idx": "2218", "code": "public PainterChain prependPainter(Painter p){\n  Painter[] newChain=new Painter[chain.length + 1];\n  System.arraycopy(chain,1,newChain,0,chain.length);\n  newChain[0]=p;\n  return new PainterChain(newChain);\n}\n", "docstring": "creates a new chain based on the existing chain with the new element added at the beginning", "partition": "test"}
{"idx": "2219", "code": "@Nullable private Operator.Kind parseOperator(TokenStream tokens){\n  if (tokens.has(\"=\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.EQUALS;\n  }\n  if (tokens.has(\"!\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.NOT_EQUALS;\n  }\n  if (tokens.has(\"<\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.LESS_EQUAL;\n    }\n    return Operator.Kind.LESS;\n  }\n  if (tokens.has(\">\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.GREATER_EQUAL;\n    }\n    return Operator.Kind.GREATER;\n  }\n  return null;\n}\n", "docstring": "check for and get an operator kind .", "partition": "test"}
{"idx": "2220", "code": "@Override public boolean dragTo(Selector obj,Selector destObj,int steps) throws UiObjectNotFoundException, NotImplementedException {\n  return dragTo(device.findObject(obj.toUiSelector()),destObj,steps);\n}\n", "docstring": "drags this object to a destination uiobject . the number of steps specified in your input parameter can influence the drag speed , and varying speeds may impact the results . consider evaluating different speeds when using this method in your tests .", "partition": "test"}
{"idx": "2221", "code": "private void queueUpSyncs(final Cursor contactsCursor){\n  ContactSyncEntry syncEntry=null;\n  while (contactsCursor.moveToNext()) {\n    if (syncEntry == null) {\n      syncEntry=new ContactSyncEntry(UPLOAD_BATCH_SIZE);\n    }\n    final String number=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\n    final String name=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\n    if (!TextUtils.isEmpty(number)) {\n      syncEntry.addNumber(numberToNational(number));\n      syncEntry.addName(name);\n      if (syncEntry.isFull()) {\n        Logger.d(TAG,\"Adding sync entry to queue\");\n        mSyncQueue.add(syncEntry);\n        syncEntry=null;\n      }\n    }\n  }\n}\n", "docstring": "method that hashes contacts and syncs them to server", "partition": "test"}
{"idx": "2222", "code": "public static void writeResultToFile(Result result,String fname) throws Exception {\n  PrintWriter outer=new PrintWriter(new BufferedWriter(new FileWriter(fname)));\n  outer.write(result.toString());\n  outer.close();\n}\n", "docstring": "writeresulttofile - - write a result \"'\" result \"'\" out in plain text format to file \"'\" fname \"'\" .", "partition": "test"}
{"idx": "2223", "code": "private JMXProvider(){\n}\n", "docstring": "don \"'\" t let anyone instantiate this class .", "partition": "test"}
{"idx": "2224", "code": "private static void renderTree(Tree tree,int indent,boolean parentLabelNull,boolean firstSibling,boolean leftSiblingPreTerminal,boolean topLevel,StringBuilder sb){\n  boolean suppressIndent=(parentLabelNull || (firstSibling && tree.isPreTerminal()) || (leftSiblingPreTerminal && tree.isPreTerminal()));\n  if (suppressIndent) {\n    sb.append(\' \');\n  }\n else {\n    if (!topLevel) {\n      sb.append(\'\\n\');\n    }\n    for (int i=0; i < indent; i++) {\n      sb.append(\"  \");\n    }\n  }\n  if (tree.isLeaf() || tree.isPreTerminal()) {\n    renderFlat(tree,sb);\n    return;\n  }\n  sb.append(\'(\');\n  sb.append(tree.getLabel());\n  renderChildren(tree.getChildren(),indent + 1,false,sb);\n  sb.append(\')\');\n}\n", "docstring": "display a node , implementing penn treebank style layout", "partition": "test"}
{"idx": "2225", "code": "public static StringBuffer replaceRegex(StringBuffer original,String regex,String replace,boolean CASE_INSENSITIVE){\n  int flags=0;\n  if (CASE_INSENSITIVE)   flags=Pattern.CASE_INSENSITIVE;\n  Pattern p=Pattern.compile(regex,flags);\n  Matcher m=p.matcher(original);\n  StringBuffer newSB=new StringBuffer();\n  boolean result=m.find();\n  while (result) {\n    m.appendReplacement(newSB,replace);\n    result=m.find();\n  }\n  m.appendTail(newSB);\n  return newSB;\n}\n", "docstring": "run regex expression against original string", "partition": "test"}
{"idx": "2226", "code": "public boolean equalsChars(String a,int ai,String b,int bi,boolean ignoreCase){\n  char ca=a.charAt(ai);\n  char cb=b.charAt(bi);\n  if (ignoreCase) {\n    ca=Character.toUpperCase(ca);\n    cb=Character.toUpperCase(cb);\n  }\n  return ca == cb;\n}\n", "docstring": "compare two characters in a string .", "partition": "test"}
{"idx": "2227", "code": "private void adjustBackingFileLength(byte[] buffer,long index) throws IOException {\n  if (buffer == null || buffer.length == 0) {\n    throw new IOException(\"Buffer null or empty!\");\n  }\n  long newsize=fHeader.headerSize() + (index * CHUNK_ENC_SIZE) + CHUNK_IV_SIZE+ buffer.length+ CHUNK_TLEN;\n  if (newsize > realLength()) {\n    backingRandomAccessFile.setLength(newsize);\n  }\n}\n", "docstring": "helper methods which adjusts the actual length of the backing file for caching . as with caching , data is only actually written to disk , if a chunk has been filled completely and a new chunk is being accessed , the file size has to be extended in advance in order for methods like seek / skipbytes / . . . to still be able to work .", "partition": "test"}
{"idx": "2228", "code": "private static Collection<Collection<DsnNetPin>> create_ordered_subnets(Collection<DsnNetPin> p_pin_list){\n  Collection<Collection<DsnNetPin>> result=new LinkedList<Collection<DsnNetPin>>();\n  if (p_pin_list.isEmpty()) {\n    return result;\n  }\n  Iterator<DsnNetPin> it=p_pin_list.iterator();\n  DsnNetPin prev_pin=it.next();\n  while (it.hasNext()) {\n    DsnNetPin next_pin=it.next();\n    Set<DsnNetPin> curr_subnet_pin_list=new java.util.TreeSet<DsnNetPin>();\n    curr_subnet_pin_list.add(prev_pin);\n    curr_subnet_pin_list.add(next_pin);\n    result.add(curr_subnet_pin_list);\n    prev_pin=next_pin;\n  }\n  return result;\n}\n", "docstring": "creates a sequence of subnets with 2 pins from p_pin_list", "partition": "test"}
{"idx": "2229", "code": "@Override public void run(int connID,String[] args){\n  if (args.length == 1) {\n    server.sendServerChat(connID,\"Server Side nova command\");\n    server.sendServerChat(connID,\"/nova print : will print all of your current nova networks and unlinked units.\");\n    server.sendServerChat(connID,\"/nova print id : will print the network status for the Unit with ID id.\");\n    server.sendServerChat(connID,\"/nova link id1 id2 : will link the units with ID id1 and id2.\");\n    server.sendServerChat(connID,\"+++Will Disconnect them from all prior nets.\");\n    server.sendServerChat(connID,\"/nova link id1 id2 id3 : will link the three units with ID id1 id2 and id3.\");\n    server.sendServerChat(connID,\"+++Will Disconnect them from all prior nets.\");\n    server.sendServerChat(connID,\"/nova unlink : will unlink all your novaCEWS units.\");\n    server.sendServerChat(connID,\"/nova unlink id : will unlink unit with ID id from all nova networks.\");\n  }\n  try {\n    if (args.length > 1) {\n      String cmd=args[1];\n      if (cmd.equalsIgnoreCase(\"print\")) {\n        if (args.length > 2) {\n          int id=Integer.parseInt(args[2]);\n          server.sendServerChat(connID,strListNetwork(connID,id,true));\n        }\n else {\n          server.sendServerChat(connID,strListNetworks(connID,true));\n        }\n      }\n else       if (cmd.equalsIgnoreCase(\"printcurrent\")) {\n        if (args.length > 2) {\n          int id=Integer.parseInt(args[2]);\n          server.sendServerChat(connID,strListNetwork(connID,id,false));\n        }\n else {\n          server.sendServerChat(connID,strListNetworks(connID,false));\n        }\n      }\n else       if (cmd.equalsIgnoreCase(\"debug\")) {\n        debug(connID,server);\n      }\n else       if (cmd.equalsIgnoreCase(\"link\")) {\n        if (args.length > 4) {\n          int id1=Integer.parseInt(args[2]);\n          int id2=Integer.parseInt(args[3]);\n          int id3=Integer.parseInt(args[4]);\n          server.sendServerChat(connID,strLink3(connID,id1,id2,id3));\n        }\n else         if (args.length > 3) {\n          int id1=Integer.parseInt(args[2]);\n          int id2=Integer.parseInt(args[3]);\n          server.sendServerChat(connID,strLink2(connID,id1,id2));\n        }\n      }\n else       if (cmd.equalsIgnoreCase(\"unlink\")) {\n        if (args.length > 2) {\n          int id=Integer.parseInt(args[2]);\n          server.sendServerChat(connID,strUnlinkID(connID,id));\n        }\n else {\n          server.sendServerChat(connID,strUnlinkAll(connID));\n        }\n      }\n else {\n        String failstr=args[0];\n        for (int i=1; i < args.length; i++) {\n          failstr+=\" \" + args[i];\n        }\n        server.sendServerChat(connID,\"I do not understand \" + failstr + \". /nova for help.\\n\");\n      }\n    }\n  }\n catch (  NumberFormatException nfe) {\n    server.sendServerChat(connID,\"Error parsing the command. NFE\");\n  }\ncatch (  NullPointerException npe) {\n    server.sendServerChat(connID,\"Error parsing the command. NPE\");\n  }\ncatch (  IndexOutOfBoundsException ioobe) {\n    server.sendServerChat(connID,\"Error parsing the command. IOOBE\");\n  }\n}\n", "docstring": "run this command with the arguments supplied", "partition": "test"}
{"idx": "2230", "code": "private char[] parseEntityReference() throws IOException {\n  int pos=strpos;\n  if ((ch=readCh()) == \'#\') {\n    int n=0;\n    ch=readCh();\n    if ((ch >= \'0\') && (ch <= \'9\') || ch == \'x\' || ch == \'X\') {\n      if ((ch >= \'0\') && (ch <= \'9\')) {\n        while ((ch >= \'0\') && (ch <= \'9\')) {\n          n=(n * 10) + ch - \'0\';\n          ch=readCh();\n        }\n      }\n else {\n        ch=readCh();\n        char lch=(char)Character.toLowerCase(ch);\n        while ((lch >= \'0\') && (lch <= \'9\') || (lch >= \'a\') && (lch <= \'f\')) {\n          if (lch >= \'0\' && lch <= \'9\') {\n            n=(n * 16) + lch - \'0\';\n          }\n else {\n            n=(n * 16) + lch - \'a\' + 10;\n          }\n          ch=readCh();\n          lch=(char)Character.toLowerCase(ch);\n        }\n      }\nswitch (ch) {\ncase \'\\n\':\n        ln++;\n      ch=readCh();\n    lfCount++;\n  break;\ncase \'\\r\':\nln++;\nif ((ch=readCh()) == \'\\n\') {\nch=readCh();\ncrlfCount++;\n}\n else {\ncrCount++;\n}\nbreak;\ncase \';\':\nch=readCh();\nbreak;\n}\nchar data[]=mapNumericReference(n);\nreturn data;\n}\naddString(\'#\');\nif (!parseIdentifier(false)) {\nerror(\"ident.expected\");\nstrpos=pos;\nchar data[]={\'&\',\'#\'};\nreturn data;\n}\n}\n else if (!parseIdentifier(false)) {\nchar data[]={\'&\'};\nreturn data;\n}\nboolean semicolon=false;\nswitch (ch) {\ncase \'\\n\':\nln++;\nch=readCh();\nlfCount++;\nbreak;\ncase \'\\r\':\nln++;\nif ((ch=readCh()) == \'\\n\') {\nch=readCh();\ncrlfCount++;\n}\n else {\ncrCount++;\n}\nbreak;\ncase \';\':\nsemicolon=true;\nch=readCh();\nbreak;\n}\nString nm=getString(pos);\nEntity ent=dtd.getEntity(nm);\nif (!strict && (ent == null)) {\nent=dtd.getEntity(nm.toLowerCase());\n}\nif ((ent == null) || !ent.isGeneral()) {\nif (nm.length() == 0) {\nerror(\"invalid.entref\",nm);\nreturn new char[0];\n}\nString str=\"&\" + nm + (semicolon ? \";\" : \"\");\nchar b[]=new char[str.length()];\nstr.getChars(0,b.length,b,0);\nreturn b;\n}\nreturn ent.getData();\n}\n", "docstring": "parse an entity reference . [ 59 ", "partition": "test"}
{"idx": "2231", "code": "private static String createJsMethodInvocationExpression(String methodName,boolean isStatic,String... paramNames){\n  StringBuilder sb=new StringBuilder();\n  sb.append(isStatic ? WND : THIS);\n  sb.append(\".\");\n  sb.append(methodName);\n  sb.append(\"(\");\n  for (int i=0; i < paramNames.length; i++) {\n    if (i != 0) {\n      sb.append(\", \");\n    }\n    sb.append(paramNames[i]);\n  }\n  sb.append(\");\");\n  return sb.toString();\n}\n", "docstring": "creates a jsni method invocation expression .", "partition": "test"}
{"idx": "2232", "code": "public static Node serializableInstance(){\n  return new GraphNode(\"X\");\n}\n", "docstring": "generates a simple exemplar of this class to test serialization .", "partition": "test"}
{"idx": "2233", "code": "protected void dropTables(List<String> dropTableNames,SQLiteDatabase db){\n  if (dropTableNames != null && !dropTableNames.isEmpty()) {\n    String[] dropTableSQLS=new String[dropTableNames.size()];\n    for (int i=0; i < dropTableSQLS.length; i++) {\n      dropTableSQLS[i]=generateDropTableSQL(dropTableNames.get(i));\n    }\n    execute(dropTableSQLS,db);\n  }\n}\n", "docstring": "drop the tables by the passing table name .", "partition": "test"}
{"idx": "2234", "code": "private Segment createDiskSegment(SegmentDescriptor descriptor){\n  File segmentFile=SegmentFile.createSegmentFile(name,storage.directory(),descriptor.id(),descriptor.version());\n  Buffer buffer=FileBuffer.allocate(segmentFile,Math.min(DEFAULT_BUFFER_SIZE,descriptor.maxSegmentSize()),Integer.MAX_VALUE);\n  descriptor.copyTo(buffer);\n  Segment segment=new Segment(new SegmentFile(segmentFile),buffer.slice(),descriptor,createIndex(descriptor),new OffsetPredicate(),serializer.clone(),this);\n  LOGGER.debug(\"Created segment: {}\",segment);\n  return segment;\n}\n", "docstring": "creates a new segment .", "partition": "test"}
{"idx": "2235", "code": "public Boolean exists(String email){\n  for (  Person person : people) {\n    if (email.equals(person.getEmail())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "given an email checks if the person exists in the manager .", "partition": "test"}
{"idx": "2236", "code": "private double maxIgnoreNaN(double a,double b){\n  if (Double.isNaN(a)) {\n    return b;\n  }\n  if (Double.isNaN(b)) {\n    return a;\n  }\n else {\n    return Math.max(a,b);\n  }\n}\n", "docstring": "a function to find the maximum of two values , but ignoring any double . nan values .", "partition": "test"}
{"idx": "2237", "code": "public void crabDownDirBlockForModification(BlockId blk){\n  lockTbl.xLock(blk,txNum);\n  writenIndexBlks.add(blk);\n}\n", "docstring": "sets exclusive lock on the directory block when crabbing down for modification .", "partition": "test"}
{"idx": "2238", "code": "private static void removeReferenceToConnection(final HttpConnectionWithReference connection){\nsynchronized (REFERENCE_TO_CONNECTION_SOURCE) {\n    REFERENCE_TO_CONNECTION_SOURCE.remove(connection.reference);\n  }\n}\n", "docstring": "removes the reference being stored for the given connection . this method should be called when the connection manager again has a direct reference to the connection .", "partition": "test"}
{"idx": "2239", "code": "public boolean matchesWord(){\n  return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n}\n", "docstring": "test if the queue matches a word character ( letter or digit ) .", "partition": "test"}
{"idx": "2240", "code": "public VacuumEnvironment(){\n  Random r=new Random();\n  envState=new VacuumEnvironmentState(0 == r.nextInt(2) ? LocationState.Clean : LocationState.Dirty,0 == r.nextInt(2) ? LocationState.Clean : LocationState.Dirty);\n}\n", "docstring": "constructs a vacuum environment with two locations , in which dirt is placed at random .", "partition": "test"}
{"idx": "2241", "code": "public void generate(BatchEnvironment env,ClassDefinition cdef,File destDir){\n  RemoteClass remoteClass=RemoteClass.forClass(env,cdef);\n  if (remoteClass == null)   return;\n  RMIGenerator gen;\n  try {\n    gen=new RMIGenerator(env,cdef,destDir,remoteClass,version);\n  }\n catch (  ClassNotFound e) {\n    env.error(0,\"rmic.class.not.found\",e.name);\n    return;\n  }\n  gen.generate();\n}\n", "docstring": "generate the source files for the stub and / or skeleton classes needed by rmi for the given remote implementation class .", "partition": "test"}
{"idx": "2242", "code": "public void remove(final CreatureRespawnPoint point){\n  respawnPoints.remove(point);\n}\n", "docstring": "remove a creature respawn point from the zone .", "partition": "test"}
{"idx": "2243", "code": "public Photo(File d,File f) throws IOException, NumberFormatException {\n  ExtendedExifInterface exif=new ExtendedExifInterface(f.toString());\n  String lonStr=exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE);\n  if (lonStr == null) {\n    throw new IOException(\"No EXIF tag\");\n  }\n  float lonf=convertToDegree(lonStr);\n  String lonRef=exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF);\n  if (lonRef != null && !lonRef.equals(\"E\")) {\n    lonf=-lonf;\n  }\n  float latf=convertToDegree(exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE));\n  String latRef=exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE_REF);\n  if (latRef != null && !latRef.equals(\"N\")) {\n    latf=-latf;\n  }\n  lat=(int)(latf * 1E7d);\n  lon=(int)(lonf * 1E7d);\n  Log.d(\"Photo\",\"lat: \" + lat + \" lon: \"+ lon);\n  ref=d.getAbsolutePath() + \"/\" + f.getName();\n  String dir=exif.getAttribute(ExtendedExifInterface.TAG_GPS_IMG_DIRECTION);\n  if (dir != null) {\n    direction=(int)Double.parseDouble(dir);\n    directionRef=exif.getAttribute(ExtendedExifInterface.TAG_GPS_IMG_DIRECTION_REF);\n    Log.d(\"Photo\",\"dir \" + dir + \" direction \"+ direction+ \" ref \"+ directionRef);\n  }\n}\n", "docstring": "create a bug from an osb gpx xml wpt element .", "partition": "test"}
{"idx": "2244", "code": "public static long bytesToLong(final byte[] bytes){\n  final ByteBuffer buffer=ByteBuffer.allocate(8);\n  buffer.put(bytes,0,8);\n  buffer.flip();\n  return buffer.getLong();\n}\n", "docstring": "converts an array of 8 bytes into a long .", "partition": "test"}
{"idx": "2245", "code": "@Override public void mouseEntered(MouseEvent evt){\n  delegate.mouseMoved(evt);\n}\n", "docstring": "pass mouseevent straight through to delegate", "partition": "test"}
{"idx": "2246", "code": "public static String removeFormatting(String line){\n  int length=line.length();\n  StringBuilder buffer=new StringBuilder();\n  for (int i=0; i < length; i++) {\n    char ch=line.charAt(i);\n    if (ch != '\\u000f' && ch != '\\u0002' && ch != '\\u001f' && ch != '\\u0016')     buffer.append(ch);\n  }\n  return buffer.toString();\n}\n", "docstring": "remove formatting from a line of irc text .", "partition": "test"}
{"idx": "2247", "code": "public void print(){\n  Object[] iterChargingTimes=chargingTimes.toArray();\n  Arrays.sort(iterChargingTimes);\n  for (int i=0; i < iterChargingTimes.length; i++) {\n    ChargeLog curItem=(ChargeLog)iterChargingTimes[i];\n    curItem.print();\n  }\n}\n", "docstring": "just prints out sorted after the time ( starting with 0 : 00 ) note : this is not the order in which the charging happened .", "partition": "test"}
{"idx": "2248", "code": "public boolean isEmpty(){\n  return rdns.isEmpty();\n}\n", "docstring": "determines whether this ldap name is empty . an empty name is one with zero components .", "partition": "test"}
{"idx": "2249", "code": "private void writeLocalCSV(MedtronicSensorRecord mostRecentData,Context context){\n  try {\n    if (mostRecentData == null || mostRecentData.bGValue == null)     log.debug(\"writeLocalCSV SAVING  EMPTY!!\");\n else     log.debug(\"writeLocalCSV SAVING --> \" + mostRecentData.bGValue);\n    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File(context.getFilesDir(),\"save.bin\")));\n    oos.writeObject(mostRecentData);\n    oos.flush();\n    oos.close();\n  }\n catch (  Exception e) {\n    Log.e(TAG,\"write to OutputStream failed\",e);\n    log.error(\"write to OutputStream failed\",e);\n  }\n}\n", "docstring": "this method saves a file with the last record read from the device", "partition": "test"}
{"idx": "2250", "code": "public ServiceConfig createOrganizationConfig(String orgName,Map attrs) throws SMSException, SSOException {\n  validateSSM();\n  ServiceSchemaImpl ss=ssm.getSchema(SchemaType.ORGANIZATION);\n  if (ss == null) {\n    String[] args={serviceName};\n    throw (new SMSException(IUMSConstants.UMS_BUNDLE_NAME,\"sms-service-does-not-have-org-schema\",args));\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  CreateServiceConfig.checkBaseNodesForOrg(token,orgdn,serviceName,version);\n  String orgDN=scm.constructServiceConfigDN(SMSUtils.DEFAULT,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  try {\n    CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,orgDN);\n    if (cEntry.isDirty()) {\n      cEntry.refresh();\n    }\n    if (cEntry.isNewEntry()) {\n      CreateServiceConfig.createSubConfigEntry(token,orgDN,ss,null,null,attrs,orgName);\n      if (ServiceManager.isCoexistenceMode()) {\n        String smsDN=DNMapper.orgNameToDN(orgName);\n        OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(smsDN),smsDN);\n        amsdk.assignService(serviceName);\n      }\n    }\n else     if (attrs != null && !attrs.isEmpty()) {\n      ServiceConfig sc=getOrganizationConfig(orgName,null);\n      sc.setAttributes(attrs);\n    }\n  }\n catch (  ServiceAlreadyExistsException slee) {\n  }\n  return (getOrganizationConfig(orgName,null));\n}\n", "docstring": "creates organization configuration for the default instance of the service given configuration attributes .", "partition": "test"}
{"idx": "2251", "code": "public void deleteAuthenticationDomain(String realm,String cotName) throws AMConsoleException {\n  String[] param={realm,cotName};\n  logEvent(\"ATTEMPT_DELETE_AUTH_DOMAINS\",param);\n  try {\n    CircleOfTrustManager manager=getCircleOfTrustManager();\n    manager.deleteCircleOfTrust(realm,cotName);\n    logEvent(\"SUCCEED_DELETE_AUTH_DOMAIN\",param);\n  }\n catch (  COTException e) {\n    String strError=getErrorString(e);\n    String[] paramsEx={realm,cotName,strError};\n    logEvent(\"FEDERATION_EXCEPTION_DELETE_AUTH_DOMAIN\",paramsEx);\n    throw new AMConsoleException(strError);\n  }\n}\n", "docstring": "deletes an authentication domain ( circle of trust ) within a given realm .", "partition": "test"}
{"idx": "2252", "code": "protected void addSourceCodeRemark(TestSolution testSolution,Element element,String messageCode,EvidenceElement evidenceElement){\n  if (evidenceElement != null) {\n    Collection<EvidenceElement> evidenceElementList=new ArrayList<>();\n    evidenceElementList.add(evidenceElement);\n    processRemarkService.addSourceCodeRemarkOnElement(testSolution,element,messageCode,evidenceElementList);\n  }\n else {\n    processRemarkService.addSourceCodeRemarkOnElement(testSolution,element,messageCode);\n  }\n}\n", "docstring": "add a sourcecoderemark on the given element with a preset evidence element collection", "partition": "test"}
{"idx": "2253", "code": "void eventPreModify(ActionType type,long position,boolean isSingle){\n  if (type != currentActionType || !isSingle || System.currentTimeMillis() - previousTime > MERGE_TIME || (type == ActionType.INSERT || type == ActionType.OVERWRITE) && actionExclusiveEnd() != position || type == ActionType.DELETE && actionPosition() != position && actionPosition() - 1L != position) {\n    startAction(type,isSingle);\n  }\n else {\n    isBackspace=actionPosition() > position;\n  }\n  if (isSingle && type == ActionType.INSERT) {\n    updateNewRange(position);\n    previousTime=System.currentTimeMillis();\n  }\n}\n", "docstring": "user event : single / block delete / insert / overwrite . called before any change has been done", "partition": "test"}
{"idx": "2254", "code": "void saveAsync(DocumentEntity entity,Consumer<DocumentEntity> callBack) throws ExecuteAsyncQueryException, UnsupportedOperationException ;\n", "docstring": "saves an entity asynchronously", "partition": "test"}
{"idx": "2255", "code": "public String resolveParentRelationName(String parentName,Object parent,String childName,Object child){\n  return parentName;\n}\n", "docstring": "follow the most conventional pattern , returns the parentname unchanged .", "partition": "test"}
{"idx": "2256", "code": "public RelNode convertSelect(SqlSelect select,boolean top){\n  final SqlValidatorScope selectScope=validator.getWhereScope(select);\n  final Blackboard bb=createBlackboard(selectScope,null,top);\n  convertSelectImpl(bb,select);\n  return bb.root;\n}\n", "docstring": "converts a select statement \"'\" s parse tree into a relational expression .", "partition": "test"}
{"idx": "2257", "code": "private static String formatSampleRate(int rate){\n  return MHZ_FORMATTER.format((double)rate / 1E6d);\n}\n", "docstring": "formats the rate in hertz for display as megahertz", "partition": "test"}
{"idx": "2258", "code": "void start(){\n  this.running=true;\n  Thread thread=new Thread(this,\"IceConnector@\" + hashCode());\n  thread.setDaemon(true);\n  thread.start();\n}\n", "docstring": "start the network listening thread .", "partition": "test"}
{"idx": "2259", "code": "public static byte[] escape(final byte[] bytes){\n  final byte[] temp=new byte[2 * bytes.length];\n  int currentPosition=0;\n  for (  final byte b : bytes) {\n    if (b == ESCAPE_CHAR) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=REPLACEMENT_CHAR;\n    }\n else     if (b == DELIMITER) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=ESCAPE_CHAR;\n    }\n else {\n      temp[currentPosition++]=b;\n    }\n  }\n  final byte[] escaped=new byte[currentPosition];\n  System.arraycopy(temp,0,escaped,0,currentPosition);\n  return escaped;\n}\n", "docstring": "escapes the provided string so that it no longer contains the constants . delimiter character .", "partition": "test"}
{"idx": "2260", "code": "public final native String name();\n", "docstring": "human readable name of the mode , such as \" c + + \" .", "partition": "test"}
{"idx": "2261", "code": "protected void drawChartValuesText(Canvas canvas,XYSeries series,XYSeriesRenderer renderer,Paint paint,List<Float> points,int seriesIndex,int startIndex){\n  if (points.size() > 1) {\n    float previousPointX=points.get(0);\n    float previousPointY=points.get(1);\n    for (int k=0; k < points.size(); k+=2) {\n      if (k == 2) {\n        if (Math.abs(points.get(2) - points.get(0)) > renderer.getDisplayChartValuesDistance() || Math.abs(points.get(3) - points.get(1)) > renderer.getDisplayChartValuesDistance()) {\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex)),points.get(0),points.get(1) - renderer.getChartValuesSpacing(),paint,0);\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + 1)),points.get(2),points.get(3) - renderer.getChartValuesSpacing(),paint,0);\n          previousPointX=points.get(2);\n          previousPointY=points.get(3);\n        }\n      }\n else       if (k > 2) {\n        if (Math.abs(points.get(k) - previousPointX) > renderer.getDisplayChartValuesDistance() || Math.abs(points.get(k + 1) - previousPointY) > renderer.getDisplayChartValuesDistance()) {\n          drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + k / 2)),points.get(k),points.get(k + 1) - renderer.getChartValuesSpacing(),paint,0);\n          previousPointX=points.get(k);\n          previousPointY=points.get(k + 1);\n        }\n      }\n    }\n  }\n else {\n    for (int k=0; k < points.size(); k+=2) {\n      drawText(canvas,getLabel(renderer.getChartValuesFormat(),series.getY(startIndex + k / 2)),points.get(k),points.get(k + 1) - renderer.getChartValuesSpacing(),paint,0);\n    }\n  }\n}\n", "docstring": "the graphical representation of the series values as text .", "partition": "test"}
{"idx": "2262", "code": "public static String toString(Document hostDoc) throws IOException {\n  try {\n    StringWriter out=new StringWriter();\n    DOMSource domSource=new DOMSource(hostDoc);\n    StreamResult streamResult=new StreamResult(out);\n    TransformerFactory tf=TransformerFactory.newInstance();\n    Transformer serializer=tf.newTransformer();\n    serializer.setOutputProperty(OutputKeys.ENCODING,ENC.name());\n    serializer.setOutputProperty(OutputKeys.METHOD,\"html\");\n    serializer.setOutputProperty(OutputKeys.INDENT,\"no\");\n    serializer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC,HtmlDomUtil.HTML_STRICT);\n    serializer.transform(domSource,streamResult);\n    return out.toString();\n  }\n catch (  TransformerException e) {\n    IOException r=new IOException(\"Error transforming page\");\n    r.initCause(e);\n    throw r;\n  }\n}\n", "docstring": "convert a document to a string , assuming later encoding to utf - 8 .", "partition": "test"}
{"idx": "2263", "code": "public MongoClient clientForMembers(ServerAddress... seeds){\n  List<ServerAddress> addresses=new ArrayList<>();\n  for (  ServerAddress seedAddress : seeds) {\n    if (seedAddress != null)     addresses.add(seedAddress);\n  }\n  return clientForMembers(addresses);\n}\n", "docstring": "obtain a client connection to the replica set or cluster . the supplied addresses are used as seeds , and once a connection is established it will discover all of the members .", "partition": "test"}
{"idx": "2264", "code": "public static boolean stringToBooleanValue(String str) throws ExpressionException {\n  str=StringUtil.toLowerCase(str.trim());\n  if (str.equals(\"yes\") || str.equals(\"true\"))   return true;\n else   if (str.equals(\"no\") || str.equals(\"false\"))   return false;\n  throw new CasterException(\"Can\'t cast String [\" + str + \"] to boolean\");\n}\n", "docstring": "cast a string to a boolean value ( primitive value type )", "partition": "test"}
{"idx": "2265", "code": "public void generateClassFile(OutputStream os){\n  ClassWriter cw=new SootASMClassWriter(ClassWriter.COMPUTE_FRAMES);\n  cv=cw;\n  generateByteCode();\n  try {\n    os.write(cw.toByteArray());\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Could not write class file in the ASM-backend!\",e);\n  }\n}\n", "docstring": "outputs the bytecode generated as a class file", "partition": "test"}
{"idx": "2266", "code": "private static boolean useCompactFontFormat(Map<String,Object> args,int compatibilityVersion){\n  String value=(String)args.get(EMBEDASCFF);\n  boolean useCFF=true;\n  if (compatibilityVersion < MxmlConfiguration.VERSION_4_0)   useCFF=false;\n  if (value != null) {\n    useCFF=Boolean.parseBoolean(value.trim());\n  }\n  return useCFF;\n}\n", "docstring": "the cff flag determines whether font information should be embedded in the compact font format using swf tag definefont4 .", "partition": "test"}
{"idx": "2267", "code": "public static void main(String[] args){\n  new GeneratorTester(args);\n}\n", "docstring": "test the image generator .", "partition": "test"}
{"idx": "2268", "code": "private String mosesize(String feature){\n  if (joshuaConfiguration.moses) {\n    if (feature.startsWith(\"tm_\") || feature.startsWith(\"lm_\"))     return feature.replace(\"_\",\"-\");\n  }\n  return feature;\n}\n", "docstring": "moses requires the pattern . * _ . * for sparse features , and prohibits underscores in dense features . this conforms to that pattern . we assume non - conforming dense features start with tm_ or lm_ , and the only sparse feature that needs converting is oovpenalty .", "partition": "test"}
{"idx": "2269", "code": "private void checkShutdown(){\nsynchronized (mux) {\n    if (isBeingShutdown)     throw new RejectedExecutionException(\"Failed to execute command during executor shutdown.\");\n  }\n}\n", "docstring": "checks if service is being shutdown .", "partition": "test"}
{"idx": "2270", "code": "private static final void checkQueueForDependenciesAndExecuteUnblockedTasks(){\n  List<ProgressThread> toRemove=new LinkedList<>();\nsynchronized (LOCK) {\n    for (    ProgressThread pg : queuedThreads) {\n      if (!pg.isBlockedByDependencies()) {\n        if (!pg.isWaiting()) {\n          toRemove.add(pg);\n          EXECUTOR.execute(pg.makeWrapper());\n        }\n      }\n    }\n  }\n  for (  ProgressThread pg : toRemove) {\nsynchronized (LOCK) {\n      queuedThreads.remove(pg);\n    }\n  }\n}\n", "docstring": "checks the currently queued tasks if there are ones which are no longer blocked by dependencies and executes them .", "partition": "test"}
{"idx": "2271", "code": "private static short CallShortMethodV(JNIEnvironment env,int objJREF,int methodID,Address argAddress) throws Exception {\n  if (traceJNI)   VM.sysWrite(\"JNI called: CallShortMethodV  \\n\");\n  RuntimeEntrypoints.checkJNICountDownToGC();\n  try {\n    Object obj=env.getJNIRef(objJREF);\n    Object returnObj=JNIHelpers.invokeWithVarArg(obj,methodID,argAddress,TypeReference.Short,false);\n    return Reflection.unwrapShort(returnObj);\n  }\n catch (  Throwable unexpected) {\n    if (traceJNI)     unexpected.printStackTrace(System.err);\n    env.recordException(unexpected);\n    return 0;\n  }\n}\n", "docstring": "callshortmethodv : invoke a virtual method that returns a short value", "partition": "test"}
{"idx": "2272", "code": "public static void drawVerticalMarginIndicator(Graphics2D g,String text,int x,int y1,int y2){\n  if (y1 > y2) {\n    int temp=y1;\n    y1=y2;\n    y2=temp;\n  }\n  if (text == null) {\n    g.drawLine(x,y1,x,y2);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    return;\n  }\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=4;\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int th=(int)bounds.getHeight();\n  int offset=3 * CONNECTION_ARROW_SIZE;\n  int h=((y2 - y1) - (th + 2 * padding)) / 2;\n  if (h <= padding) {\n    g.drawLine(x,y1,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2) + offset,y2 - h - padding);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y1,x + CONNECTION_ARROW_SIZE,y1);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y2,x + CONNECTION_ARROW_SIZE,y2);\n  }\n else {\n    g.drawLine(x,y1,x,y1 + h);\n    g.drawLine(x,y2 - h,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2),y2 - h - padding);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n  }\n}\n", "docstring": "utility function to draw a vertical margin indicator", "partition": "test"}
{"idx": "2273", "code": "protected void removeMarkers(){\n  for (int i=markerImage.size(); i > 0; i--) {\n    LocoIcon il=markerImage.get(i - 1);\n    if ((il != null) && (il.isActive())) {\n      markerImage.remove(i - 1);\n      il.remove();\n      il.dispose();\n      setDirty(true);\n    }\n  }\n  super.removeMarkers();\n  repaint();\n}\n", "docstring": "remove marker icons from panel", "partition": "test"}
{"idx": "2274", "code": "public IElementType captureString(){\n  CharSequence buffer=getBuffer();\n  int currentPosition=getTokenEnd();\n  setTokenStart(currentPosition);\n  int bufferEnd=getBufferEnd();\n  char openQuote=buffer.charAt(currentPosition);\n  char closeQuote=RegexBlock.getQuoteCloseChar(openQuote);\n  boolean quotesDiffer=openQuote != closeQuote;\n  boolean isEscaped=false;\n  int quotesDepth=0;\n  currentPosition++;\n  while (currentPosition < bufferEnd) {\n    char currentChar=buffer.charAt(currentPosition);\n    if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote) {\n      break;\n    }\n    if (!isEscaped && quotesDiffer) {\n      if (currentChar == openQuote) {\n        quotesDepth++;\n      }\n else       if (currentChar == closeQuote) {\n        quotesDepth--;\n      }\n    }\n    isEscaped=!isEscaped && currentChar == '\\\\';\n    currentPosition++;\n  }\n  if (currentPosition < bufferEnd) {\n    currentPosition++;\n  }\n  setTokenEnd(currentPosition);\n  PerlStringLexer stringLexer=getStringLexer();\n  popState();\n  preparsedTokensList.addAll(lexCurrentToken(stringLexer));\n  return getPreParsedToken();\n}\n", "docstring": "captures string token from current position according to the current lexical state", "partition": "test"}
{"idx": "2275", "code": "public static String toLocalizedInteger(long value){\n  return NUMBER_FORMAT0.format(value);\n}\n", "docstring": "this static method converts the passed in number into a localizable representation of an integer , with digit grouping using locale dependant separators .", "partition": "test"}
{"idx": "2276", "code": "public void testParseClientHandshake() throws Exception {\n  for (int splitPos=1; splitPos < 5; splitPos++) {\n    log.info(\"Checking split position: \" + splitPos);\n    ByteBuffer tmp=clientHandshakePacket();\n    ByteBuffer[] split=split(tmp,splitPos);\n    GridNioSession ses=new MockNioSession();\n    ses.addMeta(MARSHALLER.ordinal(),new GridClientOptimizedMarshaller());\n    GridTcpRestParser parser=new GridTcpRestParser(false);\n    Collection<GridClientMessage> lst=new ArrayList<>(1);\n    for (    ByteBuffer buf : split) {\n      GridClientMessage r;\n      while (buf.hasRemaining() && (r=parser.decode(ses,buf)) != null)       lst.add(r);\n      assertTrue(\"Parser has left unparsed bytes.\",buf.remaining() == 0);\n    }\n    assertEquals(1,lst.size());\n    GridClientHandshakeRequest req=(GridClientHandshakeRequest)F.first(lst);\n    assertNotNull(req);\n    assertEquals(U.bytesToShort(new byte[]{5,0},0),req.version());\n  }\n}\n", "docstring": "tests correct parsing of client handshake packets .", "partition": "test"}
{"idx": "2277", "code": "public void initialize(Context context,HapticFeedbackController hapticFeedbackController,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){\n  if (mTimeInitialized) {\n    Log.e(TAG,\"Time has already been initialized.\");\n    return;\n  }\n  mHapticFeedbackController=hapticFeedbackController;\n  mIs24HourMode=is24HourMode;\n  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() ? true : mIs24HourMode;\n  mCircleView.initialize(context,mHideAmPm);\n  mCircleView.invalidate();\n  if (!mHideAmPm) {\n    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);\n    mAmPmCirclesView.invalidate();\n  }\n  Resources res=context.getResources();\n  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};\n  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};\n  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};\n  String[] hoursTexts=new String[12];\n  String[] innerHoursTexts=new String[12];\n  String[] minutesTexts=new String[12];\n  for (int i=0; i < 12; i++) {\n    hoursTexts[i]=is24HourMode ? String.format(\"%02d\",hours_24[i]) : String.format(\"%d\",hours[i]);\n    innerHoursTexts[i]=String.format(\"%d\",hours[i]);\n    minutesTexts[i]=String.format(\"%02d\",minutes[i]);\n  }\n  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);\n  mHourRadialTextsView.invalidate();\n  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);\n  mMinuteRadialTextsView.invalidate();\n  setValueForItem(HOUR_INDEX,initialHoursOfDay);\n  setValueForItem(MINUTE_INDEX,initialMinutes);\n  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;\n  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));\n  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;\n  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);\n  mTimeInitialized=true;\n}\n", "docstring": "initialize the layout with starting values .", "partition": "test"}
{"idx": "2278", "code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Node nameNode;\n  CharacterData child;\n  String childData;\n  doc=(Document)load(\"staff\",true);\n  elementList=doc.getElementsByTagName(\"address\");\n  nameNode=elementList.item(0);\n  child=(CharacterData)nameNode.getFirstChild();\n  child.deleteData(4,50);\n  childData=child.getData();\n  assertEquals(\"characterdataDeleteDataExceedsLengthAssert\",\"1230\",childData);\n}\n", "docstring": "runs the test case .", "partition": "test"}
{"idx": "2279", "code": "protected void sqrtLayout(VisualTable labels){\n  Rectangle2D b=getLayoutBounds();\n  double breadth=getBreadth(b);\n  double span=m_hi - m_lo;\n  double splo=MathLib.safeSqrt(m_prevlo);\n  double spspan=MathLib.safeSqrt(m_prevhi) - splo;\n  double vlo=Math.pow(10,Math.floor(MathLib.safeLog10(m_lo)));\n  double slo=MathLib.safeSqrt(m_lo);\n  double sspan=MathLib.safeSqrt(m_hi) - slo;\n  Iterator iter=labels.tuples();\n  while (iter.hasNext()) {\n    VisualItem item=(VisualItem)iter.next();\n    reset(item);\n    double v=item.getDouble(VALUE);\n    double x=span == 0 ? 0 : ((MathLib.safeSqrt(v) - slo) / sspan) * breadth;\n    set(item,x,b);\n  }\n  Index index=labels.index(VALUE);\n  double step=getLinearStep(span,breadth / span);\n  if (step == 0)   step=1;\n  int r;\n  for (double x, v=vlo; v <= m_hi; v+=step) {\n    x=((MathLib.safeSqrt(v) - slo) / sspan) * breadth;\n    if (x < -0.5) {\n      continue;\n    }\n else     if ((r=index.get(v)) >= 0) {\n      VisualItem item=labels.getItem(r);\n      item.setVisible(true);\n      item.setEndVisible(true);\n    }\n else {\n      VisualItem item=labels.addItem();\n      item.set(LABEL,m_nf.format(v));\n      item.setDouble(VALUE,v);\n      double f=spspan == 0 ? 0 : ((MathLib.safeSqrt(v) - splo) / spspan);\n      if (f <= 0 || f >= 1.0) {\n        item.setStartVisible(true);\n      }\n      set(item,f * breadth,b);\n      set(item,x,b);\n    }\n  }\n}\n", "docstring": "calculates a quantitative , square root scaled layout .", "partition": "test"}
{"idx": "2280", "code": "public static Template create(String value){\n  if (Settings.isFunction(value)) {\n    return new FunctionalTemplate(value);\n  }\n  if (Graph.isRelational(value)) {\n    try {\n      return new RelationalTemplate(value);\n    }\n catch (    Exception e) {\n      log.warning(\"illegal relational structure: \" + value + \")\");\n      return new StringTemplate(value);\n    }\n  }\n else   if (RegexTemplate.isPossibleRegex(value)) {\n    try {\n      if (ArithmeticTemplate.isArithmeticExpression(value)) {\n        return new ArithmeticTemplate(value);\n      }\n      return new RegexTemplate(value);\n    }\n catch (    PatternSyntaxException e) {\n      log.warning(\"illegal pattern: \" + value + \")\");\n      return new StringTemplate(value);\n    }\n  }\n else {\n    return new StringTemplate(value);\n  }\n}\n", "docstring": "creates a new template based on the string value . this method finds the best template representation for the string and returns the result .", "partition": "test"}
{"idx": "2281", "code": "protected boolean customShouldTakeFocus(){\n  if (customArea instanceof Label) {\n    return false;\n  }\n  if (customArea instanceof CLabel) {\n    return (customArea.getStyle() & SWT.NO_FOCUS) > 0;\n  }\n  return true;\n}\n", "docstring": "return whether or not we should apply the workaround where we take focus for the default button or if that should be determined by the dialog . by default only return true if the custom area is a label or clabel that cannot take focus .", "partition": "test"}
{"idx": "2282", "code": "private Map<String,List<Zone>> selectZonesForInitiatorsAndPorts(NetworkLite network,Map<String,List<Zone>> wwnToZones,Map<String,StoragePort> initiatorPortsMap){\n  Map<String,List<Zone>> filteredMap=new HashMap<String,List<Zone>>();\n  Zone zone=null;\n  List<Zone> zones=null;\n  for (  String initiatorWwn : wwnToZones.keySet()) {\n    for (    String portWwn : initiatorPortsMap.keySet()) {\n      zone=_networkScheduler.selectExistingZoneForInitiatorPort(network,initiatorWwn,portWwn,wwnToZones.get(initiatorWwn));\n      if (zone != null) {\n        zones=filteredMap.get(initiatorWwn);\n        if (zones == null) {\n          zones=new ArrayList<>();\n          filteredMap.put(initiatorWwn,zones);\n        }\n        zones.add(zone);\n      }\n    }\n  }\n  return filteredMap;\n}\n", "docstring": "given the map of all existing zones for a set on initiators and ports , this function selects the zones that should be used by vipr .", "partition": "test"}
{"idx": "2283", "code": "public static boolean isExtension(String filename,Collection<String> extensions){\n  if (filename == null)   return false;\n  if (extensions == null || extensions.isEmpty())   return indexOfExtension(filename) == -1;\n  String fileExt=getExtension(filename);\n  for (  String extension : extensions) {\n    if (fileExt.equals(extension))     return true;\n  }\n  return false;\n}\n", "docstring": "checks whether the extension of the filename is one of those specified . < p > this method obtains the extension as the textual part of the filename after the last dot . there must be no directory separator after the dot . the extension check is case - sensitive on all platforms .", "partition": "test"}
{"idx": "2284", "code": "private void writeJarPostResource(Element postResourceEl,String path){\n  postResourceEl.setAttribute(\"className\",JAR_RESOURCE_SET);\n  postResourceEl.setAttribute(\"base\",path.replace(\"&\",\"&amp;\"));\n}\n", "docstring": "write jar post resource", "partition": "test"}
{"idx": "2285", "code": "public void closeFile() throws IOException {\n  file.close();\n  file=null;\n}\n", "docstring": "close the file . the file may later be re - opened using openfile .", "partition": "test"}
{"idx": "2286", "code": "public TypedEventListener(EventListener<E> wrappedListener,Class<E> eventClass){\n  this.eventClass=eventClass;\n  this.wrappedListener=wrappedListener;\n}\n", "docstring": "constructs a new single typed event listener .", "partition": "test"}
{"idx": "2287", "code": "public static Corleone context(String jobContext){\n  if (jobContext == null || jobContext.equals(\"\")) {\n    throw new IllegalArgumentException(\"Job context must not be null or empty.\");\n  }\n  contexts.clear();\n  contexts.add(jobContext);\n  return getInstance();\n}\n", "docstring": "provides a corleone instance to work on the given context .", "partition": "test"}
{"idx": "2288", "code": "protected final void init() throws NoGlyphException {\n  char[] codes=chars.toCharArray();\n  indices=new int[codes.length];\n  advances=new int[codes.length];\n  double maxAscent=0.0;\n  double maxDescent=0.0;\n  double scale=size * SWFConstants.TWIPS / 1024.0;\n  for (int i=0; i < codes.length; i++) {\n    int code=(int)codes[i];\n    int[] index=new int[1];\n    FontDefinition.Glyph glyph=getGlyph(code,index);\n    indices[i]=index[0];\n    if (glyph != null) {\n      Shape shape=glyph.getShape();\n      double[] outline=shape.getBoundingRectangle();\n      double x1=outline[0] * scale;\n      double y1=outline[1] * scale;\n      double x2=outline[2] * scale;\n      double y2=outline[3] * scale;\n      if (maxAscent < -y1) {\n        maxAscent=-y1;\n      }\n      if (maxDescent < y2) {\n        maxDescent=y2;\n      }\n      double advance=glyph.getAdvance() * scale;\n      if (advance == 0) {\n        advance=x2 - x1;\n      }\n      if (i < codes.length - 1) {\n        advance+=(fontDef.getKerningOffset(code,(int)codes[i + 1]) * scale);\n      }\n      totalAdvance+=advance;\n      advances[i]=(int)(advance * SWFConstants.TWIPS);\n      if (i == 0) {\n        leftMargin=-y1;\n      }\n      if (i == codes.length - 1) {\n        rightMargin=x2 - advance;\n      }\n    }\n  }\n  ascent=fontDef.getAscent() * scale;\n  if (ascent == 0.0) {\n    ascent=maxAscent;\n  }\n  descent=fontDef.getDescent() * scale;\n  if (descent == 0.0) {\n    descent=maxDescent;\n  }\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2289", "code": "public static double info(int counts[]){\n  int total=0;\n  double x=0;\n  for (  int count : counts) {\n    x-=xlogx(count);\n    total+=count;\n  }\n  return x + xlogx(total);\n}\n", "docstring": "computes entropy for an array of integers .", "partition": "test"}
{"idx": "2290", "code": "public void addMethod(SootMethod m){\n  checkLevel(SIGNATURES);\n  if (m.isDeclared())   throw new RuntimeException(\"already declared: \" + m.getName());\n  if (subSigToMethods.get(m.getNumberedSubSignature()) != null) {\n    throw new RuntimeException(\"Attempting to add method \" + m.getSubSignature() + \" to class \"+ this+ \", but the class already has a method with that signature.\");\n  }\n  subSigToMethods.put(m.getNumberedSubSignature(),m);\n  methodList.add(m);\n  m.setDeclared(true);\n  m.setDeclaringClass(this);\n}\n", "docstring": "adds the given method to this class .", "partition": "test"}
{"idx": "2291", "code": "private void addReplicationFactor(Operation op){\n  op.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n}\n", "docstring": "authorization related operations should take effect on all replicas , before they complete . this method adds a special header that sets the quorum level to all available nodes , avoiding a race where a client can reach a node that has not yet received latest authorization changes , even if it received success from this auth helper class", "partition": "test"}
{"idx": "2292", "code": "private static Frame showInitialSplash(){\n  Frame splashFrame=null;\n  Image image=null;\n  URL imageURL=getChosenSplashURL();\n  if (imageURL != null) {\n    try {\n      image=ImageIO.read(imageURL);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n    if (image != null) {\n      splashFrame=AWTSplashWindow.splash(image);\n    }\n  }\n  return splashFrame;\n}\n", "docstring": "shows the initial splash window .", "partition": "test"}
{"idx": "2293", "code": "protected void decodeLineSuffix(PushbackInputStream inStream,OutputStream outStream) throws IOException {\n  int c;\n  while (true) {\n    c=inStream.read();\n    if (c == -1) {\n      throw new CEStreamExhausted();\n    }\n    if (c == '\\n') {\n      break;\n    }\n    if (c == '\\r') {\n      c=inStream.read();\n      if ((c != '\\n') && (c != -1)) {\n        inStream.unread(c);\n      }\n      break;\n    }\n  }\n}\n", "docstring": "find the end of the line for the next operation . the following sequences are recognized as end - of - line cr , cr lf , or lf", "partition": "test"}
{"idx": "2294", "code": "public void addTransaction(SIPServerTransaction serverTransaction) throws IOException {\n  if (isLoggingEnabled())   stackLogger.logDebug(\"added transaction \" + serverTransaction);\n  serverTransaction.map();\n  addTransactionHash(serverTransaction);\n}\n", "docstring": "add a new server transaction to the set of existing transactions . add it to the top of the list so an incoming ack has less work to do in order to find the transaction .", "partition": "test"}
{"idx": "2295", "code": "public boolean containsPoly(SootMethod method){\n  return getMethod(method) != null;\n}\n", "docstring": "search for polymorphic containment based on inheritance of receiver and arguments .", "partition": "test"}
{"idx": "2296", "code": "public JKTagMapping(final String sourceQName,final String targetQName,final JKNamespace namespace){\n  logger.info(String.format(\"creating TagMapping with sourceTag(%s) and (%s)\",sourceQName,targetQName));\n  this.sourceQName=sourceQName;\n  this.targetQName=targetQName;\n  this.namespace=namespace;\n  this.auto=true;\n}\n", "docstring": "instantiates a new jk tag mapping .", "partition": "test"}
{"idx": "2297", "code": "private void selectAttributeSetInstance(){\n  int m_warehouse_id=getM_Warehouse_ID();\n  int m_product_id=getM_Product_ID();\n  if (m_product_id <= 0)   return;\n  MProduct product=MProduct.get(getCtx(),m_product_id);\n  MWarehouse wh=MWarehouse.get(getCtx(),m_warehouse_id);\n  String title=product.get_Translation(MProduct.COLUMNNAME_Name) + \" - \" + wh.get_Translation(MWarehouse.COLUMNNAME_Name);\n  PAttributeInstance pai=new PAttributeInstance(m_frame,title,m_warehouse_id,0,m_product_id,0);\n  if (pai.getM_AttributeSetInstance_ID() != -1) {\n    fAttrSetInstance_ID.setText(pai.getM_AttributeSetInstanceName());\n    fAttrSetInstance_ID.setValue(new Integer(pai.getM_AttributeSetInstance_ID()));\n  }\n else {\n    fAttrSetInstance_ID.setValue(Integer.valueOf(0));\n  }\n}\n", "docstring": "filter by attribute set instance", "partition": "test"}
{"idx": "2298", "code": "private void ensureFileOpen(){\n  if (savingDisabled) {\n    Log.e(TAG,\"Saving disabled but tried to ensureFileOpen\");\n    return;\n  }\n  if (saveFileStream != null)   return;\n  File saveFile=new File(ctx.getFilesDir(),SAVEFILE);\n  try {\n    FileOutputStream fileOutput=null;\n    DataOutputStream out=null;\n    if (saveFile.exists()) {\n      fileOutput=ctx.openFileOutput(SAVEFILE,Context.MODE_APPEND);\n      out=new DataOutputStream(new BufferedOutputStream(fileOutput));\n    }\n else {\n      fileOutput=ctx.openFileOutput(SAVEFILE,Context.MODE_PRIVATE);\n      out=new DataOutputStream(new BufferedOutputStream(fileOutput));\n      out.writeInt(TrackPoint.FORMAT_VERSION);\n      savedTrackPoints=0;\n    }\n    saveFileStream=out;\n  }\n catch (  Exception e) {\n    markSavingBroken(\"Failed to open track save file\",e);\n  }\n}\n", "docstring": "opens the savefilestream if necessary", "partition": "test"}
{"idx": "2299", "code": "public void test_canonicalizingCache(){\n  final Properties properties=getProperties();\n  properties.setProperty(AbstractTransactionService.Options.MIN_RELEASE_AGE,\"5000\");\n  final Journal journal=new Journal(properties);\n  try {\n    final long commitTime0=journal.commit();\n    assertTrue(commitTime0 != 0L);\n    final ICommitRecord commitRecord0=journal.getCommitRecord(commitTime0);\n    assertEquals(commitRecord0,journal.getCommitRecord());\n    journal.write(ByteBuffer.wrap(new byte[]{1,2,3}));\n    final long commitTime1=journal.commit();\n    assertTrue(commitTime1 != 0L);\n    final ICommitRecord commitRecord1=journal.getCommitRecord(commitTime1);\n    assertEquals(commitRecord1,journal.getCommitRecord());\n    assertTrue(commitRecord0 == journal.getCommitRecord(commitTime1 - 1));\n    assertTrue(commitRecord1 == journal.getCommitRecord(commitTime1 + 0));\n    assertTrue(commitRecord1 == journal.getCommitRecord(commitTime1 + 1));\n  }\n  finally {\n    journal.destroy();\n  }\n}\n", "docstring": "test verifies that exact match and find always return the same reference for the same commit record ( at least as long as the test holds a hard reference to the commit record of interest ) .", "partition": "test"}
{"idx": "2300", "code": "@Override public void stop(Runnable arg0){\n  stop();\n  arg0.run();\n}\n", "docstring": "smart lifecycle stop implementation . closes the db connection pool .", "partition": "test"}
{"idx": "2301", "code": "protected int read(InputStream inputStream,byte[] buffer,char divider) throws IOException {\n  int index=0;\n  do {\n    byte readByte=(byte)(0x000000FF & inputStream.read());\n    if (readByte == -1 || readByte == (byte)divider) {\n      return index;\n    }\n    buffer[index]=readByte;\n    index++;\n  }\n while (index < buffer.length);\n  return index;\n}\n", "docstring": "reads bytes from a given file reader until either a certain character is read , the buffer is completely filled or the end of file is reached .", "partition": "test"}
{"idx": "2302", "code": "private static void generateGraphFile(TransMeta transMeta,String graphFile) throws GraphGeneratorException {\n  DataOutputStream dos=null;\n  try {\n    String xml=transMeta.getXML();\n    dos=new DataOutputStream(new FileOutputStream(new File(graphFile)));\n    dos.write(xml.getBytes(CarbonCommonConstants.DEFAULT_CHARSET));\n  }\n catch (  KettleException kettelException) {\n    throw new GraphGeneratorException(\"Error while getting the graph XML\",kettelException);\n  }\ncatch (  FileNotFoundException e) {\n    throw new GraphGeneratorException(\"Unable to find the graph fileL\",e);\n  }\ncatch (  UnsupportedEncodingException ue) {\n    throw new GraphGeneratorException(\"Error while Converting the graph xml string to bytes\",ue);\n  }\ncatch (  IOException ioe) {\n    throw new GraphGeneratorException(\"Error while writing the graph file\",ioe);\n  }\n finally {\n    if (dos != null) {\n      try {\n        dos.close();\n      }\n catch (      IOException e) {\n        e.getMessage();\n      }\n    }\n  }\n}\n", "docstring": "generate the graph file . . .", "partition": "test"}
{"idx": "2303", "code": "private void testMultiStatement(){\n  MVStore s=MVStore.open(null);\n  TransactionStore ts=new TransactionStore(s);\n  ts.init();\n  Transaction tx;\n  TransactionMap<String,String> m;\n  long startUpdate;\n  tx=ts.begin();\n  startUpdate=tx.setSavepoint();\n  m=tx.openMap(\"test\");\n  m.setSavepoint(startUpdate);\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertTrue(m.trySet(\"1\",\"Hello\",true));\n  assertTrue(m.trySet(\"2\",\"World\",true));\n  assertNull(m.get(\"1\"));\n  assertNull(m.get(\"2\"));\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertEquals(\"Hello\",m.get(\"1\"));\n  assertEquals(\"World\",m.get(\"2\"));\n  assertEquals(\"Hello\",m.get(\"1\"));\n  assertTrue(m.trySet(\"1\",null,true));\n  assertTrue(m.trySet(\"2\",\"Hello\",true));\n  assertEquals(\"World\",m.get(\"2\"));\n  assertTrue(m.trySet(\"2\",null,true));\n  assertTrue(m.trySet(\"3\",\"World\",true));\n  assertEquals(\"Hello\",m.get(\"1\"));\n  assertEquals(\"World\",m.get(\"2\"));\n  assertNull(m.get(\"3\"));\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertNull(m.get(\"1\"));\n  assertEquals(\"Hello\",m.get(\"2\"));\n  assertEquals(\"World\",m.get(\"3\"));\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertTrue(m.trySet(\"2\",null,true));\n  assertTrue(m.trySet(\"1\",\"Hello\",true));\n  assertTrue(m.trySet(\"3\",null,true));\n  assertFalse(m.trySet(\"1\",\"World\",true));\n  tx.rollbackToSavepoint(startUpdate);\n  startUpdate=tx.setSavepoint();\n  m.setSavepoint(startUpdate);\n  assertNull(m.get(\"1\"));\n  assertEquals(\"Hello\",m.get(\"2\"));\n  assertEquals(\"World\",m.get(\"3\"));\n  tx.commit();\n  ts.close();\n  s.close();\n}\n", "docstring": "tests behavior when used for a sequence of sql statements . each statement uses a savepoint . within a statement , changes by the statement itself are not seen ; the change is only seen when the statement finished . < p > update statements that change the key of multiple rows may use delete / add pairs to do so ( they don \"'\" t need to first delete all entries and then re - add them ) . trying to add multiple values for the same key is not allowed ( an update statement that would result in a duplicate key ) .", "partition": "test"}
{"idx": "2304", "code": "public void createEntityConfig(String realm,FederationConfigElement config) throws WSFederationMetaException {\n  String federationId=config.getFederationID();\n  if (federationId == null) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig: \" + \"entity ID is null\");\n    String[] data={realm};\n    LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_ID_CREATE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(\"empty_entityid\",null);\n  }\n  if (realm == null) {\n    realm=\"/\";\n  }\n  String[] objs={federationId,realm};\n  try {\n    Map attrs=WSFederationMetaUtils.convertJAXBToAttrMap(ATTR_ENTITY_CONFIG,config);\n    Map oldAttrs=configInst.getConfiguration(realm,federationId);\n    if (oldAttrs == null) {\n      LogUtil.error(Level.INFO,LogUtil.NO_ENTITY_DESCRIPTOR_CREATE_ENTITY_CONFIG,objs,null);\n      throw new WSFederationMetaException(\"entity_descriptor_not_exist\",objs);\n    }\n    Set oldValues=(Set)oldAttrs.get(ATTR_ENTITY_CONFIG);\n    if (oldValues != null && !oldValues.isEmpty()) {\n      LogUtil.error(Level.INFO,LogUtil.ENTITY_CONFIG_EXISTS,objs,null);\n      throw new WSFederationMetaException(\"entity_config_exists\",objs);\n    }\n    configInst.setConfiguration(realm,federationId,attrs);\n    LogUtil.access(Level.INFO,LogUtil.ENTITY_CONFIG_CREATED,objs,null);\n    SPSSOConfigElement spconfig=getSPSSOConfig(realm,federationId);\n    if (spconfig != null) {\n      addToCircleOfTrust(spconfig,realm,federationId);\n    }\n    IDPSSOConfigElement idpconfig=getIDPSSOConfig(realm,federationId);\n    if (idpconfig != null) {\n      addToCircleOfTrust(idpconfig,realm,federationId);\n    }\n  }\n catch (  ConfigurationException e) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig:\",e);\n    String[] data={e.getMessage(),federationId,realm};\n    LogUtil.error(Level.INFO,LogUtil.CONFIG_ERROR_CREATE_ENTITY_CONFIG,data,null);\n    throw new WSFederationMetaException(e);\n  }\ncatch (  JAXBException jaxbe) {\n    debug.error(\"WSFederationMetaManager.createEntityConfig:\",jaxbe);\n    LogUtil.error(Level.INFO,LogUtil.CREATE_INVALID_ENTITY_CONFIG,objs,null);\n    throw new WSFederationMetaException(\"invalid_config\",objs);\n  }\n}\n", "docstring": "creates the extended entity configuration under the realm .", "partition": "test"}
{"idx": "2305", "code": "private void loadUserInfoIntoActionBar(){\n  if (!TextUtils.isEmpty(mWithUserImage)) {\n    Utils.loadCircularImage(getActivity(),mWithImageView,mWithUserImage,AvatarBitmapTransformation.AvatarSize.NORMAL);\n  }\n}\n", "docstring": "loads the user image into the action bar profile pic", "partition": "test"}
{"idx": "2306", "code": "public static Direction directionForArrowKey(KeyEvent e){\n  int index=Math.max(0,Math.min(e.getKeyCode(),KeyEvent.VK_DOWN) - KeyEvent.VK_LEFT);\n  return Direction.values()[index];\n}\n", "docstring": "returns a direction corresponding to the specified arrow key . if the event does not map to one of the 4 keyboard arrows , the returned direction will be either left or down .", "partition": "test"}
{"idx": "2307", "code": "public TraceGraph(Collection<Span> spans){\n  this.spansByParent=new SpansByParent(spans);\n  this.spansByTracerId=new SpansByTracerId(spans);\n}\n", "docstring": "create a new tracegraph", "partition": "test"}
{"idx": "2308", "code": "public static java.util.Date toDate(String monthStr,String dayStr,String yearStr,String hourStr,String minuteStr,String secondStr){\n  int month, day, year, hour, minute, second;\n  try {\n    month=Integer.parseInt(monthStr);\n    day=Integer.parseInt(dayStr);\n    year=Integer.parseInt(yearStr);\n    hour=Integer.parseInt(hourStr);\n    minute=Integer.parseInt(minuteStr);\n    second=Integer.parseInt(secondStr);\n  }\n catch (  Exception e) {\n    return null;\n  }\n  return toDate(month,day,year,hour,minute,second);\n}\n", "docstring": "makes a date from separate strings for month , day , year , hour , minute , and second .", "partition": "test"}
{"idx": "2309", "code": "protected void handleMesosFailure(String taskId){\n  int attempt=TaskUtils.getAttemptForTaskId(taskId);\n  BaseContainer container=containersInfo.get(TaskUtils.getContainerIndexForTaskId(taskId));\n  boolean hasAttemptsLeft=attempt < container.retries;\n  if (hasAttemptsLeft) {\n    LOG.warning(String.format(\"Retrying task: %s, attempt: %d\",container.name,attempt + 1));\n    String newTaskId=TaskUtils.getTaskId(container.name,attempt + 1);\n    scheduleNewTask(newTaskId);\n  }\n else {\n    LOG.severe(\"Would not restart the job since it is beyond retries: \" + attempt);\n  }\n}\n", "docstring": "restart a failed task unless exceeding the retires limitation", "partition": "test"}
{"idx": "2310", "code": "private void updateLtp(SingleChannelElement sce){\n  IndividualChannelStream ics=sce.ics;\n  float saved[]=sce.saved;\n  float savedLtp[]=sce.coeffs;\n  final float lwindow[]=ics.useKbWindow[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n  final float swindow[]=ics.useKbWindow[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n  if (ics.windowSequence[0] == EIGHT_SHORT_SEQUENCE) {\n    System.arraycopy(saved,0,savedLtp,0,512);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else   if (ics.windowSequence[0] == LONG_START_SEQUENCE) {\n    System.arraycopy(ac.bufMdct,512,savedLtp,0,448);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else {\n    FloatDSP.vectorFmulReverse(savedLtp,0,ac.bufMdct,512,lwindow,512,512);\n    for (int i=0; i < 512; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * lwindow[511 - i];\n    }\n  }\n  System.arraycopy(sce.ltpState,1024,sce.ltpState,0,1024);\n  System.arraycopy(sce.ret,0,sce.ltpState,1024,1024);\n  System.arraycopy(savedLtp,0,sce.ltpState,2048,1024);\n}\n", "docstring": "update the ltp buffer for next frame", "partition": "test"}
{"idx": "2311", "code": "public static File findConfigInWorkingDirectory(){\n  for (  final String suffix : SUFFIXES) {\n    final File configFile=new File(System.getProperty(\"user.dir\"),PREFIX + suffix);\n    if (configFile.isFile()) {\n      return configFile;\n    }\n  }\n  return null;\n}\n", "docstring": "finds a log4j configuration file in the current working directory . the names of the files to look for are the same as those that log4j would look for on the classpath .", "partition": "test"}
{"idx": "2312", "code": "@Override public void drawRangeMarker(Graphics2D g2,XYPlot plot,ValueAxis rangeAxis,Marker marker,Rectangle2D dataArea){\n  if (marker instanceof ValueMarker) {\n    ValueMarker vm=(ValueMarker)marker;\n    double value=vm.getValue();\n    Range range=rangeAxis.getRange();\n    if (!range.contains(value)) {\n      return;\n    }\n    double v=rangeAxis.valueToJava2D(value,dataArea,plot.getRangeAxisEdge());\n    PlotOrientation orientation=plot.getOrientation();\n    Line2D line=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      line=new Line2D.Double(v,dataArea.getMinY(),v,dataArea.getMaxY());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      line=new Line2D.Double(dataArea.getMinX(),v,dataArea.getMaxX(),v);\n    }\n else {\n      throw new IllegalStateException(\"Unrecognised orientation.\");\n    }\n    final Composite originalComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    g2.setPaint(marker.getPaint());\n    g2.setStroke(marker.getStroke());\n    g2.draw(line);\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,line.getBounds2D(),marker.getLabelOffset(),LengthAdjustmentType.EXPAND,anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(originalComposite);\n  }\n else   if (marker instanceof IntervalMarker) {\n    IntervalMarker im=(IntervalMarker)marker;\n    double start=im.getStartValue();\n    double end=im.getEndValue();\n    Range range=rangeAxis.getRange();\n    if (!(range.intersects(start,end))) {\n      return;\n    }\n    double start2d=rangeAxis.valueToJava2D(start,dataArea,plot.getRangeAxisEdge());\n    double end2d=rangeAxis.valueToJava2D(end,dataArea,plot.getRangeAxisEdge());\n    double low=Math.min(start2d,end2d);\n    double high=Math.max(start2d,end2d);\n    PlotOrientation orientation=plot.getOrientation();\n    Rectangle2D rect=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      low=Math.max(low,dataArea.getMinX());\n      high=Math.min(high,dataArea.getMaxX());\n      rect=new Rectangle2D.Double(low,dataArea.getMinY(),high - low,dataArea.getHeight());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      low=Math.max(low,dataArea.getMinY());\n      high=Math.min(high,dataArea.getMaxY());\n      rect=new Rectangle2D.Double(dataArea.getMinX(),low,dataArea.getWidth(),high - low);\n    }\n    final Composite originalComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    Paint p=marker.getPaint();\n    if (p instanceof GradientPaint) {\n      GradientPaint gp=(GradientPaint)p;\n      GradientPaintTransformer t=im.getGradientPaintTransformer();\n      if (t != null) {\n        gp=t.transform(gp,rect);\n      }\n      g2.setPaint(gp);\n    }\n else {\n      g2.setPaint(p);\n    }\n    g2.fill(rect);\n    if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n      if (orientation == PlotOrientation.VERTICAL) {\n        Line2D line=new Line2D.Double();\n        double x0=dataArea.getMinX();\n        double x1=dataArea.getMaxX();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(x0,start2d,x1,start2d);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(x0,end2d,x1,end2d);\n          g2.draw(line);\n        }\n      }\n else {\n        Line2D line=new Line2D.Double();\n        double y0=dataArea.getMinY();\n        double y1=dataArea.getMaxY();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(start2d,y0,start2d,y1);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(end2d,y0,end2d,y1);\n          g2.draw(line);\n        }\n      }\n    }\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,rect,marker.getLabelOffset(),marker.getLabelOffsetType(),anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(originalComposite);\n  }\n}\n", "docstring": "draws a line on the chart perpendicular to the y - axis to mark a value or range of values .", "partition": "test"}
{"idx": "2313", "code": "protected boolean attemptToAddWord(Word word){\n  double additionalLength=word.getWordWidth();\n  additionalLength+=!words.isEmpty() ? spaceSize : 0;\n  if (currentLineLength + additionalLength <= maxLength || maxLength == -1) {\n    words.add(word);\n    currentLineLength+=additionalLength;\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "attempt to add a word to the line . if the line can fit the word in without reaching the maximum line length then the word is added and the line length increased .", "partition": "test"}
{"idx": "2314", "code": "@Override public boolean onPreferenceClick(Preference preference){\n  if (preference == mPlayExample) {\n    getSampleText();\n    return true;\n  }\n  return false;\n}\n", "docstring": "called when mplayexample is clicked", "partition": "test"}
{"idx": "2315", "code": "public void readWwwAuthenticateHeader(String header){\n  if (header != null) {\n    mIsDigestAuthentication=header.startsWith(HttpDigestMd5Authentication.HTTP_DIGEST_SCHEMA);\n    if (!mIsDigestAuthentication) {\n      return;\n    }\n    String value=getValue(header,\"realm\");\n    mDigest.setRealm(value);\n    value=getValue(header,\"opaque\");\n    mDigest.setOpaque(value);\n    value=getValue(header,\"qop\");\n    mDigest.setQop(value);\n    value=getValue(header,\"nonce\");\n    mDigest.setNextnonce(value);\n  }\n}\n", "docstring": "read the www - authenticate header", "partition": "test"}
{"idx": "2316", "code": "public static String valueOf(Boolean value){\n  return value != null ? String.valueOf(value) : null;\n}\n", "docstring": "returns the string value of the given boolean . returns null if argument is null .", "partition": "test"}
{"idx": "2317", "code": "public void testSendReceive() throws Exception {\n  messages.clear();\n  for (int i=0; i < data.length; i++) {\n    Message message=session.createTextMessage(data[i]);\n    message.setStringProperty(\"stringProperty\",data[i]);\n    message.setIntProperty(\"intProperty\",i);\n    if (verbose) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"About to send a message: \" + message + \" with text: \"+ data[i]);\n      }\n    }\n    sendToProducer(producer,producerDestination,message);\n    messageSent();\n  }\n  assertMessagesAreReceived();\n  LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n}\n", "docstring": "sends and consumes the messages .", "partition": "test"}
{"idx": "2318", "code": "public AllocationSite(int line,int column){\nsynchronized (sites) {\n    this.id=sites.size();\n    sites.add(this);\n  }\n  this.line=line;\n  this.column=column;\n}\n", "docstring": "create an allocation site for a given source code line / column .", "partition": "test"}
{"idx": "2319", "code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver obs){\n  return mGraphics.drawImage(img,xform,obs);\n}\n", "docstring": "draws an image , applying a transform from image space into user space before drawing . the transformation from user space into device space is done with the current transform in the graphics2d . the given transformation is applied to the image before the transform attribute in the graphics2d state is applied . the rendering attributes applied include the clip , transform , and composite attributes . note that the result is undefined , if the given transform is noninvertible .", "partition": "test"}
{"idx": "2320", "code": "public final static int parseInt(char[] digitChars,int offset,int len){\n  int num=digitChars[offset] - '0';\n  len+=offset;\n  if (++offset < len) {\n    num=(num * 10) + (digitChars[offset] - '0');\n    if (++offset < len) {\n      num=(num * 10) + (digitChars[offset] - '0');\n      if (++offset < len) {\n        num=(num * 10) + (digitChars[offset] - '0');\n        if (++offset < len) {\n          num=(num * 10) + (digitChars[offset] - '0');\n          if (++offset < len) {\n            num=(num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n              num=(num * 10) + (digitChars[offset] - '0');\n              if (++offset < len) {\n                num=(num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                  num=(num * 10) + (digitChars[offset] - '0');\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return num;\n}\n", "docstring": "fast method for parsing integers that are known to fit into regular 32 - bit signed int type . this means that length is between 1 and 9 digits ( inclusive ) < p > note : public to let unit tests call it", "partition": "test"}
{"idx": "2321", "code": "public ActivityMonitorSample(){\n  initComponents();\n  ownerARadio.setActionCommand(\"A\");\n  ownerBRadio.setActionCommand(\"B\");\n  ownerCRadio.setActionCommand(\"C\");\n  indicatorA.setActivityOwner(\"A\");\n  indicatorB.setActivityOwner(\"B\");\n  indicatorC.setActivityOwner(\"C\");\n  JActivityWindow.getInstance();\n}\n", "docstring": "creates new form activitymonitorsample", "partition": "test"}
{"idx": "2322", "code": "public static LatLon[] greatCircleExtremeLocations(LatLon location,Angle azimuth){\n  if (location == null) {\n    throw new IllegalArgumentException(\"Location Is Null\");\n  }\n  if (azimuth == null) {\n    throw new IllegalArgumentException(\"Azimuth Is Null\");\n  }\n  double lat0=location.getLatitude().radians;\n  double az=azimuth.radians;\n  double tanDistance=-Math.tan(lat0) / Math.cos(az);\n  double distance=Math.atan(tanDistance);\n  Angle extremeDistance1=Angle.fromRadians(distance + (Math.PI / 2.0));\n  Angle extremeDistance2=Angle.fromRadians(distance - (Math.PI / 2.0));\n  return new LatLon[]{greatCircleEndPosition(location,azimuth,extremeDistance1),greatCircleEndPosition(location,azimuth,extremeDistance2)};\n}\n", "docstring": "returns two locations with the most extreme latitudes on the great circle with the given starting location and azimuth .", "partition": "test"}
{"idx": "2323", "code": "private void initCheckbox(CheckBoxPreference checkbox,boolean checked,boolean enabled){\n  checkbox.setChecked(checked);\n  checkbox.setEnabled(enabled);\n}\n", "docstring": "initialize the service activation checkbox", "partition": "test"}
{"idx": "2324", "code": "private void paintCheckIconEnabledAndSelected(Graphics2D g,int width,int height){\n  Shape s=shapeGenerator.createCheckMark(0,0,width,height);\n  g.setPaint(iconEnabledSelected);\n  g.fill(s);\n}\n", "docstring": "paint the check mark in enabled state .", "partition": "test"}
{"idx": "2325", "code": "public static int findURISplitIndex(String uri){\n  int uriLength=uri.length();\n  int idx=uriLength - 1;\n  for (; idx >= 0; idx--) {\n    if (!TurtleUtil.isNameChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  idx++;\n  for (; idx < uriLength; idx++) {\n    if (TurtleUtil.isNameStartChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  if (!TurtleUtil.isNameEndChar(uri.charAt(uriLength - 1))) {\n    return -1;\n  }\n  if (idx > 0 && idx < uriLength) {\n    return idx;\n  }\n  return -1;\n}\n", "docstring": "tries to find an index where the supplied uri can be split into a namespace and a local name that comply with the serialization constraints of the turtle format .", "partition": "test"}
{"idx": "2326", "code": "private void writeLog(String cmd){\n  try {\n    if (m_writer == null) {\n      File file=File.createTempFile(\"create\",\".log\");\n      m_writer=new PrintWriter(new FileWriter(file));\n      log.info(file.toString());\n    }\n    m_writer.println(cmd);\n    m_writer.flush();\n  }\n catch (  Exception e) {\n    log.severe(e.toString());\n  }\n}\n", "docstring": "write to file log", "partition": "test"}
{"idx": "2327", "code": "public void reload(String why){\n  mFullPhotoPaths=mRootDir.list(MediaScanner.JPG_FILENAME_FILTER);\n  if ((mFullPhotoPaths != null) && (mFullPhotoPaths.length == 0)) {\n    mFullPhotoPaths=null;\n    Log.i(Global.LOG_CONTEXT,mDebugPrefix + why + \"AdapterArrayHelper.refreshLocal(\"+ mRootDir+ \") \"+ 0);\n  }\n else   if (mFullPhotoPaths != null) {\n    if (Global.debugEnabled) {\n      Log.i(Global.LOG_CONTEXT,mDebugPrefix + why + \"AdapterArrayHelper.refreshLocal(\"+ mRootDir+ \") \"+ mFullPhotoPaths.length);\n    }\n    String parentDirString=mRootDir.getAbsolutePath();\n    for (int i=0; i < mFullPhotoPaths.length; i++) {\n      mFullPhotoPaths[i]=parentDirString + \"/\" + mFullPhotoPaths[i];\n    }\n  }\n}\n", "docstring": "refreshlocal files from inital path", "partition": "test"}
{"idx": "2328", "code": "protected void addContentSpecToElement(XMLElementDecl elementDecl){\n  if ((fDepth == 0 || (fDepth == 1 && elementDecl.type == XMLElementDecl.TYPE_MIXED)) && fNodeIndexStack != null) {\n    if (elementDecl.type == XMLElementDecl.TYPE_MIXED) {\n      int pcdata=addUniqueLeafNode(null);\n      if (fNodeIndexStack[0] == -1) {\n        fNodeIndexStack[0]=pcdata;\n      }\n else {\n        fNodeIndexStack[0]=addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_CHOICE,pcdata,fNodeIndexStack[0]);\n      }\n    }\n    setContentSpecIndex(fCurrentElementIndex,fNodeIndexStack[fDepth]);\n  }\n}\n", "docstring": "adds the content spec to the given element declaration .", "partition": "test"}
{"idx": "2329", "code": "private void growSpine(){\n  spine=new int[(spine.length << 1) + 1];\n  threshold=(int)(spine.length * loadFactor);\n  Arrays.fill(spine,-1);\n  for (int i=0; i < size; i++) {\n    insert(objs[i],i);\n  }\n}\n", "docstring": "expands the hash \" spine \" - - equivalent to increasing the number of buckets in a conventional hash table .", "partition": "test"}
{"idx": "2330", "code": "public void reconnect(){\n  if (opened && !allowConnectionRecovery) {\n    return;\n  }\n  reconnectwait thread=new reconnectwait();\n  thread.start();\n  try {\n    thread.join();\n  }\n catch (  InterruptedException e) {\n    log.error(\"Unable to join to the reconnection thread \" + e.getMessage());\n  }\n  if (!opened) {\n    log.error(\"Failed to re-establish connectivity\");\n  }\n else {\n    log.info(\"Reconnected to \" + getCurrentPortName());\n    resetupConnection();\n  }\n}\n", "docstring": "attempts to reconnect to a failed server", "partition": "test"}
{"idx": "2331", "code": "public Collection<GridPortRecord> records(){\nsynchronized (recs) {\n    return Collections.unmodifiableCollection(new ArrayList<>(recs));\n  }\n}\n", "docstring": "returns unmodifiable collections of records .", "partition": "test"}
{"idx": "2332", "code": "public boolean hasChangeEvent(String name){\n  if (var != null) {\n    List<MetaData> mdList=var.getMetaData(StandardDefs.MD_CHANGEEVENT);\n    if (mdList != null) {\n      for (int i=0, size=mdList.size(); i < size; i++) {\n        MetaData md=mdList.get(i);\n        if (name.equals(md.getValue(0))) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "[ changeevent ", "partition": "test"}
{"idx": "2333", "code": "public float distanceToOtherCircle(Circle circle){\n  return (float)Math.abs(Math.sqrt(Math.pow(circle.center.x - center.x,2) + Math.pow(circle.center.y - center.y,2)));\n}\n", "docstring": "distance between circle center", "partition": "test"}
{"idx": "2334", "code": "public SimpleCommand(String commandName,String... args){\n  this(commandName,(Argument)null);\n  ArrayList<Argument> argList=new ArrayList<Argument>();\n  for (  String arg : args)   argList.add(new Argument(arg));\n  _arguments=argList.toArray(new Argument[0]);\n}\n", "docstring": "constructs a simplecommand from the given command name and the list of arguments .", "partition": "test"}
{"idx": "2335", "code": "public PickingGraphMousePlugin(int selectionModifiers,int addToSelectionModifiers){\n  super(selectionModifiers);\n  this.addToSelectionModifiers=addToSelectionModifiers;\n  this.lensPaintable=new LensPaintable();\n  this.cursor=Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);\n}\n", "docstring": "create an instance with overides", "partition": "test"}
{"idx": "2336", "code": "public int[] breadthFirstSearch(int intialValue,IBFSTraversable<N> traversable,int firstValue,IIntegerBfsNextValueIterator<N> nextValueIterator,List<Integer> sourcesIndex){\n  int[] results=new int[nodes.length];\n  Arrays.fill(results,intialValue);\n  boolean[] alreadyScanned=new boolean[nodes.length];\n  Arrays.fill(alreadyScanned,false);\n  Set<Integer> currentNodesIndex=new HashSet<>(sourcesIndex);\n  iterativeIntegerBreadthFirstSearch(results,alreadyScanned,currentNodesIndex,firstValue,0,traversable,nextValueIterator);\n  return results;\n}\n", "docstring": "breadth - first search implementation for integers . see double implementation for the parameters details . note that for compilation reasons parameters are in a different order compared to the double version hint : you can compute distances by providing to the sources by providing a + 1 next value visitor", "partition": "test"}
{"idx": "2337", "code": "public ViewRefRender(ViewRender<T> view,Class<T> type,int priority){\n  Objects.requireNonNull(view);\n  _view=view;\n  _type=type;\n  _priority=priority;\n}\n", "docstring": "creates the view and analyzes the type", "partition": "test"}
{"idx": "2338", "code": "private boolean announce(String[] groups){\n  if (dataPackets == null || !lastLocator.equals(myLocator) || !Arrays.equals(lastGroups,groups)) {\n    List<DatagramPacket> packets=new ArrayList<DatagramPacket>();\n    Discovery disco;\n    try {\n      disco=getDiscovery(multicastAnnouncementConstraints.chooseProtocolVersion());\n    }\n catch (    DiscoveryProtocolException e) {\n      throw new AssertionError(e);\n    }\n    EncodeIterator ei=disco.encodeMulticastAnnouncement(new MulticastAnnouncement(announcementSeqNo++,myLocator.getHost(),myLocator.getPort(),groups,myServiceID),multicastAnnouncementConstraints.getMulticastMaxPacketSize(DEFAULT_MAX_PACKET_SIZE),multicastAnnouncementConstraints.getUnfulfilledConstraints());\n    while (ei.hasNext()) {\n      try {\n        packets.addAll(Arrays.asList(ei.next()));\n      }\n catch (      Exception e) {\n        logger.log((e instanceof UnsupportedConstraintException) ? Levels.HANDLED : Level.INFO,\"exception encoding multicast\" + \" announcement\",e);\n      }\n    }\n    lastLocator=myLocator;\n    lastGroups=groups;\n    dataPackets=packets.toArray(new DatagramPacket[packets.size()]);\n  }\n  try {\n    send(dataPackets);\n  }\n catch (  InterruptedIOException e) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "announce membership in the specified groups , and return false if interrupted , otherwise return true . this method is run from synchronized run method in thread .", "partition": "test"}
{"idx": "2339", "code": "public DrawingAttributes(){\n  propertyChangeSupport=new PropertyChangeSupport(this);\n}\n", "docstring": "create a drawingattributes with the default settings - clear fill paint and pattern , sold black edge line of width 1 .", "partition": "test"}
{"idx": "2340", "code": "static void createPolicyTree(String configName,String configId,ServiceConfigManager scm,String org) throws NoPermissionException, PolicyException, SSOException {\n  try {\n    ServiceConfig pConfig=scm.getOrganizationConfig(org,null);\n    if (pConfig == null) {\n      scm.createOrganizationConfig(org,null);\n      pConfig=scm.getOrganizationConfig(org,null);\n    }\n    pConfig.addSubConfig(configName,configId,0,null);\n  }\n catch (  ServiceAlreadyExistsException se) {\n    if (debug.messageEnabled()) {\n      debug.message(\"PolicyManager->createPolicyTree: Name: \" + configName + \" ID: \"+ configId+ \" Policy service already exists under org->\"+ org);\n    }\n  }\ncatch (  SMSException e) {\n    String[] objs={org};\n    if (e.getExceptionCode() == SMSException.STATUS_NO_PERMISSION) {\n      throw (new NoPermissionException(ResBundleUtils.rbName,\"insufficient_access_rights\",null));\n    }\n else {\n      throw (new PolicyException(ResBundleUtils.rbName,\"unable_to_create_policy_for_org\",objs,e));\n    }\n  }\n}\n", "docstring": "creates the policy tree , ou = policy , ou = services , . . .", "partition": "test"}
{"idx": "2341", "code": "private void rollbackMethodForCreateSnapshot(boolean isSnapshotCreated,boolean isDummyLunPathAdded,HDSApiClient hdsApiClient,StorageSystem storage,URI snapshot) throws Exception {\n  if (isDummyLunPathAdded) {\n    log.info(\"Remove dummy path while doing roll back\");\n    hdsProtectionOperations.removeDummyLunPath(storage,snapshot);\n  }\n  if (isSnapshotCreated) {\n    log.info(\"Remove snapshot volume for roll back\");\n    BlockSnapshot snapshotObj=dbClient.queryObject(BlockSnapshot.class,snapshot);\n    String systemObjectID=HDSUtils.getSystemObjectID(storage);\n    String logicalUnitObjId=HDSUtils.getLogicalUnitObjectId(snapshotObj.getNativeId(),storage);\n    hdsApiClient.deleteSnapshotVolume(systemObjectID,logicalUnitObjId,storage.getModel());\n  }\n}\n", "docstring": "roll back method to clean up stale snapshot volume on storage system", "partition": "test"}
{"idx": "2342", "code": "public static int convertStringToTimeSeconds(String time){\n  int result=0;\n  if (time.endsWith(\"H\")) {\n    int hoursToAdd=Integer.valueOf(StringUtils.remove(time,\'H\'));\n    result=(60 * 60) * hoursToAdd;\n  }\n else   if (time.endsWith(\"M\")) {\n    int minsToAdd=Integer.valueOf(StringUtils.remove(time,\'M\'));\n    result=60 * minsToAdd;\n  }\n else   if (time.endsWith(\"S\")) {\n    int secsToAdd=Integer.valueOf(StringUtils.remove(time,\'S\'));\n    result=secsToAdd;\n  }\n  return result;\n}\n", "docstring": "converts a string denoting an amount of time into seconds . strings are expected to follow this form where # equals a digit : # m the following are permitted for denoting time : h = hours , m = minutes , s = seconds", "partition": "test"}
{"idx": "2343", "code": "public void detach(AppCompatActivity activity){\n  attrViewMaps.remove(activity.hashCode());\n}\n", "docstring": "this method should be called in activity ondestroy method", "partition": "test"}
{"idx": "2344", "code": "public void readPrefs(SharedPreferences settings,ActionFactory factory){\n  boolean visible=false;\n  String actionId=settings.getString(\"button_action_\" + name + \"_0\",\"\");\n  mainAction=factory.getAction(actionId);\n  if (mainAction != null)   visible=true;\n  menuActions.clear();\n  for (int i=0; i < maxMenuActions; i++) {\n    actionId=settings.getString(\"button_action_\" + name + \"_\"+ (i + 1),\"\");\n    UIAction a=factory.getAction(actionId);\n    if (a != null)     visible=true;\n    menuActions.add(a);\n  }\n  if (button != null)   button.setVisibility(visible ? View.VISIBLE : View.GONE);\n}\n", "docstring": "update button actions from preferences settings .", "partition": "test"}
{"idx": "2345", "code": "public boolean addToActiveList(DownloadInfoRunnable downloadInfoRunnable){\n  return activeListHasRoom() && mActiveList.add(downloadInfoRunnable);\n}\n", "docstring": "tries to add a download object to the active list . will not work if the max number of downloads is already reached .", "partition": "test"}
{"idx": "2346", "code": "private void addExprToTLA(TLAExpr expr){\n  Vector sv=expr.toStringVector();\n  Vector exprMapping=expr.toMappingVector();\n  int indent=tlacodeNextLine.length();\n  int nextLine=0;\n  if (indent != 0) {\n    MappingObject.shiftMappingVector(exprMapping,indent);\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n    nextLine=1;\n    if (sv.size() > 1) {\n      endCurrentLineOfTLA();\n    }\n  }\n  if (sv.size() > 1) {\n    String spaces=NSpaces(indent);\n    while (nextLine < sv.size() - 1) {\n      tlacode.addElement(spaces + ((String)sv.elementAt(nextLine)));\n      mappingVector.addElement((Vector)exprMapping.elementAt(nextLine));\n      nextLine++;\n    }\n    tlacodeNextLine=spaces + ((String)sv.elementAt(nextLine));\n    mappingVectorNextLine=(Vector)exprMapping.elementAt(nextLine);\n  }\n else   if (indent == 0) {\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n  }\n}\n", "docstring": "adds the expression to tlacode / tlacodenextline and its mapping to mappingvector / mappingvectornextline . it adds no space before the expression and leaves the last line of the expression ( which could be its first line ) at the end of tlacodenextline .", "partition": "test"}
{"idx": "2347", "code": "private boolean isUpperCaseCamelCaseHunk(String hunk){\n  if (hunk.length() < 2)   return false;\n  for (int i=0; i < hunk.length(); i++) {\n    if (!isLegalChar(hunk.charAt(i)))     return false;\n  }\n  return true;\n}\n", "docstring": "true if hunk is longer than 1 character and all letters in the hunk are uppercase . false if not .", "partition": "test"}
{"idx": "2348", "code": "public void type(String string){\n  for (int i=0; i < string.length(); i++) {\n    char c=string.charAt(i);\n    type(c);\n  }\n}\n", "docstring": "simulate keyboard type to type out a string . this types upper case letter by using shift + lower case letter . almost every typeable character on ansi keyboard is supported .", "partition": "test"}
{"idx": "2349", "code": "public boolean providesIdentifier(){\n  return false;\n}\n", "docstring": "simple registration doesn \"'\" t implement authentication services .", "partition": "test"}
{"idx": "2350", "code": "static void removeRedundantAffix(TranslatorUtils.IContain iContain,List<String> strList){\n  if (strList.size() <= 1) {\n    return;\n  }\n  int w=0;\n  for (  String str : strList) {\n    if (w == 0 || !iContain.containFunc(str,strList.get(w - 1))) {\n      strList.set(w,str);\n      w++;\n    }\n  }\n  strList=strList.subList(0,w);\n}\n", "docstring": "this function ensures that prefix / suffix sets aren \"'\" t redundant . for example , if we know \" ab \" is a possible prefix , then it doesn \"'\" t help at all to know that \" abc \" is also a possible prefix , so delete \" abc \" .", "partition": "test"}
{"idx": "2351", "code": "public static int nextInt(int n){\n  Random random=getRandom();\n  int value=random.nextInt(n);\n  if (!_isTest)   _freeRandomList.free(random);\n  return value;\n}\n", "docstring": "returns the next random int .", "partition": "test"}
{"idx": "2352", "code": "protected void doResumeUpdates(){\n  Calendar cal=Calendar.getInstance(Locale.getDefault());\n  mFirstDayOfWeek=cal.getFirstDayOfWeek() - 1;\n  mShowWeekNumber=false;\n  updateHeader();\n  goTo(mSelectedDay.toMillis(true),false,false,false);\n  mAdapter.setSelectedDay(mSelectedDay);\n  mTodayUpdater.run();\n}\n", "docstring": "updates the user preference fields . override this to use a different preference space .", "partition": "test"}
{"idx": "2353", "code": "private void storeLastUsed(){\n  put(LAST_USE,(int)(System.currentTimeMillis() / 1000));\n}\n", "docstring": "store current system time as the last used", "partition": "test"}
{"idx": "2354", "code": "private boolean canContain(ElementContainmentInfo child,ElementContainmentInfo top,int topIndex){\n  int childTypes=child.types;\n  int contents=top.contents;\n  int transparencyAllowed=childTypes & (top.transparentToContents & ~contents);\n  for (int containerIndex=topIndex - 1; transparencyAllowed != 0; --containerIndex) {\n    if (containerIndex < 0) {\n      contents|=transparencyAllowed;\n      break;\n    }\n    ElementContainmentInfo container=openElements.get(containerIndex);\n    contents|=transparencyAllowed & container.contents;\n    transparencyAllowed=transparencyAllowed & container.transparentToContents & ~contents;\n  }\n  return (contents & childTypes) != 0;\n}\n", "docstring": "takes into account transparency when figuring out what can be contained .", "partition": "test"}
{"idx": "2355", "code": "public static int[] extractArcs(ASN1ObjectIdentifier oid) throws InvalidObjectIdException {\n  String oidStr=oid.getId();\n  StringTokenizer strTokCnt=new StringTokenizer(oidStr,\".\",false);\n  int arcCount=strTokCnt.countTokens();\n  StringTokenizer strTok=new StringTokenizer(oidStr,\".\",true);\n  boolean expectDelimiter=false;\n  int[] arcs=new int[arcCount];\n  int i=0;\n  while (strTok.hasMoreTokens()) {\n    String token=strTok.nextToken();\n    if (expectDelimiter && (!token.equals(\".\") || !strTok.hasMoreTokens())) {\n      throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n    }\n else     if (!expectDelimiter) {\n      try {\n        arcs[i]=Integer.parseInt(token);\n        if (arcs[i] < 0) {\n          throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n        }\n        i++;\n      }\n catch (      NumberFormatException ex) {\n        throw new InvalidObjectIdException(res.getString(\"InvalidOidNotNonNegativeIntSequence.exception.message\"));\n      }\n    }\n    expectDelimiter=!expectDelimiter;\n  }\n  return arcs;\n}\n", "docstring": "extract the arcs from an object identifier .", "partition": "test"}
{"idx": "2356", "code": "public void testIsDuplicateString(){\n  int count=10000;\n  ActiveMQMessageAudit audit=new ActiveMQMessageAudit();\n  IdGenerator idGen=new IdGenerator();\n  List<String> list=new ArrayList<>();\n  for (int i=0; i < count; i++) {\n    String id=idGen.generateId();\n    list.add(id);\n    assertFalse(audit.isDuplicate(id));\n  }\n  List<String> windowList=list.subList(list.size() - 1 - audit.getAuditDepth(),list.size() - 1);\n  for (  String id : windowList) {\n    assertTrue(\"duplicate, id:\" + id,audit.isDuplicate(id));\n  }\n}\n", "docstring": "test case for isduplicate", "partition": "test"}
{"idx": "2357", "code": "protected void updateStatsForConditionalDensityEstimator(ConditionalDensityEstimator classifier,Instance classMissing,double classValue) throws Exception {\n  if (m_PriorEstimator == null) {\n    setNumericPriorsFromBuffer();\n  }\n  m_SumSchemeEntropy-=classifier.logDensity(classMissing,classValue) * classMissing.weight() / Utils.log2;\n  m_SumPriorEntropy-=m_PriorEstimator.logDensity(classValue) * classMissing.weight() / Utils.log2;\n}\n", "docstring": "updates stats for conditional density estimator based on current test instance .", "partition": "test"}
{"idx": "2358", "code": "@Override public boolean accept(File f){\n  if (f != null) {\n    if (f.isDirectory()) {\n      return true;\n    }\n    String extension=getExtension(f);\n    if (extension != null && filters.get(getExtension(f)) != null) {\n      return true;\n    }\n    ;\n  }\n  return false;\n}\n", "docstring": "return true if this file should be shown in the directory pane , false if it shouldn \"'\" t . files that begin with \" . \" are ignored .", "partition": "test"}
{"idx": "2359", "code": "@Override public PollResult startPoll(PollController conn){\n  if (!_lifecycle.isActive()) {\n    log.warning(this + \" select disabled\");\n    return PollResult.CLOSED;\n  }\n  SocketBar socket=conn.getSocket();\n  if (socket == null) {\n    log.warning(this + \" socket empty for \" + conn);\n    return PollResult.CLOSED;\n  }\n  SelectableChannel selChannel=socket.selectableChannel();\n  if (selChannel == null) {\n    log.warning(this + \" no channel for \" + socket);\n    return PollResult.CLOSED;\n  }\n  _connectionCount.incrementAndGet();\n  _activeCount.incrementAndGet();\n  _registerQueue.offer(conn);\n  return PollResult.START;\n}\n", "docstring": "adds a keepalive connection .", "partition": "test"}
{"idx": "2360", "code": "public ClusterPolicy createClusterPolicy(String clusterMemberName) throws CreateException {\n  long time1=System.currentTimeMillis();\n  if (_clusterPolicies == null) {\n    _clusterMemberNames=getClusterMemberNames();\n    if (_clusterMemberNames != null && _clusterMemberNames.length > 0) {\n      _clusterPolicies=new HashMap<String,ClusterPolicy>();\n      ClusterPolicy[] tempPolicy=new ClusterPolicy[_clusterMemberNames.length];\n      for (int i=0; i < _clusterMemberNames.length; i++)       tempPolicy[i]=createClusterPolicyInternal(_clusterMemberNames[i]);\n      ArrayList<ReplicationPolicy> selectedReplPolicies=new ArrayList<ReplicationPolicy>(_clusterMemberNames.length);\n      List<String> selectedReplGroupNames=new ArrayList<String>(_clusterMemberNames.length);\n      for (int i=0; i < tempPolicy.length; i++)       if (tempPolicy[i].m_ReplicationPolicy != null && !selectedReplGroupNames.contains(tempPolicy[i].m_ReplicationPolicy.m_ReplicationGroupName)) {\n        selectedReplPolicies.add(tempPolicy[i].m_ReplicationPolicy);\n        selectedReplGroupNames.add(tempPolicy[i].m_ReplicationPolicy.m_ReplicationGroupName);\n      }\n      if (selectedReplPolicies.isEmpty())       selectedReplPolicies=null;\n else       selectedReplPolicies.trimToSize();\n      for (int i=0; i < _clusterMemberNames.length; i++) {\n        tempPolicy[i].m_ReplicationGroups=selectedReplPolicies;\n        _clusterPolicies.put(_clusterMemberNames[i],tempPolicy[i]);\n      }\n    }\n  }\n  ClusterPolicy result=_clusterPolicies.get(clusterMemberName);\n  if (result == null)   result=createClusterPolicyInternal(clusterMemberName);\n  long time2=System.currentTimeMillis();\n  if (_logger.isLoggable(Level.FINE)) {\n    _logger.fine(\"Creation of ClusterPolicy instance for \\\"\" + clusterMemberName + \"\\\" cluster member took \"+ (time2 - time1)+ \" msec.\");\n  }\n  return result;\n}\n", "docstring": "creating cluster policy object .", "partition": "test"}
{"idx": "2361", "code": "public static boolean compareDoubles(double a,double b){\n  if (Double.isNaN(a) && Double.isNaN(b))   return true;\n  if (!Double.isInfinite(a) && !Double.isInfinite(b))   return Math.abs(a - b) <= EPSILON;\n  return a == b;\n}\n", "docstring": "compares two doubles for equality .", "partition": "test"}
{"idx": "2362", "code": "public ConfigureCoerceiveParsingDialog_NB(CoerciveParsing coerciveParsing){\n  this.coerciveParsing=coerciveParsing;\n  initComponents();\n  final IterateModel numberOfTagsIterator=coerciveParsing.getNumberOfTagsIterator();\n  configureIterateModel_NB2.setStartAt(String.valueOf(numberOfTagsIterator.getStartAt()));\n  configureIterateModel_NB2.setStopAt(String.valueOf(numberOfTagsIterator.getStopAt()));\n  configureIterateModel_NB2.setIncrement(String.valueOf(numberOfTagsIterator.getIncrement()));\n  configureIterateModel_NB2.setIterateStrategie(numberOfTagsIterator.getIterateStrategie());\n  List<String> tagNames=Arrays.asList(coerciveParsing.getTagNames());\n  configureStringList_NB1.setStringList(tagNames);\n}\n", "docstring": "creates new form configurecoerceiveparsingdialog_nb", "partition": "test"}
{"idx": "2363", "code": "public static double logOfBase(double number,int base){\n  return Math.log(number) / Math.log(base);\n}\n", "docstring": "gets the log at a certain base of a number .", "partition": "test"}
{"idx": "2364", "code": "public Entry editEntry(User user,String id,String note,String quotation,boolean isPublic,Long modTime,boolean isAdmin,Errors errors){\n  if (modTime == null) {\n    Errors.add(errors,errorMessages.errorModTimeIsNull());\n    return null;\n  }\n  if (user == null) {\n    Errors.add(errors,errorMessages.errorUserIsNull());\n    return null;\n  }\n  if (id != null && !idGenerator.isIdWellFormed(id)) {\n    Errors.add(errors,errorMessages.errorIdIsInvalid());\n    return null;\n  }\n  final Entry entry=getEntryById(id);\n  if (entry == null) {\n    Errors.add(errors,errorMessages.errorTheEntryCouldNotBeFound());\n    return null;\n  }\n  if (!canUserModifyEntry(user,entry,isAdmin)) {\n    Errors.add(errors,errorMessages.errorTheUserIsNotEntitledToModifyTheEntry());\n    return null;\n  }\n  if (note != null) {\n    note=cleanUpText(note);\n  }\n  if (entry.isNotebook()) {\n    entry.setNotebookTitle(note);\n  }\n else   if (entry.isSource()) {\n    entry.setSourceTitle(note);\n  }\n else {\n    entry.setNote(note);\n  }\n  entry.setModTime(modTime);\n  entry.setIsPublic(isPublic);\n  if (entry.getCreateTime() > modTime.longValue()) {\n    modTime=entry.getCreateTime();\n  }\n  if (entry.isQuotation()) {\n    if (quotation != null) {\n      quotation=cleanUpText(quotation);\n      entry.setQuotation(quotation);\n    }\n  }\n  return entry;\n}\n", "docstring": "api method . change values for the entry entry .", "partition": "test"}
{"idx": "2365", "code": "public FileSaverDescriptor(@NotNull String title,@NotNull String description,String... extensions){\n  super(true,true,true,true,false,false);\n  setTitle(title);\n  setDescription(description);\n  this.extensions=Arrays.asList(extensions);\n}\n", "docstring": "constructs save dialog properties", "partition": "test"}
{"idx": "2366", "code": "protected int readBlock(){\n  blockSize=read();\n  int n=0;\n  if (blockSize > 0) {\n    try {\n      int count;\n      while (n < blockSize) {\n        count=blockSize - n;\n        rawData.get(block,n,count);\n        n+=count;\n      }\n    }\n catch (    final Exception e) {\n      Log.w(TAG,\"Error Reading Block\",e);\n      status=STATUS_FORMAT_ERROR;\n    }\n  }\n  return n;\n}\n", "docstring": "reads next variable length block from input .", "partition": "test"}
{"idx": "2367", "code": "public void addRun(final Run run){\n  runs.add(run);\n  run.setId(runIdCounter++);\n}\n", "docstring": "will add the run to the list .", "partition": "test"}
{"idx": "2368", "code": "void copyInto(Converter[] converters){\n  System.arraycopy(iConverters,0,converters,0,iConverters.length);\n}\n", "docstring": "copies all the converters in the set to the given array .", "partition": "test"}
{"idx": "2369", "code": "@Override public boolean addOutputSensor(String sensorName,int state){\n  OutputSensor outputSensor=new OutputSensor(sensorName);\n  if (!outputSensor.setState(state)) {\n    return false;\n  }\n  _outputSensorList.add(outputSensor);\n  return true;\n}\n", "docstring": "add an output sensor to this route", "partition": "test"}
{"idx": "2370", "code": "public void init(SocketChannel channel){\n  _channel=channel;\n  _readBuffer.clear();\n  _readBuffer.flip();\n  _needsFlush=false;\n}\n", "docstring": "initialize the socketstream with a new socket .", "partition": "test"}
{"idx": "2371", "code": "public void reset(){\n  Timber.i(\"resetting QueuedMediaPlayer...\");\n  mCurrentPlayer.reset();\n  mNextPlayer.reset();\n  mQueue=Collections.emptyList();\n  mQueueIndex=0;\n  mRequestedSeekPosition=0;\n  mPlayWhenPrepared=false;\n}\n", "docstring": "resets both mediaplayers , and clears the queue . this makes the current instance act like a new one , retaining any attached callbacks and other properties unrelated to the queue .", "partition": "test"}
{"idx": "2372", "code": "@Override public Expected<T> ifPresent(final Consumer<? super T> consumer){\n  if (this.value != null)   consumer.accept(this.value);\n  return this;\n}\n", "docstring": "if a value is present , invoke the consumer with the value .", "partition": "test"}
{"idx": "2373", "code": "protected void sendIntensity(double intensity){\n  if (log.isDebugEnabled()) {\n    log.debug(\"sendIntensity(\" + intensity + \")\"+ \" lastOutputStep: \"+ lastOutputStep+ \" maxDimStep: \"+ maxDimStep);\n  }\n  int newStep=(int)Math.round(intensity * maxDimStep);\n  if ((newStep < 0) || (newStep > maxDimStep)) {\n    log.error(\"newStep wrong: \" + newStep + \" intensity: \"+ intensity);\n  }\n  if (newStep == 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"intensity \" + intensity + \" within current step, return\");\n    }\n    return;\n  }\n  X10Sequence out=new X10Sequence();\n  out.addExtData(housecode,devicecode,X10Sequence.EXTCMD_DIM,newStep);\n  tc.sendX10Sequence(out,null);\n  lastOutputStep=newStep;\n  if (log.isDebugEnabled()) {\n    log.debug(\"sendIntensity(\" + intensity + \") house \"+ X10Sequence.houseValueToText(housecode)+ \" device \"+ devicecode+ \" newStep: \"+ newStep);\n  }\n}\n", "docstring": "send a dim / bright commands to the x10 hardware to reach a specific intensity . acts immediately , and changes no general state . < p > this sends \" dim \" commands .", "partition": "test"}
{"idx": "2374", "code": "public GlowScheduler(GlowServer server,WorldScheduler worlds){\n  this.server=server;\n  this.worlds=worlds;\n  inTickTaskCondition=worlds.getAdvanceCondition();\n  tickEndRun=null;\n  primaryThread=Thread.currentThread();\n}\n", "docstring": "creates a new task scheduler .", "partition": "test"}
{"idx": "2375", "code": "public void delete() throws IOException {\n  close();\n  Utils.deleteContents(directory);\n}\n", "docstring": "closes the cache and deletes all of its stored values . this will delete all files in the cache directory including files that weren \"'\" t created by the cache .", "partition": "test"}
{"idx": "2376", "code": "@Override public boolean execute(@NotNull PsiElement pe,@NotNull ResolveState state){\n  if (pe instanceof PsiVariable) {\n    final PsiVariable pvar=(PsiVariable)pe;\n    if (!myStaticSensitiveFlag || !myStaticScopeFlag || pvar.hasModifierProperty(PsiModifier.STATIC)) {\n      if (check(pvar,state)) {\n        myResultList.add(pvar);\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "always return true since we wanna get all vars in scope", "partition": "test"}
{"idx": "2377", "code": "public void characters(char[] ch,int start,int length) throws SAXException {\n  try {\n    stopTerminator();\n    if (w == null)     return;\n    int end=start + length;\n    for (int i=start; i < end; i++) {\n      char c=ch[i];\nswitch (c) {\ncase \'&\':\n        w.write(\"&amp;\");\n      break;\ncase \'<\':\n    w.write(\"&lt;\");\n  break;\ncase \'>\':\nw.write(\"&gt;\");\nbreak;\ncase \'\\n\':\ncase \'\\r\':\ncase \'\\t\':\nw.write(c);\nbreak;\ndefault :\nif (canEncode(c)) {\nw.write(c);\n}\n else {\nw.write(\"&#\");\nw.write(Integer.toString(c));\nw.write(\";\");\n}\nbreak;\n}\n}\n}\n catch (IOException e) {\nthrow new SAXException(e);\n}\n}\n", "docstring": "inserts a string of characters into the document .", "partition": "test"}
{"idx": "2378", "code": "public static String toHumanReadableString(final String iso8601Duration){\n  String str=\"\";\n  if (iso8601Duration.matches(\"P\\\\d+[YMD].+\")) {\n    str=\"inf.\";\n  }\n else {\n    String hours=getHours(iso8601Duration), minutes=getMinutes(iso8601Duration), seconds=getSeconds(iso8601Duration);\n    if (hours != null) {\n      str=hours;\n      if (minutes != null && minutes.length() == 1) {\n        minutes=\"0\" + minutes;\n      }\n    }\n    if (str.isEmpty())     str=minutes;\n else     str+=\":\" + minutes;\n    if (str.isEmpty())     str=seconds;\n else     str+=\":\" + seconds;\n  }\n  return str;\n}\n", "docstring": "converts the supplies iso 8601 duration into a human readable string . if the supplied duration is greater than 1 day , then it will return \" inf . \" .", "partition": "test"}
{"idx": "2379", "code": "@Override public IChatMessage sendMessage(final String text) throws RemoteException {\n  if (TextUtils.isEmpty(text)) {\n    throw new ServerApiIllegalArgumentException(\"GroupChat message must not be null or empty!\");\n  }\n  int messageLength=text.length();\n  int maxMessageLength=mRcsSettings.getMaxGroupChatMessageLength();\n  if (messageLength > maxMessageLength) {\n    throw new ServerApiIllegalArgumentException(\"chat message length: \" + messageLength + \" exceeds max group chat message length: \"+ maxMessageLength+ \"!\");\n  }\n  if (!isAllowedToSendMessage()) {\n    throw new ServerApiPermissionDeniedException(\"Not allowed to send GroupChat message on the connected IMS server!\");\n  }\n  try {\n    mImService.removeGroupChatComposingStatus(mChatId);\n    long timestamp=System.currentTimeMillis();\n    final ChatMessage msg=ChatUtils.createTextMessage(null,text,timestamp,timestamp);\n    ChatMessagePersistedStorageAccessor persistedStorage=new ChatMessagePersistedStorageAccessor(mMessagingLog,msg.getMessageId(),msg.getRemoteContact(),text,msg.getMimeType(),mChatId,Direction.OUTGOING);\n    addOutgoingGroupChatMessage(msg,Content.Status.QUEUED,Content.ReasonCode.UNSPECIFIED);\n    if (!mChatService.isGroupChatActive(mChatId)) {\n      mChatService.setGroupChatStateAndReasonCode(mChatId,GroupChat.State.STARTED,GroupChat.ReasonCode.UNSPECIFIED);\n    }\n    mImService.tryToDequeueGroupChatMessagesAndGroupFileTransfers(mChatId);\n    return new ChatMessageImpl(persistedStorage);\n  }\n catch (  ServerApiBaseException e) {\n    if (!e.shouldNotBeLogged()) {\n      sLogger.error(ExceptionUtil.getFullStackTrace(e));\n    }\n    throw e;\n  }\ncatch (  Exception e) {\n    sLogger.error(ExceptionUtil.getFullStackTrace(e));\n    throw new ServerApiGenericException(e);\n  }\n}\n", "docstring": "sends a text message to the group", "partition": "test"}
{"idx": "2380", "code": "void remove(TcpServerThread t){\n  running.remove(t);\n}\n", "docstring": "remove a thread from the list .", "partition": "test"}
{"idx": "2381", "code": "public DockNodeEventHandler(Node node){\n  this.node=node;\n}\n", "docstring": "creates a default dock node event handler that will help this dock pane track the current docking area .", "partition": "test"}
{"idx": "2382", "code": "private int readSourceToLog(Settings settings){\n  String sourceToLog=settings.get(INDEX_INDEXING_SLOWLOG_MAX_SOURCE_CHARS_TO_LOG,\"1000\");\n  try {\n    return Integer.parseInt(sourceToLog,10);\n  }\n catch (  NumberFormatException e) {\n    return Booleans.parseBoolean(sourceToLog,true) ? Integer.MAX_VALUE : 0;\n  }\n}\n", "docstring": "reads how much of the source to log . the user can specify any value they like and numbers are interpreted the maximum number of characters to log and everything else is interpreted as elasticsearch interprets booleans which is then converted to 0 for false and integer . max_value for true .", "partition": "test"}
{"idx": "2383", "code": "private void deleteCurrentLicenseFileOnDisk(){\n  File licenseFile=new File(LicenseConstants.LICENSE_FILE_PATH);\n  if (licenseFile.exists()) {\n    licenseFile.delete();\n  }\n}\n", "docstring": "deletes current version of license file in / tmp / . license", "partition": "test"}
{"idx": "2384", "code": "@Deprecated public static NetworkParameters testNet(){\n  return TestNet3Params.get();\n}\n", "docstring": "alias for testnet3params . get ( ) , use that instead .", "partition": "test"}
{"idx": "2385", "code": "public final void readFromStream(DataInputStream dis,int version) throws IOException, ChessParseError {\n  event=dis.readUTF();\n  site=dis.readUTF();\n  date=dis.readUTF();\n  round=dis.readUTF();\n  white=dis.readUTF();\n  black=dis.readUTF();\n  startPos=TextIO.readFEN(dis.readUTF());\n  currentPos=new Position(startPos);\n  timeControl=dis.readUTF();\n  if (version >= 2) {\n    whiteTimeControl=dis.readUTF();\n    blackTimeControl=dis.readUTF();\n  }\n else {\n    whiteTimeControl=\"?\";\n    blackTimeControl=\"?\";\n  }\n  int nTags=dis.readInt();\n  tagPairs.clear();\n  for (int i=0; i < nTags; i++) {\n    TagPair tp=new TagPair();\n    tp.tagName=dis.readUTF();\n    tp.tagValue=dis.readUTF();\n    tagPairs.add(tp);\n  }\n  rootNode=new Node();\n  Node.readFromStream(dis,rootNode);\n  currentNode=rootNode;\n  int pathLen=dis.readInt();\n  for (int i=0; i < pathLen; i++)   goForward(dis.readInt());\n  updateListener();\n}\n", "docstring": "de - serialize from input stream .", "partition": "test"}
{"idx": "2386", "code": "public Rect updateFastScrollerBounds(BaseRecyclerView rv,int lastTouchY){\n  mInvalidateRect.set(mBgBounds);\n  if (isVisible()) {\n    int edgePadding=rv.getMaxScrollbarWidth();\n    int bgPadding=(mBgOriginalSize - mTextBounds.height()) / 2;\n    int bgHeight=mBgOriginalSize;\n    int bgWidth=Math.max(mBgOriginalSize,mTextBounds.width() + (2 * bgPadding));\n    if (Utilities.isRtl(mRes)) {\n      mBgBounds.left=rv.getBackgroundPadding().left + (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.right=mBgBounds.left + bgWidth;\n    }\n else {\n      mBgBounds.right=rv.getWidth() - rv.getBackgroundPadding().right - (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.left=mBgBounds.right - bgWidth;\n    }\n    mBgBounds.top=lastTouchY - (int)(FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR * bgHeight);\n    mBgBounds.top=Math.max(edgePadding,Math.min(mBgBounds.top,rv.getHeight() - edgePadding - bgHeight));\n    mBgBounds.bottom=mBgBounds.top + bgHeight;\n  }\n else {\n    mBgBounds.setEmpty();\n  }\n  mInvalidateRect.union(mBgBounds);\n  return mInvalidateRect;\n}\n", "docstring": "updates the bounds for the fast scroller .", "partition": "test"}
{"idx": "2387", "code": "public DNetscapeCaPolicyUrl(JDialog parent){\n  super(parent);\n  setTitle(res.getString(\"DNetscapeCaPolicyUrl.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dnetscapecapolicyurl dialog .", "partition": "test"}
{"idx": "2388", "code": "public boolean textboxKeyTyped(char p_146201_1_,int p_146201_2_){\n  if (!isFocused)   return false;\n else   if (GuiScreen.func_175278_g(p_146201_2_)) {\n    setCursorPositionEnd();\n    setSelectionPos(0);\n    return true;\n  }\n else   if (GuiScreen.func_175280_f(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    return true;\n  }\n else   if (GuiScreen.func_175279_e(p_146201_2_)) {\n    if (isEnabled)     writeText(GuiScreen.getClipboardString());\n    return true;\n  }\n else   if (GuiScreen.func_175277_d(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    if (isEnabled)     writeText(\"\");\n    return true;\n  }\n else switch (p_146201_2_) {\ncase 14:\n    if (GuiScreen.isCtrlKeyDown()) {\n      if (isEnabled)       deleteWords(-1);\n    }\n else     if (isEnabled)     deleteFromCursor(-1);\n  return true;\ncase 199:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(0);\n else setCursorPositionZero();\nreturn true;\ncase 203:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(-1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() - 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(-1));\n else moveCursorBy(-1);\nreturn true;\ncase 205:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() + 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(1));\n else moveCursorBy(1);\nreturn true;\ncase 207:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(text.length());\n else setCursorPositionEnd();\nreturn true;\ncase 211:\nif (GuiScreen.isCtrlKeyDown()) {\nif (isEnabled) deleteWords(1);\n}\n else if (isEnabled) deleteFromCursor(1);\nreturn true;\ndefault :\nif (EmailAllowedCharacters.isAllowedCharacter(p_146201_1_)) {\nif (isEnabled) writeText(Character.toString(p_146201_1_));\nreturn true;\n}\n else return false;\n}\n}\n", "docstring": "call this method from your guiscreen to process the keys into the textbox", "partition": "test"}
{"idx": "2389", "code": "public static Path createDirectory(final Path parent,final String folderName){\n  final File file=new File(parent.toFile(),folderName);\n  if (!file.exists()) {\n    if (!file.mkdir()) {\n      throw new RuntimeException(\"Error while trying to create folder at \" + parent + \" with \"+ folderName+ \".\");\n    }\n  }\n  file.deleteOnExit();\n  return file.toPath();\n}\n", "docstring": "creates a new directory with the given parent folder and folder name . the newly created folder will be deleted on graceful vm shutdown .", "partition": "test"}
{"idx": "2390", "code": "public static boolean isWindows8(){\n  return osName.indexOf(\"Windows\") > -1 && (osVersion.equals(\"6.2\") || osVersion.equals(\"6.3\"));\n}\n", "docstring": "is operating system windows 8 or 8 . 1 ?", "partition": "test"}
{"idx": "2391", "code": "protected Set<FunctionInterface> findUnusedFunctions(Set<UnitInterface> units){\n  Set<FunctionInterface> allFunctions=new HashSet<FunctionInterface>();\n  Set<FunctionInterface> usedFunctions=new HashSet<FunctionInterface>();\n  for (  UnitInterface unit : units) {\n    List<FunctionInterface> unitFunctions=getUnitFunctions(unit);\n    allFunctions.addAll(unitFunctions);\n    for (    FunctionInterface unitFunction : unitFunctions) {\n      for (      FunctionInterface usedFunction : unitFunction.getCalledFunctions()) {\n        usedFunctions.add(usedFunction);\n      }\n    }\n  }\n  allFunctions.removeAll(usedFunctions);\n  return allFunctions;\n}\n", "docstring": "find unused functions in a unit", "partition": "test"}
{"idx": "2392", "code": "private static void addItemsToList(int startIndex,int endIndex){\n  for (int i=startIndex; i < endIndex; i++) {\n    values.add(new Integer(i));\n  }\n}\n", "docstring": "adds the items to the list . items added to the list are numbers and letters .", "partition": "test"}
{"idx": "2393", "code": "public static synchronized List<Proxy> noProxyList(){\n  if (noProxyList == null) {\n    ArrayList<Proxy> list=new ArrayList<Proxy>(1);\n    list.add(Proxy.NO_PROXY);\n    noProxyList=Collections.unmodifiableList(list);\n  }\n  return noProxyList;\n}\n", "docstring": "gets an unmodifiable proxy list that will have as it \"'\" s only entry an direct proxy .", "partition": "test"}
{"idx": "2394", "code": "public void addIncludes(String[] definitions){\n  addStrings(INCLUDES,definitions);\n  addStrings(linker_more,INCLUDES,definitions);\n  newLinkerOptionsAfterCompile.add(INCLUDES);\n}\n", "docstring": "adds a list of definitions to the existing list of definitions .", "partition": "test"}
{"idx": "2395", "code": "public void tallyVariant(VcfHeader header,VcfRecord rec){\n  tallyVariant(rec,header.getSampleNames());\n}\n", "docstring": "add the given vcf record to the statistics", "partition": "test"}
{"idx": "2396", "code": "public LDIFEntryReader(final String... ldifLines){\n  super(Arrays.asList(ldifLines));\n}\n", "docstring": "creates a new ldif entry reader which will read lines of ldif from the provided array of ldif lines .", "partition": "test"}
{"idx": "2397", "code": "public void updatePresonInfo(){\n  this.leftPerson=person2LeavingPersonInfo.get(this.personId);\n  this.enteredPerson=person2EnteringPersonInfo.get(this.personId);\n}\n", "docstring": "a person may re - appear on the same link .", "partition": "test"}
{"idx": "2398", "code": "public void presentLicenses(boolean preAccept){\n  LicenseSet licenses=licenseModule.getRequiredLicenses();\n  if (preAccept) {\n    licenses.acceptAll();\n  }\n else {\n    for (    License license : licenses) {\n      if (license.isAccepted()) {\n        continue;\n      }\n      user.show(\"\");\n      user.show(license.getLicenseText());\n      String input=user.ask(\"prompt\");\n      if (input != null && YES.startsWith(input.toLowerCase())) {\n        license.accept();\n      }\n else {\n        license.reject();\n      }\n    }\n  }\n}\n", "docstring": "present the licenses to the user - if the preaccept parameter is set , then simply display them through system . out . otherwise display each one and confirm that the user agrees before displaying the next . finally , check that all licenses have been agreed to before continuing .", "partition": "test"}
{"idx": "2399", "code": "public void addGeoKey(XTIFFField geoKey){\n  geoKeyIndex.put(new Integer(geoKey.getTag()),geoKey);\n  hasGeoKeys=true;\n}\n", "docstring": "add an existing geokey to the directory .", "partition": "test"}
{"idx": "2400", "code": "public static GeoTimeSerie detect(GeoTimeSerie gts,int alphabetSize,int wordLen,int windowLen,Collection<String> patterns,boolean standardizePAA) throws WarpScriptException {\n  GeoTimeSerie gtsPatterns=GTSHelper.bSAX(gts,alphabetSize,wordLen,windowLen,standardizePAA);\n  GTSHelper.sort(gtsPatterns);\n  GeoTimeSerie detected=new GeoTimeSerie(gts.lastbucket,gts.bucketcount,gts.bucketspan,16);\n  detected.setMetadata(gts.getMetadata());\n  int lastidx=-1;\n  for (int i=0; i < gtsPatterns.values; i++) {\n    if (!patterns.contains(gtsPatterns.stringValues[i])) {\n      continue;\n    }\n    for (int j=0; j < windowLen; j++) {\n      if (i + j > lastidx) {\n        lastidx=i + j;\n        GTSHelper.setValue(detected,GTSHelper.tickAtIndex(gts,lastidx),GTSHelper.locationAtIndex(gts,lastidx),GTSHelper.elevationAtIndex(gts,lastidx),GTSHelper.valueAtIndex(gts,lastidx),false);\n      }\n    }\n  }\n  return detected;\n}\n", "docstring": "detect patterns in a geo time serie instance . return a modified version of the original gts instance where only the values which are part of one of the provided patterns are kept .", "partition": "test"}
{"idx": "2401", "code": "private StringBuilder debugDumpCandidates(StringBuilder msg,List<? extends Itemset> candidates,VectorFieldTypeInformation<BitVector> meta){\n  msg.append(\':\');\n  for (  Itemset itemset : candidates) {\n    msg.append(\" [\");\n    itemset.appendTo(msg,meta);\n    msg.append(\']\');\n  }\n  return msg;\n}\n", "docstring": "debug method : output all itemsets .", "partition": "test"}
{"idx": "2402", "code": "public static final void writeBooleanArrayXml(boolean[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"boolean-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  for (int i=0; i < N; i++) {\n    out.startTag(null,\"item\");\n    out.attribute(null,\"value\",Boolean.toString(val[i]));\n    out.endTag(null,\"item\");\n  }\n  out.endTag(null,\"boolean-array\");\n}\n", "docstring": "flatten a boolean [ ", "partition": "test"}
{"idx": "2403", "code": "public void addOutboundRule(final OutboundRule outboundRule){\n  outboundRule.setId(outboundRuleIdCounter++);\n  outboundRules.add(outboundRule);\n}\n", "docstring": "will add the rule to the rules list .", "partition": "test"}
{"idx": "2404", "code": "public Skype(String username,String password){\n  this.username=username;\n  this.password=password;\n}\n", "docstring": "builds a new skype connection without connecting to anything .", "partition": "test"}
{"idx": "2405", "code": "private void addFlags(int newflags){\n  flags=getLayoutFlags() | newflags;\n}\n", "docstring": "or newflags with existing flags . first computes existing flags if needed .", "partition": "test"}
{"idx": "2406", "code": "public static String matchCertificate(KeyStore keyStore,X509Certificate cert) throws CryptoException {\n  try {\n    for (Enumeration aliases=keyStore.aliases(); aliases.hasMoreElements(); ) {\n      String alias=(String)aliases.nextElement();\n      if (keyStore.isCertificateEntry(alias)) {\n        X509Certificate compCert=X509CertUtil.convertCertificate(keyStore.getCertificate(alias));\n        if (cert.equals(compCert)) {\n          return alias;\n        }\n      }\n    }\n    return null;\n  }\n catch (  KeyStoreException ex) {\n    throw new CryptoException(res.getString(\"NoMatchCertificate.exception.message\"),ex);\n  }\n}\n", "docstring": "check whether or not a trusted certificate in the supplied keystore matches the supplied x . 509 certificate .", "partition": "test"}
{"idx": "2407", "code": "void purgeLastArticles(int amountToPurge){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  String query=\"_id IN ( SELECT _id FROM \" + TABLE_ARTICLES + \" WHERE isPublished=0 AND isStarred=0 ORDER BY updateDate DESC LIMIT -1 OFFSET \"+ (Utils.ARTICLE_LIMIT - amountToPurge + \")\");\n  safelyDeleteArticles(query,null);\n  Log.d(TAG,\"purgeLastArticles took \" + (System.currentTimeMillis() - time) + \"ms\");\n}\n", "docstring": "delete given amount of last updated articles from db . published and starred articles are ignored so the configured limit is not an exact upper limit to the number of articles in the database .", "partition": "test"}
{"idx": "2408", "code": "public void reclaimViews(List<View> views){\n  int childCount=getChildCount();\n  RecyclerListener listener=mRecycler.mRecyclerListener;\n  for (int i=0; i < childCount; i++) {\n    View child=getChildAt(i);\n    TwoWayAbsListView.LayoutParams lp=(TwoWayAbsListView.LayoutParams)child.getLayoutParams();\n    if (lp != null && mRecycler.shouldRecycleViewType(lp.viewType)) {\n      views.add(child);\n      if (listener != null) {\n        listener.onMovedToScrapHeap(child);\n      }\n    }\n  }\n  mRecycler.reclaimScrapViews(views);\n  removeAllViewsInLayout();\n}\n", "docstring": "move all views ( excluding headers and footers ) held by this twowayabslistview into the supplied list . this includes views displayed on the screen as well as views stored in twowayabslistview \"'\" s internal view recycler .", "partition": "test"}
{"idx": "2409", "code": "ProxyVerifier(TxnManager serverProxy,Uuid proxyID){\n  if (!(serverProxy instanceof RemoteMethodControl)) {\n    throw new UnsupportedOperationException(\"No verifier available for non-constrainable service\");\n  }\n else   if (!(serverProxy instanceof TrustEquivalence)) {\n    throw new UnsupportedOperationException(\"Verifier requires service proxy to implement \" + \"TrustEquivalence\");\n  }\n else   if (proxyID == null) {\n    throw new IllegalArgumentException(\"Proxy id cannot be null\");\n  }\n  this.serverProxy=(RemoteMethodControl)serverProxy;\n  this.proxyID=proxyID;\n}\n", "docstring": "returns a verifier for the smart proxies of the specified mahalo server proxy .", "partition": "test"}
{"idx": "2410", "code": "public void paint(Graphics g){\n  g.translate(0,translateY);\n  super.paint(g);\n}\n", "docstring": "displays our component in the location ( 0 , translatey ) . note that this changes only the rendering location of the button , not the physical location of it . note , also , that rendering into g will be clipped to the physical location of the button , so the button will disappear as it moves away from that location .", "partition": "test"}
{"idx": "2411", "code": "private static long addAndCheck(long a,long b,Localizable pattern) throws MathRuntimeException {\n  final long result=a + b;\n  if (!((a ^ b) < 0 || (a ^ result) >= 0)) {\n    throw new MathRuntimeException(pattern,a,b);\n  }\n  return result;\n}\n", "docstring": "add two long integers , checking for overflow .", "partition": "test"}
{"idx": "2412", "code": "private void serializeCompactRDFGeneralQualifier(int indent,XMPNode node) throws IOException, XMPException {\n  write(\" rdf:parseType=\\\"Resource\\\">\");\n  writeNewline();\n  serializeCanonicalRDFProperty(node,false,true,indent + 1);\n  for (Iterator iq=node.iterateQualifier(); iq.hasNext(); ) {\n    XMPNode qualifier=(XMPNode)iq.next();\n    serializeCanonicalRDFProperty(qualifier,false,false,indent + 1);\n  }\n}\n", "docstring": "serializes the general qualifier .", "partition": "test"}
{"idx": "2413", "code": "private JCheckBox addCheckbox(String text,Container container){\n  JCheckBox checkbox=new JCheckBox(text);\n  checkbox.setAlignmentX(Component.LEFT_ALIGNMENT);\n  checkbox.setBorder(BorderFactory.createEmptyBorder(0,0,10,5));\n  container.add(checkbox);\n  return checkbox;\n}\n", "docstring": "adds a preconfigured jcheckbox to the specified container , setting its alignment constraint to left and adding an empty padding border .", "partition": "test"}
{"idx": "2414", "code": "public void push(){\n  state.cliprgn=g.getClipBounds();\n  stack.push(state);\n  state=(GraphicsState)state.clone();\n}\n", "docstring": "push the current graphics state onto the stack . continue working with the current object ; calling pop ( ) restores the state of this object to its state when push ( ) was called .", "partition": "test"}
{"idx": "2415", "code": "public static void dropIndex(Connection conn,String schema,String table) throws SQLException {\n  init(conn);\n  PreparedStatement prep=conn.prepareStatement(\"SELECT ID FROM \" + SCHEMA + \".INDEXES WHERE SCHEMA=? AND TABLE=?\");\n  prep.setString(1,schema);\n  prep.setString(2,table);\n  ResultSet rs=prep.executeQuery();\n  if (!rs.next()) {\n    return;\n  }\n  int indexId=rs.getInt(1);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".INDEXES WHERE ID=?\");\n  prep.setInt(1,indexId);\n  prep.execute();\n  createOrDropTrigger(conn,schema,table,false);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".ROWS WHERE INDEXID=? AND ROWNUM<10000\");\n  while (true) {\n    prep.setInt(1,indexId);\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".MAP M \"+ \"WHERE NOT EXISTS (SELECT * FROM \"+ SCHEMA+ \".ROWS R WHERE R.ID=M.ROWID) AND ROWID<10000\");\n  while (true) {\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n}\n", "docstring": "drop an existing full text index for a table . this method returns silently if no index for this table exists .", "partition": "test"}
{"idx": "2416", "code": "public synchronized int add(IAudioProcessor processor){\n  processors.add(processor);\n  buildFinalProcessor();\n  return processors.indexOf(processor);\n}\n", "docstring": "adds a processor to the internal processor queue .", "partition": "test"}
{"idx": "2417", "code": "public ScriptBuilder data(int index,byte[] data){\n  byte[] copy=Arrays.copyOf(data,data.length);\n  int opcode;\n  if (data.length == 0) {\n    opcode=OP_0;\n  }\n else   if (data.length == 1) {\n    byte b=data[0];\n    if (b >= 1 && b <= 16)     opcode=Script.encodeToOpN(b);\n else     opcode=1;\n  }\n else   if (data.length < OP_PUSHDATA1) {\n    opcode=data.length;\n  }\n else   if (data.length < 256) {\n    opcode=OP_PUSHDATA1;\n  }\n else   if (data.length < 65536) {\n    opcode=OP_PUSHDATA2;\n  }\n else {\n    throw new RuntimeException(\"Unimplemented\");\n  }\n  return addChunk(index,new ScriptChunk(opcode,copy));\n}\n", "docstring": "adds a copy of the given byte array as a data element ( i . e . pushdata ) at the given index in the program .", "partition": "test"}
{"idx": "2418", "code": "public void initialize(Map configParams){\n  String delimiterConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_DELIMITER);\n  if (delimiterConfig != null) {\n    this.delimiter=delimiterConfig;\n  }\n  String caseConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_CASE_SENSITIVE);\n  if (caseConfig != null) {\n    if (caseConfig.equals(\"true\")) {\n      this.caseSensitive=true;\n    }\n else     if (caseConfig.equals(\"false\")) {\n      this.caseSensitive=false;\n    }\n else {\n      this.caseSensitive=true;\n    }\n  }\n  String wildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_WILDCARD);\n  if (wildcardConfig != null) {\n    this.wildcard=wildcardConfig;\n  }\n  String oneLevelWildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_ONE_LEVEL_WILDCARD);\n  if (oneLevelWildcardConfig != null) {\n    this.oneLevelWildcard=oneLevelWildcardConfig;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"PrefixResourceName:initialize():\" + \" delimiter = \" + delimiter + \" wildcard = \"+ wildcard+ \" oneLevelWildcard = \"+ oneLevelWildcard+ \" case = \"+ caseConfig);\n  }\n  oneLevelWildcardLength=oneLevelWildcard.length();\n  wildcardLength=wildcard.length();\n  if (oneLevelWildcard.indexOf(wildcard) != -1) {\n    wildcardEmbedded=true;\n  }\n else {\n    wildcardEmbedded=false;\n  }\n  if (wildcard.indexOf(oneLevelWildcard) != -1) {\n    oneLevelWildcardEmbedded=true;\n  }\n else {\n    oneLevelWildcardEmbedded=false;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"wildcardEmbedded,oneLevelWildcardEmbedded\" + wildcardEmbedded + \",\"+ oneLevelWildcardEmbedded);\n  }\n  return;\n}\n", "docstring": "initializes the resource name with configuration information , usally set by the administrators . the main configration information retrived is mainly like wild card pattern used , one level wild card pattern used , case sensitivity etc .", "partition": "test"}
{"idx": "2419", "code": "private String convertLessThanOneThousand(int number){\n  String soFar;\n  if (number % 100 < 20) {\n    soFar=numNames[number % 100];\n    number/=100;\n  }\n else {\n    soFar=numNames[number % 10];\n    number/=10;\n    String s=Integer.toString(number);\n    if (s.endsWith(\"2\") && !soFar.equals(\"\"))     soFar=\" VINT-I-\" + soFar.trim();\n else     if (soFar.equals(\"\"))     soFar=tensNames[number % 10] + soFar;\n else     soFar=tensNames[number % 10] + \"-\" + soFar;\n    number/=10;\n  }\n  if (number == 0)   return tensNames[number % 10] + soFar;\n  if (number > 1)   soFar=\"S\" + soFar;\n  if (number == 1 && !soFar.equals(\"\"))   number=0;\n  return numNames[number] + \" CENT\" + soFar;\n}\n", "docstring": "convert less than one thousand", "partition": "test"}
{"idx": "2420", "code": "public static boolean isEmbeddedBase64Image(String uri){\n  return (uri != null && uri.startsWith(\"data:image/\"));\n}\n", "docstring": "detect if an uri represents an embedded base 64 image .", "partition": "test"}
{"idx": "2421", "code": "void changeState(int newState){\n  int oldState;\nsynchronized (stateLock) {\n    if (state == newState)     return;\n    oldState=state;\n    state=newState;\n    stateLock.notifyAll();\n  }\n  sendStateChangeNotification(oldState,newState);\n}\n", "docstring": "for internal use only .", "partition": "test"}
{"idx": "2422", "code": "private int parseLinkLabel(){\n  String m=match(LINK_LABEL);\n  return m == null ? 0 : m.length();\n}\n", "docstring": "attempt to parse a link label , returning number of characters parsed .", "partition": "test"}
{"idx": "2423", "code": "private static void insertCommentsInNode(Node node,List<Comment> commentsToAttribute){\n  if (commentsToAttribute.size() == 0)   return;\n  List<Node> children=node.getChildrenNodes();\n  PositionUtils.sortByBeginPosition(children);\n  for (  Node child : children) {\n    List<Comment> commentsInsideChild=new LinkedList<Comment>();\n    for (    Comment c : commentsToAttribute) {\n      if (PositionUtils.nodeContains(child,c,_doNotConsiderAnnotationsAsNodeStartForCodeAttribution)) {\n        commentsInsideChild.add(c);\n      }\n    }\n    commentsToAttribute.removeAll(commentsInsideChild);\n    insertCommentsInNode(child,commentsInsideChild);\n  }\n  List<Comment> attributedComments=new LinkedList<Comment>();\n  for (  Comment comment : commentsToAttribute) {\n    if (comment.isLineComment()) {\n      for (      Node child : children) {\n        if (child.getEndLine() == comment.getBeginLine()) {\n          if (attributeLineCommentToNodeOrChild(child,comment.asLineComment())) {\n            attributedComments.add(comment);\n          }\n        }\n      }\n    }\n  }\n  Comment previousComment=null;\n  attributedComments=new LinkedList<Comment>();\n  List<Node> childrenAndComments=new LinkedList<Node>();\n  childrenAndComments.addAll(children);\n  childrenAndComments.addAll(commentsToAttribute);\n  PositionUtils.sortByBeginPosition(childrenAndComments,_doNotConsiderAnnotationsAsNodeStartForCodeAttribution);\n  for (  Node thing : childrenAndComments) {\n    if (thing instanceof Comment) {\n      previousComment=(Comment)thing;\n      if (!previousComment.isOrphan()) {\n        previousComment=null;\n      }\n    }\n else {\n      if (previousComment != null && !thing.hasComment()) {\n        if (!_doNotAssignCommentsPreceedingEmptyLines || !thereAreLinesBetween(previousComment,thing)) {\n          thing.setComment(previousComment);\n          attributedComments.add(previousComment);\n          previousComment=null;\n        }\n      }\n    }\n  }\n  commentsToAttribute.removeAll(attributedComments);\n  for (  Comment c : commentsToAttribute) {\n    if (c.isOrphan()) {\n      node.addOrphanComment(c);\n    }\n  }\n}\n", "docstring": "this method try to attributes the nodes received to child of the node . it returns the node that were not attributed .", "partition": "test"}
{"idx": "2424", "code": "public static String readFileAsString(File file) throws FileNotFoundException {\n  return readFileAsString(file.getAbsolutePath());\n}\n", "docstring": "devuelve el contenido de un file como string", "partition": "test"}
{"idx": "2425", "code": "public synchronized void checkAccess(LicenseCheckerCallback callback){\n  if (mPolicy.allowAccess()) {\n    Log.i(TAG,\"Using cached license response\");\n    callback.allow(Policy.LICENSED);\n  }\n else {\n    LicenseValidator validator=new LicenseValidator(mPolicy,new NullDeviceLimiter(),callback,generateNonce(),mPackageName,mVersionCode);\n    if (mService == null) {\n      Log.i(TAG,\"Binding to licensing service.\");\n      try {\n        boolean bindResult=mContext.bindService(new Intent(new String(Base64.decode(\"Y29tLmFuZHJvaWQudmVuZGluZy5saWNlbnNpbmcuSUxpY2Vuc2luZ1NlcnZpY2U=\"))),this,Context.BIND_AUTO_CREATE);\n        if (bindResult) {\n          mPendingChecks.offer(validator);\n        }\n else {\n          Log.e(TAG,\"Could not bind to service.\");\n          handleServiceConnectionError(validator);\n        }\n      }\n catch (      SecurityException e) {\n        callback.applicationError(LicenseCheckerCallback.ERROR_MISSING_PERMISSION);\n      }\ncatch (      Base64DecoderException e) {\n        e.printStackTrace();\n      }\n    }\n else {\n      mPendingChecks.offer(validator);\n      runChecks();\n    }\n  }\n}\n", "docstring": "checks if the user should have access to the app . binds the service if necessary . < p > note : this call uses a trivially obfuscated string ( base64 - encoded ) . for best security , we recommend obfuscating the string that is passed into bindservice using another method of your own devising . < p > source string : \" com . android . vending . licensing . ilicensingservice \" < p >", "partition": "test"}
{"idx": "2426", "code": "public void close(){\n  if (!isOpen)   return;\n  Log.d(TAG,\"Trying to close track\");\n  loadingLock.lock();\n  try {\n    save();\n    if (saveFileStream != null) {\n      SavingHelper.close(saveFileStream);\n      saveFileStream=null;\n    }\n    savingDisabled=true;\n    isOpen=false;\n    Log.i(TAG,\"Track closed\");\n  }\n  finally {\n    loadingLock.unlock();\n  }\n}\n", "docstring": "saves and closes the track . the object should not be used afterwards , as saving will be disabled . the save file will never be accessed by this object again , and isopen will be set to false . this will allow to open the track again .", "partition": "test"}
{"idx": "2427", "code": "@Override public List chunkString(String sToChunk){\n  Integer[] iRes=splitPointsByDelimiterList(sToChunk,getDelimiters());\n  String[] sRes=splitStringByDelimiterPoints(sToChunk,iRes);\n  return Arrays.asList(sRes);\n}\n", "docstring": "returns a list of string chunks , derived from a given string .", "partition": "test"}
{"idx": "2428", "code": "public static String convertBooleanArrToString(Boolean[] noDictionaryDimsMapping){\n  StringBuilder builder=new StringBuilder();\n  int index=0;\n  for (; index < noDictionaryDimsMapping.length; index++) {\n    builder.append(noDictionaryDimsMapping[index]);\n    builder.append(CarbonCommonConstants.COMA_SPC_CHARACTER);\n  }\n  int lastIndex=builder.lastIndexOf(CarbonCommonConstants.COMA_SPC_CHARACTER);\n  String str=-1 != lastIndex ? builder.substring(0,lastIndex) : builder.toString();\n  return str;\n}\n", "docstring": "this method will convert boolean [ ", "partition": "test"}
{"idx": "2429", "code": "public void clear(){\n  m_Model.clear();\n  setButtons(null);\n}\n", "docstring": "clears the content of the panel", "partition": "test"}
{"idx": "2430", "code": "public static int brighter(int c){\n  int r=red(c), g=green(c), b=blue(c);\n  int i=(int)(1.0 / (1.0 - scale));\n  if (r == 0 && g == 0 && b == 0) {\n    return rgba(i,i,i,alpha(c));\n  }\n  if (r > 0 && r < i)   r=i;\n  if (g > 0 && g < i)   g=i;\n  if (b > 0 && b < i)   b=i;\n  return rgba(Math.min(255,(int)(r / scale)),Math.min(255,(int)(g / scale)),Math.min(255,(int)(b / scale)),alpha(c));\n}\n", "docstring": "get a brighter shade of an input color .", "partition": "test"}
{"idx": "2431", "code": "public void shutdown(){\n  running=false;\n  if (networkThreads != null) {\n    for (    NetworkThread n : networkThreads) {\n      n.stopped=true;\n    }\n  }\n  networkThreads=null;\nsynchronized (LOCK) {\n    LOCK.notifyAll();\n  }\n}\n", "docstring": "shuts down the network thread , this will trigger failures if you have network requests", "partition": "test"}
{"idx": "2432", "code": "public SerialMessage(byte[] a){\n  super(String.valueOf(a));\n  setBinary(true);\n}\n", "docstring": "this ctor interprets the byte array as a sequence of characters to send .", "partition": "test"}
{"idx": "2433", "code": "@Override @SuppressWarnings(\"unchecked\") public void completed(int bytesTransferred,boolean canInvokeDirect){\n  if (bytesTransferred == 0) {\n    bytesTransferred=-1;\n  }\n else {\n    updateBuffers(bytesTransferred);\n  }\n  releaseBuffers();\nsynchronized (result) {\n    if (result.isDone())     return;\n    enableReading();\n    if (scatteringRead) {\n      result.setResult((V)Long.valueOf(bytesTransferred));\n    }\n else {\n      result.setResult((V)Integer.valueOf(bytesTransferred));\n    }\n  }\n  if (canInvokeDirect) {\n    Invoker.invokeUnchecked(result);\n  }\n else {\n    Invoker.invoke(result);\n  }\n}\n", "docstring": "executed when the i / o has completed", "partition": "test"}
{"idx": "2434", "code": "public void writeGolomb(int divisor,int value){\n  int q=value / divisor;\n  for (int i=0; i < q; i++) {\n    writeBit(1);\n  }\n  writeBit(0);\n  int r=value - q * divisor;\n  int bit=31 - Integer.numberOfLeadingZeros(divisor - 1);\n  if (r < ((2 << bit) - divisor)) {\n    bit--;\n  }\n else {\n    r+=(2 << bit) - divisor;\n  }\n  for (; bit >= 0; bit--) {\n    writeBit((r >>> bit) & 1);\n  }\n}\n", "docstring": "write the golomb code of a value .", "partition": "test"}
{"idx": "2435", "code": "private static MetricValue number_to_metric_value_(Number elem){\n  if (elem == null)   return MetricValue.EMPTY;\n  final String num=elem.toString();\n  try {\n    return MetricValue.fromIntValue(Long.parseLong(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  try {\n    return MetricValue.fromDblValue(Double.parseDouble(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  return MetricValue.fromStrValue(num);\n}\n", "docstring": "work around for google gson parser emitting numbers as \"'\" lazily parsed \"'\" numbers .", "partition": "test"}
{"idx": "2436", "code": "public boolean overlaps(String sequence,int start,int end){\n  if (start == MISSING || end == MISSING || end < start) {\n    throw new IllegalArgumentException();\n  }\n  if (!mSequence.equals(sequence)) {\n    return false;\n  }\n  if ((mEnd != MISSING && start >= mEnd) || (end <= mStart)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "test whether the specified range overlaps the current region", "partition": "test"}
{"idx": "2437", "code": "public OkapiBM25(double k1,double b){\n  if (Double.isNaN(k1) || Double.isInfinite(k1) || k1 < 0)   throw new IllegalArgumentException(\"coefficient k1 must be a non negative constant, not \" + k1);\n  this.k1=k1;\n  if (Double.isNaN(b) || b < 0 || b > 1)   throw new IllegalArgumentException(\"coefficient b must be in the range [0,1], not \" + b);\n  this.b=b;\n}\n", "docstring": "creates a new okapi object", "partition": "test"}
{"idx": "2438", "code": "protected void prepare(){\n  for (  ProcessInfoParameter para : getParameter()) {\n    String name=para.getParameterName();\n    if (para.getParameter() == null)     ;\n else     if (name.equals(PARAM_M_Warehouse_ID))     p_M_Warehouse_ID=para.getParameterAsInt();\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n  p_C_Invoice_ID=getRecord_ID();\n}\n", "docstring": "prepare - e . g . , get parameters .", "partition": "test"}
{"idx": "2439", "code": "public boolean isConfigured(){\n  LOG.debug(\"lookup url: \" + url);\n  return url != null && !url.isEmpty();\n}\n", "docstring": "method to quickly indicate if the service is not configured .", "partition": "test"}
{"idx": "2440", "code": "private static void FatalError(JNIEnvironment env,Address messageAddress){\n  if (traceJNI)   VM.sysWrite(\"JNI called: FatalError  \\n\");\n  RuntimeEntrypoints.checkJNICountDownToGC();\n  try {\n    VM.sysWrite(JNIGenericHelpers.createStringFromC(messageAddress));\n    System.exit(EXIT_STATUS_JNI_TROUBLE);\n  }\n catch (  Throwable unexpected) {\n    if (traceJNI)     unexpected.printStackTrace(System.err);\n    System.exit(EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN);\n  }\n}\n", "docstring": "fatalerror : print a message and terminate the vm", "partition": "test"}
{"idx": "2441", "code": "public boolean makeBackupFile(String directory,File file){\n  if (file == null) {\n    log.info(\"No file to backup\");\n  }\n else   if (file.canWrite()) {\n    String backupFullName=directory + File.separator + createFileNameWithDate(file.getName());\n    if (log.isDebugEnabled()) {\n      log.debug(\"new backup file: \" + backupFullName);\n    }\n    File backupFile=findFile(backupFullName);\n    if (backupFile != null) {\n      if (backupFile.delete()) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"deleted backup file \" + backupFullName);\n        }\n      }\n    }\n else {\n      backupFile=new File(backupFullName);\n    }\n    File parentDir=backupFile.getParentFile();\n    if (!parentDir.exists()) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"creating backup directory: \" + parentDir.getName());\n      }\n      if (!parentDir.mkdirs()) {\n        log.error(\"backup directory not created\");\n        return false;\n      }\n    }\n    if (file.renameTo(new File(backupFullName))) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"created new backup file \" + backupFullName);\n      }\n    }\n else {\n      if (log.isDebugEnabled()) {\n        log.debug(\"could not create backup file \" + backupFullName);\n      }\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "move original file to backup directory .", "partition": "test"}
{"idx": "2442", "code": "public void removeStorage() throws BackupException {\n  logger.debug(\"Removing contents of storage directory: \" + dataDirSpec.getAbsolutePath());\n  processHelper.exec(\"Removing contents of storage directory\",rmCmd);\n}\n", "docstring": "clears storage in preparation for restore operation .", "partition": "test"}
{"idx": "2443", "code": "private void appendContainerConfig(DockerSlaveTemplate slaveTemplate,CreateContainerCmd containerConfig){\n  Map<String,String> labels=containerConfig.getLabels();\n  if (labels == null) {\n    labels=new HashMap<>();\n  }\n  labels.put(DOCKER_CLOUD_LABEL,getDisplayName());\n  labels.put(DOCKER_TEMPLATE_LABEL,slaveTemplate.getId());\n  containerConfig.withLabels(labels);\n}\n", "docstring": "cloud specific container config options", "partition": "test"}
{"idx": "2444", "code": "ReadOnlyGameSettings(){\n}\n", "docstring": "constructs game settings with default parameters", "partition": "test"}
{"idx": "2445", "code": "public void removeRegion(Region r){\n  regions.remove(r);\n}\n", "docstring": "include a region in the model", "partition": "test"}
{"idx": "2446", "code": "public static void silentCloseInputStream(InputStream is){\n  try {\n    if (is != null) {\n      is.close();\n    }\n  }\n catch (  IOException e) {\n    log.w(LOG_TAG,\"Cannot close input stream\",e);\n  }\n}\n", "docstring": "a utility function to close an input stream without raising an exception .", "partition": "test"}
{"idx": "2447", "code": "@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {\n  if (requestID == null && localName.equals(\"batchRequest\")) {\n    requestID=attributes.getValue(\"requestID\");\n  }\n  super.startElement(uri,localName,qName,attributes);\n}\n", "docstring": "this function fetches the requestid value of the batchrequest xml element and call the default implementation ( super ) .", "partition": "test"}
{"idx": "2448", "code": "public void stop(int timeout) throws InterruptedException {\n  if (!isclosed.compareAndSet(false,true)) {\n    return;\n  }\n  List<WebSocket> socketsToClose=null;\nsynchronized (connections) {\n    socketsToClose=new ArrayList<WebSocket>(connections);\n  }\n  for (  WebSocket ws : socketsToClose) {\n    ws.close(CloseFrame.GOING_AWAY);\n  }\nsynchronized (this) {\n    if (selectorthread != null) {\n      if (Thread.currentThread() != selectorthread) {\n      }\n      if (selectorthread != Thread.currentThread()) {\n        if (socketsToClose.size() > 0)         selectorthread.join(timeout);\n        selectorthread.interrupt();\n        selectorthread.join();\n      }\n    }\n  }\n}\n", "docstring": "closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads . if this method is called before the server is started it will never start .", "partition": "test"}
{"idx": "2449", "code": "public Storage(){\n  this(new File(getTemporaryStorageDirectoryString()));\n}\n", "docstring": "creates new instance of storage for storing temporary data . the storage directory is initialized by gettemporarystoragedirectory ( ) value .", "partition": "test"}
{"idx": "2450", "code": "protected void calculateItemWidth(CategoryPlot plot,Rectangle2D dataArea,int rendererIndex,CategoryItemRendererState state){\n  CategoryAxis domainAxis=getDomainAxis(plot,rendererIndex);\n  CategoryDataset dataset=plot.getDataset(rendererIndex);\n  if (dataset != null) {\n    int columns=dataset.getColumnCount();\n    int rows=state.getVisibleSeriesCount() >= 0 ? state.getVisibleSeriesCount() : dataset.getRowCount();\n    double space=0.0;\n    PlotOrientation orientation=plot.getOrientation();\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      space=dataArea.getHeight();\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      space=dataArea.getWidth();\n    }\n    double maxWidth=space * getMaximumItemWidth();\n    double categoryMargin=0.0;\n    double currentItemMargin=0.0;\n    if (columns > 1) {\n      categoryMargin=domainAxis.getCategoryMargin();\n    }\n    if (rows > 1) {\n      currentItemMargin=getItemMargin();\n    }\n    double used=space * (1 - domainAxis.getLowerMargin() - domainAxis.getUpperMargin()- categoryMargin- currentItemMargin);\n    if ((rows * columns) > 0) {\n      state.setBarWidth(Math.min(used / (rows * columns),maxWidth));\n    }\n else {\n      state.setBarWidth(Math.min(used,maxWidth));\n    }\n  }\n}\n", "docstring": "calculates the bar width and stores it in the renderer state .", "partition": "test"}
{"idx": "2451", "code": "@RequiresPermission(Manifest.permission.CAMERA) public CameraSource start() throws IOException {\nsynchronized (mCameraLock) {\n    if (mCamera != null) {\n      return this;\n    }\n    mCamera=createCamera();\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n      mDummySurfaceTexture=new SurfaceTexture(DUMMY_TEXTURE_NAME);\n      mCamera.setPreviewTexture(mDummySurfaceTexture);\n    }\n else {\n      mDummySurfaceView=new SurfaceView(mContext);\n      mCamera.setPreviewDisplay(mDummySurfaceView.getHolder());\n    }\n    mCamera.startPreview();\n    isSafeToTakePicture=true;\n    mProcessingThread=new Thread(mFrameProcessor);\n    mFrameProcessor.setActive(true);\n    mProcessingThread.start();\n  }\n  return this;\n}\n", "docstring": "opens the camera and starts sending preview frames to the underlying detector . the preview frames are not displayed .", "partition": "test"}
{"idx": "2452", "code": "public void addBreakpointListener(final BreakpointListener listener){\n  breakpointListeners.add(listener);\n}\n", "docstring": "adds a breakpoint listener .", "partition": "test"}
{"idx": "2453", "code": "public void update(Graphics g){\n  if (isShowing()) {\n    if (!(peer instanceof LightweightPeer)) {\n      g.clearRect(0,0,width,height);\n    }\n    paint(g);\n  }\n}\n", "docstring": "updates the container . this forwards the update to any lightweight components that are children of this container . if this method is reimplemented , super . update ( g ) should be called so that lightweight components are properly rendered . if a child component is entirely clipped by the current clipping setting in g , update ( ) will not be forwarded to that child .", "partition": "test"}
{"idx": "2454", "code": "public static void printStackTrace(Throwable e){\n  try {\n    Debug.printStackTrace(e);\n  }\n catch (  Throwable f) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "used in environments where full debug may not be available", "partition": "test"}
{"idx": "2455", "code": "@Override public Void visitType(TypeElement e,Void p){\n  scan(e.getTypeParameters(),p);\n  checkCamelCase(e,true);\n  super.visitType(e,p);\n  return null;\n}\n", "docstring": "check the name of a type and its enclosed elements and type parameters .", "partition": "test"}
{"idx": "2456", "code": "public Block(boolean multiPush){\n  this(multiPush,\"block\",null,Arrays.asList(\"scrape-1\",\"scrape-2\"));\n}\n", "docstring": "create a new block with default style at ( startx , starty )", "partition": "test"}
{"idx": "2457", "code": "private double Poisson(double x){\n  return Math.exp(-m_Lambda + (x * Math.log(m_Lambda)) - logFac(x));\n}\n", "docstring": "returns value for poisson distribution", "partition": "test"}
{"idx": "2458", "code": "protected Expression findExpression(String source){\n  if (source != null && source.length() > 0) {\n    source=source.trim();\n    if (source.length() == 0) {\n      return null;\n    }\n    String leftSide=source;\n    String rightSide=null;\n    Connector op=findOp(leftSide);\n    if (op != null) {\n      rightSide=op.getRightSide(leftSide);\n      leftSide=leftSide.substring(0,op.sourceLoc);\n      Expression leftExpression=findExpression(leftSide);\n      Expression rightExpression=findExpression(rightSide);\n      if (leftExpression != null) {\n        op.addExpr(leftExpression);\n      }\n      if (rightExpression != null) {\n        op.addExpr(rightExpression);\n      }\n      return op;\n    }\n    op=findMiniOp(leftSide);\n    if (op != null) {\n      rightSide=op.getRightSide(leftSide);\n      leftSide=leftSide.substring(0,op.sourceLoc);\n      Expression leftExpression=findExpression(leftSide);\n      Expression rightExpression=findExpression(rightSide);\n      if (leftExpression != null) {\n        op.addExpr(leftExpression);\n      }\n      if (rightExpression != null) {\n        op.addExpr(rightExpression);\n      }\n      return op;\n    }\n    if (logger.isLoggable(Level.FINER)) {\n      logger.finer(\"need to break up: \" + source);\n    }\n    return findMathOp(source);\n  }\n  return null;\n}\n", "docstring": "recursive parsing statement . keys on connectors ( and , or ) and builds expressions based on those . then looks for mini connectors ( and , or ) and builds on those . of course , there might just be one expression here , one that is separated by an operator .", "partition": "test"}
{"idx": "2459", "code": "void putChannel(final StoredClientChannel channel){\n  putChannel(channel,true);\n}\n", "docstring": "adds the given channel to this set of stored states , broadcasting the contract and refund transactions when the channel expires and notifies the wallet of an update to this wallet extension", "partition": "test"}
{"idx": "2460", "code": "@SuppressWarnings(\"ResultOfMethodCallIgnored\") public static void pipeInputToOutputStream(InputStream in,File fileOut,boolean ignoreErrors) throws IOException {\n  if (fileOut == null) {\n    logger.error(\"The output filename doesn\'t exist or is invalid\");\n    if (!ignoreErrors) {\n      throw new IOException(\"The output filename doesn\'t exist or is invalid\");\n    }\n  }\n else {\n    File parent=fileOut.getParentFile();\n    if (parent != null && !parent.exists()) {\n      parent.mkdirs();\n    }\n    OutputStream fileStream=null;\n    try {\n      fileStream=new FileOutputStream(fileOut);\n      pipeInputToOutputStream(in,fileStream,true,ignoreErrors);\n    }\n catch (    IOException e) {\n      if (fileStream != null) {\n        try {\n          fileStream.close();\n        }\n catch (        IOException ex) {\n          logger.error(\"Cannot close stream - {}\",ex.getMessage());\n        }\n      }\n      if (!ignoreErrors) {\n        throw e;\n      }\n    }\n  }\n}\n", "docstring": "convenient way of sending data from an input stream to an output file in the most efficient way possible", "partition": "test"}
{"idx": "2461", "code": "public E take() throws InterruptedException {\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null)       available.await();\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n else         if (leader != null)         available.await();\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            available.awaitNanos(delay);\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}\n", "docstring": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .", "partition": "test"}
{"idx": "2462", "code": "public boolean threadSafeTimeout(long delayTime,TimeUnit unit,Action0 action){\n  boolean scheduled=true;\n  Thread currentThread=Thread.currentThread();\n  if (currentThread.equals(dutyThread)) {\n    timerWheel.newTimeout(delayTime,unit,null);\n  }\n else {\n    scheduled=actions.offer(null);\n  }\n  return scheduled;\n}\n", "docstring": "schedules timeout on the timerwheel in a thread - safe manner", "partition": "test"}
{"idx": "2463", "code": "void addAttributeSelection(String exp){\n  int index=exp.indexOf(\'=\');\n  String value=null;\n  int constraint=AttString.EQUALS;\n  if (index != -1) {\n    if (index == 0) {\n      setTagId(TAG_CSS_ILLEGAL_SELECTOR);\n      return;\n    }\n    int opIndex=index;\n    char c=exp.charAt(index - 1);\n    if (c == \'~\') {\n      constraint=AttString.CONTAINS_WORD;\n      opIndex--;\n    }\n else     if (c == \'|\') {\n      constraint=AttString.BEGINS_WITH;\n      opIndex--;\n    }\n    value=exp.substring(index + 1);\n    if (((value.startsWith(\"\\\"\")) && (value.endsWith(\"\\\"\"))) || ((value.startsWith(\"\'\")) && (value.endsWith(\"\'\")))) {\n      value=value.substring(1,value.length() - 1);\n    }\n    exp=exp.substring(0,opIndex);\n  }\n  if (attributeSelections == null) {\n    attributeSelections=new Vector();\n  }\n  attributeSelections.addElement(new AttString(exp,constraint,value));\n}\n", "docstring": "adds the given attribute selection", "partition": "test"}
{"idx": "2464", "code": "public Value sample(){\n  int index=sampler.nextInt(actionValues.size());\n  if (actionValuesAsArray == null) {\n    actionValuesAsArray=actionValues.toArray(new Value[actionValues.size()]);\n  }\n  return actionValuesAsArray[index];\n}\n", "docstring": "returns a sample point for the action , assuming a uniform distribution over the action values", "partition": "test"}
{"idx": "2465", "code": "@Override public void channelClosed(ChannelHandlerContext channelHandlerContext,ChannelStateEvent channelStateEvent) throws Exception {\n  curr_conns.decrementAndGet();\n  channelGroup.remove(channelHandlerContext.getChannel());\n}\n", "docstring": "on close we manage some statistics , and remove this connection from the channel group .", "partition": "test"}
{"idx": "2466", "code": "private static void configureHeadLessSimulation(){\n  System.setProperty(\"java.awt.headless\",\"true\");\n  GAMA.setHeadLessMode();\n}\n", "docstring": "load in headless mode a specified model and create an experiment", "partition": "test"}
{"idx": "2467", "code": "public static boolean isNextWindow(URI id){\n  return id == null || NEXT.equals(id);\n}\n", "docstring": "determines if this id corresponds to the \"'\" next \"'\" execution window .", "partition": "test"}
{"idx": "2468", "code": "public byte[] remove(QueueEvent event) throws KeeperException, InterruptedException {\n  TimerContext time=stats.time(dir + \"_remove_event\");\n  try {\n    String path=event.getId();\n    String responsePath=dir + \"/\" + response_prefix+ path.substring(path.lastIndexOf(\"-\") + 1);\n    if (zookeeper.exists(responsePath,true)) {\n      zookeeper.setData(responsePath,event.getBytes(),true);\n    }\n    byte[] data=zookeeper.getData(path,null,null,true);\n    zookeeper.delete(path,-1,true);\n    return data;\n  }\n  finally {\n    time.stop();\n  }\n}\n", "docstring": "remove the event and save the response into the other path .", "partition": "test"}
{"idx": "2469", "code": "public PropertyXMLBuilder(ServiceSchema serviceSchema,AMModel model,Set attributeSchemas) throws SMSException, SSOException {\n  this.model=model;\n  this.serviceName=serviceSchema.getServiceName();\n  getServiceResourceBundle(serviceSchema);\n  if (serviceBundle != null) {\n    mapTypeToAttributeSchema=new HashMap(attributeSchemas.size() * 2);\n    mapTypeToAttributeSchema.put(NULL_TYPE,attributeSchemas);\n  }\n}\n", "docstring": "returns a xml for displaying attribute in property sheet .", "partition": "test"}
{"idx": "2470", "code": "public boolean is(String arg,boolean allowAbbr){\n  if (name.equalsIgnoreCase(arg)) {\n    return true;\n  }\n  if (allowAbbr && arg.length() == 1) {\n    if (arg.charAt(0) == c) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the atg string matches the name of the arg , or , if allowabbr is true , returns true if the arg length is one and it matches the first letter of the arg name .", "partition": "test"}
{"idx": "2471", "code": "static public void addAll(List<String> list,String[] array){\n  for (  String item : array)   list.add(item);\n}\n", "docstring": "adds all items in the specific array to the specific list .", "partition": "test"}
{"idx": "2472", "code": "void remove(SuperCardToast superCardToast){\n  mList.remove(superCardToast);\n}\n", "docstring": "removes a supercardtoast from the list .", "partition": "test"}
{"idx": "2473", "code": "public void test_vmstat_header_and_data_parse(){\n  final Pattern pattern=VMStatCollector.pattern;\n  final String header=\"  r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\";\n  final String data=\"  1  0     96 178580 206520 1170604   56   12     0     7    1    0  1  0 99  3  0\";\n{\n    final String[] fields=pattern.split(header.trim(),0);\n    for (int i=0; i < fields.length; i++) {\n      if (log.isInfoEnabled())       log.info(\"fields[\" + i + \"]=[\"+ fields[i]+ \"]\");\n    }\n    assertField(header,fields,2,\"swpd\");\n    assertField(header,fields,3,\"free\");\n    assertField(header,fields,6,\"si\");\n    assertField(header,fields,7,\"so\");\n    assertField(header,fields,12,\"us\");\n    assertField(header,fields,13,\"sy\");\n    assertField(header,fields,14,\"id\");\n    assertField(header,fields,15,\"wa\");\n  }\n{\n    final String[] fields=pattern.split(data.trim(),0);\n    assertField(data,fields,2,\"96\");\n    assertField(data,fields,3,\"178580\");\n    assertField(data,fields,6,\"56\");\n    assertField(data,fields,7,\"12\");\n    assertField(data,fields,12,\"1\");\n    assertField(data,fields,13,\"0\");\n    assertField(data,fields,14,\"99\");\n    assertField(data,fields,15,\"3\");\n  }\n}\n", "docstring": "test based on some sample data .", "partition": "test"}
{"idx": "2474", "code": "private String partiallyEscapeAssertionValue(String assertionValue){\n  StringBuilder sb=new StringBuilder(assertionValue.length());\n  for (int j=0; j < assertionValue.length(); j++) {\n    char c=assertionValue.charAt(j);\n    if (c == '*') {\n      sb.append(c);\n    }\n else {\n      sb.append(Filter.escapeAssertionValue(String.valueOf(c)));\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "escapes the provided assertion value according to the ldap standard . as a special case this method does not escape the \"'\" * \"'\" character , in order to be able to use wildcards in filters .", "partition": "test"}
{"idx": "2475", "code": "@Override public void step(MessageLogger logger){\n  try {\n    addAgent();\n    env.step();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "executes one simulation step .", "partition": "test"}
{"idx": "2476", "code": "public static AttackStatus calculatePhysicalStatus(Creature attacker,Creature attacked,boolean isMainHand){\n  return calculatePhysicalStatus(attacker,attacked,isMainHand,0,100,false,false);\n}\n", "docstring": "manage attack status rate", "partition": "test"}
{"idx": "2477", "code": "public T vertexProcessor(final BiConsumer<Vertex,Map<String,Object>> vertexProcessor){\n  this.vertexProcessor=Optional.ofNullable(vertexProcessor);\n  return extendingClass.cast(this);\n}\n", "docstring": "the function supplied here may be called more than once per vertex depending on the implementation .", "partition": "test"}
{"idx": "2478", "code": "synchronized boolean release(){\n  d(\"release()\");\n  if (state == BUSY) {\n    state=IDLE;\n    idleSince=System.currentTimeMillis();\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "changes the state of a connectiondesc from busy to idle and records the current time so that we will know how long it has been idle .", "partition": "test"}
{"idx": "2479", "code": "private void validateReplicaAvailability(Slice slice,String shard,String collectionName,int count){\n  if (slice != null) {\n    Collection<Replica> allReplicasForShard=slice.getReplicas();\n    if (allReplicasForShard == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"No replicas found  in shard/collection: \" + shard + \"/\"+ collectionName);\n    }\n    if (allReplicasForShard.size() == 1) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"There is only one replica available in shard/collection: \" + shard + \"/\"+ collectionName+ \". Cannot delete that.\");\n    }\n    if (allReplicasForShard.size() <= count) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"There are lesser num replicas requested to be deleted than are available in shard/collection : \" + shard + \"/\"+ collectionName+ \" Requested: \"+ count+ \" Available: \"+ allReplicasForShard.size()+ \".\");\n    }\n  }\n}\n", "docstring": "validate if there is less replicas than requested to remove . also error out if there is only one replica available", "partition": "test"}
{"idx": "2480", "code": "default ClassDeclaration asClass(){\n  throw new UnsupportedOperationException(String.format(\"%s is not a class\",this));\n}\n", "docstring": "return this as a classdeclaration or throw unsupportedoperationexception .", "partition": "test"}
{"idx": "2481", "code": "private static String partitionSpecToName(Map<String,String> spec){\n  StringBuilder sb=new StringBuilder();\n  for (  Map.Entry<String,String> entry : spec.entrySet()) {\n    if (sb.length() != 0) {\n      sb.append(\"/\");\n    }\n    sb.append(entry.getKey() + \"=\" + entry.getValue());\n  }\n  return sb.toString();\n}\n", "docstring": "converts a map of partition key - value pairs to a name . note that special characters are not escaped unlike in production , and the order of the key is dictated by the iteration order for the map .", "partition": "test"}
{"idx": "2482", "code": "@Modifying @Transactional public void deleteCheque(@PathVariable Long chequeID){\n  chequeRepository.delete(chequeID);\n  photoRepository.deleteByChequeId(chequeID.toString());\n}\n", "docstring": "method deletecheque remove cheque from db by id", "partition": "test"}
{"idx": "2483", "code": "public static synchronized double partialCorrelation(TetradMatrix submatrix){\n  try {\n    TetradMatrix inverse=submatrix.inverse();\n    double a=-1.0 * inverse.get(0,1);\n    double v0=inverse.get(0,0);\n    double v1=inverse.get(1,1);\n    double b=Math.sqrt(v0 * v1);\n    return a / b;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return Double.NaN;\n  }\n}\n", "docstring": "assumes that the given covariance matrix was extracted in such a way that the order of the variables ( in either direction ) is x , y , z1 , . . . , zn , where the partial correlation one wants is correlation ( x , y | z1 , . . . , zn ) . this may be extracted using datautils . submatrix ( ) .", "partition": "test"}
{"idx": "2484", "code": "public void addColumn(String name,String expr){\n  Expression ex=ExpressionParser.parse(expr);\n  Throwable t=ExpressionParser.getError();\n  if (t != null) {\n    throw new RuntimeException(t);\n  }\n else {\n    addColumn(name,ex);\n  }\n}\n", "docstring": "add a derived column to this table , using an expression instance to dynamically calculate the column data values .", "partition": "test"}
{"idx": "2485", "code": "public void addPutAndGetTimeNanos(long duration){\n  putTimeNanos.addAndGet(duration);\n  getTimeNanos.addAndGet(duration);\n  if (delegate != null)   delegate.addPutAndGetTimeNanos(duration);\n}\n", "docstring": "increments put and get time accumulators .", "partition": "test"}
{"idx": "2486", "code": "private float checkSaturationValid(final float val){\n  float tempval=val;\n  if (val > 1) {\n    tempval=1;\n  }\n  if (val < 0) {\n    tempval=0;\n  }\n  return tempval;\n}\n", "docstring": "check whether the specified saturation is valid or not .", "partition": "test"}
{"idx": "2487", "code": "String parse(String cellStr,int layoutConstant){\n  return cellStr.split(LayoutConstants.CELL_PTRN)[layoutConstant];\n}\n", "docstring": "utility method to parse a cell definition for a particular value .", "partition": "test"}
{"idx": "2488", "code": "public void pseudoPropertyChange(String propName,Object old,Object n){\n  if (log.isDebugEnabled()) {\n    log.debug(\"pseudoPropertyChange: Block \\\"\" + getSystemName() + \" property \\\"\"+ propName+ \"\\\" new value= \"+ n.toString());\n  }\n  firePropertyChange(propName,old,n);\n}\n", "docstring": "call for circuit builder to make icon color changes for its gui", "partition": "test"}
{"idx": "2489", "code": "public static String runCmd(File directory,List<String> cmd,String errorMessage) throws Exception {\n  ProcessBuilder pb=new ProcessBuilder(cmd);\n  pb.directory(directory);\n  pb.redirectErrorStream(true);\n  Process p=pb.start();\n  String s;\n  StringBuilder sb=new StringBuilder();\n  BufferedReader stdout=new BufferedReader(new InputStreamReader(p.getInputStream()));\n  while ((s=stdout.readLine()) != null) {\n    logger.info(s);\n    sb.append(s);\n    sb.append(\'\\n\');\n  }\n  String sbs=sb.toString();\n  int exitValue=p.waitFor();\n  if (exitValue != 0)   throw new Exception(errorMessage + \" exit value \" + exitValue+ \"  \"+ sbs);\n  return sbs;\n}\n", "docstring": "run command cmd in separate process in directory", "partition": "test"}
{"idx": "2490", "code": "@Override public SelectableChannel selectableChannel(){\n  return socketChannel;\n}\n", "docstring": "returns the socketchannel underlying this socketcommchannel", "partition": "test"}
{"idx": "2491", "code": "public static String fromTag(ByteArrayTag tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  byte value : tag.getValue()) {\n    ByteTag b=new ByteTag(value);\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromTag(b));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}\n", "docstring": "creates a mojangson string from the given bytearray tag .", "partition": "test"}
{"idx": "2492", "code": "@Override protected void addChooserFilters(JFileChooser chooser){\n  javax.swing.filechooser.FileNameExtensionFilter filter=new javax.swing.filechooser.FileNameExtensionFilter(Bundle.getMessage(\"FileFilterLabel\",\"*.dfm, *.hex\"),\"dmf\",\"hex\");\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Digitrax Mangled Firmware (*.dmf)\",\"dmf\"));\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Intel Hex Format Firmware (*.hex)\",\"hex\"));\n  chooser.addChoosableFileFilter(filter);\n  chooser.setFileFilter(filter);\n}\n", "docstring": "add filter ( s ) for possible types to the input file chooser .", "partition": "test"}
{"idx": "2493", "code": "private static byte[] WindowsRegEnumValue1(int hKey,int valueIndex,int maxValueNameLength){\n  byte[] result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "retries regenumvalueex ( ) max_attempts times before giving up .", "partition": "test"}
{"idx": "2494", "code": "public static DateTime parseRfc822(String str) throws ParseException {\n  Date date;\nsynchronized (dateTimeFormat822) {\n    try {\n      date=dateTimeFormat822.parse(str);\n    }\n catch (    java.text.ParseException e) {\n      throw new ParseException(e);\n    }\n  }\n  return new DateTime(date);\n}\n", "docstring": "parses the value as an rfc 822 date / time .", "partition": "test"}
{"idx": "2495", "code": "public void testEmptyIndex() throws Exception {\n  IndexSearcher empty=newSearcher(new MultiReader());\n  Query query=new TermQuery(new Term(\"contents\",\"foo\"));\n  Sort sort=new Sort();\n  TopDocs td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"int\",SortField.Type.INT),SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"string\",SortField.Type.STRING,true),SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"string_val\",SortField.Type.STRING_VAL,true),SortField.FIELD_DOC);\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n  sort.setSort(new SortField(\"float\",SortField.Type.FLOAT),new SortField(\"string\",SortField.Type.STRING));\n  td=empty.search(query,10,sort,true,true);\n  assertEquals(0,td.totalHits);\n}\n", "docstring": "test sorts when there \"'\" s nothing in the index", "partition": "test"}
{"idx": "2496", "code": "public Model validateModel(Dataset dataset,URI shapesGraphURI,Resource minSeverity,boolean validateShapes,Function<RDFNode,String> labelFunction,ProgressMonitor monitor) throws InterruptedException {\n  if (dataset.getDefaultModel() == null) {\n    throw new IllegalArgumentException(\"Dataset requires a default model\");\n  }\n  Model shapesModel=dataset.getNamedModel(shapesGraphURI.toString());\n  if (monitor != null) {\n    monitor.subTask(\"Preparing execution plan\");\n  }\n  List<Property> constraintProperties=SHACLUtil.getAllConstraintProperties(validateShapes);\n  Map<Resource,List<SHConstraint>> map=buildShape2ConstraintsMap(shapesModel,dataset.getDefaultModel(),constraintProperties,validateShapes);\n  if (monitor != null) {\n    monitor.subTask(\"\");\n  }\n  if (monitor != null) {\n    monitor.beginTask(\"Validating constraints for \" + map.size() + \" shapes...\",map.size());\n  }\n  Model results=JenaUtil.createMemoryModel();\n  results.setNsPrefixes(dataset.getDefaultModel());\n  for (  Resource shape : map.keySet()) {\n    for (    SHConstraint constraint : map.get(shape)) {\n      validateConstraintForShape(dataset,shapesGraphURI,minSeverity,constraint,shape,results,labelFunction,monitor);\n      if (monitor != null) {\n        monitor.worked(1);\n        if (monitor.isCanceled()) {\n          throw new InterruptedException();\n        }\n      }\n    }\n  }\n  return results;\n}\n", "docstring": "validates all resources in a given model , which is expected to be the default graph of a given dataset .", "partition": "test"}
{"idx": "2497", "code": "public PdfPage addAnnotation(PdfAnnotation annotation){\n  return addAnnotation(-1,annotation,true);\n}\n", "docstring": "adds specified annotation to the end of annotations array and tagged it . may be used in chain .", "partition": "test"}
{"idx": "2498", "code": "public static String findPreferredIDP(String realm,HttpServletRequest request){\n  if (request == null) {\n    return null;\n  }\n  String succinctID=request.getParameter(IFSConstants.PROVIDER_ID_KEY);\n  if ((succinctID == null) || succinctID.length() == 0) {\n    debug.message(\"FSUtils.findPreferredIDP::Pref IDP not found.\");\n    return null;\n  }\n  succinctID=succinctID.trim();\n  String preferredSuccinctId=null;\n  StringTokenizer st=new StringTokenizer(succinctID,\" \");\n  while (st.hasMoreTokens()) {\n    preferredSuccinctId=st.nextToken();\n    if ((preferredSuccinctId.length() < 28) && st.hasMoreTokens()) {\n      preferredSuccinctId=preferredSuccinctId + \"+\" + st.nextToken();\n    }\n  }\n  preferredSuccinctId=SAMLUtils.byteArrayToString(Base64.decode(preferredSuccinctId));\n  return getProviderIDFromSuccinctID(realm,preferredSuccinctId);\n}\n", "docstring": "finds the preferred idp from the httpservletrequest .", "partition": "test"}
{"idx": "2499", "code": "private void checkAndCreateDirectory(final String directoryName){\n  try {\n    final File dir=new File(directoryName);\n    if (!dir.exists() && dir.mkdirs()) {\n      _logger.debug(\"Debug dump directory created successfully.\");\n    }\n  }\n catch (  Exception ex) {\n    _logger.error(\"Debug dump directory creation failed due to {}\",ex.getMessage());\n  }\n}\n", "docstring": "verify whether directory already exists or not . if it is not there create one .", "partition": "test"}
{"idx": "2500", "code": "public int findEventPositionNearestTime(Time time,long id){\n  if (mRowInfo == null) {\n    return 0;\n  }\n  long millis=time.toMillis(false);\n  long minDistance=Integer.MAX_VALUE;\n  long idFoundMinDistance=Integer.MAX_VALUE;\n  int minIndex=0;\n  int idFoundMinIndex=0;\n  int eventInTimeIndex=-1;\n  int allDayEventInTimeIndex=-1;\n  int allDayEventDay=0;\n  int minDay=0;\n  boolean idFound=false;\n  int len=mRowInfo.size();\n  for (int index=0; index < len; index++) {\n    RowInfo row=mRowInfo.get(index);\n    if (row.mType == TYPE_DAY) {\n      continue;\n    }\n    if (row.mEventId == id) {\n      if (row.mEventStartTimeMilli == millis) {\n        return index;\n      }\n      long distance=Math.abs(millis - row.mEventStartTimeMilli);\n      if (distance < idFoundMinDistance) {\n        idFoundMinDistance=distance;\n        idFoundMinIndex=index;\n      }\n      idFound=true;\n    }\n    if (!idFound) {\n      if (millis >= row.mEventStartTimeMilli && millis <= row.mEventEndTimeMilli) {\n        if (row.mAllDay) {\n          if (allDayEventInTimeIndex == -1) {\n            allDayEventInTimeIndex=index;\n            allDayEventDay=row.mDay;\n          }\n        }\n else         if (eventInTimeIndex == -1) {\n          eventInTimeIndex=index;\n        }\n      }\n else       if (eventInTimeIndex == -1) {\n        long distance=Math.abs(millis - row.mEventStartTimeMilli);\n        if (distance < minDistance) {\n          minDistance=distance;\n          minIndex=index;\n          minDay=row.mDay;\n        }\n      }\n    }\n  }\n  if (idFound) {\n    return idFoundMinIndex;\n  }\n  if (eventInTimeIndex != -1) {\n    return eventInTimeIndex;\n  }\n else   if (allDayEventInTimeIndex != -1 && minDay != allDayEventDay) {\n    return allDayEventInTimeIndex;\n  }\n  return minIndex;\n}\n", "docstring": "finds the position in the cursor of the event that best matches the time and id . it will try to find the event that has the specified id and start time , if such event doesn \"'\" t exist , it will return the event with a matching id that is closest to the start time . if the id doesn \"'\" t exist , it will return the event with start time closest to the specified time .", "partition": "test"}
{"idx": "2501", "code": "final public void println(float v){\n  String s=String.valueOf(v);\n  write(s,0,s.length());\n  println();\n}\n", "docstring": "prints a float followed by a newline .", "partition": "test"}
{"idx": "2502", "code": "private static TranslationResult extractRegister(final ITranslationEnvironment environment,final long offset,final String subRegister) throws InternalTranslationException {\n  final ArrayList<ReilInstruction> instructions=new ArrayList<ReilInstruction>();\n  final String parentRegister=getParentRegister(subRegister);\n  final OperandSize archSize=environment.getArchitectureSize();\n  if (isHigher8BitRegister(subRegister)) {\n    final String maskResult=environment.getNextVariableString();\n    final String shiftResult=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAnd(offset,archSize,parentRegister,OperandSize.WORD,\"65280\",OperandSize.WORD,maskResult));\n    instructions.add(ReilHelpers.createBsh(offset + 1,OperandSize.WORD,maskResult,OperandSize.WORD,\"-8\",OperandSize.BYTE,shiftResult));\n    return new TranslationResult(shiftResult,OperandSize.BYTE,TranslationResultType.REGISTER,null,instructions,offset);\n  }\n else {\n    final OperandSize subRegisterSize=getRegisterSize(subRegister);\n    final String mask=String.valueOf(TranslationHelpers.getAllBitsMask(subRegisterSize));\n    final String result=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAnd(offset,archSize,parentRegister,subRegisterSize,mask,subRegisterSize,result));\n    return new TranslationResult(result,subRegisterSize,TranslationResultType.REGISTER,null,instructions,offset);\n  }\n}\n", "docstring": "extracts a subregister ( like ax , al , ah ) from a parent register ( like eax )", "partition": "test"}
{"idx": "2503", "code": "public void onLoginFailure(Map requestParamsMap,HttpServletRequest req,HttpServletResponse res) throws AuthenticationException {\n  debug.message(\"ReplayPasswd.onLoginFailure: called\");\n}\n", "docstring": "post processing on failed authentication .", "partition": "test"}
{"idx": "2504", "code": "public Interceptor[] buildMethodInterceptors(Method method){\n  Interceptors before=method.getAnnotation(Interceptors.class);\n  return before != null ? createInterceptors(before) : NULL_INTERCEPTOR_ARRAY;\n}\n", "docstring": "build interceptors of method", "partition": "test"}
{"idx": "2505", "code": "private static void lookForChanges(DataObject left,DataObject right,HashMap<String,Change> changes,Set<String> included,Set<String> excluded,Set<String> contained){\n  Class refClass=left.getClass();\n  Method[] methods=refClass.getMethods();\n  for (  Method method : methods) {\n    boolean contain=false;\n    Name nameAnn=method.getAnnotation(Name.class);\n    if (nameAnn == null) {\n      continue;\n    }\n    String key=nameAnn.value();\n    if (contained != null && contained.contains(key)) {\n      contain=true;\n    }\n else     if (included != null && !included.contains(key)) {\n      continue;\n    }\n    if (excluded.contains(key)) {\n      continue;\n    }\n    Class type=method.getReturnType();\n    try {\n      Object obja=method.invoke(left);\n      Object objb=method.invoke(right);\n      if (type == StringSet.class) {\n        if (contain) {\n          analyzeNewStringSetContainsOldStringSetValues((StringSet)obja,(StringSet)objb,key,changes);\n        }\n else {\n          analyzeStringSets((StringSet)obja,(StringSet)objb,key,changes);\n        }\n      }\n else       if (type == StringMap.class) {\n        analyzeStringMaps((StringMap)obja,(StringMap)objb,key,changes);\n      }\n else       if (type == StringSetMap.class) {\n        analyzeStringSetMaps((StringSetMap)obja,(StringSetMap)objb,key,changes);\n      }\n else {\n        if (!isEqual(obja,objb)) {\n          Change change=new Change(key,obja,objb,nameAnn.value());\n          changes.put(key,change);\n        }\n      }\n    }\n catch (    IllegalAccessException ex) {\n      throw new ServiceCodeException(ServiceCode.UNFORSEEN_ERROR,ex,ex.getMessage(),new String[]{});\n    }\ncatch (    InvocationTargetException ex) {\n      throw new ServiceCodeException(ServiceCode.UNFORSEEN_ERROR,ex,ex.getMessage(),new String[]{});\n    }\n  }\n}\n", "docstring": "scans the methods looking for ones annotated with the name annotation . when found ( if not excluded ) , invokes the method on each of the dataobjects and then compares the results .", "partition": "test"}
{"idx": "2506", "code": "static void removeAllPhis(IR ir){\n  for (Instruction s=ir.firstInstructionInCodeOrder(), sentinel=ir.lastInstructionInCodeOrder(), nextInstr=null; s != sentinel; s=nextInstr) {\n    nextInstr=s.nextInstructionInCodeOrder();\n    if (Phi.conforms(s))     s.remove();\n  }\n}\n", "docstring": "remove all phi instructions from the ir .", "partition": "test"}
{"idx": "2507", "code": "private Map<TestCase,Set<TestFitnessFunction>> initializeCoverageMapFromTests(List<TestCase> tests){\n  Map<TestCase,Set<TestFitnessFunction>> testToGoals=new LinkedHashMap<>();\n  for (  TestCase test : tests) {\n    testToGoals.put(test,filterSupportedGoals(new LinkedHashSet<>(test.getCoveredGoals())));\n  }\n  return testToGoals;\n}\n", "docstring": "builds the name map based on coverage goal stored as covered in each of the tests", "partition": "test"}
{"idx": "2508", "code": "public Interceptor[] buildRouteInterceptors(Interceptor[] defaultInters,Interceptor[] resourceInters,Class<? extends Resource> resourceClass,Interceptor[] methodInters,Method method){\n  List<Interceptor> allInters=new ArrayList<Interceptor>();\n  for (  Interceptor defaultInter : defaultInters) {\n    allInters.add(defaultInter);\n  }\n  for (  Interceptor resourceInter : resourceInters) {\n    allInters.add(resourceInter);\n  }\n  for (  Interceptor methodInter : methodInters) {\n    allInters.add(methodInter);\n  }\n  Class<? extends Interceptor>[] resourceClears=getResourceClears(resourceClass);\n  Class<? extends Interceptor>[] methodClears=getMethodClears(method);\n  if ((resourceClears != null && resourceClears.length > 0) || (methodClears != null && methodClears.length > 0)) {\n    for (int i=0; i < allInters.size(); i++) {\n      i=clearInterceptor(allInters,resourceClears,i);\n      i=clearInterceptor(allInters,methodClears,i);\n    }\n  }\n  return allInters.toArray(new Interceptor[allInters.size()]);\n}\n", "docstring": "build interceptors of action", "partition": "test"}
{"idx": "2509", "code": "public static boolean checkGMLFootprint(String footprint){\n  try {\n    Configuration configuration=new GMLConfiguration();\n    Parser parser=new Parser(configuration);\n    Geometry geom=(Geometry)parser.parse(new InputSource(new StringReader(footprint)));\n    if (!geom.isEmpty() && !geom.isValid()) {\n      logger.error(\"Wrong footprint\");\n      return false;\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Error in extracted footprint: \" + e.getMessage());\n    return false;\n  }\n  return true;\n}\n", "docstring": "check gml footprint validity", "partition": "test"}
{"idx": "2510", "code": "public static double quantile(double p,double k,double theta,double shift){\n  return Math.exp(GammaDistribution.quantile(p,k,theta)) + shift;\n}\n", "docstring": "compute probit ( inverse cdf ) for loggamma distributions .", "partition": "test"}
{"idx": "2511", "code": "public OrionEditorInit(final TextEditorConfiguration configuration,final CodeAssistantFactory codeAssistantFactory,final QuickAssistAssistant quickAssist,final OrionEditorPresenter textEditor){\n  this.configuration=configuration;\n  this.codeAssistantFactory=codeAssistantFactory;\n  this.quickAssist=quickAssist;\n  this.textEditor=textEditor;\n}\n", "docstring": "the quick assist assistant .", "partition": "test"}
{"idx": "2512", "code": "final void putByte(int offset,byte value){\n  unsafe.putByte(offset + address,value);\n}\n", "docstring": "writes a byte at the specified offset from this native object \"'\" s base address .", "partition": "test"}
{"idx": "2513", "code": "public final void addValidationError(String error){\n  validationErrors.add(error);\n}\n", "docstring": "add a new validation error to the accumulating validation errors", "partition": "test"}
{"idx": "2514", "code": "public static void parseOptionSettingTo(String optionSetting,Map<String,String> dst){\n  int eqIndex=optionSetting.indexOf(\'=\');\n  if (eqIndex == -1) {\n    throw new InternalError(\"Option setting has does not match the pattern <name>=<value>: \" + optionSetting);\n  }\n  dst.put(optionSetting.substring(0,eqIndex),optionSetting.substring(eqIndex + 1));\n}\n", "docstring": "parses a given option setting string to a map of settings .", "partition": "test"}
{"idx": "2515", "code": "public BigInteger generateClientCredentials(byte[] salt,byte[] identity,byte[] password){\n  this.x=SRP6Util.calculateX(digest,N,salt,identity,password);\n  this.a=selectPrivateValue();\n  this.A=g.modPow(a,N);\n  return A;\n}\n", "docstring": "generates client \"'\" s credentials given the client \"'\" s salt , identity and password", "partition": "test"}
{"idx": "2516", "code": "public void build(SolrCore core,SolrIndexSearcher searcher) throws IOException {\n  LOG.info(\"SolrSuggester.build(\" + name + \")\");\n  dictionary=dictionaryFactory.create(core,searcher);\n  lookup.build(dictionary);\n  if (storeDir != null) {\n    File target=getStoreFile();\n    if (!lookup.store(new FileOutputStream(target))) {\n      LOG.error(\"Store Lookup build failed\");\n    }\n else {\n      LOG.info(\"Stored suggest data to: \" + target.getAbsolutePath());\n    }\n  }\n}\n", "docstring": "build the underlying lucene suggester", "partition": "test"}
{"idx": "2517", "code": "public void start(String json){\n  guidedTourSteps.clear();\n  GuidedTourConfiguration configuration=dtoFactory.createDtoFromJson(json,GuidedTourConfiguration.class);\n  log.setDebugMode(configuration.getDebugMode());\n  this.guidedTourSteps=configuration.getSteps();\n  this.tourName=configuration.getName();\n  if (this.tourName == null || tourName.isEmpty()) {\n    tourName=\"unamed\";\n  }\n  this.hasWelcomeStep=configuration.getHasWelcomeStep();\n  startTour();\n}\n", "docstring": "loads the given json data and start the tour", "partition": "test"}
{"idx": "2518", "code": "private void connect() throws IOException {\n  JMXServiceURL jmxUrl=new JMXServiceURL(String.format(fmtUrl,host,port));\n  Map<String,Object> env=new HashMap<String,Object>();\n  if (username != null) {\n    String[] creds={username,password};\n    env.put(JMXConnector.CREDENTIALS,creds);\n  }\n  env.put(\"com.sun.jndi.rmi.factory.socket\",getRMIClientSocketFactory());\n  jmxc=JMXConnectorFactory.connect(jmxUrl,env);\n  mbeanServerConn=jmxc.getMBeanServerConnection();\n  try {\n    ObjectName name=new ObjectName(ssObjName);\n    ssProxy=JMX.newMBeanProxy(mbeanServerConn,name,StorageServiceMBean.class);\n    name=new ObjectName(MessagingService.MBEAN_NAME);\n    msProxy=JMX.newMBeanProxy(mbeanServerConn,name,MessagingServiceMBean.class);\n    name=new ObjectName(StreamManagerMBean.OBJECT_NAME);\n    streamProxy=JMX.newMBeanProxy(mbeanServerConn,name,StreamManagerMBean.class);\n    name=new ObjectName(CompactionManager.MBEAN_OBJECT_NAME);\n    compactionProxy=JMX.newMBeanProxy(mbeanServerConn,name,CompactionManagerMBean.class);\n    name=new ObjectName(FailureDetector.MBEAN_NAME);\n    fdProxy=JMX.newMBeanProxy(mbeanServerConn,name,FailureDetectorMBean.class);\n    name=new ObjectName(CacheService.MBEAN_NAME);\n    cacheService=JMX.newMBeanProxy(mbeanServerConn,name,CacheServiceMBean.class);\n    name=new ObjectName(StorageProxy.MBEAN_NAME);\n    spProxy=JMX.newMBeanProxy(mbeanServerConn,name,StorageProxyMBean.class);\n    name=new ObjectName(HintedHandOffManager.MBEAN_NAME);\n    hhProxy=JMX.newMBeanProxy(mbeanServerConn,name,HintedHandOffManagerMBean.class);\n    name=new ObjectName(GCInspector.MBEAN_NAME);\n    gcProxy=JMX.newMBeanProxy(mbeanServerConn,name,GCInspectorMXBean.class);\n    name=new ObjectName(Gossiper.MBEAN_NAME);\n    gossProxy=JMX.newMBeanProxy(mbeanServerConn,name,GossiperMBean.class);\n  }\n catch (  MalformedObjectNameException e) {\n    throw new RuntimeException(\"Invalid ObjectName? Please report this as a bug.\",e);\n  }\n  memProxy=ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,ManagementFactory.MEMORY_MXBEAN_NAME,MemoryMXBean.class);\n  runtimeProxy=ManagementFactory.newPlatformMXBeanProxy(mbeanServerConn,ManagementFactory.RUNTIME_MXBEAN_NAME,RuntimeMXBean.class);\n}\n", "docstring": "create a connection to the jmx agent and setup the m [ x ", "partition": "test"}
{"idx": "2519", "code": "private static void runRandomTest(final int wordLength,final int bytePadding,final int wordCount){\n  final long seed=randomLong();\n  final Random random=new Random(seed);\n  final Random verificationRandom=new Random(seed);\n  final long wordMask;\n  if (wordLength == 64) {\n    wordMask=~0L;\n  }\n else {\n    wordMask=(1L << wordLength) - 1L;\n  }\n  final BigEndianAscendingWordSerializer serializer=new BigEndianAscendingWordSerializer(wordLength,wordCount,bytePadding);\n  for (int i=0; i < wordCount; i++) {\n    final long value=random.nextLong() & wordMask;\n    serializer.writeWord(value);\n  }\n  final byte[] bytes=serializer.getBytes();\n  final BigEndianAscendingWordDeserializer deserializer=new BigEndianAscendingWordDeserializer(wordLength,bytePadding,bytes);\n  assertEquals(deserializer.totalWordCount(),wordCount);\n  for (int i=0; i < wordCount; i++) {\n    assertEquals(deserializer.readWord(),(verificationRandom.nextLong() & wordMask));\n  }\n}\n", "docstring": "runs a test which serializes and deserializes random word values .", "partition": "test"}
{"idx": "2520", "code": "public static MaildirMessageName createUniqueName(MaildirFolder parentFolder,long size){\n  String timestamp=String.valueOf(System.currentTimeMillis());\n  timestamp=timestamp.substring(0,timestamp.length() - 3);\n  StringBuilder uniquePart=new StringBuilder();\n  uniquePart.append(Integer.toHexString(random.nextInt()));\n  uniquePart.append(timestamp.substring(timestamp.length() - 3));\n  uniquePart.append(processName);\n  uniquePart.append(getNextDeliveryNumber());\n  String sizeString=\",S=\" + String.valueOf(size);\n  String fullName=timestamp + \".\" + uniquePart.toString()+ \".\"+ currentHostname+ sizeString;\n  MaildirMessageName uniqueName=new MaildirMessageName(parentFolder,fullName);\n  uniqueName.timestamp=timestamp;\n  uniqueName.uniqueString=uniquePart.toString();\n  uniqueName.hostname=currentHostname;\n  uniqueName.sizeString=sizeString;\n  uniqueName.isSplit=true;\n  uniqueName.size=size;\n  return uniqueName;\n}\n", "docstring": "create a name for a message according to < a href = \" http : / / cr . yp . to / proto / maildir . html \" / > < br / > the following elements are used : < br > < br / > \" a unique name has three pieces , separated by dots . on the left is the result of time ( ) or the second counter from gettimeofday ( ) . on the right is the result of gethostname ( ) . ( to deal with invalid host names , replace / with \\ 057 and : with \\ 072 . ) in the middle is a delivery identifier , discussed below . < br / > < br / > modern delivery identifiers are created by concatenating enough of the following strings to guarantee uniqueness : < br / > < br / > [ . . . ", "partition": "test"}
{"idx": "2521", "code": "@Override public void handleClick(int x,int y,PlotRenderingInfo info){\n}\n", "docstring": "handles a \"'\" click \"'\" on the plot by updating the anchor values . . .", "partition": "test"}
{"idx": "2522", "code": "private void adjustBCIndex(Instruction barrier){\n  NormalMethod source=barrier.position().method;\n  if (source.isForOsrSpecialization()) {\n    barrier.adjustBytecodeIndex(-source.getOsrPrologueLength());\n  }\n}\n", "docstring": "the osrbarrier instruction is not in ir , so the bc index was not adjusted in osr_adjustbcindex .", "partition": "test"}
{"idx": "2523", "code": "@Override public String toString(){\n  StringBuilder risul=new StringBuilder(1000);\n  risul.append(\"BoardPanel \");\n  risul.append(\"available object: itera_board\");\n  return risul.toString();\n}\n", "docstring": "used to have some meaningful info on this object mostly used for beanshell", "partition": "test"}
{"idx": "2524", "code": "public static long[] interpose(long[] vector,int vectorLen,int offset,int len){\n  long[] updated=create(vectorLen + len);\n  int idx=offset >> 6;\n  System.arraycopy(vector,0,updated,0,idx);\n  if (idx < vector.length) {\n    int delta=offset & 63;\n    updated[idx]|=vector[idx] & maskBelow(delta);\n  }\n  copy(vector,offset,updated,offset + len,vectorLen - offset);\n  return updated;\n}\n", "docstring": "returns a copy of the vector , with an empty bit range inserted at the specified location .", "partition": "test"}
{"idx": "2525", "code": "Task<Void> synchronizeAllAuthDataAsync(){\n  Map<String,Map<String,String>> authData;\nsynchronized (mutex) {\n    if (!isCurrentUser()) {\n      return Task.forResult(null);\n    }\n    authData=getAuthData();\n  }\n  List<Task<Void>> tasks=new ArrayList<>(authData.size());\n  for (  String authType : authData.keySet()) {\n    tasks.add(synchronizeAuthDataAsync(authType));\n  }\n  return Task.whenAll(tasks);\n}\n", "docstring": "ensures that all auth sources have auth data ( e . g . access tokens , etc . ) that matches this user .", "partition": "test"}
{"idx": "2526", "code": "public static Element createElementInEncryptionSpace(Document doc,String elementName){\n  if (doc == null) {\n    throw new RuntimeException(\"Document is null\");\n  }\n  if ((xencPrefix == null) || (xencPrefix.length() == 0)) {\n    return doc.createElementNS(EncryptionConstants.EncryptionSpecNS,elementName);\n  }\n  return doc.createElementNS(EncryptionConstants.EncryptionSpecNS,xencPrefix + \":\" + elementName);\n}\n", "docstring": "creates an element in the xml encryption specification namespace .", "partition": "test"}
{"idx": "2527", "code": "private boolean hasProxySettings(Properties settings){\n  String proxyHost=settings.getProperty(\"org.gnome.system.proxy.http host\",null);\n  return proxyHost != null && proxyHost.length() > 0;\n}\n", "docstring": "checks if we have proxy configuration settings in the properties .", "partition": "test"}
{"idx": "2528", "code": "public boolean equalsDefault(){\n  return (Double.doubleToLongBits(value) == 0);\n}\n", "docstring": "check if the expression is equal to its default static value", "partition": "test"}
{"idx": "2529", "code": "public void test_filter_001() throws IOException {\n  final File basefile=File.createTempFile(getName(),\"-test\");\n  try {\n    final String basename=basefile.toString();\n    final NameAndExtensionFilter logFilter=new NameAndExtensionFilter(basename,\".log\");\n    assertSameFiles(new File[]{},logFilter.getFiles());\n  }\n  finally {\n    basefile.delete();\n  }\n}\n", "docstring": "test verifies that no files are found using a guarenteed unique basename .", "partition": "test"}
{"idx": "2530", "code": "public void resetTeleMissileAttacks(){\n  pendingTeleMissileAttacks.removeAllElements();\n}\n", "docstring": "resets the pending rams list .", "partition": "test"}
{"idx": "2531", "code": "public void addCommands(PDFPage page,Matrix extra){\nsynchronized (commands) {\n    addPush();\n    if (extra != null) {\n      addXform(extra);\n    }\n    commands.addAll(page.getCommands());\n    addPop();\n  }\n  updateImages();\n}\n", "docstring": "add a collection of commands to the page list . this is probably invoked as the result of an xobject \"'\" do \"'\" command , or through a type 3 font .", "partition": "test"}
{"idx": "2532", "code": "public String toString(){\n  StringBuffer sb=new StringBuffer();\n  char[] separator={'[',' '};\n  int n=rows.length;\n  for (int i=0; i < n; i++) {\n    separator[0]='{';\n    for (int j=0; j <= i; j++) {\n      sb.append(separator);\n      sb.append(rows[i][j]);\n      separator[0]=' ';\n    }\n    sb.append('}');\n    sb.append('\\n');\n  }\n  return sb.toString();\n}\n", "docstring": "returns a string representation of the system .", "partition": "test"}
{"idx": "2533", "code": "public void addLast(StatementSequence statements){\n  if (statements != null) {\n    sequence.addAll(statements.sequence);\n  }\n}\n", "docstring": "adds a sequence of statements to the end of this sequence when the sequence object is not null , otherwise does nothing .", "partition": "test"}
{"idx": "2534", "code": "private void notifyActivityStateChanged(Bundle bundle){\n  if (!mRecords.isEmpty()) {\n    Log.d(TAG,\"notifyActivityStatusChanged:clients = \" + mRecords.size());\nsynchronized (mRecords) {\n      Iterator<Record> iterator=mRecords.iterator();\n      while (iterator.hasNext()) {\n        Record record=(Record)iterator.next();\n        FmRadioListener listener=record.mCallback;\n        if (listener == null) {\n          iterator.remove();\n          return;\n        }\n        listener.onCallBack(bundle);\n      }\n    }\n  }\n}\n", "docstring": "call back from service to activity", "partition": "test"}
{"idx": "2535", "code": "public double elasticity(final double spot){\n  final double val=value();\n  final double del=delta(spot);\n  if (val > Constants.QL_EPSILON)   return del / val * spot;\n else   if (Math.abs(del) < Constants.QL_EPSILON)   return 0.0;\n else   if (del > 0.0)   return Double.MAX_VALUE;\n else   return Double.MIN_VALUE;\n}\n", "docstring": "sensitivity in percent to a percent change in the underlying spot price .", "partition": "test"}
{"idx": "2536", "code": "private byte[] entityToBytes(HttpEntity entity,Request request) throws IOException, ServerError {\n  PoolingByteArrayOutputStream bytes=new PoolingByteArrayOutputStream(mPool,(int)entity.getContentLength());\n  byte[] buffer=null;\n  try {\n    InputStream in=entity.getContent();\n    if (in == null) {\n      throw new ServerError();\n    }\n    buffer=mPool.getBuf(1024);\n    int progress=0;\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      bytes.write(buffer,0,count);\n      progress+=count;\n      request.progressUpdate(progress);\n    }\n    return bytes.toByteArray();\n  }\n  finally {\n    try {\n      entity.consumeContent();\n    }\n catch (    IOException e) {\n      VinciLog.d(\"Error occured when calling consumingContent\");\n    }\n    mPool.returnBuf(buffer);\n    bytes.close();\n  }\n}\n", "docstring": "reads the contents of httpentity into a byte [ ", "partition": "test"}
{"idx": "2537", "code": "public static float roundDecimal(float value){\n  return roundDecimal(value,Math.log10(INT_PRECISION));\n}\n", "docstring": "static method to round a float value to the number of decimal places defined by decimal_places .", "partition": "test"}
{"idx": "2538", "code": "@AssistedInject public RunnerImpl(@NotNull RunnerLocalizationConstant locale,@NotNull RunnerCounter runnerCounter,@NotNull GetEnvironmentsUtil util,@NotNull @Assisted RunOptions runOptions,@NotNull @Assisted Scope environmentScope,@Nullable @Assisted String environmentName){\n  this.runOptions=runOptions;\n  this.ram=runOptions.getMemorySize();\n  this.title=RUNNER_NAME + runnerCounter.getRunnerNumber() + (environmentName == null ? \"\" : \" - \" + getCorrectName(environmentName));\n  this.activeTab=locale.runnerTabConsole();\n  this.status=IN_QUEUE;\n  this.scope=environmentScope;\n  creationTime=System.currentTimeMillis();\n  String environmentId=runOptions.getEnvironmentId();\n  if (environmentId == null || environmentId.startsWith(\"project:/\")) {\n    this.type=util.getType();\n  }\n else {\n    this.type=util.getCorrectCategoryName(runOptions.getEnvironmentId());\n  }\n  if (environmentId != null) {\n    runOptions.setEnvironmentId(environmentId);\n  }\n}\n", "docstring": "this runner needs runner options ( user configurations ) and environment name ( inputted by user ) . it analyzes all given information and get necessary information .", "partition": "test"}
{"idx": "2539", "code": "public String globalInfo(){\n  return \"Generates a single train/test split and calls the appropriate \" + \"SplitEvaluator to generate some results.\";\n}\n", "docstring": "returns a string describing this result producer", "partition": "test"}
{"idx": "2540", "code": "public static boolean isWindowsMe(){\n  return osName.indexOf(\"Windows\") > -1 && osVersion.equals(\"4.9\");\n}\n", "docstring": "is operating system windows me ?", "partition": "test"}
{"idx": "2541", "code": "private String dateToString(Date input){\n  if (input == null) {\n    return null;\n  }\n else {\n    return input.toString();\n  }\n}\n", "docstring": "converts the input to a string with special missing value handling", "partition": "test"}
{"idx": "2542", "code": "private static int componentSize(Component component,FormSpec formSpec,int cellSize,FormLayout.Measure minMeasure,FormLayout.Measure prefMeasure){\n  if (formSpec == null) {\n    return prefMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.MINIMUM) {\n    return minMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.PREFERRED) {\n    return prefMeasure.sizeOf(component);\n  }\n else {\n    return Math.min(cellSize,prefMeasure.sizeOf(component));\n  }\n}\n", "docstring": "computes and returns the pixel size of the given component using the given form specification , measures , and cell size .", "partition": "test"}
{"idx": "2543", "code": "protected synchronized void start(long curPrimaryGen) throws IOException {\n  if (state.equals(\"init\") == false) {\n    throw new IllegalStateException(\"already started\");\n  }\n  message(\"top: now start\");\n  try {\n    String segmentsFileName=SegmentInfos.getLastCommitSegmentsFileName(dir);\n    long maxPendingGen=-1;\n    for (    String fileName : dir.listAll()) {\n      if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        long gen=Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length() + 1),Character.MAX_RADIX);\n        if (gen > maxPendingGen) {\n          maxPendingGen=gen;\n        }\n      }\n    }\n    SegmentInfos infos;\n    if (segmentsFileName == null) {\n      infos=new SegmentInfos();\n      message(\"top: init: no segments in index\");\n    }\n else {\n      message(\"top: init: read existing segments commit \" + segmentsFileName);\n      infos=SegmentInfos.readCommit(dir,segmentsFileName);\n      message(\"top: init: segments: \" + infos.toString() + \" version=\"+ infos.getVersion());\n      Collection<String> indexFiles=infos.files(false);\n      lastCommitFiles.add(segmentsFileName);\n      lastCommitFiles.addAll(indexFiles);\n      deleter.incRef(lastCommitFiles);\n      lastNRTFiles.addAll(indexFiles);\n      deleter.incRef(lastNRTFiles);\n      message(\"top: commitFiles=\" + lastCommitFiles);\n      message(\"top: nrtFiles=\" + lastNRTFiles);\n    }\n    message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    deleter.deleteUnknownFiles(segmentsFileName);\n    message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    String s=infos.getUserData().get(PRIMARY_GEN_KEY);\n    long myPrimaryGen;\n    if (s == null) {\n      assert infos.size() == 0;\n      myPrimaryGen=-1;\n    }\n else {\n      myPrimaryGen=Long.parseLong(s);\n    }\n    message(\"top: myPrimaryGen=\" + myPrimaryGen);\n    boolean doCommit;\n    if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n      assert myPrimaryGen < curPrimaryGen;\n      final long initSyncStartNS=System.nanoTime();\n      message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen + \" vs curPrimaryGen=\"+ curPrimaryGen+ \"; sync now before mgr init\");\n      CopyJob job=null;\n      message(\"top: now delete starting commit point \" + segmentsFileName);\n      assert deleter.getRefCount(segmentsFileName) == 1;\n      deleter.decRef(Collections.singleton(segmentsFileName));\n      if (dir instanceof FSDirectory && ((FSDirectory)dir).checkPendingDeletions()) {\n        throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n      }\n      boolean didRemove=lastCommitFiles.remove(segmentsFileName);\n      assert didRemove;\n      while (true) {\n        job=newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\"+ infos.getVersion(),null,null,true,null);\n        job.start();\n        message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n        try {\n          job.runBlocking();\n          job.finish();\n          break;\n        }\n catch (        IOException ioe) {\n          job.cancel(\"startup failed\",ioe);\n          if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n            message(\"top: failed to copy: \" + ioe + \"; retrying\");\n          }\n else {\n            throw ioe;\n          }\n        }\n      }\n      lastPrimaryGen=job.getCopyState().primaryGen;\n      byte[] infosBytes=job.getCopyState().infosBytes;\n      SegmentInfos syncInfos=SegmentInfos.readCommit(dir,new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\",job.getCopyState().infosBytes)),job.getCopyState().gen);\n      syncInfos.updateGeneration(infos);\n      infos=syncInfos;\n      assert infos.getVersion() == job.getCopyState().version;\n      message(\"  version=\" + infos.getVersion() + \" segments=\"+ infos.toString());\n      message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n      deleter.incRef(job.getFileNames());\n      message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n      deleter.decRef(lastNRTFiles);\n      lastNRTFiles.clear();\n      lastNRTFiles.addAll(job.getFileNames());\n      message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n      lastFileMetaData=job.getCopyState().files;\n      message(String.format(Locale.ROOT,\"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",id,(System.nanoTime() - initSyncStartNS) / 1000000000.0,bytesToString(job.getTotalBytesCopied()),job.getCopyState().version));\n      doCommit=true;\n    }\n else {\n      doCommit=false;\n      lastPrimaryGen=curPrimaryGen;\n      message(\"top: same primary as before\");\n    }\n    if (infos.getGeneration() < maxPendingGen) {\n      message(\"top: move infos generation from \" + infos.getGeneration() + \" to \"+ maxPendingGen);\n      infos.setNextWriteGeneration(maxPendingGen);\n    }\n    sendNewReplica();\n    mgr=new SegmentInfosSearcherManager(dir,this,infos,searcherFactory);\n    IndexSearcher searcher=mgr.acquire();\n    try {\n      int hitCount=searcher.count(new TermQuery(new Term(\"marker\",\"marker\")));\n      message(\"top: marker count=\" + hitCount + \" version=\"+ ((DirectoryReader)searcher.getIndexReader()).getVersion());\n    }\n  finally {\n      mgr.release(searcher);\n    }\n    if (doCommit) {\n      commit();\n    }\n    message(\"top: done start\");\n    state=\"idle\";\n  }\n catch (  Throwable t) {\n    if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n      message(\"exc on start:\");\n      t.printStackTrace(printStream);\n    }\n else {\n      dir.close();\n    }\n    IOUtils.reThrow(t);\n  }\n}\n", "docstring": "start up this replica , which possibly requires heavy copying of files from the primary node , if we were down for a long time", "partition": "test"}
{"idx": "2544", "code": "public static boolean isSameElementType(ASTNode node1,ASTNode node2){\n  return node1 != null && node2 != null && node1.getElementType() == node1.getElementType();\n}\n", "docstring": "checks if ielementtype of both nodes are the same . returns false if either are null .", "partition": "test"}
{"idx": "2545", "code": "@Override public LogMessage readNextLogMessage(){\n  try {\n    if (reader == null) {\n      return null;\n    }\n    while (true) {\n      String line=reader.readLine();\n      if (line == null) {\n        close();\n        if (currentLog != null && matchRegex(currentLog)) {\n          incrementLogCount(currentLog);\n          return currentLog;\n        }\n        return null;\n      }\n      fileLineNumber++;\n      LogMessage nextLog=null;\n      if (parser != null) {\n        nextLog=parser.parseLine(line,request);\n      }\n else {\n        for (        LogParser parser : parserTable) {\n          nextLog=parser.parseLine(line,request);\n          if (!nextLog.isContinuation()) {\n            this.parser=parser;\n            break;\n          }\n        }\n        if (nextLog == null || nextLog.isContinuation()) {\n          status.appendInfo(this.filePath,fileLineNumber);\n          continue;\n        }\n      }\n      if (nextLog.isContinuation()) {\n        if (currentLog != null) {\n          currentLog.appendMessage(LogUtil.stringToBytes(line));\n        }\n      }\n else       if (nextLog.isRejected()) {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=null;\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n      }\n else       if (nextLog.isRejectedLast()) {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=null;\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n        break;\n      }\n else {\n        if (currentLog != null) {\n          LogMessage returnedLog=currentLog;\n          currentLog=nextLog;\n          if (returnedLog.isHeader() && currentLog.isHeader()) {\n            continue;\n          }\n          if (matchRegex(returnedLog)) {\n            incrementLogCount(returnedLog);\n            return returnedLog;\n          }\n        }\n else {\n          currentLog=nextLog;\n        }\n      }\n    }\n  }\n catch (  IOException e) {\n    status.appendErrFileName(filePath);\n  }\n  return null;\n}\n", "docstring": "read one log message from log file", "partition": "test"}
{"idx": "2546", "code": "private void loadBinary(DataInputStream is) throws IOException {\n  if (is.readInt() != MAGIC) {\n    throw new Error(\"Bad magic in db\");\n  }\n  if (is.readInt() != VERSION) {\n    throw new Error(\"Bad VERSION in db\");\n  }\n  continuityWeight=is.readInt();\n  optimalCoupling=is.readInt();\n  extendSelections=is.readInt();\n  joinMethod=is.readInt();\n  joinWeightShift=is.readInt();\n  int weightLength=is.readInt();\n  joinWeights=new int[weightLength];\n  for (int i=0; i < joinWeights.length; i++) {\n    joinWeights[i]=is.readInt();\n  }\n  int unitsLength=is.readInt();\n  units=new DatabaseClusterUnit[unitsLength];\n  for (int i=0; i < units.length; i++) {\n    units[i]=new DatabaseClusterUnit(is);\n  }\n  int unitTypesLength=is.readInt();\n  unitTypes=new UnitType[unitTypesLength];\n  for (int i=0; i < unitTypes.length; i++) {\n    unitTypes[i]=new UnitType(is);\n  }\n  sts=new SampleSet(is);\n  mcep=new SampleSet(is);\n  int numCarts=is.readInt();\n  cartMap=new HashMap();\n  for (int i=0; i < numCarts; i++) {\n    String name=Utilities.getString(is);\n    CART cart=CARTImpl.loadBinary(is);\n    cartMap.put(name,cart);\n    if (defaultCart == null) {\n      defaultCart=cart;\n    }\n  }\n}\n", "docstring": "loads the database from the given input stream .", "partition": "test"}
{"idx": "2547", "code": "public static String toString(long l){\n  if (l < NUMBERS_MIN || l > NUMBERS_MAX) {\n    return Long.toString(l,10);\n  }\n  return NUMBERS[(int)l];\n}\n", "docstring": "cast a long value to a string", "partition": "test"}
{"idx": "2548", "code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 1788) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "docstring": "unpacks the compressed character translation table .", "partition": "test"}
{"idx": "2549", "code": "protected boolean isIDPProxyEnabled(FSAuthnRequest authnRequest) throws FSException {\n  if (authnRequest.getMinorVersion() != IFSConstants.FF_12_PROTOCOL_MINOR_VERSION) {\n    return false;\n  }\n  FSScoping scoping=authnRequest.getScoping();\n  if (scoping != null && scoping.getProxyCount() == 0) {\n    return false;\n  }\n  String enabledString=IDFFMetaUtils.getFirstAttributeValueFromConfig(spConfig,IFSConstants.ENABLE_IDP_PROXY);\n  if (enabledString != null && enabledString.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "checks if the identity provider is configured for proxying the authentication requests for a requesting service provider .", "partition": "test"}
{"idx": "2550", "code": "private void compileProlog(ObjectId prolog,File tempDir) throws IOException, CompileException {\n  File tempRules=copyToTempFile(prolog,tempDir);\n  try {\n    Compiler comp=new Compiler();\n    comp.prologToJavaSource(tempRules.getPath(),tempDir.getPath());\n  }\n  finally {\n    tempRules.delete();\n  }\n}\n", "docstring": "creates a copy of rules . pl and compiles it into java sources .", "partition": "test"}
{"idx": "2551", "code": "public SelectionInputDialog(Window owner,String key,boolean editable,T[] selectionValues,T initialSelectionValue,InputValidator<T> inputValidator,Object... keyArguments){\n  this(owner,key,selectionValues,initialSelectionValue,inputValidator,keyArguments);\n  comboBox.setEditable(editable);\n}\n", "docstring": "create a selectioninputdialog whose combobox can be editable .", "partition": "test"}
{"idx": "2552", "code": "public void build(SolrCore core,SolrIndexSearcher searcher) throws IOException {\n  LOG.info(\"build()\");\n  dictionary=dictionaryFactory.create(core,searcher);\n  lookup.build(dictionary);\n  if (storeDir != null) {\n    File target=new File(storeDir,factory.storeFileName());\n    if (!lookup.store(new FileOutputStream(target))) {\n      LOG.error(\"Store Lookup build failed\");\n    }\n else {\n      LOG.info(\"Stored suggest data to: \" + target.getAbsolutePath());\n    }\n  }\n}\n", "docstring": "build the underlying lucene suggester", "partition": "test"}
{"idx": "2553", "code": "public byte[] toByteArray(){\n  return Arrays.copyOf(buf,cnt);\n}\n", "docstring": "creates a newly allocated byte array . its size is the current size of this output stream and the valid contents of the buffer have been copied into it .", "partition": "test"}
{"idx": "2554", "code": "public void createDiskAsync(final String projectId,final DiskCreateSpec diskCreateSpec,final FutureCallback<Task> responseCallback) throws IOException {\n  final String path=String.format(\"%s/%s/disks\",getBasePath(),projectId);\n  createObjectAsync(path,serializeObjectAsJson(diskCreateSpec),responseCallback);\n}\n", "docstring": "create a disk in the specified project .", "partition": "test"}
{"idx": "2555", "code": "@Override public boolean domainMatch(final String host,final String domain){\n  return host.endsWith(domain);\n}\n", "docstring": "performs domain - match as described in the netscape draft .", "partition": "test"}
{"idx": "2556", "code": "public synchronized void disableAttribute(String name){\n  enabledAttributes.removeElement(name);\n}\n", "docstring": "disables all the attribute change notifications the attribute name of which equals the specified attribute name to be sent to the listener . < br > if the specified name is not in the list of enabled attribute names , this method has no effect .", "partition": "test"}
{"idx": "2557", "code": "public void push(final Handle handle){\n  mv.visitLdcInsn(handle);\n}\n", "docstring": "generates the instruction to push a handle on the stack .", "partition": "test"}
{"idx": "2558", "code": "public static IFitsHeader lookup(String key){\n  int keyLength=key.length();\n  if (keyLength > 0 && Character.isDigit(key.charAt(keyLength - 1))) {\n    StringBuilder builder=new StringBuilder();\n    for (int index=0; index < keyLength; index++) {\n      char character=key.charAt(index);\n      if (Character.isDigit(character)) {\n        if (builder.charAt(builder.length() - 1) != 'n') {\n          builder.append('n');\n        }\n      }\n else {\n        builder.append(character);\n      }\n    }\n    return STANDARD_KEYS.get(builder.toString());\n  }\n  return STANDARD_KEYS.get(key);\n}\n", "docstring": "lookup a string key in the standard key sets .", "partition": "test"}
{"idx": "2559", "code": "private static void assertChangeEvents(Collection<PortChangeEvent> earlyEvents,Collection<PortChangeEvent> lateEvents,Collection<PortChangeEvent> anytimeEvents,Collection<PortChangeEvent> actualEvents){\n  String inputDesc=String.format(\"earlyEvents=%s, lateEvents=%s, \" + \"anytimeEvents=%s, actualEvents=%s\",earlyEvents,lateEvents,anytimeEvents,actualEvents);\n  Collection<PortChangeEvent> early=new ArrayList<PortChangeEvent>(earlyEvents);\n  Collection<PortChangeEvent> late=new ArrayList<PortChangeEvent>(lateEvents);\n  Collection<PortChangeEvent> any=new ArrayList<PortChangeEvent>(anytimeEvents);\n  for (  PortChangeEvent ev : early) {\n    assertFalse(\"Test setup error. Early and late overlap\",late.contains(ev));\n    assertFalse(\"Test setup error. Early and anytime overlap\",any.contains(ev));\n  }\n  for (  PortChangeEvent ev : late) {\n    assertFalse(\"Test setup error. Late and early overlap\",early.contains(ev));\n    assertFalse(\"Test setup error. Late and any overlap\",any.contains(ev));\n  }\n  for (  PortChangeEvent ev : any) {\n    assertFalse(\"Test setup error. Anytime and early overlap\",early.contains(ev));\n    assertFalse(\"Test setup error. Anytime and late overlap\",late.contains(ev));\n  }\n  for (  PortChangeEvent a : actualEvents) {\n    if (early.remove(a)) {\n      continue;\n    }\n    if (any.remove(a)) {\n      continue;\n    }\n    if (late.remove(a)) {\n      if (!early.isEmpty()) {\n        fail(a + \" is in late list, but haven\'t seen all required \" + \"early events. \"+ inputDesc);\n      }\n else {\n        continue;\n      }\n    }\n    fail(a + \" was not expected. \" + inputDesc);\n  }\n  if (!early.isEmpty())   fail(\"Elements left in early: \" + early + \". \"+ inputDesc);\n  if (!late.isEmpty())   fail(\"Elements left in late: \" + late + \". \"+ inputDesc);\n  if (!any.isEmpty())   fail(\"Elements left in any: \" + any + \". \"+ inputDesc);\n}\n", "docstring": "assert that the expected portchangeevents have been recevied , asserting the expected ordering . all events in earlyevents have to appear in actualevents before any event in lateevent appears . events in anytimeevents can appear at any given time . earlyevents , lateevents , and anytimeevents must be mutually exclusive ( their intersection must be none ) and their union must contain all elements from actualevents", "partition": "test"}
{"idx": "2560", "code": "@Override public void write(Kryo kryo,Output output){\n  int size=index.size();\n  output.writeInt(size + 1,true);\n  for (int i=0; i < size; ++i) {\n    String s=index.get(i);\n    if (s == null) {\n      throw new RuntimeException(\"Cannot serialize null string at index \" + Integer.toString(i));\n    }\n    output.writeString(s);\n  }\n}\n", "docstring": "custom serializer . follows kryo \"'\" s stringarrayserializer example .", "partition": "test"}
{"idx": "2561", "code": "public final ObjectProperty<Control> toggleNodeProperty(){\n  return this.toggleNode;\n}\n", "docstring": "* public properties *", "partition": "test"}
{"idx": "2562", "code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n    sb.append((char)bb.get(0));\n    return i + 2;\n  }\n else {\n    CharBuffer cb=UTF_8_CHARSET.decode(bb);\n    sb.append(cb.toString());\n    return i + bb.limit() * 3 - 1;\n  }\n}\n", "docstring": "decodes octets to characters using the utf - 8 decoding and appends the characters to a stringbuffer .", "partition": "test"}
{"idx": "2563", "code": "public ArrayFieldVector(FieldVector<T> v1,T[] v2) throws NullArgumentException {\n  MathUtils.checkNotNull(v1);\n  MathUtils.checkNotNull(v2);\n  field=v1.getField();\n  final T[] v1Data=(v1 instanceof ArrayFieldVector) ? ((ArrayFieldVector<T>)v1).data : v1.toArray();\n  data=MathArrays.buildArray(field,v1Data.length + v2.length);\n  System.arraycopy(v1Data,0,data,0,v1Data.length);\n  System.arraycopy(v2,0,data,v1Data.length,v2.length);\n}\n", "docstring": "construct a vector by appending one vector to another vector .", "partition": "test"}
{"idx": "2564", "code": "public void start(){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Start address book monitoring\");\n  }\n  mCleanupExecutor=Executors.newSingleThreadExecutor();\n  if (!mObserverIsRegistered) {\n    mContactsContractObserver=new ContactsContractObserver(new Handler());\n    mContactsContractCursor=mContentResolver.query(Phone.CONTENT_URI,null,null,null,null);\n    CursorUtil.assertCursorIsNotNull(mContactsContractCursor,Phone.CONTENT_URI);\n    mContactsContractCursor.registerContentObserver(mContactsContractObserver);\n    mObserverIsRegistered=true;\n  }\n}\n", "docstring": "start address book monitoring", "partition": "test"}
{"idx": "2565", "code": "protected final void fireVetoableChange(String propertyName,double oldValue,double newValue) throws PropertyVetoException {\n  fireVetoableChange(propertyName,Double.valueOf(oldValue),Double.valueOf(newValue));\n}\n", "docstring": "support for reporting changes for constrained integer properties . this method can be called before a constrained property will be changed and it will send the appropriate propertychangeevent to any registered vetoablechangelisteners .", "partition": "test"}
{"idx": "2566", "code": "public void testLMDirichlet() throws IOException {\n  float p=(FREQ + 2000.0f * (TOTAL_TERM_FREQ + 1) / (NUMBER_OF_FIELD_TOKENS + 1.0f)) / (DOC_LEN + 2000.0f);\n  float a=2000.0f / (DOC_LEN + 2000.0f);\n  float gold=(float)(Math.log(p / (a * (TOTAL_TERM_FREQ + 1) / (NUMBER_OF_FIELD_TOKENS + 1.0f))) + Math.log(a));\n  correctnessTestCore(new LMDirichletSimilarity(),gold);\n}\n", "docstring": "correctness test for the dirichlet lm model .", "partition": "test"}
{"idx": "2567", "code": "public void onSinksReceived(String sourceUrn,List<MediaSink> sinks){\n  mSinks.put(sourceUrn,sinks);\n  nativeOnSinksReceived(mNativeMediaRouterAndroid,sourceUrn,sinks.size());\n}\n", "docstring": "called when the sinks found by the media route provider for the particular | sourceurn | have changed .", "partition": "test"}
{"idx": "2568", "code": "public User toEntity(UserDTO dto){\n  return toEntity(dto,1);\n}\n", "docstring": "converts the passed dto to a user . convenient for query by example .", "partition": "test"}
{"idx": "2569", "code": "protected void writeExternalForeignKeyDropStmt(Table table,ForeignKey foreignKey,StringBuilder ddl){\n  writeTableAlterStmt(table,ddl);\n  ddl.append(\"DROP CONSTRAINT \");\n  printIdentifier(getForeignKeyName(table,foreignKey),ddl);\n  printEndOfStatement(ddl);\n}\n", "docstring": "generates the statement to drop a foreignkey constraint from the database using an alter table statement .", "partition": "test"}
{"idx": "2570", "code": "public void obtain(long timeout_ms) throws IOException, InterruptedException, TimeoutException {\n  Long quit_time=System.currentTimeMillis() + timeout_ms;\n  if (fileLock != null && fileLock.isValid()) {\n    return;\n  }\n  do {\n    try {\n      fileLock=fileToLock.tryLock();\n      return;\n    }\n catch (    OverlappingFileLockException e) {\n      Thread.sleep(1000);\n    }\n  }\n while (System.currentTimeMillis() < quit_time);\n  throw new TimeoutException();\n}\n", "docstring": "locks the file , with a timeout ( non - blocking ) .", "partition": "test"}
{"idx": "2571", "code": "@Deprecated public void pointToData(Data o) throws FitsException {\n  o.fillHeader(this);\n}\n", "docstring": "create a header which points to the given data object .", "partition": "test"}
{"idx": "2572", "code": "@NotNull protected VirtualFile[] collectAffectedFiles(@NotNull Project project,@NotNull VirtualFile[] files){\n  List<VirtualFile> affectedFiles=new ArrayList<VirtualFile>(files.length);\n  ProjectLevelVcsManager projectLevelVcsManager=ProjectLevelVcsManager.getInstance(project);\n  for (  VirtualFile file : files) {\n    if (!file.isDirectory() && projectLevelVcsManager.getVcsFor(file) instanceof GitVcs) {\n      affectedFiles.add(file);\n    }\n else     if (file.isDirectory() && isRecursive()) {\n      addChildren(project,affectedFiles,file);\n    }\n  }\n  return VfsUtilCore.toVirtualFileArray(affectedFiles);\n}\n", "docstring": "given a list of action - target files , returns all the files that should be subject to the action does not keep directories , but recursively adds directory contents", "partition": "test"}
{"idx": "2573", "code": "protected void update(int length){\n  tickLabelValues.clear();\n  tickLabels.clear();\n  tickLabelPositions.clear();\n  if (scale.isLogScaleEnabled()) {\n    updateTickLabelForLogScale(length);\n  }\n else {\n    updateTickLabelForLinearScale(length);\n  }\n  updateTickVisibility();\n  updateTickLabelMaxLengthAndHeight();\n}\n", "docstring": "updates the tick labels .", "partition": "test"}
{"idx": "2574", "code": "private static boolean isWithinBounds(VisualPosition targetPosition,VisualPosition startPosition,VisualPosition endPosition){\n  return targetPosition.line >= startPosition.line && targetPosition.line <= endPosition.line && targetPosition.column >= startPosition.column && targetPosition.column <= endPosition.column;\n}\n", "docstring": "allows to answer if particular visual position belongs to visual rectangle identified by the given visual position of its top - left and bottom - right corners .", "partition": "test"}
{"idx": "2575", "code": "static public void assertStatementIndicesConsistent(final AbstractTripleStore db,final int maxerrors){\n  if (log.isInfoEnabled())   log.info(\"Verifying statement indices\");\n  final AtomicInteger nerrs=new AtomicInteger(0);\n  final int from, to;\n  if (db.getSPOKeyArity() == 3) {\n    from=SPOKeyOrder.FIRST_TRIPLE_INDEX;\n    to=SPOKeyOrder.LAST_TRIPLE_INDEX;\n  }\n else {\n    from=SPOKeyOrder.FIRST_QUAD_INDEX;\n    to=SPOKeyOrder.LAST_QUAD_INDEX;\n  }\n  for (int i=from; i <= to; i++) {\n    for (int j=from; j <= to; j++) {\n      if (i <= j) {\n        continue;\n      }\n      assertSameStatements(db,SPOKeyOrder.valueOf(i),SPOKeyOrder.valueOf(j),nerrs,maxerrors);\n    }\n  }\n  assertEquals(0,nerrs.get());\n}\n", "docstring": "validates that the same statements are found in each of the statement indices .", "partition": "test"}
{"idx": "2576", "code": "public void show(@IdRes final int itemId){\n  map.add(itemId);\n  navigation.invalidateBadge(itemId);\n}\n", "docstring": "request to display a new badge over the passed menu item id", "partition": "test"}
{"idx": "2577", "code": "public Options put(String option,Integer value){\n  if (value == null) {\n    return remove(option);\n  }\n  options.put(option,value.toString());\n  return this;\n}\n", "docstring": "put an option integer value .", "partition": "test"}
{"idx": "2578", "code": "private int determineTargetPage(int currentPage,float pageOffset,int velocity,int deltaX){\n  int targetPage;\n  if (Math.abs(deltaX) > flingDistance && Math.abs(velocity) > minimumVelocity) {\n    if (virtualPos < 0) {\n      targetPage=velocity > 0 ? currentPage : currentPage + 1;\n    }\n else {\n      targetPage=velocity > 0 ? currentPage + 1 : currentPage;\n    }\n  }\n else {\n    final float truncator=currentPage >= currentItem ? 0.4f : 0.6f;\n    targetPage=(int)(currentPage + pageOffset + truncator);\n  }\n  if (items.size() > 0) {\n    final ItemInfo firstItem=items.get(0);\n    final ItemInfo lastItem=items.get(items.size() - 1);\n    targetPage=Math.max(firstItem.position,Math.min(targetPage,lastItem.position));\n  }\n  if (targetPage > currentPage && onCardChangeListener != null) {\n    onCardChangeListener.onCardDismissed(currentPage,virtualPos > 0);\n  }\n  return targetPage;\n}\n", "docstring": "figure out what the target page would be given current scroll and velocity .", "partition": "test"}
{"idx": "2579", "code": "protected String form(ObjectMatrix1D matrix,int index,Former formatter){\n  Object value=matrix.get(index);\n  if (value == null)   return \"\";\n  return String.valueOf(value);\n}\n", "docstring": "converts a given cell to a string ; no alignment considered .", "partition": "test"}
{"idx": "2580", "code": "public void disable(BluetoothAdapter adapter){\n  int mask=(BluetoothReceiver.STATE_TURNING_OFF_FLAG | BluetoothReceiver.STATE_OFF_FLAG | BluetoothReceiver.SCAN_MODE_NONE_FLAG);\n  long start=-1;\n  BluetoothReceiver receiver=getBluetoothReceiver(mask);\n  int state=adapter.getState();\nswitch (state) {\ncase BluetoothAdapter.STATE_OFF:\n    assertFalse(adapter.isEnabled());\n  removeReceiver(receiver);\nreturn;\ncase BluetoothAdapter.STATE_TURNING_ON:\nassertFalse(adapter.isEnabled());\nstart=System.currentTimeMillis();\nbreak;\ncase BluetoothAdapter.STATE_ON:\nassertTrue(adapter.isEnabled());\nstart=System.currentTimeMillis();\nassertTrue(adapter.disable());\nbreak;\ncase BluetoothAdapter.STATE_TURNING_OFF:\nassertFalse(adapter.isEnabled());\nmask=0;\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"disable() invalid state: state=%d\",state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) {\nstate=adapter.getState();\nif (state == BluetoothAdapter.STATE_OFF && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.isEnabled());\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"disable() completed in %d ms\",(finish - start)));\n}\n else {\nwriteOutput(\"disable() completed\");\n}\nremoveReceiver(receiver);\nreturn;\n}\nsleep(POLL_TIME);\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",state,BluetoothAdapter.STATE_OFF,firedFlags,mask));\n}\n", "docstring": "disables bluetooth and checks to make sure that bluetooth was turned off and that the correct actions were broadcast .", "partition": "test"}
{"idx": "2581", "code": "public static String toRegex(String glob,String separator){\n  checkNotNull(separator,\"separator must be non-null\");\n  checkArgument(separator.length() == 1,\"separator must be a single character: %s\",separator);\n  return toRegex(glob,separator.charAt(0));\n}\n", "docstring": "converts the given glob pattern into a regular expression .", "partition": "test"}
{"idx": "2582", "code": "protected void forceNoLoss(boolean value){\n}\n", "docstring": "should the data of this tile be forced to case no data loss . this information is not relevant in all cases that it is ignored by default .", "partition": "test"}
{"idx": "2583", "code": "public static String[] splitWithoutEscaped(String str,char separatorChar,boolean retainEmpty){\n  int len=str.length();\n  if (len == 0) {\n    return new String[0];\n  }\n  List<String> list=new ArrayList<String>();\n  int i=0;\n  int start=0;\n  boolean match=false;\n  while (i < len) {\n    if (str.charAt(i) == '\\\\') {\n      match=true;\n      i+=2;\n    }\n else     if (str.charAt(i) == separatorChar) {\n      if (retainEmpty || match) {\n        list.add(str.substring(start,i));\n        match=false;\n      }\n      start=++i;\n    }\n else {\n      match=true;\n      i++;\n    }\n  }\n  if (retainEmpty || match) {\n    list.add(str.substring(start,i));\n  }\n  return list.toArray(new String[list.size()]);\n}\n", "docstring": "does not take into account escaped separators", "partition": "test"}
{"idx": "2584", "code": "private static HashMap<BasicBlockPair,HashSet<Register>> findSplitPoints(IR ir,LiveAnalysis live,LSTGraph lst){\n  HashMap<BasicBlockPair,HashSet<Register>> result=new HashMap<BasicBlockPair,HashSet<Register>>(10);\n  for (Enumeration<GraphNode> e=lst.enumerateNodes(); e.hasMoreElements(); ) {\n    LSTNode node=(LSTNode)e.nextElement();\n    BasicBlock header=node.getHeader();\n    BitVector loop=node.getLoop();\n    if (loop == null)     continue;\n    for (Enumeration<BasicBlock> in=header.getIn(); in.hasMoreElements(); ) {\n      BasicBlock bb=in.nextElement();\n      if (loop.get(bb.getNumber()))       continue;\n      HashSet<Register> liveRegisters=live.getLiveRegistersOnEdge(bb,header);\n      for (      Register r : liveRegisters) {\n        if (r.isSymbolic()) {\n          HashSet<Register> s=findOrCreateSplitSet(result,bb,header);\n          s.add(r);\n        }\n      }\n    }\n    for (int i=0; i < loop.length(); i++) {\n      if (loop.get(i)) {\n        BasicBlock bb=ir.getBasicBlock(i);\n        for (Enumeration<BasicBlock> out=bb.getNormalOut(); out.hasMoreElements(); ) {\n          BasicBlock dest=out.nextElement();\n          if (loop.get(dest.getNumber()))           continue;\n          HashSet<Register> liveRegisters=live.getLiveRegistersOnEdge(bb,dest);\n          for (          Register r : liveRegisters) {\n            if (r.isSymbolic()) {\n              HashSet<Register> s=findOrCreateSplitSet(result,bb,dest);\n              s.add(r);\n            }\n          }\n        }\n      }\n    }\n  }\n  addEntriesForInfrequentBlocks(ir,live,result);\n  return result;\n}\n", "docstring": "find the points the ir where live ranges should be split .", "partition": "test"}
{"idx": "2585", "code": "public void testSplitEscapedSemicolons(){\n  Properties inner=PropertyUtils.splitPropertiesOnSemicolon(PropertyUtils.escapeBackSlashesIfNotNull(\"foo=bar;baz=blorple\\\\;zot;windows=c:\\\\test;glorg=gluux\"));\n  assertEquals(4,inner.size());\n  assertEquals(\"bar\",inner.getProperty(\"foo\"));\n  assertEquals(\"blorple;zot\",inner.getProperty(\"baz\"));\n  assertEquals(\"gluux\",inner.getProperty(\"glorg\"));\n  assertEquals(\"c:\\\\test\",inner.getProperty(\"windows\"));\n}\n", "docstring": "test split of escaped semicolons .", "partition": "test"}
{"idx": "2586", "code": "public static void removeObjectAtOffset(Object[] sourceArray,Object[] destinationArray,int offset){\n  System.arraycopy(sourceArray,0,destinationArray,0,offset);\n  System.arraycopy(sourceArray,offset + 1,destinationArray,offset,sourceArray.length - offset - 1);\n}\n", "docstring": "removes the object at the source array offset and copies all other objects to the destination array", "partition": "test"}
{"idx": "2587", "code": "@SuppressWarnings(\"unchecked\") public DictionaryAdapter(Context context,File dbPath,String dbName,String defaultTable){\n  mContext=context;\n  mDbName=dbName;\n  mDefaultTable=defaultTable;\n  mDbPath=dbPath;\n  mDbFile=new File(dbPath,mDbName);\n  if (mDbFile.exists()) {\n    open();\n  }\n}\n", "docstring": "open the database if it exists or create it if it doesn \"'\" t . additionally checks if the table exists and creates it if it doesn \"'\" t .", "partition": "test"}
{"idx": "2588", "code": "HttpStreamWrapper(HttpStream stream) throws IOException {\n  _stream=stream;\n}\n", "docstring": "create a new http stream .", "partition": "test"}
{"idx": "2589", "code": "public boolean handleFile(File file){\n  if (DEBUG) {\n    logger.fine(\"searching finds: \" + file.getAbsolutePath());\n  }\n  filenames.add(file);\n  return true;\n}\n", "docstring": "when a file is found , add it .", "partition": "test"}
{"idx": "2590", "code": "public boolean looksLikeNumberComing(){\n  if (n >= s.length())   return false;\n  return Character.isDigit(s.charAt(n));\n}\n", "docstring": "peeks the next char , without gobbling it . tells us if it \"'\" s a digit or not .", "partition": "test"}
{"idx": "2591", "code": "public short readShort() throws IOException {\n  return primitiveTypes.readShort();\n}\n", "docstring": "reads a short ( 16 bit ) from the source stream .", "partition": "test"}
{"idx": "2592", "code": "public void print(int inum){\n  print(String.valueOf(inum));\n}\n", "docstring": "prints the string representation of the specified integer to the target .", "partition": "test"}
{"idx": "2593", "code": "public static <NodeType extends IViewNode<?>>ZyProximityNode<?> createProximityNode(final Graph2D graph,final ZyGraphNode<?> attachedNode,final int degree,final boolean isIncoming){\n  Preconditions.checkNotNull(graph,\"Graph argument can not be null\");\n  Preconditions.checkNotNull(attachedNode,\"Target node argument can not be null\");\n  final ZyLabelContent labelcontent=new ZyLabelContent(null);\n  labelcontent.addLineContent(new ZyLineContent(String.valueOf(degree),new Font(\"New Courier\",Font.PLAIN,12),null));\n  final ZyProximityNodeRealizer<NodeType> r=new ZyProximityNodeRealizer<NodeType>(labelcontent);\n  final Node node=graph.createNode(r);\n  @SuppressWarnings(\"unchecked\") final ZyProximityNode<NodeType> infoNode=new ZyProximityNode<NodeType>(node,r,(ZyGraphNode<NodeType>)attachedNode,isIncoming);\n  final ZyNodeData<ZyProximityNode<NodeType>> data=new ZyNodeData<ZyProximityNode<NodeType>>(infoNode);\n  r.setUserData(data);\n  return infoNode;\n}\n", "docstring": "creates a proximity browsing node .", "partition": "test"}
{"idx": "2594", "code": "public static boolean isZoningRequired(DbClient dbClient,URI varrayUri){\n  if (varrayUri != null) {\n    VirtualArray nh=dbClient.queryObject(VirtualArray.class,varrayUri);\n    if (nh != null) {\n      return isZoningRequired(dbClient,nh);\n    }\n  }\n  return false;\n}\n", "docstring": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "partition": "test"}
{"idx": "2595", "code": "protected CCAnimation(String name,float delay,ArrayList<CCSpriteFrame> frames){\n  delay_=delay;\n  name_=name;\n  frames_=new ArrayList<CCSpriteFrame>();\n  if (frames != null)   frames_.addAll(frames);\n}\n", "docstring": "initializes a ccanimation with a name , delay and an array of ccspriteframes .", "partition": "test"}
{"idx": "2596", "code": "private void navigateToDump(){\n  TreePath currentPath=tree.getSelectionPath();\n  tree.setSelectionPath(currentPath.getParentPath());\n  tree.scrollPathToVisible(currentPath.getParentPath());\n}\n", "docstring": "navigate to root node of currently active dump", "partition": "test"}
{"idx": "2597", "code": "public synchronized void addMessages(ArrayList<SmsMmsMessage> newMessages){\n  if (newMessages != null) {\n    messages.addAll(0,newMessages);\n    UpdateMessageCount();\n  }\n}\n", "docstring": "add a list of new messages to the end of the current message list .", "partition": "test"}
{"idx": "2598", "code": "public int swap(){\n  if (!egl.eglSwapBuffers(eglDisplay,eglSurface)) {\n    return egl.eglGetError();\n  }\n  return EGL10.EGL_SUCCESS;\n}\n", "docstring": "display the current render surface .", "partition": "test"}
{"idx": "2599", "code": "public static List<Window> windows(String words,int windowSize){\n  StringTokenizer tokenizer=new StringTokenizer(words);\n  List<String> list=new ArrayList<String>();\n  while (tokenizer.hasMoreTokens())   list.add(tokenizer.nextToken());\n  return windows(list,windowSize);\n}\n", "docstring": "constructs a list of window of size windowsize . note that padding for each window is created as well .", "partition": "test"}
{"idx": "2600", "code": "protected void drawCenterText(Canvas c){\n  CharSequence centerText=mChart.getCenterText();\n  if (mChart.isDrawCenterTextEnabled() && centerText != null) {\n    MPPointF center=mChart.getCenterCircleBox();\n    MPPointF offset=mChart.getCenterTextOffset();\n    float x=center.x + offset.x;\n    float y=center.y + offset.y;\n    float innerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();\n    RectF holeRect=mRectBuffer[0];\n    holeRect.left=x - innerRadius;\n    holeRect.top=y - innerRadius;\n    holeRect.right=x + innerRadius;\n    holeRect.bottom=y + innerRadius;\n    RectF boundingRect=mRectBuffer[1];\n    boundingRect.set(holeRect);\n    float radiusPercent=mChart.getCenterTextRadiusPercent() / 100f;\n    if (radiusPercent > 0.0) {\n      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);\n    }\n    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {\n      mCenterTextLastBounds.set(boundingRect);\n      mCenterTextLastValue=centerText;\n      float width=mCenterTextLastBounds.width();\n      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);\n    }\n    float layoutHeight=mCenterTextLayout.getHeight();\n    c.save();\n    if (Build.VERSION.SDK_INT >= 18) {\n      Path path=mDrawCenterTextPathBuffer;\n      path.reset();\n      path.addOval(holeRect,Path.Direction.CW);\n      c.clipPath(path);\n    }\n    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);\n    mCenterTextLayout.draw(c);\n    c.restore();\n    MPPointF.recycleInstance(center);\n    MPPointF.recycleInstance(offset);\n  }\n}\n", "docstring": "draws the unit text in the center of the pie chart makes most sense when center - hole is enabled", "partition": "test"}
{"idx": "2601", "code": "protected void groupFrames(Vector<Frame> frames,Vector<Group> groups,boolean isDchum) throws MakeTocException {\n  Frame frame;\n  Group group;\n  int groupCount;\n  int nFrames=frames.size();\n  Debug.message(\"maketoc\",\"MakeToc: *** grouping frames ***\");\n  for (int i=0; i < nFrames; i++) {\n    Debug.message(\"maketocdetail\",\"MakeToc: group addition, starting outer loop\");\n    frame=(Frame)frames.elementAt(i);\n    if (!frame.marked) {\n      groupCount=groups.size();\n      group=new Group();\n      group.left=maxSide / 2;\n      group.right=group.left + 1;\n      group.top=maxSide / 2;\n      group.bottom=group.top + 1;\n      group.horiz_pos[group.top]=frame.top;\n      group.horiz_pos[group.bottom]=frame.bottom;\n      group.vert_pos[group.left]=frame.left;\n      group.vert_pos[group.right]=frame.right;\n      group.h_interval=frame.h_interval;\n      group.v_interval=frame.v_interval;\n      group.h_resolution=frame.h_resolution;\n      group.v_resolution=frame.v_resolution;\n      group.scale=frame.scale;\n      group.zone=frame.zone;\n      group.cib=frame.cib;\n      group.cdted=frame.cdted;\n      frame.x=group.left;\n      frame.y=group.top;\n      frame.group=groupCount;\n      frame.marked=true;\n      Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: created group \" + groupCount + \" for frame \"+ i+ \", - \"+ frame.filename+ \" checking other frames for neighbors\");\n      if (!isDchum) {\n        for (int j=0; j < nFrames; j++) {\n          if (i == j) {\n            Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: inner loop, i = j = \" + i + \", frame that created group added to group, expecting false return\");\n            continue;\n          }\n          Frame f=(Frame)frames.elementAt(j);\n          if (addFrameToGroup(group,f,groupCount)) {\n            Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: added frame \" + j + \" to group \"+ groupCount);\n            continue;\n          }\n        }\n      }\n      Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: adding another group - \" + groupCount + \" *******************\\n\\n\");\n      groups.add(group);\n    }\n    fireProgressUpdate(ProgressEvent.UPDATE,\"Organizing frames\",i,nFrames);\n  }\n  if (Debug.debugging(\"maketoc\")) {\n    Debug.output(\"MakeToc: Number of boundary rectangles (groups): \" + groups.size());\n  }\n}\n", "docstring": "take the vector of frames , and group them into boundary rectangles , represented by groups . if dchum is present , all frames get placed in their own group .", "partition": "test"}
{"idx": "2602", "code": "private static Object add(final Object array,final int index,final Object element,final Class<?> clss){\n  if (array == null) {\n    if (index != 0) {\n      throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n    }\n    Object joinedArray=Array.newInstance(clss,1);\n    Array.set(joinedArray,0,element);\n    return joinedArray;\n  }\n  int length=Array.getLength(array);\n  if (index > length || index < 0) {\n    throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \"+ length);\n  }\n  Object result=Array.newInstance(clss,length + 1);\n  System.arraycopy(array,0,result,0,index);\n  Array.set(result,index,element);\n  if (index < length) {\n    System.arraycopy(array,index,result,index + 1,length - index);\n  }\n  return result;\n}\n", "docstring": "underlying implementation of add ( array , index , element ) methods . the last parameter is the class , which may not equal element . getclass for primitives .", "partition": "test"}
{"idx": "2603", "code": "public double doubleValue(){\n  return d.doubleValue();\n}\n", "docstring": "get the double value corresponding to the instance .", "partition": "test"}
{"idx": "2604", "code": "public String toMatlab(){\n  StringBuffer result;\n  int i;\n  int n;\n  result=new StringBuffer();\n  result.append(\"[\");\n  for (i=0; i < getRowDimension(); i++) {\n    if (i > 0) {\n      result.append(\"; \");\n    }\n    for (n=0; n < getColumnDimension(); n++) {\n      if (n > 0) {\n        result.append(\" \");\n      }\n      result.append(Double.toString(get(i,n)));\n    }\n  }\n  result.append(\"]\");\n  return result.toString();\n}\n", "docstring": "converts the matrix into a single line matlab string : matrix is enclosed by parentheses , rows are separated by semicolon and single cells by blanks , e . g . , [ 1 2 ; 3 4 ", "partition": "test"}
{"idx": "2605", "code": "public FileInputReader(File f) throws IOException {\n  if (Debug.debugging(\"binaryfile\")) {\n    Debug.output(\"FileInputReader created from \" + f.getAbsolutePath());\n  }\n  name=f.getName();\n  absolutePath=f.getAbsolutePath();\n  inputFile=init(f);\n}\n", "docstring": "constructs a new binaryfile with the specified file as the input . the default byte - order is lsb first . reads start at the first byte of the file .", "partition": "test"}
{"idx": "2606", "code": "public static ObjectOutputStream newObjectOutputStream(Path self) throws IOException {\n  return new ObjectOutputStream(Files.newOutputStream(self));\n}\n", "docstring": "create an object output stream for this path .", "partition": "test"}
{"idx": "2607", "code": "@Override public Set<K> keySet(){\n  HashSet<K> set=new HashSet<K>();\n  for (  Segment<K,V> s : segments) {\n    set.addAll(s.keySet());\n  }\n  return set;\n}\n", "docstring": "get the set of keys for resident entries .", "partition": "test"}
{"idx": "2608", "code": "public void add(final CertificateValidity certificateValidity){\n  certificateValidityList.add(certificateValidity);\n}\n", "docstring": "this method allows to add a candidate for the signing certificate .", "partition": "test"}
{"idx": "2609", "code": "public void addPolicyListener(PolicyListener policyListener){\n  policyCache.addPolicyListener(policyListener);\n}\n", "docstring": "adds a policy listener that would be notified whenever a policy is added , removed or changed", "partition": "test"}
{"idx": "2610", "code": "public static Result verify(String sid,String code){\n  String id=\"//captcha/\" + sid;\n  Code c=(Code)Cache.get(id);\n  if (c == null) {\n    log.warn(\"no code in cache, sid=\" + sid);\n    return Result.badcode;\n  }\n else   if (!X.isSame(code,c.code)) {\n    log.warn(\"is not same, code.server=\" + c.code + \", code.client=\"+ code);\n    return Result.badcode;\n  }\n else   if (c.expired < System.currentTimeMillis()) {\n    log.warn(\"expired, expired=\" + c.expired);\n    return Result.expired;\n  }\n  return Result.ok;\n}\n", "docstring": "verify the code associated", "partition": "test"}
{"idx": "2611", "code": "protected static INaviRawModule findRawModule(final int rawModuleId,final List<INaviRawModule> rawModules){\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be positive integer\",rawModuleId);\n  Preconditions.checkNotNull(rawModules,\"IE02263: raw modules argument can not be null\");\n  for (  final INaviRawModule rawModule : rawModules) {\n    if (rawModule.getId() == rawModuleId) {\n      return rawModule;\n    }\n  }\n  throw new IllegalStateException(\"IE00160: Could not find raw module\");\n}\n", "docstring": "returns the raw module with the given id .", "partition": "test"}
{"idx": "2612", "code": "public static Object extractTypeChecked(List<Object> args,int i,Class clazz,Function<List<Object>,Object> extractFunc){\n  if (args.size() < i + 1) {\n    return null;\n  }\n else   if (clazz.isInstance(args.get(i))) {\n    return extractFunc.apply(args);\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "extract type - checked value from an argument list using the specified type check and extraction function", "partition": "test"}
{"idx": "2613", "code": "@Override public JapaneseDate dateYearDay(int prolepticYear,int dayOfYear){\n  return new JapaneseDate(LocalDate.ofYearDay(prolepticYear,dayOfYear));\n}\n", "docstring": "obtains a local date in japanese calendar system from the proleptic - year and day - of - year fields . < p > the day - of - year in this factory is expressed relative to the start of the proleptic year . the japanese proleptic year and day - of - year are the same as those in the iso calendar system . they are not reset when the era changes .", "partition": "test"}
{"idx": "2614", "code": "private Pair<Entry,char[]> recoverEntry(KeyStore ks,String alias,char[] pstore,char[] pkey) throws Exception {\n  if (ks.containsAlias(alias) == false) {\n    MessageFormat form=new MessageFormat(rb.getString(\"Alias.alias.does.not.exist\"));\n    Object[] source={alias};\n    throw new Exception(form.format(source));\n  }\n  PasswordProtection pp=null;\n  Entry entry;\n  try {\n    entry=ks.getEntry(alias,pp);\n    pkey=null;\n  }\n catch (  UnrecoverableEntryException une) {\n    if (P11KEYSTORE.equalsIgnoreCase(ks.getType()) || KeyStoreUtil.isWindowsKeyStore(ks.getType())) {\n      throw une;\n    }\n    if (pkey != null) {\n      pp=new PasswordProtection(pkey);\n      entry=ks.getEntry(alias,pp);\n    }\n else {\n      try {\n        pp=new PasswordProtection(pstore);\n        entry=ks.getEntry(alias,pp);\n        pkey=pstore;\n      }\n catch (      UnrecoverableEntryException une2) {\n        if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {\n          throw une2;\n        }\n else {\n          pkey=getKeyPasswd(alias,null,null);\n          pp=new PasswordProtection(pkey);\n          entry=ks.getEntry(alias,pp);\n        }\n      }\n    }\n  }\n  return Pair.of(entry,pkey);\n}\n", "docstring": "recovers entry associated with given alias .", "partition": "test"}
{"idx": "2615", "code": "URLClassLoader newLoader(URL base){\n  return new URLClassLoader(new URL[]{base});\n}\n", "docstring": "creates a class loader with the given base url as its classpath .", "partition": "test"}
{"idx": "2616", "code": "public Wiser(){\n  this.server=new SMTPServer(new SimpleMessageListenerAdapter(this));\n}\n", "docstring": "create a new smtp server with this class as the listener . the default port is 25 . call setport ( ) / sethostname ( ) before calling start ( ) .", "partition": "test"}
{"idx": "2617", "code": "protected static int[] concat(@Nullable int[] arr,int... obj){\n  int[] newArr;\n  if (arr == null || arr.length == 0)   newArr=obj;\n else {\n    newArr=Arrays.copyOf(arr,arr.length + obj.length);\n    System.arraycopy(obj,0,newArr,arr.length,obj.length);\n  }\n  return newArr;\n}\n", "docstring": "concatenates elements to an int array .", "partition": "test"}
{"idx": "2618", "code": "public void truckCamera(float size){\n  moveToPosition(-(float)(targetXoff + (size * Math.sin(Math.toRadians(zrot - 90)))),-(float)(targetYoff + (size * Math.cos(Math.toRadians(zrot - 90)))));\n}\n", "docstring": "change camera position horizontally ( left or right ) .", "partition": "test"}
{"idx": "2619", "code": "public static byte[] decode2(String encoded){\n  if (encoded == null) {\n    return null;\n  }\n  char[] base64Data=encoded.toCharArray();\n  int len=removeWhiteSpace(base64Data);\n  if (len % FOURBYTE != 0) {\n    return null;\n  }\n  int numberQuadruple=(len / FOURBYTE);\n  if (numberQuadruple == 0) {\n    return new byte[0];\n  }\n  byte decodedData[]=null;\n  byte b1=0, b2=0, b3=0, b4=0;\n  char d1=0, d2=0, d3=0, d4=0;\n  int i=0;\n  int encodedIndex=0;\n  int dataIndex=0;\n  decodedData=new byte[(numberQuadruple) * 3];\n  for (; i < numberQuadruple - 1; i++) {\n    if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++])) || !isData((d3=base64Data[dataIndex++]))|| !isData((d4=base64Data[dataIndex++]))) {\n      return null;\n    }\n    b1=base64Alphabet[d1];\n    b2=base64Alphabet[d2];\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  if (!isData((d1=base64Data[dataIndex++])) || !isData((d2=base64Data[dataIndex++]))) {\n    return null;\n  }\n  b1=base64Alphabet[d1];\n  b2=base64Alphabet[d2];\n  d3=base64Data[dataIndex++];\n  d4=base64Data[dataIndex++];\n  if (!isData((d3)) || !isData((d4))) {\n    if (isPad(d3) && isPad(d4)) {\n      if ((b2 & 0xf) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 1];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex]=(byte)(b1 << 2 | b2 >> 4);\n      return tmp;\n    }\n else     if (!isPad(d3) && isPad(d4)) {\n      b3=base64Alphabet[d3];\n      if ((b3 & 0x3) != 0) {\n        return null;\n      }\n      byte[] tmp=new byte[i * 3 + 2];\n      System.arraycopy(decodedData,0,tmp,0,i * 3);\n      tmp[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n      tmp[encodedIndex]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n      return tmp;\n    }\n else {\n      return null;\n    }\n  }\n else {\n    b3=base64Alphabet[d3];\n    b4=base64Alphabet[d4];\n    decodedData[encodedIndex++]=(byte)(b1 << 2 | b2 >> 4);\n    decodedData[encodedIndex++]=(byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n    decodedData[encodedIndex++]=(byte)(b3 << 6 | b4);\n  }\n  return decodedData;\n}\n", "docstring": "decodes base64 data into octects", "partition": "test"}
{"idx": "2620", "code": "public void shutdown(){\n  scheduledExecutorService.shutdownNow();\n}\n", "docstring": "shut down the health checker .", "partition": "test"}
{"idx": "2621", "code": "public static String deflate(String previous,String current){\n  if (previous == null)   return current;\n  StringBuilder buf=new StringBuilder();\n  int start1=0;\n  int start2=0;\n  while (start1 < previous.length() && start2 < current.length()) {\n    int end1=start1;\n    int end2=start2;\n    while (end1 <= previous.length() && end2 <= current.length()) {\n      int c1=(end1 < previous.length() ? previous.charAt(end1) : \'\\t\');\n      int c2=(end2 < current.length() ? current.charAt(end2) : \'\\t\');\n      if (c1 == c2) {\n        if (c1 == \'\\t\') {\n          buf.append(\"&\");\n          break;\n        }\n else {\n          end1++;\n          end2++;\n        }\n      }\n else {\n        while (end1 < previous.length() && previous.charAt(end1) != \'\\t\') {\n          end1++;\n        }\n        while (end2 < current.length() && current.charAt(end2) != \'\\t\') {\n          end2++;\n        }\n        for (int i=start2; i < end2; i++)         buf.append(current.charAt(i));\n        break;\n      }\n    }\n    start1=end1 + 1;\n    start2=end2 + 1;\n    if (start2 < current.length())     buf.append(\"\\t\");\n  }\n  return buf.toString();\n}\n", "docstring": "deflate current sam line by replacing all fields that equalovershorterofboth previous line by an ampersand", "partition": "test"}
{"idx": "2622", "code": "protected int splitListIndex(List<Pair<Double,Integer>> S){\n  return S.size() / 2;\n}\n", "docstring": "determines which index to use as the splitting index for the vp radius", "partition": "test"}
{"idx": "2623", "code": "public static synchronized void addPropertyChangeListener(PropertyChangeListener l){\n  if (!listeners.contains(l)) {\n    listeners.add(l);\n  }\n}\n", "docstring": "register for notification on changes to specific types", "partition": "test"}
{"idx": "2624", "code": "private static void cleanDirectory(File path){\n  if (path == null)   return;\n  if (path.exists()) {\n    for (    File f : path.listFiles()) {\n      if (f.isDirectory())       cleanDirectory(f);\n      f.delete();\n    }\n  }\n}\n", "docstring": "recursive remove all from directory", "partition": "test"}
{"idx": "2625", "code": "private GridCacheVersion minVersion(Iterable<IgniteTxEntry> entries,GridCacheVersion min,IgniteInternalTx tx){\n  for (  IgniteTxEntry txEntry : entries) {\n    GridCacheEntryEx cached=txEntry.cached();\n    assert txEntry.isRead() || !cached.obsolete(tx.xidVersion()) : \"Invalid obsolete version for transaction [entry=\" + cached + \", tx=\"+ tx+ \']\';\n    for (    GridCacheMvccCandidate cand : cached.remoteMvccSnapshot())     if (min == null || cand.version().isLess(min))     min=cand.version();\n  }\n  return min;\n}\n", "docstring": "go through all candidates for entries involved in transaction and find their min version . we know that these candidates will commit after this transaction , and therefore we can grab the min version so we can send all committed and rolled back versions from min to current to remote nodes for re - ordering .", "partition": "test"}
{"idx": "2626", "code": "public DimensionedScalar(String fieldValue) throws IllegalArgumentException {\n  super(\"\",\"\");\n  Matcher matcher=PATTERN.matcher(fieldValue);\n  if (matcher.find()) {\n    String name=matcher.group(1);\n    String dimensions=matcher.group(2);\n    String value=matcher.group(3);\n    setName(name);\n    setValue(value);\n    this.dimensions=new Dimensions(dimensions);\n  }\n else {\n    throw new DictionaryException(\"CANNOT PARSE:  >\" + fieldValue + \"<\");\n  }\n}\n", "docstring": "la stringa contiene il value del field di cui bisogna fare il parsing per estrarre valore e unita \"'\" di misura", "partition": "test"}
{"idx": "2627", "code": "public void characters(char ch[],int start,int length) throws SAXException {\n  m_valueBuffer.append(ch,start,length);\n}\n", "docstring": "characters read from xml are assigned to a variable , based on the current m_context . no checks are being done , it is assumed that the context is correct .", "partition": "test"}
{"idx": "2628", "code": "protected double computeStdDev(Instance inst,Matrix k) throws Exception {\n  double kappa=m_kernel.eval(-1,-1,inst) + m_deltaSquared;\n  double s=0;\n  int n=m_L.length;\n  for (int i=0; i < n; i++) {\n    double t=0;\n    for (int j=0; j < n; j++) {\n      t-=k.get(j,0) * (i > j ? m_L[i][j] : m_L[j][i]);\n    }\n    s+=t * k.get(i,0);\n  }\n  double sigma=m_delta;\n  if (kappa > s) {\n    sigma=Math.sqrt(kappa - s);\n  }\n  return sigma;\n}\n", "docstring": "computes standard deviation for given instance , without transforming target back into original space .", "partition": "test"}
{"idx": "2629", "code": "protected void initialize(Properties p){\n}\n", "docstring": "sub - classes can override to initialize other properties .", "partition": "test"}
{"idx": "2630", "code": "public void add(int index,int element){\n  checkRangeIncludingEndpoint(index);\n  ensureCapacity(size + 1);\n  int numtomove=size - index;\n  System.arraycopy(array,index,array,index + 1,numtomove);\n  array[index]=element;\n  size++;\n}\n", "docstring": "inserts the specified element at the specified position in this list . shifts the element currently at that position ( if any ) and any subsequent elements to the right ( adds one to their indices ) .", "partition": "test"}
{"idx": "2631", "code": "public MultiplexManager(DataStore... dataStores){\n  this.dataStores=Arrays.asList(dataStores);\n}\n", "docstring": "create a single datastore to handle provided managers within a single transaction .", "partition": "test"}
{"idx": "2632", "code": "public boolean matchesRawNamePattern(Object item){\n  String prefix=patternMatcher.getPattern();\n  String text=getElementName(item);\n  if (text == null)   return false;\n  int textLength=text.length();\n  int prefixLength=prefix.length();\n  if (textLength < prefixLength) {\n    return false;\n  }\n  for (int i=prefixLength - 1; i >= 0; i--) {\n    if (Character.toLowerCase(prefix.charAt(i)) != Character.toLowerCase(text.charAt(i)))     return false;\n  }\n  return true;\n}\n", "docstring": "general method for matching raw name pattern . checks whether current pattern is prefix of name provided item .", "partition": "test"}
{"idx": "2633", "code": "public static @Nonnull <T>T valueOrDefault(@Nullable T value,@Nonnull T defaultValue){\n  return value == null ? defaultValue : value;\n}\n", "docstring": "returns a value if that value is not null , or a specified default value otherwise .", "partition": "test"}
{"idx": "2634", "code": "protected abstract int compareToLastMsg(Pair<K,V> tupleKeyValue,Pair<byte[],byte[]> lastReceivedKeyValue);\n", "docstring": "compare the incoming tuple with the last received message in kafka .", "partition": "test"}
{"idx": "2635", "code": "private void parseMenu(XmlPullParser parser,AttributeSet attrs,SublimeMenu menu) throws XmlPullParserException, IOException {\n  MenuState menuState=new MenuState(menu);\n  int eventType=parser.getEventType();\n  String tagName;\n  boolean lookingForEndOfUnknownTag=false;\n  String unknownTagName=null;\n  do {\n    if (eventType == XmlPullParser.START_TAG) {\n      tagName=parser.getName();\n      if (tagName.equals(XML_MENU)) {\n        eventType=parser.next();\n        break;\n      }\n      throw new RuntimeException(\"Expecting menu, got \" + tagName);\n    }\n    eventType=parser.next();\n  }\n while (eventType != XmlPullParser.END_DOCUMENT);\n  boolean reachedEndOfMenu=false;\n  while (!reachedEndOfMenu) {\nswitch (eventType) {\ncase XmlPullParser.START_TAG:\n      if (lookingForEndOfUnknownTag) {\n        break;\n      }\n    tagName=parser.getName();\n  if (tagName.equals(XML_GROUP)) {\n    if (menuState.groupId != MenuState.defaultGroupId) {\n      throw new RuntimeException(\"A \'Group\' item cannot have \" + \"other \'Group\' items as children.\");\n    }\n    menuState.readGroup(attrs);\n    menuState.addGroup();\n  }\n else   if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_SEPARATOR)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_GROUP_HEADER)) {\n    if (menuState.groupId == MenuState.defaultGroupId) {\n      throw new RuntimeException(\"\'GroupHeader\' item should \" + \"be placed inside a Group element.\");\n    }\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_MENU)) {\n    throw new RuntimeException(\"Sub-menus are not supported. \" + \"Similar functionality can be afforded \" + \"using the \'group\' tag.\");\n  }\n else {\n    lookingForEndOfUnknownTag=true;\n    unknownTagName=tagName;\n  }\nbreak;\ncase XmlPullParser.END_TAG:\ntagName=parser.getName();\nif (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {\nlookingForEndOfUnknownTag=false;\nunknownTagName=null;\n}\n else if (tagName.equals(XML_GROUP)) {\nif (menuState.isGroupCollapsible() && menuState.groupHeadersAdded != 1) {\nif (menuState.groupHeadersAdded < 1) {\n  throw new RuntimeException(\"A \'GroupHeader\' is required \" + \"to create a \'collapsible\' Group.\");\n}\n else {\n  throw new RuntimeException(\"A \'collapsible\' Group can only \" + \"have ONE \'GroupHeader\'. You have provided: \" + menuState.groupHeadersAdded + \".\");\n}\n}\nmenuState.resetGroup();\n}\n else if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)|| tagName.equals(XML_GROUP_HEADER)|| tagName.equals(XML_SEPARATOR)) {\nif (!menuState.hasAddedItem()) {\nmenuState.addItem();\n}\n}\n else if (tagName.equals(XML_MENU)) {\nreachedEndOfMenu=true;\n}\nbreak;\ncase XmlPullParser.END_DOCUMENT:\nthrow new RuntimeException(\"Unexpected end of document\");\n}\neventType=parser.next();\n}\n}\n", "docstring": "called internally to fill the given menu .", "partition": "test"}
{"idx": "2636", "code": "public static double crossTrackDistanceRad(double lat1,double lon1,double lat2,double lon2,double latQ,double lonQ){\n  final double dlon12=lon2 - lon1;\n  final double dlon1Q=lonQ - lon1;\n  final double dlat1Q=latQ - lat1;\n  final double clat1=Math.cos(lat1), slat1=MathUtil.cosToSin(lat1,clat1);\n  final double clatQ=Math.cos(latQ), slatQ=MathUtil.cosToSin(latQ,clatQ);\n  final double clat2=Math.cos(lat2), slat2=MathUtil.cosToSin(lat2,clat2);\n  final double slat=Math.sin(dlat1Q * .5);\n  final double slon=Math.sin(dlon1Q * .5);\n  final double a=slat * slat + slon * slon * clat1* clatQ;\n  final double angDist1Q=2 * Math.atan2(Math.sqrt(a),Math.sqrt(1 - a));\n  final double sdlon12=Math.sin(dlon12), cdlon12=MathUtil.sinToCos(dlon12,sdlon12);\n  final double sdlon1Q=Math.sin(dlon1Q), cdlon1Q=MathUtil.sinToCos(dlon1Q,sdlon1Q);\n  final double yE=sdlon12 * clat2;\n  final double yQ=sdlon1Q * clatQ;\n  final double xE=clat1 * slat2 - slat1 * clat2 * cdlon12;\n  final double xQ=clat1 * slatQ - slat1 * clatQ * cdlon1Q;\n  final double crs12=Math.atan2(yE,xE);\n  final double crs1Q=Math.atan2(yQ,xQ);\n  return Math.asin(Math.sin(angDist1Q) * Math.sin(crs1Q - crs12));\n}\n", "docstring": "compute the cross - track distance . xtd = asin ( sin ( dist_sq ) * sin ( crs_sq - crs_se ) )", "partition": "test"}
{"idx": "2637", "code": "public String chooseServerAlias(String keyType,Principal[] issuers,Socket socket){\n  return defaultX509KM.chooseServerAlias(keyType,issuers,socket);\n}\n", "docstring": "returns an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .", "partition": "test"}
{"idx": "2638", "code": "public static double pdf(double x,double shape,double scale,double factor){\n  if (x <= 0)   return 0.0;\n  final double a=Math.exp(shape * Math.log(scale) - (shape + 1) * Math.log(x) - (scale / x) - GammaFunction.lnGamma(shape));\n  return factor * a;\n}\n", "docstring": "probability density function of the gamma distribution", "partition": "test"}
{"idx": "2639", "code": "public String charge(Properties ctx,int WindowNo,GridTab mTab,GridField mField,Object value){\n  Integer C_Charge_ID=(Integer)value;\n  if (C_Charge_ID == null || C_Charge_ID.intValue() == 0)   return \"\";\n  String sql=\"SELECT ChargeAmt FROM C_Charge WHERE C_Charge_ID=?\";\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,C_Charge_ID.intValue());\n    rs=pstmt.executeQuery();\n    if (rs.next()) {\n      mTab.setValue(\"PriceEntered\",rs.getBigDecimal(1));\n    }\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n    return e.getLocalizedMessage();\n  }\n finally {\n    DB.close(rs,pstmt);\n    rs=null;\n    pstmt=null;\n  }\n  return tax(ctx,WindowNo,mTab,mField,value);\n}\n", "docstring": "invoice batch line - charge . - updates priceentered from charge calles tax", "partition": "test"}
{"idx": "2640", "code": "protected Array<Actor> parse(){\n  actors=GdxArrays.newArray(Actor.class);\n  invokePreListeners(actors);\n  final StringBuilder builder=new StringBuilder();\n  while (templateReader.hasNextCharacter()) {\n    final char character=templateReader.nextCharacter();\n    if (character == syntax.getArgumentOpening()) {\n      processArgument();\n    }\n else     if (character == syntax.getTagOpening()) {\n      if (isNextCharacterCommentOpening()) {\n        processComment();\n        continue;\n      }\n      if (currentParentTag != null) {\n        currentParentTag.handleDataBetweenTags(builder);\n      }\n      Strings.clearBuilder(builder);\n      processTag(builder);\n    }\n else {\n      builder.append(character);\n    }\n  }\n  if (currentParentTag != null) {\n    throwError(\'\"\' + currentParentTag.getTagName() + \"\\\" tag was never closed.\");\n  }\n  invokePortListeners(actors);\n  return actors;\n}\n", "docstring": "does the actual parsing", "partition": "test"}
{"idx": "2641", "code": "public void testABandCBbrokerNetwork() throws Exception {\n  bridgeBrokers(\"BrokerA\",\"BrokerB\");\n  bridgeBrokers(\"BrokerC\",\"BrokerB\");\n  startAllBrokers();\n  Destination dest=createDestination(\"TEST.FOO\",true);\n  MessageConsumer clientA=createConsumer(\"BrokerA\",dest);\n  MessageConsumer clientB=createConsumer(\"BrokerB\",dest);\n  MessageConsumer clientC=createConsumer(\"BrokerC\",dest);\n  Thread.sleep(2000);\n  sendMessages(\"BrokerA\",dest,MESSAGE_COUNT);\n  sendMessages(\"BrokerB\",dest,MESSAGE_COUNT);\n  sendMessages(\"BrokerC\",dest,MESSAGE_COUNT);\n  MessageIdList msgsA=getConsumerMessages(\"BrokerA\",clientA);\n  MessageIdList msgsB=getConsumerMessages(\"BrokerB\",clientB);\n  MessageIdList msgsC=getConsumerMessages(\"BrokerC\",clientC);\n  msgsA.waitForMessagesToArrive(MESSAGE_COUNT);\n  msgsB.waitForMessagesToArrive(MESSAGE_COUNT * 3);\n  msgsC.waitForMessagesToArrive(MESSAGE_COUNT);\n  assertEquals(MESSAGE_COUNT,msgsA.getMessageCount());\n  assertEquals(MESSAGE_COUNT * 3,msgsB.getMessageCount());\n  assertEquals(MESSAGE_COUNT,msgsC.getMessageCount());\n}\n", "docstring": "brokera - > brokerb < - brokerc", "partition": "test"}
{"idx": "2642", "code": "public void flush() throws IOException {\n  WspUtil.writeUint8(os_,0x01);\n  writePublicIdentifier(os_,publicID_);\n  WspUtil.writeUintvar(os_,WapConstants.MIB_ENUM_UTF_8);\n  writeStringTable(os_);\n  wbxmlBody_.close();\n  wbxmlBody_.writeTo(os_);\n  os_.flush();\n}\n", "docstring": "writes the wbxml to stream .", "partition": "test"}
{"idx": "2643", "code": "public static void discard(){\n  current.remove();\n}\n", "docstring": "discards any active baggage currently in this thread", "partition": "test"}
{"idx": "2644", "code": "private Token toASIToken(ILeafNode leaf){\n  if (leaf.isHidden()) {\n    return newSemicolonToken(leaf);\n  }\n else {\n    if (!leafNodes.hasNext()) {\n      int tokenType=tokenTypeMapper.getInternalTokenType(leaf);\n      int semicolonTokenType=tokenTypeMapper.getInternalTokenType(semicolon);\n      if (tokenType == semicolonTokenType) {\n        return new CommonToken(semicolonTokenType,leaf.getText());\n      }\n      if (leaf.getTotalEndOffset() == endOffset) {\n        leafNodes=Iterators.emptyIterator();\n        return new CommonToken(tokenType,leaf.getText());\n      }\n      next=new CommonToken(semicolonTokenType,leaf.getText());\n      return new CommonToken(tokenType,leaf.getText());\n    }\n else     if (leaf.getGrammarElement() == rightCurlyInBlock || leaf.getGrammarElement() == rightCurlyInArrowExpression) {\n      int tokenType=tokenTypeMapper.getInternalTokenType(leaf);\n      next=new CommonToken(tokenType);\n      return new CommonToken(tokenTypeMapper.getInternalTokenType(semicolon),leaf.getText());\n    }\n else {\n      return newSemicolonToken(leaf);\n    }\n  }\n}\n", "docstring": "produces either one or two tokens from the given leaf which represents a location where the production parser inserted a semicolon .", "partition": "test"}
{"idx": "2645", "code": "@Override public PacketBuffer write(PacketBuffer buf){\n  values.forEach(null);\n  return buf;\n}\n", "docstring": "writes this packet to the given buffer", "partition": "test"}
{"idx": "2646", "code": "public final void registerFileType(@NotNull FileType type,@NonNls @Nullable String... defaultAssociatedExtensions){\n  List<FileNameMatcher> matchers=new ArrayList<FileNameMatcher>();\n  if (defaultAssociatedExtensions != null) {\n    for (    String extension : defaultAssociatedExtensions) {\n      matchers.add(new ExtensionFileNameMatcher(extension));\n    }\n  }\n  registerFileType(type,matchers);\n}\n", "docstring": "registers a file type .", "partition": "test"}
{"idx": "2647", "code": "public int parseInt(String localeFormattedInteger){\n  return Integer.parseInt(localeFormattedInteger);\n}\n", "docstring": "parses an integer based on locale conventions", "partition": "test"}
{"idx": "2648", "code": "public static RequestSecurityTokenResponse parseXML(String xml) throws WSFederationException {\n  Document doc=XMLUtils.toDOMDocument(xml,debug);\n  Element root=doc.getDocumentElement();\n  return new RequestSecurityTokenResponse(root);\n}\n", "docstring": "returns requestsecuritytokenresponse object based on the xml document received from server . this method is used primarily at the client side . the schema of the xml document is defined in ws - trust .", "partition": "test"}
{"idx": "2649", "code": "@Override public void requestResources(SamzaResourceRequest resourceRequest){\n  final int DEFAULT_PRIORITY=0;\n  log.info(\"Requesting resources on  \" + resourceRequest.getPreferredHost() + \" for container \"+ resourceRequest.getContainerID());\n  int memoryMb=resourceRequest.getMemoryMB();\n  int cpuCores=resourceRequest.getNumCores();\n  String containerLabel=yarnConfig.getContainerLabel();\n  String preferredHost=resourceRequest.getPreferredHost();\n  Resource capability=Resource.newInstance(memoryMb,cpuCores);\n  Priority priority=Priority.newInstance(DEFAULT_PRIORITY);\n  AMRMClient.ContainerRequest issuedRequest;\n  if (preferredHost.equals(\"ANY_HOST\")) {\n    log.info(\"Making a request for ANY_HOST \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,null,null,priority,true,containerLabel);\n  }\n else {\n    log.info(\"Making a preferred host request on \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,new String[]{preferredHost},null,priority,true,containerLabel);\n  }\nsynchronized (lock) {\n    requestsMap.put(resourceRequest,issuedRequest);\n    amClient.addContainerRequest(issuedRequest);\n  }\n}\n", "docstring": "request resources for running container processes .", "partition": "test"}
{"idx": "2650", "code": "private Collection<ExtractedItemsCollection> filterItemsByLevel(Player player,List<ExtractedItemsCollection> itemsCollections){\n  int playerLevel=player.getLevel();\n  Collection<ExtractedItemsCollection> result=new ArrayList<ExtractedItemsCollection>();\n  for (  ExtractedItemsCollection collection : itemsCollections) {\n    if (collection.getMinLevel() > playerLevel) {\n      continue;\n    }\n    if (collection.getMaxLevel() > 0 && collection.getMaxLevel() < playerLevel) {\n      continue;\n    }\n    result.add(collection);\n  }\n  return result;\n}\n", "docstring": "add to result collection only items witch suits player \"'\" s level", "partition": "test"}
{"idx": "2651", "code": "private String printDFormat(String sx){\n  int nLeadingZeros=0;\n  int nBlanks=0, n=0;\n  int i=0;\n  final int jFirst;\n  final boolean neg=sx.charAt(0) == \'-\';\n  if (sx.equals(\"0\") && precisionSet && precision == 0) {\n    sx=\"\";\n  }\n  if (!neg) {\n    if (precisionSet && sx.length() < precision) {\n      nLeadingZeros=precision - sx.length();\n    }\n  }\n else {\n    if (precisionSet && (sx.length() - 1) < precision) {\n      nLeadingZeros=precision - sx.length() + 1;\n    }\n  }\n  if (nLeadingZeros < 0) {\n    nLeadingZeros=0;\n  }\n  if (fieldWidthSet) {\n    nBlanks=fieldWidth - nLeadingZeros - sx.length();\n    if (!neg && (leadingSign || leadingSpace)) {\n      nBlanks--;\n    }\n  }\n  if (nBlanks < 0) {\n    nBlanks=0;\n  }\n  if (leadingSign) {\n    n++;\n  }\n else   if (leadingSpace) {\n    n++;\n  }\n  n+=nBlanks;\n  n+=nLeadingZeros;\n  n+=sx.length();\n  final char[] ca=new char[n];\n  if (leftJustify) {\n    if (neg) {\n      ca[i++]=\'-\';\n    }\n else     if (leadingSign) {\n      ca[i++]=\'+\';\n    }\n else     if (leadingSpace) {\n      ca[i++]=\' \';\n    }\n    final char[] csx=sx.toCharArray();\n    jFirst=neg ? 1 : 0;\n    for (int j=0; j < nLeadingZeros; i++, j++) {\n      ca[i]=\'0\';\n    }\n    for (int j=jFirst; j < csx.length; j++, i++) {\n      ca[i]=csx[j];\n    }\n    for (int j=0; j < nBlanks; i++, j++) {\n      ca[i]=\' \';\n    }\n  }\n else {\n    if (!leadingZeros) {\n      for (i=0; i < nBlanks; i++) {\n        ca[i]=\' \';\n      }\n      if (neg) {\n        ca[i++]=\'-\';\n      }\n else       if (leadingSign) {\n        ca[i++]=\'+\';\n      }\n else       if (leadingSpace) {\n        ca[i++]=\' \';\n      }\n    }\n else {\n      if (neg) {\n        ca[i++]=\'-\';\n      }\n else       if (leadingSign) {\n        ca[i++]=\'+\';\n      }\n else       if (leadingSpace) {\n        ca[i++]=\' \';\n      }\n      for (int j=0; j < nBlanks; j++, i++) {\n        ca[i]=\'0\';\n      }\n    }\n    for (int j=0; j < nLeadingZeros; j++, i++) {\n      ca[i]=\'0\';\n    }\n    final char[] csx=sx.toCharArray();\n    jFirst=neg ? 1 : 0;\n    for (int j=jFirst; j < csx.length; j++, i++) {\n      ca[i]=csx[j];\n    }\n  }\n  return new String(ca);\n}\n", "docstring": "utility method for formatting using the d conversion character .", "partition": "test"}
{"idx": "2652", "code": "private void drawHost(Graphics2D g2){\n  Coord loc=node.getLocation();\n  if (drawCoverage && node.isRadioActive()) {\n    ArrayList<NetworkInterface> interfaces=new ArrayList<NetworkInterface>();\n    interfaces.addAll(node.getInterfaces());\n    for (    NetworkInterface ni : interfaces) {\n      double range=ni.getTransmitRange();\n      Ellipse2D.Double coverage;\n      coverage=new Ellipse2D.Double(scale(loc.getX() - range),scale(loc.getY() - range),scale(range * 2),scale(range * 2));\n      g2.setColor(rangeColor);\n      g2.draw(coverage);\n    }\n  }\n  if (drawConnections) {\n    g2.setColor(conColor);\n    Coord c1=node.getLocation();\n    ArrayList<Connection> conList=new ArrayList<Connection>();\n    conList.addAll(node.getConnections());\n    for (    Connection c : conList) {\n      DTNHost otherNode=c.getOtherNode(node);\n      Coord c2;\n      if (otherNode == null) {\n        continue;\n      }\n      c2=otherNode.getLocation();\n      g2.drawLine(scale(c1.getX()),scale(c1.getY()),scale(c2.getX()),scale(c2.getY()));\n    }\n  }\n  g2.setColor(hostColor);\n  g2.drawRect(scale(loc.getX() - 1),scale(loc.getY() - 1),scale(2),scale(2));\n  if (isHighlighted()) {\n    g2.setColor(highlightedNodeColor);\n    g2.fillRect(scale(loc.getX()) - 3,scale(loc.getY()) - 3,6,6);\n  }\n  if (drawNodeName) {\n    g2.setColor(hostNameColor);\n    g2.drawString(node.toString(),scale(loc.getX()),scale(loc.getY()));\n  }\n}\n", "docstring": "visualize node \"'\" s location , radio ranges and connections", "partition": "test"}
{"idx": "2653", "code": "public boolean add(symbol sym) throws internal_error {\n  Object previous;\n  not_null(sym);\n  previous=_all.put(sym.name(),sym);\n  return previous == null;\n}\n", "docstring": "add a single symbol to the set .", "partition": "test"}
{"idx": "2654", "code": "public final int size(){\n  if (GWT.isScript()) {\n    return jsArray.size();\n  }\n else {\n    return javaArray.size();\n  }\n}\n", "docstring": "return the list size", "partition": "test"}
{"idx": "2655", "code": "public boolean intersects(final PlanetModel planetModel,final Plane q,final GeoPoint[] notablePoints,final GeoPoint[] moreNotablePoints,final Membership[] bounds,final Membership... moreBounds){\n  if (isNumericallyIdentical(q)) {\n    for (    GeoPoint p : notablePoints) {\n      if (meetsAllBounds(p,bounds,moreBounds)) {\n        return true;\n      }\n    }\n    for (    GeoPoint p : moreNotablePoints) {\n      if (meetsAllBounds(p,bounds,moreBounds)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  final double lineVectorX=y * q.z - z * q.y;\n  final double lineVectorY=z * q.x - x * q.z;\n  final double lineVectorZ=x * q.y - y * q.x;\n  if (Math.abs(lineVectorX) < MINIMUM_RESOLUTION && Math.abs(lineVectorY) < MINIMUM_RESOLUTION && Math.abs(lineVectorZ) < MINIMUM_RESOLUTION) {\n    return false;\n  }\n  double x0;\n  double y0;\n  double z0;\n  final double denomYZ=this.y * q.z - this.z * q.y;\n  final double denomXZ=this.x * q.z - this.z * q.x;\n  final double denomXY=this.x * q.y - this.y * q.x;\n  if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {\n    if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomYZ;\n    x0=0.0;\n    y0=(-this.D * q.z - this.z * -q.D) * denom;\n    z0=(this.y * -q.D + this.D * q.y) * denom;\n  }\n else   if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {\n    if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomXZ;\n    x0=(-this.D * q.z - this.z * -q.D) * denom;\n    y0=0.0;\n    z0=(this.x * -q.D + this.D * q.x) * denom;\n  }\n else {\n    if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    final double denom=1.0 / denomXY;\n    x0=(-this.D * q.y - this.y * -q.D) * denom;\n    y0=(this.x * -q.D + this.D * q.x) * denom;\n    z0=0.0;\n  }\n  final double A=lineVectorX * lineVectorX * planetModel.inverseAbSquared + lineVectorY * lineVectorY * planetModel.inverseAbSquared + lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n  final double B=2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n  final double C=x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n  final double BsquaredMinus=B * B - 4.0 * A * C;\n  if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n    final double inverse2A=1.0 / (2.0 * A);\n    final double t=-B * inverse2A;\n    final double pointX=lineVectorX * t + x0;\n    final double pointY=lineVectorY * t + y0;\n    final double pointZ=lineVectorZ * t + z0;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(pointX,pointY,pointZ)) {\n        return false;\n      }\n    }\n    for (    final Membership bound : moreBounds) {\n      if (!bound.isWithin(pointX,pointY,pointZ)) {\n        return false;\n      }\n    }\n    return true;\n  }\n else   if (BsquaredMinus > 0.0) {\n    final double inverse2A=1.0 / (2.0 * A);\n    final double sqrtTerm=Math.sqrt(BsquaredMinus);\n    final double t1=(-B + sqrtTerm) * inverse2A;\n    final double t2=(-B - sqrtTerm) * inverse2A;\n    final double point1X=lineVectorX * t1 + x0;\n    final double point1Y=lineVectorY * t1 + y0;\n    final double point1Z=lineVectorZ * t1 + z0;\n    boolean point1Valid=true;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(point1X,point1Y,point1Z)) {\n        point1Valid=false;\n        break;\n      }\n    }\n    if (point1Valid) {\n      for (      final Membership bound : moreBounds) {\n        if (!bound.isWithin(point1X,point1Y,point1Z)) {\n          point1Valid=false;\n          break;\n        }\n      }\n    }\n    if (point1Valid) {\n      return true;\n    }\n    final double point2X=lineVectorX * t2 + x0;\n    final double point2Y=lineVectorY * t2 + y0;\n    final double point2Z=lineVectorZ * t2 + z0;\n    for (    final Membership bound : bounds) {\n      if (!bound.isWithin(point2X,point2Y,point2Z)) {\n        return false;\n      }\n    }\n    for (    final Membership bound : moreBounds) {\n      if (!bound.isWithin(point2X,point2Y,point2Z)) {\n        return false;\n      }\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "determine whether the plane intersects another plane within the bounds provided .", "partition": "test"}
{"idx": "2656", "code": "public double SumOutlinkAuthorityScore(Page page){\n  List<String> outLinks=page.getOutlinks();\n  double authScore=0;\n  for (int i=0; i < outLinks.size(); i++) {\n    Page outLink=pTable.get(outLinks.get(i));\n    if (outLink != null) {\n      authScore+=outLink.authority;\n    }\n  }\n  return authScore;\n}\n", "docstring": "calculate the hub score of a page by summing the authority scores of that page \"'\" s outlinks .", "partition": "test"}
{"idx": "2657", "code": "public synchronized void end(){\n  graphicsToBeDrawn.close();\n  if (currentGraphics != null) {\n    graphicsDrawn.append(currentGraphics);\n  }\n  graphicsDrawn.closeWhenEmpty();\n  if (printerJobThread != null && printerJobThread.isAlive()) {\n    try {\n      printerJobThread.join();\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}\n", "docstring": "ends the print job and does any necessary cleanup .", "partition": "test"}
{"idx": "2658", "code": "public List<FileStatus> browse(String filePath) throws Exception {\n  LOG.info(\"HDFS File Path   :  \" + filePath + \"   and EndPoint  : \"+ hdfsEndPoint);\n  FileSystem hdfsFileSystem=null;\n  FileStatus[] listStatus;\n  try {\n    Configuration config=createConfig();\n    hdfsFileSystem=getFileSystem(config);\n    Path path=new Path(filePath);\n    listStatus=hdfsFileSystem.listStatus(path);\n  }\n catch (  Exception ex) {\n    LOG.error(\" Exception when browsing files for the path \" + filePath,ex.getMessage());\n    throw new Exception(\" Exception When browsing Files in HDFS .. Message :  \" + ex.getMessage());\n  }\n finally {\n    if (hdfsFileSystem != null)     hdfsFileSystem.close();\n  }\n  return Arrays.asList(listStatus);\n}\n", "docstring": "brows the files for the specific path", "partition": "test"}
{"idx": "2659", "code": "public EipModelWizardInitialObjectCreationPage(String pageId){\n  super(pageId);\n}\n", "docstring": "pass in the selection . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "2660", "code": "private void unwrapData() throws IgniteCheckedException, SSLException {\n  if (log.isDebugEnabled())   log.debug(\"Unwrapping received data.\");\n  inNetBuf.flip();\n  SSLEngineResult res=unwrap0();\n  inNetBuf.compact();\n  checkStatus(res);\n  renegotiateIfNeeded(res);\n}\n", "docstring": "unwraps user data to the application buffer .", "partition": "test"}
{"idx": "2661", "code": "private static void checkPermission() throws SecurityException {\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n  }\n}\n", "docstring": "checks whether the provider may be changed using permission \"'\" currenttime . setprovider \"'\" .", "partition": "test"}
{"idx": "2662", "code": "private void storePassword(String password){\n  if (isStore && sharedState != null) {\n    sharedState.put(getPwdKey(),password);\n  }\n}\n", "docstring": "stores password into shared state map . this method may be called after successful authentication by each individual module .", "partition": "test"}
{"idx": "2663", "code": "void deleteChild(PolicyNode childNode){\n  if (isImmutable) {\n    throw new IllegalStateException(\"PolicyNode is immutable\");\n  }\n  mChildren.remove(childNode);\n}\n", "docstring": "deletes the specified child node of this node , if it exists .", "partition": "test"}
{"idx": "2664", "code": "public ExternalProcessResult awaitTerminationAndResult(int timeoutMs,boolean destroyOnError) throws InterruptedException, TimeoutException, OperationCancellation, IOException {\n  awaitTermination(timeoutMs,destroyOnError);\n  return new ExternalProcessResult(process.exitValue(),getStdOutBytes(),getStdErrBytes());\n}\n", "docstring": "awaits for successful process termination , as well as successful termination of reader threads , throws an exception otherwise ( and destroys the process ) .", "partition": "test"}
{"idx": "2665", "code": "public void refreshInheritedMethods(Set modifiedSuperExpandos){\n  for (Iterator i=modifiedSuperExpandos.iterator(); i.hasNext(); ) {\n    ExpandoMetaClass superExpando=(ExpandoMetaClass)i.next();\n    if (superExpando != this) {\n      refreshInheritedMethods(superExpando);\n    }\n  }\n}\n", "docstring": "called from expandometaclasscreationhandle in the registry if it exists to set up inheritance handling", "partition": "test"}
{"idx": "2666", "code": "public static List<Fragment> parsePlaceholder(String parseString) throws PlaceholderParseException {\n  List<Fragment> result=new ArrayList<Fragment>();\n  int currOutputIndex=0;\n  int currSearchIndex=0;\n  while (true) {\n    if (currSearchIndex == parseString.length()) {\n      break;\n    }\n    int startIndex=parseString.indexOf(\"${\",currSearchIndex);\n    if (startIndex == -1) {\n      if (currOutputIndex < parseString.length()) {\n        String endString=parseString.substring(currOutputIndex,parseString.length());\n        TextFragment textFragment=new TextFragment(endString);\n        result.add(textFragment);\n      }\n      break;\n    }\n    if (startIndex > 0) {\n      String textSoFar=parseString.substring(currOutputIndex,startIndex);\n      if (textSoFar.length() != 0) {\n        result.add(new TextFragment(textSoFar));\n      }\n    }\n    if ((startIndex > 0) && (parseString.charAt(startIndex - 1) == \'$\')) {\n      currOutputIndex=startIndex + 1;\n      currSearchIndex=startIndex + 1;\n      continue;\n    }\n    int endIndex=parseString.indexOf(\'}\',startIndex);\n    if (endIndex == -1) {\n      throw new PlaceholderParseException(\"Syntax error in property or variable: \'\" + parseString.substring(startIndex,parseString.length()) + \"\'\");\n    }\n    String between=parseString.substring(startIndex + 2,endIndex);\n    ParameterFragment parameterFragment=new ParameterFragment(between);\n    result.add(parameterFragment);\n    currOutputIndex=endIndex + 1;\n    currSearchIndex=endIndex;\n  }\n  LinkedList<Fragment> fragments=new LinkedList<Fragment>();\n  fragments.add(result.get(0));\n  for (int i=1; i < result.size(); i++) {\n    Fragment fragment=result.get(i);\n    if (!(result.get(i) instanceof TextFragment)) {\n      fragments.add(fragment);\n      continue;\n    }\n    if (!(fragments.getLast() instanceof TextFragment)) {\n      fragments.add(fragment);\n      continue;\n    }\n    TextFragment textFragment=(TextFragment)fragments.getLast();\n    fragments.removeLast();\n    fragments.add(new TextFragment(textFragment.getValue() + fragment.getValue()));\n  }\n  return fragments;\n}\n", "docstring": "parses a string to find placeholders of format $ { placeholder } . < p > example : \" my $ { thing } is $ { color } \" < p > the example above parses into 4 fragements : a text fragment of value \" my \" , a parameter fragment \" thing \" , a text fragement \" is \" and a parameter fragment \" color \" .", "partition": "test"}
{"idx": "2667", "code": "@Override protected void failed(){\n  relation.setCanceled(true);\n  super.failed();\n}\n", "docstring": "marks the relation as canceled and invokes the the handler \"'\" s failed ( ) method .", "partition": "test"}
{"idx": "2668", "code": "private void routeSingleGetRequest(RequestAndResponse requestAndResponse,String uri) throws IOException, ServletException {\n  if (uri.startsWith(\"/notebooks/\")) {\n    handleHtmlShowNotebooks(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/quotations/\")) {\n    handleHtmlShowQuotations(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/sources/\")) {\n    handleHtmlShowSources(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/source/\")) {\n    handleHtmlShowSource(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/notebook/\")) {\n    handleHtmlShowNotebook(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/search/\")) {\n    handleHtmlSearch(requestAndResponse);\n  }\n else   if (uri.equals(\"/help/\")) {\n    handleHtmlBasicHelp(requestAndResponse);\n  }\n else   if (uri.equals(\"/advancedHelp/\")) {\n    handleHtmlAdvancedHelp(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/help/\")) {\n    handleHtmlHelp(requestAndResponse);\n  }\n else   if (uri.equals(\"/backup/\")) {\n    handleHtmlUserBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/restore/\")) {\n    handleHtmlUserRestoreForm(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/account/\")) {\n    handleHtmlShowAccount(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/accounts/\")) {\n    handleHtmlShowAccounts(requestAndResponse);\n  }\n else   if (uri.equals(\"/shutdown/\")) {\n    handleHtmlShutdownForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/clear/\")) {\n    handleHtmlClearForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/onlineBackup/\")) {\n    handleHtmlOnlineBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/checkForErrors/\")) {\n    handleHtmlCheckForErrorsForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/backups/\")) {\n    handleHtmlShowDBBackups(requestAndResponse);\n  }\n else   if (uri.equals(\"/offlineBackup/\")) {\n    handleHtmlOfflineDbBackupForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteJson/\")) {\n    handleJsonShowEntry(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteParentJson/\")) {\n    handleJsonShowEntryParent(requestAndResponse);\n  }\n else   if (uri.equals(\"/noteChildrenJson/\")) {\n    handleJsonShowEntryChildren(requestAndResponse);\n  }\n else   if (uri.equals(\"/searchNotesJson/\")) {\n    handleJsonSearchNotes(requestAndResponse);\n  }\n else   if (uri.equals(\"/newNotebook/\")) {\n    handleHtmlNewNotebookForm(requestAndResponse);\n  }\n else   if (uri.equals(\"/nothing/\")) {\n    handleHtmlNothing(requestAndResponse);\n  }\n else   if (uri.equals(\"/couldNotCreateNote/\")) {\n    handleHtmlCouldNotCreateNote(requestAndResponse);\n  }\n else   if (uri.equals(\"/restoreBackupCommand/\")) {\n    handleHtmlShowRestoreDbBackupCommand(requestAndResponse);\n  }\n else   if (uri.equals(\"/signedOut/\")) {\n    handleHtmlShowSignedOut(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/changePassword/\")) {\n    handleHtmlChangePassword(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/changeAccount/\")) {\n    handleHtmlChangeAccount(requestAndResponse);\n  }\n else   if (uri.startsWith(\"/closeAccount/\")) {\n    handleHtmlCloseAccount(requestAndResponse);\n  }\n else   if (uri.equals(\"/isSignedIn/\")) {\n    handleJsonIsSignedIn(requestAndResponse);\n  }\n else   if (uri.equals(\"/restoreFrame/\")) {\n    handleHtmlUserRestoreFrame(requestAndResponse);\n  }\n else {\n    returnHtml404(requestAndResponse);\n  }\n}\n", "docstring": "routes a single get request .", "partition": "test"}
{"idx": "2669", "code": "private void changeAnnotationDocumentState(SourceDocument aSourceDocument,User aUser,AnnotationDocumentStateTransition aAnnotationDocumentStateTransition){\n  AnnotationDocument annotationDocument=repository.getAnnotationDocument(aSourceDocument,aUser);\n  annotationDocument.setState(AnnotationDocumentStateTransition.transition(aAnnotationDocumentStateTransition));\n  try {\n    repository.createAnnotationDocument(annotationDocument);\n  }\n catch (  IOException e) {\n    LOG.info(\"Unable to get the LOG file\");\n  }\n}\n", "docstring": "change the state of an annotation document . used to re - open closed documents", "partition": "test"}
{"idx": "2670", "code": "boolean removeEdge(SparseEdge e){\n  boolean removedEdge=edges.remove(e);\n  boolean removedNeighbour=neighbours.remove(e.getOpposite(this));\n  if (removedEdge && removedNeighbour)   return true;\n else   if (!removedEdge && !removedNeighbour)   return false;\n else   throw new RuntimeException(\"Graph connectivity appears to be inconsitent!\");\n}\n", "docstring": "disconnects this vertex from an edge .", "partition": "test"}
{"idx": "2671", "code": "protected void longKeyPress(int keyCode){\n}\n", "docstring": "if this component is focused this method is invoked when the user presses and holds the key", "partition": "test"}
{"idx": "2672", "code": "public boolean hasDescendant(Pattern pattern){\n  Queue<BNode> nodesToProcess=new LinkedList<BNode>();\n  nodesToProcess.add(this);\n  while (!nodesToProcess.isEmpty()) {\n    BNode currentNode=nodesToProcess.poll();\n    for (    BNode descendantNode : currentNode.getOutputNodes()) {\n      Matcher matcher=pattern.matcher(descendantNode.getId());\n      if (matcher.matches()) {\n        return true;\n      }\n      if (!nodesToProcess.contains(descendantNode)) {\n        nodesToProcess.add(descendantNode);\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if at there exists at least one descendant whose identifier matches the regular expression pattern , and false otherwise", "partition": "test"}
{"idx": "2673", "code": "private static void generateFiles(){\n  String[] classNames;\n  ResourceBundle rules, info;\n  info=ResourceBundle.getBundle(\"sun.text.resources.BreakIteratorInfo\",new Locale(language,country,valiant),BreakIteratorRBControl.INSTANCE);\n  classNames=info.getStringArray(\"BreakIteratorClasses\");\n  rules=ResourceBundle.getBundle(\"sun.text.resources.BreakIteratorRules\",new Locale(language,country,valiant),BreakIteratorRBControl.INSTANCE);\n  if (info.containsKey(\"CharacterData\")) {\n    generateDataFile(info.getString(\"CharacterData\"),rules.getString(\"CharacterBreakRules\"),classNames[0]);\n  }\n  if (info.containsKey(\"WordData\")) {\n    generateDataFile(info.getString(\"WordData\"),rules.getString(\"WordBreakRules\"),classNames[1]);\n  }\n  if (info.containsKey(\"LineData\")) {\n    generateDataFile(info.getString(\"LineData\"),rules.getString(\"LineBreakRules\"),classNames[2]);\n  }\n  if (info.containsKey(\"SentenceData\")) {\n    generateDataFile(info.getString(\"SentenceData\"),rules.getString(\"SentenceBreakRules\"),classNames[3]);\n  }\n}\n", "docstring": "generate data files whose names are included in sun . text . resources . breakiteratorinfo + < localename >", "partition": "test"}
{"idx": "2674", "code": "public static boolean isCglibProxy(Object object){\n  return ClassUtils.isCglibProxyClass(object.getClass());\n}\n", "docstring": "check whether the given object is a cglib proxy .", "partition": "test"}
{"idx": "2675", "code": "public void testBug10630() throws Exception {\n  Connection conn2=null;\n  Statement stmt2=null;\n  try {\n    conn2=getConnectionWithProps((Properties)null);\n    stmt2=conn2.createStatement();\n    conn2.close();\n    stmt2.getWarnings();\n    fail(\"Should\'ve caught an exception here\");\n  }\n catch (  SQLException sqlEx) {\n    assertEquals(SQLError.SQL_STATE_ILLEGAL_ARGUMENT,sqlEx.getSQLState());\n  }\n finally {\n    if (stmt2 != null) {\n      stmt2.close();\n    }\n    if (conn2 != null) {\n      conn2.close();\n    }\n  }\n}\n", "docstring": "tests fix for bug # 10630 , statement . getwarnings ( ) fails with npe if statement has been closed .", "partition": "test"}
{"idx": "2676", "code": "public static boolean equals(boolean[] field1,boolean[] field2){\n  if (field1 == null || field1.length == 0) {\n    return field2 == null || field2.length == 0;\n  }\n else {\n    return Arrays.equals(field1,field2);\n  }\n}\n", "docstring": "checks repeated boolean field equality ; null - value and 0 - length fields are considered equal .", "partition": "test"}
{"idx": "2677", "code": "public void toFront(final WorkflowAnnotation anno){\n  if (anno == null) {\n    throw new IllegalArgumentException(\"anno must not be null!\");\n  }\nsynchronized (lock) {\n    if (annotationsDrawOrder.remove(anno)) {\n      annotationsDrawOrder.add(anno);\n    }\n    if (annotationsEventOrder.remove(anno)) {\n      annotationsEventOrder.add(0,anno);\n    }\n  }\n}\n", "docstring": "bring the given annotation to the front . that annotation will be drawn over all other annotations as well as recieve events first .", "partition": "test"}
{"idx": "2678", "code": "public synchronized void addFrame(final Image image,final long frameDuration){\n  totalDuration+=frameDuration;\n  frames.add(new AnimFrame(image,totalDuration));\n}\n", "docstring": "adds an image to the animation with the specified duration ( time to display the image ) .", "partition": "test"}
{"idx": "2679", "code": "public static String printCodePointAsString(int codePoint){\n  StringBuilder builder=new StringBuilder(12);\n  builder.append(\'\"\');\n  try {\n    printStringCodePoint(builder,codePoint);\n  }\n catch (  IOException e) {\n    throw new Error(e);\n  }\n  builder.append(\'\"\');\n  return builder.toString();\n}\n", "docstring": "builds a string denoting an ascii - encoded ion string , with double - quotes surrounding a single unicode code point .", "partition": "test"}
{"idx": "2680", "code": "private void cleanupMinidumpFile(){\n  if (!CrashFileManager.tryMarkAsUploaded(mFileToUpload)) {\n    Log.w(TAG,\"Unable to mark \" + mFileToUpload + \" as uploaded.\");\n    if (!mFileToUpload.delete()) {\n      Log.w(TAG,\"Cannot delete \" + mFileToUpload);\n    }\n  }\n}\n", "docstring": "mark file we just uploaded for cleanup later . we do not immediately delete the file for testing reasons , but if marking the file fails , we do delete it right away .", "partition": "test"}
{"idx": "2681", "code": "boolean closeOutbound() throws SSLException {\n  if (sslEngine == null || sslEngine.isOutboundDone()) {\n    return false;\n  }\n  sslEngine.closeOutbound();\n  createOutNetBuffer(0);\n  SSLEngineResult result;\n  for (; ; ) {\n    result=sslEngine.wrap(emptyBuffer.buf(),outNetBuffer.buf());\n    if (result.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n      outNetBuffer.capacity(outNetBuffer.capacity() << 1);\n      outNetBuffer.limit(outNetBuffer.capacity());\n    }\n else {\n      break;\n    }\n  }\n  if (result.getStatus() != SSLEngineResult.Status.CLOSED) {\n    throw new SSLException(\"Improper close state: \" + result);\n  }\n  outNetBuffer.flip();\n  return true;\n}\n", "docstring": "start ssl shutdown process .", "partition": "test"}
{"idx": "2682", "code": "@Nullable private static Bitmap extractThumbnail(Bitmap source,int width,int height){\n  return extractThumbnail(source,width,height,OPTIONS_NONE);\n}\n", "docstring": "creates a centered bitmap of the desired size .", "partition": "test"}
{"idx": "2683", "code": "private void writePkgInfo() throws BuildException {\n  File pkgInfo=new File(mContentsDir,\"PkgInfo\");\n  PrintWriter writer=null;\n  try {\n    writer=new PrintWriter(new BufferedWriter(new FileWriter(pkgInfo)));\n    writer.print(bundleProperties.getCFBundlePackageType());\n    writer.println(bundleProperties.getCFBundleSignature());\n    writer.flush();\n  }\n catch (  IOException ex) {\n    throw new BuildException(\"Cannot create PkgInfo file: \" + ex);\n  }\n finally {\n    mFileUtils.close(writer);\n  }\n}\n", "docstring": "write the pkginfo file into the application bundle", "partition": "test"}
{"idx": "2684", "code": "public EventBean[] toArray(){\n  if (firstEvent == null) {\n    return new EventBean[0];\n  }\n  if (additionalEvents == null) {\n    return new EventBean[]{firstEvent};\n  }\n  EventBean[] events=new EventBean[1 + additionalEvents.size()];\n  events[0]=firstEvent;\n  int count=1;\n  for (  EventBean theEvent : additionalEvents) {\n    events[count]=theEvent;\n    count++;\n  }\n  return events;\n}\n", "docstring": "returns an array holding the collected events .", "partition": "test"}
{"idx": "2685", "code": "private byte[] decode(DerInputStream in) throws IOException {\n  DerValue val=in.getDerValue();\n  byte[] derEncoding=val.toByteArray();\n  derEncoding[0]=DerValue.tag_SetOf;\n  DerInputStream derIn=new DerInputStream(derEncoding);\n  DerValue[] derVals=derIn.getSet(3,true);\n  PKCS9Attribute attrib;\n  ObjectIdentifier oid;\n  boolean reuseEncoding=true;\n  for (int i=0; i < derVals.length; i++) {\n    try {\n      attrib=new PKCS9Attribute(derVals[i]);\n    }\n catch (    ParsingException e) {\n      if (ignoreUnsupportedAttributes) {\n        reuseEncoding=false;\n        continue;\n      }\n else {\n        throw e;\n      }\n    }\n    oid=attrib.getOID();\n    if (attributes.get(oid) != null)     throw new IOException(\"Duplicate PKCS9 attribute: \" + oid);\n    if (permittedAttributes != null && !permittedAttributes.containsKey(oid))     throw new IOException(\"Attribute \" + oid + \" not permitted in this attribute set\");\n    attributes.put(oid,attrib);\n  }\n  return reuseEncoding ? derEncoding : generateDerEncoding();\n}\n", "docstring": "decode this set of pkcs9 attributes from the contents of its der encoding . ignores unsupported attributes when directed .", "partition": "test"}
{"idx": "2686", "code": "@Override public CategoricalResults clone(){\n  CategoricalResults copy=new CategoricalResults(n);\n  copy.probabilities=Arrays.copyOf(probabilities,probabilities.length);\n  return copy;\n}\n", "docstring": "creates a deep clone of this", "partition": "test"}
{"idx": "2687", "code": "private boolean typeSpecialChar(char c){\nswitch (c) {\ncase '\\t':\n    controller.keyPress(KeyEvent.VK_TAB);\n  controller.keyRelease(KeyEvent.VK_TAB);\nreturn true;\ncase '\\n':\ncontroller.keyPress(KeyEvent.VK_ENTER);\ncontroller.keyRelease(KeyEvent.VK_ENTER);\nreturn true;\ndefault :\nreturn false;\n}\n}\n", "docstring": "simulate keyboard to type out a special character . there are only several special characters supported .", "partition": "test"}
{"idx": "2688", "code": "protected static boolean eq(Object o1,Object o2){\n  return o1 == null ? o2 == null : o1.equals(o2);\n}\n", "docstring": "helper method to check for equality between two object , including null checks .", "partition": "test"}
{"idx": "2689", "code": "public Iterable<Notification> skip(@Nonnull final Iterable<Notification> notifications,final long startId,final boolean inclusive,final int limitSize){\n  Objects.requireNonNull(notifications);\n  final int position=indexOf(notifications,startId);\n  if (position == -1) {\n    return Iterables.limit(notifications,limitSize);\n  }\n  if (inclusive) {\n    return Iterables.limit(Iterables.skip(notifications,position),limitSize);\n  }\n  return Iterables.limit(Iterables.skip(notifications,position + 1),limitSize);\n}\n", "docstring": "returns an iterable that skips forward to a given notification id then only returns count more notifications . if the given notification id is not found", "partition": "test"}
{"idx": "2690", "code": "public boolean writeData(PdxWriter writer,Object obj){\n  if (isRelevant(obj.getClass())) {\n    writeData(writer,obj,getClassInfo(obj.getClass()));\n    return true;\n  }\n  return false;\n}\n", "docstring": "using the given pdxwriter , write out the relevant fields for the object instance passed in .", "partition": "test"}
{"idx": "2691", "code": "protected final void writeC(ByteBuffer buf,int value){\n  buf.put((byte)value);\n}\n", "docstring": "write byte to buffer .", "partition": "test"}
{"idx": "2692", "code": "public ViterbiPoint(Item item){\n  this.item=item;\n}\n", "docstring": "creates a viterbipoint for the given item . a typical item of choice is a segment item .", "partition": "test"}
{"idx": "2693", "code": "protected void paintContentBorderBottomEdge(Graphics g,int x,int y,int w,int h,boolean drawBroken,Rectangle selRect,boolean isContentBorderPainted){\n  if (isContentBorderPainted) {\n    g.setColor(darkShadow);\n    g.fillRect(x,y + h - 1,w - 1,1);\n  }\n}\n", "docstring": "draws the bottom edge of the border around the content area . draw broken line if selected tab is visible and adjacent to content and tabplacement is same as painted edge .", "partition": "test"}
{"idx": "2694", "code": "public RSAPublicKey parsePEMPublicKey(String pem) throws GeneralSecurityException {\n  try {\n    byte[] bs=decodeAsciiArmoredPEM(pem);\n    ByteBuffer data=ByteBuffer.wrap(bs);\n    final ASN1Object ob=asn1Parser.parseASN1(data);\n    final List<ASN1Object> seq=asn1ObjectToSequence(ob,2);\n    final BigInteger modulus=asn1ObjectToBigInt(seq.get(0));\n    final BigInteger exponent=asn1ObjectToBigInt(seq.get(1));\n    return createKeyFromModulusAndExponent(modulus,exponent);\n  }\n catch (  IllegalArgumentException e) {\n    throw new InvalidKeyException();\n  }\n}\n", "docstring": "parse a pkcs1 pem encoded rsa public key into the modulus / exponent components and construct a new rsapublickey", "partition": "test"}
{"idx": "2695", "code": "public static <T>ParallelPublisher<T> from(Publisher<? extends T> source,boolean ordered,int parallelism){\n  return from(source,ordered,parallelism,Px.bufferSize(),Px.defaultQueueSupplier(Px.bufferSize()));\n}\n", "docstring": "take a publisher and prepare to consume it on parallallism number of \"'\" rails \"'\" , possibly ordered and round - robin fashion .", "partition": "test"}
{"idx": "2696", "code": "public void addToQueue(Var var){\n  addToQueue(Collections.singleton(var));\n}\n", "docstring": "add a single var to the queue", "partition": "test"}
{"idx": "2697", "code": "public String canonicalize(String simpleURL){\n  String resultURL=simpleURL;\n  if (simpleURL.startsWith(\"ftp.\")) {\n    resultURL=\"ftp://\" + simpleURL;\n  }\n else   if (simpleURL.startsWith(\"gopher.\")) {\n    resultURL=\"gopher://\" + simpleURL;\n  }\n else   if (simpleURL.startsWith(\"/\")) {\n    resultURL=\"file:\" + simpleURL;\n  }\n else   if (!hasProtocolName(simpleURL)) {\n    if (isSimpleHostName(simpleURL)) {\n      simpleURL=\"www.\" + simpleURL + \".com\";\n    }\n    resultURL=\"http://\" + simpleURL;\n  }\n  return resultURL;\n}\n", "docstring": "given a possibly abbreviated url ( missing a protocol name , typically ) , this method \"'\" s job is to transform that url into a canonical form , by including a protocol name and additional syntax , if necessary . for a correctly formed url , this method should just return its argument .", "partition": "test"}
{"idx": "2698", "code": "@RequestProcessing(value=\"/member/{userName}/points\",method=HTTPRequestMethod.GET) @Before(adviceClass={StopwatchStartAdvice.class,AnonymousViewCheck.class,UserBlockCheck.class}) @After(adviceClass=StopwatchEndAdvice.class) public void showHomePoints(final HTTPRequestContext context,final HttpServletRequest request,final HttpServletResponse response,final String userName) throws Exception {\n  final JSONObject user=(JSONObject)request.getAttribute(User.USER);\n  request.setAttribute(Keys.TEMAPLTE_DIR_NAME,Symphonys.get(\"skinDirName\"));\n  final AbstractFreeMarkerRenderer renderer=new SkinRenderer();\n  context.setRenderer(renderer);\n  renderer.setTemplateName(\"/home/points.ftl\");\n  final Map<String,Object> dataModel=renderer.getDataModel();\n  filler.fillHeaderAndFooter(request,response,dataModel);\n  String pageNumStr=request.getParameter(\"p\");\n  if (Strings.isEmptyOrNull(pageNumStr) || !Strings.isNumeric(pageNumStr)) {\n    pageNumStr=\"1\";\n  }\n  final int pageNum=Integer.valueOf(pageNumStr);\n  final int pageSize=Symphonys.getInt(\"userHomePointsCnt\");\n  final int windowSize=Symphonys.getInt(\"userHomePointsWindowSize\");\n  fillHomeUser(dataModel,user);\n  avatarQueryService.fillUserAvatarURL(user);\n  final String followingId=user.optString(Keys.OBJECT_ID);\n  dataModel.put(Follow.FOLLOWING_ID,followingId);\n  final JSONObject userPointsResult=pointtransferQueryService.getUserPoints(user.optString(Keys.OBJECT_ID),pageNum,pageSize);\n  final List<JSONObject> userPoints=CollectionUtils.<JSONObject>jsonArrayToList(userPointsResult.optJSONArray(Keys.RESULTS));\n  dataModel.put(Common.USER_HOME_POINTS,userPoints);\n  final boolean isLoggedIn=(Boolean)dataModel.get(Common.IS_LOGGED_IN);\n  if (isLoggedIn) {\n    final JSONObject currentUser=(JSONObject)dataModel.get(Common.CURRENT_USER);\n    final String followerId=currentUser.optString(Keys.OBJECT_ID);\n    final boolean isFollowing=followQueryService.isFollowing(followerId,user.optString(Keys.OBJECT_ID));\n    dataModel.put(Common.IS_FOLLOWING,isFollowing);\n  }\n  user.put(UserExt.USER_T_CREATE_TIME,new Date(user.getLong(Keys.OBJECT_ID)));\n  final int pointsCnt=userPointsResult.optInt(Pagination.PAGINATION_RECORD_COUNT);\n  final int pageCount=(int)Math.ceil((double)pointsCnt / (double)pageSize);\n  final List<Integer> pageNums=Paginator.paginate(pageNum,pageSize,pageCount,windowSize);\n  if (!pageNums.isEmpty()) {\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM,pageNums.get(0));\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM,pageNums.get(pageNums.size() - 1));\n  }\n  dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM,pageNum);\n  dataModel.put(Pagination.PAGINATION_PAGE_COUNT,pageCount);\n  dataModel.put(Pagination.PAGINATION_PAGE_NUMS,pageNums);\n}\n", "docstring": "shows user home points page .", "partition": "test"}
{"idx": "2699", "code": "private static double norm(final double[] v){\n  double agg=0;\n  for (int i=0; i < v.length; i++) {\n    agg+=(v[i] * v[i]);\n  }\n  return Math.sqrt(agg);\n}\n", "docstring": "returns the norm l2 . sqrt ( sum_i ( v_i ^ 2 ) )", "partition": "test"}
{"idx": "2700", "code": "private int measureHeight(int measureSpec){\n  float result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=mPaintSelected.getStrokeWidth() + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return (int)((float)Math.ceil(result));\n}\n", "docstring": "determines the height of this view", "partition": "test"}
{"idx": "2701", "code": "public void layout(Container container){\n  Map<Location,Drawable> comps=getComponentsByLocation(container);\n  Drawable north=comps.get(Location.NORTH);\n  Drawable northEast=comps.get(Location.NORTH_EAST);\n  Drawable east=comps.get(Location.EAST);\n  Drawable southEast=comps.get(Location.SOUTH_EAST);\n  Drawable south=comps.get(Location.SOUTH);\n  Drawable southWest=comps.get(Location.SOUTH_WEST);\n  Drawable west=comps.get(Location.WEST);\n  Drawable northWest=comps.get(Location.NORTH_WEST);\n  Drawable center=comps.get(Location.CENTER);\n  double widthWest=getMaxWidth(northWest,west,southWest);\n  double widthEast=getMaxWidth(northEast,east,southEast);\n  double heightNorth=getMaxHeight(northWest,north,northEast);\n  double heightSouth=getMaxHeight(southWest,south,southEast);\n  double gapEast=(widthEast > 0.0) ? getGapX() : 0.0;\n  double gapWest=(widthWest > 0.0) ? getGapX() : 0.0;\n  double gapNorth=(heightNorth > 0.0) ? getGapY() : 0.0;\n  double gapSouth=(heightSouth > 0.0) ? getGapY() : 0.0;\n  Rectangle2D bounds=container.getBounds();\n  Insets2D insets=container.getInsets();\n  if (insets == null) {\n    insets=new Insets2D.Double();\n  }\n  double xWest=bounds.getMinX() + insets.getLeft() - gapWest - widthWest;\n  double xCenter=bounds.getMinX() + insets.getLeft();\n  double xEast=bounds.getMaxX() - insets.getRight() + gapEast;\n  double yNorth=bounds.getMinY() + insets.getTop() - gapNorth - heightNorth;\n  double yCenter=bounds.getMinY() + insets.getTop();\n  double ySouth=bounds.getMaxY() - insets.getBottom() + gapSouth;\n  layoutComponent(northWest,xWest,yNorth,widthWest,heightNorth);\n  layoutComponent(north,xCenter,yNorth,bounds.getWidth() - insets.getHorizontal(),heightNorth);\n  layoutComponent(northEast,xEast,yNorth,widthEast,heightNorth);\n  layoutComponent(east,xEast,yCenter,widthEast,bounds.getHeight() - insets.getVertical());\n  layoutComponent(southEast,xEast,ySouth,widthEast,heightSouth);\n  layoutComponent(south,xCenter,ySouth,bounds.getWidth() - insets.getHorizontal(),heightSouth);\n  layoutComponent(southWest,xWest,ySouth,widthWest,heightSouth);\n  layoutComponent(west,xWest,yCenter,widthWest,bounds.getHeight() - insets.getVertical());\n  layoutComponent(center,xCenter + getGapX(),yCenter + getGapY(),bounds.getWidth() - insets.getHorizontal() - 2 * getGapX(),bounds.getHeight() - insets.getVertical() - 2 * getGapY());\n}\n", "docstring": "arranges the components of the specified container according to this layout .", "partition": "test"}
{"idx": "2702", "code": "public void add(int i,int data){\n  if (_length + 1 > _capacity)   ensureCapacity(_length + 1);\n  System.arraycopy(_buffer,i,_buffer,i + 1,_length - i);\n  _buffer[i]=(byte)data;\n  _length+=1;\n}\n", "docstring": "inserts a byte array", "partition": "test"}
{"idx": "2703", "code": "private double mean(double[] vec){\n  double result=0;\n  for (int i=0; i < vec.length; i++)   result+=vec[i];\n  return result / vec.length;\n}\n", "docstring": "the mean of the values in the double array", "partition": "test"}
{"idx": "2704", "code": "private Sprite(float xPos,float yPos,float xVel,float yVel,Image... sprites){\n  if (sprites != null)   spriteFrame=new ImageView(sprites[0]);\n  playerStates.addAll(Arrays.asList(sprites));\n  spriteFrame.setTranslateX(xPos);\n  spriteFrame.setTranslateY(yPos);\n  this.xPos=xPos;\n  this.yPos=yPos;\n  this.xVel=xVel;\n  this.yVel=yVel;\n}\n", "docstring": "used internally to create common functions between motion and stationary sprite .", "partition": "test"}
{"idx": "2705", "code": "protected static SyncToken createSyncToken(String dateString,@Nullable String uuid){\n  try {\n    return new SyncToken(DB_DATE_FORMAT.parse(dateString),uuid);\n  }\n catch (  ParseException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "creates a sync token , and converts any thrown exceptions to runtimeexceptions so it can be used for static fields .", "partition": "test"}
{"idx": "2706", "code": "private static boolean equalsHandlesNulls(Object a,Object b){\n  return a == b || (a != null && a.equals(b));\n}\n", "docstring": "returns true if a and b are equal or are both null .", "partition": "test"}
{"idx": "2707", "code": "public void init(String flagzDirectory) throws FlagException, EtcdFlagFieldUpdaterException {\n  this.directoryPrefix=MoreObjects.firstNonNull(flagzDirectory,directoryFlag.get());\n  client=new EtcdClient(uris.toArray(new URI[uris.size()]));\n  client.setRetryHandler(retryPolicy);\n  initialSetAllFlagz();\n}\n", "docstring": "init performs the initial read of values from etcd .", "partition": "test"}
{"idx": "2708", "code": "public static void closeEL(InputStream is){\n  try {\n    if (is != null)     is.close();\n  }\n catch (  Throwable t) {\n  }\n}\n", "docstring": "close inputstream without a exception", "partition": "test"}
{"idx": "2709", "code": "public void testRandom(){\n  ExtremityMonitor monitor=new ExtremityMonitor();\n  Random random=new Random(42);\n  for (int i=0; i < 1000; i++) {\n    monitor.update(random.nextDouble());\n  }\n  assertTrue(monitor.getMin() < 0.1);\n  assertTrue(monitor.getMax() < 1.0);\n  assertTrue(monitor.getMin() >= 0.0);\n  assertTrue(monitor.getMax() > 0.9);\n}\n", "docstring": "throws a bunch of random numbers between [ 0 , 1 ", "partition": "test"}
{"idx": "2710", "code": "public static String replace(String str,char oldChar,String newStr){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < str.length(); i++) {\n    char ch=str.charAt(i);\n    if (ch == oldChar) {\n      buf.append(newStr);\n    }\n else {\n      buf.append(ch);\n    }\n  }\n  return buf.toString();\n}\n", "docstring": "returns a string with all occurrences of oldchar replaced by newstr", "partition": "test"}
{"idx": "2711", "code": "@Action(value=\"/receipts/challan-newform\") @ValidationErrorPage(value=ERROR) @SkipValidation public String newform(){\n  setLoginDept();\n  SimpleDateFormat sdf=new SimpleDateFormat(\"dd/MM/yyyy\");\n  try {\n    cutOffDate=sdf.parse(collectionsUtil.getAppConfigValue(CollectionConstants.MODULE_NAME_COLLECTIONS_CONFIG,CollectionConstants.APPCONFIG_VALUE_COLLECTIONDATAENTRYCUTOFFDATE));\n  }\n catch (  ParseException e) {\n    LOGGER.error(getText(\"Error parsing Cut Off Date\") + e.getMessage());\n  }\n  return NEW;\n}\n", "docstring": "this method is invoked when the user clicks on create challan from menu tree", "partition": "test"}
{"idx": "2712", "code": "public TypeDeclaration canonicalize(){\n  List<Type> sts=getSatisfiedTypes();\n  if (sts.isEmpty()) {\n    return unit.getAnythingDeclaration();\n  }\n else   if (sts.size() == 1) {\n    Type st=sts.get(0);\n    if (st.isExactlyNothing()) {\n      return unit.getNothingDeclaration();\n    }\n  }\n  for (  Type st : sts) {\n    if (st.isUnion()) {\n      List<Type> caseTypes=st.getCaseTypes();\n      List<Type> ulist=new ArrayList<Type>(caseTypes.size());\n      for (      Type ct : caseTypes) {\n        List<Type> ilist=new ArrayList<Type>(sts.size());\n        for (        Type pt : sts) {\n          if (pt == st) {\n            addToIntersection(ilist,ct,unit);\n          }\n else {\n            addToIntersection(ilist,pt,unit);\n          }\n        }\n        Type it=canonicalIntersection(ilist,unit);\n        addToUnion(ulist,it);\n      }\n      TypeDeclaration result=new UnionType(unit);\n      result.setCaseTypes(ulist);\n      return result;\n    }\n  }\n  return this;\n}\n", "docstring": "apply the distributive rule x & ( y | z ) = = x & y | x & z to simplify the intersection to a canonical form with no parens . the result is a union of intersections , instead of an intersection of unions .", "partition": "test"}
{"idx": "2713", "code": "public static void openOtherUri(final String url,final Activity activity){\n  Intent intent=new Intent(Intent.ACTION_VIEW,Uri.parse(url));\n  activity.startActivity(intent);\n}\n", "docstring": "start the application in browser to see the url or choose by other application to view this uri", "partition": "test"}
{"idx": "2714", "code": "public static boolean waitForAllActiveAndLiveReplicas(ZkStateReader zkStateReader,int timeoutInMs){\n  return waitForAllActiveAndLiveReplicas(zkStateReader,null,timeoutInMs);\n}\n", "docstring": "wait to see * all * cores live and active .", "partition": "test"}
{"idx": "2715", "code": "public boolean checkForRp(){\n  return NullColumnValueGetter.isNotNullValue(getRpCopyName());\n}\n", "docstring": "uses a field in the volume to determine if the volume is an rp volume . best to use a field that is set during placement / scheduling of the volume , during vipr ( cassandra ) volume creation .", "partition": "test"}
{"idx": "2716", "code": "public static List<String> splitPath(File file){\n  List<String> output=new ArrayList<>();\n  File current=file;\n  while (current != null) {\n    output.add(current.getName());\n    current=current.getParentFile();\n  }\n  Collections.reverse(output);\n  return output;\n}\n", "docstring": "split a file into a list of directories ending with the file name", "partition": "test"}
{"idx": "2717", "code": "private static StsdData parseStsd(ParsableByteArray stsd,int trackId,long durationUs,int rotationDegrees,String language,boolean isQuickTime){\n  stsd.setPosition(Atom.FULL_HEADER_SIZE);\n  int numberOfEntries=stsd.readInt();\n  StsdData out=new StsdData(numberOfEntries);\n  for (int i=0; i < numberOfEntries; i++) {\n    int childStartPosition=stsd.getPosition();\n    int childAtomSize=stsd.readInt();\n    Assertions.checkArgument(childAtomSize > 0,\"childAtomSize should be positive\");\n    int childAtomType=stsd.readInt();\n    if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3 || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1 || childAtomType == Atom.TYPE_s263 || childAtomType == Atom.TYPE_vp08 || childAtomType == Atom.TYPE_vp09) {\n      parseVideoSampleEntry(stsd,childAtomType,childStartPosition,childAtomSize,trackId,durationUs,rotationDegrees,out,i);\n    }\n else     if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3 || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt) {\n      parseAudioSampleEntry(stsd,childAtomType,childStartPosition,childAtomSize,trackId,durationUs,language,isQuickTime,out,i);\n    }\n else     if (childAtomType == Atom.TYPE_TTML) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_TTML,MediaFormat.NO_VALUE,durationUs,language);\n    }\n else     if (childAtomType == Atom.TYPE_tx3g) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_TX3G,MediaFormat.NO_VALUE,durationUs,language);\n    }\n else     if (childAtomType == Atom.TYPE_wvtt) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_MP4VTT,MediaFormat.NO_VALUE,durationUs,language);\n    }\n else     if (childAtomType == Atom.TYPE_stpp) {\n      out.mediaFormat=MediaFormat.createTextFormat(Integer.toString(trackId),MimeTypes.APPLICATION_TTML,MediaFormat.NO_VALUE,durationUs,language,0);\n    }\n    stsd.setPosition(childStartPosition + childAtomSize);\n  }\n  return out;\n}\n", "docstring": "parses a stsd atom ( defined in 14496 - 12 ) .", "partition": "test"}
{"idx": "2718", "code": "protected boolean isCompatible(Taxa taxa,List<Taxon> availableTaxa){\n  for (int i=0; i < taxa.getTaxonCount(); i++) {\n    Taxon taxon=taxa.getTaxon(i);\n    if (!availableTaxa.contains(taxon)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "returns true if taxa are all found in availabletaxa", "partition": "test"}
{"idx": "2719", "code": "protected int drawLabelText(Object nativeGraphics,int textDecoration,boolean rtl,boolean isTickerRunning,boolean endsWith3Points,Object nativeFont,int txtW,int textSpaceW,int shiftText,String text,int x,int y,int fontHeight){\n  if ((!isTickerRunning) || rtl) {\n    if (txtW > textSpaceW && textSpaceW > 0) {\n      if (rtl) {\n        if ((!isTickerRunning) && endsWith3Points) {\n          String points=\"...\";\n          int pointsW=stringWidth(nativeFont,points);\n          drawString(nativeGraphics,nativeFont,points,shiftText + x,y,textDecoration,fontHeight);\n          clipRect(nativeGraphics,pointsW + shiftText + x,y,textSpaceW - pointsW,fontHeight);\n        }\n        x=x - txtW + textSpaceW;\n      }\n else       if (endsWith3Points) {\n        String points=\"...\";\n        int index=1;\n        int widest=charWidth(nativeFont,\'W\');\n        int pointsW=stringWidth(nativeFont,points);\n        int textLen=text.length();\n        while (fastCharWidthCheck(text,index,textSpaceW - pointsW,widest,nativeFont) && index < textLen) {\n          index++;\n        }\n        text=text.substring(0,Math.min(textLen,Math.max(1,index - 1))) + points;\n        txtW=stringWidth(nativeFont,text);\n      }\n    }\n  }\n  drawString(nativeGraphics,nativeFont,text,shiftText + x,y,textDecoration,fontHeight);\n  return Math.min(txtW,textSpaceW);\n}\n", "docstring": "draws the text of a label", "partition": "test"}
{"idx": "2720", "code": "public boolean hasMapObjects(){\n  return mapObjects != null && !mapObjects.isEmpty();\n}\n", "docstring": "indicates whether this map layer has any map objects .", "partition": "test"}
{"idx": "2721", "code": "public void performActions() throws Throwable {\n  for (  Throwing.Runnable action : actions) {\n    action.run();\n  }\n}\n", "docstring": "runs the commands that have been queued up .", "partition": "test"}
{"idx": "2722", "code": "public java.util.Collection<ObjectReference> dumpThreadRoots(int width){\n  return Collections.emptyList();\n}\n", "docstring": "print the thread roots and return them for processing .", "partition": "test"}
{"idx": "2723", "code": "protected void addFieldNameTranslation(EmbeddableMapping embeddableMapping,String overrideName,DatabaseField overrideField,MappingAccessor aggregatesAccessor){\n  DatabaseMapping aggregatesMapping=aggregatesAccessor.getMapping();\n  DatabaseField aggregatesMappingField=aggregatesMapping.getField();\n  if (aggregatesAccessor.isId()) {\n    updatePrimaryKeyField(aggregatesAccessor,overrideField);\n  }\n  if (overrideName.contains(\".\")) {\n    embeddableMapping.addNestedFieldTranslation(overrideName,overrideField,aggregatesMappingField.getName());\n  }\n else {\n    embeddableMapping.addFieldTranslation(overrideField,aggregatesMappingField.getName());\n  }\n}\n", "docstring": "internal : process an attribute override for either an embedded object mapping , or an element collection mapping containing embeddable objects .", "partition": "test"}
{"idx": "2724", "code": "public Dimension minimumLayoutSize(Container target){\nsynchronized (target.getTreeLock()) {\n    Dimension dim=new Dimension(0,0);\n    if ((chart != null) && chart.isVisible()) {\n      Dimension d=chart.getMinimumSize();\n      dim.width=d.width;\n      dim.height=d.height;\n    }\n    if ((xLabel != null) && xLabel.isVisible()) {\n      Dimension d=xLabel.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    if ((yLabel != null) && yLabel.isVisible()) {\n      Dimension d=yLabel.getMinimumSize();\n      dim.width+=d.width + hgap;\n      dim.height=Math.max(d.height,dim.height);\n    }\n    if ((title != null) && title.isVisible()) {\n      Dimension d=title.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    Insets insets=target.getInsets();\n    dim.width+=insets.left + insets.right;\n    dim.height+=insets.top + insets.bottom;\n    return dim;\n  }\n}\n", "docstring": "returns the minimum dimensions needed to layout the components contained in the specified target container .", "partition": "test"}
{"idx": "2725", "code": "private void checkResourceChange(final Resource resource,final Group group,final Callback callback,final AtomicBoolean isChanged) throws Exception {\n  if (isChanged(resource,group.getName())) {\n    isChanged.compareAndSet(false,true);\n    callback.onResourceChanged(resource);\n    lifecycleCallback.onResourceChanged(resource);\n  }\n}\n", "docstring": "will check if a given resource was changed and will invoke the appropriate callback .", "partition": "test"}
{"idx": "2726", "code": "public javax2.sip.address.TelURL createTelURL(String uri) throws ParseException {\n  if (uri == null)   throw new NullPointerException(\"null url\");\n  String telUrl=\"tel:\" + uri;\n  try {\n    StringMsgParser smp=new StringMsgParser();\n    TelURLImpl timp=(TelURLImpl)smp.parseUrl(telUrl);\n    return (TelURL)timp;\n  }\n catch (  ParseException ex) {\n    throw new ParseException(ex.getMessage(),0);\n  }\n}\n", "docstring": "creates a telurl based on given uri string . the scheme or \"'\" + \"'\" should not be included in the phonenumber string argument .", "partition": "test"}
{"idx": "2727", "code": "public EvoSVMModel(ExampleSet exampleSet,List<SupportVector> supportVectors,Kernel kernel,double bias){\n  super(exampleSet,ExampleSetUtilities.SetsCompareOption.ALLOW_SUPERSET,ExampleSetUtilities.TypesCompareOption.ALLOW_SAME_PARENTS);\n  this.supportVectors=supportVectors;\n  if (supportVectors == null || supportVectors.size() == 0) {\n    throw new IllegalArgumentException(\"Null or empty support vector collection: not possible to predict values!\");\n  }\n  this.kernel=kernel;\n  this.bias=bias;\n  if (this.kernel instanceof DotKernel) {\n    this.weights=new double[getNumberOfAttributes()];\n    for (int i=0; i < getNumberOfSupportVectors(); i++) {\n      SupportVector sv=getSupportVector(i);\n      if (sv != null) {\n        double[] x=sv.getX();\n        double alpha=sv.getAlpha();\n        double y=sv.getY();\n        for (int j=0; j < weights.length; j++) {\n          weights[j]+=y * alpha * x[j];\n        }\n      }\n else {\n        this.weights=null;\n        break;\n      }\n    }\n  }\n}\n", "docstring": "creates a classification model .", "partition": "test"}
{"idx": "2728", "code": "private synchronized boolean _restart() throws ServletException {\n  if (singelton != null)   singelton.reset();\n  initEngine();\n  System.gc();\n  return true;\n}\n", "docstring": "restart the cfml engine", "partition": "test"}
{"idx": "2729", "code": "public Sorter(){\n  useDefaultVisual();\n  setLayout(new BorderLayout());\n  add(m_visual,BorderLayout.CENTER);\n  m_env=Environment.getSystemWide();\n  m_stopRequested=new AtomicBoolean(false);\n}\n", "docstring": "constructs a new sorter", "partition": "test"}
{"idx": "2730", "code": "public static double logpdf(double x,double mu,double shape){\n  if (!(x > 0) || x == Double.POSITIVE_INFINITY) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  final double v=(x - mu) / mu;\n  return v < Double.MAX_VALUE ? 0.5 * Math.log(shape / (MathUtil.TWOPI * x * x* x)) - shape * v * v / (2. * x) : Double.NEGATIVE_INFINITY;\n}\n", "docstring": "probability density function of the wald distribution .", "partition": "test"}
{"idx": "2731", "code": "public static Format generateFormat(String codec){\n  return (Format)SUPPORTED_CODECS.get(codec.toLowerCase());\n}\n", "docstring": "generate the format associated to the codec name", "partition": "test"}
{"idx": "2732", "code": "public OptionalInt maxByInt(IntUnaryOperator keyExtractor){\n  int[] result=collect(null,null,null);\n  return result[2] == 1 ? OptionalInt.of(result[0]) : OptionalInt.empty();\n}\n", "docstring": "returns the maximum element of this stream according to the provided key extractor function . < p > this is a terminal operation .", "partition": "test"}
{"idx": "2733", "code": "public T findByCommitCounter(final long commitCounter){\n  if (commitCounter < 0L)   throw new IllegalArgumentException();\n  final Lock lock=readLock();\n  lock.lock();\n  try {\n    @SuppressWarnings(\"unchecked\") final ITupleIterator<T> itr=rangeIterator(null,null,0,IRangeQuery.DEFAULT | IRangeQuery.REVERSE,null);\n    while (itr.hasNext()) {\n      final ITuple<T> t=itr.next();\n      final T r=t.getObject();\n      final IRootBlockView rb=r.getRootBlock();\n      if (rb.getCommitCounter() <= commitCounter) {\n        return r;\n      }\n    }\n    return null;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "find the oldest entry whose commit counter is lte the specified commit counter .", "partition": "test"}
{"idx": "2734", "code": "public static String traceExcetion(Throwable ex){\n  final Writer result=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(result);\n  ex.printStackTrace(printWriter);\n  String stacktrace=result.toString();\n  Log.e(TAG,\"ERROR ---> \" + stacktrace);\n  return stacktrace;\n}\n", "docstring": "write exception throw in log", "partition": "test"}
{"idx": "2735", "code": "public static Pair<String,String> split(String varName){\n  int splitIndex=varName.indexOf('.');\n  if (splitIndex < 0) {\n    return null;\n  }\n  String left=varName.substring(0,splitIndex);\n  String right=varName.substring(splitIndex + 1);\n  if (left == null || left.length() == 0 || right == null || right.length() == 0) {\n    return null;\n  }\n  return Pair.of(left,right);\n}\n", "docstring": "splits a qualified varname into two parts , a left and a right left will be the text before the first instance of \"'\" . \"'\" right will be everything else returns null if the varname could not be split for any reason", "partition": "test"}
{"idx": "2736", "code": "public void onChildThreadResumeEnd(){\n  _threadCount.getAndDecrement();\n  wake();\n}\n", "docstring": "end housekeeping for a child thread managed by the launcher \"'\" s housekeeping , but not spawned by the launcher itself , e . g . comet , websocket , keepalive .", "partition": "test"}
{"idx": "2737", "code": "public static void registerTransportMBean(String containerName){\n  MBeanServer mBeanServer=getMBeanServer(containerName);\n  if (mBeanServer == null)   return;\n  TransportProtocolMonitorMBean transportConnectionsInfoMBean=new TransportProtocolMonitor();\n  ObjectName objName=TransportConstants.createTransportMBeanObjectName(containerName);\n  if (!mBeanServer.isRegistered(objName)) {\n    try {\n      mBeanServer.registerMBean(transportConnectionsInfoMBean,objName);\n    }\n catch (    InstanceAlreadyExistsException e) {\n      if (_logger.isLoggable(Level.CONFIG)) {\n        _logger.config(alreadyRegistredTransportMBeanMessage + containerName + \">\");\n      }\n    }\ncatch (    NotCompliantMBeanException e) {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\ncatch (    MBeanRegistrationException e) {\n      if (_logger.isLoggable(Level.SEVERE)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(successfulTransportMBeanRegistrationMessage + containerName + \">\");\n    }\n  }\n else {\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(alreadyRegistredTransportMBeanMessage);\n    }\n  }\n}\n", "docstring": "create management bean for jspace container .", "partition": "test"}
{"idx": "2738", "code": "public static int update(String where,Object[] args,V sets,Class<? extends Bean> t){\n  Table mapping=(Table)t.getAnnotation(Table.class);\n  if (mapping == null) {\n    if (log.isErrorEnabled())     log.error(\"mapping missed in [\" + t + \"] declaretion\");\n    return -1;\n  }\n  if (!X.isEmpty(mapping.name())) {\n    return updateTable(mapping.name(),where,args,sets);\n  }\n  return -1;\n}\n", "docstring": "update the data using values", "partition": "test"}
{"idx": "2739", "code": "private void stopVideoFadingEdgesScreenTimer(){\n  if (null != mVideoFadingEdgesTimer) {\n    mVideoFadingEdgesTimer.cancel();\n    mVideoFadingEdgesTimer=null;\n    mVideoFadingEdgesTimerTask=null;\n  }\n}\n", "docstring": "stop the video fading timer .", "partition": "test"}
{"idx": "2740", "code": "public void removeListener(final TimeoutEventListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "deregisters a timeout event listener for timeout notification .", "partition": "test"}
{"idx": "2741", "code": "protected static void processGenericPropertiesCreatorProps(File propsFile){\n  try {\n    Properties expProps=new Properties();\n    BufferedInputStream bi=new BufferedInputStream(new FileInputStream(propsFile));\n    expProps.load(bi);\n    bi.close();\n    bi=null;\n    Properties GPCInputProps=GenericPropertiesCreator.getGlobalInputProperties();\n    Set<Object> keys=expProps.keySet();\n    Iterator<Object> keysI=keys.iterator();\n    while (keysI.hasNext()) {\n      String key=(String)keysI.next();\n      String existingVal=GPCInputProps.getProperty(key,\"\");\n      if (existingVal.length() > 0) {\n        String newVal=expProps.getProperty(key);\n        if (existingVal.indexOf(newVal) < 0) {\n          newVal=existingVal + \",\" + newVal;\n          GPCInputProps.put(key,newVal);\n        }\n      }\n else {\n        String newVal=expProps.getProperty(key);\n        GPCInputProps.put(key,newVal);\n      }\n    }\n  }\n catch (  Exception ex) {\n  }\n}\n", "docstring": "process a package \"'\" s genericpropertiescreator . props file", "partition": "test"}
{"idx": "2742", "code": "private synchronized void addTableLockObject(AbsoluteTableIdentifier absoluteTableIdentifier){\n  if (null == tableLockMap.get(absoluteTableIdentifier)) {\n    tableLockMap.put(absoluteTableIdentifier,new Object());\n  }\n}\n", "docstring": "method to add table level lock if lock is not present for the table", "partition": "test"}
{"idx": "2743", "code": "public static <T>void updateMappingToImmutableSet(Map<T,Set<AnnotationMirror>> map,T key,Set<AnnotationMirror> newQual){\n  Set<AnnotationMirror> result=AnnotationUtils.createAnnotationSet();\n  if (!map.containsKey(key)) {\n    result.addAll(newQual);\n  }\n else {\n    result.addAll(map.get(key));\n    result.addAll(newQual);\n  }\n  map.put(key,Collections.unmodifiableSet(result));\n}\n", "docstring": "see checkers . types . qualifierhierarchy # updatemappingtomutableset ( qualifierhierarchy , map , object , annotationmirror ) ( not linked because it is in an independent project .", "partition": "test"}
{"idx": "2744", "code": "public static void join(final AsyncInvocation<?> async,final long timeoutMilliseconds){\n  join(async.getThread(),timeoutMilliseconds);\n}\n", "docstring": "wait for a thread to join .", "partition": "test"}
{"idx": "2745", "code": "void define(MemberDefinition field,int slot,int from,int to){\n  if (from >= to) {\n    return;\n  }\n  for (int i=0; i < len; i++) {\n    if ((locals[i].field == field) && (locals[i].slot == slot) && (from <= locals[i].to)&& (to >= locals[i].from)) {\n      locals[i].from=Math.min(locals[i].from,from);\n      locals[i].to=Math.max(locals[i].to,to);\n      return;\n    }\n  }\n  if (len == locals.length) {\n    LocalVariable newlocals[]=new LocalVariable[len * 2];\n    System.arraycopy(locals,0,newlocals,0,len);\n    locals=newlocals;\n  }\n  locals[len++]=new LocalVariable(field,slot,from,to);\n}\n", "docstring": "define a new local variable . merge entries where possible .", "partition": "test"}
{"idx": "2746", "code": "protected Connection openConnection(boolean autocommit) throws SQLException {\n  Connection conn=dataSrc.getConnection();\n  conn.setAutoCommit(autocommit);\n  return conn;\n}\n", "docstring": "gets connection from a pool .", "partition": "test"}
{"idx": "2747", "code": "public void mousePressed(MouseEvent e){\n  int nclicks=SwingUtilities2.getAdjustedClickCount(getComponent(),e);\n  if (SwingUtilities.isLeftMouseButton(e)) {\n    if (e.isConsumed()) {\n      shouldHandleRelease=true;\n    }\n else {\n      shouldHandleRelease=false;\n      adjustCaretAndFocus(e);\n      if (nclicks == 2 && SwingUtilities2.canEventAccessSystemClipboard(e)) {\n        selectWord(e);\n      }\n    }\n  }\n}\n", "docstring": "if button 1 is pressed , this is implemented to request focus on the associated text component , and to set the caret position . if the shift key is held down , the caret will be moved , potentially resulting in a selection , otherwise the caret position will be set to the new location . if the component is not enabled , there will be no request for focus .", "partition": "test"}
{"idx": "2748", "code": "public Object apply(String source,int lineNo,int columnNo,Object funcBody,Vector paramNames,Vector arguments) throws BSFException {\n  Object object=eval(source,lineNo,columnNo,funcBody);\n  if (object instanceof Closure) {\n    Closure closure=(Closure)object;\n    return closure.call(arguments.toArray());\n  }\n  return object;\n}\n", "docstring": "allow an anonymous function to be declared and invoked", "partition": "test"}
{"idx": "2749", "code": "public Set keySet(){\n  return totalKeySet();\n}\n", "docstring": "returns the total key set of all scopes . this method violates the map contract by returning an unmodifiable set .", "partition": "test"}
{"idx": "2750", "code": "public void output(List list,Writer out) throws IOException {\n  printContentRange(out,list,0,list.size(),0,createNamespaceStack());\n  out.flush();\n}\n", "docstring": "this will handle printing out a list of nodes . this can be useful for printing the content of an element that contains html , like \" & lt ; description & gt ; jdom is & lt ; b & gt ; fun & gt ; ! & lt ; / description & gt ; \" .", "partition": "test"}
{"idx": "2751", "code": "public boolean consumeEncumbranceBudget(final Map<String,Object> detailsMap){\n  if (detailsMap == null)   throw new ValidationException(Arrays.asList(new ValidationError(\"required input is null\",\"required input is null\")));\n  detailsMap.put(Constants.CONSUMEORRELEASE,true);\n  final BigDecimal bd=getDetails(detailsMap);\n  return bd.intValue() == 1;\n}\n", "docstring": "this api is to check whether the planning budget is available or not . for the amount passed if there is sufficient budget available api will return true . else it will return false . at any point the budgetavailable will show the right picture of how much more we can plan for . < p > assumptions - 1 ) on load of the budget there will be budgetavailable amount loaded using the multiplier factor . 2 ) on load of supplementary budget budget available is recalculated and updated . < p > for the sake of audit we should be updating the budgetusage object with the reference object and the moduleid and amount for any budget consumed . this will be used for reporting as to which object consumed how much and when .", "partition": "test"}
{"idx": "2752", "code": "private int[] mod(int[] a,int[] f){\n  int df=computeDegree(f);\n  if (df == -1) {\n    throw new ArithmeticException(\"Division by zero\");\n  }\n  int[] result=new int[a.length];\n  int hc=headCoefficient(f);\n  hc=field.inverse(hc);\n  System.arraycopy(a,0,result,0,result.length);\n  while (df <= computeDegree(result)) {\n    int[] q;\n    int coeff=field.mult(headCoefficient(result),hc);\n    q=multWithMonomial(f,computeDegree(result) - df);\n    q=multWithElement(q,coeff);\n    result=add(q,result);\n  }\n  return result;\n}\n", "docstring": "reduce a polynomial modulo another polynomial .", "partition": "test"}
{"idx": "2753", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=enumToVector(super.listOptions());\n  result.addElement(new Option(\"\\tThe number of clusters (default \" + defaultNumClusters() + \")\",\"k\",1,\"-k <num>\"));\n  result.addElement(new Option(\"\\tSet pattern to grid (default is random).\\n\" + \"\\tThis flag cannot be used at the same time as flag I.\\n\" + \"\\tThe pattern is random, if neither flag G nor flag I is set.\",\"G\",0,\"-G\"));\n  result.addElement(new Option(\"\\tSet pattern to sine (default is random).\\n\" + \"\\tThis flag cannot be used at the same time as flag I.\\n\" + \"\\tThe pattern is random, if neither flag G nor flag I is set.\",\"I\",0,\"-I\"));\n  result.addElement(new Option(\"\\tThe range of number of instances per cluster (default \" + defaultMinInstNum() + \"..\"+ defaultMaxInstNum()+ \").\\n\"+ \"\\tLower number must be between 0 and 2500,\\n\"+ \"\\tupper number must be between 50 and 2500.\",\"N\",1,\"-N <num>..<num>\"));\n  result.addElement(new Option(\"\\tThe range of radius per cluster (default \" + defaultMinRadius() + \"..\"+ defaultMaxRadius()+ \").\\n\"+ \"\\tLower number must be between 0 and SQRT(2), \\n\"+ \"\\tupper number must be between SQRT(2) and SQRT(32).\",\"R\",1,\"-R <num>..<num>\"));\n  result.addElement(new Option(\"\\tThe distance multiplier (default \" + defaultDistMult() + \").\",\"M\",1,\"-M <num>\"));\n  result.addElement(new Option(\"\\tThe number of cycles (default \" + defaultNumCycles() + \").\",\"C\",1,\"-C <num>\"));\n  result.addElement(new Option(\"\\tFlag for input order is ORDERED. If flag is not set then \\n\" + \"\\tinput order is RANDOMIZED. RANDOMIZED is currently not \\n\" + \"\\timplemented, therefore is the input order always ORDERED.\",\"O\",0,\"-O\"));\n  result.addElement(new Option(\"\\tThe noise rate in percent (default \" + defaultNoiseRate() + \").\\n\"+ \"\\tCan be between 0% and 30%. (Remark: The original \\n\"+ \"\\talgorithm only allows noise up to 10%.)\",\"P\",1,\"-P <num>\"));\n  return result.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "2754", "code": "public static void appendHexJavaScriptRepresentation(StringBuilder sb,char c){\n  sb.append(\"\\\\u\");\n  String val=Integer.toHexString(c);\n  for (int j=val.length(); j < 4; j++) {\n    sb.append(\'0\');\n  }\n  sb.append(val);\n}\n", "docstring": "returns a javascript representation of the character in a hex escaped format . although this is a rather specific method , it is made public because it is also used by the jscompiler .", "partition": "test"}
{"idx": "2755", "code": "private void printBootstrapMap(){\n  LOG.info(\"Bootstrap map:\");\n  for (  Integer i : chainMap.keySet()) {\n    LOG.info(String.format(\"  %6d: %d\",i,chainMap.get(i)));\n  }\n}\n", "docstring": "just a small method to show how many times each activity chain index was sampled . thie method is only needed during the development phase .", "partition": "test"}
{"idx": "2756", "code": "public Vector<Option> enumToVector(Enumeration<Option> enu){\n  Vector<Option> options=new Vector<Option>();\n  options.addAll(Collections.list(enu));\n  return options;\n}\n", "docstring": "convenience method . turns the given enumeration of options into a vector .", "partition": "test"}
{"idx": "2757", "code": "private P filterLargeValueSets(FilterSpec fs,MetaDataObject rootMeta,F root,boolean forceEntityBased,JoinType defaultPredicateJoinType){\n  ArrayList<FilterSpec> specs=new ArrayList<>();\n  List<?> list=new ArrayList<>((Collection<?>)fs.getValue());\n  for (int i=0; i < list.size(); i+=ORACLE_PARAM_LIMIT) {\n    int nextOffset=i + Math.min(list.size() - i,ORACLE_PARAM_LIMIT);\n    List<?> batchList=list.subList(i,nextOffset);\n    specs.add(new FilterSpec(fs.getAttributePath(),fs.getOperator(),batchList));\n  }\n  FilterSpec orSpec=FilterSpec.or(specs);\n  return filterSpecListToPredicate(rootMeta,root,orSpec,forceEntityBased,defaultPredicateJoinType);\n}\n", "docstring": "split filters with two many value possibilities . for example , oracle cannot handle more than 1000 .", "partition": "test"}
{"idx": "2758", "code": "protected void addTags(E data,Builder builder){\n  PlatformIdent platformIdent=cachedDataService.getPlatformIdentForId(data.getPlatformIdent());\n  builder.tag(Series.TAG_AGENT_ID,String.valueOf(data.getPlatformIdent()));\n  if (null != platformIdent) {\n    builder.tag(Series.TAG_AGENT_NAME,platformIdent.getAgentName());\n  }\n}\n", "docstring": "adds needed tags related to the data to the builder . when overriding sub - classes should call super first .", "partition": "test"}
{"idx": "2759", "code": "public int compare(String s1,String s2){\n  final Matcher match1=MATCH_ID_PATTERN.matcher(s1);\n  final Matcher match2=MATCH_ID_PATTERN.matcher(s2);\n  final boolean match1matches=match1.matches();\n  final boolean match2matches=match2.matches();\n  if (match1matches ^ match2matches) {\n    return (match1matches) ? 1 : -1;\n  }\n else   if (match1matches && match2matches) {\n    int signature1=Integer.parseInt(match1.group(1));\n    int signature2=Integer.parseInt(match2.group(1));\n    int comparison=(signature1 < signature2) ? -1 : (signature1 > signature2) ? 1 : 0;\n    if (comparison == 0) {\n      int start1=Integer.parseInt(match1.group(2));\n      int start2=Integer.parseInt(match2.group(2));\n      comparison=(start1 < start2) ? -1 : (start1 > start2) ? 1 : 0;\n    }\n    if (comparison == 0) {\n      int end1=Integer.parseInt(match1.group(3));\n      int end2=Integer.parseInt(match2.group(3));\n      comparison=(end1 < end2) ? -1 : (end1 > end2) ? 1 : 0;\n    }\n    return comparison;\n  }\n else {\n    int seqLength1=s1.length(), n2=s2.length();\n    for (int i1=0, i2=0; i1 < seqLength1 && i2 < n2; i1++, i2++) {\n      char c1=s1.charAt(i1);\n      char c2=s2.charAt(i2);\n      if (c1 != c2) {\n        c1=Character.toUpperCase(c1);\n        c2=Character.toUpperCase(c2);\n        if (c1 != c2) {\n          c1=Character.toLowerCase(c1);\n          c2=Character.toLowerCase(c2);\n          if (c1 != c2) {\n            return c1 - c2;\n          }\n        }\n      }\n    }\n    return seqLength1 - n2;\n  }\n}\n", "docstring": "sorts on the following : < p / > 1 . the integer used to uniquely identify the signature 2 . earliest start position 3 . earliest stop position", "partition": "test"}
{"idx": "2760", "code": "private static int loadBuildNumber(Context context,PackageManager packageManager){\n  try {\n    ApplicationInfo appInfo=packageManager.getApplicationInfo(context.getPackageName(),PackageManager.GET_META_DATA);\n    Bundle metaData=appInfo.metaData;\n    if (metaData != null) {\n      return metaData.getInt(BUNDLE_BUILD_NUMBER,0);\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    L.e(\"Exception thrown when accessing the application info:\");\n    e.printStackTrace();\n  }\n  return 0;\n}\n", "docstring": "helper method to load the build number from the androidmanifest .", "partition": "test"}
{"idx": "2761", "code": "public static LeftRegularBipartiteGraphSegment buildRandomLeftRegularBipartiteGraph(int leftSize,int rightSize,int leftDegree,Random random){\n  LeftRegularBipartiteGraphSegment leftRegularBipartiteGraphSegment=new LeftRegularBipartiteGraphSegment(leftSize / 2,leftDegree,rightSize / 2,leftSize / 2,2.0,Integer.MAX_VALUE,new IdentityEdgeTypeMask(),new NullStatsReceiver());\n  LongSet addedIds=new LongOpenHashSet(leftDegree);\n  for (int i=0; i < leftSize; i++) {\n    addedIds.clear();\n    for (int j=0; j < leftDegree; j++) {\n      long idToAdd;\n      do {\n        idToAdd=random.nextInt(rightSize);\n      }\n while (addedIds.contains(idToAdd));\n      addedIds.add(idToAdd);\n      leftRegularBipartiteGraphSegment.addEdge(i,idToAdd,(byte)0);\n    }\n  }\n  return leftRegularBipartiteGraphSegment;\n}\n", "docstring": "build a random left - regular bipartite graph of given left and right sizes .", "partition": "test"}
{"idx": "2762", "code": "protected HttpURLConnection configureRequest(final HttpURLConnection request){\n  if (credentials != null)   request.setRequestProperty(HEADER_AUTHORIZATION,credentials);\n  request.setRequestProperty(HEADER_USER_AGENT,userAgent);\n  request.setRequestProperty(HEADER_ACCEPT,getHeaderAccept());\n  return request;\n}\n", "docstring": "configure request with standard headers", "partition": "test"}
{"idx": "2763", "code": "public static String convertToTitle(int n){\n  if (n <= 0)   return \"\";\n  StringBuilder title=new StringBuilder();\n  while (n > 0) {\n    n--;\n    int r=n % 26;\n    title.insert(0,(char)(\'A\' + r));\n    n=n / 26;\n  }\n  return title.toString();\n}\n", "docstring": "get the remainder in each loop it should be the last digit note that the map shall have 1 offset", "partition": "test"}
{"idx": "2764", "code": "static public void process(String input,String output,String packFileName){\n  process(new Settings(),input,output,packFileName);\n}\n", "docstring": "packs using defaults settings .", "partition": "test"}
{"idx": "2765", "code": "private ReplicatorRuntimeConf(String serviceName){\n  replicatorHomeDir=locateReplicatorHomeDir();\n  replicatorLogDir=locateReplicatorLogDir();\n  replicatorConfDir=locateReplicatorConfDir();\n  replicatorProperties=new File(locateReplicatorConfDir(),\"static-\" + serviceName + \".properties\");\n  if (!replicatorProperties.isFile() || !replicatorProperties.canRead()) {\n    throw new ServerRuntimeException(\"Replicator static properties does not exist or is invalid: \" + replicatorProperties);\n  }\n  replicatorDynamicProperties=new File(replicatorConfDir,\"dynamic-\" + serviceName + \".properties\");\n  replicatorDynamicRole=new File(replicatorConfDir,\"dynamic-\" + serviceName + \".role\");\n  this.clearDynamicProperties=Boolean.parseBoolean(System.getProperty(CLEAR_DYNAMIC_PROPERTIES));\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "2766", "code": "public static long[] asLongArray(final List<Long> l){\n  final long[] a=new long[l.size()];\n  for (int i=0; i < a.length; i++) {\n    a[i]=l.get(i);\n  }\n  return a;\n}\n", "docstring": "return list of boxed longs as a primitive array .", "partition": "test"}
{"idx": "2767", "code": "private void updateMenuState(){\n  m_appendAnd.setEnabled(m_criteriumNode.allowAppend(CAndCriterium.class));\n  m_appendOr.setEnabled(m_criteriumNode.allowAppend(COrCriterium.class));\n  m_appendNot.setEnabled(m_criteriumNode.allowAppend(CNotCriterium.class));\n  m_insertAnd.setEnabled(m_criteriumNode.allowInsert(CAndCriterium.class));\n  m_insertOr.setEnabled(m_criteriumNode.allowInsert(COrCriterium.class));\n  m_insertNot.setEnabled(m_criteriumNode.allowInsert(CNotCriterium.class));\n  m_conditionSubmenu.setEnabled(m_criteriumNode.allowAppend(CConditionCriterium.class));\n  m_remove.setEnabled(!m_criteriumNode.isRoot());\n  m_removeAll.setEnabled(m_criteriumNode.getChildCount() != 0);\n}\n", "docstring": "updates the state of the context menu depending on the state of the criterium tree .", "partition": "test"}
{"idx": "2768", "code": "public void testPutGetRemove() throws Exception {\n  initStore(2);\n  Set<Integer> exp;\n  try {\n    exp=runPutGetRemoveMultithreaded(10,10);\n  }\n  finally {\n    shutdownStore();\n  }\n  Map<Integer,String> map=delegate.getMap();\n  Collection<Integer> extra=new HashSet<>(map.keySet());\n  extra.removeAll(exp);\n  assertTrue(\"The underlying store contains extra keys: \" + extra,extra.isEmpty());\n  Collection<Integer> missing=new HashSet<>(exp);\n  missing.removeAll(map.keySet());\n  assertTrue(\"Missing keys in the underlying store: \" + missing,missing.isEmpty());\n  for (  Integer key : exp)   assertEquals(\"Invalid value for key \" + key,\"val\" + key,map.get(key));\n}\n", "docstring": "this test performs complex set of operations on store from multiple threads .", "partition": "test"}
{"idx": "2769", "code": "public static String formatListToString(List<String> list){\n  String result=\"\";\n  for (  String s : list)   result+=s + \"\\t\\t\";\n  result=result.trim();\n  return result.toUpperCase();\n}\n", "docstring": "formats the list objects from the pokemodel into formatted strings that are easily readable .", "partition": "test"}
{"idx": "2770", "code": "@Override public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {\n  if (SNMP_ADAPTOR_LOGGER.isLoggable(Level.FINEST)) {\n    SNMP_ADAPTOR_LOGGER.logp(Level.FINEST,dbgTag,\"removeNotificationListener\",\"Removing listener \" + listener);\n  }\n  notifBroadcaster.removeNotificationListener(listener);\n}\n", "docstring": "removes the specified listener from this communicatorserver . note that if the listener has been registered with different handback objects or notification filters , all entries corresponding to the listener will be removed .", "partition": "test"}
{"idx": "2771", "code": "public static boolean isNewer(long ts1,long size1,long ts2,long size2){\n  return ts1 > ts2 || (ts1 == ts2 && size1 < size2);\n}\n", "docstring": "determines if a file is newer than another by comparing the timestamps and sizes . this heuristic is consisten with the behavior of rotating log files : at the instant the file is rotated there will likely exist two files with the same timestamp ; in that case , knowing nothing else about the files , the old file is almost certainly the one which has more data , since the newer file has just been created ( or truncated ) and would not have enough data yet . todo : the edge case where the new file fills so quickly ( within 1 second ) to become as large as the old file will escape this heuristic . this is * exceedingly rare * to happen in reality however , and will soon rectify itself ( within 1 second ) since the timestamp of the file that \"'\" s being written to will change , and the sizes won \"'\" t matter anymore .", "partition": "test"}
{"idx": "2772", "code": "private static void d_ucumm(double[] a,double[] agg,double[] c,int m,int n,int rl,int ru){\n  double[] cprods=(agg != null) ? agg : new double[n];\n  if (agg == null)   Arrays.fill(cprods,1);\n  for (int i=rl, aix=rl * n; i < ru; i++, aix+=n) {\n    productAgg(a,cprods,aix,0,n);\n    System.arraycopy(cprods,0,c,aix,n);\n  }\n}\n", "docstring": "cumprod , opcode : ucum * , dense input .", "partition": "test"}
{"idx": "2773", "code": "public static List<ModuleSpec> expandSpecWildcards(File dir,List<ModuleSpec> modules,Backend forBackend){\n  List<File> dirs=new ArrayList<File>();\n  dirs.add(dir);\n  return expandSpecWildcards(dirs,modules,forBackend);\n}\n", "docstring": "given a source directory and a list of modulespecs that possibly contain wildcards it returns a expanded list of modulespecs of modules that were actually found in the given source directory . modulespecs that didn \"'\" t contain wildcards are left alone ( it \"'\" s not checked if they exist or not ) . if a backend is passed expanded modules will be checked if they support it ( they either don \"'\" t have a native annotation or it is for the correct backend ) .", "partition": "test"}
{"idx": "2774", "code": "private void $$$setupUI$$$(){\n  myContentPanel=new JPanel();\n  myContentPanel.setLayout(new GridLayoutManager(6,1,new Insets(0,0,0,0),-1,-1));\n  myYoursRadioButton=new JRadioButton();\n  myYoursRadioButton.setSelected(true);\n  myYoursRadioButton.setText(\"Keep local\");\n  myYoursRadioButton.setMnemonic(\'K\');\n  myYoursRadioButton.setDisplayedMnemonicIndex(0);\n  myContentPanel.add(myYoursRadioButton,new GridConstraints(0,0,1,1,GridConstraints.ANCHOR_WEST,GridConstraints.FILL_NONE,GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,GridConstraints.SIZEPOLICY_FIXED,null,null,null,0,false));\n  myTheirsRadioButton=new JRadioButton();\n  myTheirsRadioButton.setText(\"Accept server\");\n  myTheirsRadioButton.setMnemonic(\'A\');\n  myTheirsRadioButton.setDisplayedMnemonicIndex(0);\n  myContentPanel.add(myTheirsRadioButton,new GridConstraints(1,0,1,1,GridConstraints.ANCHOR_WEST,GridConstraints.FILL_NONE,GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,GridConstraints.SIZEPOLICY_FIXED,null,null,null,0,false));\n  myUseCustomRadioButton=new JRadioButton();\n  myUseCustomRadioButton.setText(\"Use specified:\");\n  myUseCustomRadioButton.setMnemonic(\'U\');\n  myUseCustomRadioButton.setDisplayedMnemonicIndex(0);\n  myContentPanel.add(myUseCustomRadioButton,new GridConstraints(2,0,1,1,GridConstraints.ANCHOR_WEST,GridConstraints.FILL_NONE,GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,GridConstraints.SIZEPOLICY_FIXED,null,null,null,0,false));\n  myCustomPathTextField=new JTextField();\n  myCustomPathTextField.setEnabled(false);\n  myContentPanel.add(myCustomPathTextField,new GridConstraints(3,0,1,1,GridConstraints.ANCHOR_WEST,GridConstraints.FILL_BOTH,GridConstraints.SIZEPOLICY_WANT_GROW,GridConstraints.SIZEPOLICY_FIXED,null,new Dimension(100,-1),null,2,false));\n  final Spacer spacer1=new Spacer();\n  myContentPanel.add(spacer1,new GridConstraints(5,0,1,1,GridConstraints.ANCHOR_CENTER,GridConstraints.FILL_VERTICAL,1,GridConstraints.SIZEPOLICY_WANT_GROW,null,null,null,0,false));\n  myErrorLabel=new JLabel();\n  myErrorLabel.setForeground(new Color(-65536));\n  myErrorLabel.setText(\"\");\n  myContentPanel.add(myErrorLabel,new GridConstraints(4,0,1,1,GridConstraints.ANCHOR_WEST,GridConstraints.FILL_NONE,GridConstraints.SIZEPOLICY_CAN_GROW,GridConstraints.SIZEPOLICY_FIXED,null,null,null,0,false));\n  ButtonGroup buttonGroup;\n  buttonGroup=new ButtonGroup();\n  buttonGroup.add(myYoursRadioButton);\n  buttonGroup.add(myTheirsRadioButton);\n  buttonGroup.add(myUseCustomRadioButton);\n}\n", "docstring": "method generated by intellij idea gui designer > > > important ! ! < < < do not edit this method or call it in your code !", "partition": "test"}
{"idx": "2775", "code": "private static String reportListContents(Collection<ProcessErrorStateInfo> errList){\n  if (errList == null)   return null;\n  StringBuilder builder=new StringBuilder();\n  Iterator<ProcessErrorStateInfo> iter=errList.iterator();\n  while (iter.hasNext()) {\n    ProcessErrorStateInfo entry=iter.next();\n    String condition;\nswitch (entry.condition) {\ncase ActivityManager.ProcessErrorStateInfo.CRASHED:\n      condition=\"a CRASH\";\n    break;\ncase ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING:\n  condition=\"an ANR\";\nbreak;\ndefault :\ncondition=\"an unknown error\";\nbreak;\n}\nbuilder.append(String.format(\"Process %s encountered %s (%s)\",entry.processName,condition,entry.shortMsg));\nif (entry.condition == ActivityManager.ProcessErrorStateInfo.CRASHED) {\nbuilder.append(String.format(\" with stack trace:\\n%s\\n\",entry.stackTrace));\n}\nbuilder.append(\"\\n\");\n}\nreturn builder.toString();\n}\n", "docstring": "this helper function will dump the actual error reports .", "partition": "test"}
{"idx": "2776", "code": "public void parseArguments(final String[] rawArguments,Properties argumentProperties) throws ArgumentException {\n  boolean inTrailingArgs=false;\n  final int numArguments=rawArguments.length;\n  for (int i=0; i < numArguments; i++) {\n    final String arg=rawArguments[i];\n    if (inTrailingArgs) {\n      trailingArguments.add(arg);\n      if (maxTrailingArguments > 0 && trailingArguments.size() > maxTrailingArguments) {\n        final LocalizableMessage message=ERR_ARGPARSER_TOO_MANY_TRAILING_ARGS.get(maxTrailingArguments);\n        throw new ArgumentException(message);\n      }\n      continue;\n    }\n    if (arg.equals(\"--\")) {\n      inTrailingArgs=true;\n    }\n else     if (arg.startsWith(\"--\")) {\n      String argName=arg.substring(2);\n      String argValue=null;\n      final int equalPos=argName.indexOf(\'=\');\n      if (equalPos == 0) {\n        throw new ArgumentException(ERR_ARGPARSER_LONG_ARG_WITHOUT_NAME.get(arg));\n      }\n else       if (equalPos > 0) {\n        argValue=argName.substring(equalPos + 1);\n        argName=argName.substring(0,equalPos);\n      }\n      final String origArgName=argName;\n      argName=formatLongIdentifier(argName);\n      final Argument a=longIDMap.get(argName);\n      if (a == null) {\n        if (OPTION_LONG_HELP.equals(argName)) {\n          writeToUsageOutputStream(getUsage());\n          return;\n        }\n else         if (OPTION_LONG_PRODUCT_VERSION.equals(argName)) {\n          printVersion();\n          return;\n        }\n else {\n          throw new ArgumentException(ERR_ARGPARSER_NO_ARGUMENT_WITH_LONG_ID.get(origArgName));\n        }\n      }\n else {\n        a.setPresent(true);\n        if (isUsageArgument(a)) {\n          writeToUsageOutputStream(getUsage());\n          return;\n        }\n      }\n      if (a.needsValue()) {\n        if (argValue == null) {\n          if ((i + 1) == numArguments) {\n            throw new ArgumentException(ERR_ARGPARSER_NO_VALUE_FOR_ARGUMENT_WITH_LONG_ID.get(origArgName));\n          }\n          argValue=rawArguments[++i];\n        }\n        final LocalizableMessageBuilder invalidReason=new LocalizableMessageBuilder();\n        if (!a.valueIsAcceptable(argValue,invalidReason)) {\n          throw new ArgumentException(ERR_ARGPARSER_VALUE_UNACCEPTABLE_FOR_LONG_ID.get(argValue,origArgName,invalidReason));\n        }\n        if (a.hasValue() && !a.isMultiValued()) {\n          throw new ArgumentException(ERR_ARGPARSER_NOT_MULTIVALUED_FOR_LONG_ID.get(origArgName));\n        }\n        a.addValue(argValue);\n      }\n else       if (argValue != null) {\n        throw new ArgumentException(ERR_ARGPARSER_ARG_FOR_LONG_ID_DOESNT_TAKE_VALUE.get(origArgName));\n      }\n    }\n else     if (arg.startsWith(\"-\")) {\n      if (arg.equals(\"-\")) {\n        throw new ArgumentException(ERR_ARGPARSER_INVALID_DASH_AS_ARGUMENT.get());\n      }\n      final char argCharacter=arg.charAt(1);\n      String argValue;\n      if (arg.length() > 2) {\n        argValue=arg.substring(2);\n      }\n else {\n        argValue=null;\n      }\n      final Argument a=shortIDMap.get(argCharacter);\n      if (a == null) {\n        if (argCharacter == \'?\') {\n          writeToUsageOutputStream(getUsage());\n          return;\n        }\n else         if (versionHandler != null && argCharacter == OPTION_SHORT_PRODUCT_VERSION && !shortIDMap.containsKey(OPTION_SHORT_PRODUCT_VERSION)) {\n          printVersion();\n          return;\n        }\n else {\n          throw new ArgumentException(ERR_ARGPARSER_NO_ARGUMENT_WITH_SHORT_ID.get(argCharacter));\n        }\n      }\n else {\n        a.setPresent(true);\n        if (isUsageArgument(a)) {\n          writeToUsageOutputStream(getUsage());\n          return;\n        }\n      }\n      if (a.needsValue()) {\n        if (argValue == null) {\n          if ((i + 1) == numArguments) {\n            throw new ArgumentException(ERR_ARGPARSER_NO_VALUE_FOR_ARGUMENT_WITH_SHORT_ID.get(argCharacter));\n          }\n          argValue=rawArguments[++i];\n        }\n        final LocalizableMessageBuilder invalidReason=new LocalizableMessageBuilder();\n        if (!a.valueIsAcceptable(argValue,invalidReason)) {\n          throw new ArgumentException(ERR_ARGPARSER_VALUE_UNACCEPTABLE_FOR_SHORT_ID.get(argValue,argCharacter,invalidReason));\n        }\n        if (a.hasValue() && !a.isMultiValued()) {\n          throw new ArgumentException(ERR_ARGPARSER_NOT_MULTIVALUED_FOR_SHORT_ID.get(argCharacter));\n        }\n        a.addValue(argValue);\n      }\n else       if (argValue != null) {\n        final int valueLength=argValue.length();\n        for (int j=0; j < valueLength; j++) {\n          final char c=argValue.charAt(j);\n          final Argument b=shortIDMap.get(c);\n          if (b == null) {\n            throw new ArgumentException(ERR_ARGPARSER_NO_ARGUMENT_WITH_SHORT_ID.get(argCharacter));\n          }\n else           if (b.needsValue()) {\n            throw new ArgumentException(ERR_ARGPARSER_CANT_MIX_ARGS_WITH_VALUES.get(argCharacter,argValue,c));\n          }\n else {\n            b.setPresent(true);\n            if (isUsageArgument(b)) {\n              writeToUsageOutputStream(getUsage());\n              return;\n            }\n          }\n        }\n      }\n    }\n else     if (allowsTrailingArguments) {\n      inTrailingArgs=true;\n      trailingArguments.add(arg);\n    }\n else {\n      throw new ArgumentException(ERR_ARGPARSER_DISALLOWED_TRAILING_ARGUMENT.get(arg));\n    }\n  }\n  if (allowsTrailingArguments && minTrailingArguments > 0 && trailingArguments.size() < minTrailingArguments) {\n    throw new ArgumentException(ERR_ARGPARSER_TOO_FEW_TRAILING_ARGUMENTS.get(minTrailingArguments));\n  }\n  if (argumentProperties == null) {\n    argumentProperties=checkExternalProperties();\n  }\n  normalizeArguments(argumentProperties,argumentList);\n}\n", "docstring": "parses the provided set of arguments and updates the information associated with this parser accordingly . default values for unspecified arguments may be read from the specified properties if any are provided .", "partition": "test"}
{"idx": "2777", "code": "@Override public boolean start() throws IOException {\n  LOG.info(\"Starting reader using {}\",initialCheckpointGenerator);\n  try {\n    KinesisReaderCheckpoint initialCheckpoint=initialCheckpointGenerator.generate(kinesis);\n    List<ShardRecordsIterator> iterators=newArrayList();\n    for (    ShardCheckpoint checkpoint : initialCheckpoint) {\n      iterators.add(checkpoint.getShardRecordsIterator(kinesis));\n    }\n    shardIterators=new RoundRobin<>(iterators);\n  }\n catch (  TransientKinesisException e) {\n    throw new IOException(e);\n  }\n  return advance();\n}\n", "docstring": "generates initial checkpoint and instantiates iterators for shards .", "partition": "test"}
{"idx": "2778", "code": "@Override public XADataSource createXADataSource(Properties properties) throws SQLException {\n  Properties propertiesCopy=new Properties();\n  if (properties != null) {\n    propertiesCopy.putAll(properties);\n  }\n  rejectUnsupportedOptions(propertiesCopy);\n  rejectPoolingOptions(propertiesCopy);\n  JdbcDataSource dataSource=new JdbcDataSource();\n  setupH2DataSource(dataSource,propertiesCopy);\n  return dataSource;\n}\n", "docstring": "creates a pooled xa data source .", "partition": "test"}
{"idx": "2779", "code": "public static double toDegrees(double x){\n  if (Double.isInfinite(x) || x == 0.0) {\n    return x;\n  }\n  final double facta=57.2957763671875;\n  final double factb=3.145894820876798E-6;\n  double xa=doubleHighPart(x);\n  double xb=x - xa;\n  return xb * factb + xb * facta + xa * factb + xa * facta;\n}\n", "docstring": "convert radians to degrees , with error of less than 0 . 5 ulp", "partition": "test"}
{"idx": "2780", "code": "void initDemandAndCollectionMap(final List<String> prepareFieldNames,final Map<String,BigDecimal> demand,final Map<String,BigDecimal> collection,final Map<String,BigDecimal> rebates){\n  if (prepareFieldNames != null && !prepareFieldNames.isEmpty())   for (  final String fieldName : prepareFieldNames) {\n    demand.put(fieldName,BigDecimal.ZERO);\n    collection.put(fieldName,BigDecimal.ZERO);\n    rebates.put(fieldName,BigDecimal.ZERO);\n  }\n}\n", "docstring": "method called internally to prepare the map with fieldnames dynamically ( i . e field names can be verified depending upon the client )", "partition": "test"}
{"idx": "2781", "code": "protected Instance specifier(int i){\n  return m_Specifiers.get(i);\n}\n", "docstring": "get the template at the given position .", "partition": "test"}
{"idx": "2782", "code": "public ShapedCraftingRecipe(Item nominalOutput,RecipeFunction recipeFunction,String format,boolean mirrored,ItemIngredient... ingredients){\n  this.nominalOutput=nominalOutput;\n  String[] formatLines=format.split(\"\\\\-\");\n  int numIngredients=0;\n  int width=0;\n  for (  String formatLine : formatLines) {\n    width=Math.max(width,formatLine.length());\n    for (    char c : formatLine.toCharArray()) {\n      if (c == \' \') {\n        continue;\n      }\n else       if (c >= \'A\' && c <= \'Z\') {\n        numIngredients++;\n      }\n else {\n        throw new IllegalArgumentException(\"Invalid character in format string \" + format + \": \"+ c);\n      }\n    }\n  }\n  this.width=width;\n  this.height=formatLines.length;\n  this.posx=new int[numIngredients];\n  this.posy=new int[numIngredients];\n  this.ingredients=new ItemIngredient[numIngredients];\n  this.mirrored=mirrored;\n  int ingredientIndex=0;\n  for (int y=0; y < this.height; y++) {\n    String formatLine=formatLines[y];\n    for (int x=0; x < formatLine.length(); x++) {\n      char c=formatLine.charAt(x);\n      if (c == \' \') {\n        continue;\n      }\n      this.posx[ingredientIndex]=x;\n      this.posy[ingredientIndex]=y;\n      this.ingredients[ingredientIndex]=ingredients[c - \'A\'];\n      ingredientIndex++;\n    }\n  }\n  this.recipeFunction=recipeFunction;\n  this.lastIngredientIndexOnFirstLine=getLastIngredientIndexOnFirstLine();\n}\n", "docstring": "defines an advanced crafting recipe , using a format string .", "partition": "test"}
{"idx": "2783", "code": "public void writeTag(String tag,Font value){\n  startTag(tag);\n  writeTag(\"name\",value.getName());\n  int style=value.getStyle();\n  if ((style & Font.BOLD) != 0 && (style & Font.ITALIC) != 0) {\n    writeTag(STYLE,\"BOLDITALIC\");\n  }\n else   if ((style & Font.BOLD) != 0) {\n    writeTag(STYLE,\"BOLD\");\n  }\n else   if ((style & Font.ITALIC) != 0) {\n    writeTag(STYLE,\"ITALIC\");\n  }\n else {\n    writeTag(STYLE,\"PLAIN\");\n  }\n  writeTag(\"size\",value.getSize());\n  closeTag();\n}\n", "docstring": "writes & lt ; tag & gt ; value & lt ; / tag & gt ; to output stream", "partition": "test"}
{"idx": "2784", "code": "private Socket connect(String host,String portString) throws IOException {\n  int port=0;\n  Socket sock=null;\n  boolean DEBUG=Debug.debugging(\"netmap\");\n  try {\n    port=Integer.parseInt(portString,10);\n  }\n catch (  NumberFormatException e) {\n    if (DEBUG)     Debug.output(\"Illegal name \" + host + \":\"+ portString);\n    throw new IOException(\"Illegal port: \" + portString);\n  }\n  if (DEBUG)   Debug.output(\"Connecting to server \" + host + \":\"+ port);\n  try {\n    sock=new Socket(host,port);\n  }\n catch (  IOException e) {\n    if (sock != null)     sock.close();\n    if (DEBUG) {\n      Debug.output(\"Can\'t connect to \" + host + \":\"+ port+ \"\\n   \"+ e);\n    }\n    throw e;\n  }\n  return sock;\n}\n", "docstring": "a general connection method that returns a socket for a host and port .", "partition": "test"}
{"idx": "2785", "code": "@Override public boolean batchFinished(){\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  Instances toFilter=getInputFormat();\n  int cutOff=(int)Math.round(toFilter.numInstances() * m_Percentage / 100);\n  if (m_Inverse) {\n    for (int i=0; i < cutOff; i++) {\n      push(toFilter.instance(i));\n    }\n  }\n else {\n    for (int i=cutOff; i < toFilter.numInstances(); i++) {\n      push(toFilter.instance(i));\n    }\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}\n", "docstring": "signify that this batch of input to the filter is finished . output ( ) may now be called to retrieve the filtered instances .", "partition": "test"}
{"idx": "2786", "code": "public void computeParameters(){\n  if (ellps == null) {\n    ellps=Ellipsoid.WGS_84;\n  }\n  if (mode == MODE_BELGIUM) {\n    alpha=0.00014204d;\n  }\n else {\n    alpha=0d;\n  }\n  double phi1=ProjMath.degToRad(lambert_sp_one);\n  double phi2=ProjMath.degToRad(lambert_sp_two);\n  double phif=ProjMath.degToRad(referenceLatitude);\n  double e=ellps.ecc;\n  double sinphi;\n  sinphi=Math.sin(phi1);\n  double m1=lambMsfn(sinphi,Math.cos(phi1),e);\n  double t1=lambTsfn(phi1,sinphi,e);\n  if (MoreMath.approximately_equal(phi1,phi2,EPS10)) {\n    n=sinphi;\n  }\n else {\n    sinphi=Math.sin(phi2);\n    double m2=lambMsfn(sinphi,Math.cos(phi2),e);\n    double t2=lambTsfn(phi2,sinphi,e);\n    n=Math.log(m1 / m2) / Math.log(t1 / t2);\n  }\n  F=m1 / (n * Math.pow(t1,n));\n  if (MoreMath.approximately_equal(phi1,phi2,EPS10)) {\n    rf=0.0d;\n  }\n else {\n    rf=ellps.radius * F * Math.pow(lambTsfn(phif,Math.sin(phif),e),n);\n  }\n  lamdaf=ProjMath.degToRad(centralMeridian);\n  locationCenterXPixel=((double)getWidth() / 2d);\n  locationCenterYPixel=((double)getHeight() / 2d);\n  locationPixelsPerLambert=(double)getPPM() / getScale();\n  LatLonPoint origin=new LatLonPoint.Double(referenceLatitude,centralMeridian);\n  Point2D lp=LLToWorld(origin.getY(),origin.getX(),new Point2D.Double());\n  locationOriginX=lp.getX();\n  locationOriginY=lp.getY();\n  LatLonPoint center=getCenter();\n  lp=LLToWorld(center.getY(),center.getX(),lp);\n  locationCenterXLambert=lp.getX();\n  locationCenterYLambert=lp.getY();\n  locationOriginXfPixel=locationCenterXPixel + (locationOriginX - locationCenterXLambert) * locationPixelsPerLambert;\n  locationOriginYfPixel=locationCenterYPixel - (locationOriginY - locationCenterYLambert) * locationPixelsPerLambert;\n  if (Debug.debugging(\"Lambert\")) {\n    Debug.output(\"Creating LambertConformal: center x = \" + locationCenterXLambert + \", center y = \"+ locationCenterYLambert);\n    Debug.output(\"Creating LambertConformal: origin x = \" + locationOriginX + \", origin y = \"+ locationOriginY);\n  }\n}\n", "docstring": "called when some fundamental parameters change . < p > each projection will decide how to respond to this change . for instance , they may need to recalculate \" constant \" parameters used in the forward ( ) and inverse ( ) calls . < p >", "partition": "test"}
{"idx": "2787", "code": "protected OkHttpClient configureHttpClient(){\n  final OkHttpClient.Builder builder=new OkHttpClient.Builder();\n  final CookieManager cookieManager=new CookieManager();\n  cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ALL);\n  builder.cookieJar(new JavaNetCookieJar(cookieManager));\n  builder.connectTimeout(60,TimeUnit.SECONDS);\n  builder.writeTimeout(60,TimeUnit.SECONDS);\n  builder.readTimeout(90,TimeUnit.SECONDS);\n  return builder.build();\n}\n", "docstring": "configures the http client .", "partition": "test"}
{"idx": "2788", "code": "public String parseFile(File file){\n  log.config(file.getAbsolutePath());\n  String line=null;\n  try {\n    BufferedReader in=new BufferedReader(new InputStreamReader(new FileInputStream(file),Ini.getCharset()),10240);\n    String errMsg=\"\";\n    int lineNo=1;\n    while ((line=in.readLine()) != null && errMsg.length() == 0) {\n      errMsg=parseLine(line,lineNo);\n      lineNo++;\n    }\n    line=null;\n    in.close();\n    if (errMsg.length() != 0)     return errMsg;\n  }\n catch (  Exception ioe) {\n    String s=ioe.getLocalizedMessage();\n    if (s == null || s.length() == 0)     s=ioe.toString();\n    return \"Parse Error: Line=\" + line + \" - \"+ s;\n  }\n  return \"\";\n}\n", "docstring": "read and parse file", "partition": "test"}
{"idx": "2789", "code": "public static Test suite() throws Exception {\n  return suite(true);\n}\n", "docstring": "skip the dataset tests for now until we can figure out what is wrong with them . fixme fix the dataset tests . there is some problem in how the data to be loaded into the fixture is being resolved in these tests .", "partition": "test"}
{"idx": "2790", "code": "public void load(Element element,Object o){\n  log.error(\"load(Element, Object) called unexpectedly\");\n}\n", "docstring": "update static data from xml file", "partition": "test"}
{"idx": "2791", "code": "public OMRaster(double lt,double ln,int offset_x1,int offset_y1,ImageIcon ii){\n  this(lt,ln,offset_x1,offset_y1,ii.getImage());\n}\n", "docstring": "create an omraster , lat / lon with x / y placement with an imageicon .", "partition": "test"}
{"idx": "2792", "code": "private synchronized boolean startDequeue(){\n  int threads=Math.min(queue.size(),maxThreads);\n  for (int i=0; i < threads; i++) {\n    ResourceThread t=(ResourceThread)queue.firstElement();\n    queue.removeElementAt(0);\n    running.addElement(t);\n    threadCount++;\n  }\n  for (Enumeration e=running.elements(); e.hasMoreElements(); ) {\n    ResourceThread t=(ResourceThread)e.nextElement();\n    t.go();\n  }\n  return (threads > 0);\n}\n", "docstring": "starts dequeuing the queue into the running pool and launch them", "partition": "test"}
{"idx": "2793", "code": "public void propertyChange(PropertyChangeEvent evt){\n  String name=evt.getPropertyName();\n  if (name == \"width\" || name == \"preferredWidth\") {\n    invalidateWidthCache();\n    fireColumnMarginChanged();\n  }\n}\n", "docstring": "property change listener change method . used to track changes to the column width or preferred column width .", "partition": "test"}
{"idx": "2794", "code": "public static void assertEquals(Object object1,Object object2){\n  checkAssertion(object1.equals(object2),null);\n}\n", "docstring": "asserts that given object1 equals object2 .", "partition": "test"}
{"idx": "2795", "code": "public String formatSQL(Object obj,Object expr){\n  String sql=null;\n  if (expr instanceof String) {\n    sql=(String)expr;\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL retrieved from state = \" + sql);\n    }\n  }\n else   if (obj != null) {\n    sql=toString(obj);\n    if (sql != null) {\n      if (sql.startsWith(\"prep\")) {\n        sql=sql.replaceFirst(\"prep[0-9]*: \",\"\");\n      }\n      sql=sql.replaceAll(\"X\'.*\'\",BINARY_SQL_MARKER);\n    }\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL derived from context = \" + sql);\n    }\n  }\n  return sql;\n}\n", "docstring": "this method attempts to return a sql statement . if an expression is supplied , and is string , it will be used . otherwise the method will attempt to derive an expression from the supplied object .", "partition": "test"}
{"idx": "2796", "code": "public void addFakeView(View childView){\n  childView.layout(0,0,getWidth(),childView.getMeasuredHeight());\n  views.add(childView);\n}\n", "docstring": "add a view for the dummyview to draw .", "partition": "test"}
{"idx": "2797", "code": "public void compileProjects(List<File> projects,IssueAcceptor issueAcceptor) throws N4JSCompileException {\n  compileProjects(Arrays.asList(new File(\".\")),projects,Collections.emptyList(),issueAcceptor);\n}\n", "docstring": "compile a list of projects .", "partition": "test"}
{"idx": "2798", "code": "protected final void print_contact_info(ObjectInfoPanel p_window,java.util.Locale p_locale){\n  Collection<BrdItem> contacts=get_normal_contacts();\n  if (contacts.isEmpty())   return;\n  GuiResources resources=r_board.newGuiResources(\"board.resources.ObjectInfoPanel\");\n  p_window.append(\", \" + resources.getString(\"contacts\") + \" \");\n  Integer contact_count=contacts.size();\n  p_window.append_items(contact_count.toString(),resources.getString(\"contact_info\"),contacts);\n}\n", "docstring": "internal function used in the implementation of print_info", "partition": "test"}
{"idx": "2799", "code": "@SuppressWarnings(\"unchecked\") public Promise<Result,Progress> resolve(Result result){\n  List<DoneCallback<Result>> doneCallbacks;\n  List<AlwaysCallback> alwaysCallbacks;\nsynchronized (this) {\n    validateInPendingState();\n    mState=STATE_RESOLVED;\n    printStateChanged(\"RESOLVED\");\n    mResult=result;\n    doneCallbacks=mCallbacks.cloneDoneCallbacks();\n    alwaysCallbacks=mCallbacks.cloneAlwaysCallbacks();\n    clearCallbacks();\n  }\n  if (doneCallbacks.size() > 0 || alwaysCallbacks.size() > 0) {\n    triggerAllDones(doneCallbacks);\n    triggerAllAlways(alwaysCallbacks);\n  }\n  return this;\n}\n", "docstring": "resolves the promise , triggers any done / always callbacks", "partition": "test"}
{"idx": "2800", "code": "private void createSnapshot(BlockSnapshot snapshot,Snap unitySnap,StorageSystem storage,DbClient dbClient){\n  snapshot.setNativeId(unitySnap.getId());\n  snapshot.setNativeGuid(NativeGUIDGenerator.generateNativeGuid(storage,snapshot));\n  snapshot.setDeviceLabel(unitySnap.getName());\n  snapshot.setIsSyncActive(true);\n  snapshot.setInactive(false);\n  snapshot.setCreationTime(Calendar.getInstance());\n  snapshot.setWWN(unitySnap.getAttachedWWN());\n  snapshot.setAllocatedCapacity(unitySnap.getSize());\n  snapshot.setProvisionedCapacity(unitySnap.getSize());\n  dbClient.createObject(snapshot);\n}\n", "docstring": "create the blocksnapshot in db", "partition": "test"}
{"idx": "2801", "code": "public void save() throws IOException {\n  if (!props.isEmpty()) {\n    ConfigurationUtil.saveConfigurationProperties(props,propsFile,false);\n  }\n  ConfigurationUtil.saveConfigurationProperties(props,new File(propsFile.getParentFile(),propsFile.getName() + \".default\"),true);\n}\n", "docstring": "saves the currently known settings .", "partition": "test"}
{"idx": "2802", "code": "public static int len(String list,String delimiter,boolean ignoreEmpty){\n  if (delimiter.length() == 1)   return len(list,delimiter.charAt(0),ignoreEmpty);\n  char[] del=delimiter.toCharArray();\n  int len=StringUtil.length(list);\n  if (len == 0)   return 0;\n  int count=0;\n  int last=0;\n  char c;\n  for (int i=0; i < len; i++) {\n    c=list.charAt(i);\n    for (int y=0; y < del.length; y++) {\n      if (c == del[y]) {\n        if (!ignoreEmpty || last < i)         count++;\n        last=i + 1;\n        break;\n      }\n    }\n  }\n  if (!ignoreEmpty || last < len)   count++;\n  return count;\n}\n", "docstring": "returns count of items in the list", "partition": "test"}
{"idx": "2803", "code": "static void dispose(long pData,long pConfigInfo){\n  OGLRenderQueue rq=OGLRenderQueue.getInstance();\n  rq.lock();\n  try {\n    OGLContext.setScratchSurface(pConfigInfo);\n    RenderBuffer buf=rq.getBuffer();\n    rq.ensureCapacityAndAlignment(12,4);\n    buf.putInt(DISPOSE_SURFACE);\n    buf.putLong(pData);\n    rq.flushNow();\n  }\n  finally {\n    rq.unlock();\n  }\n}\n", "docstring": "disposes the native resources associated with the given oglsurfacedata ( referenced by the pdata parameter ) . this method is invoked from the native dispose ( ) method from the disposer thread when the java - level oglsurfacedata object is about to go away . note that we also pass a reference to the native glx / wglgraphicsconfiginfo ( pconfiginfo ) for the purposes of making a context current .", "partition": "test"}
{"idx": "2804", "code": "void renderNormal(){\n  glEnable(GL_DEPTH_TEST);\n  glUseProgram(this.normalProgram);\n  glUniformMatrix4fv(viewMatrixUniform,false,viewMatrix.get(matrixBuffer));\n  glUniformMatrix4fv(projMatrixUniform,false,projMatrix.get(matrixBuffer));\n  glUniformMatrix3fv(normalMatrixUniform,false,normalMatrix.get(matrixBuffer));\n  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,fbo);\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  glBindBuffer(GL_ARRAY_BUFFER,this.cubeVbo);\n  glEnableVertexAttribArray(0);\n  glVertexAttribPointer(0,3,GL_FLOAT,false,0,0L);\n  glEnableVertexAttribArray(1);\n  glVertexAttribPointer(1,3,GL_FLOAT,false,0,normalsOffset);\n  glDrawArrays(GL_TRIANGLES,0,numVertices);\n  glDisableVertexAttribArray(0);\n  glDisableVertexAttribArray(1);\n  glBindBuffer(GL_ARRAY_BUFFER,0);\n  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,0);\n  glUseProgram(0);\n}\n", "docstring": "render the normals into a texture .", "partition": "test"}
{"idx": "2805", "code": "private <T extends CWLResource>List<T> lookForResources(CWLResourceType type,Class<T> clazz){\n  List<T> resources=getRequirements(type,clazz);\n  if (resources == null || resources.size() == 0) {\n    resources=getHints(type,clazz);\n  }\n  return resources;\n}\n", "docstring": "find all resources by type", "partition": "test"}
{"idx": "2806", "code": "@Override public boolean release(int decrement){\n  if (isEmpty) {\n    return false;\n  }\n  if (decrement < 1) {\n    throw new IllegalStateException(String.format(\"release(%d) argument is not positive. Buffer Info: %s\",decrement,toVerboseString()));\n  }\n  final int refCnt=ledger.decrement(decrement);\n  if (BaseAllocator.DEBUG) {\n    historicalLog.recordEvent(\"release(%d). original value: %d\",decrement,refCnt + decrement);\n  }\n  if (refCnt < 0) {\n    throw new IllegalStateException(String.format(\"ArrowBuf[%d] refCnt has gone negative. Buffer Info: %s\",id,toVerboseString()));\n  }\n  return refCnt == 0;\n}\n", "docstring": "release the provided number of reference counts .", "partition": "test"}
{"idx": "2807", "code": "int listSize(){\n  int result=memSize();\n  for (Iterator it=iterator(); it.hasNext(); ) {\n    ASTNode child=(ASTNode)it.next();\n    result+=child.treeSize();\n  }\n  return result;\n}\n", "docstring": "returns an estimate of the memory footprint in bytes of this node list and all its subtrees .", "partition": "test"}
{"idx": "2808", "code": "public UniformDistribution estimate(double min,double max,final int count){\n  double grow=(count > 1) ? 0.5 * (max - min) / (count - 1) : 0.;\n  return new UniformDistribution(Math.max(min - grow,-Double.MAX_VALUE),Math.min(max + grow,Double.MAX_VALUE));\n}\n", "docstring": "estimate from simple characteristics .", "partition": "test"}
{"idx": "2809", "code": "public static RepositoryMetaData readFrom(StreamInput in) throws IOException {\n  String name=in.readString();\n  String type=in.readString();\n  Settings settings=Settings.readSettingsFromStream(in);\n  return new RepositoryMetaData(name,type,settings);\n}\n", "docstring": "reads repository metadata from stream input", "partition": "test"}
{"idx": "2810", "code": "public static boolean isPrimitiveDatatype(IRI datatype){\n  return datatype.equals(XMLSchema.DURATION) || datatype.equals(XMLSchema.DATETIME) || datatype.equals(XMLSchema.TIME)|| datatype.equals(XMLSchema.DATE)|| datatype.equals(XMLSchema.GYEARMONTH)|| datatype.equals(XMLSchema.GYEAR)|| datatype.equals(XMLSchema.GMONTHDAY)|| datatype.equals(XMLSchema.GDAY)|| datatype.equals(XMLSchema.GMONTH)|| datatype.equals(XMLSchema.STRING)|| datatype.equals(XMLSchema.BOOLEAN)|| datatype.equals(XMLSchema.BASE64BINARY)|| datatype.equals(XMLSchema.HEXBINARY)|| datatype.equals(XMLSchema.FLOAT)|| datatype.equals(XMLSchema.DECIMAL)|| datatype.equals(XMLSchema.DOUBLE)|| datatype.equals(XMLSchema.ANYURI)|| datatype.equals(XMLSchema.QNAME)|| datatype.equals(XMLSchema.NOTATION);\n}\n", "docstring": "checks whether the supplied datatype is a primitive xml schema datatype .", "partition": "test"}
{"idx": "2811", "code": "protected void appendLine(JComponent c){\n  c.setAlignmentX(0.f);\n  contents.add(c);\n}\n", "docstring": "handle gui layout details during construction .", "partition": "test"}
{"idx": "2812", "code": "public void postProcess(){\n  if (foreignColumnName != null) {\n    foreignAutoRefresh=true;\n  }\n  if (foreignAutoRefresh && maxForeignAutoRefreshLevel == DatabaseField.NO_MAX_FOREIGN_AUTO_REFRESH_LEVEL_SPECIFIED) {\n    maxForeignAutoRefreshLevel=DatabaseField.DEFAULT_MAX_FOREIGN_AUTO_REFRESH_LEVEL;\n  }\n}\n", "docstring": "process the settings when we are going to consume them .", "partition": "test"}
{"idx": "2813", "code": "private void persistNewTemp(File fileCfg){\n  if (hsDeleteOnExit.size() == 0) {\n    logDebug(LogArea.CONFIG,\"No temp file names to persist on exit.\");\n    fileCfg.delete();\n    return;\n  }\n  logDebug(LogArea.CONFIG,\"Persisting %d temp file names into %s\",hsDeleteOnExit.size(),fileCfg.getAbsolutePath());\n  BufferedWriter writer=null;\n  try {\n    writer=new BufferedWriter(new FileWriter(fileCfg));\n    for (    File file : hsDeleteOnExit) {\n      if (!file.delete()) {\n        String f=file.getCanonicalPath();\n        writer.write(f);\n        writer.newLine();\n        logWarn(LogArea.JAR,\"JVM failed to release %s\",f);\n      }\n    }\n  }\n catch (  IOException e) {\n  }\n finally {\n    if (writer != null) {\n      try {\n        writer.close();\n      }\n catch (      IOException e) {\n      }\n    }\n  }\n}\n", "docstring": "creates file with temporary files list . this list will be used to delete temporary files on the next application launch . the method is called from shutdown ( ) .", "partition": "test"}
{"idx": "2814", "code": "public void addWritten(byte[] value){\n  writeSetLock.lock();\n  writeSet.add(new TimestampValuePair(ets,value));\n  writeSetLock.unlock();\n}\n", "docstring": "add a value that shall be written to the writeset", "partition": "test"}
{"idx": "2815", "code": "public void load(Entity unit) throws IllegalArgumentException {\n  if (!canLoad(unit)) {\n    throw new IllegalArgumentException(\"Can not load \" + unit.getShortName() + \" into this bay.\");\n  }\n  currentSpace-=1;\n  troops.addElement(unit.getId());\n}\n", "docstring": "load the given unit .", "partition": "test"}
{"idx": "2816", "code": "public void finish() throws IOException {\n  if (!def.finished()) {\n    def.finish();\n    while (!def.finished()) {\n      int len=def.deflate(buf,0,buf.length);\n      if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n        writeTrailer(buf,len);\n        len=len + TRAILER_SIZE;\n        out.write(buf,0,len);\n        return;\n      }\n      if (len > 0)       out.write(buf,0,len);\n    }\n    byte[] trailer=new byte[TRAILER_SIZE];\n    writeTrailer(trailer,0);\n    out.write(trailer);\n  }\n}\n", "docstring": "finishes writing compressed data to the output stream without closing the underlying stream . use this method when applying multiple filters in succession to the same output stream .", "partition": "test"}
{"idx": "2817", "code": "public boolean free(T obj){\n  AtomicInteger topRef=_top;\n  while (true) {\n    final int top=topRef.get();\n    if (_capacity <= top) {\n      return false;\n    }\n    boolean isFree=_freeStack.compareAndSet(top,null,obj);\n    topRef.compareAndSet(top,top + 1);\n    if (isFree) {\n      return true;\n    }\n  }\n}\n", "docstring": "frees the object . if the free list is full , the object will be garbage collected .", "partition": "test"}
{"idx": "2818", "code": "public static boolean hasBinding(Injector injector,Key<?> key){\n  Binding<?> binding=getBinding(injector,key);\n  return binding != null;\n}\n", "docstring": "returns true if a binding exists for the given key", "partition": "test"}
{"idx": "2819", "code": "private OpenReplicatorManagerMBean createInternalService(String serviceName) throws ReplicatorException {\n  logger.info(\"Starting replication service: name=\" + serviceName);\n  try {\n    OpenReplicatorManager orm=new OpenReplicatorManager(serviceName);\n    orm.setRmiHost(managerRMIHost);\n    orm.setRmiPort(managerRMIPort);\n    orm.setHostTimeZone(hostTimeZone);\n    orm.setReplicatorTimeZone(replicatorTimeZone);\n    orm.advertiseInternal();\n    orm.setSecurityInfo(this.securityInfo);\n    return (OpenReplicatorManagerMBean)orm;\n  }\n catch (  Exception e) {\n    throw new ReplicatorException(String.format(\"Unable to instantiate replication service \'%s\'\",serviceName),e);\n  }\n}\n", "docstring": "creates a replication service that will run as a thread internal to the replicationservicemanager .", "partition": "test"}
{"idx": "2820", "code": "public static CheckIndex.Status checkIndex(Directory dir) throws IOException {\n  return checkIndex(dir,true);\n}\n", "docstring": "this runs the checkindex tool on the index in . if any issues are hit , a runtimeexception is thrown ; else , true is returned .", "partition": "test"}
{"idx": "2821", "code": "static void policyChanged(String serviceTypeName,PolicyEvent pe){\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"PolicyEvaulator.policyChanged():serviceTypeName=\" + serviceTypeName);\n  }\n  resourceNamesMap.remove(serviceTypeName);\n  Cache resourceNamesCache=(Cache)resourceNamesMap.get(serviceTypeName);\n  if ((resourceNamesCache == null) || (resourceNamesCache.isEmpty())) {\n    return;\n  }\n  try {\n    DEBUG.error(\"PolicyEvaluator.policyChanged: enterred try block\");\n    ServiceTypeManager stm=ServiceTypeManager.getServiceTypeManager();\n    ServiceType serviceType=stm.getServiceType(serviceTypeName);\n    Set resourceNamesToRemove=new HashSet();\nsynchronized (resourceNamesCache) {\n      Enumeration resourceNames=resourceNamesCache.keys();\n      while (resourceNames.hasMoreElements()) {\n        String resourceName=(String)resourceNames.nextElement();\n        if (resourceNamesToRemove.contains(resourceName)) {\n          continue;\n        }\n        Set affectedResourceNames=pe.getResourceNames();\n        Iterator iter=affectedResourceNames.iterator();\n        while (iter.hasNext()) {\n          String affectedResourceName=(String)iter.next();\n          if (serviceType.compare(resourceName,affectedResourceName) != ResourceMatch.NO_MATCH) {\n            resourceNamesToRemove.add(resourceName);\n          }\n        }\n      }\n      Iterator iter1=resourceNamesToRemove.iterator();\n      while (iter1.hasNext()) {\n        String resourceNameToRemove=(String)iter1.next();\n        resourceNamesCache.remove(resourceNameToRemove);\n      }\n    }\n  }\n catch (  SSOException e) {\n    DEBUG.error(\"PolicyEvaluator.policyChanged:\",e);\n  }\ncatch (  PolicyException pex) {\n    DEBUG.error(\"PolicyEvaluator.policyChanged:\",pex);\n  }\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"PolicyEvaulator.policyChanged():serviceTypeName=\" + serviceTypeName + \", new cached resoruceNames=\"+ resourceNamesMap.get(serviceTypeName));\n  }\n}\n", "docstring": "handles policychanged notifications - clears the cached resource names for the service type name", "partition": "test"}
{"idx": "2822", "code": "private void startHideAnimations(){\n  animationPlaying=true;\n  lightAnimationLayout();\n  if (buttonType.equals(ButtonType.CIRCLE)) {\n    if (hideOrderType.equals(OrderType.DEFAULT)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(dots[i],circleButtons[i],endLocations[i],startLocations[i],i);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.REVERSE)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(dots[i],circleButtons[i],endLocations[i],startLocations[i],buttonNum - i - 1);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.RANDOM)) {\n      Random random=new Random();\n      boolean[] used=new boolean[buttonNum];\n      for (int i=0; i < buttonNum; i++)       used[i]=false;\n      int count=0;\n      while (true) {\n        int i=random.nextInt(buttonNum);\n        if (!used[i]) {\n          used[i]=true;\n          setHideAnimation(dots[count],circleButtons[count],endLocations[count],startLocations[count],i);\n          count++;\n          if (count == buttonNum)           break;\n        }\n      }\n    }\n  }\n else   if (buttonType.equals(ButtonType.HAM)) {\n    if (hideOrderType.equals(OrderType.DEFAULT)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(bars[i],hamButtons[i],endLocations[i],startLocations[i],i);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.REVERSE)) {\n      for (int i=0; i < buttonNum; i++) {\n        setHideAnimation(bars[i],hamButtons[i],endLocations[i],startLocations[i],buttonNum - i - 1);\n      }\n    }\n else     if (hideOrderType.equals(OrderType.RANDOM)) {\n      Random random=new Random();\n      boolean[] used=new boolean[buttonNum];\n      for (int i=0; i < buttonNum; i++)       used[i]=false;\n      int count=0;\n      while (true) {\n        int i=random.nextInt(buttonNum);\n        if (!used[i]) {\n          used[i]=true;\n          setHideAnimation(bars[count],hamButtons[count],endLocations[count],startLocations[count],i);\n          count++;\n          if (count == buttonNum)           break;\n        }\n      }\n    }\n  }\n}\n", "docstring": "start all animations about dismissing .", "partition": "test"}
{"idx": "2823", "code": "public static void putShort(long addr,short val){\n  if (UNALIGNED)   UNSAFE.putShort(addr,val);\n else   putShortByByte(addr,val,BIG_ENDIAN);\n}\n", "docstring": "stores given short value . alignment aware .", "partition": "test"}
{"idx": "2824", "code": "public static byte[] hashTwice(byte[] input,int offset,int length){\n  MessageDigest digest=newDigest();\n  digest.update(input,offset,length);\n  return digest.digest(digest.digest());\n}\n", "docstring": "calculates the sha - 256 hash of the given byte range , and then hashes the resulting hash again .", "partition": "test"}
{"idx": "2825", "code": "public PronounceableFSM(URL url,boolean scanFromFront) throws IOException {\n  this.scanFromFront=scanFromFront;\n  InputStream is=Utilities.getInputStream(url);\n  loadText(is);\n  is.close();\n}\n", "docstring": "constructs a pronounceablefsm with information in the given url .", "partition": "test"}
{"idx": "2826", "code": "private char[] applyFloatPadding(final char[] ca4,final boolean noDigits){\n  char[] ca5=ca4;\n  if (fieldWidthSet) {\n    int i;\n    int j;\n    final int nBlanks;\n    if (leftJustify) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        for (i=0; i < ca4.length; i++) {\n          ca5[i]=ca4[i];\n        }\n        for (j=0; j < nBlanks; j++, i++) {\n          ca5[i]=' ';\n        }\n      }\n    }\n else     if (!leadingZeros || noDigits) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        for (i=0; i < nBlanks; i++) {\n          ca5[i]=' ';\n        }\n        for (j=0; j < ca4.length; i++, j++) {\n          ca5[i]=ca4[j];\n        }\n      }\n    }\n else     if (leadingZeros) {\n      nBlanks=fieldWidth - ca4.length;\n      if (nBlanks > 0) {\n        ca5=new char[ca4.length + nBlanks];\n        i=0;\n        j=0;\n        if (ca4[0] == '-') {\n          ca5[0]='-';\n          i++;\n          j++;\n        }\n        for (int k=0; k < nBlanks; i++, k++) {\n          ca5[i]='0';\n        }\n        for (; j < ca4.length; i++, j++) {\n          ca5[i]=ca4[j];\n        }\n      }\n    }\n  }\n  return ca5;\n}\n", "docstring": "apply zero or blank , left or right padding .", "partition": "test"}
{"idx": "2827", "code": "@Override public void makeImmutable(){\n  if (isMutable) {\n    if (authnStatements != null) {\n      int length=authnStatements.size();\n      for (int i=0; i < length; i++) {\n        AuthnStatement authn=(AuthnStatement)authnStatements.get(i);\n        authn.makeImmutable();\n      }\n      authnStatements=Collections.unmodifiableList(authnStatements);\n    }\n    if (authzDecisionStatements != null) {\n      int length=authzDecisionStatements.size();\n      for (int i=0; i < length; i++) {\n        AuthzDecisionStatement authz=(AuthzDecisionStatement)authzDecisionStatements.get(i);\n        authz.makeImmutable();\n      }\n      authzDecisionStatements=Collections.unmodifiableList(authzDecisionStatements);\n    }\n    if (attributeStatements != null) {\n      int length=attributeStatements.size();\n      for (int i=0; i < length; i++) {\n        AttributeStatement attr=(AttributeStatement)attributeStatements.get(i);\n        attr.makeImmutable();\n      }\n      attributeStatements=Collections.unmodifiableList(attributeStatements);\n    }\n    if (statements != null) {\n      statements=Collections.unmodifiableList(statements);\n    }\n    if (conditions != null) {\n      conditions.makeImmutable();\n    }\n    if (issuer != null) {\n      issuer.makeImmutable();\n    }\n    if (subject != null) {\n      subject.makeImmutable();\n    }\n    if (advice != null) {\n      advice.makeImmutable();\n    }\n    isMutable=false;\n  }\n}\n", "docstring": "makes the object immutable", "partition": "test"}
{"idx": "2828", "code": "@Override public String findLibrary(String name){\n  String systemName=System.mapLibraryName(name);\n  ArrayList<Loader> loaders=getLoaders();\n  for (int i=0; i < loaders.size(); i++) {\n    Loader loader=loaders.get(i);\n    Path path=loader.getPath(systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n    path=loader.getPath(\"native/\" + systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n  }\n  for (int i=0; i < _nativePath.size(); i++) {\n    Path path=_nativePath.get(i);\n    if (path.canRead())     return path.getNativePath();\n  }\n  return super.findLibrary(name);\n}\n", "docstring": "returns the full library path for the name .", "partition": "test"}
{"idx": "2829", "code": "public void removeComponentListener(final ComponentUpdateListener listener){\n  componentListeners.remove(listener);\n}\n", "docstring": "removes a component listener from this instance .", "partition": "test"}
{"idx": "2830", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return APPKEY;\ncase 2:\n  return SEND_TIME;\ncase 3:\nreturn LOAD_INFO;\ncase 4:\nreturn STATUS;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "2831", "code": "public static boolean isEmpty(CharSequence text){\n  return text == null || text.length() == 0;\n}\n", "docstring": "returns true if the string is null or 0 - length .", "partition": "test"}
{"idx": "2832", "code": "protected byte[] assertEncodeDecode(final IGangliaMetadataMessage decl,final IGangliaMessage expected){\n  if (expected == null)   throw new IllegalArgumentException();\n  final XDROutputBuffer xdr=new XDROutputBuffer(IGangliaDefaults.BUFFER_SIZE);\n  final GangliaMessageEncoder31 messageEncoder=new GangliaMessageEncoder31();\n  final GangliaMessageDecoder31 messageDecoder=new GangliaMessageDecoder31();\n  if (expected.isMetricRequest()) {\n    messageEncoder.writeRequest(xdr,(IGangliaRequestMessage)expected);\n  }\n else   if (expected.isMetricMetadata()) {\n    messageEncoder.writeMetadata(xdr,(IGangliaMetadataMessage)expected);\n  }\n else   if (expected.isMetricValue()) {\n    if (decl == null)     throw new IllegalArgumentException(\"Declaration required for metric value record\");\n    messageEncoder.writeMetric(xdr,decl,(IGangliaMetricMessage)expected);\n  }\n else {\n    throw new AssertionError();\n  }\n  final IGangliaMessage actual=messageDecoder.decode(xdr.getBuffer(),0,xdr.getLength());\n  assertEquals(\"messages not equal()\",expected,actual);\n  final byte[] actualData=new byte[xdr.getLength()];\n  System.arraycopy(xdr.getBuffer(),0,actualData,0,actualData.length);\n  return actualData;\n}\n", "docstring": "verify that we can encode and decode a record .", "partition": "test"}
{"idx": "2833", "code": "private boolean isIndexable(String term){\n  return (term.length() < 30) && (term.length() > 2);\n}\n", "docstring": "checks a term if it can be processed indexed .", "partition": "test"}
{"idx": "2834", "code": "private void sendResponse(String status,String mime,Properties header,InputStream data){\n  try {\n    if (status == null)     throw new Error(\"sendResponse(): Status can\'t be null.\");\n    OutputStream out=mySocket.getOutputStream();\n    PrintWriter pw=new PrintWriter(out);\n    pw.print(\"HTTP/1.0 \" + status + \" \\r\\n\");\n    if (mime != null)     pw.print(\"Content-Type: \" + mime + \"\\r\\n\");\n    if (header == null || header.getProperty(\"Date\") == null)     pw.print(\"Date: \" + gmtFrmt.format(new Date()) + \"\\r\\n\");\n    if (header != null) {\n      Enumeration e=header.keys();\n      while (e.hasMoreElements()) {\n        String key=(String)e.nextElement();\n        String value=header.getProperty(key);\n        pw.print(key + \": \" + value+ \"\\r\\n\");\n      }\n    }\n    pw.print(\"\\r\\n\");\n    pw.flush();\n    if (data != null) {\n      byte[] buff=new byte[2048];\n      while (true) {\n        int read=data.read(buff,0,2048);\n        if (read <= 0)         break;\n        out.write(buff,0,read);\n      }\n    }\n    out.flush();\n    out.close();\n    if (data != null)     data.close();\n  }\n catch (  IOException ioe) {\n    try {\n      mySocket.close();\n    }\n catch (    Throwable t) {\n    }\n  }\n}\n", "docstring": "sends given response to the socket .", "partition": "test"}
{"idx": "2835", "code": "public static String decode(String encoded,AMEncryption encr){\n  if (checkCaller()) {\n    try {\n      ISSecurityPermission isp=new ISSecurityPermission(\"access\",\"adminpassword\");\n      if (securityManager != null) {\n        securityManager.checkPermission(isp);\n      }\n    }\n catch (    SecurityException e) {\n      Debug debug=Debug.getInstance(\"amSDK\");\n      debug.error(\"Security Alert: Unauthorized access to \" + \"Encoding/Decoding password utility: Returning NULL\",e);\n      return null;\n    }\n  }\n  if (encoded == null || encoded.length() == 0) {\n    return (null);\n  }\n  byte[] encData=null;\n  encData=Base64.decode(encoded.trim());\n  if (encData == null) {\n    return null;\n  }\n  byte[] rawData=encr.decrypt(encData);\n  if (rawData == null) {\n    return (null);\n  }\n  String answer=null;\n  try {\n    answer=new String(rawData,\"utf-8\");\n  }\n catch (  UnsupportedEncodingException uue) {\n    Debug debug=Debug.getInstance(\"amSDK\");\n    debug.error(\"Crypt:: Unsupported encoding UTF-8\",uue);\n    answer=new String(rawData);\n  }\n  return (answer);\n}\n", "docstring": "decode an encoded string", "partition": "test"}
{"idx": "2836", "code": "protected void waitForShutdownSignal() throws InterruptedException {\n  if (mutexWaiting == null)   mutexWaiting=new Object();\n  try {\nsynchronized (mutexWaiting) {\n      mutexWaiting.wait();\n    }\n  }\n catch (  InterruptedException e) {\n    if (!shutdown)     throw e;\n  }\n}\n", "docstring": "causes the current thread to block until signalshutdown is called . this is used by workerthreads which are not actively polling the shutdown field .", "partition": "test"}
{"idx": "2837", "code": "public void addConnection(Connection connection){\n  if (connection == null)   throw new IllegalArgumentException(\"connection cannot be null.\");\nsynchronized (connectionsLock) {\n    Connection[] newConnections=new Connection[connections.length + 1];\n    newConnections[0]=connection;\n    System.arraycopy(connections,0,newConnections,1,connections.length);\n    connections=newConnections;\n  }\n  connection.addListener(invokeListener);\n  if (TRACE)   trace(\"kryonet\",\"Added connection to ObjectSpace: \" + connection);\n}\n", "docstring": "allows the remote end of the specified connection to access objects registered in this objectspace .", "partition": "test"}
{"idx": "2838", "code": "public double distance(Point2D pt){\n  final double x_distance=(pt.getX() - x) * (pt.getX() - x);\n  final double y_distance=(pt.getY() - y) * (pt.getY() - y);\n  return Math.sqrt(x_distance + y_distance);\n}\n", "docstring": "returns the euclidean distance between a specified point and this point .", "partition": "test"}
{"idx": "2839", "code": "private static int convertToInt(String value,int defaultValue){\n  String trim=value.trim();\n  if (trim.length() == 0) {\n    return defaultValue;\n  }\n  return Integer.parseInt(trim);\n}\n", "docstring": "convert a string to an int treating empty strings as the default value .", "partition": "test"}
{"idx": "2840", "code": "public ChainIterable<T> addItem(@NotNull T item){\n  return (ChainIterable<T>)super.add(Collections.<T>singleton(item));\n}\n", "docstring": "convenience : add an item wrapping it into a singleiterable behind the scenes .", "partition": "test"}
{"idx": "2841", "code": "private void updateStateView(int itCount,Collection<Individual<Double>> gen){\n  Platform.runLater(null);\n  simPaneCtrl.waitAfterStep();\n}\n", "docstring": "caution : while the background thread should be slowed down , updates of the gui have to be done in the gui thread !", "partition": "test"}
{"idx": "2842", "code": "@Override public void run(){\n  try {\n    for (; ; ) {\n      int n=portGetn(port,bufferAddress,MAX_EVENT_COUNT);\n      assert n > 0;\n      long address=bufferAddress;\n      for (int i=0; i < n; i++) {\n        boolean shutdown=processEvent(address);\n        if (shutdown)         return;\n        address+=SIZEOF_PORT_EVENT;\n      }\n    }\n  }\n catch (  UnixException x) {\n    x.printStackTrace();\n  }\n}\n", "docstring": "poller main loop . blocks on port_getn waiting for events and then processes them .", "partition": "test"}
{"idx": "2843", "code": "@Override public List<String> allKeys(){\n  List<String> nameFiles=new ArrayList<>();\n  File[] files=cacheDirectory.listFiles();\n  if (files == null)   return nameFiles;\n  for (  File file : files) {\n    if (file.isFile()) {\n      nameFiles.add(file.getName());\n    }\n  }\n  return nameFiles;\n}\n", "docstring": "retrieve the names from all files in dir", "partition": "test"}
{"idx": "2844", "code": "public DialogueRecorder(DialogueSystem system){\n  this.settings=system.getSettings();\n}\n", "docstring": "creates a new dialogue recorder for the dialogue system", "partition": "test"}
{"idx": "2845", "code": "private static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManagerInterface manager){\n  long now=System.currentTimeMillis();\n  long ancient=now - DateUtils.DAY_IN_MILLIS;\n  String[] projection=new String[]{CalendarContract.CalendarAlerts.ALARM_TIME};\n  if (Build.VERSION.SDK_INT >= 23 && ContextCompat.checkSelfPermission(context,Manifest.permission.READ_CALENDAR) != PackageManager.PERMISSION_GRANTED) {\n    Log.d(TAG,\"Manifest.permission.READ_CALENDAR is not granted\");\n    return;\n  }\n  Cursor cursor=cr.query(CalendarAlerts.CONTENT_URI,projection,WHERE_RESCHEDULE_MISSED_ALARMS,(new String[]{Long.toString(now),Long.toString(ancient),Long.toString(now)}),SORT_ORDER_ALARMTIME_ASC);\n  if (cursor == null) {\n    return;\n  }\n  if (DEBUG) {\n    Log.d(TAG,\"missed alarms found: \" + cursor.getCount());\n  }\n  try {\n    long alarmTime=-1;\n    while (cursor.moveToNext()) {\n      long newAlarmTime=cursor.getLong(0);\n      if (alarmTime != newAlarmTime) {\n        if (DEBUG) {\n          Log.w(TAG,\"rescheduling missed alarm. alarmTime: \" + newAlarmTime);\n        }\n        AlertUtils.scheduleAlarm(context,manager,newAlarmTime);\n        alarmTime=newAlarmTime;\n      }\n    }\n  }\n  finally {\n    cursor.close();\n  }\n}\n", "docstring": "searches the calendaralerts table for alarms that should have fired but have not and then reschedules them . this method can be called at boot time to restore alarms that may have been lost due to a phone reboot .", "partition": "test"}
{"idx": "2846", "code": "@Override default CompletableFuture<OptionalDouble> minDouble(final ToDoubleFunction<? super T> fn){\n  return CompletableFuture.supplyAsync(null,getExec());\n}\n", "docstring": "perform an asynchronous min operation", "partition": "test"}
{"idx": "2847", "code": "private boolean toState(LifecycleState newState){\n  LifecycleState state;\nsynchronized (this) {\n    state=_state;\n    _state=newState;\n    _lastChangeTime=CurrentTime.currentTime();\n  }\n  if (_log != null && _log.isLoggable(_lowLevel)) {\n    _log.log(_lowLevel,newState + \" \" + _name);\n  }\n  notifyListeners(state,newState);\n  return true;\n}\n", "docstring": "changes to the next state .", "partition": "test"}
{"idx": "2848", "code": "public boolean initDialog(){\n  log.config(\"\");\n  gbc.anchor=GridBagConstraints.NORTHWEST;\n  gbc.weightx=0;\n  gbc.weighty=0;\n  gbc.gridy=m_line++;\n  gbc.gridx=0;\n  gbc.gridwidth=1;\n  gbc.insets=nullInset;\n  gbc.fill=GridBagConstraints.HORIZONTAL;\n  centerPanel.add(Box.createVerticalStrut(10),gbc);\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = \'Y\' \"+ \"                 AND p.IsActive = \'Y\' \"+ \"                 AND l.IsActive = \'Y\' \"+ \"                 AND cl.IsActive = \'Y\' \"+ \"                 AND pp.ASP_Status = \'S\') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = \'Y\' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = \'S\') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = \'Y\' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = \'H\')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, p.ReadOnlyLogic, p.DisplayLogic, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive=\'Y\' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, p.ReadOnlyLogic, p.DisplayLogic, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language=\'\" + Env.getAD_Language(Env.getCtx()) + \"\'\"+ \" AND p.IsActive=\'Y\' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs);\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_vEditors.size() || m_mFields2.size() != m_vEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    gbc.gridy=m_line++;\n    centerPanel.add(Box.createVerticalStrut(10),gbc);\n    gbc.gridx=3;\n    centerPanel.add(Box.createHorizontalStrut(12),gbc);\n    AEnv.positionCenterWindow(m_frame,this);\n  }\n else   dispose();\n  return hasFields;\n}\n", "docstring": "read fields to display", "partition": "test"}
{"idx": "2849", "code": "@Override protected String dateToString(DateTimeData date){\n  StringBuffer message=new StringBuffer(5);\n  message.append('-');\n  message.append('-');\n  append(message,date.month,2);\n  append(message,(char)date.utc,0);\n  return message.toString();\n}\n", "docstring": "converts month object representation to string", "partition": "test"}
{"idx": "2850", "code": "private void addTest(Test newTest){\n  if (m_RuleList == null) {\n    m_RuleList=new ArrayList<Test>();\n  }\n  m_RuleList.add(newTest);\n}\n", "docstring": "adds the given test to the list", "partition": "test"}
{"idx": "2851", "code": "public double nextDouble(double alpha,double lambda){\n  double a=alpha;\n  double aa=-1.0, aaa=-1.0, b=0.0, c=0.0, d=0.0, e, r, s=0.0, si=0.0, ss=0.0, q0=0.0, q1=0.0416666664, q2=0.0208333723, q3=0.0079849875, q4=0.0015746717, q5=-0.0003349403, q6=0.0003340332, q7=0.0006053049, q8=-0.0004701849, q9=0.0001710320, a1=0.333333333, a2=-0.249999949, a3=0.199999867, a4=-0.166677482, a5=0.142873973, a6=-0.124385581, a7=0.110368310, a8=-0.112750886, a9=0.104089866, e1=1.000000000, e2=0.499999994, e3=0.166666848, e4=0.041664508, e5=0.008345522, e6=0.001353826, e7=0.000247453;\n  double gds, p, q, t, sign_u, u, v, w, x;\n  double v1, v2, v12;\n  if (a <= 0.0)   throw new IllegalArgumentException();\n  if (lambda <= 0.0)   new IllegalArgumentException();\n  if (a < 1.0) {\n    b=1.0 + 0.36788794412 * a;\n    for (; ; ) {\n      p=b * randomGenerator.raw();\n      if (p <= 1.0) {\n        gds=Math.exp(Math.log(p) / a);\n        if (Math.log(randomGenerator.raw()) <= -gds)         return (gds / lambda);\n      }\n else {\n        gds=-Math.log((b - p) / a);\n        if (Math.log(randomGenerator.raw()) <= ((a - 1.0) * Math.log(gds)))         return (gds / lambda);\n      }\n    }\n  }\n else {\n    if (a != aa) {\n      aa=a;\n      ss=a - 0.5;\n      s=Math.sqrt(ss);\n      d=5.656854249 - 12.0 * s;\n    }\n    do {\n      v1=2.0 * randomGenerator.raw() - 1.0;\n      v2=2.0 * randomGenerator.raw() - 1.0;\n      v12=v1 * v1 + v2 * v2;\n    }\n while (v12 > 1.0);\n    t=v1 * Math.sqrt(-2.0 * Math.log(v12) / v12);\n    x=s + 0.5 * t;\n    gds=x * x;\n    if (t >= 0.0)     return (gds / lambda);\n    u=randomGenerator.raw();\n    if (d * u <= t * t * t)     return (gds / lambda);\n    if (a != aaa) {\n      aaa=a;\n      r=1.0 / a;\n      q0=((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;\n      if (a > 3.686) {\n        if (a > 13.022) {\n          b=1.77;\n          si=0.75;\n          c=0.1515 / s;\n        }\n else {\n          b=1.654 + 0.0076 * ss;\n          si=1.68 / s + 0.275;\n          c=0.062 / s + 0.024;\n        }\n      }\n else {\n        b=0.463 + s - 0.178 * ss;\n        si=1.235;\n        c=0.195 / s - 0.079 + 0.016 * s;\n      }\n    }\n    if (x > 0.0) {\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (Math.log(1.0 - u) <= q)       return (gds / lambda);\n    }\n    for (; ; ) {\n      do {\n        e=-Math.log(randomGenerator.raw());\n        u=randomGenerator.raw();\n        u=u + u - 1.0;\n        sign_u=(u > 0) ? 1.0 : -1.0;\n        t=b + (e * si) * sign_u;\n      }\n while (t <= -0.71874483771719);\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (q <= 0.0)       continue;\n      if (q > 0.5) {\n        w=Math.exp(q) - 1.0;\n      }\n else {\n        w=((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;\n      }\n      if (c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {\n        x=s + 0.5 * t;\n        return (x * x / lambda);\n      }\n    }\n  }\n}\n", "docstring": "returns a random number from the distribution ; bypasses the internal state .", "partition": "test"}
{"idx": "2852", "code": "public void swap(int i,int j){\n  x.assertTrue(i < list.size());\n  x.assertTrue(j < list.size());\n  list.set(i,list.set(j,list.get(i)));\n}\n", "docstring": "swaps in place the elements at the specified positions in the specified list . ( if the specified positions are equal , invoking this method leaves the list unchanged . )", "partition": "test"}
{"idx": "2853", "code": "private List<NameValuePair> buildIPTParameters(Ipt ipt,String organisationKey){\n  List<NameValuePair> data=new ArrayList<NameValuePair>();\n  if (ipt != null && organisationKey != null) {\n    data.add(new BasicNameValuePair(\"organisationKey\",StringUtils.trimToEmpty(organisationKey)));\n    data.add(new BasicNameValuePair(\"name\",StringUtils.trimToEmpty(ipt.getName())));\n    data.add(new BasicNameValuePair(\"description\",StringUtils.trimToEmpty(ipt.getDescription())));\n    data.add(new BasicNameValuePair(\"primaryContactType\",StringUtils.trimToEmpty(ipt.getPrimaryContactType())));\n    data.add(new BasicNameValuePair(\"primaryContactName\",StringUtils.trimToEmpty(ipt.getPrimaryContactName())));\n    data.add(new BasicNameValuePair(\"primaryContactEmail\",StringUtils.trimToEmpty(ipt.getPrimaryContactEmail())));\n    data.add(new BasicNameValuePair(\"serviceTypes\",SERVICE_TYPE_RSS));\n    data.add(new BasicNameValuePair(\"serviceURLs\",getRssFeedURL()));\n  }\n else {\n    log.debug(\"One or both of IPT and Organisation key were null. Params needed for ws will be empty\");\n  }\n  return data;\n}\n", "docstring": "populate a list of name value pairs used in the common ws requests for ipt registrations and updates .", "partition": "test"}
{"idx": "2854", "code": "public static <T,U extends Closeable>T withCloseable(U self,@ClosureParams(value=FirstParam.class) Closure<T> action) throws IOException {\n  try {\n    T result=action.call(self);\n    Closeable temp=self;\n    self=null;\n    temp.close();\n    return result;\n  }\n  finally {\n    DefaultGroovyMethodsSupport.closeWithWarning(self);\n  }\n}\n", "docstring": "allows this closeable to be used within the closure , ensuring that it is closed once the closure has been executed and before this method returns .", "partition": "test"}
{"idx": "2855", "code": "public static boolean isMatch(String actualString,LinkedList patterns,char wildCard){\n  boolean matched=false;\n  for (ListIterator iter=patterns.listIterator(0); iter.hasNext(); ) {\n    if (isMatch(actualString,(String)iter.next(),wildCard)) {\n      matched=true;\n      break;\n    }\n  }\n  return matched;\n}\n", "docstring": "check whether the string matches the pattern .", "partition": "test"}
{"idx": "2856", "code": "public synchronized void addServer(ServerLocation location,String[] groups,ServerLoad initialLoad,long loadPollInterval){\n  serverGroupMap.put(location,groups);\n  LoadHolder connectionLoad=new LoadHolder(location,initialLoad.getConnectionLoad(),initialLoad.getLoadPerConnection(),loadPollInterval);\n  addGroups(connectionLoadMap,groups,connectionLoad);\n  LoadHolder queueLoad=new LoadHolder(location,initialLoad.getSubscriptionConnectionLoad(),initialLoad.getLoadPerSubscriptionConnection(),loadPollInterval);\n  addGroups(queueLoadMap,groups,queueLoad);\n  updateLoad(location,initialLoad);\n}\n", "docstring": "add a new server to the load snapshot .", "partition": "test"}
{"idx": "2857", "code": "public void addLeaf(CatalogTreeLeaf leaf){\n  _leaves.add(leaf);\n}\n", "docstring": "append leaf to the end of the leaves list", "partition": "test"}
{"idx": "2858", "code": "private static String stampToString(long tstamp,String formatMask){\n  StringBuilder sb=new StringBuilder(30);\n  Formatter fmt=new Formatter(sb,Locale.US);\n  int[] pieces=new int[NUMIDX];\n  ComponentTime.unpackBits(tstamp,pieces);\n  fmt.format(formatMask,pieces[YIDX],pieces[MIDX],pieces[DIDX],pieces[HIDX],pieces[IIDX],pieces[SIDX],pieces[UIDX]);\n  fmt.close();\n  return (sb.toString());\n}\n", "docstring": "convenience method for converting component time longs to strings", "partition": "test"}
{"idx": "2859", "code": "public HttpRequest contentLength(final String value){\n  return contentLength(Integer.parseInt(value));\n}\n", "docstring": "set the \"'\" content - length \"'\" request header to the given value", "partition": "test"}
{"idx": "2860", "code": "public VNXeCommandJob modifyLunAsync(LunModifyParam param,String resourceId){\n  StringBuilder urlBld=new StringBuilder(URL_RESOURCE);\n  urlBld.append(resourceId);\n  urlBld.append(URL_LUN_MODIFY_ACTION);\n  _url=urlBld.toString();\n  return postRequestAsync(param);\n}\n", "docstring": "modify lun ( export / unexport / expand etc ) in async mode", "partition": "test"}
{"idx": "2861", "code": "public String replace(CharSequence target,CharSequence replacement){\n  if (target == null) {\n    throw new NullPointerException(\"target should not be null\");\n  }\n  if (replacement == null) {\n    throw new NullPointerException(\"replacement should not be null\");\n  }\n  String ts=target.toString();\n  int index=indexOf(ts,0);\n  if (index == -1)   return this;\n  String rs=replacement.toString();\n  StringBuilder buffer=new StringBuilder(count);\n  int tl=target.length();\n  int tail=0;\n  do {\n    buffer.append(value,offset + tail,index - tail);\n    buffer.append(rs);\n    tail=index + tl;\n  }\n while ((index=indexOf(ts,tail)) != -1);\n  buffer.append(value,offset + tail,count - tail);\n  return buffer.toString();\n}\n", "docstring": "copies this string replacing occurrences of the specified target sequence with another sequence . the string is processed from the beginning to the end .", "partition": "test"}
{"idx": "2862", "code": "public boolean similarTo(Object o){\n  if (o == null) {\n    return false;\n  }\n  if (!(o instanceof SemanticConcept)) {\n    return false;\n  }\n  SemanticConcept otherConcept=(SemanticConcept)o;\n  HashSet<Integer> synset_intersection=new HashSet<Integer>(this.synsets);\n  synset_intersection.retainAll(otherConcept.synsets);\n  if (!synset_intersection.isEmpty()) {\n    return true;\n  }\n  HashSet<String> concept_intersection=new HashSet<String>(this.concepts);\n  concept_intersection.retainAll(otherConcept.concepts);\n  return !concept_intersection.isEmpty();\n}\n", "docstring": "semanticconcepts are similar if they share a synset or a concept", "partition": "test"}
{"idx": "2863", "code": "public void jGoogleAnalyticsTracker(final String eventType,final String version,final String trackerId){\n  final JGoogleAnalyticsTracker tracker=new JGoogleAnalyticsTracker(\"vdi_calculator\",version,trackerId);\n  final FocusPoint focusPoint=new FocusPoint(eventType.toLowerCase());\n  tracker.trackAsynchronously(focusPoint);\n}\n", "docstring": "google analytics usage tracking", "partition": "test"}
{"idx": "2864", "code": "public void put(Song song){\n  if (!mSongs.contains(song)) {\n    mSongs.add(song);\n  }\n}\n", "docstring": "adds a song to the adapter", "partition": "test"}
{"idx": "2865", "code": "@NotNull public PsiQuery childrenNamed(@NotNull final Class<? extends PsiNamedElement> clazz,@NotNull final String name){\n  final List<PsiElement> result=new ArrayList<PsiElement>();\n  for (  final PsiElement element : myPsiElements) {\n    for (    final PsiNamedElement child : PsiTreeUtil.findChildrenOfType(element,clazz)) {\n      if (name.equals(child.getName())) {\n        result.add(child);\n      }\n    }\n  }\n  return new PsiQuery(result.toArray(new PsiElement[result.size()]));\n}\n", "docstring": "filter children by name and class", "partition": "test"}
{"idx": "2866", "code": "@Override public boolean equals(Object o){\n  return o.hashCode() == hashCode();\n}\n", "docstring": "returns true if the object is a complex effect with an identical content", "partition": "test"}
{"idx": "2867", "code": "private ArrayList<String> parseJson(String text){\n  text=text.substring(text.indexOf(\"\\\\nEvents\\\\n\") + SIZE_OF_EVENTS,text.indexOf(\"\\\\n\\\\n\\\\nBirths\"));\n  ArrayList<String> events=new ArrayList<String>();\n  if (text.isEmpty()) {\n    return events;\n  }\n  int startIndex=0, endIndex=0;\n  while (endIndex != -1) {\n    endIndex=text.indexOf(\"\\\\n\",startIndex + DELIMITER_SIZE);\n    String eventText=(endIndex == -1 ? text.substring(startIndex) : text.substring(startIndex,endIndex));\n    Pattern pattern=Pattern.compile(\"\\\\\\\\u2013\\\\s*\");\n    Matcher matcher=pattern.matcher(eventText);\n    eventText=matcher.replaceAll(\"\");\n    pattern=Pattern.compile(\"(^\\\\d+)\");\n    matcher=pattern.matcher(eventText);\n    if (matcher.find()) {\n      eventText=matcher.replaceFirst(matcher.group(1) + \",\");\n    }\n    eventText=\"In \" + eventText;\n    startIndex=endIndex + 2;\n    events.add(eventText);\n  }\n  Collections.reverse(events);\n  return events;\n}\n", "docstring": "parse json - formatted list of events / births / deaths from wikipedia , extract list of events and split the events into a string array of individual events . run regex matchers to make the list pretty by adding a comma after the year to add a pause , and by removing a unicode char .", "partition": "test"}
{"idx": "2868", "code": "public StrBuilder replace(int startIndex,int endIndex,String replaceStr){\n  endIndex=validateRange(startIndex,endIndex);\n  int insertLen=(replaceStr == null ? 0 : replaceStr.length());\n  replaceImpl(startIndex,endIndex,endIndex - startIndex,replaceStr,insertLen);\n  return this;\n}\n", "docstring": "replaces a portion of the string builder with another string . the length of the inserted string does not have to match the removed length .", "partition": "test"}
{"idx": "2869", "code": "public static void addPermissionRecursive(Path path,PosixFilePermission permission) throws IOException {\n  changePermissionsRecursive(path,PermissionChange.ADD,Collections.singleton(permission));\n}\n", "docstring": "recursively adds a permission to a directory .", "partition": "test"}
{"idx": "2870", "code": "private void runTimeoutTask(){\n  while (isActive()) {\n    reapTimeouts();\n    try {\n      Thread.sleep(_timeoutReapInterval);\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "docstring": "running process accepting connections .", "partition": "test"}
{"idx": "2871", "code": "public void testCase19(){\n  byte aBytes[]={-127,100,56,7,98,-1,39,-128,127,75};\n  byte bBytes[]={27,-15,65,39,100};\n  int aSign=1;\n  int bSign=-1;\n  byte rBytes[]={12,-21,73,56,27};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.remainder(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "remainder of division of two numbers of different signs . the first is positive .", "partition": "test"}
{"idx": "2872", "code": "public static boolean hasVisibleChildren(ActionGroup group,PresentationFactory factory,ActionManager actionManager,PerspectiveManager perspectiveManager){\n  ActionEvent event=new ActionEvent(factory.getPresentation(group),actionManager,perspectiveManager);\n  for (  Action anAction : group.getChildren(event)) {\n    if (anAction == null) {\n      Log.error(Utils.class,\"Null action found in group \" + group + \", \"+ factory.getPresentation(group));\n      continue;\n    }\n    if (anAction instanceof Separator) {\n      continue;\n    }\n    final Presentation presentation=factory.getPresentation(anAction);\n    anAction.update(new ActionEvent(presentation,actionManager,perspectiveManager));\n    if (anAction instanceof ActionGroup) {\n      ActionGroup childGroup=(ActionGroup)anAction;\n      if (childGroup.isPopup()) {\n        if (!presentation.isVisible()) {\n          continue;\n        }\n      }\n      if (hasVisibleChildren(childGroup,factory,actionManager,perspectiveManager)) {\n        return true;\n      }\n    }\n else     if (presentation.isVisible()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if action group has visible children .", "partition": "test"}
{"idx": "2873", "code": "private static void checkArgReferences(String typeSnippet,int numberOfArgs){\n  Matcher argRefMatcher=ARG_REF_PATTERN.matcher(typeSnippet);\n  while (argRefMatcher.find()) {\n    int index=Integer.parseInt(argRefMatcher.group(1),10) - 1;\n    Preconditions.checkArgument(index >= 0,\"%s not allowed, indices start at 1\",argRefMatcher.group(0));\n    Preconditions.checkArgument(index < numberOfArgs,\"%s too large for number of provided type mirrors\",argRefMatcher.group(0));\n  }\n}\n", "docstring": "check that all % d references in the given type snippet are within bounds .", "partition": "test"}
{"idx": "2874", "code": "public void randomize(){\n  randomizeIncomingWeights();\n  normalizeIncomingWeights();\n}\n", "docstring": "randomize and normalize weights .", "partition": "test"}
{"idx": "2875", "code": "private boolean isFileValid(File file,String methodName){\n  if (file == null) {\n    Log.printConcatLine(name,\".\",methodName,\": Warning - the given file is null.\");\n    return false;\n  }\n  String fileName=file.getName();\n  if (fileName == null || fileName.length() == 0) {\n    Log.printConcatLine(name,\".\" + methodName,\": Warning - invalid file name.\");\n    return false;\n  }\n  return true;\n}\n", "docstring": "check if the file is valid or not . this method checks whether the given file or the file name of the file is valid . the method name parameter is used for debugging purposes , to output in which method an error has occurred .", "partition": "test"}
{"idx": "2876", "code": "public void append(byte[] bytes){\n  append(bytes,0,bytes.length);\n}\n", "docstring": "append specified bytes to the buffer", "partition": "test"}
{"idx": "2877", "code": "public static boolean enoughSpaceOnPhone(long updateSize){\n  return getRealSizeOnPhone() > updateSize;\n}\n", "docstring": "checks if there is enough space on phone self", "partition": "test"}
{"idx": "2878", "code": "private Object stringToValue(Object oldValue,String newValue) throws ReplicatorException {\n  if (oldValue instanceof String) {\n    return newValue;\n  }\n else   if (oldValue instanceof Integer) {\n    return Integer.valueOf(newValue);\n  }\n else   if (oldValue instanceof SerialBlob) {\n    try {\n      return DatabaseHelper.getSafeBlob(newValue.getBytes());\n    }\n catch (    SQLException e) {\n      throw new ReplicatorException(\"Unable to convert back from String to SerialBlob: \" + e,e);\n    }\n  }\n else {\n    return newValue;\n  }\n}\n", "docstring": "converts string back to correct ( previous ) data type .", "partition": "test"}
{"idx": "2879", "code": "public String toZString(){\n  StringBuilder buffer=new StringBuilder(32);\n  try {\n    printZ(buffer);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Exception printing to StringBuilder\",e);\n  }\n  return buffer.toString();\n}\n", "docstring": "returns the string representation ( in ion format ) of this timestamp in utc .", "partition": "test"}
{"idx": "2880", "code": "public TrieDictionary<T> build(int baseId){\n  byte[] trieBytes=buildTrieBytes(baseId);\n  TrieDictionary<T> r=new TrieDictionary<T>(trieBytes);\n  return r;\n}\n", "docstring": "flatten the trie into a byte array for a minimized memory footprint . lookup remains fast . cost is inflexibility to modify ( becomes immutable ) . flattened node structure is head + nodes , for each node : - o byte , offset to child node , o = stats . mbpn_sizechildoffset - 1 bit , islastchild flag , the 1st msb of o - 1 bit , isendofvalue flag , the 2nd msb of o - c byte , number of values beneath , c = stats . mbpn_sizenovaluebeneath - 1 byte , number of value bytes - n byte , value bytes", "partition": "test"}
{"idx": "2881", "code": "public void recordState(DialogueState state,String name){\n  states.put(name,state);\n  if (!listModel.contains(name)) {\n    int position=name.contains(CURRENT) ? 0 : Math.min(2,listModel.size());\n    listModel.add(position,name);\n  }\n}\n", "docstring": "records a dialogue state in the component and makes it available for display in the network selection list on the left side . the network is associated with a specific name . if the name already exists , the previous network is erased .", "partition": "test"}
{"idx": "2882", "code": "public int writeUTF8(final CharSequence chars,int off,int len){\n  if (len > remaining()) {\n    return writeUTF8Slow(chars,off,len);\n  }\n  final Block block=current;\n  int limit=block.limit;\n  char ch=\'\\0\';\n  int octets=0;\n  while (len > 0) {\n    ch=chars.charAt(off);\n    if (ch >= UTF8_2_OCTET_MIN_VALUE) {\n      break;\n    }\n    block.data[limit++]=(byte)ch;\n    octets++;\n    off++;\n    len--;\n  }\n  block.limit=limit;\n  if (len > 0) {\n    if (ch < UTF8_3_OCTET_MIN_VALUE) {\n      return octets + writeUTF8UpTo2Byte(chars,off,len);\n    }\n    if (ch >= LOW_SURROGATE_FIRST && ch <= LOW_SURROGATE_LAST) {\n      throw new IllegalArgumentException(\"Unpaired low surrogate: \" + ch);\n    }\n    if (ch >= HIGH_SURROGATE_FIRST && ch <= HIGH_SURROGATE_LAST) {\n      return octets + writeUTF8Slow(chars,off,len);\n    }\n    return octets + writeUTF8UpTo3Byte(chars,off,len);\n  }\n  return octets;\n}\n", "docstring": "returns the number of octets written .", "partition": "test"}
{"idx": "2883", "code": "public GeoServerWPSClient(GeoServerConnection connection){\n  this.connection=connection;\n}\n", "docstring": "instantiates a new geo server wps client .", "partition": "test"}
{"idx": "2884", "code": "protected ConnectionStateSSLv3(SSLSessionImpl session){\n  try {\n    CipherSuite cipherSuite=session.cipherSuite;\n    boolean is_exportabe=cipherSuite.isExportable();\n    hash_size=cipherSuite.getMACLength();\n    int key_size=(is_exportabe) ? cipherSuite.keyMaterial : cipherSuite.expandedKeyMaterial;\n    int iv_size=cipherSuite.ivSize;\n    block_size=cipherSuite.getBlockSize();\n    String algName=cipherSuite.getBulkEncryptionAlgorithm();\n    String hashName=cipherSuite.getHashName();\n    if (logger != null) {\n      logger.println(\"ConnectionStateSSLv3.create:\");\n      logger.println(\"  cipher suite name: \" + session.getCipherSuite());\n      logger.println(\"  encryption alg name: \" + algName);\n      logger.println(\"  hash alg name: \" + hashName);\n      logger.println(\"  hash size: \" + hash_size);\n      logger.println(\"  block size: \" + block_size);\n      logger.println(\"  IV size:\" + iv_size);\n      logger.println(\"  key size: \" + key_size);\n    }\n    byte[] clientRandom=session.clientRandom;\n    byte[] serverRandom=session.serverRandom;\n    byte[] key_block=new byte[2 * hash_size + 2 * key_size + 2 * iv_size];\n    byte[] seed=new byte[clientRandom.length + serverRandom.length];\n    System.arraycopy(serverRandom,0,seed,0,serverRandom.length);\n    System.arraycopy(clientRandom,0,seed,serverRandom.length,clientRandom.length);\n    PRF.computePRF_SSLv3(key_block,session.master_secret,seed);\n    byte[] client_mac_secret=new byte[hash_size];\n    byte[] server_mac_secret=new byte[hash_size];\n    byte[] client_key=new byte[key_size];\n    byte[] server_key=new byte[key_size];\n    boolean is_client=!session.isServer;\n    System.arraycopy(key_block,0,client_mac_secret,0,hash_size);\n    System.arraycopy(key_block,hash_size,server_mac_secret,0,hash_size);\n    System.arraycopy(key_block,2 * hash_size,client_key,0,key_size);\n    System.arraycopy(key_block,2 * hash_size + key_size,server_key,0,key_size);\n    IvParameterSpec clientIV=null;\n    IvParameterSpec serverIV=null;\n    if (is_exportabe) {\n      if (logger != null) {\n        logger.println(\"ConnectionStateSSLv3: is_exportable\");\n      }\n      MessageDigest md5=MessageDigest.getInstance(\"MD5\");\n      md5.update(client_key);\n      md5.update(clientRandom);\n      md5.update(serverRandom);\n      client_key=md5.digest();\n      md5.update(server_key);\n      md5.update(serverRandom);\n      md5.update(clientRandom);\n      server_key=md5.digest();\n      key_size=cipherSuite.expandedKeyMaterial;\n      if (block_size != 0) {\n        md5.update(clientRandom);\n        md5.update(serverRandom);\n        clientIV=new IvParameterSpec(md5.digest(),0,iv_size);\n        md5.update(serverRandom);\n        md5.update(clientRandom);\n        serverIV=new IvParameterSpec(md5.digest(),0,iv_size);\n      }\n    }\n else     if (block_size != 0) {\n      clientIV=new IvParameterSpec(key_block,2 * hash_size + 2 * key_size,iv_size);\n      serverIV=new IvParameterSpec(key_block,2 * hash_size + 2 * key_size + iv_size,iv_size);\n    }\n    if (logger != null) {\n      logger.println(\"is exportable: \" + is_exportabe);\n      logger.println(\"master_secret\");\n      logger.print(session.master_secret);\n      logger.println(\"client_random\");\n      logger.print(clientRandom);\n      logger.println(\"server_random\");\n      logger.print(serverRandom);\n      logger.println(\"client_mac_secret\");\n      logger.print(client_mac_secret);\n      logger.println(\"server_mac_secret\");\n      logger.print(server_mac_secret);\n      logger.println(\"client_key\");\n      logger.print(client_key,0,key_size);\n      logger.println(\"server_key\");\n      logger.print(server_key,0,key_size);\n      if (clientIV != null) {\n        logger.println(\"client_iv\");\n        logger.print(clientIV.getIV());\n        logger.println(\"server_iv\");\n        logger.print(serverIV.getIV());\n      }\n else {\n        logger.println(\"no IV.\");\n      }\n    }\n    if (algName == null) {\n      encCipher=new NullCipher();\n      decCipher=new NullCipher();\n    }\n else {\n      encCipher=Cipher.getInstance(algName);\n      decCipher=Cipher.getInstance(algName);\n      if (is_client) {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(client_key,0,key_size,algName),clientIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(server_key,0,key_size,algName),serverIV);\n      }\n else {\n        encCipher.init(Cipher.ENCRYPT_MODE,new SecretKeySpec(server_key,0,key_size,algName),serverIV);\n        decCipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(client_key,0,key_size,algName),clientIV);\n      }\n    }\n    messageDigest=MessageDigest.getInstance(hashName);\n    if (is_client) {\n      mac_write_secret=client_mac_secret;\n      mac_read_secret=server_mac_secret;\n    }\n else {\n      mac_write_secret=server_mac_secret;\n      mac_read_secret=client_mac_secret;\n    }\n    if (hashName.equals(\"MD5\")) {\n      pad_1=SSLv3Constants.MD5pad1;\n      pad_2=SSLv3Constants.MD5pad2;\n    }\n else {\n      pad_1=SSLv3Constants.SHApad1;\n      pad_2=SSLv3Constants.SHApad2;\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new AlertException(AlertProtocol.INTERNAL_ERROR,new SSLProtocolException(\"Error during computation of security parameters\"));\n  }\n}\n", "docstring": "creates the instance of ssl v3 connection state . all of the security parameters are provided by session object .", "partition": "test"}
{"idx": "2885", "code": "long cleanup(long now){\n  int inUseConnectionCount=0;\n  int idleConnectionCount=0;\n  RealConnection longestIdleConnection=null;\n  long longestIdleDurationNs=Long.MIN_VALUE;\nsynchronized (this) {\n    for (Iterator<RealConnection> i=connections.iterator(); i.hasNext(); ) {\n      RealConnection connection=i.next();\n      if (pruneAndGetAllocationCount(connection,now) > 0) {\n        inUseConnectionCount++;\n        continue;\n      }\n      idleConnectionCount++;\n      long idleDurationNs=now - connection.idleAtNanos;\n      if (idleDurationNs > longestIdleDurationNs) {\n        longestIdleDurationNs=idleDurationNs;\n        longestIdleConnection=connection;\n      }\n    }\n    if (longestIdleDurationNs >= this.keepAliveDurationNs || idleConnectionCount > this.maxIdleConnections) {\n      connections.remove(longestIdleConnection);\n    }\n else     if (idleConnectionCount > 0) {\n      return keepAliveDurationNs - longestIdleDurationNs;\n    }\n else     if (inUseConnectionCount > 0) {\n      return keepAliveDurationNs;\n    }\n else {\n      cleanupRunning=false;\n      return -1;\n    }\n  }\n  closeQuietly(longestIdleConnection.socket());\n  return 0;\n}\n", "docstring": "performs maintenance on this pool , evicting the connection that has been idle the longest if either it has exceeded the keep alive limit or the idle connections limit . < p > returns the duration in nanos to sleep until the next scheduled call to this method . returns - 1 if no further cleanups are required .", "partition": "test"}
{"idx": "2886", "code": "public StateInfo(){\n}\n", "docstring": "creates a new stateinfo .", "partition": "test"}
{"idx": "2887", "code": "public boolean compare(Object expected,Object current){\n  if (current != null) {\n    equal=current.equals(expected);\n  }\n else   if (expected != null) {\n    equal=expected.equals(1.0);\n  }\n  return equal;\n}\n", "docstring": "this is used to compare the expected and current versions of the class . once compared the comparison result is cached within the revision class so that it can be used repeatedly .", "partition": "test"}
{"idx": "2888", "code": "public static byte[] decode(String hexa) throws CoderException {\n  if (hexa == null) {\n    throw new CoderException(\"can\'t decode empty String\");\n  }\n  if ((hexa.length() % 2) != 0) {\n    throw new CoderException(\"invalid hexadicimal String\");\n  }\n  int tamArray=hexa.length() / 2;\n  byte[] retorno=new byte[tamArray];\n  for (int i=0; i < tamArray; i++) {\n    retorno[i]=hexToByte(hexa.substring(i * 2,i * 2 + 2));\n  }\n  return retorno;\n}\n", "docstring": "decodes back a string to a byte array", "partition": "test"}
{"idx": "2889", "code": "private List<UserNamespaceAuthorization> createUserNamespaceAuthorizationsFromEntities(List<UserNamespaceAuthorizationEntity> userNamespaceAuthorizationEntities){\n  List<UserNamespaceAuthorization> userNamespaceAuthorizations=new ArrayList<>();\n  for (  UserNamespaceAuthorizationEntity userNamespaceAuthorizationEntity : userNamespaceAuthorizationEntities) {\n    userNamespaceAuthorizations.add(createUserNamespaceAuthorizationFromEntity(userNamespaceAuthorizationEntity));\n  }\n  return userNamespaceAuthorizations;\n}\n", "docstring": "creates a list of user namespace authorizations from the list of persisted entities .", "partition": "test"}
{"idx": "2890", "code": "private void readHeader() throws OpenStegoException {\n  this.dataHeader=new DCTDataHeader(this,this.config);\n}\n", "docstring": "method to read header data from the input stream", "partition": "test"}
{"idx": "2891", "code": "protected void drawText(String text1,String text2,int x,int y,Canvas c){\n  if (textPaint == null) {\n    Paint p=new Paint();\n    p.setTypeface(RobotoLightTypeface.getInstance(context));\n    p.setColor(textColor);\n    p.setTextSize(14 * pixelDensity);\n    this.textPaint=p;\n  }\n  float w=textPaint.measureText(text1,0,text1.length());\n  int offset=(int)w / 2;\n  c.drawText(text1,x - offset,y + (18f * pixelDensity),textPaint);\n  w=textPaint.measureText(text2,0,text2.length());\n  offset=(int)w / 2;\n  c.drawText(text2,x - offset,y + (36f * pixelDensity),textPaint);\n}\n", "docstring": "draw the text under the graphics", "partition": "test"}
{"idx": "2892", "code": "public boolean isLessThenOrEqualTo(Percent Percent){\n  assertDefined();\n  BigDecimal thisValue=notNull(this);\n  BigDecimal parameter=notNull(Percent);\n  return (thisValue.compareTo(parameter) <= 0);\n}\n", "docstring": "compares two percent objects .", "partition": "test"}
{"idx": "2893", "code": "public static boolean pointOutsidePrefSize(JTable table,int row,int column,Point p){\n  if (table.convertColumnIndexToModel(column) != 0 || row == -1) {\n    return true;\n  }\n  TableCellRenderer tcr=table.getCellRenderer(row,column);\n  Object value=table.getValueAt(row,column);\n  Component cell=tcr.getTableCellRendererComponent(table,value,false,false,row,column);\n  Dimension itemSize=cell.getPreferredSize();\n  Rectangle cellBounds=table.getCellRect(row,column,false);\n  cellBounds.width=itemSize.width;\n  cellBounds.height=itemSize.height;\n  assert (p.x >= cellBounds.x && p.y >= cellBounds.y);\n  return p.x > cellBounds.x + cellBounds.width || p.y > cellBounds.y + cellBounds.height;\n}\n", "docstring": "returns true if the given point is outside the preferredsize of the item at the given row of the table . ( column must be 0 ) . does not check the \" table . isfilelist \" property . that should be checked before calling this method . this is used to make windowsl & f jfilechooser act like native dialogs .", "partition": "test"}
{"idx": "2894", "code": "public Builder addSourceFolder(@NonNull File folder){\n  foldersToScan.add(folder);\n  return this;\n}\n", "docstring": "root folder for labels - > documents . each subfolder name will be presented as label , and contents of this folder will be represented as labelleddocument , with label attached", "partition": "test"}
{"idx": "2895", "code": "public Method suspendSRDFGroupMethod(final URI systemURI,final RemoteDirectorGroup group,final List<URI> sourceVolumes,final List<URI> targetVolumes){\n  return new Workflow.Method(SUSPEND_SRDF_GROUP_METHOD,systemURI,group,sourceVolumes,targetVolumes);\n}\n", "docstring": "returns a workflow . method for suspending srdf group", "partition": "test"}
{"idx": "2896", "code": "private void fieldGoalAtt(Team offense,Team defense){\n  double fgDistRatio=Math.pow((110 - gameYardLine) / 50,2);\n  double fgAccRatio=Math.pow((110 - gameYardLine) / 50,1.25);\n  double fgDistChance=(getHFadv() + offense.getK(0).ratKickPow - fgDistRatio * 80);\n  double fgAccChance=(getHFadv() + offense.getK(0).ratKickAcc - fgAccRatio * 80);\n  if (fgDistChance > 20 && fgAccChance * Math.random() > 15) {\n    if (gamePoss) {\n      homeScore+=3;\n      HomeKStats[3]++;\n      HomeKStats[2]++;\n    }\n else {\n      awayScore+=3;\n      AwayKStats[3]++;\n      AwayKStats[2]++;\n    }\n    gameEventLog+=getEventPrefix() + offense.abbr + \" K \"+ offense.getK(0).name+ \" made the \"+ (110 - gameYardLine)+ \" yard FG.\";\n    addPointsQuarter(3);\n    offense.getK(0).statsFGMade++;\n    offense.getK(0).statsFGAtt++;\n    if (!playingOT)     kickOff(offense);\n else     resetForOT();\n  }\n else {\n    gameEventLog+=getEventPrefix() + offense.abbr + \" K \"+ offense.getK(0).name+ \" missed the \"+ (110 - gameYardLine)+ \" yard FG.\";\n    offense.getK(0).statsFGAtt++;\n    if (!playingOT) {\n      gameYardLine=Math.max(100 - gameYardLine,20);\n      gameDown=1;\n      gameYardsNeed=10;\n      if (gamePoss) {\n        HomeKStats[3]++;\n      }\n else {\n        AwayKStats[3]++;\n      }\n      gamePoss=!gamePoss;\n    }\n else     resetForOT();\n  }\n  gameTime-=20;\n}\n", "docstring": "attempt a field goal using the offense \"'\" s kicker . if successful , add 3 points and kick off . if not , turn the ball over .", "partition": "test"}
{"idx": "2897", "code": "@Override public double calculateM(double delta,double epsilon){\n  double i=1;\n  while (conf(i,delta) > epsilon / 2.0d) {\n    i=i + 10000;\n  }\n  if (i > 1) {\n    i=i - 10000;\n  }\n  while (conf(i,delta) > (epsilon / 2.0d)) {\n    i++;\n  }\n  return Math.ceil(i);\n}\n", "docstring": "calculates the m - value needed for the gss algorithm .", "partition": "test"}
{"idx": "2898", "code": "public static ServerSocket createServerSocket(int port,InetAddress bindAddress) throws IOException {\n  ServerSocket socket=null;\n  if (SysProperties.ENABLE_ANONYMOUS_TLS) {\n    removeAnonFromLegacyAlgorithms();\n  }\n  setKeystore();\n  ServerSocketFactory f=SSLServerSocketFactory.getDefault();\n  SSLServerSocket secureSocket;\n  if (bindAddress == null) {\n    secureSocket=(SSLServerSocket)f.createServerSocket(port);\n  }\n else {\n    secureSocket=(SSLServerSocket)f.createServerSocket(port,0,bindAddress);\n  }\n  secureSocket.setEnabledProtocols(disableSSL(secureSocket.getEnabledProtocols()));\n  if (SysProperties.ENABLE_ANONYMOUS_TLS) {\n    String[] list=enableAnonymous(secureSocket.getEnabledCipherSuites(),secureSocket.getSupportedCipherSuites());\n    secureSocket.setEnabledCipherSuites(list);\n  }\n  socket=secureSocket;\n  return socket;\n}\n", "docstring": "create a secure server socket . if a bind address is specified , the socket is only bound to this address . if h2 . enableanonymoustls is true , an attempt is made to modify the security property jdk . tls . legacyalgorithms ( in newer jvms ) to allow anonymous tls . this system change is effectively permanent for the lifetime of the jvm .", "partition": "test"}
{"idx": "2899", "code": "public void printBytes(byte[] data,int offset,int length) throws IOException {\n  int i;\n  for (; length >= 3; length-=3) {\n    int chunk=(((data[offset] & 0xff) << 16) + ((data[offset + 1] & 0xff) << 8) + (data[offset + 2] & 0xff));\n    os.write(base64encode(chunk >> 18));\n    os.write(base64encode(chunk >> 12));\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    offset+=3;\n  }\n  if (length == 2) {\n    int chunk=((data[offset] & 0xff) << 8) + (data[offset + 1] & 0xff);\n    os.write(base64encode(chunk >> 12));\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    os.write('=');\n  }\n else   if (length == 1) {\n    int chunk=data[offset] & 0xff;\n    os.write(base64encode(chunk >> 6));\n    os.write(base64encode(chunk));\n    os.write('=');\n    os.write('=');\n  }\n}\n", "docstring": "prints a byte array to the stream , properly encoded in base64 .", "partition": "test"}
{"idx": "2900", "code": "public void deleteVVset(String nativeId) throws Exception {\n  _log.info(\"3PARDriver: deleteVVset enter\");\n  ClientResponse clientResp=null;\n  final String path=MessageFormat.format(URI_DELETE_CG,nativeId);\n  _log.info(\"3PARDriver:deleteVVset running delete VV Set \" + path);\n  try {\n    clientResp=delete(path);\n    if (clientResp == null) {\n      _log.error(\"3PARDriver:deleteVVset There is no response from 3PAR\");\n      throw new HP3PARException(\"There is no response from 3PAR\");\n    }\n else     if (clientResp.getStatus() != 200) {\n      String errResp=getResponseDetails(clientResp);\n      throw new HP3PARException(errResp);\n    }\n else {\n      _log.info(\"3PARDriver: deleteVVset success\");\n    }\n  }\n catch (  Exception e) {\n    throw e;\n  }\n finally {\n    if (clientResp != null) {\n      clientResp.close();\n    }\n    _log.info(\"3PARDriver:deleteVVset leave\");\n  }\n}\n", "docstring": "delete a vv set or consistency group", "partition": "test"}
{"idx": "2901", "code": "private int findKeyCommentIndex(String keyName){\n  for (int i=0; i < keyValComments.size(); i++) {\n    String t=keyValComments.get(i);\n    String targetedKey=\"! \" + keyName + \": \";\n    if (t.startsWith(targetedKey)) {\n      return i;\n    }\n  }\n  if (log.isDebugEnabled()) {\n    log.debug(\"Did not find key \" + keyName);\n  }\n  return -1;\n}\n", "docstring": "finds the index of the specified key within the array containing key / value comments", "partition": "test"}
{"idx": "2902", "code": "public boolean isExpired(){\n  return (cookieExpiryDate != null && cookieExpiryDate.getTime() <= System.currentTimeMillis());\n}\n", "docstring": "returns true if this cookie has expired .", "partition": "test"}
{"idx": "2903", "code": "InMemoryEntryStore(){\n  entries=Maps.newHashMap();\n  topLevelEntries=Sets.newHashSet();\n  children=HashMultimap.create();\n}\n", "docstring": "creates a new inmemoryentrystore which provides constant time storage and retrieval of entries by id or parent id .", "partition": "test"}
{"idx": "2904", "code": "public ClassAnnotator(URL[] codebase,Properties props){\n  if (props != null)   properties.putAll(props);\n  setAnnotationURLs(codebase);\n}\n", "docstring": "constructs a new classannotator for the specified codebase urls", "partition": "test"}
{"idx": "2905", "code": "public int next(){\n  return mix(gen.getAndIncrement());\n}\n", "docstring": "produce the next identifier .", "partition": "test"}
{"idx": "2906", "code": "public InputStream put(final URLConnection connection,final boolean flushCacheOnClose){\n  final String key=getKey(connection);\n  if (key == null)   return null;\n  if (!isCacheable((HttpURLConnection)connection))   try {\n    cache.remove(key);\n    return null;\n  }\n catch (  IOException e) {\n    return null;\n  }\n  String etag=connection.getHeaderField(HEADER_ETAG);\n  if (etag == null || etag.length() == 0)   return null;\n  Editor editor;\n  try {\n    editor=cache.edit(key);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  if (editor == null)   return null;\n  try {\n    editor.set(ETAG,etag);\n  }\n catch (  IOException e) {\n    try {\n      editor.abort();\n    }\n catch (    IOException ignored) {\n    }\n    return null;\n  }\n  InputStream input;\n  try {\n    input=connection.getInputStream();\n    if (!(input instanceof InflaterInputStream) && ENCODING_GZIP.equals(connection.getHeaderField(HEADER_CONTENT_ENCODING)))     input=new GZIPInputStream(input);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  OutputStream output;\n  try {\n    output=editor.newOutputStream(BODY);\n  }\n catch (  IOException e) {\n    return null;\n  }\n  if (output != null)   return new CacheStream(input,output,editor,this,flushCacheOnClose);\n else   return null;\n}\n", "docstring": "create stream that will be cached after it is read", "partition": "test"}
{"idx": "2907", "code": "public static String[] parseTitle(String title){\n  String v[]={\"\",\"\"};\n  if (title == null)   return v;\n  Pattern p=Pattern.compile(\"(.*)\\\\s+\\\\(?([0-9]{4})\\\\)?\",Pattern.CASE_INSENSITIVE);\n  Matcher m=p.matcher(title);\n  if (m.find()) {\n    v[0]=m.group(1);\n    v[1]=m.group(2);\n  }\n else {\n    v[0]=title;\n  }\n  return v;\n}\n", "docstring": "return a 2 element array . 0 = title ; 1 = date parses the title in the format title year or title ( year )", "partition": "test"}
{"idx": "2908", "code": "public String sel(){\n  return mSelection.toString();\n}\n", "docstring": "returns the selection produced by this object .", "partition": "test"}
{"idx": "2909", "code": "public double calculateExcitatoryRatio(){\n  excitatoryRatio=exSynapseSet.size() / (double)size();\n  if (Double.isNaN(excitatoryRatio)) {\n    return 0;\n  }\n  return excitatoryRatio;\n}\n", "docstring": "if a randomize operation changes the ratio of excitatory to inhibitory synapses , this method can be called to change the excitatoryratio to reflect this value . this happens rarely , and generally speaking is not recommended outside prototyping .", "partition": "test"}
{"idx": "2910", "code": "public void rootRemoved(ISVNRepositoryLocation root){\n  Iterator it=listeners.iterator();\n  while (it.hasNext()) {\n    IRepositoryListener listener=(IRepositoryListener)it.next();\n    listener.repositoryRemoved(root);\n  }\n}\n", "docstring": "a repository root has been removed .", "partition": "test"}
{"idx": "2911", "code": "public synchronized void insert(double _priority,Object _data){\n  numElements++;\n  if (numElements == queue.length) {\n    PriorityQueueNode[] tmp=new PriorityQueueNode[(int)(queue.length * 1.5)];\n    System.arraycopy(queue,0,tmp,0,queue.length);\n    for (int i=queue.length; i < tmp.length; i++) {\n      tmp[i]=new PriorityQueueNode();\n    }\n    queue=tmp;\n  }\n  queue[numElements].data=_data;\n  queue[numElements].priority=_priority;\n  reheapify(numElements);\n}\n", "docstring": "insert the object passed with the priority value passed", "partition": "test"}
{"idx": "2912", "code": "protected Message(){\n}\n", "docstring": "creates a new message with no specified message type .", "partition": "test"}
{"idx": "2913", "code": "protected String wrapLinuxCommand(String command) throws IOException, InterruptedException {\n  String setGroup=\"export GROUP_NAME=`(getent group \" + getGid() + \" || (groupadd -g \"+ getGid()+ \" user && echo user:x:\"+ getGid()+ \")) | cut -d: -f1`\";\n  String setUser=\"export USER_NAME=`(getent passwd \" + getUid() + \" || (useradd -u \"+ getUid()+ \" -g ${GROUP_NAME} user && echo user:x:\"+ getGid()+ \")) | cut -d: -f1`\";\n  String chownCommand=\"chown --silent -R ${USER_NAME}.${GROUP_NAME} /usr/src/app || true\";\n  return setGroup + \" && \" + setUser+ \" && \"+ chownCommand+ \" && \"+ command+ \" && \"+ chownCommand;\n}\n", "docstring": "wrap the given command into a command with chown . also add group / user that match host environment if not exists", "partition": "test"}
{"idx": "2914", "code": "public AbstractDMLQuery parseSqlQuery(SQLQuery sqlQuery,ISpaceProxy space) throws SQLException {\n  AbstractDMLQuery query=(AbstractDMLQuery)getQueryFromCache(getUniqueKey(sqlQuery));\n  try {\n    if (query == null) {\n      if (_logger.isLoggable(Level.FINE)) {\n        _logger.fine(\"Query wasn\'t in cache, will be parsed\");\n      }\n      SqlParser parser=initParser(sqlQuery.getQuery());\n      query=parse(parser);\n      query.setTableName(sqlQuery.getTypeName());\n      query.validateQuery(space);\n      if (!query.isPrepared() && !query.containsSubQueries())       query.build();\n      addQueryToCache(getUniqueKey(sqlQuery),query);\n      if (!query.isPrepared())       return query;\n    }\n    query=query.clone();\n    return query;\n  }\n catch (  SQLException sqlEx) {\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.log(Level.FINE,\"Error executing statement [\" + sqlQuery.getQuery() + \"]\",sqlEx);\n    }\n    throw sqlEx;\n  }\ncatch (  Throwable t) {\n    if (_logger.isLoggable(Level.FINE)) {\n      _logger.log(Level.FINE,\"Couldn\'t parse given statement [\" + sqlQuery.getQuery() + \"]\",t);\n    }\n    SQLException sqlEx=new SQLException(\"Error in statement [\" + sqlQuery.getQuery() + \"]; Cause: \"+ t,\"GSP\",-201);\n    sqlEx.initCause(t);\n    throw sqlEx;\n  }\n}\n", "docstring": "the main method to handle the query . first it will try to retrieve the query from the cache , if its not there , it will build a parser to parse the statement and then put it in the cache .", "partition": "test"}
{"idx": "2915", "code": "private int indexOfElementInLevel(int element,int level[]) throws Exception {\n  for (int i=0; i < level.length; i++) {\n    if (level[i] == element) {\n      return i;\n    }\n  }\n  throw new Exception(\"Error. Didn\'t find element \" + m_nodes.get(element).ID + \" in level. Inspect code for \"+ \"weka.gui.graphvisualizer.HierarchicalBCEngine\");\n}\n", "docstring": "returns the index of an element in a level . must never be called with the wrong element and the wrong level , will throw an exception otherwise . it takes as agrument the index of the element ( in the m_nodes vector ) and the level it is supposed to be in ( as each level contains the indices of the nodes present in that level ) .", "partition": "test"}
{"idx": "2916", "code": "public int size(){\n  return _attrs.size();\n}\n", "docstring": "get the number of attributes in the attribute set", "partition": "test"}
{"idx": "2917", "code": "public void deepSort(int[] setFeatureSequence){\n  featureSequence=setFeatureSequence;\n  numberOfLeaves=0;\n  tree=new MaryNode(0,featureVectors.length);\n  sortNode(0,tree);\n}\n", "docstring": "launches a deep sort on the array of feature vectors . this is public because it can be used to re - index the previously read feature file .", "partition": "test"}
{"idx": "2918", "code": "public void removeListeners(){\n  listeners.clear();\n}\n", "docstring": "remove all existing listeners .", "partition": "test"}
{"idx": "2919", "code": "public String decrypt(String sCipherText){\n  int nLen=(sCipherText.length() >> 1) & ~7;\n  if (nLen < BlowfishECB.BLOCKSIZE)   return null;\n  byte[] cbciv=new byte[BlowfishECB.BLOCKSIZE];\n  int nNumOfBytes=BinConverter.binHexToBytes(sCipherText,cbciv,0,0,BlowfishECB.BLOCKSIZE);\n  if (nNumOfBytes < BlowfishECB.BLOCKSIZE)   return null;\n  m_bfish.setCBCIV(cbciv);\n  nLen-=BlowfishECB.BLOCKSIZE;\n  if (nLen == 0)   return \"\";\n  byte[] buf=new byte[nLen];\n  nNumOfBytes=BinConverter.binHexToBytes(sCipherText,buf,BlowfishECB.BLOCKSIZE * 2,0,nLen);\n  if (nNumOfBytes < nLen)   return null;\n  m_bfish.decrypt(buf);\n  int nPadByte=buf[buf.length - 1] & 0x0ff;\n  if ((nPadByte > 8) || (nPadByte < 0))   nPadByte=0;\n  nNumOfBytes-=nPadByte;\n  if (nNumOfBytes < 0)   return \"\";\n  return BinConverter.byteArrayToUNCString(buf,0,nNumOfBytes);\n}\n", "docstring": "decrypts a hexbin string ( handling is case sensitive )", "partition": "test"}
{"idx": "2920", "code": "public static double L_RankLoss(int y[],int r[]){\n  int L=y.length;\n  ArrayList<Integer> tI=new ArrayList<Integer>();\n  ArrayList<Integer> fI=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      tI.add(j);\n    }\n else {\n      fI.add(j);\n    }\n  }\n  if (!tI.isEmpty() && !fI.isEmpty()) {\n    int c=0;\n    for (    int k : tI) {\n      for (      int l : fI) {\n        if (position(k,r) < position(l,r)) {\n          c++;\n        }\n      }\n    }\n    return (double)c / (double)(tI.size() * fI.size());\n  }\n else {\n    return 0.0;\n  }\n}\n", "docstring": "rank loss - the average fraction of labels which are not correctly ordered . thanks to noureddine yacine nair benrekia for providing bug fix for this .", "partition": "test"}
{"idx": "2921", "code": "private double addRecursively(ArrayList<double[]> hull,Hierarchy<Cluster<Model>> hier,Cluster<Model> clus){\n  final DBIDs ids=clus.getIDs();\n  double weight=ids.size();\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    double[] projP=proj.fastProjectDataToRenderSpace(rel.get(iter));\n    if (projP[0] != projP[0] || projP[1] != projP[1]) {\n      continue;\n    }\n    hull.add(projP);\n  }\n  for (Iter<Cluster<Model>> iter=hier.iterChildren(clus); iter.valid(); iter.advance()) {\n    weight+=.5 * addRecursively(hull,hier,iter.get());\n  }\n  return weight;\n}\n", "docstring": "recursively add a cluster and its children .", "partition": "test"}
{"idx": "2922", "code": "public void attributeUpdate(PrintServiceAttributeEvent psae){\n  log.fine(\"attributeUpdate - \" + psae);\n}\n", "docstring": "print service attribute listener .", "partition": "test"}
{"idx": "2923", "code": "public void evict() throws Exception {\n  assertOpen();\n  boolean isEmpty;\nsynchronized (this) {\n    isEmpty=pool.isEmpty();\n  }\n  if (!isEmpty) {\n    if (softMinEvictableIdleTimeMillis > 0) {\n      int numToEvict=getNumIdle() - getMinIdle();\n      evict(System.currentTimeMillis() - softMinEvictableIdleTimeMillis,numToEvict);\n    }\n    if (minEvictableIdleTimeMillis > 0) {\n      int numToEvict=getNumIdle();\n      evict(System.currentTimeMillis() - minEvictableIdleTimeMillis,numToEvict);\n    }\n  }\n}\n", "docstring": "make one pass of the idle object evictor .", "partition": "test"}
{"idx": "2924", "code": "protected void generateRandomPopulation(int population_size){\n  logger.debug(\"Creating random population\");\n  for (int i=0; i < population_size; i++) {\n    T individual=chromosomeFactory.getChromosome();\n    for (    FitnessFunction<?> fitnessFunction : this.fitnessFunctions) {\n      individual.addFitness(fitnessFunction);\n    }\n    population.add(individual);\n    if (isFinished())     break;\n  }\n  logger.debug(\"Created \" + population.size() + \" individuals\");\n}\n", "docstring": "generate random population of given size", "partition": "test"}
{"idx": "2925", "code": "public Session(){\n  long uptime=System.currentTimeMillis();\n  mMainHandler=new Handler(Looper.getMainLooper());\n  mTimestamp=(uptime / 1000) << 32 & (((uptime - ((uptime / 1000) * 1000)) >> 32) / 1000);\n  mOrigin=\"127.0.0.1\";\n  try {\n    sSignal.await();\n  }\n catch (  InterruptedException e) {\n  }\n}\n", "docstring": "creates a streaming session that can be customized by adding tracks .", "partition": "test"}
{"idx": "2926", "code": "public List<Visitante> listar(){\n  List<Visitante> dados=new ArrayList<>();\n  try {\n    String sql=\"SELECT tb_visitantes.* FROM tb_visitantes \";\n    stm=conector.prepareStatement(sql);\n    rs=stm.executeQuery(sql);\n    while (rs.next()) {\n      dados.add(new Visitante(rs.getInt(1),rs.getString(2),rs.getString(3),rs.getString(4),rs.getString(5),rs.getString(6),Tempo.toDate(rs.getTimestamp(7)),rs.getString(8),rs.getString(9)));\n    }\n    stm.close();\n    rs.close();\n  }\n catch (  SQLException ex) {\n    Mensagem.erro(\"Erro ao consultar visitantes na base de dados! \\n\" + ex);\n  }\n  return dados;\n}\n", "docstring": "consultar todos visitantes cadastrdos na base de dados", "partition": "test"}
{"idx": "2927", "code": "private void insertBefore(Instruction[] list,Instruction s){\n  for (  Instruction x : list) {\n    s.insertBefore(x);\n  }\n}\n", "docstring": "inserts each instruction in a list before another instruction .", "partition": "test"}
{"idx": "2928", "code": "public int countArray(String[] array){\n  return array.length;\n}\n", "docstring": "counts the size of an array .", "partition": "test"}
{"idx": "2929", "code": "private void processUnprocessed(){\n  boolean clean_processings=Boolean.getBoolean(\"Archive.processings.clean\");\n  logger.info(\"Archives processing clean instead of recovery \" + \"(Archive.processings.clean) requested by user (\" + clean_processings + \")\");\n  productService.processUnprocessed(!clean_processings);\n}\n", "docstring": "run recovery of stopped scanners . warning : do never perform archive . check when recovery is expected . this may cause data lost .", "partition": "test"}
{"idx": "2930", "code": "public double[] popy(double x_[]){\n  return popY(new double[][]{x_})[0];\n}\n", "docstring": "forward pass - given input x_ , get output y_ .", "partition": "test"}
{"idx": "2931", "code": "public void gotoFrame(int frameNumber) throws IOException {\n  print(\"gotoFrame\",new String[]{Integer.toString(frameNumber)});\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "2932", "code": "public void delete(String name) throws IOException {\n  if (name.equalsIgnoreCase(SUBJECT_NAME)) {\n    names=null;\n  }\n else {\n    throw new IOException(\"Attribute name not recognized by \" + \"CertAttrSet:SubjectAlternativeName.\");\n  }\n  encodeThis();\n}\n", "docstring": "delete the attribute value .", "partition": "test"}
{"idx": "2933", "code": "public GeoDistanceBuilder addUnboundedFrom(String key,double from){\n  ranges.add(new Range(key,from,null));\n  return this;\n}\n", "docstring": "add a new range with no upper bound .", "partition": "test"}
{"idx": "2934", "code": "private void sendResponse(Document doc,MessageFactory messageFactory,String contentType,HttpServletResponse res) throws IOException, SOAPException {\n  SOAPMessage reply=messageFactory.createMessage();\n  SOAPHeader header=reply.getSOAPHeader();\n  header.detachNode();\n  SOAPBody replyBody=reply.getSOAPBody();\n  res.setHeader(\"Content-Type\",contentType);\n  replyBody.addDocument(doc);\n  reply.saveChanges();\n  OutputStream os=res.getOutputStream();\n  reply.writeTo(os);\n  os.flush();\n}\n", "docstring": "send a response back to the client . this could be either a soap fault or a correct dsml response .", "partition": "test"}
{"idx": "2935", "code": "public static String replaceChars(String str,String oldchars,char newchar){\n  int pos=indexOfChars(str,oldchars);\n  if (pos == -1) {\n    return str;\n  }\n  StringBuilder buf=new StringBuilder(str);\n  do {\n    buf.setCharAt(pos,newchar);\n    pos=indexOfChars(str,oldchars,pos + 1);\n  }\n while (pos != -1);\n  return buf.toString();\n}\n", "docstring": "like string . replace ( ) except that it accepts any number of old chars . replaces any occurrances of \"'\" oldchars \"'\" in \"'\" str \"'\" with \"'\" newchar \"'\" . example : replacechars ( \" hello , world ! \" , \" h , ! \" , \"'\" \"'\" ) returns \" ello world \"", "partition": "test"}
{"idx": "2936", "code": "public InMemoryMessageExchangeStore(final NetworkConfig config,TokenProvider tokenProvider){\n  if (config == null) {\n    throw new NullPointerException(\"Configuration must not be null\");\n  }\n  if (tokenProvider == null) {\n    throw new NullPointerException(\"TokenProvider must not be null\");\n  }\n  this.tokenProvider=tokenProvider;\n  this.config=config;\n}\n", "docstring": "creates a new store for configuration values .", "partition": "test"}
{"idx": "2937", "code": "public static void next(){\n  try {\n    if (musicPlaybackService != null) {\n      musicPlaybackService.next();\n    }\n  }\n catch (  final RemoteException ignored) {\n  }\n}\n", "docstring": "changes to the next track", "partition": "test"}
{"idx": "2938", "code": "private void drawBitmapWithStroke(Canvas canvas,Bitmap bitmap,int centerX,int centerY,float radius,Paint drawPaint){\n  drawPaint.setStyle(Paint.Style.FILL);\n  float strokeRadius=radius + mRadiusStrokeWidth;\n  drawPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n  canvas.drawCircle(centerX,centerY,strokeRadius,drawPaint);\n  drawPaint.setXfermode(null);\n  final int halfBitmapWidth=bitmap.getWidth() / 2;\n  final int halfBitmapHeight=bitmap.getHeight() / 2;\n  BitmapShader bitmapShader=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);\n  Matrix shaderMatrix=new Matrix();\n  float minSize=bitmap.getWidth() > bitmap.getHeight() ? bitmap.getHeight() : bitmap.getWidth();\n  float scale=radius * 2 / minSize;\n  shaderMatrix.setScale(scale,scale);\n  shaderMatrix.postTranslate(centerX - (halfBitmapWidth * scale),centerY - (halfBitmapHeight * scale));\n  bitmapShader.setLocalMatrix(shaderMatrix);\n  drawPaint.setShader(bitmapShader);\n  canvas.drawCircle(centerX,centerY,radius,drawPaint);\n  drawPaint.setShader(null);\n}\n", "docstring": "draw single bitmap with the giving centerx , centery and radius", "partition": "test"}
{"idx": "2939", "code": "public MqttDevice mqttDevice(){\n  return mqttDevice;\n}\n", "docstring": "get the application \"'\" s mqttdevice", "partition": "test"}
{"idx": "2940", "code": "public AbbaLockingDetector startCollecting(){\n  thread=new Thread(this,\"AbbaLockingDetector\");\n  thread.setDaemon(true);\n  thread.start();\n  return this;\n}\n", "docstring": "start collecting locking data .", "partition": "test"}
{"idx": "2941", "code": "public float toMeters(double pixels){\n  return (float)(pixels * METERS_PER_PIXELS);\n}\n", "docstring": "converts pixels to meters", "partition": "test"}
{"idx": "2942", "code": "boolean addToBuffer(char c) throws IOException {\n  int len=sb.length();\n  if (len == 0 && c != CHAR_LT)   return false;\n  sb.append(c);\n  if (++len >= minTagLen) {\n    boolean isClosingTag=(len >= 2 && sb.charAt(1) == CHAR_SL);\n    String substr;\n    if (isClosingTag)     substr=sb.substring(2);\n else     substr=sb.substring(1);\n    for (int i=0; i < EXCLUDE_TAGS.length; i++) {\n      if (substr.equalsIgnoreCase(EXCLUDE_TAGS[i])) {\n        if (isClosingTag) {\n          depthDec(i);\n          printBuffer();\n          lastChar=0;\n        }\n else {\n          depthInc(i);\n        }\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "checks if a character is part of an open html tag or close html tag , and if so adds it to the buffer , otherwise returns false .", "partition": "test"}
{"idx": "2943", "code": "public static double length(double x,double y,double z){\n  return Math.sqrt(x * x + y * y + z * z);\n}\n", "docstring": "computes the length of a vector", "partition": "test"}
{"idx": "2944", "code": "public static <T>T jsonToObject(String jsonString,Class<T> klass){\n  T objectFromJson=null;\n  try {\n    GfJsonObject jsonObject=new GfJsonObject(jsonString);\n    objectFromJson=klass.newInstance();\n    Method[] declaredMethods=klass.getDeclaredMethods();\n    Map<String,Method> methodsMap=new HashMap<String,Method>();\n    for (    Method method : declaredMethods) {\n      methodsMap.put(method.getName(),method);\n    }\n    int noOfFields=jsonObject.size();\n    Iterator<String> keys=jsonObject.keys();\n    while (keys.hasNext()) {\n      String key=keys.next();\n      Method method=methodsMap.get(\"set\" + capitalize(key));\n      if (method != null) {\n        Class<?>[] parameterTypes=method.getParameterTypes();\n        if (parameterTypes.length == 1) {\n          Class<?> parameterType=parameterTypes[0];\n          Object value=jsonObject.get(key);\n          if (isPrimitiveOrWrapper(parameterType)) {\n            value=getPrimitiveOrWrapperValue(parameterType,value);\n          }\n else           if (isArray(parameterType)) {\n            value=toArray(value,parameterType);\n          }\n else           if (isList(parameterType)) {\n            value=toList(value,parameterType);\n          }\n else           if (isMap(parameterType)) {\n            value=toMap(value,parameterType);\n          }\n else           if (isSet(parameterType)) {\n            value=toSet(value,parameterType);\n          }\n else {\n            value=jsonToObject(value.toString(),parameterType);\n          }\n          method.invoke(objectFromJson,new Object[]{value});\n          noOfFields--;\n        }\n      }\n    }\n    if (noOfFields != 0) {\n      throw new IllegalArgumentException(\"Not enough setter methods for fields in given JSON String : \" + jsonString + \" in class : \"+ klass);\n    }\n  }\n catch (  InstantiationException e) {\n    throw new IllegalArgumentException(\"Couldn\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  IllegalAccessException e) {\n    throw new IllegalArgumentException(\"Couldn\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  GfJsonException e) {\n    throw new IllegalArgumentException(\"Couldn\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  IllegalArgumentException e) {\n    throw new IllegalArgumentException(\"Couldn\'t convert JSON to Object of type \" + klass,e);\n  }\ncatch (  InvocationTargetException e) {\n    throw new IllegalArgumentException(\"Couldn\'t convert JSON to Object of type \" + klass,e);\n  }\n  return objectFromJson;\n}\n", "docstring": "converts given json string in to a object . refer http : / / www . json . org / to construct a json format .", "partition": "test"}
{"idx": "2945", "code": "private Cache createCache() throws CacheException {\n  final Properties props=new Properties();\n  props.setProperty(LOCATORS,\"\");\n  props.setProperty(MCAST_PORT,\"0\");\n  return CacheFactory.create(DistributedSystem.connect(props));\n}\n", "docstring": "creates the cache instance for the test", "partition": "test"}
{"idx": "2946", "code": "public AttributeListPanel(){\n  m_Table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  m_Table.setColumnSelectionAllowed(false);\n  m_Table.setPreferredScrollableViewportSize(new Dimension(250,150));\n  setLayout(new BorderLayout());\n  add(new JScrollPane(m_Table),BorderLayout.CENTER);\n}\n", "docstring": "creates the attribute selection panel with no initial instances .", "partition": "test"}
{"idx": "2947", "code": "protected String[][] toArray(){\n  int i;\n  int n;\n  int ii;\n  int nn;\n  int x;\n  int y;\n  String[][] result;\n  String[][] tmpResult;\n  int cols;\n  int rows;\n  boolean valueExists;\n  rows=getVisibleRowCount();\n  if (getShowAverage()) {\n    rows++;\n  }\n  cols=getVisibleColCount();\n  if (getShowStdDev()) {\n    cols=cols * 3;\n  }\n else {\n    cols=cols * 2;\n  }\n  result=new String[rows + 2][cols + 1];\n  result[0][0]=trimString(\"Dataset\",getRowNameWidth());\n  x=1;\n  for (ii=0; ii < getColCount(); ii++) {\n    i=getDisplayCol(ii);\n    if (getColHidden(i)) {\n      continue;\n    }\n    result[0][x]=trimString(removeFilterName(getColName(i)),getColNameWidth());\n    x++;\n    if (getShowStdDev()) {\n      result[0][x]=\"\";\n      x++;\n    }\n    result[0][x]=\"\";\n    x++;\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (!getRowHidden(i)) {\n      result[y][0]=trimString(removeFilterName(getRowName(i)),getRowNameWidth());\n      y++;\n    }\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (getRowHidden(i)) {\n      continue;\n    }\n    x=1;\n    for (nn=0; nn < getColCount(); nn++) {\n      n=getDisplayCol(nn);\n      if (getColHidden(n)) {\n        continue;\n      }\n      valueExists=(!Double.isNaN(getMean(n,i)));\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\n        result[y][x]=doubleToString(getMean(n,i),getMeanPrec());\n      }\n      x++;\n      if (getShowStdDev()) {\n        if (!valueExists) {\n          result[y][x]=\"\";\n        }\n else         if (Double.isInfinite(getStdDev(n,i))) {\n          result[y][x]=\"Inf\";\n        }\n else {\n          result[y][x]=doubleToString(getStdDev(n,i),getStdDevPrec());\n        }\n        x++;\n      }\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\nswitch (getSignificance(n,i)) {\ncase SIGNIFICANCE_TIE:\n          result[y][x]=TIE_STRING;\n        break;\ncase SIGNIFICANCE_WIN:\n      result[y][x]=WIN_STRING;\n    break;\ncase SIGNIFICANCE_LOSS:\n  result[y][x]=LOSS_STRING;\nbreak;\n}\n}\nx++;\n}\ny++;\n}\nif (getShowAverage()) {\ny=result.length - 2;\nx=0;\nresult[y][0]=\"Average\";\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=doubleToString(getAverage(i),getMeanPrec());\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=\"\";\nx++;\n}\n}\ny=result.length - 1;\nx=0;\nresult[y][0]=LEFT_PARENTHESES + WIN_STRING + \"/\"+ TIE_STRING+ \"/\"+ LOSS_STRING+ RIGHT_PARENTHESES;\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=\"\";\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=LEFT_PARENTHESES + getSignificanceCount(i,SIGNIFICANCE_WIN) + \"/\"+ getSignificanceCount(i,SIGNIFICANCE_TIE)+ \"/\"+ getSignificanceCount(i,SIGNIFICANCE_LOSS)+ RIGHT_PARENTHESES;\nx++;\n}\ntmpResult=new String[result.length][result[0].length - 1];\nx=0;\nfor (i=0; i < result[0].length; i++) {\nif (((i == 3) && (getShowStdDev())) || ((i == 2) && (!getShowStdDev()))) {\ncontinue;\n}\nfor (n=0; n < result.length; n++) {\ntmpResult[n][x]=result[n][i];\n}\nx++;\n}\nresult=tmpResult;\nreturn result;\n}\n", "docstring": "returns a 2 - dimensional array with the prepared data . includes the column and row names . hidden cols / rows are already excluded . < br > first row : column names < br > last row : wins / ties / losses < br > first col : row names < br >", "partition": "test"}
{"idx": "2948", "code": "private Environment(){\n  throw ContractUtils.unreachable();\n}\n", "docstring": "make sure nobody can instantiate the class", "partition": "test"}
{"idx": "2949", "code": "public void removePhoto(PhotoEntity photo){\n  photos.remove(photo);\n}\n", "docstring": "removes the given photo from this user", "partition": "test"}
{"idx": "2950", "code": "public static void compute(double minScore,double topPercent,double maxExpected,float minPercentIdentity,IReadBlock readBlock,String classificationName,BitSet activeMatchesForClassification){\n  activeMatchesForClassification.clear();\n  for (int i=0; i < readBlock.getNumberOfAvailableMatchBlocks(); i++) {\n    final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n    if (!matchBlock.isIgnore() && matchBlock.getBitScore() >= minScore && matchBlock.getExpected() <= maxExpected && matchBlock.getPercentIdentity() >= minPercentIdentity) {\n      if (matchBlock.getId(classificationName) > 0)       activeMatchesForClassification.set(i);\n    }\n  }\n  float bestScore=0;\n  for (int i=activeMatchesForClassification.nextSetBit(0); i != -1; i=activeMatchesForClassification.nextSetBit(i + 1)) {\n    final IMatchBlock matchBlock=readBlock.getMatchBlock(i);\n    float score=matchBlock.getBitScore();\n    if (score > bestScore)     bestScore=score;\n  }\n  applyTopPercentFilter(topPercent,bestScore,minPercentIdentity,readBlock,activeMatchesForClassification);\n}\n", "docstring": "get the set of matches active for the given read", "partition": "test"}
{"idx": "2951", "code": "public E[] toArray(E[] a){\n  if (a.length != array.length()) {\n    throw new ElasticsearchGenerationException(\"AtomicArrays can only be copied to arrays of the same size\");\n  }\n  for (int i=0; i < array.length(); i++) {\n    a[i]=array.get(i);\n  }\n  return a;\n}\n", "docstring": "copies the content of the underlying atomic array to a normal one .", "partition": "test"}
{"idx": "2952", "code": "synchronized public void failOn(Failure fail){\n  if (failures == null) {\n    failures=new ArrayList<>();\n  }\n  failures.add(fail);\n}\n", "docstring": "add a failure object to the list of objects to be evaluated at every potential failure point", "partition": "test"}
{"idx": "2953", "code": "public void dump_stack(){\n  if (stack == null) {\n    debug_message(\"# Stack dump requested, but stack is null\");\n    return;\n  }\n  debug_message(\"============ Parse Stack Dump ============\");\n  for (int i=0; i < stack.size(); i++) {\n    debug_message(\"Symbol: \" + ((symbol)stack.elementAt(i)).sym + \" State: \"+ ((symbol)stack.elementAt(i)).parse_state);\n  }\n  debug_message(\"==========================================\");\n}\n", "docstring": "dump the parse stack for debugging purposes .", "partition": "test"}
{"idx": "2954", "code": "private static Set<String> createCategoriesSet(Set<String> categories){\n  Set<String> result=new HashSet<>();\n  for (  String cat : categories) {\n    result.add(StringUtil.toLowerCase(cat));\n  }\n  return result;\n}\n", "docstring": "creates a new set with the given categories , making them all lowercase in the process . duplicate categories that were only differentiated by case will of course be reduced to one lowercase one by the set .", "partition": "test"}
{"idx": "2955", "code": "public void upload(File file,long restartAt,FTPDataTransferListener listener) throws IllegalStateException, FileNotFoundException, IOException, FTPIllegalReplyException, FTPException, FTPDataTransferException, FTPAbortedException {\n  if (!file.exists()) {\n    throw new FileNotFoundException(file.getAbsolutePath());\n  }\n  InputStream inputStream=null;\n  try {\n    inputStream=new FileInputStream(file);\n  }\n catch (  IOException e) {\n    throw new FTPDataTransferException(e);\n  }\n  try {\n    upload(file.getName(),inputStream,restartAt,restartAt,listener);\n  }\n catch (  IllegalStateException e) {\n    throw e;\n  }\ncatch (  IOException e) {\n    throw e;\n  }\ncatch (  FTPIllegalReplyException e) {\n    throw e;\n  }\ncatch (  FTPException e) {\n    throw e;\n  }\ncatch (  FTPDataTransferException e) {\n    throw e;\n  }\ncatch (  FTPAbortedException e) {\n    throw e;\n  }\n finally {\n    if (inputStream != null) {\n      try {\n        inputStream.close();\n      }\n catch (      Throwable t) {\n        ;\n      }\n    }\n  }\n}\n", "docstring": "this method uploads a file to the remote server . calling this method blocks the current thread until the operation is completed . the operation could be interrupted by another thread calling abortcurrentdatatransfer ( ) . the method will break with a ftpabortedexception .", "partition": "test"}
{"idx": "2956", "code": "public SSLSocket createSSLSocket(Socket socket) throws IOException {\n  SSLSocketFactory sf=((SSLSocketFactory)SSLSocketFactory.getDefault());\n  InetSocketAddress remoteAddress=(InetSocketAddress)socket.getRemoteSocketAddress();\n  SSLSocket s=(SSLSocket)(sf.createSocket(socket,remoteAddress.getHostName(),socket.getPort(),true));\n  s.setUseClientMode(false);\n  s.setEnabledCipherSuites(s.getSupportedCipherSuites());\n  return s;\n}\n", "docstring": "create a ssl socket that wraps the existing socket . this method is called after the client issued the starttls command . < p > subclasses may override this method to configure the key stores , enabled protocols / cipher suites , enforce client authentication , etc .", "partition": "test"}
{"idx": "2957", "code": "private String formatNode(RightThreadedBinaryNode<T> node){\n  RightThreadedBinaryNode<T> n;\n  StringBuilder response=new StringBuilder(\"(\");\n  if ((n=node.getLeftSon()) != null) {\n    response.append(formatNode(n));\n  }\n  response.append(node.toString());\n  if ((n=node.getRightSon()) != null) {\n    response.append(formatNode(n));\n  }\n  response.append(\")\");\n  return response.toString();\n}\n", "docstring": "format the node , recursively .", "partition": "test"}
{"idx": "2958", "code": "public static void unregisterMBean(Class<?> mbeanInterface){\n  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();\n  try {\n    ObjectName name=generateMBeanObjectName(mbeanInterface);\n    if (mbs.isRegistered(name)) {\n      logger.info(\"Unregistering mbean: \" + name.toString());\n      mbs.unregisterMBean(name);\n    }\n else {\n      logger.warn(\"Ignoring attempt to unregister unknown mbean: \" + name.toString());\n    }\n  }\n catch (  Exception e) {\n    throw new ServerRuntimeException(\"Unable to unregister mbean: interface=\" + mbeanInterface,e);\n  }\n}\n", "docstring": "server helper method to register a jmx mbean . mbeans are registered by a combination of their mbean interface and the custom mbeanname argument . the mbeanname permits multiple mbeans to be registered under the same name .", "partition": "test"}
{"idx": "2959", "code": "static boolean causedByRDE(DiskAccessException dae){\n  boolean result=false;\n  if (dae != null) {\n    Throwable cause=dae.getCause();\n    while (cause != null) {\n      if (cause instanceof RegionDestroyedException) {\n        result=true;\n        break;\n      }\n      cause=cause.getCause();\n    }\n  }\n  return result;\n}\n", "docstring": "return true if dae was caused by a regiondestroyedexception . this was added for bug 39603 .", "partition": "test"}
{"idx": "2960", "code": "public JsonArray add(String value){\n  values.add(Json.value(value));\n  return this;\n}\n", "docstring": "appends the json representation of the specified string to the end of this array .", "partition": "test"}
{"idx": "2961", "code": "public MagicVariablesArgumentsBundle(@NonNull Map<String,String> arguments,@NonNull Map<String,String> variables,String layerName,@NonNull DisplayMetrics metrics){\n  super(arguments,metrics);\n  mVariables=variables;\n  mLayerNamePrefix='@' + layerName.replace('-','_') + '_';\n}\n", "docstring": "create a new simple arguments bundle implementation from provided key - & gt ; value map .", "partition": "test"}
{"idx": "2962", "code": "@HLEUnimplemented @HLEFunction(nid=0xCFE9E999,version=271) public int sceUsbCamSetupVideoEx(pspUsbCamSetupVideoExParam usbCamSetupVideoExParam,TPointer workArea,int workAreaSize){\n  this.workArea=workArea.getAddress();\n  this.workAreaSize=workAreaSize;\n  resolution=convertResolutionExToResolution(usbCamSetupVideoExParam.resolution);\n  frameRate=usbCamSetupVideoExParam.framerate;\n  whiteBalance=usbCamSetupVideoExParam.wb;\n  saturation=usbCamSetupVideoExParam.saturation;\n  brightness=usbCamSetupVideoExParam.brightness;\n  contrast=usbCamSetupVideoExParam.contrast;\n  sharpness=usbCamSetupVideoExParam.sharpness;\n  imageEffectMode=usbCamSetupVideoExParam.effectmode;\n  frameSize=usbCamSetupVideoExParam.framesize;\n  evLevel=usbCamSetupVideoExParam.evlevel;\n  if (!setupVideo()) {\n    log.warn(String.format(\"Cannot find webcam\"));\n    return SceKernelErrors.ERROR_USBCAM_NOT_READY;\n  }\n  return 0;\n}\n", "docstring": "set ups the parameters for video capture ( with more options )", "partition": "test"}
{"idx": "2963", "code": "public List<User> loadAllDeepFromCursor(Cursor cursor){\n  int count=cursor.getCount();\n  List<User> list=new ArrayList<User>(count);\n  if (cursor.moveToFirst()) {\n    if (identityScope != null) {\n      identityScope.lock();\n      identityScope.reserveRoom(count);\n    }\n    try {\n      do {\n        list.add(loadCurrentDeep(cursor,false));\n      }\n while (cursor.moveToNext());\n    }\n  finally {\n      if (identityScope != null) {\n        identityScope.unlock();\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "reads all available rows from the given cursor and returns a list of new imageto objects .", "partition": "test"}
{"idx": "2964", "code": "public static Date convertISO8601toDate(String dateString) throws ParseException {\n  DateFormat dateFormat=new SimpleDateFormat(\"yyyy-MM-dd\'T\'HH:mm:ss\");\n  Date date=dateFormat.parse(dateString);\n  return date;\n}\n", "docstring": "method that converts a an iso 8601 string to java date", "partition": "test"}
{"idx": "2965", "code": "public static Document createDOM(InputStream is) throws ParserConfigurationException, SAXException, IOException {\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  dbf.setValidating(false);\n  dbf.setIgnoringComments(false);\n  dbf.setIgnoringElementContentWhitespace(true);\n  dbf.setNamespaceAware(true);\n  dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,true);\n  dbf.setFeature(DISALLOW_DOCTYPE_DECL,true);\n  dbf.setFeature(EXTERNAL_GENERAL_ENTITIES,false);\n  dbf.setFeature(EXTERNAL_PARAMETER_ENTITIES,false);\n  dbf.setFeature(LOAD_EXTERNAL_DTD,false);\n  DocumentBuilder db=null;\n  db=dbf.newDocumentBuilder();\n  db.setEntityResolver(new NullResolver());\n  db.setErrorHandler(new SamlParserErrorHandler());\n  return db.parse(is);\n}\n", "docstring": "create dom from iostream .", "partition": "test"}
{"idx": "2966", "code": "public void resetCount(){\n  msgCnt.set(0);\n}\n", "docstring": "resets counter to zero .", "partition": "test"}
{"idx": "2967", "code": "void decodeAttributeBody(byte[] attributeValue,char offset,char length) throws StunException {\n  realm=new byte[length];\n  System.arraycopy(attributeValue,offset,realm,0,length);\n}\n", "docstring": "copies the value of the realm attribute from the specified attributevalue .", "partition": "test"}
{"idx": "2968", "code": "public static void copyAssets(Context context,String assetsFilename,File file,String mode) throws IOException, InterruptedException {\n  String abi=Build.CPU_ABI;\n  String libraryName;\n  if (abi.equalsIgnoreCase(\"armeabi\")) {\n    libraryName=\"armeabi\";\n  }\n else   if (abi.equalsIgnoreCase(\"x86\")) {\n    libraryName=\"x86\";\n  }\n else   if (abi.contains(\"armeabi-v7\")) {\n    libraryName=\"armeabi-v7a\";\n  }\n else {\n    return;\n  }\n  AssetManager manager=context.getAssets();\n  final InputStream is=manager.open(libraryName + \"/\" + assetsFilename);\n  copyFile(file,is,mode);\n}\n", "docstring": "copy file in assets into destination file", "partition": "test"}
{"idx": "2969", "code": "public boolean is_same(Object obj){\n  if (this == obj)   return true;\n  if (obj == null)   return false;\n  if (getClass() != obj.getClass())   return false;\n  HouseNumber other=(HouseNumber)obj;\n  if (number == null) {\n    if (name == null) {\n      if (other.name != null)       return false;\n    }\n else     if (!name.equals(other.name))     return false;\n  }\n else   if (!number.equals(other.number))   return false;\n  if (street == null) {\n    if (other.street != null)     return false;\n  }\n else   if (!street.equals(other.street))   return false;\n  return true;\n}\n", "docstring": "check if address are content identical if number are equals and street ( if number is null , we look at the name )", "partition": "test"}
{"idx": "2970", "code": "public int threeWayDistance(Key k1,Key k2){\n  byte[] h0=hash;\n  byte[] h1=k1.hash;\n  byte[] h2=k2.hash;\n  int mmi=mismatch(h1,h2);\n  if (mmi == -1)   return 0;\n  int h=Byte.toUnsignedInt(h0[mmi]);\n  int a=Byte.toUnsignedInt(h1[mmi]);\n  int b=Byte.toUnsignedInt(h2[mmi]);\n  return Integer.compareUnsigned(a ^ h,b ^ h);\n}\n", "docstring": "compares the distance of two keys relative to this one using the xor metric", "partition": "test"}
{"idx": "2971", "code": "public AsyncSelector() throws IOException {\n  this(Selector.open());\n}\n", "docstring": "construct asyncselector with brand new selector", "partition": "test"}
{"idx": "2972", "code": "public void removeChildAt(int index){\n  if ((index < 0) || (children == null) || (index >= children.size())) {\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  Element child=(Element)children.get(index);\n  child.setParent(null);\n  children.remove(index);\n}\n", "docstring": "removes the child at the given index", "partition": "test"}
{"idx": "2973", "code": "private void paint(Painter p,SynthContext ctx,Graphics g,int x,int y,int w,int h,AffineTransform transform){\n  if (p != null) {\n    if (g instanceof Graphics2D) {\n      Graphics2D gfx=(Graphics2D)g;\n      if (transform != null) {\n        gfx.transform(transform);\n      }\n      gfx.translate(x,y);\n      p.paint(gfx,ctx.getComponent(),w,h);\n      gfx.translate(-x,-y);\n      if (transform != null) {\n        try {\n          gfx.transform(transform.createInverse());\n        }\n catch (        NoninvertibleTransformException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n else {\n      BufferedImage img=new BufferedImage(w,h,BufferedImage.TYPE_INT_ARGB);\n      Graphics2D gfx=img.createGraphics();\n      if (transform != null) {\n        gfx.transform(transform);\n      }\n      p.paint(gfx,ctx.getComponent(),w,h);\n      gfx.dispose();\n      g.drawImage(img,x,y,null);\n      img=null;\n    }\n  }\n}\n", "docstring": "paint the provided painter using the provided transform at the specified position and size . handles if g is a non 2d graphics by painting via a bufferedimage .", "partition": "test"}
{"idx": "2974", "code": "static void loadDirectory(File file,ModuleCandidate candidate) throws IOException {\n  File[] files=file.listFiles();\n  if (files != null)   for (  File f : files)   loadSubDirectory(file,f,candidate);\n}\n", "docstring": "load a module candidate from a directory . this is usually used in - sim - - search .", "partition": "test"}
{"idx": "2975", "code": "public static boolean hasSuppressed(@Nullable Throwable t,@Nullable Class<? extends Throwable> cls){\n  if (t == null || cls == null)   return false;\n  if (t.getSuppressed() != null) {\n    for (    Throwable th : t.getSuppressed()) {\n      if (cls.isAssignableFrom(th.getClass()))       return true;\n      if (hasSuppressed(th,cls))       return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks if passed throwable has given class in one of the suppressed exceptions .", "partition": "test"}
{"idx": "2976", "code": "static int writeVarLong(OutputStream out,long x) throws IOException {\n  int len=0;\n  while ((x & ~0x7f) != 0) {\n    out.write((byte)(0x80 | (x & 0x7f)));\n    x>>>=7;\n    len++;\n  }\n  out.write((byte)x);\n  return ++len;\n}\n", "docstring": "write a variable size long value .", "partition": "test"}
{"idx": "2977", "code": "protected void engineUpdate(byte b) throws SignatureException {\n  messageDigest.update(b);\n  needsReset=true;\n}\n", "docstring": "updates the data to be signed or verified using the specified byte .", "partition": "test"}
{"idx": "2978", "code": "private boolean checkIfInitiatorForRPBeforeMigration(Initiator initiator){\n  if (initiator == null) {\n    return false;\n  }\n  boolean isRP=true;\n  if (NullColumnValueGetter.isNullValue(initiator.getHostName()) || !NullColumnValueGetter.isNullURI(initiator.getHost())) {\n    isRP=false;\n  }\n  log.debug(\"RP initiator? \" + (isRP ? \"Yes!\" : \"No!\"));\n  return isRP;\n}\n", "docstring": "check if the passed in initiator is for rp", "partition": "test"}
{"idx": "2979", "code": "@Override public Collection<SerialMessage> initialize(boolean refresh){\n  ArrayList<SerialMessage> result=new ArrayList<SerialMessage>();\n  if (isSupportRequestSupported == true && (refresh == true || initialiseDone == false) && getVersion() > 1) {\n    result.add(getSupportedMessage());\n  }\n  return result;\n}\n", "docstring": "initializes the meter command class . requests the supported meter types .", "partition": "test"}
{"idx": "2980", "code": "public static DMLConfig readConfigurationFile(String configPath) throws ParseException, FileNotFoundException {\n  DMLConfig config=new DMLConfig();\n  if (configPath != null) {\n    try {\n      config=new DMLConfig(configPath,false);\n    }\n catch (    FileNotFoundException fnfe) {\n      LOG.error(\"Custom config file \" + configPath + \" not found.\");\n      throw fnfe;\n    }\ncatch (    ParseException e) {\n      throw e;\n    }\n  }\n else {\n    try {\n      config=new DMLConfig(DEFAULT_SYSTEMML_CONFIG_FILEPATH,false);\n    }\n catch (    FileNotFoundException fnfe) {\n      LOG.info(\"Using internal default configuration settings.  If you wish to \" + \"customize any settings, please supply a `SystemML-config.xml` file.\");\n      config=new DMLConfig();\n    }\ncatch (    ParseException e) {\n      throw e;\n    }\n  }\n  return config;\n}\n", "docstring": "start with the internal default settings , then merge in the settings from any specified configuration file , if available . if it is not explicitly given , then merge in settings from the default configuration file location , if available .", "partition": "test"}
{"idx": "2981", "code": "default B withDefault(String key,int value){\n  return withDefault(key,Integer.toString(value));\n}\n", "docstring": "if there is no field with the specified key , then associate the given value with the specified key .", "partition": "test"}
{"idx": "2982", "code": "private String[] combineResultsFromMultipleReads(String[] buffer,String[] lastRead){\n  String[] t=new String[buffer.length + lastRead.length];\n  System.arraycopy(buffer,0,t,0,buffer.length);\n  System.arraycopy(lastRead,0,t,buffer.length,lastRead.length);\n  return t;\n}\n", "docstring": "for multi line records this method combines the current result with the result from previous read ( s ) .", "partition": "test"}
{"idx": "2983", "code": "private static boolean isRetina(){\n  if (SystemInfo.isAppleJvm) {\n    return hasAppleRetinaDevice();\n  }\n  if (SystemInfo.isMac) {\n    GraphicsEnvironment e=GraphicsEnvironment.getLocalGraphicsEnvironment();\n    GraphicsDevice[] devices=e.getScreenDevices();\n    for (    GraphicsDevice device : devices) {\n      if (isOracleMacRetinaDevice(device)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "checks that at least one retina device is present . do not use this method if your are going to make decision for a particular screen . isretina ( graphics2d ) is more preferable", "partition": "test"}
{"idx": "2984", "code": "protected void scanCompilationUnits(final List<ICompilationUnit> us) throws IllegalArgumentException, CoreException {\n  progressMonitor.beginTask(\"Iterating over laconizeable compilation units...\",us.size());\n  for (  final ICompilationUnit \u00a2 : us)   scanCompilationUnit(\u00a2,newSubMonitor(progressMonitor));\n  progressMonitor.done();\n}\n", "docstring": "creates a change from each compilation unit and stores it in the changes list", "partition": "test"}
{"idx": "2985", "code": "private void drawCombat(final Graphics2D g2d,final int x,final int y,final int width,final int height){\n  Rectangle2D wrect=entity.getArea();\n  final Rectangle srect=new Rectangle((int)(wrect.getX() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getY() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getWidth() * IGameScreen.SIZE_UNIT_PIXELS),(int)(wrect.getHeight() * IGameScreen.SIZE_UNIT_PIXELS));\n  int circleHeight=(int)((srect.height - 2) / SQRT2);\n  circleHeight=Math.max(circleHeight,srect.height - IGameScreen.SIZE_UNIT_PIXELS / 2);\n  if (entity.isAttacking(User.get())) {\n    g2d.setColor(RING_COLOR_ORANGE);\n    g2d.drawOval(srect.x - 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    g2d.drawOval(srect.x,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    g2d.drawOval(srect.x + 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n    drawShadedOval(g2d,srect.x + 1,srect.y + srect.height - circleHeight + 1,srect.width - 2,circleHeight - 2,RING_COLOR_ORANGE,true,false);\n  }\n  if (entity.isBeingAttacked()) {\n    Color lineColor;\n    g2d.setColor(RING_COLOR_RED);\n    if (entity.isAttacking(User.get())) {\n      lineColor=RING_COLOR_RED;\n      drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_RED,false,true);\n    }\n else {\n      lineColor=RING_COLOR_DARK_RED;\n      g2d.drawOval(srect.x - 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      g2d.drawOval(srect.x,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      g2d.drawOval(srect.x + 1,srect.y + srect.height - circleHeight,srect.width,circleHeight);\n      drawShadedOval(g2d,srect.x + 1,srect.y + srect.height - circleHeight + 1,srect.width - 2,circleHeight - 2,RING_COLOR_RED,true,false);\n      drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_ORANGE,false,false);\n    }\n    EnumSet<Direction> directions=EnumSet.noneOf(Direction.class);\n    for (    Entity attacker : entity.getAttackers()) {\n      directions.add(Direction.getAreaDirectionTowardsArea(entity.getArea(),attacker.getArea()));\n    }\n    drawArrows(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,directions,lineColor);\n  }\n else   if (entity.isAttacking(User.get())) {\n    drawShadedOval(g2d,srect.x - 1,srect.y + srect.height - circleHeight - 1,srect.width + 2,circleHeight + 2,RING_COLOR_ORANGE,false,false);\n  }\n  drawAttack(g2d,x,y,width,height);\n  if (entity.isDefending()) {\n    final int sx=srect.x + srect.width - ICON_OFFSET;\n    final int sy=y + height - 2 * ICON_OFFSET;\nswitch (entity.getResolution()) {\ncase BLOCKED:\n      blockedSprite.draw(g2d,sx,sy);\n    break;\ncase MISSED:\n  missedSprite.draw(g2d,sx,sy);\nbreak;\ncase HIT:\nhitSprite.draw(g2d,sx,sy);\nbreak;\ndefault :\n}\n}\n}\n", "docstring": "draw the combat indicators .", "partition": "test"}
{"idx": "2986", "code": "public ActivityResolveInfo(ResolveInfo resolveInfo){\n  this.resolveInfo=resolveInfo;\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "2987", "code": "private static Pair<String,String> postIndexedLSR(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2,final String immediateNodeValue){\n  final String address=environment.getNextVariableString();\n  final String tmpVar1=environment.getNextVariableString();\n  final String tmpVar2=environment.getNextVariableString();\n  final String index=environment.getNextVariableString();\n  long baseOffset=offset;\n  instructions.add(ReilHelpers.createStr(baseOffset++,dw,registerNodeValue1,dw,address));\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dw,registerNodeValue2,dw,\"-\" + immediateNodeValue,qw,tmpVar1));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,qw,tmpVar1,dw,dWordBitMask,dw,index));\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue1,dw,index,dw,tmpVar2));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dw,tmpVar2,dw,dWordBitMask,dw,registerNodeValue1));\n  return new Pair<String,String>(address,registerNodeValue1);\n}\n", "docstring": "operation : [ < rn > ", "partition": "test"}
{"idx": "2988", "code": "public final void addReference(Object ref){\n  refSet.add(ref);\n}\n", "docstring": "adds the given object to the set of hard references , which will prevent that object from being disposed until the queue has been flushed completely . this is useful in cases where some enqueued data could become invalid if the reference object were garbage collected before the queue could be processed . ( for example , keeping a hard reference to a fontstrike will prevent any enqueued glyph images associated with that strike from becoming invalid before the queue is flushed . ) the reference set will be cleared immediately after the queue is flushed each time .", "partition": "test"}
{"idx": "2989", "code": "public RequirementsBuilder addRequireProperty(String name,RequirementsBuilder builder){\n  addProperty(name,builder);\n  requiredProperties.add(name);\n  return this;\n}\n", "docstring": "add a required property of type object .", "partition": "test"}
{"idx": "2990", "code": "public HeadRule(String dir,String rule){\n  String[] tmp=P_TAGSETS.split(rule);\n  int i, size=tmp.length;\n  b_r2l=dir.equals(DIR_RIGHT_TO_LEFT);\n  a_tagSets=new HeadTagSet[size];\n  for (i=0; i < size; i++)   a_tagSets[i]=new HeadTagSet(tmp[i]);\n}\n", "docstring": "constructs a new headrule by decoding the specific head tagsets .", "partition": "test"}
{"idx": "2991", "code": "public void testNegPosFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=1;\n  byte rBytes[]={-74,91,47,-5,-13,-7,-5,-33,-49,-65,-1,-9,-3};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.or(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,result.signum());\n}\n", "docstring": "or for two negative numbers ; the first is shorter", "partition": "test"}
{"idx": "2992", "code": "@Override public <T>Future<T> submit(Callable<T> task){\nsynchronized (this) {\n    active.incrementAndGet();\n    long timeout=0;\n    while (queue.remainingCapacity() == 0) {\n      try {\n        if (timeout <= giveupTime) {\n          Thread.sleep(DEFAULT_SLEEP);\n          timeout+=DEFAULT_SLEEP;\n        }\n else {\n          throw new RuntimeException(\"Timed out because TPE is too busy...\");\n        }\n      }\n catch (      InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return super.submit(task);\n  }\n}\n", "docstring": "this is a thread safe way to avoid rejection exception . . . this is implemented because we might want to hold the incoming requests till there is a free thread .", "partition": "test"}
{"idx": "2993", "code": "public void testSubtractMathContextDiffScalePosNeg(){\n  String a=\"1231212478987482988429808779810457634781384756794987\";\n  int aScale=15;\n  String b=\"747233429293018787918347987234564568\";\n  int bScale=-10;\n  String c=\"-7.4723342916989754E+45\";\n  int cScale=-29;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  MathContext mc=new MathContext(17,RoundingMode.DOWN);\n  BigDecimal result=aNumber.subtract(bNumber,mc);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",cScale,result.scale());\n}\n", "docstring": "subtract two numbers of different scales using mathcontext ; the first is positive", "partition": "test"}
{"idx": "2994", "code": "protected XSQLDA allocateXSqlDa(RowDescriptor rowDescriptor){\n  if (rowDescriptor == null || rowDescriptor.getCount() == 0) {\n    final XSQLDA xSqlDa=new XSQLDA(1);\n    xSqlDa.sqld=xSqlDa.sqln=0;\n    return xSqlDa;\n  }\n  final XSQLDA xSqlDa=new XSQLDA(rowDescriptor.getCount());\n  for (int idx=0; idx < rowDescriptor.getCount(); idx++) {\n    final FieldDescriptor fieldDescriptor=rowDescriptor.getFieldDescriptor(idx);\n    final XSQLVAR xSqlVar=xSqlDa.sqlvar[idx];\n    xSqlVar.sqltype=(short)(fieldDescriptor.getType() | 1);\n    xSqlVar.sqlsubtype=(short)fieldDescriptor.getSubType();\n    xSqlVar.sqlscale=(short)fieldDescriptor.getScale();\n    xSqlVar.sqllen=(short)fieldDescriptor.getLength();\n    xSqlVar.sqlind=new ShortByReference();\n    final int requiredDataSize=fieldDescriptor.isVarying() ? fieldDescriptor.getLength() + 3 : fieldDescriptor.getLength() + 1;\n    xSqlVar.sqldata=new Memory(requiredDataSize);\n  }\n  return xSqlDa;\n}\n", "docstring": "creates an xsqlda , populates type information and allocates memory for the sqldata fields .", "partition": "test"}
{"idx": "2995", "code": "public static void overwrite(long[] vector,long val,int offset,int len){\n  int idx=offset >> 6;\n  int bitIdx=offset & 63;\n  int truncatedValLen=Math.min(len,64 - bitIdx);\n  vector[idx]&=~(maskBelow(truncatedValLen) << bitIdx);\n  vector[idx]|=val << bitIdx;\n  if (len != truncatedValLen) {\n    long mask=maskBelow(len - truncatedValLen);\n    vector[idx + 1]&=~mask;\n    vector[idx + 1]|=(val >>> truncatedValLen);\n  }\n}\n", "docstring": "overwrites a bit range within the vector .", "partition": "test"}
{"idx": "2996", "code": "public static boolean isEmpty(String string){\n  if (null == string)   return true;\n  return string.equals(EMPTY);\n}\n", "docstring": "check if the given string is empty or null", "partition": "test"}
{"idx": "2997", "code": "public void beginUpdateMemoryUsed(long bytesUsed,boolean willSendEvent);\n", "docstring": "called at the beginning of updatememoryused .", "partition": "test"}
{"idx": "2998", "code": "@Override public Point translateJava2DToScreen(Point2D java2DPoint){\n  Insets insets=getInsets();\n  int x=(int)(java2DPoint.getX() * this.scaleX + insets.left);\n  int y=(int)(java2DPoint.getY() * this.scaleY + insets.top);\n  return new Point(x,y);\n}\n", "docstring": "translates a java2d point on the chart to a screen location .", "partition": "test"}
{"idx": "2999", "code": "protected FastMap<String> readDeclaredProperties(WidgetCreatorContext context){\n  FastMap<String> declaredProperties=new FastMap<String>();\n  String backColor=context.readWidgetProperty(\"backColor\");\n  if (backColor != null && backColor.length() > 0) {\n    declaredProperties.put(\"backColor\",backColor);\n  }\n  String fontName=context.readWidgetProperty(\"fontName\");\n  if (fontName != null && fontName.length() > 0) {\n    declaredProperties.put(\"fontName\",fontName);\n  }\n  String fontSize=context.readWidgetProperty(\"fontSize\");\n  if (fontSize != null && fontSize.length() > 0) {\n    declaredProperties.put(\"fontSize\",fontSize);\n  }\n  String foreColor=context.readWidgetProperty(\"foreColor\");\n  if (foreColor != null && foreColor.length() > 0) {\n    declaredProperties.put(\"foreColor\",foreColor);\n  }\n  String justification=context.readWidgetProperty(\"justification\");\n  if (justification != null && justification.length() > 0) {\n    declaredProperties.put(\"justification\",justification);\n  }\n  String bold=context.readWidgetProperty(\"bold\");\n  if (bold != null && bold.length() > 0) {\n    declaredProperties.put(\"bold\",bold);\n  }\n  String italic=context.readWidgetProperty(\"italic\");\n  if (italic != null && italic.length() > 0) {\n    declaredProperties.put(\"italic\",italic);\n  }\n  String subscript=context.readWidgetProperty(\"subscript\");\n  if (subscript != null && subscript.length() > 0) {\n    declaredProperties.put(\"subscript\",subscript);\n  }\n  String superscript=context.readWidgetProperty(\"superscript\");\n  if (superscript != null && superscript.length() > 0) {\n    declaredProperties.put(\"superscript\",superscript);\n  }\n  String underline=context.readWidgetProperty(\"underline\");\n  if (underline != null && underline.length() > 0) {\n    declaredProperties.put(\"underline\",underline);\n  }\n  String strikethrough=context.readWidgetProperty(\"strikethrough\");\n  if (strikethrough != null && strikethrough.length() > 0) {\n    declaredProperties.put(\"strikethrough\",strikethrough);\n  }\n  return declaredProperties;\n}\n", "docstring": "reads all declared properties in the component span tag . these properties will be used to initialise the basic formatter . it will be done by method initbasicformatteroptions", "partition": "test"}
{"idx": "3000", "code": "private void updateTrafficProjections(){\n  List<AirMapTraffic> updated=new ArrayList<>();\n  for (  AirMapTraffic traffic : allTraffic) {\n    if (traffic.getGroundSpeedKt() > -1 && traffic.getTrueHeading() > -1) {\n      allTraffic.remove(traffic);\n      Coordinate projected=projectedCoordinate(traffic);\n      traffic.setCoordinate(projected);\n      traffic.setShowAlert(false);\n      allTraffic.add(traffic);\n      updated.add(traffic);\n    }\n  }\n  notifyUpdated(updated);\n}\n", "docstring": "update all the traffic projections based on their heading and ground speed", "partition": "test"}
{"idx": "3001", "code": "public static void logStackTrace(Level level,Throwable throwable){\n  logStackTrace(level,throwable,null);\n}\n", "docstring": "logs the stack trace for the given throwable if logger is initialized else prints the stack trace using system . out .", "partition": "test"}
{"idx": "3002", "code": "public static float computeContrastBetweenColors(int bg,int fg){\n  float bgR=Color.red(bg) / 255f;\n  float bgG=Color.green(bg) / 255f;\n  float bgB=Color.blue(bg) / 255f;\n  bgR=(bgR < 0.03928f) ? bgR / 12.92f : (float)Math.pow((bgR + 0.055f) / 1.055f,2.4f);\n  bgG=(bgG < 0.03928f) ? bgG / 12.92f : (float)Math.pow((bgG + 0.055f) / 1.055f,2.4f);\n  bgB=(bgB < 0.03928f) ? bgB / 12.92f : (float)Math.pow((bgB + 0.055f) / 1.055f,2.4f);\n  float bgL=0.2126f * bgR + 0.7152f * bgG + 0.0722f * bgB;\n  float fgR=Color.red(fg) / 255f;\n  float fgG=Color.green(fg) / 255f;\n  float fgB=Color.blue(fg) / 255f;\n  fgR=(fgR < 0.03928f) ? fgR / 12.92f : (float)Math.pow((fgR + 0.055f) / 1.055f,2.4f);\n  fgG=(fgG < 0.03928f) ? fgG / 12.92f : (float)Math.pow((fgG + 0.055f) / 1.055f,2.4f);\n  fgB=(fgB < 0.03928f) ? fgB / 12.92f : (float)Math.pow((fgB + 0.055f) / 1.055f,2.4f);\n  float fgL=0.2126f * fgR + 0.7152f * fgG + 0.0722f * fgB;\n  return Math.abs((fgL + 0.05f) / (bgL + 0.05f));\n}\n", "docstring": "calculates the constrast between two colors , using the algorithm provided by the wcag v2 .", "partition": "test"}
{"idx": "3003", "code": "private SublimeBaseMenuItem addInternal(int group,int id,CharSequence title,CharSequence hint,SublimeBaseMenuItem.ItemType itemType,boolean valueProvidedAsync,CharSequence badgeText,boolean showsIconSpace,boolean addedByUser){\n  SublimeBaseMenuItem item;\n  boolean isGroupHeader=false;\nswitch (itemType) {\ncase SEPARATOR:\n    item=new SublimeSeparatorMenuItem(this,group,id);\n  break;\ncase BADGE:\nitem=new SublimeTextWithBadgeMenuItem(this,group,id,title,hint,valueProvidedAsync,badgeText,showsIconSpace);\nbreak;\ncase SWITCH:\nitem=new SublimeSwitchMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\ncase CHECKBOX:\nitem=new SublimeCheckboxMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\ncase GROUP_HEADER:\nisGroupHeader=true;\nitem=new SublimeGroupHeaderMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\ndefault :\nitem=new SublimeTextMenuItem(this,group,id,title,hint,valueProvidedAsync,showsIconSpace);\nbreak;\n}\ncheckExistenceOfGroup(group);\nif (isGroupHeader) {\ncheckIfGroupHeaderAlreadyExistsForGroup(group);\nint index=findGroupIndex(group);\nif (index >= 0) {\nmItems.add(index,item);\n}\n else {\nmItems.add(item);\n}\n}\n else if (addedByUser) {\nif (group != NO_GROUP_ID) {\nint lastGroupIndex=findLastGroupIndex(group);\nmItems.add(lastGroupIndex == mItems.size() ? lastGroupIndex : lastGroupIndex + 1,item);\n}\n else {\nmItems.add(item);\n}\n}\n else {\nmItems.add(item);\n}\nonItemsChanged();\nreturn item;\n}\n", "docstring": "adds an item to the menu . the other add methods funnel to this .", "partition": "test"}
{"idx": "3004", "code": "public static String decodeBCD(final short bcd){\n  return String.format(\"%x.%02x\",(bcd & 0xFF00) >> 8,bcd & 0x00FF);\n}\n", "docstring": "decodes a binary - coded decimal into a string and returns it .", "partition": "test"}
{"idx": "3005", "code": "public void addLayoutEditor(LayoutEditor panel){\n  if (panels.size() > 0) {\n    for (int i=0; i < panels.size(); i++) {\n      LayoutEditor ed=panels.get(i);\n      if (ed == panel) {\n        return;\n      }\n    }\n  }\n  panels.add(panel);\n}\n", "docstring": "keeps track of layouteditor panels that are using this layoutblock", "partition": "test"}
{"idx": "3006", "code": "void triggerWildcardExpander(final Collection<File> allFiles,final WildcardContext wildcardContext) throws IOException {\n  LOG.debug(\"wildcard resources: {}\",allFiles);\n  if (allFiles.isEmpty()) {\n    final String message=String.format(\"No resource found for wildcard: %s\",wildcardContext.getWildcard());\n    LOG.warn(message);\n    throw new IOException(message);\n  }\n  if (wildcardExpanderHandler != null) {\n    try {\n      wildcardExpanderHandler.apply(allFiles);\n    }\n catch (    final IOException e) {\n      throw e;\n    }\ncatch (    final Exception e) {\n      LOG.debug(\"wildcard expanding error. Reporting original exception\",e);\n      throw new IOException(\"Exception during expanding wildcard: \" + e.getMessage());\n    }\n  }\n}\n", "docstring": "uses the wildcardexpanderhandler to process all found files and directories .", "partition": "test"}
{"idx": "3007", "code": "@POST @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @CheckPermission(roles={Role.TENANT_ADMIN}) @Path(\"/{id}/ip-interfaces\") public IpInterfaceRestRep createIpInterface(@PathParam(\"id\") URI id,IpInterfaceCreateParam createParam) throws DatabaseException {\n  Host host=queryObject(Host.class,id,true);\n  validateIpInterfaceData(createParam,null);\n  IpInterface ipInterface=new IpInterface();\n  ipInterface.setHost(host.getId());\n  ipInterface.setId(URIUtil.createId(IpInterface.class));\n  populateIpInterface(createParam,ipInterface);\n  _dbClient.createObject(ipInterface);\n  auditOp(OperationTypeEnum.CREATE_HOST_IPINTERFACE,true,null,ipInterface.auditParameters());\n  return map(ipInterface);\n}\n", "docstring": "creates a new ip interface for a host .", "partition": "test"}
{"idx": "3008", "code": "protected List<IEditProposal> collectEditProposals(){\n  List<IEditProposal> proposals=new ArrayList<IEditProposal>();\n  View selectedView=getSelectedView();\n  if (selectedView != null) {\n    if (proposalProviders != null) {\n      for (      IEditProposalProvider provider : proposalProviders) {\n        for (        IEditProposal editProposal : provider.getProposals(selectedView)) {\n          if (editProposal.isApplicable())           proposals.add(editProposal);\n        }\n      }\n    }\n  }\n  return proposals;\n}\n", "docstring": "collects all edit proposals from contained poroposal providers .", "partition": "test"}
{"idx": "3009", "code": "public ExtensionQuery(String pluginId,String extensionPointName,String attributeName){\n  this.pluginId=extensionPointName.contains(\".\") ? null : pluginId;\n  this.extensionPointName=extensionPointName;\n  this.attributeName=attributeName;\n}\n", "docstring": "create a new instance .", "partition": "test"}
{"idx": "3010", "code": "private void ensureNamespaceExists(Result result){\n  DockerImage image=DockerImage.fromImageName(result.name);\n  if (image.getNamespace() == null) {\n    result.name=String.format(\"%s/%s\",DEFAULT_NAMESPACE,image.getRepository());\n  }\n}\n", "docstring": "ensures that an image name has a namespace prefix . an image pushed to a v1 registry without namespace prefix is processed in the following way : < registry_name > / < repository_name > - > < registry_name > / library / < repository_name > results from v1 queries , however , do not contain the default prefix . this could be a problem later when we instantiate containers based on these images . an image pushed to a v2 registry does not get the default prefix .", "partition": "test"}
{"idx": "3011", "code": "public void testFilteredClassifier(){\n  Instances data;\n  int i;\n  if (m_FilteredClassifier == null) {\n    return;\n  }\n  try {\n    data=getFilteredClassifierData();\n    m_FilteredClassifier.buildClassifier(data);\n    for (i=0; i < data.numInstances(); i++) {\n      m_FilteredClassifier.classifyInstance(data.instance(i));\n    }\n  }\n catch (  Exception e) {\n    fail(\"Problem with FilteredClassifier: \" + e.toString());\n  }\n}\n", "docstring": "tests the filter in conjunction with the filteredclassifier", "partition": "test"}
{"idx": "3012", "code": "protected int chooseRandomIndexBasedOnProportions(double[] proportionArray,Random random){\n  double probSum;\n  double val;\n  int index;\n  double sum;\n  probSum=Utils.sum(proportionArray);\n  val=random.nextDouble() * probSum;\n  index=0;\n  sum=0.0;\n  while ((sum <= val) && (index < proportionArray.length)) {\n    sum+=proportionArray[index++];\n  }\n  return index - 1;\n}\n", "docstring": "returns a random index based on the given proportions", "partition": "test"}
{"idx": "3013", "code": "private void checkWidth(final int[] rect){\n  final int x1=rect[0];\n  final int y2=rect[1];\n  final int y1=y2 + rect[3];\n  final int x2=x1 + rect[2];\n  if (x1 < pageX1) {\n    pageX1=x1;\n  }\n  if (x2 > pageX2) {\n    pageX2=x2;\n  }\n  if (y1 > pageY1) {\n    pageY1=y1;\n  }\n  if (y2 < pageY2) {\n    pageY2=y2;\n  }\n}\n", "docstring": "track actual size of shape", "partition": "test"}
{"idx": "3014", "code": "@NotNull public static Map<RadComponent,List<RadComponent>> groupSiblings(@NotNull List<? extends RadComponent> components){\n  Map<RadComponent,List<RadComponent>> siblingLists=new HashMap<RadComponent,List<RadComponent>>();\n  if (components.isEmpty()) {\n    return siblingLists;\n  }\n  if (components.size() == 1) {\n    RadComponent component=components.get(0);\n    siblingLists.put(component.getParent(),Collections.singletonList(component));\n    return siblingLists;\n  }\n  for (  RadComponent component : components) {\n    RadComponent parent=component.getParent();\n    List<RadComponent> children=siblingLists.get(parent);\n    if (children == null) {\n      children=new ArrayList<RadComponent>();\n      siblingLists.put(parent,children);\n    }\n    children.add(component);\n  }\n  return siblingLists;\n}\n", "docstring": "partitions the given list of components into a map where each value is a list of siblings , in the same order as in the original list , and where the keys are the parents ( or null for the components that do not have a parent ) . < p / > the value lists will never be empty . the parent key will be null for components without parents .", "partition": "test"}
{"idx": "3015", "code": "private int countNonNewline(String str,int off,int len){\n  for (int cnt=0; cnt < len; cnt++) {\n    final int pos=off + cnt;\n    if (str.charAt(pos) == UNIX_NEWLINE) {\n      return cnt;\n    }\n    if (str.charAt(pos) == CARRIAGE_RETURN) {\n      return cnt;\n    }\n  }\n  return len;\n}\n", "docstring": "count the number of non - newline characters before first newline in the string .", "partition": "test"}
{"idx": "3016", "code": "public String description(){\n  StringBuilder sb=new StringBuilder();\n  if (isCombo()) {\n    int i=0;\n    for (    NewComboLeg leg : m_comboLegs) {\n      if (i++ > 0) {\n        sb.append(\"/\");\n      }\n      sb.append(leg.toString());\n    }\n  }\n else {\n    sb.append(m_symbol);\n    app(sb,m_secType);\n    app(sb,m_exchange);\n    if (m_exchange != null && m_exchange.equals(\"SMART\") && m_primaryExch != null) {\n      app(sb,m_primaryExch);\n    }\n    app(sb,m_expiry);\n    if (m_strike != 0) {\n      app(sb,m_strike);\n    }\n    if (m_right != Right.None) {\n      app(sb,m_right);\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "returns a text description that can be used for display .", "partition": "test"}
{"idx": "3017", "code": "public void addClaimedSignerRole(final String claimedSignerRole){\n  if ((claimedSignerRole == null) || (claimedSignerRole.length() == 0)) {\n    throw new NullPointerException(\"claimedSignerRole\");\n  }\n  if (claimedSignerRoles == null) {\n    claimedSignerRoles=new ArrayList<String>();\n  }\n  claimedSignerRoles.add(claimedSignerRole);\n}\n", "docstring": "adds a claimed signer role", "partition": "test"}
{"idx": "3018", "code": "@SuppressWarnings(\"nullness\") @GwtIncompatible(\"java.io.ObjectOutputStream\") public static <K extends Object,V extends Object>void writeMap(Map<K,V> map,ObjectOutputStream stream) throws IOException {\n  stream.writeInt(map.size());\n  for (  Map.Entry<K,V> entry : map.entrySet()) {\n    stream.writeObject(entry.getKey());\n    stream.writeObject(entry.getValue());\n  }\n}\n", "docstring": "stores the contents of a map in an output stream , as part of serialization . it does not support concurrent maps whose content may change while the method is running . < p > the serialized output consists of the number of entries , first key , first value , second key , second value , and so on .", "partition": "test"}
{"idx": "3019", "code": "protected void sleep(int sleepMillis,int sleepNanos) throws InterruptedException {\n  Thread.sleep(sleepMillis,sleepNanos);\n}\n", "docstring": "sub classes ( tests basically ) can use this to override how the sleep is being done", "partition": "test"}
{"idx": "3020", "code": "public static void restorePreviousOutAndErrStream(){\n  if (!alreadyMuted) {\n    return;\n  }\n  System.setOut(latestOut);\n  System.setErr(latestErr);\n  alreadyMuted=false;\n}\n", "docstring": "allow again printing to previous streams that were muted", "partition": "test"}
{"idx": "3021", "code": "public static BigInteger CRT(List<BigInteger> congs,List<BigInteger> moduli){\n  BigInteger[] cs=ArrayConverter.convertListToArray(congs);\n  BigInteger[] ms=ArrayConverter.convertListToArray(moduli);\n  return CRT(cs,ms);\n}\n", "docstring": "computes chinese reminder theorem : x = = congs [ i ", "partition": "test"}
{"idx": "3022", "code": "private int measureHeight(int measureSpec){\n  int result=0;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  mAscent=(int)mTextPaint.ascent();\n  if (specMode == MeasureSpec.EXACTLY) {\n    result=specSize;\n  }\n else {\n    result=(int)(-mAscent + mTextPaint.descent()) + getPaddingTop() + getPaddingBottom();\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "docstring": "determines the height of this view", "partition": "test"}
{"idx": "3023", "code": "protected <T extends TaskServiceDocument<E>,E extends Enum<E>>T waitForTaskCompletion(String documentSelfLink,Class<T> type) throws Throwable {\n  return waitForPropertyValue(documentSelfLink,type,TaskServiceDocument.FIELD_NAME_TASK_STAGE,Arrays.asList(TaskStage.FINISHED,TaskStage.FAILED,TaskStage.CANCELLED),true,waitForStageChangeCountLonger());\n}\n", "docstring": "waits until the given task completes and returns its final state .", "partition": "test"}
{"idx": "3024", "code": "private List<EndIsland> findSurroundingIslands(int chunkX,int chunkY,int chunksPerFragmentX,int chunksPerFragmentY){\n  List<EndIsland> result=new LinkedList<EndIsland>();\n  for (int y=-SURROUNDING_CHUNKS; y <= chunksPerFragmentY + SURROUNDING_CHUNKS; y++) {\n    for (int x=-SURROUNDING_CHUNKS; x <= chunksPerFragmentX + SURROUNDING_CHUNKS; x++) {\n      EndIsland island=tryCreateEndIsland(chunkX + x,chunkY + y);\n      if (island != null) {\n        result.add(island);\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "returns a list of all islands that might be touching a chunk - area .", "partition": "test"}
{"idx": "3025", "code": "void insertFunction2(ByteBuffer bb){\n  int baseSec=(int)(windowId >> 32);\n  bb.putInt(baseSec);\n  Integer operId=operatorId;\n  for (int i=0; i < 3; i++) {\n    byte num=(byte)(operId >> 8 * (2 - i));\n    bb.put(num);\n  }\n  bb.putShort((short)(windowId & 0xffff));\n  for (int i=0; i < 3; i++) {\n    byte num=(byte)(tupleId >> 8 * (2 - i));\n    bb.put(num);\n  }\n}\n", "docstring": "4b basesec | 3b operatorid | 2b windowid | 3b tupleid", "partition": "test"}
{"idx": "3026", "code": "private static boolean calculateGap(Rectangle a,Rectangle b,Rectangle gap){\n  if (a.intersects(b)) {\n    gap.width=0;\n    return false;\n  }\n  int ax1=a.x;\n  int ax2=a.x + a.width;\n  int ay1=a.y;\n  int ay2=a.y + a.height;\n  int bx1=b.x;\n  int bx2=b.x + b.width;\n  int by1=b.y;\n  int by2=b.y + b.height;\n  int xOverlap=Math.min(ax2,bx2) - Math.max(ax1,bx1);\n  int yOverlap=Math.min(ay2,by2) - Math.max(ay1,by1);\n  if (xOverlap <= 0 && yOverlap <= 0) {\n    gap.width=0;\n    return false;\n  }\n  if (xOverlap > 0) {\n    gap.x=Math.max(ax1,bx1);\n    gap.y=(ay1 > by1) ? by2 : ay2;\n    gap.width=xOverlap;\n    gap.height=-yOverlap;\n  }\n  if (yOverlap > 0) {\n    gap.x=(ax1 > bx1) ? bx2 : ax2;\n    gap.y=Math.max(ay1,by1);\n    gap.width=-xOverlap;\n    gap.height=yOverlap;\n  }\n  return true;\n}\n", "docstring": "calculate the gap rectangle between two rectangles", "partition": "test"}
{"idx": "3027", "code": "public boolean nextTile() throws ModelControlException {\n  boolean movedToRow=super.nextTile();\n  if (movedToRow) {\n    curTile=getTileIndex();\n    setDisplayFieldValue(TXT_PARENT_INDEX,parentIdx);\n    setDisplayFieldValue(TXT_CHOICE,choices[curTile]);\n    setDisplayFieldValue(TXT_INDEX,Integer.toString(curTile));\n  }\n  return movedToRow;\n}\n", "docstring": "moves the current tile position to the next available tile .", "partition": "test"}
{"idx": "3028", "code": "public boolean hasMyomerBooster(){\n  for (  Mounted mEquip : getMisc()) {\n    MiscType mtype=(MiscType)mEquip.getType();\n    if (mtype.hasFlag(MiscType.F_MASC) && !mEquip.isInoperable()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "does this ba mount a myomer booster ?", "partition": "test"}
{"idx": "3029", "code": "public static boolean isIntentAvailable(Context context,String action){\n  final PackageManager packageManager=context.getPackageManager();\n  final Intent intent=new Intent(action);\n  Log.d(MP_TAG,\"Looking for intent \" + action);\n  List<ResolveInfo> list=packageManager.queryIntentServices(intent,PackageManager.MATCH_DEFAULT_ONLY);\n  return list.size() > 0;\n}\n", "docstring": "indicates whether the specified action can be used as an intent . this method queries the package manager for installed packages that can respond to an intent with the specified action . if no suitable package is found , this method returns false .", "partition": "test"}
{"idx": "3030", "code": "private void sendCONNECTRequest() throws IOException {\n  int port=url.getPort();\n  requests.set(0,HTTP_CONNECT + \" \" + connectRequestURI(url)+ \" \"+ httpVersion,null);\n  requests.setIfNotSet(\"User-Agent\",userAgent);\n  String host=url.getHost();\n  if (port != -1 && port != url.getDefaultPort()) {\n    host+=\":\" + String.valueOf(port);\n  }\n  requests.setIfNotSet(\"Host\",host);\n  requests.setIfNotSet(\"Accept\",acceptString);\n  if (http.getHttpKeepAliveSet()) {\n    requests.setIfNotSet(\"Proxy-Connection\",\"keep-alive\");\n  }\n  setPreemptiveProxyAuthentication(requests);\n  if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n    logger.fine(requests.toString());\n  }\n  http.writeRequests(requests,null);\n}\n", "docstring": "send a connect request for establishing a tunnel to proxy server", "partition": "test"}
{"idx": "3031", "code": "private boolean isSelfSigned(X509Certificate cert){\n  return signedBy(cert,cert);\n}\n", "docstring": "returns true if the certificate is self - signed , false otherwise .", "partition": "test"}
{"idx": "3032", "code": "@RequestMapping(value={\"/\",\"\"},method=RequestMethod.PUT) @ResponseBody public RestWrapper insert(@ModelAttribute(\"userroles\") @Valid UserRoles userRoles,BindingResult bindingResult,Principal principal){\n  RestWrapper restWrapper=null;\n  if (bindingResult.hasErrors()) {\n    BindingResultError bindingResultError=new BindingResultError();\n    return bindingResultError.errorMessage(bindingResult);\n  }\n  try {\n    com.wipro.ats.bdre.md.dao.jpa.UserRoles jpaUserRoles=new com.wipro.ats.bdre.md.dao.jpa.UserRoles();\n    jpaUserRoles.setUserRoleId(userRoles.getUserRoleId());\n    jpaUserRoles.setRole(userRoles.getRole());\n    Users users=new Users();\n    users.setUsername(userRoles.getUsername());\n    jpaUserRoles.setUsers(users);\n    Integer userRolesId=userRolesDAO.insert(jpaUserRoles);\n    userRoles.setUserRoleId(userRolesId);\n    restWrapper=new RestWrapper(userRoles,RestWrapper.OK);\n    LOGGER.info(\"Record with ID:\" + userRoles.getUserRoleId() + \" inserted in UserRoles by User:\"+ principal.getName()+ userRoles);\n  }\n catch (  Exception e) {\n    LOGGER.error(e);\n    restWrapper=new RestWrapper(e.getMessage(),RestWrapper.ERROR);\n  }\n  return restWrapper;\n}\n", "docstring": "this method calls proc insertuserroles and adds a record in userroles table . it also validates the values passed .", "partition": "test"}
{"idx": "3033", "code": "public Set<WordToken> nearestWords(final int distance,final WordToken... start){\n  return nearestWords(distance,null,Arrays.asList(start));\n}\n", "docstring": "find the nearest neighbours within dependency distance links of the provided start dependencies .", "partition": "test"}
{"idx": "3034", "code": "public void rewind(){\nsynchronized (used) {\n    for (    ParameterPair pair : used) {\n      current.addParameter(pair.option,pair.value);\n    }\n    used.clear();\n  }\n}\n", "docstring": "rewind the configuration to the initial situation", "partition": "test"}
{"idx": "3035", "code": "public List<Interval> merge(List<Interval> intervals){\n  List<Interval> res=new ArrayList<>();\n  if (intervals == null || intervals.size() == 0) {\n    return res;\n  }\n  Collections.sort(intervals,null);\n  Interval prev=null;\n  for (  Interval i : intervals) {\n    if (prev == null || prev.end < i.start) {\n      res.add(i);\n      prev=i;\n    }\n else     if (i.end > prev.end) {\n      prev.end=i.end;\n    }\n  }\n  return res;\n}\n", "docstring": "sort and merge , o ( nlogn ) time . sort the intervals according to the start value in asc order . for each of the intervals , 1 ) add to result directly if the result list is empty . 2 ) add to result directly if there is no overlap between current interval and previous interval . 3 ) if there is overlap , we already know current interval \"'\" s start is larger than previous interval . we need to update the end of previous interval if current interval \"'\" s end is larger .", "partition": "test"}
{"idx": "3036", "code": "private String formatType(Object typeRep){\n  StringTokenizer tokenizer=new StringTokenizer(typeRep.toString(),\"()<>[], \",true);\n  StringBuilder sb=new StringBuilder();\n  while (tokenizer.hasMoreTokens()) {\n    String token=tokenizer.nextToken();\n    if (token.length() == 1 || token.lastIndexOf(\'.\') == -1)     sb.append(token);\n else {\n      int index=token.lastIndexOf(\'.\');\n      sb.append(token.substring(index + 1));\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "outputs the simple name of the type", "partition": "test"}
{"idx": "3037", "code": "@NotNull public static String sha1(@NotNull File keyStoreFile) throws Exception {\n  return sha1(keyStoreFile,null,null);\n}\n", "docstring": "get the sha1 hash of the first signing certificate inside a keystore , encoded as base16 ( each byte separated by \"'\" : \"'\" ) .", "partition": "test"}
{"idx": "3038", "code": "@Override public void panDomainAxes(double panRange,PlotRenderingInfo info,Point2D source){\n  XYPlot subplot=findSubplot(info,source);\n  if (subplot == null) {\n    return;\n  }\n  if (!subplot.isDomainPannable()) {\n    return;\n  }\n  PlotRenderingInfo subplotInfo=info.getSubplotInfo(info.getSubplotIndex(source));\n  if (subplotInfo == null) {\n    return;\n  }\n  for (int i=0; i < subplot.getDomainAxisCount(); i++) {\n    ValueAxis domainAxis=subplot.getDomainAxis(i);\n    if (domainAxis != null) {\n      domainAxis.pan(panRange);\n    }\n  }\n}\n", "docstring": "pans all domain axes by the specified percentage .", "partition": "test"}
{"idx": "3039", "code": "private void init(){\n  startController=new PourStartController();\n  startController.setCheckView(this);\n  waveController=new WaveController();\n  waveController.setCheckView(this);\n  PourFinishController finishController=new PourFinishController();\n  finishController.setCheckView(this);\n  TickController tickController=new TickController();\n  tickController.setCheckView(this);\n  List<BaseController> finishControllers=new ArrayList<>();\n  finishControllers.add(finishController);\n  finishControllers.add(tickController);\n  this.finishControllers=finishControllers;\n}\n", "docstring": "basic animations to build the liquidbutton", "partition": "test"}
{"idx": "3040", "code": "private JLabel createIconLabel(JCheckBox checkBox){\n  checkBox.setOpaque(false);\n  checkBox.setSize(checkBox.getMinimumSize());\n  Image image=new BufferedImage(checkBox.getWidth(),checkBox.getHeight(),Transparency.TRANSLUCENT);\n  Graphics g=image.getGraphics();\n  checkBox.paint(g);\n  g.dispose();\n  return new JLabel(new ImageIcon(image));\n}\n", "docstring": "creates an image of the checkbox and puts it in a label .", "partition": "test"}
{"idx": "3041", "code": "public void closeWindow(){\n  WindowEvent ev=new WindowEvent(frame,WindowEvent.WINDOW_CLOSING);\n  frame.dispatchEvent(ev);\n}\n", "docstring": "closes the window ( and opendial ) .", "partition": "test"}
{"idx": "3042", "code": "private void populateHostData(Host host,HostParam param){\n  if (param.getName() != null) {\n    host.setLabel(param.getName());\n  }\n  if (param.getHostName() != null) {\n    host.setHostName(param.getHostName());\n  }\n  if (param.getCluster() != null) {\n    host.setCluster(param.getCluster());\n  }\n  if (param.getOsVersion() != null) {\n    host.setOsVersion(param.getOsVersion());\n  }\n  if (param.getUserName() != null) {\n    host.setUsername(param.getUserName());\n  }\n  if (param.getPassword() != null) {\n    host.setPassword(param.getPassword());\n  }\n  if (param.getPortNumber() != null) {\n    host.setPortNumber(param.getPortNumber());\n  }\n  if (param.getUseSsl() != null) {\n    host.setUseSSL(param.getUseSsl());\n  }\n  if (param.getType() != null) {\n    host.setType(param.getType());\n  }\n  if (param.getDiscoverable() != null) {\n    host.setDiscoverable(param.getDiscoverable());\n  }\n  if (param.getVcenterDataCenter() != null) {\n    host.setVcenterDataCenter(NullColumnValueGetter.isNullURI(param.getVcenterDataCenter()) ? NullColumnValueGetter.getNullURI() : param.getVcenterDataCenter());\n  }\n  Cluster cluster=null;\n  if (!NullColumnValueGetter.isNullURI(param.getCluster())) {\n    cluster=queryObject(Cluster.class,param.getCluster(),true);\n    if (!NullColumnValueGetter.isNullURI(cluster.getVcenterDataCenter())) {\n      host.setVcenterDataCenter(cluster.getVcenterDataCenter());\n    }\n    if (!NullColumnValueGetter.isNullURI(cluster.getProject())) {\n      host.setProject(cluster.getProject());\n    }\n  }\n  if (param.getBootVolume() != null) {\n    host.setBootVolumeId(NullColumnValueGetter.isNullURI(param.getBootVolume()) ? NullColumnValueGetter.getNullURI() : param.getBootVolume());\n  }\n}\n", "docstring": "populate an instance of host with the provided host parameter", "partition": "test"}
{"idx": "3043", "code": "@Nullable public AvdInfo createOrUpdateAvd(@Nullable AvdInfo currentInfo,@NotNull String avdName,@NotNull Device device,@NotNull SystemImageDescription systemImageDescription,@NotNull ScreenOrientation orientation,boolean isCircular,@Nullable String sdCard,@Nullable File skinFolder,@NotNull Map<String,String> hardwareProperties,boolean createSnapshot){\n  if (!initIfNecessary()) {\n    return null;\n  }\n  File avdFolder;\n  try {\n    if (currentInfo != null) {\n      avdFolder=new File(currentInfo.getDataFolderPath());\n    }\n else {\n      avdFolder=AvdInfo.getDefaultAvdFolder(myAvdManager,avdName,myFileOp,true);\n    }\n  }\n catch (  AndroidLocation.AndroidLocationException e) {\n    IJ_LOG.error(\"Could not create AVD \" + avdName,e);\n    return null;\n  }\n  Dimension resolution=device.getScreenSize(orientation);\n  assert resolution != null;\n  String skinName=null;\n  if (skinFolder == null && isCircular) {\n    skinFolder=getRoundSkin(systemImageDescription);\n  }\n  if (FileUtil.filesEqual(skinFolder,AvdWizardUtils.NO_SKIN)) {\n    skinFolder=null;\n  }\n  if (skinFolder == null) {\n    skinName=String.format(\"%dx%d\",Math.round(resolution.getWidth()),Math.round(resolution.getHeight()));\n  }\n  if (orientation == ScreenOrientation.LANDSCAPE) {\n    hardwareProperties.put(HardwareProperties.HW_INITIAL_ORIENTATION,ScreenOrientation.LANDSCAPE.getShortDisplayValue().toLowerCase(Locale.ROOT));\n  }\n  if (currentInfo != null && !avdName.equals(currentInfo.getName())) {\n    boolean success=myAvdManager.moveAvd(currentInfo,avdName,currentInfo.getDataFolderPath(),SDK_LOG);\n    if (!success) {\n      return null;\n    }\n  }\n  return myAvdManager.createAvd(avdFolder,avdName,systemImageDescription.getSystemImage(),skinFolder,skinName,sdCard,hardwareProperties,device.getBootProps(),createSnapshot,false,currentInfo != null,SDK_LOG);\n}\n", "docstring": "update the given avd with the new settings or create one if no avd is specified . returns the created avd .", "partition": "test"}
{"idx": "3044", "code": "public void engineDeleteEntry(String alias) throws KeyStoreException {\nsynchronized (entries) {\n    entries.remove(alias.toLowerCase(Locale.ENGLISH));\n  }\n}\n", "docstring": "deletes the entry identified by the given alias from this keystore .", "partition": "test"}
{"idx": "3045", "code": "public DisjointSets(int numElements){\n  array=new int[numElements];\n  Arrays.fill(array,-1);\n}\n", "docstring": "construct a disjoint sets object .", "partition": "test"}
{"idx": "3046", "code": "public final void printClusters(PrintWriter out,List<ClusterData> clusterData,int[] matIndexToMsgInternalId) throws AdeException {\n  if (m_finalClusters == null) {\n    updateClusters(clusterData,matIndexToMsgInternalId);\n  }\n  for (  Map.Entry<String,Collection<Integer>> entry : m_finalClusters.entrySet()) {\n    final String n=entry.getKey();\n    final Collection<Integer> c=entry.getValue();\n    out.printf(\"%s\\t\",n);\n    for (    int m : c) {\n      out.printf(\"%d\\t\",matIndexToMsgInternalId[m]);\n    }\n    out.println();\n  }\n}\n", "docstring": "prints out the cluster information .", "partition": "test"}
{"idx": "3047", "code": "protected void addToGUI(JPanel gui,JTextField b,String cmd){\n  b.setActionCommand(cmd);\n  b.addActionListener(this);\n  gui.add(b);\n}\n", "docstring": "adds a feature to the gui attribute of the e00layer object", "partition": "test"}
{"idx": "3048", "code": "static TokenStream wrap(String fieldName,Analyzer indexAnalyzer,String content,char splitChar) throws IOException {\n  if (indexAnalyzer.getOffsetGap(fieldName) != 1) {\n    throw new IllegalArgumentException(\"offset gap of the provided analyzer should be 1 (field \" + fieldName + \")\");\n  }\n  int splitCharIdx=content.indexOf(splitChar);\n  if (splitCharIdx == -1) {\n    return indexAnalyzer.tokenStream(fieldName,content);\n  }\n  TokenStream subTokenStream=indexAnalyzer.tokenStream(fieldName,content.substring(0,splitCharIdx));\n  return new MultiValueTokenStream(subTokenStream,fieldName,indexAnalyzer,content,splitChar,splitCharIdx);\n}\n", "docstring": "note : the caller must remember to close the tokenstream eventually .", "partition": "test"}
{"idx": "3049", "code": "public final boolean check_trace(Polyline p_polyline,int p_half_width,int p_layer,NetNosList p_net_no_arr,int p_clearance_class_no,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_max_spring_over_recursion_depth){\n  AwtreeShapeSearch search_tree=search_tree_manager.get_default_tree();\n  int compensated_half_width=p_half_width + search_tree.get_clearance_compensation(p_clearance_class_no,p_layer);\n  ArrayList<ShapeTile> trace_shapes=p_polyline.offset_shapes(compensated_half_width,0,p_polyline.corner_count());\n  for (int index=0; index < trace_shapes.size(); ++index) {\n    ShapeTile curr_trace_shape=trace_shapes.get(index);\n    BrdFromSide from_side=new BrdFromSide(p_polyline,index + 1,curr_trace_shape);\n    boolean check_shove_ok=shove_trace_algo.shove_trace_check(curr_trace_shape,from_side,null,p_layer,p_net_no_arr,p_clearance_class_no,p_max_recursion_depth,p_max_via_recursion_depth,p_max_spring_over_recursion_depth,null);\n    if (!check_shove_ok)     return false;\n  }\n  return true;\n}\n", "docstring": "checks , if a trace polyline with the input parameters can be inserted while shoving aside obstacle traces and vias .", "partition": "test"}
{"idx": "3050", "code": "public static void delete(File fileOrFolder) throws IOException {\n  if (fileOrFolder != null)   delete(fileOrFolder.toPath());\n}\n", "docstring": "a method that will delete a file or folder . folders are removed recursively .", "partition": "test"}
{"idx": "3051", "code": "public static double[] expandArrayD(int bufferSize,double[] currentArray){\n  if (currentArray == null) {\n    return new double[bufferSize * 3];\n  }\n  int length=currentArray.length;\n  double[] ret=new double[length + bufferSize * 3];\n  System.arraycopy(currentArray,0,ret,0,length);\n  return ret;\n}\n", "docstring": "create an array to hold double data for 3d polygons and lines .", "partition": "test"}
{"idx": "3052", "code": "@SuppressWarnings(\"unchecked\") public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory){\n  if (configurableListableBeanFactory.containsBean(sessionFactoryBeanName)) {\n    BeanDefinition sessionFactoryBeanDefinition=configurableListableBeanFactory.getBeanDefinition(sessionFactoryBeanName);\n    MutablePropertyValues propertyValues=sessionFactoryBeanDefinition.getPropertyValues();\n    if (mappingResources != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"mappingResources\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"mappingResources\",new ArrayList());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      List existingMappingResources=(List)propertyValue.getValue();\n      existingMappingResources.addAll(mappingResources);\n    }\n    if (annotatedClasses != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"annotatedClasses\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"annotatedClasses\",new ArrayList());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      List existingMappingResources=(List)propertyValue.getValue();\n      existingMappingResources.addAll(annotatedClasses);\n    }\n    if (configLocations != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"configLocations\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"configLocations\",new ArrayList());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      List existingConfigLocations=(List)propertyValue.getValue();\n      existingConfigLocations.addAll(configLocations);\n    }\n    if (hibernateProperties != null) {\n      PropertyValue propertyValue=propertyValues.getPropertyValue(\"hibernateProperties\");\n      if (propertyValue == null) {\n        propertyValue=new PropertyValue(\"hibernateProperties\",new Properties());\n        propertyValues.addPropertyValue(propertyValue);\n      }\n      Properties existingHibernateProperties=(Properties)propertyValue.getValue();\n      existingHibernateProperties.putAll(hibernateProperties);\n    }\n  }\n else {\n    throw new NoSuchBeanDefinitionException(\"No bean named [\" + sessionFactoryBeanName + \"] exists within the bean factory. \"+ \"Cannot post process session factory to add Hibernate resource definitions.\");\n  }\n}\n", "docstring": "adds the annotated classes and the mapping resources to the existing session factory configuration .", "partition": "test"}
{"idx": "3053", "code": "protected int encode(double value,double lower,double upper,int nbits){\n  if (value < lower)   return 0;\n  int maxval=(int)(Math.pow(2,nbits) - 1);\n  if (value >= upper)   return maxval;\n  return (int)((value - lower) * ((maxval - 0) / (upper - lower)));\n}\n", "docstring": "encode value as an nbits unsigned integer", "partition": "test"}
{"idx": "3054", "code": "public long skipBytes(long n) throws IOException {\n  long count=0;\n  long gotsofar=0;\n  if (inputStream == null) {\n    reopen();\n    if (inputStream == null) {\n      reopen();\n      throw new IOException(\"Stream closed, can\'t be reopened\");\n    }\n  }\n  while (count < n) {\n    gotsofar=inputStream.skip(n - count);\n    if (gotsofar == 0) {\n      Debug.error(\"StreamInputReader can\'t skip \" + n + \" bytes as instructed\");\n      break;\n    }\n    count+=gotsofar;\n  }\n  count((int)count);\n  return count;\n}\n", "docstring": "skip over n bytes in the input file", "partition": "test"}
{"idx": "3055", "code": "public void handleTblDSAttributeMapListHrefActionRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    WSPPServiceDSAttributeMapListEditViewBean vb=(WSPPServiceDSAttributeMapListEditViewBean)getViewBean(WSPPServiceDSAttributeMapListEditViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    vb.populateValues((String)getDisplayFieldValue(\"tblDSAttributeMapListHrefAction\"));\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n    forwardTo();\n  }\n}\n", "docstring": "handles edit ldap attribute mapping request .", "partition": "test"}
{"idx": "3056", "code": "private V doGet(Object key){\n  if (key == null)   throw new NullPointerException();\n  Comparator<? super K> cmp=comparator;\n  outer:   for (; ; ) {\n    for (Node<K,V> b=findPredecessor(key,cmp), n=b.next; ; ) {\n      Object v;\n      int c;\n      if (n == null)       break outer;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      if ((v=n.value) == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (b.value == null || v == n)       break;\n      if ((c=cpr(cmp,key,n.key)) == 0) {\n        @SuppressWarnings(\"unchecked\") V vv=(V)v;\n        return vv;\n      }\n      if (c < 0)       break outer;\n      b=n;\n      n=f;\n    }\n  }\n  return null;\n}\n", "docstring": "gets value for key . almost the same as findnode , but returns the found value ( to avoid retries during re - reads )", "partition": "test"}
{"idx": "3057", "code": "void handleSwfLoadedEvent(SwfLoadedEvent e){\n  dumpSwfLoadedLine(e);\n}\n", "docstring": "called when a swf has been loaded by the player", "partition": "test"}
{"idx": "3058", "code": "private void quickReply(){\n  quickReplySmsMessage=smsPopupPager.getActiveMessage();\n  quickReply(quickReplySmsMessage.getReplyText());\n}\n", "docstring": "show the quick reply dialog , resetting the text in the edittext and storing the current smsmmsmessage ( in case another message comes in )", "partition": "test"}
{"idx": "3059", "code": "@Override protected synchronized void write(long offset,byte[] b) throws IOException {\n  if (byteBuffer != null) {\n    byteBuffer.position((int)offset);\n    byteBuffer.put(b);\n  }\n else {\n    throw new IOException(\"Write failed, file \" + getPath() + \" not mapped for I/O\");\n  }\n}\n", "docstring": "writes bytes to the underlying rrd file on the disk", "partition": "test"}
{"idx": "3060", "code": "public boolean hasChanged(){\n  return System.identityHashCode(config) != initialHash;\n}\n", "docstring": "checks if the config has changed since it was loaded .", "partition": "test"}
{"idx": "3061", "code": "void fixCompatibility(View root){\n  Queue<View> queue=new LinkedList<View>();\n  queue.add(root);\n  View view=null;\n  while ((view=queue.poll()) != null) {\n    if (view instanceof ViewGroup) {\n      ViewGroup group=(ViewGroup)view;\n      for (int i=0; i < group.getChildCount(); i++) {\n        queue.add(group.getChildAt(i));\n      }\n    }\n  }\n}\n", "docstring": "iterate through each view in the view hiearchy and implement standout specific compatibility workarounds . < p > currently , this method does the following : < p > nothing yet .", "partition": "test"}
{"idx": "3062", "code": "public void substituteHeader(int state,String header) throws AuthLoginException {\n  if (debug.messageEnabled()) {\n    debug.message(\"substituteHeader : state=\" + state + \", header=\"+ header);\n  }\n  if (state > stateLength) {\n    throw new AuthLoginException(bundleName,\"invalidState\",new Object[]{new Integer(state)});\n  }\n  Callback[] ext=getCallback(state);\n  if (ext.length <= 0) {\n    throw new AuthLoginException(bundleName,\"invalidCallbackIndex\",null);\n  }\n  if ((header != null) && (header.length() != 0)) {\n    PagePropertiesCallback pc=(PagePropertiesCallback)((Callback[])internal.get(state - 1))[0];\n    pc.setHeader(header);\n  }\n}\n", "docstring": "use this method to replace the header text from the xml file with new text . this method can be used multiple times on the same state replacing text with new text each time . useful for modules that control their own error handling .", "partition": "test"}
{"idx": "3063", "code": "public static Service createService(PatternTimetable timetable){\n  Calendar calendar=new Calendar();\n  calendar.monday=timetable.monday ? 1 : 0;\n  calendar.tuesday=timetable.tuesday ? 1 : 0;\n  calendar.wednesday=timetable.wednesday ? 1 : 0;\n  calendar.thursday=timetable.thursday ? 1 : 0;\n  calendar.friday=timetable.friday ? 1 : 0;\n  calendar.saturday=timetable.saturday ? 1 : 0;\n  calendar.sunday=timetable.sunday ? 1 : 0;\n  StringBuilder nameBuilder=new StringBuilder(\"MOD-\");\n  nameBuilder.append(timetable.monday ? \'M\' : \'x\');\n  nameBuilder.append(timetable.monday ? \'T\' : \'x\');\n  nameBuilder.append(timetable.monday ? \'W\' : \'x\');\n  nameBuilder.append(timetable.monday ? \'T\' : \'x\');\n  nameBuilder.append(timetable.monday ? \'F\' : \'x\');\n  nameBuilder.append(timetable.monday ? \'S\' : \'x\');\n  nameBuilder.append(timetable.monday ? \'S\' : \'x\');\n  Service service=new Service(nameBuilder.toString());\n  calendar.start_date=18500101;\n  calendar.end_date=22000101;\n  service.calendar=calendar;\n  return service;\n}\n", "docstring": "creates a gtfs - lib service object based on the information in the given patterntimetable , which is usually part of a modification deserialized from json .", "partition": "test"}
{"idx": "3064", "code": "public boolean remove(ImageInfo object){\n  final int location=getLocation(object);\n  final boolean removed=data.remove(object);\n  notifyItemRemoved(location);\n  return removed;\n}\n", "docstring": "removes the first occurrence of the specified object from the data .", "partition": "test"}
{"idx": "3065", "code": "public T allowedUsers(User... users){\n  List<User> usersList=Arrays.asList(users);\n  this.userPredicate=null;\n  return instance();\n}\n", "docstring": "allow a list of users to use this menu", "partition": "test"}
{"idx": "3066", "code": "VPlexDistributedDeviceInfo findDistributedDevice(String deviceName) throws VPlexApiException {\n  return findDistributedDevice(deviceName,false);\n}\n", "docstring": "finds the distributed device with the passed name .", "partition": "test"}
{"idx": "3067", "code": "static CopyState readCopyState(DataInput in) throws IOException {\n  byte[] infosBytes=new byte[in.readVInt()];\n  in.readBytes(infosBytes,0,infosBytes.length);\n  long gen=in.readVLong();\n  long version=in.readVLong();\n  Map<String,FileMetaData> files=readFilesMetaData(in);\n  int count=in.readVInt();\n  Set<String> completedMergeFiles=new HashSet<>();\n  for (int i=0; i < count; i++) {\n    completedMergeFiles.add(in.readString());\n  }\n  long primaryGen=in.readVLong();\n  return new CopyState(files,version,gen,infosBytes,completedMergeFiles,primaryGen,null);\n}\n", "docstring": "pulls copystate off the wire", "partition": "test"}
{"idx": "3068", "code": "public void notifyTasks(){\n  if (tracker.shouldInterruptTask()) {\n    for (    Thread t : threadMap.values()) {\n      t.interrupt();\n    }\n  }\n}\n", "docstring": "interrupts currently running tasks .", "partition": "test"}
{"idx": "3069", "code": "public boolean confirmOverwrite(final File file){\n  String message=\"The file \\\"\" + file.getName() + \"\\\" already exists. Overwrite?\";\n  Object[] options={\"OK\",\"Cancel\"};\n  return JOptionPane.YES_OPTION == JOptionPane.showOptionDialog(null,message,\"Warning\",JOptionPane.DEFAULT_OPTION,JOptionPane.WARNING_MESSAGE,null,options,options[0]);\n}\n", "docstring": "ask user whether to overwrite the give existing file .", "partition": "test"}
{"idx": "3070", "code": "public TvShowUpdateDatasourceTask(String datasource){\n  super(BUNDLE.getString(\"update.datasource\") + \" (\" + datasource+ \")\");\n  tvShowList=TvShowList.getInstance();\n  dataSources=new ArrayList<>(1);\n  dataSources.add(datasource);\n}\n", "docstring": "instantiates a new scrape task - to update a single datasource", "partition": "test"}
{"idx": "3071", "code": "public int findLine(int offset){\n  int line=lineStarts.length - 1;\n  while ((lineStarts[line] > offset) && (line > 0)) {\n    line--;\n  }\n  return line;\n}\n", "docstring": "line in the original source file for the given offset .", "partition": "test"}
{"idx": "3072", "code": "public void clear(){\n  Set<Sensor> oldSelection=new HashSet<Sensor>(selection);\n  selection.clear();\n  if (!oldSelection.isEmpty()) {\n    fireSelectionChanged(oldSelection,selection);\n  }\n}\n", "docstring": "clear this sensor selection model .", "partition": "test"}
{"idx": "3073", "code": "private void loadFileRecursively(String path,Map<String,ThriftFileElement> loadedFiles) throws IOException {\n  ThriftFileElement element=null;\n  File dir=null;\n  File file=findFirstExisting(path,null);\n  if (file != null) {\n    file=file.getCanonicalFile();\n    if (loadedFiles.containsKey(file.getAbsolutePath())) {\n      return;\n    }\n    dir=file.getParentFile();\n    element=loadSingleFile(file.getParentFile(),file.getName());\n  }\n  if (element == null) {\n    throw new FileNotFoundException(\"Failed to locate \" + path + \" in \"+ includePaths);\n  }\n  loadedFiles.put(file.getAbsolutePath(),element);\n  ImmutableList<IncludeElement> includes=element.includes();\n  if (includes.size() > 0) {\n    includePaths.addFirst(dir);\n    for (    IncludeElement include : includes) {\n      if (!include.isCpp()) {\n        loadFileRecursively(include.path(),loadedFiles);\n      }\n    }\n    includePaths.removeFirst();\n  }\n}\n", "docstring": "loads and parses a thrift file and all files included ( both directly and transitively ) by it .", "partition": "test"}
{"idx": "3074", "code": "public void assureProxyOk(){\n  if (socket.isClosed()) {\n    restart();\n  }\n}\n", "docstring": "assure that proxy is in a stable status .", "partition": "test"}
{"idx": "3075", "code": "@Override public boolean add(IMessage message){\n  return add(message,false);\n}\n", "docstring": "this adds a message object to the internal message cache .", "partition": "test"}
{"idx": "3076", "code": "public Key(byte[] hash){\n  if (hash.length != SHA1_HASH_LENGTH) {\n    throw new IllegalArgumentException(\"Invalid Hash must be 20bytes, was: \" + hash.length);\n  }\n  System.arraycopy(hash,0,this.hash,0,SHA1_HASH_LENGTH);\n}\n", "docstring": "creates a key with this hash", "partition": "test"}
{"idx": "3077", "code": "private static RoadPermission roadFlagComparision(Way iosmWay,String newTag,String newValue,EnumSet<EdgeStore.EdgeFlag> forwardExpected,EnumSet<EdgeStore.EdgeFlag> backwardExpected){\n  Way osmWay=new Way();\n  StringJoiner stringJoiner=new StringJoiner(\";\");\n  for (  OSMEntity.Tag tag : iosmWay.tags) {\n    osmWay.addTag(tag.key,tag.value);\n    stringJoiner.add(tag.key + \"=\" + tag.value);\n  }\n  if (newTag != null && newValue != null) {\n    osmWay.addTag(newTag,newValue);\n    stringJoiner.add(newTag + \"=\" + newValue);\n  }\n  Set<EdgeStore.EdgeFlag> forwardFiltered;\n  Set<EdgeStore.EdgeFlag> backwardFiltered;\n  RoadPermission roadPermission=traversalPermissionLabeler.getPermissions(osmWay);\n  forwardFiltered=filterFlags(roadPermission.forward);\n  backwardFiltered=filterFlags(roadPermission.backward);\n  String tags=\"Tags: \" + stringJoiner.toString();\n  assertEquals(tags,forwardExpected,forwardFiltered);\n  assertEquals(tags,backwardExpected,backwardFiltered);\n  return roadPermission;\n}\n", "docstring": "makes comparision of way with osmway tags and newtag with newvalue and compares forward and backward permissions with expected permissions copy of osmway is made since otherwise tags would be changed", "partition": "test"}
{"idx": "3078", "code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  IdentitySubjectModel subjectModel=getSubjectModel();\n  PolicyModel model=(PolicyModel)getModel();\n  super.beginDisplay(event);\n  if (!canModify) {\n    Map mapValues=getDefaultValues();\n    if ((mapValues != null) && !mapValues.isEmpty()) {\n      Set values=(Set)mapValues.get(AMIdentityMembershipCondition.AM_IDENTITY_NAME);\n      Set identityNames=helper.getAMIdentityNames(model.getUserSSOToken(),values);\n      propertySheetModel.setValue(VALUES_MULTIPLE_CHOICE_VALUE,AMAdminUtils.getString(identityNames,\",\",false));\n    }\n  }\n else {\n    CCDropDownMenu menu=(CCDropDownMenu)getChild(FILTER_TYPE);\n    Map supportedEntityTypes=model.getSupportedEntityTypes(realmName);\n    OptionList entityTypes=createOptionList(supportedEntityTypes);\n    entityTypes.add(0,\"policy.subject.select.identity.type\",\"\");\n    menu.setOptions(entityTypes);\n    menu.setValue(\"\");\n    CCAddRemove child=(CCAddRemove)getChild(VALUES_MULTIPLE_CHOICE_VALUE);\n    child.restoreStateData();\n    if (!submitCycle) {\n      helper.setSelectedIdentities(child,model.getUserSSOToken(),model.getUserLocale(),this,getDefaultValues());\n    }\n else {\n      OptionList possible=helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,getPossibleValues(subjectModel,realmName));\n      OptionList selected=addRemoveModel.getSelectedOptionList();\n      List selectedIds=AMAdminUtils.toList(selected);\n      child.resetStateData();\n      addRemoveModel.setAvailableOptionList(possible);\n      addRemoveModel.setSelectedOptionList(helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,selectedIds));\n    }\n  }\n}\n", "docstring": "sets the values to ui model .", "partition": "test"}
{"idx": "3079", "code": "public byte[] readBytes() throws IOException {\n  int len=readInt();\n  if (len == -1) {\n    return null;\n  }\n  byte[] b=DataUtils.newBytes(len);\n  in.readFully(b);\n  return b;\n}\n", "docstring": "read a byte array .", "partition": "test"}
{"idx": "3080", "code": "public String useRelativePathTipText(){\n  return \"Use relative rather than absolute paths\";\n}\n", "docstring": "tip text suitable for displaying int the gui", "partition": "test"}
{"idx": "3081", "code": "public Joiner join(Class<? extends DataObject> clazz,String alias,URI... ids){\n  return join(clazz,alias,new ArrayList<URI>(Arrays.asList(ids)));\n}\n", "docstring": "starts a new query not related to a previous class query .", "partition": "test"}
{"idx": "3082", "code": "public void closeFile(){\n  closeFile(true);\n}\n", "docstring": "closes the current tab", "partition": "test"}
{"idx": "3083", "code": "public List<Interface> showInterface() throws NetworkDeviceControllerException {\n  List<Interface> interfaces=new ArrayList<Interface>();\n  SSHPrompt[] prompts={SSHPrompt.POUND,SSHPrompt.GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  SSHPrompt prompt=sendWaitFor(MDSDialogProperties.getString(\"MDSDialog.showInterface.cmd\"),60000,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showInterface.interfacename.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.Portdescription.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.PortWWN.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.PortmodeFCID.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.Portvsan.match\"),MDSDialogProperties.getString(\"MDSDialog.showInterface.Portmode.match\")};\n  String[] groups=new String[10];\n  Interface intf=null;\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      intf=new Interface(groups[0]);\n    intf.setStatus(groups[1]);\n  interfaces.add(intf);\nbreak;\ncase 1:\nintf.setDescription(groups[0]);\nbreak;\ncase 2:\nintf.setWwpn(groups[0]);\nbreak;\ncase 3:\nintf.setMode(groups[0]);\nintf.setFcid(groups[1]);\nbreak;\ncase 4:\nintf.setVsan(groups[0]);\nbreak;\ncase 5:\nintf.setMode(groups[0]);\nbreak;\n}\n}\nreturn interfaces;\n}\n", "docstring": "issues the \" show interface \" command and collects in information into a list of interfaces . for now only parses fiber channel interfaces starting with \" fc \" , e . g . fc1 / 1 , fc2 / 20 , . . . this method is not currently used .", "partition": "test"}
{"idx": "3084", "code": "protected void clearDataLists(int obdService){\nswitch (obdService) {\ncase OBD_SVC_DATA:\ncase OBD_SVC_FREEZEFRAME:\n    pidSupported.clear();\n  PidPvs.clear();\nbreak;\ncase OBD_SVC_READ_CODES:\ncase OBD_SVC_PENDINGCODES:\ncase OBD_SVC_PERMACODES:\ntCodes.clear();\nbreak;\ncase OBD_SVC_VEH_INFO:\npidSupported.clear();\nVidPvs.clear();\nbreak;\n}\n}\n", "docstring": "clear data lists for selected service", "partition": "test"}
{"idx": "3085", "code": "public QuadEdge makeEdge(Vertex o,Vertex d){\n  QuadEdge q=QuadEdge.makeEdge(o,d);\n  quadEdges.add(q);\n  return q;\n}\n", "docstring": "creates a new quadedge , recording it in the edges list .", "partition": "test"}
{"idx": "3086", "code": "public static void sortSeqs(List<String> seqs){\n  Collections.sort(seqs,null);\n}\n", "docstring": "sort n string sequence list .", "partition": "test"}
{"idx": "3087", "code": "default B with(String key,long value){\n  return with(key,Long.toString(value));\n}\n", "docstring": "associate the given value with the specified key .", "partition": "test"}
{"idx": "3088", "code": "private void listDirectory(File directory,RelativeDirectory subdirectory,Set<JavaFileObject.Kind> fileKinds,boolean recurse,ListBuffer<JavaFileObject> resultList){\n  File d=subdirectory.getFile(directory);\n  if (!caseMapCheck(d,subdirectory))   return;\n  File[] files=d.listFiles();\n  if (files == null)   return;\n  if (sortFiles != null)   Arrays.sort(files,sortFiles);\n  for (  File f : files) {\n    String fname=f.getName();\n    if (f.isDirectory()) {\n      if (recurse && SourceVersion.isIdentifier(fname)) {\n        listDirectory(directory,new RelativeDirectory(subdirectory,fname),fileKinds,recurse,resultList);\n      }\n    }\n else {\n      if (isValidFile(fname,fileKinds)) {\n        JavaFileObject fe=new RegularFileObject(this,fname,new File(d,fname));\n        resultList.append(fe);\n      }\n    }\n  }\n}\n", "docstring": "insert all files in subdirectory subdirectory of directory directory which match filekinds into resultlist", "partition": "test"}
{"idx": "3089", "code": "private Shape decodeEdge(int width,int height){\n  path.reset();\n  path.moveTo(width - 2,0);\n  path.lineTo(width - 2,height - 4);\n  path.lineTo(width - 4,height - 2);\n  path.lineTo(3,height - 2);\n  return path;\n}\n", "docstring": "create the button edge shape .", "partition": "test"}
{"idx": "3090", "code": "private void testScenario(String aConfiguration,boolean anExpectingAnException,List<Method> aMethodsToCall) throws Exception {\n  if (aMethodsToCall.isEmpty()) {\n    testScenario(aConfiguration,anExpectingAnException,(Method)null);\n  }\n else {\n    for (    Method myMethod : aMethodsToCall) {\n      testScenario(aConfiguration,anExpectingAnException,myMethod);\n    }\n  }\n}\n", "docstring": "load an element with default configuration and call tostring . expect that the tostring triggers lazy loading which loads the nested element is available after closing the session .", "partition": "test"}
{"idx": "3091", "code": "public boolean hasBeenCalled(String resourceName){\n  return uris.contains(resourceName);\n}\n", "docstring": "checks if a resource has been requested using the short name of the resource .", "partition": "test"}
{"idx": "3092", "code": "@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n  super.readExternal(in);\n  isLeaf=in.readBoolean();\n  numEntries=in.readInt();\n}\n", "docstring": "reads the id of this node , the numentries and the entries array from the specified stream .", "partition": "test"}
{"idx": "3093", "code": "public ObjIdMap(){\n  this(11,0.75f);\n}\n", "docstring": "creates a new , empty map with the default initial capacity ( 11 buckets ) and load factor ( 0 . 75 ) .", "partition": "test"}
{"idx": "3094", "code": "public static ConnectionFactory newFailoverConnectionPool(Set<LDAPURL> servers,String username,char[] password,int maxSize,int heartBeatInterval,String heartBeatTimeUnit,Options ldapOptions){\n  List<ConnectionFactory> factories=new ArrayList<ConnectionFactory>(servers.size());\n  for (  LDAPURL ldapurl : servers) {\n    ConnectionFactory cf=Connections.newFixedConnectionPool(newConnectionFactory(ldapurl,username,password,heartBeatInterval,heartBeatTimeUnit,ldapOptions),maxSize);\n    factories.add(cf);\n  }\n  return loadBalanceFactories(factories);\n}\n", "docstring": "creates a new connection pool that is capable to failover to the servers defined in case there is an error .", "partition": "test"}
{"idx": "3095", "code": "public PrintfFormat(final String fmtArg) throws IllegalArgumentException {\n  this(Locale.getDefault(),fmtArg);\n}\n", "docstring": "constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings . control strings begin with unpaired percent signs . a pair of successive percent signs designates a single percent sign in the format .", "partition": "test"}
{"idx": "3096", "code": "public MessagePropertyKey(String description,Integer ordinal){\n  this.description=description;\n  this.ordinal=ordinal;\n}\n", "docstring": "creates a parameterized instance .", "partition": "test"}
{"idx": "3097", "code": "public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  JComponent comp=(c instanceof JComponent) ? (JComponent)c : null;\n  if (g instanceof Graphics2D) {\n    Graphics2D g2=(Graphics2D)g;\n    g2.translate(x,y);\n    paint(g2,comp,width,height);\n    g2.translate(-x,-y);\n  }\n else {\n    BufferedImage img=new BufferedImage(IMG_SIZE,IMG_SIZE,BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g2=(Graphics2D)img.getGraphics();\n    paint(g2,comp,width,height);\n    g2.dispose();\n    ImageScalingHelper.paint(g,x,y,width,height,img,INSETS,INSETS,ImageScalingHelper.PaintType.PAINT9_STRETCH,ImageScalingHelper.PAINT_ALL);\n  }\n}\n", "docstring": "paints the border for the specified component with the specified position and size .", "partition": "test"}
{"idx": "3098", "code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) public static LineByLineFileInputOperator restoreCheckPoint(LineByLineFileInputOperator checkPointOper,ByteArrayOutputStream bos) throws Exception {\n  Kryo kryo=new Kryo();\n  Input lInput=new Input(bos.toByteArray());\n  LineByLineFileInputOperator oper=kryo.readObject(lInput,checkPointOper.getClass());\n  lInput.close();\n  return oper;\n}\n", "docstring": "restores the checkpointed operator .", "partition": "test"}
{"idx": "3099", "code": "private static synchronized boolean isSupportedImpl(HttpCallerInfo hci){\n  if (supported == null) {\n    supported=new HashMap<String,Boolean>();\n    cache=new HashMap<String,Negotiator>();\n  }\n  String hostname=hci.host;\n  hostname=hostname.toLowerCase();\n  if (supported.containsKey(hostname)) {\n    return supported.get(hostname);\n  }\n  Negotiator neg=Negotiator.getNegotiator(hci);\n  if (neg != null) {\n    supported.put(hostname,true);\n    cache.put(hostname,neg);\n    return true;\n  }\n else {\n    supported.put(hostname,false);\n    return false;\n  }\n}\n", "docstring": "find out if the httpcallerinfo supports negotiate protocol . in order to find out yes or no , an initialization of a negotiator object against it is tried . the generated object will be cached under the name of ths hostname at a success try . < br > if this method is called for the second time on an httpcallerinfo with the same hostname , the answer is retrieved from cache .", "partition": "test"}
{"idx": "3100", "code": "public CProjectConfiguration(final INaviProject project,final ListenerProvider<IProjectListener> listeners,final SQLProvider provider,final int projectId,final String name,final String description,final Date creationDate,final Date modificationDate,final List<DebuggerTemplate> assignedDebuggers){\n  m_project=project;\n  m_listeners=listeners;\n  m_provider=provider;\n  m_id=projectId;\n  m_name=name;\n  m_description=description;\n  m_creationDate=new Date(creationDate.getTime());\n  m_modificationDate=new Date(modificationDate.getTime());\n  m_assignedDebuggers=new ArrayList<DebuggerTemplate>(assignedDebuggers);\n}\n", "docstring": "creates a new configuration object .", "partition": "test"}
{"idx": "3101", "code": "public Shape chartToScreenShape(Shape s){\n  GeneralPath p=new GeneralPath();\n  Transform inverse=Transform.makeTranslation(getAbsoluteX(),getAbsoluteY());\n  if (currentTransform != null) {\n    inverse.concatenate(currentTransform);\n  }\n  p.append(s.getPathIterator(inverse),false);\n  return p;\n}\n", "docstring": "converts a screen coordinate spaced shape to the same shape in the chart coordinate space", "partition": "test"}
{"idx": "3102", "code": "@Override public void addShutdownWindow(final Window window){\n  if (m_isShutDown) {\n    closeWindow(window);\n    return;\n  }\nsynchronized (this) {\n    if (m_isShutDown) {\n      closeWindow(window);\n      return;\n    }\n    m_windowsToCloseOnShutdown.add(window);\n  }\n}\n", "docstring": "add a latch that will be released when the game shuts down .", "partition": "test"}
{"idx": "3103", "code": "public PerformanceLogger(){\n  time1=System.currentTimeMillis();\n}\n", "docstring": "instantiates a new performance logger .", "partition": "test"}
{"idx": "3104", "code": "public AuthRequest authenticate(List discoveries,String returnToUrl) throws ConsumerException, MessageException {\n  return authenticate(discoveries,returnToUrl,returnToUrl);\n}\n", "docstring": "builds a authentication request message for the user specified in the discovery information provided as a parameter . < p > if the discoveries parameter contains more than one entry , it will iterate over them trying to establish an association . if an association cannot be established , the first entry is used with stateless mode .", "partition": "test"}
{"idx": "3105", "code": "public boolean isNumericalRun(String pin){\n  final int len=pin.length();\n  int prevDigit=Character.digit(pin.charAt(0),10);\n  int prevDiff=Integer.MAX_VALUE;\n  boolean isRun=true;\n  for (int i=1; isRun && i < len; i++) {\n    final int digit=Character.digit(pin.charAt(i),10);\n    final int diff=digit - prevDigit;\n    if (prevDiff != Integer.MAX_VALUE && diff != prevDiff) {\n      isRun=false;\n    }\n    prevDiff=diff;\n    prevDigit=digit;\n  }\n  return isRun;\n}\n", "docstring": "tests the string to see if it contains a numeric run . for example , \" 123456 \" , \" 0000 \" , \" 9876 \" , and \" 2468 \" would all match .", "partition": "test"}
{"idx": "3106", "code": "public static int uriType(String uri){\n  if (uri.indexOf(\':\') != -1) {\n    return ABS_URI;\n  }\n else   if (uri.startsWith(\"/\")) {\n    return ROOT_REL_URI;\n  }\n else {\n    return NOROOT_REL_URI;\n  }\n}\n", "docstring": "returns the type of a uri : abs_uri root_rel_uri noroot_rel_uri", "partition": "test"}
{"idx": "3107", "code": "public static boolean isResourceReference(String str){\n  return str.startsWith(BIG_QUOTE_LEFT) && str.endsWith(BIG_QUOTE_RIGHT) && str.charAt(1) == AT.charAt(0);\n}\n", "docstring": "return the str is resource reference or not .", "partition": "test"}
{"idx": "3108", "code": "public boolean leave() throws KeeperException, InterruptedException {\n  zooKeeper.delete(rootPath + \"/\" + name,0);\n  while (true) {\nsynchronized (mutex) {\n      List<String> list=zooKeeper.getChildren(rootPath,true);\n      if (list.size() > 0) {\n        mutex.wait();\n      }\n else {\n        return true;\n      }\n    }\n  }\n}\n", "docstring": "wait until all nodes leave barrier", "partition": "test"}
{"idx": "3109", "code": "public SelectClause addWithAsProvidedName(String propertyName,String asName){\n  selectList.add(new SelectClauseExpression(new PropertyValueExpression(propertyName),asName));\n  return this;\n}\n", "docstring": "adds a single property name and an \" as \" - asname for the column .", "partition": "test"}
{"idx": "3110", "code": "public void addInterface(String interfaceName){\n  short interfaceIndex=itsConstantPool.addClass(interfaceName);\n  itsInterfaces.add(Short.valueOf(interfaceIndex));\n}\n", "docstring": "add an interface implemented by this class . this method may be called multiple times for classes that implement multiple interfaces .", "partition": "test"}
{"idx": "3111", "code": "public static String cutFromIndexOf(String string,String substring){\n  int i=string.indexOf(substring);\n  if (i != -1) {\n    string=string.substring(i);\n  }\n  return string;\n}\n", "docstring": "cuts the string from the first index of provided substring to the end .", "partition": "test"}
{"idx": "3112", "code": "private Response requestHttpGetFromRegistry(String url) throws RegistryException {\n  try {\n    Response resp=http.get(url);\n    if (resp != null && resp.content != null) {\n      return resp;\n    }\n else {\n      throw new RegistryException(TYPE.BAD_RESPONSE,\"Response content is null\");\n    }\n  }\n catch (  ClassCastException e) {\n    throw new RegistryException(TYPE.BAD_RESPONSE,e);\n  }\ncatch (  ConnectException e) {\n    throw new RegistryException(TYPE.PROXY,e);\n  }\ncatch (  UnknownHostException e) {\n    try {\n      http.get(\"http://www.google.com\");\n    }\n catch (    Exception e1) {\n      throw new RegistryException(TYPE.NO_INTERNET,e1);\n    }\n    throw new RegistryException(TYPE.SITE_DOWN,e);\n  }\ncatch (  IOException e) {\n    throw new RegistryException(TYPE.IO_ERROR,e);\n  }\ncatch (  URISyntaxException e) {\n    throw new RegistryException(TYPE.BAD_REQUEST,\"Please check the request URL: \" + ((url != null) ? url : \"empty URL used!\"));\n  }\n}\n", "docstring": "executes an http get request against the gbif registry . if the content is not null , the response is returned . otherwise , if the content was null , or an exception occurred , it throws the appropriate type of registryexception .", "partition": "test"}
{"idx": "3113", "code": "public void testIterator() throws InterruptedException {\n  LinkedBlockingQueue q=populatedQueue(SIZE);\n  Iterator it=q.iterator();\n  while (it.hasNext()) {\n    assertEquals(it.next(),q.take());\n  }\n}\n", "docstring": "iterator iterates through all elements", "partition": "test"}
{"idx": "3114", "code": "public void init(RemoteAuthenticatedUser currentUser){\n  this.currentUser=currentUser;\n}\n", "docstring": "creates a new sharedconnectiondirectory which exposes share keys as connections . only explicitly - registered and valid share keys will be accessible .", "partition": "test"}
{"idx": "3115", "code": "private void removeTvShow(TvShow tvShow){\nsynchronized (root) {\n    TvShowTreeNode child=(TvShowTreeNode)nodeMap.get(tvShow);\n    DefaultMutableTreeNode parent=root;\n    if (child != null) {\n      int index=getIndexOfChild(parent,child);\n      nodeMap.remove(tvShow);\n      for (      TvShowEpisode episode : new ArrayList<>(tvShow.getEpisodes())) {\n        nodeMap.remove(episode);\n        episode.removePropertyChangeListener(propertyChangeListener);\n      }\n      tvShow.removePropertyChangeListener(propertyChangeListener);\n      child.removeAllChildren();\n      child.removeFromParent();\n      if (index > -1) {\n        TreeModelEvent event=new TreeModelEvent(this,parent.getPath(),new int[]{index},new Object[]{child});\n        for (        TreeModelListener listener : listeners) {\n          try {\n            listener.treeNodesRemoved(event);\n          }\n catch (          NullPointerException|ArrayIndexOutOfBoundsException npe) {\n          }\n        }\n      }\n    }\n  }\n}\n", "docstring": "removes the tv show .", "partition": "test"}
{"idx": "3116", "code": "private ComplianceFeature checkEncryptPolicy(org.wso2.emm.agent.beans.Operation operation){\n  boolean encryptStatus=(devicePolicyManager.getStorageEncryptionStatus() != devicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED && devicePolicyManager.getStorageEncryptionStatus() != devicePolicyManager.ENCRYPTION_STATUS_INACTIVE);\n  if ((operation.isEnabled() && encryptStatus) || (!operation.isEnabled() && !encryptStatus)) {\n    policy.setCompliance(true);\n  }\n else {\n    policy.setCompliance(false);\n    policy.setMessage(resources.getString(R.string.error_encrypt_policy));\n  }\n  return policy;\n}\n", "docstring": "checks device encrypt policy on the device ( device external storage encryption ) .", "partition": "test"}
{"idx": "3117", "code": "public static int instanceOf(Object o,Class<?> c){\n  if (o == null)   return FALSE;\n  return c.isAssignableFrom(o.getClass()) ? TRUE : FALSE;\n}\n", "docstring": "replacement function for the java instanceof instruction , which returns a distance integer", "partition": "test"}
{"idx": "3118", "code": "@Override public Void call() throws Exception {\n  MulticastSocket datagramSocket=null;\n  ExecutorService service=null;\n  try {\n    datagramSocket=new MulticastSocket(port);\n    datagramSocket.joinGroup(group);\n    service=Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory(\"GangliaListener\"));\n    final byte[] buffer=new byte[BUFFER_SIZE];\n    final DatagramPacket packet=new DatagramPacket(buffer,0,buffer.length);\n    listening=true;\n    while (true) {\n      try {\n        datagramSocket.receive(packet);\n        if (Thread.interrupted()) {\n          break;\n        }\n        final IGangliaMessage msg=decodeRecord(packet.getData(),packet.getOffset(),packet.getLength());\n        if (msg != null) {\n          service.submit(new DispatchTask(handler,msg));\n        }\n      }\n catch (      Throwable t) {\n        log.warn(t,t);\n      }\n    }\n    return (Void)null;\n  }\n  finally {\n    if (service != null) {\n      service.shutdown();\n    }\n    if (datagramSocket != null) {\n      datagramSocket.close();\n    }\n    listening=false;\n  }\n}\n", "docstring": "listens for ganglia messages . each message is decoded as as it is received . bad packets are dropped . valid messages are dispatched using a second thread to avoid latency in the thread which is listening to the ganglia protocol . < p > note : this method blocks and does not notice an interrupt . this is because jdk 6 does not support multicast nio . todo java 6 does not support non - blocking multicast receive . write a jdk 7 specific version of class class which uses multicast with non - blocking io and hence can be interrupted .", "partition": "test"}
{"idx": "3119", "code": "protected static void invalidateSwitchPoints(){\n  if (LOG_ENABLED) {\n    LOG.info(\"invalidating switch point\");\n  }\nsynchronized (IndyInterface.class) {\n    SwitchPoint old=switchPoint;\n    switchPoint=new SwitchPoint();\n    SwitchPoint.invalidateAll(new SwitchPoint[]{old});\n  }\n}\n", "docstring": "callback for constant meta class update change", "partition": "test"}
{"idx": "3120", "code": "public VdcConfig toConfigParam(Properties vdcInfo){\n  log.info(\"copy {} to the sync config param\",vdcInfo.getProperty(GeoServiceJob.VDC_SHORT_ID));\n  VdcConfig vdcConfig=new VdcConfig();\n  vdcConfig.setId(URIUtil.uri(vdcInfo.getProperty(GeoServiceJob.OPERATED_VDC_ID)));\n  vdcConfig.setShortId(vdcInfo.getProperty(GeoServiceJob.VDC_SHORT_ID));\n  vdcConfig.setSecretKey(vdcInfo.getProperty(GeoServiceJob.VDC_SECRETE_KEY));\n  String name=vdcInfo.getProperty(GeoServiceJob.VDC_NAME);\n  if ((name != null) && (!name.isEmpty())) {\n    vdcConfig.setName(name);\n  }\n  String description=vdcInfo.getProperty(GeoServiceJob.VDC_DESCRIPTION);\n  if ((description != null) && (!description.isEmpty())) {\n    vdcConfig.setDescription(description);\n  }\n  String endPnt=vdcInfo.getProperty(GeoServiceJob.VDC_API_ENDPOINT);\n  if (endPnt != null) {\n    vdcConfig.setApiEndpoint(endPnt);\n  }\n  vdcConfig.setGeoCommandEndpoint(vdcInfo.getProperty(GeoServiceJob.VDC_GEOCOMMAND_ENDPOINT));\n  vdcConfig.setGeoDataEndpoint(vdcInfo.getProperty(GeoServiceJob.VDC_GEODATA_ENDPOINT));\n  return vdcConfig;\n}\n", "docstring": "build vdcconfig for a vdc for syncvdcconfig call", "partition": "test"}
{"idx": "3121", "code": "protected OSXAdapter(String proxySignature,Object target,Method handler){\n  this.proxySignature=proxySignature;\n  this.targetObject=target;\n  this.targetMethod=handler;\n}\n", "docstring": "each osxadapter has the name of the eawt method it intends to listen for ( handleabout , for example ) , the object that will ultimately perform the task , and the method to be called on that object .", "partition": "test"}
{"idx": "3122", "code": "private double prediction(Instance inst){\n  double[] normalizedInstance=normalizedInstance(inst);\n  double normalizedPrediction=prediction(normalizedInstance);\n  return denormalizedPrediction(normalizedPrediction);\n}\n", "docstring": "output the prediction made by this perceptron on the given instance", "partition": "test"}
{"idx": "3123", "code": "protected Object finish(Map settings) throws WizardException {\n  return provider.finish(settings);\n}\n", "docstring": "instantiate whatever object ( if any ) the wizard creates from its gathered data .", "partition": "test"}
{"idx": "3124", "code": "protected void fireClusterChange(long timestamp,String type,String message){\n  if (listeners != null && !listeners.isEmpty()) {\n    ClusterEvent event=new ClusterEvent(this,timestamp,type,message);\n    Vector targets;\nsynchronized (this) {\n      targets=(Vector)listeners.clone();\n    }\n    Enumeration e=targets.elements();\n    while (e.hasMoreElements()) {\n      ClusterEventListener l=(ClusterEventListener)e.nextElement();\n      l.changeCluster(event);\n    }\n  }\n}\n", "docstring": "fire a clusterchangeevent to all registered listeners", "partition": "test"}
{"idx": "3125", "code": "public int rgbFor(int pixel){\n  return surfaceType.rgbFor(pixel,colorModel);\n}\n", "docstring": "returns the argb representation for the specified integer value which is packed in the format of the associated colormodel .", "partition": "test"}
{"idx": "3126", "code": "private boolean checkForCarry(final char[] ca1,final int icarry){\n  boolean carry=false;\n  if (icarry < ca1.length) {\n    if (ca1[icarry] == '6' || ca1[icarry] == '7' || ca1[icarry] == '8' || ca1[icarry] == '9') {\n      carry=true;\n    }\n else     if (ca1[icarry] == '5') {\n      int ii=icarry + 1;\n      for (; ii < ca1.length; ii++) {\n        if (ca1[ii] != '0') {\n          break;\n        }\n      }\n      carry=ii < ca1.length;\n      if (!carry && icarry > 0) {\n        carry=(ca1[icarry - 1] == '1' || ca1[icarry - 1] == '3' || ca1[icarry - 1] == '5' || ca1[icarry - 1] == '7' || ca1[icarry - 1] == '9');\n      }\n    }\n  }\n  return carry;\n}\n", "docstring": "check to see if the digits that are going to be truncated because of the precision should force a round in the preceding digits .", "partition": "test"}
{"idx": "3127", "code": "protected void addBottomComponent(Component bottomComponent){\n  c.weighty=2;\n  layout.setConstraints(bottomComponent,c);\n  contentPanel.add(bottomComponent);\n}\n", "docstring": "subclasses might add an additional component here which is seen during all steps , e . g . a data view table .", "partition": "test"}
{"idx": "3128", "code": "public static boolean deleteDirectoryFiles(Set<String> inputFilePathsAndNames){\n  if ((inputFilePathsAndNames == null)) {\n    return false;\n  }\n  boolean didSuccessfullyDeleteAllFiles=true;\n  try {\n    for (    String filePathAndName : inputFilePathsAndNames) {\n      File file=new File(filePathAndName);\n      if (!file.isDirectory()) {\n        boolean deleteSuccess=deleteFile(filePathAndName);\n        if (!deleteSuccess) {\n          logger.debug(\"Warning - \" + filePathAndName + \" failed to delete\");\n          didSuccessfullyDeleteAllFiles=false;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.debug(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n    return false;\n  }\n  return didSuccessfullyDeleteAllFiles;\n}\n", "docstring": "this is a quiet method . only deletes files . doesn \"'\" t delete directories .", "partition": "test"}
{"idx": "3129", "code": "public static File createTempDir(File dir,boolean cleanup) throws IOException {\n  if (!dir.mkdirs() && !dir.exists()) {\n    throw new IOException(String.format(\"Failed to create directory structure \'%s\'\",dir.toString()));\n  }\n  if (cleanup) {\n    addCleanupHook(dir.toPath());\n  }\n  return dir;\n}\n", "docstring": "create directory that is automatically cleaned up after the jvm shuts down through use of a runtime shutdown hook .", "partition": "test"}
{"idx": "3130", "code": "public static String readCookieIgnoreSpecialCharacters(HttpServletRequest request,String cookieName){\n  String cs=request.getHeader(\"cookie\");\n  if (cs == null)   return null;\n  int start=cs.indexOf(cookieName);\n  if (start < 0)   return null;\n  cs=cs.substring(start + 1 + cookieName.length());\n  int end=cs.indexOf(\';\');\n  if (end > 0) {\n    cs=cs.substring(0,end);\n  }\n  return cs;\n}\n", "docstring": "read all cookies from the request \"'\" s \"'\" cookie \"'\" header , and parse it based on cookie version 1 . < p / > this method can resolve tomcat \"'\" s bug in handling special characters in cookie ( the cookie is maybe written by other applications ) .", "partition": "test"}
{"idx": "3131", "code": "protected final void merge(@NotNull Set<LocalResourceRepository> visited,@NotNull ResourceType type,@NotNull SetMultimap<String,String> seenQualifiers,@NotNull ListMultimap<String,ResourceItem> result){\n  if (visited.contains(this)) {\n    return;\n  }\n  visited.add(this);\n  doMerge(visited,type,seenQualifiers,result);\n}\n", "docstring": "if this repository has not already been visited , merge its items of the given type into result .", "partition": "test"}
{"idx": "3132", "code": "private byte[] translateTransferableString(String str,long format) throws IOException {\n  Long lFormat=Long.valueOf(format);\n  String charset=getBestCharsetForTextFormat(lFormat,null);\n  String eoln=(String)nativeEOLNs.get(lFormat);\n  if (eoln != null) {\n    int length=str.length();\n    StringBuffer buffer=new StringBuffer(length * 2);\n    for (int i=0; i < length; i++) {\n      if (str.startsWith(eoln,i)) {\n        buffer.append(eoln);\n        i+=eoln.length() - 1;\n        continue;\n      }\n      char c=str.charAt(i);\n      if (c == '\\n') {\n        buffer.append(eoln);\n      }\n else {\n        buffer.append(c);\n      }\n    }\n    str=buffer.toString();\n  }\n  byte[] bytes=str.getBytes(charset);\n  Integer terminators=(Integer)nativeTerminators.get(lFormat);\n  if (terminators != null) {\n    int numTerminators=terminators.intValue();\n    byte[] terminatedBytes=new byte[bytes.length + numTerminators];\n    System.arraycopy(bytes,0,terminatedBytes,0,bytes.length);\n    for (int i=bytes.length; i < terminatedBytes.length; i++) {\n      terminatedBytes[i]=0x0;\n    }\n    bytes=terminatedBytes;\n  }\n  return bytes;\n}\n", "docstring": "translation function for converting string into a byte array . search - and - replace eoln . encode into the target format . append terminating nul bytes . java to native string conversion", "partition": "test"}
{"idx": "3133", "code": "public Position createPosition(int offset) throws BadLocationException {\n  while (queue.poll() != null) {\n    unusedMarks++;\n  }\n  if (unusedMarks > Math.max(5,(marks.size() / 10))) {\n    removeUnusedMarks();\n  }\n  int g0=getGapStart();\n  int g1=getGapEnd();\n  int index=(offset < g0) ? offset : offset + (g1 - g0);\n  search.index=index;\n  int sortIndex=findSortIndex(search);\n  MarkData m;\n  StickyPosition position;\n  if (sortIndex < marks.size() && (m=marks.elementAt(sortIndex)).index == index && (position=m.getPosition()) != null) {\n  }\n else {\n    position=new StickyPosition();\n    m=new MarkData(index,position,queue);\n    position.setMark(m);\n    marks.insertElementAt(m,sortIndex);\n  }\n  return position;\n}\n", "docstring": "creates a position within the content that will track change as the content is mutated .", "partition": "test"}
{"idx": "3134", "code": "public static String pad(String string,int n,String padding,boolean right){\n  if (n < 0) {\n    n=0;\n  }\n  if (n < string.length()) {\n    return string.substring(0,n);\n  }\n else   if (n == string.length()) {\n    return string;\n  }\n  char paddingChar;\n  if (padding == null || padding.length() == 0) {\n    paddingChar=' ';\n  }\n else {\n    paddingChar=padding.charAt(0);\n  }\n  StringBuilder buff=new StringBuilder(n);\n  n-=string.length();\n  if (right) {\n    buff.append(string);\n  }\n  for (int i=0; i < n; i++) {\n    buff.append(paddingChar);\n  }\n  if (!right) {\n    buff.append(string);\n  }\n  return buff.toString();\n}\n", "docstring": "pad a string . this method is used for the sql function rpad and lpad .", "partition": "test"}
{"idx": "3135", "code": "private final void resetDTX(AffineTransform at){\n  fsref=null;\n  dtx=at;\n  invdtx=null;\n  if (!dtx.isIdentity()) {\n    try {\n      invdtx=dtx.createInverse();\n    }\n catch (    NoninvertibleTransformException e) {\n    }\n  }\n  if (gti != null) {\n    gti.strikesRef=null;\n  }\n}\n", "docstring": "change the dtx for the strike refs we use . keeps a reference to the at . at must not contain translation . called by setrendertransform , setdtx , initfontdata .", "partition": "test"}
{"idx": "3136", "code": "public static void addActivityListener(ActivityListener listener){\n  if (listener != null) {\n    startTracking();\n    listeners.add(listener);\n  }\n}\n", "docstring": "adds a listener that will be informed one time about user activity , then removed .", "partition": "test"}
{"idx": "3137", "code": "public void addMutedUsername(final String username,final Date muteTill){\n  if (isUsernameMuted(username)) {\n    removeMutedUsername(username);\n  }\n  Timestamp muteTillTs=null;\n  if (muteTill != null) {\n    muteTillTs=new Timestamp(muteTill.getTime());\n  }\n  s_logger.fine(\"Muting username:\" + username);\n  final Connection con=Database.getConnection();\n  try {\n    final PreparedStatement ps=con.prepareStatement(\"insert into muted_usernames (username, mute_till) values (?, ?)\");\n    ps.setString(1,username);\n    ps.setTimestamp(2,muteTillTs);\n    ps.execute();\n    ps.close();\n    con.commit();\n  }\n catch (  final SQLException sqle) {\n    if (sqle.getErrorCode() == 30000) {\n      s_logger.info(\"Tried to create duplicate muted username:\" + username + \" error:\"+ sqle.getMessage());\n      return;\n    }\n    s_logger.log(Level.SEVERE,\"Error inserting muted username:\" + username,sqle);\n    throw new IllegalStateException(sqle.getMessage());\n  }\n finally {\n    DbUtil.closeConnection(con);\n  }\n}\n", "docstring": "mute the given username . if mutetill is not null , the mute will expire when mutetill is reached . < p > if this username is already muted , this call will update the mute_end .", "partition": "test"}
{"idx": "3138", "code": "private Response<Bitmap> doParse(NetworkResponse response){\n  byte[] data=response.data;\n  Log.d(\"Checksum\",\"Decode\");\n  BitmapFactory.Options decodeOptions=new BitmapFactory.Options();\n  Bitmap bitmap=null;\n  Log.d(\"Checksum\",\"Decodess\");\n  decodeOptions.inJustDecodeBounds=true;\n  BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  int actualWidth=decodeOptions.outWidth;\n  int actualHeight=decodeOptions.outHeight;\n  int desiredWidth=getResizedDimension(mMaxWidth,mMaxHeight,actualWidth,actualHeight,mScaleType);\n  int desiredHeight=getResizedDimension(mMaxHeight,mMaxWidth,actualHeight,actualWidth,mScaleType);\n  decodeOptions.inJustDecodeBounds=false;\n  decodeOptions.inSampleSize=findBestSampleSize(actualWidth,actualHeight,desiredWidth,desiredHeight);\n  Bitmap tempBitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() > desiredHeight)) {\n    bitmap=Bitmap.createScaledBitmap(tempBitmap,desiredWidth,desiredHeight,true);\n    tempBitmap.recycle();\n  }\n else {\n    bitmap=tempBitmap;\n  }\n  if (bitmap == null) {\n    return Response.error(new ParseError(response));\n  }\n else {\n    return Response.success(bitmap,HttpHeaderParser.parseCacheHeaders(response));\n  }\n}\n", "docstring": "the real guts of parsenetworkresponse . broken out for readability .", "partition": "test"}
{"idx": "3139", "code": "public boolean isEmpty(){\n  return mSelectedWidgets.isEmpty();\n}\n", "docstring": "check if the selection is empty", "partition": "test"}
{"idx": "3140", "code": "public void close() throws IOException {\n  if (!closed) {\n    try {\n      finish();\n    }\n  finally {\n      out.close();\n      closed=true;\n    }\n  }\n}\n", "docstring": "writes any remaining uncompressed data to the output stream and closes the underlying output stream .", "partition": "test"}
{"idx": "3141", "code": "protected abstract C newParcelableAdapterInstance(List<Object> items);\n", "docstring": "create a new instance of your parcelableadapter using the provided list of items .", "partition": "test"}
{"idx": "3142", "code": "public static void nextBytes(byte[] bytes){\n  wasAccessed=true;\n  for (int i=0; i < bytes.length; )   for (int rnd=nextInt(), n=Math.min(bytes.length - i,4); n-- > 0; rnd>>=8)   bytes[i++]=(byte)rnd;\n}\n", "docstring": "replacement function for nextbytes", "partition": "test"}
{"idx": "3143", "code": "protected void drawLowFarOut(double aRadius,Graphics2D g2,double xx,double m){\n  double side=aRadius * 2;\n  g2.draw(new Line2D.Double(xx - side,m - side,xx + side,m - side));\n  g2.draw(new Line2D.Double(xx - side,m - side,xx,m));\n  g2.draw(new Line2D.Double(xx + side,m - side,xx,m));\n}\n", "docstring": "draws a triangle to indicate the presence of far out values .", "partition": "test"}
{"idx": "3144", "code": "private Set<ObjectName> objectNamesFromFilteredNamedObjects(Set<NamedObject> list,QueryExp query){\n  Set<ObjectName> result=new HashSet<ObjectName>();\n  if (query == null) {\n    for (    NamedObject no : list) {\n      result.add(no.getName());\n    }\n  }\n else {\n    final MBeanServer oldServer=QueryEval.getMBeanServer();\n    query.setMBeanServer(server);\n    try {\n      for (      NamedObject no : list) {\n        boolean res;\n        try {\n          res=query.apply(no.getName());\n        }\n catch (        Exception e) {\n          res=false;\n        }\n        if (res) {\n          result.add(no.getName());\n        }\n      }\n    }\n  finally {\n      query.setMBeanServer(oldServer);\n    }\n  }\n  return result;\n}\n", "docstring": "applies the specified queries to the set of namedobjects .", "partition": "test"}
{"idx": "3145", "code": "private Element createEndPoint(String name,String attrBinding,String attrLocation,String attrResponseLocation) throws DOMException {\n  if (name == null) {\n    throw new IllegalArgumentException(\"Null name\");\n  }\n  if (attrBinding == null) {\n    throw new IllegalArgumentException(\"Null binding\");\n  }\n  if (attrLocation == null) {\n    throw new IllegalArgumentException(\"Null location\");\n  }\n  Element endPt=doc.createElement(name);\n  endPt.setAttribute(SAMLNames.BINDING,attrBinding);\n  endPt.setAttribute(SAMLNames.LOCATION,attrLocation);\n  if (attrResponseLocation != null) {\n    endPt.setAttribute(SAMLNames.RESPLOC,attrResponseLocation);\n  }\n  return endPt;\n}\n", "docstring": "create end point element in dom .", "partition": "test"}
{"idx": "3146", "code": "void putFile(String relativePath,Codebase codebase){\n  try {\n    File dest=new File(rootDirectory.getAbsolutePath(),relativePath);\n    File src=codebase.getFile(relativePath);\n    boolean srcExists=filesystem.exists(src);\n    boolean destExists=filesystem.exists(dest);\n    boolean srcExecutable=filesystem.isExecutable(src);\n    boolean destExecutable=filesystem.isExecutable(dest);\n    if (!srcExists && !destExists) {\n      throw new MoeProblem(\"Neither src nor dests exists. Unreachable code:%n%s%n%s%n%s\",relativePath,src,dest);\n    }\n    if (!srcExists) {\n      util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"rm\",relativePath);\n      return;\n    }\n    try {\n      filesystem.makeDirsForFile(dest);\n      filesystem.copyFile(src,dest);\n    }\n catch (    IOException e) {\n      throw new MoeProblem(e.getMessage());\n    }\n    if (!destExists) {\n      util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"add\",\"--parents\",relativePath);\n    }\n    String mimeType=guessMimeType(relativePath);\n    if (mimeType != null) {\n      try {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propset\",\"svn:mime-type\",mimeType,relativePath);\n      }\n catch (      CommandRunner.CommandException e) {\n        ui.message(\"Error setting mime-type for %s\",relativePath);\n      }\n    }\n    if (destExecutable != srcExecutable) {\n      if (srcExecutable) {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propset\",\"svn:executable\",\"*\",relativePath);\n      }\n else {\n        util.runSvnCommandWithWorkingDirectory(rootDirectory.getAbsolutePath(),\"propdel\",\"svn:executable\",relativePath);\n      }\n    }\n  }\n catch (  CommandRunner.CommandException e) {\n    throw new MoeProblem(\"problem occurred while running svn: \" + e.stderr);\n  }\n}\n", "docstring": "put file from c into this writer . ( helper function . )", "partition": "test"}
{"idx": "3147", "code": "public String toString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(toString(getClass()));\n  buffer.append(\"[UseDefault=\");\n  buffer.append(isUseDefault());\n  buffer.append(\", UseLocaleFormat=\");\n  buffer.append(useLocaleFormat);\n  if (pattern != null) {\n    buffer.append(\", Pattern=\");\n    buffer.append(pattern);\n  }\n  if (locale != null) {\n    buffer.append(\", Locale=\");\n    buffer.append(locale);\n  }\n  buffer.append(\']\');\n  return buffer.toString();\n}\n", "docstring": "provide a string representation of this number converter .", "partition": "test"}
{"idx": "3148", "code": "public void test_multipleResourceLocking_resources10_locktries10() throws Exception {\n  final Properties properties=new Properties();\n  properties.setProperty(TestOptions.NTHREADS,\"20\");\n  properties.setProperty(TestOptions.NTASKS,\"1000\");\n  properties.setProperty(TestOptions.NRESOURCES,\"100\");\n  properties.setProperty(TestOptions.MIN_LOCKS,\"10\");\n  properties.setProperty(TestOptions.MAX_LOCKS,\"10\");\n  properties.setProperty(TestOptions.MAX_LOCK_TRIES,\"10\");\n  properties.setProperty(TestOptions.PREDECLARE_LOCKS,\"false\");\n  properties.setProperty(TestOptions.SORT_LOCK_REQUESTS,\"false\");\n  properties.setProperty(TestOptions.TIMEOUT,Long.toString(3 * 60));\n  doComparisonTest(properties);\n}\n", "docstring": "test where each operation locks one or more resources . < p > note : this condition provides the basis for deadlocks . in fact , since we have 10 resource locks for each operation and only 100 operations the chances of a deadlock on any given operation are extremely high . however , since we are predeclaring our locks and the lock requests are being sorted no deadlocks should result .", "partition": "test"}
{"idx": "3149", "code": "private byte[] convertBitmapToBytes(final Bitmap bitmap){\n  int size=bitmap.getRowBytes() * bitmap.getHeight();\n  ByteArrayOutputStream out=new ByteArrayOutputStream(size);\n  try {\n    if (bitmap.compress(Bitmap.CompressFormat.PNG,0,out)) {\n      return out.toByteArray();\n    }\n    if (sLogger.isActivated()) {\n      sLogger.debug(\"Unable to convert bitmap, compression failed\");\n    }\n    return null;\n  }\n  finally {\n    CloseableUtils.tryToClose(out);\n  }\n}\n", "docstring": "converts the specified bitmap to a byte array .", "partition": "test"}
{"idx": "3150", "code": "private static void saveTemplate(File parentDir,FileTemplateBase template,final String lineSeparator) throws IOException {\n  final File templateFile=new File(parentDir,encodeFileName(template.getName(),template.getExtension()));\n  FileOutputStream fileOutputStream;\n  try {\n    fileOutputStream=new FileOutputStream(templateFile);\n  }\n catch (  FileNotFoundException e) {\n    FileUtil.delete(templateFile);\n    fileOutputStream=new FileOutputStream(templateFile);\n  }\n  OutputStreamWriter outputStreamWriter=new OutputStreamWriter(fileOutputStream,CharsetToolkit.UTF8_CHARSET);\n  String content=template.getText();\n  if (!lineSeparator.equals(\"\\n\")) {\n    content=StringUtil.convertLineSeparators(content,lineSeparator);\n  }\n  outputStreamWriter.write(content);\n  outputStreamWriter.close();\n  fileOutputStream.close();\n}\n", "docstring": "save template to file . if template is new , it is saved to specified directory . otherwise it is saved to file from which it was read . if template was not modified , it is not saved . todo : review saving algorithm", "partition": "test"}
{"idx": "3151", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(3);\n  newVector.addElement(new Option(\"\\tSize of each bag, as a percentage of the\\n\" + \"\\ttraining set size. (default 100)\",\"P\",1,\"-P\"));\n  newVector.addElement(new Option(\"\\tCalculate the out of bag error.\",\"O\",0,\"-O\"));\n  newVector.addElement(new Option(\"\\tRepresent copies of instances using weights rather than explicitly.\",\"-represent-copies-using-weights\",0,\"-represent-copies-using-weights\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "3152", "code": "public void addComposite(TransformTreeNode node){\n  parts.add(node);\n}\n", "docstring": "adds a composite operation to the transform node . < p > as soon as a node is added , the transform node is considered a composite operation instead of a primitive transform .", "partition": "test"}
{"idx": "3153", "code": "protected static void postProcessFlood(IHex[] hexSet,int modifier){\n  int n;\n  IHex field;\n  ITerrainFactory f=Terrains.getTerrainFactory();\n  for (n=0; n < hexSet.length; n++) {\n    field=hexSet[n];\n    int elev=field.getLevel() - modifier;\n    if ((elev == 0) && !(field.containsTerrain(Terrains.WATER)) && !(field.containsTerrain(Terrains.PAVEMENT))) {\n      field.addTerrain(f.createTerrain(Terrains.SWAMP,1));\n    }\n else     if (elev < 0) {\n      if (elev < -4) {\n        elev=-4;\n      }\n      field.removeAllTerrains();\n      field.addTerrain(f.createTerrain(Terrains.WATER,-elev));\n      field.setLevel(modifier);\n    }\n  }\n}\n", "docstring": "flood negative hex levels shoreline / salt marshes effect works best with more elevation", "partition": "test"}
{"idx": "3154", "code": "public ModuleHandle addModule(String moduleName,String sessionKey){\n  String sanitizedModuleName=generateUniqueNameIfNullOrEmpty(moduleName,\"Module\");\n  ModuleHandle moduleHandle=new ModuleHandle(sanitizedModuleName,sessionKey);\nsynchronized (privateInstanceLock) {\n    modules.add(moduleHandle);\n  }\n  setTerminated(false);\n  return moduleHandle;\n}\n", "docstring": "add a module that was loaded in this browser tab . if the module name is null or the empty string , a name will be generated . it is legal to add a module with the same name and session key more than once . if this browser tab was marked as terminated , then it will be reset to the unterminated state . an event will be fired to all listeners on the model . note : this method fires events . if you \"'\" re invoking this method from other model classes , make sure that no locks are being held .", "partition": "test"}
{"idx": "3155", "code": "private static void expand2DigitNumber(String numberString,WordRelation wordRelation,Item tokenItem){\n  if (numberString.charAt(0) == '0') {\n    if (numberString.charAt(1) == '0') {\n    }\n else {\n      String number=digit2num[numberString.charAt(1) - '0'];\n      wordRelation.addWord(tokenItem,number);\n    }\n  }\n else   if (numberString.charAt(1) == '0') {\n    String number=digit2enty[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,number);\n  }\n else   if (numberString.charAt(0) == '1') {\n    String number=digit2teen[numberString.charAt(1) - '0'];\n    wordRelation.addWord(tokenItem,number);\n  }\n else {\n    String enty=digit2enty[numberString.charAt(0) - '0'];\n    wordRelation.addWord(tokenItem,enty);\n    expandDigits(numberString.substring(1,numberString.length()),wordRelation,tokenItem);\n  }\n}\n", "docstring": "expands a two - digit string into a list of english words .", "partition": "test"}
{"idx": "3156", "code": "protected int indexOf(String buffer,int start,int end,char ch){\n  for (int i=start; i < end; i++) {\n    if (buffer.charAt(i) == ch) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "docstring": "computes index of given char within stringbuffer", "partition": "test"}
{"idx": "3157", "code": "@Override public boolean isEnabled(){\n  if ((attributeSelectionPanel != null) && !isValueOnly()) {\n    return attributeSelectionPanel.isEnabled();\n  }\n else {\n    if (this.crsComboBox != null) {\n      return crsComboBox.isEnabled();\n    }\n  }\n  return false;\n}\n", "docstring": "checks if is enabled .", "partition": "test"}
{"idx": "3158", "code": "public static double variance(double[] x,double mean){\n  double var=0;\n  int count=x.length;\n  for (  double aX : x) {\n    if (Double.isNaN(aX)) {\n      count--;\n    }\n else {\n      double diff=aX - mean;\n      var+=diff * diff;\n    }\n  }\n  if (count < 2) {\n    count=1;\n  }\n else {\n    count=count - 1;\n  }\n  return var / (double)count;\n}\n", "docstring": "compute variance ( ml estimator )", "partition": "test"}
{"idx": "3159", "code": "private void stashRequestUser(RequestAndResponse requestAndResponse){\n  if (requestAndResponse.wasUserAlreadyStashed) {\n    return;\n  }\n  requestAndResponse.wasUserAlreadyStashed=true;\n  final User user=dbLogic.getUserById(getEffectiveUserId(requestAndResponse));\n  if (user != null) {\n    requestAndResponse.userIsAdmin=user.getIsAdmin();\n    requestAndResponse.userIsAccountClosed=user.getIsAccountClosed();\n    requestAndResponse.userOptions=user.getOptions();\n  }\n else {\n    requestAndResponse.userOptions=\"{}\";\n  }\n}\n", "docstring": "stashes user information in the requestandresponse to reduce the number of queries and transactions .", "partition": "test"}
{"idx": "3160", "code": "@Override public void sendLocationList(){\n  List<Location> locationList=lm.getLocationsByNameList();\n  ArrayList<Attribute> location;\n  for (  Location loc : locationList) {\n    location=new ArrayList<Attribute>(1);\n    location.add(new Attribute(LOCATIONS,loc));\n    try {\n      sendMessage(location);\n    }\n catch (    IOException ioe) {\n      log.debug(\"could not send train \" + loc.getName());\n    }\n  }\n}\n", "docstring": "send a list of locations known by operations to the client", "partition": "test"}
{"idx": "3161", "code": "@Override public boolean isInsideSoftWrap(@NotNull VisualPosition visual){\n  return isInsideSoftWrap(visual,false);\n}\n", "docstring": "allows to answer if given visual position points to soft wrap - introduced virtual space .", "partition": "test"}
{"idx": "3162", "code": "static public InputStream findClusterXML(String _clusterXML){\n  String schemaNameToBeUsed=_clusterXML;\n  InputStream schemaInputStream;\n  String schemaFilePath=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + schemaNameToBeUsed+ ClusterXML.CLUSTER_XML_FILE_SUFFIX;\n  schemaInputStream=getResourceStream(schemaFilePath);\n  if (schemaInputStream != null) {\n    if (_logger.isLoggable(Level.INFO)) {\n      _logger.info(\"Loaded the cluster XML < \" + getResourceURL(schemaNameToBeUsed) + \" > for the cluster config setup.\");\n    }\n    return schemaInputStream;\n  }\n else {\n    String defaultSchemaFileName=Constants.Container.CONTAINER_CONFIG_DIRECTORY + \"/\" + Constants.Schemas.DEFAULT_SCHEMA+ ClusterXML.CLUSTER_XML_FILE_SUFFIX;\n    schemaInputStream=getResourceStream(defaultSchemaFileName);\n    if (schemaInputStream != null) {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.warning(\"Could not find the cluster xml file: \" + schemaFilePath + \".\\n Loaded the default cluster xml < \"+ getResourceURL(defaultSchemaFileName)+ \" > for the cluster config setup.\");\n      }\n      return schemaInputStream;\n    }\n else {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.warning(\"The requested cluster xml file does not exist in the following path: \" + defaultSchemaFileName);\n      }\n    }\n  }\n  return schemaInputStream;\n}\n", "docstring": "look for the requested cluster xml file in the resourcebundle ( classpath ) under < ee home dir > / config / < reqested_schema_name > - cluster . xml . if it does no find it in the disk ( the default ) it looks for it in the jspaces . jar , in same path . if the requested schema file does not exist in the disk config / schemas dir . . in this case , do we load the default schema file which always exist in the resource under the path config / default - cluster . xml . note that the < com . gs . home > must be part of the classpath , in this case .", "partition": "test"}
{"idx": "3163", "code": "public boolean isValid(World world){\n  return true;\n}\n", "docstring": "used to determine if a task is valid . this is called each time the task is accessed . it checks if the sender / creator is valid . it is crustal that the sender is valid , because task are stored in the sender . if this returns false the task is usually discarded .", "partition": "test"}
{"idx": "3164", "code": "public void clear(){\n  Arrays.fill(ritems,0,rsize,null);\n  Arrays.fill(pitems,0,psize,null);\n  rsize=0;\n  psize=0;\n}\n", "docstring": "clear both rendering and picking queues .", "partition": "test"}
{"idx": "3165", "code": "private ParsePosition next(final ParsePosition pos){\n  pos.setIndex(pos.getIndex() + 1);\n  return pos;\n}\n", "docstring": "convenience method to advance parse position by 1", "partition": "test"}
{"idx": "3166", "code": "private int flush(int offset){\n  try {\n    _os.write(_buffer,0,offset);\n    _offset=0;\n    return 0;\n  }\n catch (  IOException e) {\n    throw new H3ExceptionOut(e);\n  }\n}\n", "docstring": "flush the buffer and set the offset to zero .", "partition": "test"}
{"idx": "3167", "code": "protected String generateSectionLabel(PieDataset dataset,Comparable key){\n  String result=null;\n  if (dataset != null) {\n    Object[] items=createItemArray(dataset,key);\n    result=MessageFormat.format(this.labelFormat,items);\n  }\n  return result;\n}\n", "docstring": "generates a label for a pie section .", "partition": "test"}
{"idx": "3168", "code": "abstract protected void doFadeIn();\n", "docstring": "fade in then play this audiosource", "partition": "test"}
{"idx": "3169", "code": "public void exec(String description,String[] baseCommand) throws BackupException {\n  exec(description,baseCommand,null,null,null,false,false);\n}\n", "docstring": "convenience method to execute command without providing input or output .", "partition": "test"}
{"idx": "3170", "code": "public static ServiceConfiguration create(InputStream inStream) throws IOException, IllegalArgumentException {\n  try {\n    checkNotNull(inStream);\n    Properties properties=new Properties();\n    properties.load(inStream);\n    return (create(properties));\n  }\n  finally {\n    if (inStream != null) {\n      inStream.close();\n    }\n  }\n}\n", "docstring": "creates serviceconfiguration and loads it with populated attribute values loaded from provided inputstream property file .", "partition": "test"}
{"idx": "3171", "code": "protected int[] splitSentence(String sentence){\n  String[] w=sentence.split(\"\\\\s+\");\n  int[] words=new int[w.length];\n  for (int i=0; i < w.length; i++)   words[i]=Vocabulary.id(w[i]);\n  return words;\n}\n", "docstring": "splits a sentence ( on white space ) , then looks up the integer representations of each word using the supplied symbol table .", "partition": "test"}
{"idx": "3172", "code": "public static boolean isFailure(List<Action> actions){\n  return actions.isEmpty();\n}\n", "docstring": "checks whether a list of actions is empty .", "partition": "test"}
{"idx": "3173", "code": "public void addToDictionary(String s){\n  if (!getAutoComplete())   return;\n  if (dict == null) {\n    setUp();\n    this.dict=createDefaultDictionary();\n  }\n  dict.addEntry(s.trim());\n}\n", "docstring": "adds the specified string to the underlying dictionary", "partition": "test"}
{"idx": "3174", "code": "public static int[][] deep_copy(int M[][]){\n  int[][] C=new int[M.length][];\n  for (int i=0; i < C.length; i++) {\n    C[i]=Arrays.copyOf(M[i],M[i].length);\n  }\n  return C;\n}\n", "docstring": "deep copy - make a deep copy of m [ ", "partition": "test"}
{"idx": "3175", "code": "public void waitForMessageToArrive(){\n  LOG.info(\"Waiting for message to arrive\");\n  long start=System.currentTimeMillis();\nsynchronized (messages) {\n    try {\n      while (hasReceivedMessage()) {\n        messages.wait(4000);\n      }\n    }\n catch (    InterruptedException e) {\n      LOG.info(\"Caught: \" + e);\n    }\n  }\n  long end=System.currentTimeMillis() - start;\n  LOG.info(\"End of wait for \" + end + \" millis\");\n}\n", "docstring": "use to wait for a single message to arrive .", "partition": "test"}
{"idx": "3176", "code": "public Date(String date){\n  String[] fields=date.split(\"/\");\n  if (fields.length != 3) {\n    throw new IllegalArgumentException(\"Invalid date\");\n  }\n  month=Integer.parseInt(fields[0]);\n  day=Integer.parseInt(fields[1]);\n  year=Integer.parseInt(fields[2]);\n  if (!isValid(month,day,year))   throw new IllegalArgumentException(\"Invalid date\");\n}\n", "docstring": "initializes new date specified as a string in form mm / dd / yyyy .", "partition": "test"}
{"idx": "3177", "code": "public static void copy(File src,File dst) throws IOException {\n  if (src.isDirectory()) {\n    ensureDirectoryExists(dst);\n    String[] filesList=src.list();\n    for (    String file : filesList) {\n      File srcFile=new File(src,file);\n      File destFile=new File(dst,file);\n      copy(srcFile,destFile);\n    }\n  }\n else {\n    copyFile(src,dst);\n  }\n}\n", "docstring": "copy file object from one place to another . can be used to copy file to file , or folder to folder .", "partition": "test"}
{"idx": "3178", "code": "public MapObjects(PokemonGo api){\n  this.api=api;\n}\n", "docstring": "instantiates a new map objects .", "partition": "test"}
{"idx": "3179", "code": "public void testSortsAccordingNumberOfAttributes() throws Exception {\n  XppDom dom1=XppFactory.buildDom(\"<dom/>\");\n  XppDom dom2=XppFactory.buildDom(\"<dom a=\'1\'/>\");\n  assertEquals(-1,comparator.compare(dom1,dom2));\n  assertEquals(\"/dom::count(@*)\",xpath.get());\n  assertEquals(1,comparator.compare(dom2,dom1));\n  assertEquals(\"/dom::count(@*)\",xpath.get());\n}\n", "docstring": "tests comparison of different number of attributes .", "partition": "test"}
{"idx": "3180", "code": "static void incrementKeepAliveCount(){\nsynchronized (keepAliveLock) {\n    keepAliveCount++;\n    if (reaper == null) {\n      reaper=AccessController.doPrivileged(new NewThreadAction(new Reaper(),\"Reaper\",false));\n      reaper.start();\n    }\n    if (gcLatencyRequest == null) {\n      gcLatencyRequest=GC.requestLatency(gcInterval);\n    }\n  }\n}\n", "docstring": "increments the \" keep - alive count \" . the \" keep - alive count \" is the number of non - permanent remote objects that are either in the object table or still have calls in progress . therefore , this method should be invoked exactly once for every non - permanent remote object exported ( a remote object must be exported before it can have any calls in progress ) . the vm is \" kept alive \" while the keep - alive count is greater than zero ; this is accomplished by keeping a non - daemon thread running . because non - permanent objects are those that can be garbage collected while exported , and thus those for which the \" reaper \" thread operates , the reaper thread also serves as the non - daemon vm keep - alive thread ; a new reaper thread is created if necessary .", "partition": "test"}
{"idx": "3181", "code": "static MethodHandle makeCollectArguments(MethodHandle target,MethodHandle collector,int collectArgPos,boolean retainOriginalArgs){\n  MethodType targetType=target.type();\n  MethodType collectorType=collector.type();\n  int collectArgCount=collectorType.parameterCount();\n  Class<?> collectValType=collectorType.returnType();\n  int collectValCount=(collectValType == void.class ? 0 : 1);\n  MethodType srcType=targetType.dropParameterTypes(collectArgPos,collectArgPos + collectValCount);\n  if (!retainOriginalArgs) {\n    srcType=srcType.insertParameterTypes(collectArgPos,collectorType.parameterList());\n  }\n  MethodType lambdaType=srcType.invokerType();\n  Name[] names=arguments(2,lambdaType);\n  final int collectNamePos=names.length - 2;\n  final int targetNamePos=names.length - 1;\n  Name[] collectorArgs=Arrays.copyOfRange(names,1 + collectArgPos,1 + collectArgPos + collectArgCount);\n  names[collectNamePos]=new Name(collector,(Object[])collectorArgs);\n  Name[] targetArgs=new Name[targetType.parameterCount()];\n  int inputArgPos=1;\n  int targetArgPos=0;\n  int chunk=collectArgPos;\n  System.arraycopy(names,inputArgPos,targetArgs,targetArgPos,chunk);\n  inputArgPos+=chunk;\n  targetArgPos+=chunk;\n  if (collectValType != void.class) {\n    targetArgs[targetArgPos++]=names[collectNamePos];\n  }\n  chunk=collectArgCount;\n  if (retainOriginalArgs) {\n    System.arraycopy(names,inputArgPos,targetArgs,targetArgPos,chunk);\n    targetArgPos+=chunk;\n  }\n  inputArgPos+=chunk;\n  chunk=targetArgs.length - targetArgPos;\n  System.arraycopy(names,inputArgPos,targetArgs,targetArgPos,chunk);\n  assert (inputArgPos + chunk == collectNamePos);\n  names[targetNamePos]=new Name(target,(Object[])targetArgs);\n  LambdaForm form=new LambdaForm(\"collect\",lambdaType.parameterCount(),names);\n  return SimpleMethodHandle.make(srcType,form);\n}\n", "docstring": "factory method : collect or filter selected argument ( s ) .", "partition": "test"}
{"idx": "3182", "code": "public InSpacePredicate(Object... values){\n  _inValues=new HashSet<Object>();\n  for (  Object value : values) {\n    _inValues.add(value);\n  }\n}\n", "docstring": "creates an in predicate using the specified values .", "partition": "test"}
{"idx": "3183", "code": "protected List<String> prepareSortKeyStatements(List<SortKey> sortKeys){\n  List<String> keys=new ArrayList<String>();\n  for (int i=0; i < sortKeys.size(); i++) {\n    SortKey sortKey=sortKeys.get(i);\n    keys.add(explicitMapping.getDbColumnName(sortKey.getField()) + (sortKey.isAscendingOrder() ? \" ASC\" : \" DESC\"));\n  }\n  return keys;\n}\n", "docstring": "loops through sort keys constructing the key statements .", "partition": "test"}
{"idx": "3184", "code": "private Optional<CuratorFramework> createClient(String zookeeperUrl){\n  if (StringUtils.isNotBlank(zookeeperUrl)) {\n    CuratorFramework client=ConfigurationsUtils.getClient(zookeeperUrl);\n    client.start();\n    return Optional.of(client);\n  }\n else {\n    return Optional.empty();\n  }\n}\n", "docstring": "creates a zookeeper client .", "partition": "test"}
{"idx": "3185", "code": "public static String addCvDescription(String toolTip,String cvDescription,String mask){\n  String descString=cvDescription;\n  String temp=getMaskDescription(mask);\n  if (temp.length() > 0) {\n    descString=descString + \" \" + temp;\n  }\n  if (PaneProgFrame.getShowCvNumbers() && (descString != null)) {\n    if (toolTip == null) {\n      toolTip=descString;\n    }\n else {\n      toolTip=addTextHTMLaware(toolTip,\" (\" + descString + \")\");\n    }\n  }\n else   if (toolTip == null) {\n    toolTip=\"\";\n  }\n  return toolTip;\n}\n", "docstring": "optionally add cv numbers and bit numbers to tool tip text based on roster preferences setting . < p > needs to be independent of variablevalue methods to allow use by non - standard elements such as speedtablevarvalue , dccaddresspanel , fnmappanel .", "partition": "test"}
{"idx": "3186", "code": "private static void convertToHTML40(AttributeSet from,MutableAttributeSet to){\n  Enumeration keys=from.getAttributeNames();\n  String value=\"\";\n  while (keys.hasMoreElements()) {\n    Object key=keys.nextElement();\n    if (key instanceof CSS.Attribute) {\n      value=value + \" \" + key+ \"=\"+ from.getAttribute(key)+ \";\";\n    }\n else {\n      to.addAttribute(key,from.getAttribute(key));\n    }\n  }\n  if (value.length() > 0) {\n    to.addAttribute(HTML.Attribute.STYLE,value);\n  }\n}\n", "docstring": "copies the given attributeset to a new set , converting any css attributes found to arguments of an html style attribute .", "partition": "test"}
{"idx": "3187", "code": "public synchronized void close() throws IOException {\n  if (in == null)   return;\n  in.close();\n  in=null;\n  buf=null;\n}\n", "docstring": "closes this input stream and releases any system resources associated with the stream . once the stream has been closed , further read ( ) , unread ( ) , available ( ) , reset ( ) , or skip ( ) invocations will throw an ioexception . closing a previously closed stream has no effect .", "partition": "test"}
{"idx": "3188", "code": "private static SSLSocketFactory trustAllHosts(HttpsURLConnection connection){\n  SSLSocketFactory oldFactory=connection.getSSLSocketFactory();\n  try {\n    SSLContext sc=SSLContext.getInstance(\"TLS\");\n    sc.init(null,trustAllCerts,new java.security.SecureRandom());\n    SSLSocketFactory newFactory=sc.getSocketFactory();\n    connection.setSSLSocketFactory(newFactory);\n  }\n catch (  Exception e) {\n    LOG.e(LOG_TAG,e.getMessage(),e);\n  }\n  return oldFactory;\n}\n", "docstring": "this function will install a trust manager that will blindly trust all ssl certificates . the reason this code is being added is to enable developers to do development using self signed ssl certificates on their web server . the standard httpsurlconnection class will throw an exception on self signed certificates if this code is not run .", "partition": "test"}
{"idx": "3189", "code": "public void updateAmount(){\n  setAmt(getTotalAmount());\n}\n", "docstring": "updates the amount on the document", "partition": "test"}
{"idx": "3190", "code": "public void testCreationUnique(){\n  Instances data;\n  ArrayList<Attribute> atts;\n  String relName;\n  relName=\"testCreationUnique\";\n  atts=new ArrayList<Attribute>();\n  atts.add(new Attribute(\"att-numeric_1\"));\n  atts.add(new Attribute(\"att-numeric_2\"));\n  atts.add(new Attribute(\"att-data_1\",\"yyyy-MM-dd HH:mm\"));\n  atts.add(new Attribute(\"att-nominal_1\",new ArrayList<String>(Arrays.asList(new String[]{\"1\",\"2\",\"3\"}))));\n  atts.add(new Attribute(\"att-nominal_2\",new ArrayList<String>(Arrays.asList(new String[]{\"yes\",\"no\"}))));\n  atts.add(new Attribute(\"att-string_1\",(ArrayList<String>)null));\n  data=new Instances(relName,atts,0);\n  assertEquals(\"relation name differs\",relName,data.relationName());\n  assertEquals(\"# of attributes differ\",atts.size(),data.numAttributes());\n}\n", "docstring": "tests the creation of a dataset ( unique attribute names ) .", "partition": "test"}
{"idx": "3191", "code": "private void updateLegends(){\n  if (m_span == null) {\n    m_span=new JPanel();\n  }\n  JPanel padder=new JPanel();\n  JPanel padd2=new JPanel();\n  m_span.setPreferredSize(new Dimension(m_span.getPreferredSize().width,(m_plots.size() + 1) * 20));\n  m_span.setMaximumSize(new Dimension(m_span.getPreferredSize().width,(m_plots.size() + 1) * 20));\n  LegendEntry tmp;\n  GridBagLayout gb=new GridBagLayout();\n  GridBagLayout gb2=new GridBagLayout();\n  GridBagConstraints constraints=new GridBagConstraints();\n  m_span.removeAll();\n  padder.setLayout(gb);\n  m_span.setLayout(gb2);\n  constraints.anchor=GridBagConstraints.CENTER;\n  constraints.gridx=0;\n  constraints.gridy=0;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.insets=new Insets(0,0,0,0);\n  padder.add(m_span,constraints);\n  constraints.gridx=0;\n  constraints.gridy=1;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.BOTH;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.weighty=5;\n  constraints.insets=new Insets(0,0,0,0);\n  padder.add(padd2,constraints);\n  constraints.weighty=0;\n  setViewportView(padder);\n  constraints.anchor=GridBagConstraints.CENTER;\n  constraints.gridx=0;\n  constraints.gridy=0;\n  constraints.weightx=5;\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridwidth=1;\n  constraints.gridheight=1;\n  constraints.weighty=5;\n  constraints.insets=new Insets(2,4,2,4);\n  for (int i=0; i < m_plots.size(); i++) {\n    tmp=new LegendEntry(m_plots.get(i),i);\n    constraints.gridy=i;\n    m_span.add(tmp,constraints);\n  }\n}\n", "docstring": "redraw the panel with the legend entries", "partition": "test"}
{"idx": "3192", "code": "public static byte[] readDex(File file) throws IOException {\n  return readDex(file.toPath());\n}\n", "docstring": "read the dex file from file , if the file is a zip file , it will return the content of classes . dex in the zip file .", "partition": "test"}
{"idx": "3193", "code": "public void runCommercial(String stream,int length){\n  if (stream == null || stream.isEmpty()) {\n    commercialResult(stream,\"Can\'t run commercial, not on a channel.\",TwitchApi.RequestResult.FAILED);\n  }\n else {\n    String channel=\"#\" + stream;\n    if (isChannelOpen(channel)) {\n      g.printLine(channel,\"Trying to run \" + length + \"s commercial..\");\n    }\n else {\n      g.printLine(\"Trying to run \" + length + \"s commercial.. (\"+ stream+ \")\");\n    }\n    api.runCommercial(stream,settings.getString(\"token\"),length);\n  }\n}\n", "docstring": "tries to run a commercial on the given stream with the given length . outputs a message about it in the appropriate channel .", "partition": "test"}
{"idx": "3194", "code": "void generateWhile(Tree.WhileStatement that){\n  Tree.WhileClause whileClause=that.getWhileClause();\n  List<VarHolder> vars=specialConditionsAndBlock(whileClause.getConditionList(),whileClause.getBlock(),\"while\",false);\n  for (  VarHolder v : vars) {\n    v.forget();\n  }\n}\n", "docstring": "generates js code for a whilestatement .", "partition": "test"}
{"idx": "3195", "code": "public static double igamma(double a,double x){\n  double coef=(Math.exp(-x) * Math.pow(x,a)) / gamma(a);\n  double sum=0.0;\n  for (int i=0; i < 100; i++) {\n    sum+=(gamma(a) / gamma(a + 1.0 + (double)i)) * Math.pow(x,(double)i);\n  }\n  return (coef * sum);\n}\n", "docstring": "calculates the incomplete gamma function for two doubles", "partition": "test"}
{"idx": "3196", "code": "public void initializeActiveSlotsList(String slots){\n  if (activeSlotsList == null) {\n    activeSlotsList=new ArrayList<String>();\n  }\n  for (  String s : slots.split(\";\")) {\n    activeSlotsList.add(s);\n  }\n}\n", "docstring": "add slots to list where slotactivateditem can be activated when equipped .", "partition": "test"}
{"idx": "3197", "code": "private static String convertActionTypeToIntent(RamlActionType actionType,boolean isTargetCollection){\nswitch (actionType) {\ncase DELETE:\n    return \"delete\";\ncase GET:\n  return \"get\";\ncase POST:\nif (isTargetCollection) {\n  return \"create\";\n}\ncase PUT:\nreturn \"update\";\ncase PATCH:\nreturn \"modify\";\ndefault :\nreturn \"do\";\n}\n}\n", "docstring": "attempts to convert the http verb into a textual representation of intent based on rest conventions", "partition": "test"}
{"idx": "3198", "code": "public static String hide(final String key){\n  return isHidden(key) ? key : HIDDEN_PREFIX.concat(key);\n}\n", "docstring": "turn the provided key into a hidden key . if the key is already a hidden key , return key .", "partition": "test"}
{"idx": "3199", "code": "private synchronized IMqttToken removeMqttToken(Bundle data){\n  String activityToken=data.getString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);\n  if (activityToken != null) {\n    int tokenNumber=Integer.parseInt(activityToken);\n    IMqttToken token=tokenMap.get(tokenNumber);\n    tokenMap.delete(tokenNumber);\n    return token;\n  }\n  return null;\n}\n", "docstring": "get a token identified by a string , and remove it from our map", "partition": "test"}
{"idx": "3200", "code": "public static boolean isExplicitAllType(String[] types){\n  return types != null && types.length == 1 && ALL.equals(types[0]);\n}\n", "docstring": "identifies whether the array containing type names given as argument explicitly refers to all types the empty or null array doesn \"'\" t explicitly map to all types", "partition": "test"}
{"idx": "3201", "code": "public static double incompleteBetaFraction2(double a,double b,double x){\n  double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;\n  double k1, k2, k3, k4, k5, k6, k7, k8;\n  double r, t, ans, z, thresh;\n  int n;\n  k1=a;\n  k2=b - 1.0;\n  k3=a;\n  k4=a + 1.0;\n  k5=1.0;\n  k6=a + b;\n  k7=a + 1.0;\n  ;\n  k8=a + 2.0;\n  pkm2=0.0;\n  qkm2=1.0;\n  pkm1=1.0;\n  qkm1=1.0;\n  z=x / (1.0 - x);\n  ans=1.0;\n  r=1.0;\n  n=0;\n  thresh=3.0 * MACHEP;\n  do {\n    xk=-(z * k1 * k2) / (k3 * k4);\n    pk=pkm1 + pkm2 * xk;\n    qk=qkm1 + qkm2 * xk;\n    pkm2=pkm1;\n    pkm1=pk;\n    qkm2=qkm1;\n    qkm1=qk;\n    xk=(z * k5 * k6) / (k7 * k8);\n    pk=pkm1 + pkm2 * xk;\n    qk=qkm1 + qkm2 * xk;\n    pkm2=pkm1;\n    pkm1=pk;\n    qkm2=qkm1;\n    qkm1=qk;\n    if (qk != 0) {\n      r=pk / qk;\n    }\n    if (r != 0) {\n      t=Math.abs((ans - r) / r);\n      ans=r;\n    }\n else {\n      t=1.0;\n    }\n    if (t < thresh) {\n      return ans;\n    }\n    k1+=1.0;\n    k2-=1.0;\n    k3+=2.0;\n    k4+=2.0;\n    k5+=1.0;\n    k6+=1.0;\n    k7+=2.0;\n    k8+=2.0;\n    if ((Math.abs(qk) + Math.abs(pk)) > big) {\n      pkm2*=biginv;\n      pkm1*=biginv;\n      qkm2*=biginv;\n      qkm1*=biginv;\n    }\n    if ((Math.abs(qk) < biginv) || (Math.abs(pk) < biginv)) {\n      pkm2*=big;\n      pkm1*=big;\n      qkm2*=big;\n      qkm1*=big;\n    }\n  }\n while (++n < 300);\n  return ans;\n}\n", "docstring": "continued fraction expansion # 2 for incomplete beta integral .", "partition": "test"}
{"idx": "3202", "code": "private String readUntil(char[] delimiter,boolean returnText) throws IOException, XmlPullParserException {\n  int start=position;\n  StringBuilder result=null;\n  if (returnText && text != null) {\n    result=new StringBuilder();\n    result.append(text);\n  }\n  search:   while (true) {\n    if (position + delimiter.length > limit) {\n      if (start < position && returnText) {\n        if (result == null) {\n          result=new StringBuilder();\n        }\n        result.append(buffer,start,position - start);\n      }\n      if (!fillBuffer(delimiter.length)) {\n        checkRelaxed(UNEXPECTED_EOF);\n        type=COMMENT;\n        return null;\n      }\n      start=position;\n    }\n    for (int i=0; i < delimiter.length; i++) {\n      if (buffer[position + i] != delimiter[i]) {\n        position++;\n        continue search;\n      }\n    }\n    break;\n  }\n  int end=position;\n  position+=delimiter.length;\n  if (!returnText) {\n    return null;\n  }\n else   if (result == null) {\n    return stringPool.get(buffer,start,end - start);\n  }\n else {\n    result.append(buffer,start,end - start);\n    return result.toString();\n  }\n}\n", "docstring": "reads text until the specified delimiter is encountered . consumes the text and the delimiter .", "partition": "test"}
{"idx": "3203", "code": "private Config(){\n  throw new AssertionError(\"com.sun.jini.config.Config cannot be instantiated\");\n}\n", "docstring": "this class cannot be instantiated .", "partition": "test"}
{"idx": "3204", "code": "public boolean isLeaf(){\n  return children == null || children.isEmpty();\n}\n", "docstring": "true , if the node is a leaf .", "partition": "test"}
{"idx": "3205", "code": "public static void drawShadow(final Rectangle2D rect,final Graphics2D g2){\n  Graphics2D g2S=(Graphics2D)g2.create();\n  Rectangle2D shadow=new Rectangle2D.Double(rect.getX() + 5,rect.getY() + ProcessDrawer.HEADER_HEIGHT + 5,rect.getWidth(),rect.getHeight() - ProcessDrawer.HEADER_HEIGHT);\n  GeneralPath bottom=new GeneralPath();\n  bottom.moveTo(shadow.getX(),rect.getMaxY());\n  bottom.lineTo(rect.getMaxX(),rect.getMaxY());\n  bottom.lineTo(shadow.getMaxX(),shadow.getMaxY());\n  bottom.lineTo(shadow.getMinX(),shadow.getMaxY());\n  bottom.closePath();\n  g2S.setPaint(new GradientPaint((float)rect.getX(),(float)rect.getMaxY(),Color.gray,(float)rect.getX(),(float)shadow.getMaxY(),TRANSPARENT_GRAY));\n  g2S.fill(bottom);\n  GeneralPath right=new GeneralPath();\n  right.moveTo(rect.getMaxX(),shadow.getMinY());\n  right.lineTo(shadow.getMaxX(),shadow.getMinY());\n  right.lineTo(shadow.getMaxX(),shadow.getMaxY());\n  right.lineTo(rect.getMaxX(),rect.getMaxY());\n  right.closePath();\n  g2S.setPaint(new GradientPaint((float)rect.getMaxX(),(float)shadow.getY(),Color.gray,(float)shadow.getMaxX(),(float)shadow.getY(),TRANSPARENT_GRAY));\n  g2S.fill(right);\n  g2S.dispose();\n}\n", "docstring": "draws a shadow around the given rectangle .", "partition": "test"}
{"idx": "3206", "code": "public static void interrupt(final Thread thread){\n  if (thread != null) {\n    thread.interrupt();\n  }\n}\n", "docstring": "interrupts the specified thread , guarding against null . < p / >", "partition": "test"}
{"idx": "3207", "code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n  s.writeInt(attrs.size());\n  Enumeration<Attribute> attrEnum=attrs.elements();\n  while (attrEnum.hasMoreElements()) {\n    s.writeObject(attrEnum.nextElement());\n  }\n}\n", "docstring": "overridden to avoid exposing implementation details .", "partition": "test"}
{"idx": "3208", "code": "public static Container east(Component east){\n  return Container.encloseIn(new BorderLayout(),east,BorderLayout.EAST);\n}\n", "docstring": "convenience method that creates a border layout container and places the given component in the east", "partition": "test"}
{"idx": "3209", "code": "public static Object[] putAll(){\n  Region region=cache.getRegion(Region.SEPARATOR + REGION_NAME);\n  assertNotNull(region);\n  try {\n    Map map=new LinkedHashMap();\n    map.put(PUTALL_KEY1,PUTALL_VALUE1);\n    map.put(PUTALL_KEY2,PUTALL_VALUE2);\n    map.put(PUTALL_KEY3,PUTALL_VALUE3);\n    map.put(PUTALL_KEY4,PUTALL_VALUE4);\n    map.put(PUTALL_KEY5,PUTALL_VALUE5);\n    region.putAll(map,\"putAllCallbackArg\");\n    EventID[] evids=new EventID[5];\n    evids[0]=putAlleventId1;\n    evids[1]=putAlleventId2;\n    evids[2]=putAlleventId3;\n    evids[3]=putAlleventId4;\n    evids[4]=putAlleventId5;\n    assertNotNull(evids[0]);\n    assertNotNull(evids[1]);\n    assertNotNull(evids[2]);\n    assertNotNull(evids[3]);\n    assertNotNull(evids[4]);\n    return evids;\n  }\n catch (  Exception e) {\n    fail(\"put failed due to \" + e);\n  }\n  return null;\n}\n", "docstring": "does an update and return the eventid generated . eventid is caught in the listener and stored in a static variable", "partition": "test"}
{"idx": "3210", "code": "public void loadLayout(File oFile,boolean newTab){\n  loadLayout(oFile,newTab,false);\n}\n", "docstring": "load a layout from a file . supports loading binary and xml serialized flow files", "partition": "test"}
{"idx": "3211", "code": "public void track(File file,Object marker,FileDeleteStrategy deleteStrategy){\n  if (file == null) {\n    throw new NullPointerException(\"The file must not be null\");\n  }\n  addTracker(file.getPath(),marker,deleteStrategy);\n}\n", "docstring": "track the specified file , using the provided marker , deleting the file when the marker instance is garbage collected . the speified deletion strategy is used .", "partition": "test"}
{"idx": "3212", "code": "public boolean hasParameter(String name){\n  return _parameters.hasParameter(name);\n}\n", "docstring": "checks if the extension contains a parameter .", "partition": "test"}
{"idx": "3213", "code": "@Override public long freeMemory(long windowId) throws IOException {\n  long size=keyStream.dataSizeUpToWindow(windowId) + valueStream.dataSizeUpToWindow(windowId);\n  windowsForFreeMemory.add(windowId);\n  return size;\n}\n", "docstring": "free memory up to the given windowid this method will be called by another thread . adding concurrency control to stream would impact the performance . this method only calculates the size of the memory that could be released and then sends free memory request to the operator thread", "partition": "test"}
{"idx": "3214", "code": "public static boolean isSQL99NonReservedKeyword(String identifier){\n  if (identifier == null) {\n    throw new NullPointerException(\"The identifier cannot be null\");\n  }\n  return Arrays.binarySearch(SQL99_NON_RESERVED,identifier.toUpperCase()) >= 0;\n}\n", "docstring": "returns true if the given identifier is a sql - 99 non - reserved keyword .", "partition": "test"}
{"idx": "3215", "code": "@Override public long handleCommit(final long commitTime){\n  if (error != null)   throw new IndexInconsistentError(error);\n  final IRootBlockView view=journal.getRootBlockView();\n  final ByteBuffer rbv=view.asReadOnlyBuffer();\n  final ByteBuffer bb=ByteBuffer.allocate(rbv.capacity());\n  for (int i=0; i < rbv.capacity(); i++) {\n    bb.put(rbv.get());\n  }\n  bb.flip();\n  return journal.write(bb);\n}\n", "docstring": "write the current root block to the journal and return its address to be stored in the commitrecord .", "partition": "test"}
{"idx": "3216", "code": "public boolean isAppendTaskName(){\n  return appendTaskName;\n}\n", "docstring": "checks if the appendtaskname flag is set .", "partition": "test"}
{"idx": "3217", "code": "public static final String toString(String str){\n  if (str == null)   return \"null\";\n  ByteArrayOutputStream buffer=new ByteArrayOutputStream();\n  toByteArray(buffer,str);\n  return buffer.toString();\n}\n", "docstring": "provides a java string literal representing the parameter string . this includes surrounding double quotes , and quoted special characters , including utf escape sequences when necessary . < p > this function works only for ascii character encoding , and assumes this is the default encoding .", "partition": "test"}
{"idx": "3218", "code": "public static double max(double[] data){\n  double max=Double.NaN;\n  for (int i=0; i < data.length; i++) {\n    if (Double.isNaN(data[i]))     continue;\n    if (Double.isNaN(max) || data[i] > max)     max=data[i];\n  }\n  return max;\n}\n", "docstring": "find the maximum of all elements in the array , ignoring elements that are nan .", "partition": "test"}
{"idx": "3219", "code": "private static boolean isStartElement(String line){\n  int first=line.lastIndexOf(\"<\");\n  int last=line.lastIndexOf(\">\");\n  if (last < first) {\n    return true;\n  }\n else {\n    int firstEnd=line.lastIndexOf(\"</\");\n    int lastEnd=line.lastIndexOf(\"/>\");\n    if ((firstEnd != first) && ((lastEnd + 1) != last)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "tries to find out if the line finishes with an element start", "partition": "test"}
{"idx": "3220", "code": "long readLong() throws IOException {\n  return (((long)_is.read() << 56) | ((long)_is.read() << 48) | ((long)_is.read() << 40)| ((long)_is.read() << 32)| ((long)_is.read() << 24)| ((long)_is.read() << 16)| ((long)_is.read() << 8)| ((long)_is.read()));\n}\n", "docstring": "parses a 64 - bit int .", "partition": "test"}
{"idx": "3221", "code": "@Override public Instance remove(int index){\n  return m_Instances.remove(index);\n}\n", "docstring": "removes the instance at the given position .", "partition": "test"}
{"idx": "3222", "code": "protected static String extractAccessKey(String s3uri){\n  return s3uri.substring(s3uri.indexOf(\"://\") + 3,s3uri.indexOf(\':\',s3uri.indexOf(\"://\") + 3));\n}\n", "docstring": "extracts the accesskey from the given uri", "partition": "test"}
{"idx": "3223", "code": "public boolean doTransaction(DB db,Object threadstate) throws WorkloadException {\n  boolean ret=true;\n  long st=System.nanoTime();\n  String op=operationchooser.nextString();\n  if (op.compareTo(\"READ\") == 0) {\n    ret=doTransactionRead(db);\n  }\n else   if (op.compareTo(\"UPDATE\") == 0) {\n    ret=doTransactionUpdate(db);\n  }\n else   if (op.compareTo(\"INSERT\") == 0) {\n    ret=doTransactionInsert(db);\n  }\n else   if (op.compareTo(\"SCAN\") == 0) {\n    ret=doTransactionScan(db);\n  }\n else {\n    ret=doTransactionReadModifyWrite(db);\n  }\n  long en=System.nanoTime();\n  _measurements.measure(_operations.get(op),(int)((en - st) / 1000));\n  if (ret)   _measurements.reportReturnCode(_operations.get(op),-1);\n else {\n    _measurements.reportReturnCode(_operations.get(op),0);\n  }\n  actualopcount.addAndGet(1);\n  return ret;\n}\n", "docstring": "do one transaction operation . because it will be called concurrently from multiple client threads , this function must be thread safe . however , avoid synchronized , or the threads will block waiting for each other , and it will be difficult to reach the target throughput . ideally , this function would have no side effects other than db operations .", "partition": "test"}
{"idx": "3224", "code": "public static void copyExcept(Object src,Object dst,int oldSize,int removeIndex){\n  if (removeIndex > 0 && oldSize > 0) {\n    System.arraycopy(src,0,dst,0,removeIndex);\n  }\n  if (removeIndex < oldSize) {\n    System.arraycopy(src,removeIndex + 1,dst,removeIndex,oldSize - removeIndex - 1);\n  }\n}\n", "docstring": "copy the elements of an array , and remove one element .", "partition": "test"}
{"idx": "3225", "code": "public SiteMonitor(String[] urlList){\n  siteUrlList=urlList;\n}\n", "docstring": "constructs a webtopnaming $ sitemonitor object with the provided site urls .", "partition": "test"}
{"idx": "3226", "code": "public Optional<BlazeVertex> vertex(final String vertexId){\n  try (final CloseableIterator<Vertex> it=vertices(vertexId)){\n    final Optional<BlazeVertex> v=it.hasNext() ? Optional.of((BlazeVertex)it.next()) : Optional.empty();\n    if (it.hasNext()) {\n      throw new IllegalStateException(\"Multiple vertices found with id: \" + vertexId);\n    }\n    return v;\n  }\n }\n", "docstring": "lookup a vertex by id .", "partition": "test"}
{"idx": "3227", "code": "public static long addAndGet(AtomicLong current,long toAdd){\n  long u, r;\n  do {\n    r=current.get();\n    if (r == Long.MAX_VALUE) {\n      return Long.MAX_VALUE;\n    }\n    u=addCap(r,toAdd);\n  }\n while (!current.compareAndSet(r,u));\n  return u;\n}\n", "docstring": "concurrent addition bound to long . max_value . any concurrent write will \" happen \" before this operation .", "partition": "test"}
{"idx": "3228", "code": "private void start(HttpServletRequest request,HttpServletResponse response) throws IOException {\n  String label=request.getParameter(\"start\");\n  String detail=request.getParameter(\"detail\");\n  MonKey key=getMonKey(label,detail,DEFAULT_UNITS);\n  startMon(key);\n  PrintWriter out=response.getWriter();\n  out.println(OK + \": start successfully called on - \" + label);\n}\n", "docstring": "start a monitor by providing a summary label and optionally a detail string . note this won \"'\" t be called unless a label was passed .", "partition": "test"}
{"idx": "3229", "code": "public double norm(){\n  double sum=0;\n  for (int i=0; i < components.length; i++)   sum+=components[i] * components[i];\n  return Math.sqrt(sum);\n}\n", "docstring": "computes the norm of a vector .", "partition": "test"}
{"idx": "3230", "code": "public static double P_Harmonic(int Y[][],int Ypred[][]){\n  int allMissings=0;\n  int N=Y.length;\n  double loss=0.0;\n  for (int i=0; i < N; i++) {\n    if (allMissing(Y[i])) {\n      allMissings++;\n      continue;\n    }\n    double curLoss=P_Harmonic(Y[i],Ypred[i]);\n    if (Double.isNaN(curLoss)) {\n      allMissings++;\n      continue;\n    }\n    loss+=curLoss;\n  }\n  return loss / (double)(N - allMissings);\n}\n", "docstring": "harmonic accuracy - - average over all labels . multi - label only .", "partition": "test"}
{"idx": "3231", "code": "public void writeEntry(CCacheOutputStream cos) throws IOException {\n  cos.write16(adType);\n  cos.write32(adData.length);\n  cos.write(adData,0,adData.length);\n}\n", "docstring": "writes the entry \"'\" s data fields in fcc format to an output stream .", "partition": "test"}
{"idx": "3232", "code": "public CloseableAnimatedBitmap(List<Bitmap> bitmaps,List<Integer> durations,ResourceReleaser<Bitmap> resourceReleaser){\n  Preconditions.checkNotNull(bitmaps);\n  Preconditions.checkState(bitmaps.size() >= 1,\"Need at least 1 frame!\");\n  mBitmaps=new ArrayList<>();\n  mBitmapReferences=new ArrayList<>();\n  for (  Bitmap bitmap : bitmaps) {\n    mBitmapReferences.add(CloseableReference.of(bitmap,resourceReleaser));\n    mBitmaps.add(bitmap);\n  }\n  mDurations=Preconditions.checkNotNull(durations);\n  Preconditions.checkState(mDurations.size() == mBitmaps.size(),\"Arrays length mismatch!\");\n}\n", "docstring": "creates a new instance of a closeablestaticbitmap .", "partition": "test"}
{"idx": "3233", "code": "public static String readLabelFile(String entrySeparator,boolean ensureInitialBoundary,String trfname) throws IOException {\n  BufferedReader lab=new BufferedReader(new FileReader(trfname));\n  try {\n    XwavesLabelfileReader xlds=new XwavesLabelfileReader(trfname);\n    String result=StringUtils.join(entrySeparator,xlds.getLabelSymbols());\n    if (ensureInitialBoundary && result.charAt(0) != \'_\') {\n      result=\"_\" + entrySeparator + result;\n    }\n    return result;\n  }\n  finally {\n    lab.close();\n  }\n}\n", "docstring": "this reads in a label file and returns a string of the phonetic symbols , separated by the entry separator character entryseparator .", "partition": "test"}
{"idx": "3234", "code": "ConverterSet add(Converter converter,Converter[] removed){\n  Converter[] converters=iConverters;\n  int length=converters.length;\n  for (int i=0; i < length; i++) {\n    Converter existing=converters[i];\n    if (converter.equals(existing)) {\n      if (removed != null) {\n        removed[0]=null;\n      }\n      return this;\n    }\n    if (converter.getSupportedType() == existing.getSupportedType()) {\n      Converter[] copy=new Converter[length];\n      for (int j=0; j < length; j++) {\n        if (j != i) {\n          copy[j]=converters[j];\n        }\n else {\n          copy[j]=converter;\n        }\n      }\n      if (removed != null) {\n        removed[0]=existing;\n      }\n      return new ConverterSet(copy);\n    }\n  }\n  Converter[] copy=new Converter[length + 1];\n  System.arraycopy(converters,0,copy,0,length);\n  copy[length]=converter;\n  if (removed != null) {\n    removed[0]=null;\n  }\n  return new ConverterSet(copy);\n}\n", "docstring": "returns a copy of this set , with the given converter added . if a matching converter is already in the set , the given converter replaces it . if the converter is exactly the same as one already in the set , the original set is returned .", "partition": "test"}
{"idx": "3235", "code": "private void parse() throws SAXException {\n  XStream xstream=(XStream)properties.get(CONFIGURED_XSTREAM_PROPERTY);\n  if (xstream == null) {\n    xstream=new XStream();\n  }\n  final List<?> source=(List<?>)properties.get(SOURCE_OBJECT_LIST_PROPERTY);\n  if (source == null || source.isEmpty()) {\n    throw new SAXException(\"Missing or empty source object list. Setting property \\\"\" + SOURCE_OBJECT_LIST_PROPERTY + \"\\\" is mandatory\");\n  }\n  try {\n    startDocument(true);\n    for (    final Object name : source) {\n      xstream.marshal(name,this);\n    }\n    endDocument(true);\n  }\n catch (  final StreamException e) {\n    if (e.getCause() instanceof SAXException) {\n      throw (SAXException)e.getCause();\n    }\n else {\n      throw new SAXException(e);\n    }\n  }\n}\n", "docstring": "serializes the java objects of the configured list into a flow of sax events .", "partition": "test"}
{"idx": "3236", "code": "private SortedMap<MessageUid,MaildirMessageName> truncateMap(Map<MessageUid,MaildirMessageName> map,MessageUid from,MessageUid to){\n  TreeMap<MessageUid,MaildirMessageName> sortedMap;\n  if (map instanceof TreeMap<?,?>)   sortedMap=(TreeMap<MessageUid,MaildirMessageName>)map;\n else   sortedMap=new TreeMap<MessageUid,MaildirMessageName>(map);\n  if (to != null)   return sortedMap.subMap(from,to.next());\n  return sortedMap.tailMap(from);\n}\n", "docstring": "sorts the given map and returns a subset which is constricted by a lower and an upper limit .", "partition": "test"}
{"idx": "3237", "code": "public void dumpIndex(boolean showBounds) throws IOException {\n  byte ixRecord[]=new byte[SPATIAL_INDEX_RECORD_LENGTH];\n  int recNum=0;\n  if (shpFileName == null) {\n    return;\n  }\n  BinaryBufferedFile ssx=new BinaryBufferedFile(ssx(shpFileName));\n  ssx.seek(100);\n  while (true) {\n    int result=ssx.read(ixRecord,0,SPATIAL_INDEX_RECORD_LENGTH);\n    if (result <= 0) {\n      logger.info(\"Processed \" + recNum + \" records\");\n      break;\n    }\n else {\n      recNum++;\n      int offset=readBEInt(ixRecord,0);\n      int length=readBEInt(ixRecord,4);\n      logger.info(\"Record \" + recNum + \": \"+ offset+ \", \"+ length+ (showBounds ? (\"; \" + readLEDouble(ixRecord,8) + \", \"+ readLEDouble(ixRecord,16)+ \", \"+ readLEDouble(ixRecord,24)+ \", \"+ readLEDouble(ixRecord,32)) : \"\"));\n    }\n  }\n  ssx.close();\n}\n", "docstring": "displays the contents of this index .", "partition": "test"}
{"idx": "3238", "code": "private static boolean compareParam(String jdiffParam,Type reflectionParamType){\n  if (jdiffParam == null) {\n    return false;\n  }\n  String reflectionParam=typeToString(reflectionParamType);\n  if (jdiffParam.equals(reflectionParam)) {\n    return true;\n  }\n  int jdiffParamEndOffset=jdiffParam.indexOf(\"...\");\n  int reflectionParamEndOffset=reflectionParam.indexOf(\"[]\");\n  if (jdiffParamEndOffset != -1 && reflectionParamEndOffset != -1) {\n    jdiffParam=jdiffParam.substring(0,jdiffParamEndOffset);\n    reflectionParam=reflectionParam.substring(0,reflectionParamEndOffset);\n    return jdiffParam.equals(reflectionParam);\n  }\n  return false;\n}\n", "docstring": "compares the parameter from the api and the parameter from reflection .", "partition": "test"}
{"idx": "3239", "code": "private void checkHeadingsHierarchy(Elements elements,TestSolutionHandler testSolutionHandler){\n  if (elements.isEmpty()) {\n    testSolutionHandler.addTestSolution(TestSolution.NOT_APPLICABLE);\n    return;\n  }\n  TestSolution checkResult=TestSolution.PASSED;\n  Iterator<Element> iter=elements.iterator();\n  Element element=iter.next();\n  int indexOfReference=getHeaderIndex(element);\n  int currentIndex;\n  int previousIndex=indexOfReference;\n  Element elementOfReference=element;\n  Element previousElement=element;\n  while (iter.hasNext()) {\n    element=iter.next();\n    currentIndex=getHeaderIndex(element);\n    if (currentIndex != -1) {\n      if (currentIndex - previousIndex >= 2) {\n        checkResult=TestSolution.FAILED;\n        addSourceCodeRemark(TestSolution.FAILED,element,HEADER_NOT_HIERARCHICALLY_WELL_DEFINED_MSG,getEvidenceElement(PREVIOUS_H_TAG_INDEX_EE,getEvidenceElementMsg(previousIndex,previousElement)));\n      }\n else       if (currentIndex < indexOfReference) {\n        checkResult=TestSolution.FAILED;\n        addSourceCodeRemark(TestSolution.FAILED,element,HEADER_NOT_HIERARCHICALLY_WELL_DEFINED_MSG,getEvidenceElement(FIRST_H_TAG_INDEX_EE,getEvidenceElementMsg(indexOfReference,elementOfReference)));\n      }\n      previousIndex=currentIndex;\n      previousElement=element;\n    }\n  }\n  testSolutionHandler.addTestSolution(checkResult);\n}\n", "docstring": "this methods checks whether the headings hierarchy is well - structured", "partition": "test"}
{"idx": "3240", "code": "public void mouseWheelMoved(MouseWheelEvent e){\n  boolean accepted=checkModifiers(e);\n  if (accepted == true) {\n    VisualizationViewer<?,?> vv=(VisualizationViewer<?,?>)e.getSource();\n    Point2D mouse=e.getPoint();\n    Point2D center=vv.getCenter();\n    int amount=e.getWheelRotation();\n    if (zoomAtMouse) {\n      if (amount > 0) {\n        scaler.scale(vv,in,mouse);\n      }\n else       if (amount < 0) {\n        scaler.scale(vv,out,mouse);\n      }\n    }\n else {\n      if (amount > 0) {\n        scaler.scale(vv,in,center);\n      }\n else       if (amount < 0) {\n        scaler.scale(vv,out,center);\n      }\n    }\n    e.consume();\n    vv.repaint();\n  }\n}\n", "docstring": "zoom the display in or out , depending on the direction of the mouse wheel motion .", "partition": "test"}
{"idx": "3241", "code": "private void handleStartElement(XMLStreamReader parser,Set<Node> childrenFound,Handler handler,Map<String,Object> values,Stack<Set<String>> stack,boolean recordStarted) throws IOException, XMLStreamException {\n  Node n=getMatchingNode(parser,childNodes);\n  Map<String,Object> decends=new HashMap<>();\n  if (n != null) {\n    childrenFound.add(n);\n    n.parse(parser,handler,values,stack,recordStarted);\n    return;\n  }\n  Node dn=this;\n  do {\n    if (dn.wildCardNodes != null) {\n      n=getMatchingNode(parser,dn.wildCardNodes);\n      if (n != null) {\n        childrenFound.add(n);\n        n.parse(parser,handler,values,stack,recordStarted);\n        break;\n      }\n      for (      Node nn : dn.wildCardNodes)       decends.put(nn.name,nn);\n    }\n    dn=dn.wildAncestor;\n  }\n while (dn != null);\n  if (n == null) {\n    int count=1;\n    while (count != 0) {\n      int token=parser.next();\n      if (token == START_ELEMENT) {\n        Node nn=(Node)decends.get(parser.getLocalName());\n        if (nn != null) {\n          childrenFound.add(nn);\n          nn.parse(parser,handler,values,stack,recordStarted);\n        }\n else         count++;\n      }\n else       if (token == END_ELEMENT)       count--;\n    }\n  }\n}\n", "docstring": "if a new tag is encountered , check if it is of interest or not by seeing if it matches against our node tree . if we have deperted from the node tree then walk back though the tree \"'\" s ancestor nodes checking to see if any / / expressions exist for the node and compare them against the new tag . if matched then \" jump \" to that node , otherwise ignore the tag . note , the list of / / expressions found while walking back up the tree is chached in the hashmap decends . then if the new tag is to be skipped , any inner chil tags are compared against the cache and jumped to if matched .", "partition": "test"}
{"idx": "3242", "code": "public boolean equivalent(IMFMarkerType other){\n  if (other == null) {\n    return false;\n  }\n  boolean result=true;\n  result&=offset.equals(other.getOffset());\n  result&=label.equivalent(other.getLabel());\n  return result;\n}\n", "docstring": "a method to determine the equivalence of any two markers .", "partition": "test"}
{"idx": "3243", "code": "public static Discretization discretize(double[] _data,double[] cutoffs,String variableName,List<String> categories){\n  if (cutoffs == null) {\n    throw new NullPointerException();\n  }\n  for (int i=0; i < cutoffs.length - 1; i++) {\n    if (!(cutoffs[i] <= cutoffs[i + 1])) {\n      throw new NullPointerException(\"Cutoffs must be in nondecreasing order.\");\n    }\n  }\n  if (variableName == null) {\n    throw new NullPointerException();\n  }\n  int numCategories=cutoffs.length + 1;\n  if (categories != null && categories.size() != numCategories) {\n    throw new IllegalArgumentException(\"If specified, the list of \" + \"categories names must be one longer than the length of \" + \"the cutoffs array.\");\n  }\n  DiscreteVariable variable;\n  if (categories == null) {\n    variable=new DiscreteVariable(variableName,numCategories);\n  }\n else {\n    variable=new DiscreteVariable(variableName,categories);\n  }\n  int[] discreteData=new int[_data.length];\n  loop:   for (int i=0; i < _data.length; i++) {\n    if (Double.isNaN(_data[i])) {\n      discreteData[i]=DiscreteVariable.MISSING_VALUE;\n      continue;\n    }\n    for (int j=0; j < cutoffs.length; j++) {\n      if (_data[i] > Double.NEGATIVE_INFINITY && _data[i] < Double.POSITIVE_INFINITY && _data[i] < cutoffs[j]) {\n        discreteData[i]=j;\n        continue loop;\n      }\n    }\n    discreteData[i]=cutoffs.length;\n  }\n  return new Discretization(variable,discreteData);\n}\n", "docstring": "discretizes the continuous data in the given column using the specified cutoffs and category names . the following scheme is used . if cutoffs [ i - 1 ", "partition": "test"}
{"idx": "3244", "code": "public static ArrayList<Long> loadWorkspaceScreensDb(Context context){\n  final ContentResolver contentResolver=context.getContentResolver();\n  final Uri screensUri=LauncherSettings.WorkspaceScreens.CONTENT_URI;\n  final Cursor sc=contentResolver.query(screensUri,null,null,null,LauncherSettings.WorkspaceScreens.SCREEN_RANK);\n  ArrayList<Long> screenIds=new ArrayList<Long>();\n  try {\n    final int idIndex=sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);\n    while (sc.moveToNext()) {\n      try {\n        screenIds.add(sc.getLong(idIndex));\n      }\n catch (      Exception e) {\n        Launcher.addDumpLog(TAG,\"Desktop items loading interrupted\" + \" - invalid screens: \" + e,true);\n      }\n    }\n  }\n  finally {\n    if (sc != null) {\n      sc.close();\n    }\n  }\n  return screenIds;\n}\n", "docstring": "loads the workspace screen ids in an ordered list .", "partition": "test"}
{"idx": "3245", "code": "private boolean renderOutput(Node node,InternalContextAdapter context,Writer writer) throws IOException, MethodInvocationException, ResourceNotFoundException {\n  String arg=\"\";\n  if (node == null) {\n    rsvc.error(\"#include() error :  null argument\");\n    return false;\n  }\n  Object value=node.value(context);\n  if (value == null) {\n    rsvc.error(\"#include() error :  null argument\");\n    return false;\n  }\n  arg=value.toString();\n  Resource resource=null;\n  try {\n    resource=rsvc.getContent(arg,getInputEncoding(context));\n  }\n catch (  ResourceNotFoundException rnfe) {\n    rsvc.error(\"#include(): cannot find resource \'\" + arg + \"\', called from template \"+ context.getCurrentTemplateName()+ \" at (\"+ getLine()+ \", \"+ getColumn()+ \")\");\n    throw rnfe;\n  }\ncatch (  Exception e) {\n    rsvc.error(\"#include(): arg = \'\" + arg + \"\', called from template \"+ context.getCurrentTemplateName()+ \" at (\"+ getLine()+ \", \"+ getColumn()+ \") : \"+ e);\n  }\n  if (resource == null)   return false;\n  writer.write((String)resource.getData());\n  return true;\n}\n", "docstring": "does the actual rendering of the included file", "partition": "test"}
{"idx": "3246", "code": "protected String e(String s) throws Exception {\n  return fmt.format(parser.parse(s,null));\n}\n", "docstring": "macro : expected : parses s , fmts", "partition": "test"}
{"idx": "3247", "code": "public Matrix4 multiplyByScale(double xScale,double yScale,double zScale){\n  double[] m=this.m;\n  m[0]*=xScale;\n  m[4]*=xScale;\n  m[8]*=xScale;\n  m[12]*=xScale;\n  m[1]*=yScale;\n  m[5]*=yScale;\n  m[9]*=yScale;\n  m[13]*=yScale;\n  m[2]*=zScale;\n  m[6]*=zScale;\n  m[10]*=zScale;\n  m[14]*=zScale;\n  return this;\n}\n", "docstring": "multiplies this matrix by a scale matrix with specified values .", "partition": "test"}
{"idx": "3248", "code": "public void changeState(){\n  linked=!linked;\n  link=linked ? linkedImIc.getImage() : unlinkedImIc.getImage();\n  repaint();\n}\n", "docstring": "changes the lock icon \"'\" s image to whatever it currently is not . also changes the locked flag accordingly .", "partition": "test"}
{"idx": "3249", "code": "public static Geometry bufferBySegments(Geometry g,double distance){\n  Geometry segs=LineHandlingFunctions.extractSegments(g);\n  double posDist=Math.abs(distance);\n  Geometry segBuf=bufferByComponents(segs,posDist);\n  if (distance < 0.0)   return g.difference(segBuf);\n  return g.union(segBuf);\n}\n", "docstring": "buffer polygons by buffering the individual boundary segments and either unioning or differencing them .", "partition": "test"}
{"idx": "3250", "code": "public void recordEndTime(){\n  int msDiff=(int)(System.currentTimeMillis() - _currentRequestStartTime.get());\n  _log.info(\"Request response time: {} ms\",msDiff);\n  updateOrResetReqRspAvgLstHr(updateOrResetReqRspAvgLstMin(msDiff,false),false);\n  updateMinMaxReqRspMs(msDiff);\n  if (msDiff >= SUSPISCIOUS_RSP_TIME_MS) {\n    _alertLog.warn(MessageFormat.format(\"Request took an unusually long time to complete: {0}ms\",msDiff));\n  }\n  _currentRequestStartTime.remove();\n}\n", "docstring": "computes the response time of the request that just finished for the local thread and updates the request response average in the last minute , and propagates to the request response per minute per hour counter . updates min / max response time . if the response is above suspicious_resp_time_ms , log a warning .", "partition": "test"}
{"idx": "3251", "code": "private boolean isAccessibleUserToKibana(Set<String> filters){\n  if (filters.contains(\"/.kibana\")) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "check if an user has auth to kibana", "partition": "test"}
{"idx": "3252", "code": "public boolean clear(){\n  try {\n    list.clear();\n    fireTableDataChanged();\n  }\n catch (  Exception e) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "remove all entries from the table list .", "partition": "test"}
{"idx": "3253", "code": "public boolean load(File fi) throws JmriConfigureXmlException {\n  return load(fi,false);\n}\n", "docstring": "load a file . < p > handles problems locally to the extent that it can , by routing them to the creationerrorencountered method .", "partition": "test"}
{"idx": "3254", "code": "public void testBug66947() throws Exception {\n  Connection con=null;\n  try {\n    Properties props=new Properties();\n    props.setProperty(\"useServerPrepStmts\",\"true\");\n    props.setProperty(\"cachePrepStmts\",\"true\");\n    props.setProperty(\"prepStmtCacheSize\",\"2\");\n    con=getConnectionWithProps(props);\n    PreparedStatement ps1_1;\n    PreparedStatement ps1_2;\n    String query=\"Select \'a\' from dual\";\n    ps1_1=con.prepareStatement(query);\n    ps1_1.execute();\n    ps1_1.close();\n    ps1_2=con.prepareStatement(query);\n    assertSame(\"SSPS should be taken from cache but is not the same.\",ps1_1,ps1_2);\n    ps1_2.execute();\n    ps1_2.close();\n    ps1_2.close();\n    ps1_1=con.prepareStatement(query);\n    assertNotSame(\"SSPS should not be taken from cache but is the same.\",ps1_2,ps1_1);\n    ps1_1.execute();\n    ps1_1.close();\n    ps1_1.close();\n    PreparedStatement ps2_1;\n    PreparedStatement ps2_2;\n    PreparedStatement ps3_1;\n    PreparedStatement ps3_2;\n    ps1_1=con.prepareStatement(\"Select \'b\' from dual\");\n    ps1_1.execute();\n    ps1_1.close();\n    ps2_1=con.prepareStatement(\"Select \'c\' from dual\");\n    ps2_1.execute();\n    ps2_1.close();\n    ps3_1=con.prepareStatement(\"Select \'d\' from dual\");\n    ps3_1.execute();\n    ps3_1.close();\n    ps1_2=con.prepareStatement(\"Select \'b\' from dual\");\n    assertNotSame(\"SSPS should not be taken from cache but is the same.\",ps1_1,ps1_2);\n    ps2_2=con.prepareStatement(\"Select \'c\' from dual\");\n    assertSame(\"SSPS should be taken from cache but is not the same.\",ps2_1,ps2_2);\n    ps3_2=con.prepareStatement(\"Select \'d\' from dual\");\n    assertSame(\"SSPS should be taken from cache but is not the same.\",ps3_1,ps3_2);\n  }\n  finally {\n    if (con != null) {\n      con.close();\n    }\n  }\n}\n", "docstring": "tests fix for bug # 66947 ( 16004987 ) - calling serverpreparedstatement . close ( ) twiche corrupts cached statements", "partition": "test"}
{"idx": "3255", "code": "public void addRequestProperty(String key,String value){\n  if (connected)   throw new IllegalStateException(\"Already connected\");\n  if (key == null)   throw new NullPointerException(\"key is null\");\n  if (requests == null)   requests=new MessageHeader();\n  requests.add(key,value);\n}\n", "docstring": "adds a general request property specified by a key - value pair . this method will not overwrite existing values associated with the same key .", "partition": "test"}
{"idx": "3256", "code": "ServerMember update(Address clientAddress,Instant time){\n  if (clientAddress != null) {\n    this.clientAddress=clientAddress;\n    if (time.isAfter(updated)) {\n      this.updated=Assert.notNull(time,\"time\");\n    }\n  }\n  return this;\n}\n", "docstring": "updates the member client address .", "partition": "test"}
{"idx": "3257", "code": "public static boolean isOrgLevelOnly(int AD_Client_ID,int AD_Table_ID){\n  Boolean share=isShared(AD_Client_ID,AD_Table_ID);\n  if (share != null)   return !share.booleanValue();\n  return false;\n}\n", "docstring": "is table org level only", "partition": "test"}
{"idx": "3258", "code": "@Override public void actionPerformed(ActionEvent event){\n  String command=event.getActionCommand();\n  if (command.equals(\"BackgroundPaint\")) {\n    attemptModifyBackgroundPaint();\n  }\n}\n", "docstring": "handles user interactions with the panel .", "partition": "test"}
{"idx": "3259", "code": "public byte[] serializeToBuffer(Object o) throws IOException {\n  ByteArrayOutputStream bufOut=new ByteArrayOutputStream();\n  try {\n    serialize(bufOut,o);\n    bufOut.flush();\n    return bufOut.toByteArray();\n  }\n  finally {\n    bufOut.close();\n  }\n}\n", "docstring": "serializes the object into a byte buffer .", "partition": "test"}
{"idx": "3260", "code": "ModulePointer resolve(String modName){\n  return (ModulePointer)context.get(modName);\n}\n", "docstring": "find the modulepointer that the string modname resolves to ; return null if either modname is not found in the context or if it is found and resolves to null , i . e . is not yet resolved .", "partition": "test"}
{"idx": "3261", "code": "public NarClassLoader(final File narWorkingDirectory) throws ClassNotFoundException, IOException {\n  super(new URL[0]);\n  this.narWorkingDirectory=narWorkingDirectory;\n  updateClasspath(narWorkingDirectory);\n}\n", "docstring": "construct a nar class loader .", "partition": "test"}
{"idx": "3262", "code": "public static TypeBinding[] substitute(Substitution substitution,TypeBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  TypeBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    TypeBinding originalType=originalTypes[i];\n    TypeBinding substitutedParameter=substitute(substitution,originalType);\n    if (substitutedParameter != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new TypeBinding[length],0,i);\n      }\n      substitutedTypes[i]=substitutedParameter;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}\n", "docstring": "returns an array of types , where original types got substituted given a substitution . only allocate an array if anything is different .", "partition": "test"}
{"idx": "3263", "code": "private boolean checkIfScrolling(float[] lastPoints,MotionEvent ev){\n  float[] point=new float[2];\n  point[0]=ev.getRawX();\n  point[1]=ev.getRawY();\n  float delta=getDistance(lastPoints,point);\n  return Math.abs(delta) > mSlop;\n}\n", "docstring": "checks to see if the user is currently scrolling the menu .", "partition": "test"}
{"idx": "3264", "code": "public void testMergeOneFilterIntoDocumentWithSameFilter() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.mergeFilters(mergeWebXml);\n  assertTrue(WebXmlUtils.hasFilter(srcWebXml,\"f1\"));\n}\n", "docstring": "tests whether a single filter in the merge descriptor is ignored because a filter with the same name already exists in the source descriptor .", "partition": "test"}
{"idx": "3265", "code": "public Edge(S src,Symbol symbol,S dest){\n  this.src=src;\n  this.symbol=symbol;\n  this.dest=dest;\n  this.srcItem=src.getFirstItem();\n  this.hashCache=calcHashCode();\n}\n", "docstring": "edge which leads to another non - accepting state .", "partition": "test"}
{"idx": "3266", "code": "public void push(final Type value){\n  if (value == null) {\n    mv.visitInsn(Opcodes.ACONST_NULL);\n  }\n else {\nswitch (value.getSort()) {\ncase Type.BOOLEAN:\n      mv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Boolean\",\"TYPE\",CLDESC);\n    break;\ncase Type.CHAR:\n  mv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Character\",\"TYPE\",CLDESC);\nbreak;\ncase Type.BYTE:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Byte\",\"TYPE\",CLDESC);\nbreak;\ncase Type.SHORT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Short\",\"TYPE\",CLDESC);\nbreak;\ncase Type.INT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Integer\",\"TYPE\",CLDESC);\nbreak;\ncase Type.FLOAT:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Float\",\"TYPE\",CLDESC);\nbreak;\ncase Type.LONG:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Long\",\"TYPE\",CLDESC);\nbreak;\ncase Type.DOUBLE:\nmv.visitFieldInsn(Opcodes.GETSTATIC,\"java/lang/Double\",\"TYPE\",CLDESC);\nbreak;\ndefault :\nmv.visitLdcInsn(value);\n}\n}\n}\n", "docstring": "generates the instruction to push the given value on the stack .", "partition": "test"}
{"idx": "3267", "code": "public ExtendedTextLabel createExtended(Font font,CoreMetrics lm,Decoration decorator,int start,int limit){\n  if (start >= limit || start < lineStart || limit > lineLimit) {\n    throw new IllegalArgumentException(\"bad start: \" + start + \" or limit: \"+ limit);\n  }\n  int level=lineBidi == null ? 0 : lineBidi.getLevelAt(start - lineStart);\n  int linedir=(lineBidi == null || lineBidi.baseIsLeftToRight()) ? 0 : 1;\n  int layoutFlags=flags & ~0x9;\n  if ((level & 0x1) != 0)   layoutFlags|=1;\n  if ((linedir & 0x1) != 0)   layoutFlags|=8;\n  TextSource source=new StandardTextSource(text,start,limit - start,lineStart,lineLimit - lineStart,level,layoutFlags,font,frc,lm);\n  return new ExtendedTextSourceLabel(source,decorator);\n}\n", "docstring": "create an extended glyph array for the text between start and limit .", "partition": "test"}
{"idx": "3268", "code": "public static String rightPad(String s,int minLength,char filling){\n  int ln=s.length();\n  if (minLength <= ln) {\n    return s;\n  }\n  StringBuilder res=new StringBuilder(minLength);\n  res.append(s);\n  int dif=minLength - ln;\n  for (int i=0; i < dif; i++) {\n    res.append(filling);\n  }\n  return res.toString();\n}\n", "docstring": "pads the string at the right with the specified character until it reaches the desired length . if the string is longer than this length , then it returns the unchanged string .", "partition": "test"}
{"idx": "3269", "code": "private static String readQuotedDescriptor(final SubstringReader reader,final boolean allowCompatChars) throws DecodeException {\n  int length=0;\n  reader.skipWhitespaces();\n  try {\n    char c=reader.read();\n    if (c != '\\'') {\n      throw DecodeException.error(ERR_ATTR_SYNTAX_EXPECTED_QUOTE_AT_POS1.get(reader.pos() - 1,c));\n    }\n    reader.mark();\n    while ((c=reader.read()) != '\\'') {\n      if (length == 0 && !isAlpha(c)) {\n        throw DecodeException.error(ERR_ATTR_SYNTAX_ILLEGAL_CHAR_IN_STRING_OID1.get(c,reader.pos() - 1));\n      }\n      if (!isKeyChar(c,allowCompatChars)) {\n        throw DecodeException.error(ERR_ATTR_SYNTAX_ILLEGAL_CHAR_IN_STRING_OID1.get(c,reader.pos() - 1));\n      }\n      length++;\n    }\n    reader.reset();\n    final String descr=reader.read(length);\n    reader.read();\n    return descr;\n  }\n catch (  final StringIndexOutOfBoundsException e) {\n    throw DecodeException.error(ERR_ATTR_SYNTAX_TRUNCATED_VALUE1.get());\n  }\n}\n", "docstring": "reads the value of a string enclosed in single quotes , skipping over the quotes and any leading spaces .", "partition": "test"}
{"idx": "3270", "code": "public String toCSV(){\n  StringBuilder builder=new StringBuilder();\n  builder.append(\",,Predicted Class,\\n\");\n  builder.append(\",,\");\n  for (  T predicted : classes) {\n    builder.append(String.format(\"%s,\",predicted));\n  }\n  builder.append(\"Total\\n\");\n  String firstColumnLabel=\"Actual Class,\";\n  for (  T actual : classes) {\n    builder.append(firstColumnLabel);\n    firstColumnLabel=\",\";\n    builder.append(String.format(\"%s,\",actual));\n    for (    T predicted : classes) {\n      builder.append(getCount(actual,predicted));\n      builder.append(\",\");\n    }\n    builder.append(getActualTotal(actual));\n    builder.append(\"\\n\");\n  }\n  builder.append(\",Total,\");\n  for (  T predicted : classes) {\n    builder.append(getPredictedTotal(predicted));\n    builder.append(\",\");\n  }\n  builder.append(\"\\n\");\n  return builder.toString();\n}\n", "docstring": "outputs the confusionmatrix as comma - separated values for easy import into spreadsheets", "partition": "test"}
{"idx": "3271", "code": "public Object assignIdValue(Object data,Number val,ObjectCache objectCache) throws SQLException {\n  Object idVal=dataPersister.convertIdNumber(val);\n  if (idVal == null) {\n    throw new SQLException(\"Invalid class \" + dataPersister + \" for sequence-id \"+ this);\n  }\n else {\n    assignField(data,idVal,false,objectCache);\n    return idVal;\n  }\n}\n", "docstring": "assign an id value to this field .", "partition": "test"}
{"idx": "3272", "code": "public final boolean isOpen(){\n  return closed.get() == false;\n}\n", "docstring": "returns true if this lock is still open ie . has not been closed yet .", "partition": "test"}
{"idx": "3273", "code": "public static Map<String,Object> performFindList(DispatchContext dctx,Map<String,Object> context){\n  Integer viewSize=(Integer)context.get(\"viewSize\");\n  if (viewSize == null)   viewSize=Integer.valueOf(20);\n  context.put(\"viewSize\",viewSize);\n  Integer viewIndex=(Integer)context.get(\"viewIndex\");\n  if (viewIndex == null)   viewIndex=Integer.valueOf(0);\n  context.put(\"viewIndex\",viewIndex);\n  Map<String,Object> result=performFind(dctx,context);\n  int start=viewIndex.intValue() * viewSize.intValue();\n  List<GenericValue> list=null;\n  Integer listSize=0;\n  try {\n    EntityListIterator it=(EntityListIterator)result.get(\"listIt\");\n    list=it.getPartialList(start + 1,viewSize);\n    listSize=it.getResultsSizeAfterPartialList();\n    it.close();\n  }\n catch (  Exception e) {\n    Debug.logInfo(\"Problem getting partial list\" + e,module);\n  }\n  result.put(\"listSize\",listSize);\n  result.put(\"list\",list);\n  result.remove(\"listIt\");\n  return result;\n}\n", "docstring": "same as performfind but now returning a list instead of an iterator extra parameters viewindex : startpage of the partial list ( 0 = first page ) viewsize : the length of the page ( number of records ) extra output parameter : listsize : size of the totallist list : the list itself .", "partition": "test"}
{"idx": "3274", "code": "public static String soapToString(SOAPElement element){\n  return domToString(element.getOwnerDocument());\n}\n", "docstring": "converts a javax . xml . soap . soapelement to a string can be used for soapui requests be carefull : to convert a soapmessage sm , you must use sm . getsoappart ( ) . getenvelope ( ) ;", "partition": "test"}
{"idx": "3275", "code": "@Override public void close() throws IOException {\n  try {\n    out.close();\n  }\n  finally {\n    lockFile.delete();\n  }\n}\n", "docstring": "closes the file writer and deletes the lockfile ( if possible ) .", "partition": "test"}
{"idx": "3276", "code": "@Override public boolean equals(Object x,Object y) throws HibernateException {\n  if (x == null) {\n    return y == null;\n  }\n  return x.equals(y);\n}\n", "docstring": "compare two instances of the class mapped by this type for persistence \" equality \" . equality of the persistent state .", "partition": "test"}
{"idx": "3277", "code": "@Override public final void writeBoolean(boolean v) throws IOException {\n  dis.writeBoolean(v);\n}\n", "docstring": "write a booleans as one byte .", "partition": "test"}
{"idx": "3278", "code": "public void train(Set<String> sFileNames){\n  Iterator<String> iFile=sFileNames.iterator();\n  while (iFile.hasNext()) {\n    String sText=utils.loadFileToString(iFile.next());\n    train(sText);\n  }\n}\n", "docstring": "train the statistics of the chunker from a given file set .", "partition": "test"}
{"idx": "3279", "code": "public void testFindSpringOpenLdapWithLimit(){\n  LdapProxy proxy=getLdapOpenLdap();\n  List result=null;\n  int limit=1;\n  try {\n    result=proxy.find(getLdapSearchVO(\"\",limit,\"cn\",\"ngomila\",null,LdapScopeConstants.SCOPE_SUBTREE));\n  }\n catch (  Exception e) {\n  }\n  assertNotNull(result);\n  if (result != null) {\n    assertEquals(limit,result.size());\n  }\n}\n", "docstring": "test de busqueda open ldap con limite", "partition": "test"}
{"idx": "3280", "code": "public PrintfFormat(String fmtArg) throws IllegalArgumentException {\n  this(Locale.getDefault(),fmtArg);\n}\n", "docstring": "constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings . control strings begin with unpaired percent signs . a pair of successive percent signs designates a single percent sign in the format .", "partition": "test"}
{"idx": "3281", "code": "static double svd_pythag(double a,double b){\n  double p, r, s, t, u, temp;\n  p=svd_dmax(Math.abs(a),Math.abs(b));\n  if (p != 0.0) {\n    temp=svd_dmin(Math.abs(a),Math.abs(b)) / p;\n    r=temp * temp;\n    t=4.0 + r;\n    while (t != 4.0) {\n      s=r / t;\n      u=1.0 + 2.0 * s;\n      p*=u;\n      temp=s / u;\n      r*=temp * temp;\n      t=4.0 + r;\n    }\n  }\n  return p;\n}\n", "docstring": "funtions used - - - - - - - - - - - - - utility dmax , dmin", "partition": "test"}
{"idx": "3282", "code": "public static void writeFixInt32(final OutputStream output,final int val) throws IOException {\n  output.write((val >>> 24) & 0xFF);\n  output.write((val >>> 16) & 0xFF);\n  output.write((val >>> 8) & 0xFF);\n  output.write(val & 0xFF);\n}\n", "docstring": "write a fixed - width 32 bit integer in network byte order ( big - endian ) .", "partition": "test"}
{"idx": "3283", "code": "public static void queueCubeLoad(ICubicWorld world,CubeIO loader,CubeProviderServer cache,int x,int y,int z,Consumer<Cube> runnable){\n  QueuedCube key=new QueuedCube(x,y,z,world);\n  AsyncCubeIOProvider task=cubeTasks.get(key);\n  if (task == null) {\n    task=new AsyncCubeIOProvider(key,loader);\n    task.addCallback(runnable);\n    cubeTasks.put(key,task);\n    pool.execute(task);\n  }\n else {\n    task.addCallback(runnable);\n  }\n  Column loadedColumn;\n  if ((loadedColumn=cache.getLoadedColumn(x,z)) == null) {\n    cache.asyncGetColumn(x,z,IProviderExtras.Requirement.LIGHT,null);\n  }\n else {\n    task.setColumn(loadedColumn);\n  }\n}\n", "docstring": "queue a cube load , running the specified callback when the load has finished . this may cause a two tick delay if the column has to be loaded , too ! if you need it faster , consider sync loading either column or both cube and column .", "partition": "test"}
{"idx": "3284", "code": "public static boolean isObjectAvailableNow(final boolean enabled,final Date availableFrom,final Date availableTo,final Date now){\n  if (!enabled) {\n    return false;\n  }\n  if (availableFrom != null && now.before(availableFrom)) {\n    return false;\n  }\n  if (availableTo != null && now.after(availableTo)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "check availability of an object .", "partition": "test"}
{"idx": "3285", "code": "public void buttonClicked(ActionEvent e);\n", "docstring": "invoked when the button part is clicked .", "partition": "test"}
{"idx": "3286", "code": "private long loadLargestMessageId(){\n  ReleaseMessage releaseMessage=releaseMessageRepository.findTopByOrderByIdDesc();\n  return releaseMessage == null ? 0 : releaseMessage.getId();\n}\n", "docstring": "find largest message id as the current start point", "partition": "test"}
{"idx": "3287", "code": "public void removeChangeListener(ChangeListener l){\n  if (listeners == null)   return;\n  listeners.remove(l);\n}\n", "docstring": "removes a changelistener from this loader .", "partition": "test"}
{"idx": "3288", "code": "public static RequestLog dump(){\n  RequestLog current=RLOG.get();\n  RequestLog copy=new RequestLog(current);\n  current.clear();\n  RLOG.remove();\n  return copy;\n}\n", "docstring": "exports a snapshot of the request log of the current thread and also resets the request log for that thread .", "partition": "test"}
{"idx": "3289", "code": "public static String urlDecode(String str){\n  try {\n    return (URLDecoder.decode(str,\"utf-8\"));\n  }\n catch (  Exception e) {\n    return (\"Decoding error\");\n  }\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "3290", "code": "public void testThenAcceptBoth_exceptionalCompletion() throws Throwable {\n  for (  ExecutionMode m : ExecutionMode.values())   for (  boolean fFirst : new boolean[]{true,false})   for (  boolean failFirst : new boolean[]{true,false})   for (  Integer v1 : new Integer[]{1,null}) {\n    final CompletableFuture<Integer> f=new CompletableFuture<>();\n    final CompletableFuture<Integer> g=new CompletableFuture<>();\n    final CFException ex=new CFException();\n    final SubtractAction r1=new SubtractAction(m);\n    final SubtractAction r2=new SubtractAction(m);\n    final SubtractAction r3=new SubtractAction(m);\n    final CompletableFuture<Integer> fst=fFirst ? f : g;\n    final CompletableFuture<Integer> snd=!fFirst ? f : g;\n    final Callable<Boolean> complete1=failFirst ? null : null;\n    final Callable<Boolean> complete2=failFirst ? null : null;\n    final CompletableFuture<Void> h1=m.thenAcceptBoth(f,g,r1);\n    assertTrue(complete1.call());\n    final CompletableFuture<Void> h2=m.thenAcceptBoth(f,g,r2);\n    checkIncomplete(h1);\n    checkIncomplete(h2);\n    assertTrue(complete2.call());\n    final CompletableFuture<Void> h3=m.thenAcceptBoth(f,g,r3);\n    checkCompletedWithWrappedException(h1,ex);\n    checkCompletedWithWrappedException(h2,ex);\n    checkCompletedWithWrappedException(h3,ex);\n    r1.assertNotInvoked();\n    r2.assertNotInvoked();\n    r3.assertNotInvoked();\n    checkCompletedNormally(failFirst ? snd : fst,v1);\n    checkCompletedExceptionally(failFirst ? fst : snd,ex);\n  }\n}\n", "docstring": "thenacceptboth result completes exceptionally after exceptional completion of either source", "partition": "test"}
{"idx": "3291", "code": "protected DefaultListModel stringToModel(String s){\n  DefaultListModel result;\n  String tmpStr;\n  int i;\n  boolean quote;\n  String[] find;\n  String[] replace;\n  int index;\n  result=new DefaultListModel();\n  find=new String[]{\"\\\"\\\"\",\"\\\\n\",\"\\\\r\",\"\\\\t\"};\n  replace=new String[]{\"\\\"\",\"\\n\",\"\\r\",\"\\t\"};\n  for (i=0; i < find.length; i++) {\n    tmpStr=\"\";\n    while (s.length() > 0) {\n      index=s.indexOf(find[i]);\n      if (index > -1) {\n        tmpStr+=s.substring(0,index) + replace[i];\n        s=s.substring(index + 2);\n      }\n else {\n        tmpStr+=s;\n        s=\"\";\n      }\n    }\n    s=tmpStr;\n  }\n  quote=false;\n  tmpStr=\"\";\n  for (i=0; i < s.length(); i++) {\n    if (s.charAt(i) == \'\"\') {\n      quote=!quote;\n      tmpStr+=\"\" + s.charAt(i);\n    }\n else     if (s.charAt(i) == \',\') {\n      if (quote) {\n        tmpStr+=\"\" + s.charAt(i);\n      }\n else {\n        if (tmpStr.startsWith(\"\\\"\")) {\n          tmpStr=tmpStr.substring(1,tmpStr.length() - 1);\n        }\n        result.addElement(tmpStr);\n        tmpStr=\"\";\n      }\n    }\n else {\n      tmpStr+=\"\" + s.charAt(i);\n    }\n  }\n  if (!tmpStr.equals(\"\")) {\n    if (tmpStr.startsWith(\"\\\"\")) {\n      tmpStr=tmpStr.substring(1,tmpStr.length() - 1);\n    }\n    result.addElement(tmpStr);\n  }\n  return result;\n}\n", "docstring": "transforms the given , comma - separated string into a defaultlistmodel .", "partition": "test"}
{"idx": "3292", "code": "public void testGetTables() throws Exception {\n  DatabaseMetaData dmd=con.getMetaData();\n  ResultSet rs=dmd.getTables(null,null,null,null);\n  assertNotNull(rs);\n  rs.close();\n}\n", "docstring": "test for bug [ 998765 ", "partition": "test"}
{"idx": "3293", "code": "public void addAll(Collection<? extends T> collection){\n  if (mEventDelegate != null)   mEventDelegate.addData(collection == null ? 0 : collection.size());\n  if (collection != null && collection.size() != 0) {\nsynchronized (mLock) {\n      mObjects.addAll(collection);\n    }\n  }\n  if (mNotifyOnChange)   notifyDataSetChanged();\n}\n", "docstring": "adds the specified collection at the end of the array .", "partition": "test"}
{"idx": "3294", "code": "public static void resetCurrentFileList(String logName){\n  currentFileList.remove(PREFIX + logName);\n}\n", "docstring": "reset the current file list for the logger .", "partition": "test"}
{"idx": "3295", "code": "@Override public abstract List<JToolBar> createToolBars(Application a,@Nullable View p);\n", "docstring": "creates toolbars for the application .", "partition": "test"}
{"idx": "3296", "code": "public static synchronized ResultSet executeQuery(String sqlStatement){\n  logger.trace(String.format(\"executeQuery( %s ) -->entry\",sqlStatement));\n  ResultSet R=null;\n  final Statement S=getStatement();\n  if (S == null) {\n    logger.error(\"executeQuery() <--exit (error: Statement unavailable)\");\n    return null;\n  }\n  try {\n    R=S.executeQuery(sqlStatement);\n    logger.trace(\"executeQuery() <--exit (normal): \" + (null == R));\n    return R;\n  }\n catch (  Throwable t) {\n    surfaceThrowable(String.format(\"executeQuery( %s )\",sqlStatement),t);\n    cleanup(S,R);\n  }\n  return null;\n}\n", "docstring": "this method is a thin wrapper for jdbc executequery ( ) . it exists primarily so that we can be assured of the properties of the resultset which is returned , and for consistency of error logging .", "partition": "test"}
{"idx": "3297", "code": "public void write(byte[] buf) throws IOException {\n  output.write(buf);\n  bytesWritten+=buf.length;\n}\n", "docstring": "counts the written bytes .", "partition": "test"}
{"idx": "3298", "code": "public static String urlEncode(@Nullable String s){\n  if (s == null) {\n    return \"\";\n  }\n  try {\n    return URLEncoder.encode(s,\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new AssertionError(\"UTF-8 should be supported in every JVM\");\n  }\n}\n", "docstring": "url - encodes a nullable string , catching the useless exception that never happens .", "partition": "test"}
{"idx": "3299", "code": "protected static boolean checkRawModulesTables(final CConnection connection,final String databaseName,final int rawModuleId){\n  Preconditions.checkNotNull(connection,\"IE02261: Connection argument can not be null\");\n  Preconditions.checkNotNull(databaseName,\"IE02262: Database name argument can not be null\");\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be a positive integer\",rawModuleId);\n  final ImmutableSet<String> rawTableNames=ImmutableSet.of(String.format(CTableNames.RAW_ADDRESS_COMMENTS_TABLE,rawModuleId),String.format(CTableNames.RAW_ADDRESS_REFERENCES_TABLE,rawModuleId),String.format(CTableNames.RAW_BASE_TYPES,rawModuleId),String.format(CTableNames.RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_BASIC_BLOCKS_TABLE,rawModuleId),String.format(CTableNames.RAW_CALLGRAPH_TABLE,rawModuleId),String.format(CTableNames.RAW_CONTROL_FLOW_GRAPHS_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_NODES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_SUBSTITUTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TREE_NODES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TREES_TABLE,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TYPES_TABLE,rawModuleId),String.format(CTableNames.RAW_FUNCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_INSTRUCTIONS_TABLE,rawModuleId),String.format(CTableNames.RAW_OPERANDS_TABLE,rawModuleId),String.format(CTableNames.RAW_SECTIONS,rawModuleId),String.format(CTableNames.RAW_EXPRESSION_TYPE_INSTANCES,rawModuleId),String.format(CTableNames.RAW_TYPE_INSTACES,rawModuleId),String.format(CTableNames.RAW_TYPES,rawModuleId));\n  final Pair<CConnection,String> cacheKey=new Pair<>(connection,databaseName);\n  if (PostgreSQLDatabaseFunctions.queryCache(cacheKey,rawTableNames)) {\n    return true;\n  }\n else {\n    if (!PostgreSQLDatabaseFunctions.fillCache(cacheKey)) {\n      return false;\n    }\n    return PostgreSQLDatabaseFunctions.queryCache(cacheKey,rawTableNames);\n  }\n}\n", "docstring": "checks the existence of all necessary raw module tables .", "partition": "test"}
{"idx": "3300", "code": "public Currency read(String symbol){\n  return Currency.getInstance(symbol);\n}\n", "docstring": "this method is used to convert the string value given to an appropriate representation . this is used when an object is being deserialized from the xml document and the value for the string representation is required .", "partition": "test"}
{"idx": "3301", "code": "public static float parseFloat(String s){\n  if (POSITIVE_INFINITY.equals(s)) {\n    return Float.POSITIVE_INFINITY;\n  }\n else   if (NEGATIVE_INFINITY.equals(s)) {\n    return Float.NEGATIVE_INFINITY;\n  }\n else   if (NaN.equals(s)) {\n    return Float.NaN;\n  }\n else {\n    s=trimPlusSign(s);\n    return Float.parseFloat(s);\n  }\n}\n", "docstring": "parses the supplied xsd : float string and returns its value .", "partition": "test"}
{"idx": "3302", "code": "public void requestPasswordForShareViaLink(boolean createShare){\n  SharePasswordDialogFragment dialog=SharePasswordDialogFragment.newInstance(mFile,createShare);\n  dialog.show(getFragmentManager(),SharePasswordDialogFragment.PASSWORD_FRAGMENT);\n}\n", "docstring": "starts a dialog that requests a password to the user to protect a share link .", "partition": "test"}
{"idx": "3303", "code": "private void forceOutOfMemory(){\n  ArrayList junk=new ArrayList();\n  for (; ; ) {\n    junk.add(new long[100000]);\n  }\n}\n", "docstring": "allocate objects until death", "partition": "test"}
{"idx": "3304", "code": "public static double enlargementScaled(SpatialComparable exist,SpatialComparable addit,double scale){\n  final int dim=assertSameDimensionality(exist,addit);\n  double v1=1.;\n  double v2=1.;\n  for (int i=0; i < dim; i++) {\n    final double emin=exist.getMin(i);\n    final double emax=exist.getMax(i);\n    final double amin=addit.getMin(i);\n    final double amax=addit.getMax(i);\n    final double min=Math.min(emin,amin);\n    final double max=Math.max(emax,amax);\n    v1*=(max - min) * scale;\n    v2*=(emax - emin) * scale;\n  }\n  return v2 - v1;\n}\n", "docstring": "compute the enlargement obtained by adding an object to an existing object .", "partition": "test"}
{"idx": "3305", "code": "public boolean canGetInt(){\n  return canGet(int.class);\n}\n", "docstring": "indicates if convenience get method can be called without an exception being thrown for the int type .", "partition": "test"}
{"idx": "3306", "code": "@TCB static String stripBannedCodeunits(String s){\n  int safeLimit=longestPrefixOfGoodCodeunits(s);\n  if (safeLimit < 0) {\n    return s;\n  }\n  StringBuilder sb=new StringBuilder(s);\n  stripBannedCodeunits(sb,safeLimit);\n  return sb.toString();\n}\n", "docstring": "returns the portion of its input that consists of xml safe chars .", "partition": "test"}
{"idx": "3307", "code": "public static void assertLinewiseEquals(String message,String expected,String actual){\n  try (Scanner expectedScanner=new Scanner(expected);Scanner actualScanner=new Scanner(actual)){\n    String expectedLine=null;\n    String actualLine=null;\n    int lineCounter=1;\n    while (expectedScanner.hasNextLine()) {\n      expectedLine=expectedScanner.nextLine();\n      if (actualScanner.hasNextLine()) {\n        actualLine=actualScanner.nextLine();\n      }\n else {\n        fail(\"Line \" + lineCounter + \": actual input has less lines then expected result! Expected: \"+ expectedLine);\n      }\n      assertEquals(\"Line \" + lineCounter + \": \"+ message+ \"\\n\\nExpected:\\n\"+ expected+ \"\\nActual:\\n\"+ actual,expectedLine,actualLine);\n      ++lineCounter;\n    }\n  }\n }\n", "docstring": "compares a string linewise , i . e . ignores different linebreak characters . does this by incrementally reading all expected an actual lines and comparing them linewise .", "partition": "test"}
{"idx": "3308", "code": "private void warning(String msg,Throwable th){\n  warning(msg);\n  th.printStackTrace();\n}\n", "docstring": "used internally to log a message about the class at level warning , in case an exception was thrown", "partition": "test"}
{"idx": "3309", "code": "public String fullForm(final String str,final String lowString){\n  String ret=lowString;\n  PrefixEntry found=prefixMap.get(str);\n  if (found != null) {\n    ret=found.prefixSingular + ret;\n  }\n else {\n    for (    PrefixEntry entry : prefixEndList) {\n      if (str.endsWith(entry.keyword)) {\n        ret=Grammar.addPrefixIfNotAlreadyThere(ret,entry.prefixSingular,entry.prefixPlural);\n        break;\n      }\n    }\n  }\n  return ret;\n}\n", "docstring": "prefix one of the registered nouns with an expression like \" piece of \" .", "partition": "test"}
{"idx": "3310", "code": "public void clearPasswordExpirationWarnedTime(){\n  operations.add(PasswordPolicyStateOperationType.CLEAR_PASSWORD_EXPIRATION_WARNED_TIME);\n}\n", "docstring": "clears the password expiration warned time .", "partition": "test"}
{"idx": "3311", "code": "public void removeListeners(){\n  if (globalListener != null) {\n    try {\n      InvokerHelper.invokeMethod(currentObject,\"removePropertyChangeListener\",globalListener);\n    }\n catch (    Exception e) {\n    }\n    globalListener=null;\n  }\n  if (localListener != null) {\n    try {\n      InvokerHelper.invokeMethod(currentObject,\"removePropertyChangeListener\",new Object[]{propertyName,localListener});\n    }\n catch (    Exception e) {\n    }\n    localListener=null;\n  }\n  if (syntheticFullBinding != null) {\n    syntheticFullBinding.unbind();\n  }\n}\n", "docstring": "remove listeners , believing that our bould flags are accurate and it removes only as declared .", "partition": "test"}
{"idx": "3312", "code": "public static String padLeft(String str,int totalChars){\n  if (str == null)   str=\"null\";\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < totalChars - str.length(); i++) {\n    sb.append(\" \");\n  }\n  sb.append(str);\n  return sb.toString();\n}\n", "docstring": "pads the given string to the left with spaces to ensure that it \"'\" s at least totalchars long .", "partition": "test"}
{"idx": "3313", "code": "public void showScores(boolean flag){\n  mShowScores=flag;\n  SwingUtilities.invokeLater(null);\n}\n", "docstring": "set whether to show scores on the plot lines", "partition": "test"}
{"idx": "3314", "code": "protected double kernelHelper(int n,char[] s,int endIndexS,char[] t,int endIndexT){\n  if (n <= 0) {\n    return getReturnValue(n);\n  }\n  if (Math.min(endIndexS + 1,endIndexT + 1) < n) {\n    return getReturnValue(n);\n  }\n  int adr=0;\n  if (m_useRecursionCache) {\n    adr=m_multX * n + m_multY * endIndexS + m_multZ * endIndexT;\n    if (cachekhK[adr % maxCache] == adr + 1) {\n      return cachekh[adr % maxCache];\n    }\n  }\n  double result=0;\n  result=m_lambda * kernelHelper(n,s,endIndexS - 1,t,endIndexT) + kernelHelper2(n,s,endIndexS,t,endIndexT);\n  if (m_useRecursionCache) {\n    cachekhK[adr % maxCache]=adr + 1;\n    cachekh[adr % maxCache]=result;\n  }\n  return result;\n}\n", "docstring": "the kernel helper function , called k \"'\" in [ 1 ", "partition": "test"}
{"idx": "3315", "code": "protected Connection openH2Connection(boolean autocommit) throws SQLException {\n  System.setProperty(\"h2.serializeJavaObject\",\"false\");\n  String dbName=\"test\";\n  Connection conn=DriverManager.getConnection(\"jdbc:h2:mem:\" + dbName + \";DB_CLOSE_DELAY=-1\");\n  conn.setAutoCommit(autocommit);\n  return conn;\n}\n", "docstring": "gets connection from a pool .", "partition": "test"}
{"idx": "3316", "code": "protected void startRecoarding(){\n  coordinates.clear();\n  enabled=true;\n}\n", "docstring": "start recording the gesture", "partition": "test"}
{"idx": "3317", "code": "public void addInputMethodListener(InputMethodListener l){\n  m_textPane.addInputMethodListener(l);\n}\n", "docstring": "add input method listener", "partition": "test"}
{"idx": "3318", "code": "public void addFooterView(View v,Object data,boolean isSelectable){\n  FixedViewInfo info=new FixedViewInfo();\n  info.view=v;\n  info.data=data;\n  info.isSelectable=isSelectable;\n  mFooterViewInfos.add(info);\n  if (mAdapter != null && mObserver != null) {\n    mObserver.onChanged();\n  }\n}\n", "docstring": "add a fixed view to appear at the bottom of the list . if addfooterview is called more than once , the views will appear in the order they were added . views added using this call can take focus if they want . < p / > note : call this before calling setadapter . this is so listview can wrap the supplied cursor with one that will also account for header and footer views .", "partition": "test"}
{"idx": "3319", "code": "public static void load(String url){\n  String driver=getDriver(url);\n  if (driver != null) {\n    loadUserClass(driver);\n  }\n}\n", "docstring": "load the driver class for the given url , if the database url is known .", "partition": "test"}
{"idx": "3320", "code": "protected void putCommand(final Class commandClass,final String[] names){\n  Check.isTrue(names.length > 0,\"names.length > 0\");\n  _commandsToCanonicalNames.put(commandClass,names[0]);\n  for (int i=0; i < names.length; i++) {\n    _aliasesToCommands.put(names[i],commandClass);\n  }\n}\n", "docstring": "add a command in the hash map .", "partition": "test"}
{"idx": "3321", "code": "protected void writeColumnAutoIncrementStmt(Table table,Column column,StringBuilder ddl){\n  ddl.append(\"IDENTITY\");\n}\n", "docstring": "prints that the column is an auto increment column .", "partition": "test"}
{"idx": "3322", "code": "private void SaveGCMData(){\n  try {\n    SharedPreferences preferences=getSharedPreferences();\n    SharedPreferences.Editor editor=preferences.edit();\n    editor.putString(PREFS_PUSHER_APP_ID_KEY,mPusherAppId);\n    editor.putString(PREFS_PUSHER_URL_KEY,mPusherUrl);\n    editor.putString(PREFS_PUSHER_FILE_TAG_KEY,mPusherBaseFileTag);\n    editor.commit();\n  }\n catch (  Exception e) {\n    Log.e(LOG_TAG,\"SaveGCMData failed \" + e.getLocalizedMessage());\n  }\n}\n", "docstring": "save the gcm info to the preferences", "partition": "test"}
{"idx": "3323", "code": "private void paintBackgroundSolid(Graphics2D g,JComponent c,int x,int y,int width,int height){\n  Color color=c.getBackground();\n  if (type == CommonControlState.DISABLED) {\n    color=new Color(color.getRed(),color.getGreen(),color.getBlue(),0x80);\n  }\n  Shape s=shapeGenerator.createRoundRectangle(x - 2,y - 2,width + 4,height + 4,CornerSize.BORDER);\n  g.setPaint(color);\n  g.fill(s);\n  if (isPaintLineSeperators(c)) {\n    paintLineSeparator(g,c,width,height);\n  }\n}\n", "docstring": "paint the background of an uneditable control , e . g . a jlabel .", "partition": "test"}
{"idx": "3324", "code": "public static void addAttributeDefaultValues(String serviceName,String subSchemaName,String schemaType,String attributeName,Set defaultValues) throws UpgradeException {\n  String classMethod=\"UpgradeUtils:addAttributeDefaultValues : \";\n  if (debug.messageEnabled()) {\n    debug.message(classMethod + \"Updating attribute default values\");\n    debug.message(\"in :\" + serviceName + \"for attribute: \"+ attributeName);\n  }\n  ServiceSchema ss=getServiceSchema(serviceName,subSchemaName,schemaType);\n  try {\n    Map attributeDefaults=ss.getAttributeDefaults();\n    Set oldAttrValues=(Set)attributeDefaults.get(attributeName);\n    Set newAttrValues=((oldAttrValues == null) || oldAttrValues.isEmpty()) ? new HashSet() : new HashSet(oldAttrValues);\n    newAttrValues.addAll(defaultValues);\n    ss.setAttributeDefaults(attributeName,newAttrValues);\n  }\n catch (  SSOException ssoe) {\n    throw new UpgradeException(\"Invalid SSOToken\");\n  }\ncatch (  SMSException sme) {\n    throw new UpgradeException(\"Failed to add attribute default \" + \"values\");\n  }\n}\n", "docstring": "adds default values to an existing attribute . the existing values in the attribute will be updated with new values .", "partition": "test"}
{"idx": "3325", "code": "private String encodeProduct(){\n  StringBuffer tokens=new StringBuffer();\n  ListIterator it=productTokens.listIterator();\n  while (it.hasNext()) {\n    tokens.append((String)it.next());\n  }\n  return tokens.toString();\n}\n", "docstring": "return canonical form . pmusgrave - put a space between products ( preserves format of header )", "partition": "test"}
{"idx": "3326", "code": "public boolean isMetadataModifiedSinceLastPublication(){\n  return metadataModifiedSinceLastPublication;\n}\n", "docstring": "called from manage resource page .", "partition": "test"}
{"idx": "3327", "code": "public Options resourceDirs(List<File> value){\n  resourceDirs.clear();\n  resourceDirs.addAll(value);\n  return this;\n}\n", "docstring": "sets the list of directories where the resources come from . this is to properly pack the paths .", "partition": "test"}
{"idx": "3328", "code": "private final String _decodeShortUnicodeName(int len) throws IOException, JsonParseException {\n  int outPtr=0;\n  char[] outBuf=_textBuffer.emptyAndGetCurrentSegment();\n  int inPtr=_inputPtr;\n  _inputPtr+=len;\n  final int[] codes=SmileConstants.sUtf8UnitLengths;\n  final byte[] inBuf=_inputBuffer;\n  for (int end=inPtr + len; inPtr < end; ) {\n    int i=inBuf[inPtr++] & 0xFF;\n    int code=codes[i];\n    if (code != 0) {\nswitch (code) {\ncase 1:\n        i=((i & 0x1F) << 6) | (inBuf[inPtr++] & 0x3F);\n      break;\ncase 2:\n    i=((i & 0x0F) << 12) | ((inBuf[inPtr++] & 0x3F) << 6) | (inBuf[inPtr++] & 0x3F);\n  break;\ncase 3:\ni=((i & 0x07) << 18) | ((inBuf[inPtr++] & 0x3F) << 12) | ((inBuf[inPtr++] & 0x3F) << 6)| (inBuf[inPtr++] & 0x3F);\ni-=0x10000;\noutBuf[outPtr++]=(char)(0xD800 | (i >> 10));\ni=0xDC00 | (i & 0x3FF);\nbreak;\ndefault :\n_reportError(\"Invalid byte \" + Integer.toHexString(i) + \" in short Unicode text block\");\n}\n}\noutBuf[outPtr++]=(char)i;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn _textBuffer.contentsAsString();\n}\n", "docstring": "helper method used to decode short unicode string , length for which actual length ( in bytes ) is known", "partition": "test"}
{"idx": "3329", "code": "private static ClassNode makeType(ClassNode cn,boolean usingClass){\n  if (usingClass) {\n    ClassNode clazzType=CLASS_Type.getPlainNodeReference();\n    clazzType.setGenericsTypes(new GenericsType[]{new GenericsType(cn)});\n    return clazzType;\n  }\n else {\n    return cn;\n  }\n}\n", "docstring": "wrap type in class & lt ; & gt ; if usingclass = = true", "partition": "test"}
{"idx": "3330", "code": "protected String toMessage(Map<String,String> results){\n  StringBuilder builder=new StringBuilder();\n  if (results != null) {\n    for (    Map.Entry<String,String> entry : results.entrySet()) {\n      builder.append(entry.getKey() + \": \" + entry.getValue()+ \";\\n\");\n    }\n  }\n  return builder.toString();\n}\n", "docstring": "returns a formatted string of the results .", "partition": "test"}
{"idx": "3331", "code": "public TestTree sort(){\n  Collections.sort(suites);\n  suites.forEach(null);\n  return this;\n}\n", "docstring": "sorts the encapsulated test suites by their name in alphabetic order , then returns with the current ( sorted ) instance .", "partition": "test"}
{"idx": "3332", "code": "public static EventBean[] addToArray(EventBean[] array,Collection<EventBean> eventsToAdd){\n  EventBean[] newArray=new EventBean[array.length + eventsToAdd.size()];\n  System.arraycopy(array,0,newArray,0,array.length);\n  int counter=array.length;\n  for (  EventBean eventToAdd : eventsToAdd) {\n    newArray[counter++]=eventToAdd;\n  }\n  return newArray;\n}\n", "docstring": "expand the array passed in by the multiple elements to add .", "partition": "test"}
{"idx": "3333", "code": "public static String replace(String a,String b,String c){\n  StringBuilder result=new StringBuilder(c.length());\n  int i=0;\n  int j=c.indexOf(a);\n  while (j >= i) {\n    result.append(c.substring(i,j));\n    result.append(b);\n    i=j + a.length();\n    j=c.indexOf(a,i);\n  }\n  result.append(c.substring(i,c.length()));\n  return result.toString();\n}\n", "docstring": "replaces a with b in c .", "partition": "test"}
{"idx": "3334", "code": "protected void onPageScrolled(int position,float offset,int offsetPixels){\n  if (mDecorChildCount > 0) {\n    final int scrollY=getScrollY();\n    int paddingTop=getPaddingTop();\n    int paddingBottom=getPaddingBottom();\n    final int height=getHeight();\n    final int childCount=getChildCount();\n    for (int i=0; i < childCount; i++) {\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      if (!lp.isDecor)       continue;\n      final int vgrav=lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;\n      int childTop=0;\nswitch (vgrav) {\ndefault :\n        childTop=paddingTop;\n      break;\ncase Gravity.TOP:\n    childTop=paddingTop;\n  paddingTop+=child.getHeight();\nbreak;\ncase Gravity.CENTER_VERTICAL:\nchildTop=Math.max((height - child.getMeasuredHeight()) / 2,paddingTop);\nbreak;\ncase Gravity.BOTTOM:\nchildTop=height - paddingBottom - child.getMeasuredHeight();\npaddingBottom+=child.getMeasuredHeight();\nbreak;\n}\nchildTop+=scrollY;\nfinal int childOffset=childTop - child.getTop();\nif (childOffset != 0) {\nchild.offsetTopAndBottom(childOffset);\n}\n}\n}\ndispatchOnPageScrolled(position,offset,offsetPixels);\nif (mPageTransformer != null) {\nfinal int scrollY=getScrollY();\nfinal int childCount=getChildCount();\nfor (int i=0; i < childCount; i++) {\nfinal View child=getChildAt(i);\nfinal LayoutParams lp=(LayoutParams)child.getLayoutParams();\nif (lp.isDecor) continue;\nfinal float transformPos=(float)(child.getTop() - scrollY) / getClientHeight();\nmPageTransformer.transformPage(child,transformPos);\n}\n}\nmCalledSuper=true;\n}\n", "docstring": "this method will be invoked when the current page is scrolled , either as part of a programmatically initiated smooth scroll or a user initiated touch scroll . if you override this method you must call through to the superclass implementation ( e . g . super . onpagescrolled ( position , offset , offsetpixels ) ) before onpagescrolled returns .", "partition": "test"}
{"idx": "3335", "code": "private void reflectMemberVariablesInFinalButton(){\n  final boolean lastPageReached=(viewPager.getCurrentItem() + 1) == pages.size();\n  final boolean buttonShouldBeInvisible=!lastPageReached || finalButtonDisabled;\n  final boolean buttonIsCurrentlyInvisible=finalButton.getVisibility() == View.INVISIBLE;\n  final boolean shouldUpdateButton=buttonShouldBeInvisible != buttonIsCurrentlyInvisible;\n  if (shouldUpdateButton) {\n    final Animator buttonAnimator=buttonShouldBeInvisible ? buttonAnimatorFactory.newFinalButtonDisappearAnimator(finalButton) : buttonAnimatorFactory.newFinalButtonAppearAnimator(finalButton);\n    if (buttonShouldBeInvisible) {\n      disableButton(buttonAnimator,finalButton);\n    }\n else {\n      enableButton(buttonAnimator,finalButton);\n    }\n  }\n}\n", "docstring": "enables or disables the final button , so that it matches the current member variables .", "partition": "test"}
{"idx": "3336", "code": "public void testDecoder6(){\n  boolean res;\n  String originalAppIdName=mAppIdName;\n  int originalContentTypeValue=mContentTypeValue;\n  Random rd=new Random();\n  for (int i=0; i < OMA_APPLICATION_ID_NAMES.length; i++) {\n    mAppIdName=OMA_APPLICATION_ID_NAMES[i];\n    mContentTypeValue=rd.nextInt(0x0FFF);\n    byte[] pdu=createPDU(6);\n    WspTypeDecoder pduDecoder=new WspTypeDecoder(pdu);\n    res=pduDecoder.seekXWapApplicationId(mWspHeaderStart,mWspHeaderStart + mWspHeaderLen - 1);\n    assertTrue(res);\n    int index=(int)pduDecoder.getValue32();\n    res=pduDecoder.decodeXWapApplicationId(index);\n    assertTrue(res);\n    Log.d(LOG_TAG,\"mAppIdValue: [\" + mAppIdName + \"], val: [\"+ pduDecoder.getValueString()+ \"]\");\n    assertTrue(mAppIdName.equals(pduDecoder.getValueString()));\n  }\n  mAppIdName=originalAppIdName;\n  mContentTypeValue=originalContentTypeValue;\n}\n", "docstring": "wsptypedecoder test , decode string appid test", "partition": "test"}
{"idx": "3337", "code": "private static boolean isWritable(@NonNull final File file){\n  boolean isExisting=file.exists();\n  try {\n    FileOutputStream output=new FileOutputStream(file,true);\n    try {\n      output.close();\n    }\n catch (    IOException e) {\n    }\n  }\n catch (  java.io.FileNotFoundException e) {\n    return false;\n  }\n  boolean result=file.canWrite();\n  if (!isExisting) {\n    file.delete();\n  }\n  return result;\n}\n", "docstring": "check is a file is writable . detects write issues on external sd card .", "partition": "test"}
{"idx": "3338", "code": "public GmPublishingPriority(){\n}\n", "docstring": "creates a gm : publishing_priority tag .", "partition": "test"}
{"idx": "3339", "code": "private RelyingParty validateRelyingParty(HttpServletRequest request,String tenantName){\n  Validate.notNull(request,\"request\");\n  Validate.notEmpty(tenantName,\"tenantName\");\n  DefaultIdmAccessorFactory idmFactory=new DefaultIdmAccessorFactory();\n  Validate.notNull(idmFactory,\"idmFactory\");\n  IdmAccessor idmAccessor=idmFactory.getIdmAccessor();\n  idmAccessor.setTenant(tenantName);\n  String encodedEntityId=request.getParameter(Shared.RELYINGPARTY_ENTITYID);\n  if (encodedEntityId == null || encodedEntityId.isEmpty()) {\n    logger.error(\"No Relying Party\'s entity ID found. Ignore the request!\");\n    return null;\n  }\n  String rpEntityId=new String(Base64.decode(encodedEntityId));\n  RelyingParty rp=idmAccessor.getRelyingPartyByUrl(rpEntityId);\n  if (rp != null) {\n    return rp;\n  }\n else {\n    logger.error(\"Unknown relying party: \" + rpEntityId);\n    return null;\n  }\n}\n", "docstring": "this method validates the relying party .", "partition": "test"}
{"idx": "3340", "code": "public void rotateZ(double theta){\n  Matrix3D tmp=new Matrix3D();\n  double c=Math.cos(theta);\n  double s=Math.sin(theta);\n  tmp.set(0,0,c);\n  tmp.set(0,1,-s);\n  tmp.set(1,0,s);\n  tmp.set(1,1,c);\n  preMultiply(tmp);\n}\n", "docstring": "rotate transformation about the z axis", "partition": "test"}
{"idx": "3341", "code": "public ServiceHost startFactory(Service instanceService){\n  final Class<? extends Service> serviceClass=instanceService.getClass();\n  return startFactory(serviceClass,null);\n}\n", "docstring": "starts a default factory service for the given instance service . note that this will not start the instance service .", "partition": "test"}
{"idx": "3342", "code": "void wakeOut(){\n  OnAvailable outFlow=_outFlow;\n  if (outFlow == null) {\n    return;\n  }\n  if (_creditsIn <= _queue.head()) {\n    return;\n  }\n  StateOutPipe stateOld;\n  StateOutPipe stateNew;\n  do {\n    stateOld=_stateOutRef.get();\n    if (!stateOld.isFull()) {\n      return;\n    }\n    stateNew=stateOld.toWake();\n  }\n while (!_stateOutRef.compareAndSet(stateOld,stateNew));\n  try (OutboxAmp outbox=OutboxAmp.currentOrCreate(_outRef.services())){\n    Objects.requireNonNull(outbox);\n    PipeWakeOutMessage<T> msg=new PipeWakeOutMessage<>(outbox,_outRef,this,outFlow);\n    outbox.offer(msg);\n  }\n }\n", "docstring": "notify the reader of available space in the pipe . if the writer is asleep , wake it .", "partition": "test"}
{"idx": "3343", "code": "public ConstraintMap createAssignmentConstraints(final AnnotatedTypeMirror assignedTo,final AnnotatedTypeMirror boxedReturnType,final AnnotatedExecutableType methodType,final Set<AFConstraint> afArgumentConstraints,final Map<TypeVariable,AnnotatedTypeMirror> inferredArgs,final Set<TypeVariable> targets,final AnnotatedTypeFactory typeFactory){\n  final LinkedList<AFConstraint> assignmentAfs=new LinkedList<>();\n  for (  AnnotatedTypeVariable typeParam : methodType.getTypeVariables()) {\n    final TypeVariable target=typeParam.getUnderlyingType();\n    final AnnotatedTypeMirror inferredType=inferredArgs.get(target);\n    if (inferredType != null) {\n      assignmentAfs.add(new A2F(inferredType,typeParam.getUpperBound()));\n      assignmentAfs.add(new F2A(typeParam.getLowerBound(),inferredType));\n    }\n else {\n      assignmentAfs.add(new F2A(typeParam,typeParam.getUpperBound()));\n      assignmentAfs.add(new A2F(typeParam.getLowerBound(),typeParam));\n    }\n  }\n  for (  AFConstraint argConstraint : afArgumentConstraints) {\n    if (argConstraint instanceof F2A) {\n      assignmentAfs.add(argConstraint);\n    }\n  }\n  LinkedList<AFConstraint> substitutedAssignmentConstraints=new LinkedList<>();\n  for (  AFConstraint afConstraint : assignmentAfs) {\n    substitutedAssignmentConstraints.add(afConstraint.substitute(inferredArgs));\n  }\n  final AnnotatedTypeMirror substitutedReturnType=TypeArgInferenceUtil.substitute(inferredArgs,boxedReturnType);\n  substitutedAssignmentConstraints.add(new F2A(substitutedReturnType,assignedTo));\n  final Set<AFConstraint> reducedConstraints=new LinkedHashSet<>();\n  reduceAfConstraints(typeFactory,reducedConstraints,substitutedAssignmentConstraints,targets);\n  final Set<TUConstraint> tuAssignmentConstraints=afToTuConstraints(reducedConstraints,targets);\n  addConstraintsBetweenTargets(tuAssignmentConstraints,targets,true,typeFactory);\n  return constraintMapBuilder.build(targets,tuAssignmentConstraints,typeFactory);\n}\n", "docstring": "the first half of step 6 . this method creates constraints : a ) between the bounds of types that are already inferred and their inferred arguments b ) between the assignment context and the return type of the method ( with the previously inferred arguments substituted into these constraints )", "partition": "test"}
{"idx": "3344", "code": "public static int columnsNumber(char c,int x,int prevX,int plainSpaceSize){\n  if (c != '\\t') {\n    return 1;\n  }\n  int result=(x - prevX) / plainSpaceSize;\n  if ((x - prevX) % plainSpaceSize > 0) {\n    result++;\n  }\n  return result;\n}\n", "docstring": "allows to answer how many columns are necessary for representation of the given char on a screen .", "partition": "test"}
{"idx": "3345", "code": "public KafkaMessageListenerContainer(ConsumerFactory<K,V> consumerFactory,ContainerProperties containerProperties,TopicPartitionInitialOffset... topicPartitions){\n  super(containerProperties);\n  Assert.notNull(consumerFactory,\"A ConsumerFactory must be provided\");\n  this.consumerFactory=consumerFactory;\n  if (topicPartitions != null) {\n    this.topicPartitions=Arrays.copyOf(topicPartitions,topicPartitions.length);\n  }\n else {\n    this.topicPartitions=containerProperties.getTopicPartitions();\n  }\n}\n", "docstring": "construct an instance with the supplied configuration properties and specific topics / partitions / initialoffsets .", "partition": "test"}
{"idx": "3346", "code": "private String toString(Matcher m,int group){\n  return (group == 0) ? \"\" : m.group(group);\n}\n", "docstring": "captures the group passed in by matching against a pattern .", "partition": "test"}
{"idx": "3347", "code": "public PlaLineInt translate_by(PlaVectorInt p_vector){\n  if (p_vector.equals(PlaVectorInt.ZERO))   return this;\n  PlaPointInt new_a=point_a.translate_by(p_vector);\n  PlaPointInt new_b=point_b.translate_by(p_vector);\n  return new PlaLineInt(new_a,new_b);\n}\n", "docstring": "translates the line by p_vector", "partition": "test"}
{"idx": "3348", "code": "@SuppressWarnings(\"all\") final void reject(Runnable command){\n  handler.rejectedExecution(command,this);\n}\n", "docstring": "invokes the rejected execution handler for the given command . package - protected for use by scheduledthreadpoolexecutor .", "partition": "test"}
{"idx": "3349", "code": "private int calculateMenuMargin(){\n  WindowManager wm=(WindowManager)getSystemService(Context.WINDOW_SERVICE);\n  Display display=wm.getDefaultDisplay();\n  Point size=new Point();\n  display.getSize(size);\n  int height=size.y;\n  return (int)Math.round(height * MENU_MARGIN_RELATIVE_MODIFIER);\n}\n", "docstring": "method that calculates space left for edittext when format text panel is visible", "partition": "test"}
{"idx": "3350", "code": "public void addRam(AttackAction ea){\n  pendingRams.addElement(ea);\n  processGameEvent(new GameNewActionEvent(this,ea));\n}\n", "docstring": "adds a pending ramming attack to the list for this phase .", "partition": "test"}
{"idx": "3351", "code": "public void testConfigFileProperty() throws Exception {\n  File configHome=new File(configuration.getHome());\n  assertTrue(\"Could not find a proper configuration home.\",configHome.exists() && configHome.isDirectory());\n  File existingFile=createFile(configHome,\"existingfile\",\"helloworld\");\n  assertEquals(\"helloworld\",readFile(existingFile));\n  String fileName=\"testConfigfile\";\n  String fileContents=\"Hello @message@ \";\n  File file=createFile(configFileDirectory,fileName,fileContents);\n  FileConfig configFile=new FileConfig();\n  configFile.setFile(getAbsolutePath(file));\n  configFile.setToFile(\"existingfile\");\n  configFile.setOverwrite(false);\n  configFile.setConfigfile(false);\n  configuration.setProperty(\"message\",\"world\");\n  configuration.setConfigFileProperty(configFile);\n  configuration.doConfigure(null);\n  File copiedFile=new File(configuration.getHome() + \"/existingfile\");\n  assertTrue(\"Cannot find the expected copied file\",copiedFile.exists());\n  assertEquals(\"Hello world \",readFile(copiedFile));\n}\n", "docstring": "test configuration file property .", "partition": "test"}
{"idx": "3352", "code": "protected byte[] generateSalt(){\n  return HEADER.getBytes(Constants.UTF8);\n}\n", "docstring": "generate the random salt bytes if required .", "partition": "test"}
{"idx": "3353", "code": "public void addListener(final ProjectorListener projectorListener){\n  if (listeners == null) {\n    listeners=new ArrayList<ProjectorListener>();\n  }\n  listeners.add(projectorListener);\n}\n", "docstring": "add a projector listener .", "partition": "test"}
{"idx": "3354", "code": "protected TupleExpr selectNextTupleExpr(List<TupleExpr> expressions,Map<TupleExpr,Double> cardinalityMap,Map<TupleExpr,List<Var>> varsMap,Map<Var,Integer> varFreqMap,Set<String> boundVars){\n  TupleExpr result=null;\n  if (expressions.size() > 1) {\n    double lowestCardinality=Double.POSITIVE_INFINITY;\n    for (    TupleExpr tupleExpr : expressions) {\n      double cardinality=getTupleExprCardinality(tupleExpr,cardinalityMap,varsMap,varFreqMap,boundVars);\n      if (cardinality < lowestCardinality || result == null) {\n        lowestCardinality=cardinality;\n        result=tupleExpr;\n      }\n    }\n  }\n else {\n    result=expressions.get(0);\n  }\n  return result;\n}\n", "docstring": "selects from a list of tuple expressions the next tuple expression that should be evaluated . this method selects the tuple expression with highest number of bound variables , preferring variables that have been bound in other tuple expressions over variables with a fixed value .", "partition": "test"}
{"idx": "3355", "code": "public static void writeBcdNumber(OutputStream os,String number) throws IOException {\n  int bcd=0x00;\n  int n=0;\n  for (int i=0; i < number.length(); i++) {\nswitch (number.charAt(i)) {\ncase '0':\n      bcd|=0x00;\n    break;\ncase '1':\n  bcd|=0x10;\nbreak;\ncase '2':\nbcd|=0x20;\nbreak;\ncase '3':\nbcd|=0x30;\nbreak;\ncase '4':\nbcd|=0x40;\nbreak;\ncase '5':\nbcd|=0x50;\nbreak;\ncase '6':\nbcd|=0x60;\nbreak;\ncase '7':\nbcd|=0x70;\nbreak;\ncase '8':\nbcd|=0x80;\nbreak;\ncase '9':\nbcd|=0x90;\nbreak;\ncase '*':\nbcd|=0xA0;\nbreak;\ncase '#':\nbcd|=0xB0;\nbreak;\ncase 'a':\nbcd|=0xC0;\nbreak;\ncase 'b':\nbcd|=0xE0;\nbreak;\n}\nn++;\nif (n == 2) {\nos.write(bcd);\nn=0;\nbcd=0x00;\n}\n else {\nbcd>>=4;\n}\n}\nif (n == 1) {\nbcd|=0xF0;\nos.write(bcd);\n}\n}\n", "docstring": "writes the given phonenumber to the stream ( bcd coded )", "partition": "test"}
{"idx": "3356", "code": "public void addMessage(String message){\n  messages.addLast(message);\n  if (messages.size() > MAX_HISTORY) {\n    messages.removeFirst();\n  }\n  pointer=messages.size();\n}\n", "docstring": "add a message to the history", "partition": "test"}
{"idx": "3357", "code": "@VisibleForTesting protected void startExecutor(final int container){\n  LOG.info(\"Starting a new executor for container: \" + container);\n  final Process containerExecutor=startExecutorProcess(container);\n  processToContainer.put(containerExecutor,container);\n  LOG.info(\"Started the executor for container: \" + container);\n  startExecutorMonitor(container,containerExecutor);\n}\n", "docstring": "start the executor for the given container", "partition": "test"}
{"idx": "3358", "code": "public static Date stringToDate(String s,DateFormat formatter){\n  try {\n    return formatter.parse(s);\n  }\n catch (  ParseException e) {\n    return null;\n  }\n}\n", "docstring": "convert a date time string ( e . g . , \" 2011 - 06 - 07 19 : 12 : 18 \" ) to a date object .", "partition": "test"}
{"idx": "3359", "code": "public void accept(AbstractReporter r){\n  r.testStart(this);\n  r.browserInfoEntry(browserInfoEntry);\n  Iterator<LogEntry> entryIterator=logEntries.iterator();\n  while (entryIterator.hasNext()) {\n    LogEntry entry=entryIterator.next();\n    if (!entryIterator.hasNext()) {\n      entry.setLast(true);\n    }\n    visit(entry,r);\n  }\n  r.testEnd(this);\n}\n", "docstring": "implementation of visitor pattern . takes the report for a guided tour through all information stored in the testinfo instance , from start of the test to all entries to test end . it is up to a particular implementation of the reporter to react to different types of test info and log entries . < br > also , detects the last log entry on the fly .", "partition": "test"}
{"idx": "3360", "code": "private void loadLatestExtensionVersions(){\n  try {\n    List<Extension> all=registryManager.getExtensions();\n    if (!all.isEmpty()) {\n      setLatestExtensionVersions(getLatestVersions(all));\n    }\n  }\n catch (  RegistryException e) {\n    String msg=RegistryException.logRegistryException(e.getType(),this);\n    warnings.addStartupError(msg);\n    LOG.error(msg);\n    msg=getText(\"admin.extensions.couldnt.load\",new String[]{cfg.getRegistryUrl()});\n    warnings.addStartupError(msg);\n    LOG.error(msg);\n  }\n finally {\n    if (getLatestExtensionVersions() == null) {\n      setLatestExtensionVersions(new ArrayList<Extension>());\n    }\n  }\n}\n", "docstring": "reload the list of registered extensions , loading only the latest extension versions .", "partition": "test"}
{"idx": "3361", "code": "public int read() throws IOException {\n  int val;\n  if ((val=is.read()) < 0) {\n    return -1;\n  }\n  if (bo == 'b') {\n    val=(char)((val << 8) | (is.read() & 0xff));\n  }\n else {\n    val=(char)((is.read() << 8) | (val & 0xff));\n  }\n  return val;\n}\n", "docstring": "reads a single character .", "partition": "test"}
{"idx": "3362", "code": "public void cancelAutoCompletion(){\n  if (inCompletion) {\n    textField.setText(textBefore);\n    textField.setCaretPosition(caretPosBefore);\n    prevCompletion=null;\n    prevCompletionIndex=0;\n    inCompletion=false;\n  }\n}\n", "docstring": "cancels the current completion , which means the state of the text is returned to what it was before completion and the info popup is closed if necessary .", "partition": "test"}
{"idx": "3363", "code": "public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.add(new Option(\"\\tSkip identical instances (distances equal to zero).\\n\",\"S\",1,\"-S\"));\n  result.addAll(Collections.list(super.listOptions()));\n  return result.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "3364", "code": "public ClientPropertiesBuilder withProxyHostName(String proxyHostName){\n  properties.setProperty(CLIENT_SERVICE_PROXY_HOST_NAME,proxyHostName);\n  return this;\n}\n", "docstring": "if a proxy is used to access the odata web service this specifies it \"'\" s host name / ip address .", "partition": "test"}
{"idx": "3365", "code": "public static void verifySetterMethods(Class<?> clazz,MappedField... fields){\n  String methodName=null;\n  String fieldName=null;\n  Class<?> fieldType=null;\n  try {\n    for (    MappedField field : fields) {\n      fieldName=field.getName();\n      fieldType=field.getType();\n      String customSet=field.setMethod();\n      if (!isNull(customSet) && !customSet.equals(Constants.DEFAULT_ACCESSOR_VALUE))       try {\n        clazz.getMethod(customSet,fieldType);\n        field.setMethod(customSet);\n        continue;\n      }\n catch (      Exception e) {\n        Error.customMethod(\"set\",customSet,clazz);\n      }\n      methodName=mSet(fieldName);\n      clazz.getMethod(methodName,fieldType);\n      field.setMethod(methodName);\n    }\n  }\n catch (  Exception e) {\n    Error.method(methodName,fieldName,clazz);\n  }\n}\n", "docstring": "verifies that the setter methods are compliant with the naming convention .", "partition": "test"}
{"idx": "3366", "code": "static public String randomPositiveFloat(int whole,int decimal){\n  StringBuilder output=new StringBuilder();\n  output.append(rnd.nextInt(8) + 1);\n  for (int i=0; i < whole - 1; i++) {\n    output.append(rnd.nextInt(9));\n  }\n  output.append(\".\");\n  for (int i=0; i < decimal; i++) {\n    output.append(rnd.nextInt(9));\n  }\n  return output.toString();\n}\n", "docstring": "get a random , positive float", "partition": "test"}
{"idx": "3367", "code": "public static Variation attemptToGetAsVariant(String part){\n  try {\n    StoneTypes var=StoneTypes.valueOf(part.toUpperCase());\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    WoodTypes var=WoodTypes.valueOf(part.toUpperCase());\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    FlowerTypes var=FlowerTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    EntityTypes var=EntityTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    MonsterEggTypes var=MonsterEggTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    ShapeTypes var=ShapeTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  try {\n    HalfTypes var=HalfTypes.fromValue(part);\n    if (var != null) {\n      Variation bv=new Variation();\n      bv.setValue(var.value());\n      return bv;\n    }\n  }\n catch (  Exception e) {\n  }\n  return null;\n}\n", "docstring": "attempt to parse string as a variation", "partition": "test"}
{"idx": "3368", "code": "public void resetTextBoxIndexesExcept(Set<Integer> excludedList){\n  Set<Integer> unusedTextBoxIndexes=new HashSet<Integer>(points.getTextBoxIndexes());\n  unusedTextBoxIndexes.removeAll(excludedList);\n  for (  Integer index : unusedTextBoxIndexes) {\n    points.removeTextBox(index);\n  }\n}\n", "docstring": "resets all textbox indexes except those which are contained in the excludedlist", "partition": "test"}
{"idx": "3369", "code": "public IDevice learnEntity(long macAddress,Short vlan,Integer ipv4Address,Long switchDPID,Integer switchPort,boolean processUpdates){\n  List<IDeviceListener> listeners=deviceListeners.getOrderedListeners();\n  if (!processUpdates) {\n    deviceListeners.clearListeners();\n  }\n  if (vlan != null && vlan.shortValue() <= 0)   vlan=null;\n  if (ipv4Address != null && ipv4Address == 0)   ipv4Address=null;\n  IDevice res=learnDeviceByEntity(new Entity(macAddress,vlan,ipv4Address,switchDPID,switchPort,new Date()));\n  if (listeners != null) {\n    for (    IDeviceListener listener : listeners) {\n      deviceListeners.addListener(\"device\",listener);\n    }\n  }\n  return res;\n}\n", "docstring": "learn a device using the given characteristics .", "partition": "test"}
{"idx": "3370", "code": "public double[] levelZeroData(){\n  List<Buffer> levelZeroBuffers=bufferMap.get(0);\n  int length=0;\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      length+=buffer.size;\n    }\n else {\n      length+=buffer.next;\n    }\n  }\n  int pos=0;\n  int currLen;\n  final double[] out=new double[length];\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      currLen=buffer.size;\n    }\n else {\n      currLen=buffer.next;\n    }\n    System.arraycopy(buffer.data,0,out,pos,currLen);\n    pos+=currLen;\n  }\n  return out;\n}\n", "docstring": "returns a fresh copy of all data from level 0 buffers .", "partition": "test"}
{"idx": "3371", "code": "public String[] showVersion() throws NetworkDeviceControllerException {\n  String[] returnVal=new String[2];\n  SSHPrompt[] prompts={SSHPrompt.MDS_POUND,SSHPrompt.MDS_GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  SSHPrompt prompt=sendWaitFor(MDSDialogProperties.getString(\"MDSDialog.showVersion.cmd\"),10000,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showVersion.version.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.MDS.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.Nexus.match\")};\n  String[] groups=new String[2];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      returnVal[1]=groups[0];\n    break;\ncase 1:\n  returnVal[0]=groups[0];\nbreak;\ncase 2:\nreturnVal[0]=groups[0];\nbreak;\n}\n}\nreturn returnVal;\n}\n", "docstring": "returns the device type and software version", "partition": "test"}
{"idx": "3372", "code": "public static int countMatches(String string,char c){\n  int n=0;\n  for (  char tc : string.toCharArray()) {\n    if (c == tc)     n++;\n  }\n  return n;\n}\n", "docstring": "counts the amount of times a certain character is part of a string", "partition": "test"}
{"idx": "3373", "code": "private ImageIcon addColor(ImageIcon icon,Color color){\n  if (icon == null || color == null) {\n    return icon;\n  }\n  BufferedImage newImage=new BufferedImage(icon.getIconWidth(),icon.getIconWidth(),BufferedImage.TYPE_INT_ARGB);\n  Graphics g=newImage.getGraphics();\n  g.setColor(color);\n  g.drawImage(icon.getImage(),0,0,color,null);\n  g.dispose();\n  return new ImageIcon(newImage);\n}\n", "docstring": "adds a background color to the given icon , if an icon and color is actually given , otherwise the original icon is returned .", "partition": "test"}
{"idx": "3374", "code": "public static byte[] readAllLimited(InputStream inStr,int limit) throws IOException {\n  ByteArrayOutputStream buf=new ByteArrayOutputStream();\n  pipeAllLimited(inStr,limit,buf);\n  return buf.toByteArray();\n}\n", "docstring": "read from instr up to a maximum number of bytes , throwing an exception if more the maximum amount of requested data is available .", "partition": "test"}
{"idx": "3375", "code": "protected String searchFor(final String target,String start){\n  return searchFor(target,null,start);\n}\n", "docstring": "searches for the given target directory starting in the \" plugins \" subdirectory of the given location . if one is found then this location is returned ; otherwise an exception is thrown .", "partition": "test"}
{"idx": "3376", "code": "private int validatePreloadOrder(CacheConfiguration[] cfgs) throws IgniteCheckedException {\n  int maxOrder=0;\n  for (  CacheConfiguration cfg : cfgs) {\n    int rebalanceOrder=cfg.getRebalanceOrder();\n    if (rebalanceOrder > 0) {\n      if (cfg.getCacheMode() == LOCAL)       throw new IgniteCheckedException(\"Rebalance order set for local cache (fix configuration and restart the \" + \"node): \" + U.maskName(cfg.getName()));\n      if (cfg.getRebalanceMode() == CacheRebalanceMode.NONE)       throw new IgniteCheckedException(\"Only caches with SYNC or ASYNC rebalance mode can be set as rebalance \" + \"dependency for other caches [cacheName=\" + U.maskName(cfg.getName()) + \", rebalanceMode=\"+ cfg.getRebalanceMode()+ \", rebalanceOrder=\"+ cfg.getRebalanceOrder()+ \']\');\n      maxOrder=Math.max(maxOrder,rebalanceOrder);\n    }\n else     if (rebalanceOrder < 0)     throw new IgniteCheckedException(\"Rebalance order cannot be negative for cache (fix configuration and restart \" + \"the node) [cacheName=\" + U.maskName(cfg.getName()) + \", rebalanceOrder=\"+ rebalanceOrder+ \']\');\n  }\n  return maxOrder;\n}\n", "docstring": "checks that preload - order - dependant caches has sync or async preloading mode .", "partition": "test"}
{"idx": "3377", "code": "public void execute(){\n  mPlayer.setLoopMode(mDoLoop);\n  mThread=new Thread(this,\"Movie Player\");\n  mThread.start();\n}\n", "docstring": "creates a new thread , and starts execution of the player .", "partition": "test"}
{"idx": "3378", "code": "@Override public void removeEnvVar(EnvVar envVar){\n  if (envVar != null) {\n    envVarList.remove(envVar);\n  }\n}\n", "docstring": "removes the environment variable .", "partition": "test"}
{"idx": "3379", "code": "static private String calcThreshold(double scoreThreshold,double lambda){\n  final double logProbThreshold=Math.log(1 - scoreThreshold / 0.999);\n  int maxNum=1000000;\n  if (calcLogProb(maxNum,lambda) > logProbThreshold) {\n    return \">1e6\";\n  }\n  int minNum=1;\n  while (minNum < maxNum) {\n    final int midNum=(maxNum + minNum) / 2;\n    final boolean passThreshold=calcLogProb(midNum,lambda) <= logProbThreshold;\n    if (passThreshold) {\n      maxNum=midNum;\n    }\n else {\n      if (midNum == minNum) {\n        break;\n      }\n      minNum=midNum;\n    }\n  }\n  return Integer.toString(maxNum);\n}\n", "docstring": "calculates the minimal number of instances required to achieve a score as high as the given scorethreshold for the given lambda .", "partition": "test"}
{"idx": "3380", "code": "public static int indexOfLastSeparator(String filename){\n  if (filename == null)   return -1;\n  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos,lastWindowsPos);\n}\n", "docstring": "returns the index of the last directory separator character . < p > this method will handle a file in either unix or windows format . the position of the last forward or backslash is returned . < p > the output will be the same irrespective of the machine that the code is running on .", "partition": "test"}
{"idx": "3381", "code": "@Category(FlakyTest.class) @Test public void test_FPAmetadataFetch(){\n  final Host host=Host.getHost(0);\n  VM server1=host.getVM(0);\n  VM server2=host.getVM(1);\n  VM server3=host.getVM(2);\n  VM server4=host.getVM(3);\n  Boolean simpleFPR=false;\n  final int portLocator=AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n  final String hostLocator=NetworkUtils.getServerHostName(server1.getHost());\n  final String locator=hostLocator + \"[\" + portLocator+ \"]\";\n  server3.invoke(null);\n  try {\n    List<FixedPartitionAttributes> fpaList=new ArrayList<FixedPartitionAttributes>();\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q1\",true,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q2\",false,3));\n    Integer port1=(Integer)server1.invoke(null);\n    fpaList.clear();\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q3\",true,3));\n    Integer port2=(Integer)server2.invoke(null);\n    fpaList.clear();\n    createClientWithLocator(hostLocator,portLocator);\n    putIntoPartitionedRegionsThreeQs();\n    getFromPartitionedRegionsFor3Qs();\n    Wait.pause(2000);\n    server1.invoke(null);\n    server2.invoke(null);\n    int totalBucketOnServer=0;\n    totalBucketOnServer+=(Integer)server1.invoke(null);\n    totalBucketOnServer+=(Integer)server2.invoke(null);\n    int currentRedundancy=1;\n    verifyMetadata(totalBucketOnServer,currentRedundancy);\n    updateIntoSinglePRFor3Qs();\n    fpaList.clear();\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q4\",true,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q2\",true,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q1\",false,3));\n    fpaList.add(FixedPartitionAttributes.createFixedPartition(\"Q3\",false,3));\n    Integer port4=(Integer)server4.invoke(null);\n    Wait.pause(2000);\n    putIntoPartitionedRegions();\n    getFromPartitionedRegions();\n    Wait.pause(2000);\n    server1.invoke(null);\n    server2.invoke(null);\n    server4.invoke(null);\n    totalBucketOnServer=0;\n    totalBucketOnServer+=(Integer)server1.invoke(null);\n    totalBucketOnServer+=(Integer)server2.invoke(null);\n    totalBucketOnServer+=(Integer)server4.invoke(null);\n    updateIntoSinglePR();\n  }\n  finally {\n    server3.invoke(null);\n  }\n}\n", "docstring": "this test will check to see if all the partitionattributes are sent to the client . in case one partition comes late , we should fetch that when there is a network hop because of that partitioned region . this test will create 3 servers with partition . do some operations on them . validate that the metadata are fetched and then later up one more partition and do some operations on them . it should fetch new fpa .", "partition": "test"}
{"idx": "3382", "code": "private static Type[] unrollBounds(final Map<TypeVariable<?>,Type> typeArguments,final Type[] bounds){\n  Type[] result=bounds;\n  int i=0;\n  for (; i < result.length; i++) {\n    final Type unrolled=unrollVariables(typeArguments,result[i]);\n    if (unrolled == null) {\n      result=ArrayUtils.remove(result,i--);\n    }\n else {\n      result[i]=unrolled;\n    }\n  }\n  return result;\n}\n", "docstring": "local helper method to unroll variables in a type bounds array .", "partition": "test"}
{"idx": "3383", "code": "public void deleteQuota(String id) throws IsilonException {\n  delete(_baseUrl.resolve(URI_QUOTAS),id,\"quota\");\n}\n", "docstring": "delete a smart quota", "partition": "test"}
{"idx": "3384", "code": "public static Map<String,String> createBasicAuthHeader(String username,String password,Map<String,String> headerMap){\n  if (headerMap == null)   headerMap=new HashMap<>();\n  String credentials=username + \":\" + password;\n  String base64EncodedCredentials=Base64.encodeToString(credentials.getBytes(),Base64.NO_WRAP);\n  headerMap.put(\"Authorization\",\"Basic \" + base64EncodedCredentials);\n  return headerMap;\n}\n", "docstring": "method to create a basic http base64 encrypted authentication header", "partition": "test"}
{"idx": "3385", "code": "private void addExtentEntry(){\n  extentModel.addNewEntry();\n  removeExtentButton.setEnabled(false);\n}\n", "docstring": "adds a new extent entry .", "partition": "test"}
{"idx": "3386", "code": "private TransportNetwork checkCached(String networkId){\n  try {\n    String filename=networkId + \"_\" + R5Version.version+ \".dat\";\n    File cacheLocation=new File(cacheDir,networkId + \"_\" + R5Version.version+ \".dat\");\n    if (cacheLocation.exists())     LOG.info(\"Found locally-cached TransportNetwork at {}\",cacheLocation);\n else {\n      LOG.info(\"No locally cached transport network at {}.\",cacheLocation);\n      if (sourceBucket != null) {\n        LOG.info(\"Checking for cached transport network on S3.\");\n        S3Object tn;\n        try {\n          tn=s3.getObject(sourceBucket,filename);\n        }\n catch (        AmazonServiceException ex) {\n          LOG.info(\"No cached transport network was found in S3. It will be built from scratch.\");\n          return null;\n        }\n        cacheDir.mkdirs();\n        LOG.info(\"Copying pre-built transport network from S3 to local file {}\",cacheLocation);\n        FileOutputStream fos=new FileOutputStream(cacheLocation);\n        InputStream is=tn.getObjectContent();\n        try {\n          ByteStreams.copy(is,fos);\n        }\n  finally {\n          is.close();\n          fos.close();\n        }\n      }\n else {\n        LOG.info(\"Transport network was not found\");\n        return null;\n      }\n    }\n    LOG.info(\"Loading cached transport network at {}\",cacheLocation);\n    FileInputStream fis=new FileInputStream(cacheLocation);\n    try {\n      return TransportNetwork.read(fis);\n    }\n  finally {\n      fis.close();\n    }\n  }\n catch (  Exception e) {\n    LOG.error(\"Exception occurred retrieving cached transport network\",e);\n    return null;\n  }\n}\n", "docstring": "if this transport network is already built and cached , fetch it quick", "partition": "test"}
{"idx": "3387", "code": "void readFile(File file) throws org.jdom2.JDOMException, java.io.IOException {\n  XmlFile xf=new XmlFile(){\n  }\n;\n  xf.rootFromFile(file);\n}\n", "docstring": "ask sax to read and verify a file", "partition": "test"}
{"idx": "3388", "code": "public boolean isAllGranted(){\n  int count=0;\n  for (int i=0; i < mPerms.size(); i++) {\n    if (mPerms.get(mUserPermission.get(i)) == PackageManager.PERMISSION_GRANTED)     count++;\n  }\n  return count == mPerms.size();\n}\n", "docstring": "is all granted boolean .", "partition": "test"}
{"idx": "3389", "code": "protected void execute(Runnable evt){\n  executor.execute(evt);\n}\n", "docstring": "fires a event on the executor thread", "partition": "test"}
{"idx": "3390", "code": "private void sendNextMessageOverNetwork() throws Exception {\n  RawData raw=outgoing.take();\n  if (raw == null)   throw new NullPointerException();\n  sendNext(raw);\n}\n", "docstring": "get the next message from the outgoing queue and send it over the network .", "partition": "test"}
{"idx": "3391", "code": "public void addAttributeFor(final Field field){\n  fieldToUseAsAttribute.add(field);\n}\n", "docstring": "tells this mapper to use an attribute for this field .", "partition": "test"}
{"idx": "3392", "code": "public boolean isSessionToken(String token){\nsynchronized (sessionTokens) {\n    return sessionTokens.contains(token);\n  }\n}\n", "docstring": "checks if is session token .", "partition": "test"}
{"idx": "3393", "code": "public static double rootMeansSquaredError(double[] real,double[] predicted){\n  double ret=0.0;\n  for (int i=0; i < real.length; i++) {\n    ret+=Math.pow((real[i] - predicted[i]),2);\n  }\n  return Math.sqrt(ret / real.length);\n}\n", "docstring": "this returns the root mean squared error of two data sets", "partition": "test"}
{"idx": "3394", "code": "public void export(ByteBuffer buf){\n  buf.putInt(seqId);\n  if (info.isRowBlockEnabled())   buf.putInt(nRows);\n  export(primaryKey,buf);\n  for (  ByteArray cb : cellBlocks) {\n    export(cb,buf);\n  }\n}\n", "docstring": "write data to given buffer , like serialize", "partition": "test"}
{"idx": "3395", "code": "private HashMap<String,Object> createAccDetailmap(String glcode,BigDecimal debitAmount,BigDecimal creditAmount){\n  HashMap<String,Object> accountdetailmap=new HashMap<String,Object>();\n  accountdetailmap.put(VoucherConstant.GLCODE,glcode);\n  accountdetailmap.put(VoucherConstant.DEBITAMOUNT,debitAmount);\n  accountdetailmap.put(VoucherConstant.CREDITAMOUNT,creditAmount);\n  accountdetailmap.put(VoucherConstant.FUNCTIONCODE,getFunctionaryCode());\n  return accountdetailmap;\n}\n", "docstring": "creates account details map", "partition": "test"}
{"idx": "3396", "code": "private void updateRadioLinks(){\n  m_advanceDataSetFirst.setEnabled(m_GeneratorPropertyPanel.getEditorActive());\n  m_advanceIteratorFirst.setEnabled(m_GeneratorPropertyPanel.getEditorActive());\n  if (m_Exp != null) {\n    if (!m_GeneratorPropertyPanel.getEditorActive()) {\n      m_Exp.setAdvanceDataSetFirst(true);\n    }\n else {\n      m_Exp.setAdvanceDataSetFirst(m_advanceDataSetFirst.isSelected());\n    }\n  }\n}\n", "docstring": "updates the primary loop iteration control of the experiment", "partition": "test"}
{"idx": "3397", "code": "public static byte[] select(String appId,String suffix){\n  String cardletAid=FIDESMO_AID_PREFIX + appId + suffix;\n  return select(cardletAid);\n}\n", "docstring": "builds the select command apdu from a cardlet \"'\" s app id : - builds the cardlet \"'\" s aid appending the fidesmo prefix and a suffix - builds the command concatenating the header , aid lenght and aid", "partition": "test"}
{"idx": "3398", "code": "public List<Properties> findAvailableProperties(String uri) throws IOException {\n  _resourcesNotLoaded.clear();\n  String fulluri=_path + uri;\n  List<Properties> properties=new ArrayList<>();\n  Enumeration<URL> resources=getResources(fulluri);\n  while (resources.hasMoreElements()) {\n    URL url=resources.nextElement();\n    try {\n      Properties props=loadProperties(url);\n      properties.add(props);\n    }\n catch (    Exception notAvailable) {\n      _resourcesNotLoaded.add(url.toExternalForm());\n    }\n  }\n  return properties;\n}\n", "docstring": "finds the corresponding resources and reads them in as a properties files < p / > any url that cannot be read in as a properties file will be added to the \"'\" resourcesnotloaded \"'\" collection . < p / > example classpath : < p / > meta - inf / app . properties meta - inf / app . properties meta - inf / app . properties < p / > resourcefinder finder = new resourcefinder ( \" meta - inf / \" ) ; list < properties > appprops = finder . findavailableproperties ( \" app . properties \" ) ;", "partition": "test"}
{"idx": "3399", "code": "void internalAddRootEntry(ProjectComparisonEntry entry){\n  entries.add(entry);\n}\n", "docstring": "should only be invoked from projectcomparisonentry", "partition": "test"}
{"idx": "3400", "code": "public static Source fromURL(URL url,Charset cs) throws IOException {\n  URI uri;\n  try {\n    uri=url.toURI();\n  }\n catch (  URISyntaxException e) {\n    throw new IOException(\"Illegal URI\",e);\n  }\n  try (InputStream is=url.openStream()){\n    return fromStream(is,uri,cs);\n  }\n }\n", "docstring": "creates a new source object from a url", "partition": "test"}
{"idx": "3401", "code": "public void testMergeOneServletIntoDocumentWithAnotherServlet() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <servlet>\" + \"    <servlet-name>s1</servlet-name>\"+ \"    <servlet-class>sclass1</servlet-class>\"+ \"  </servlet>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  String mergeXml=\"<web-app>\" + \"  <servlet>\" + \"    <servlet-name>s2</servlet-name>\"+ \"    <servlet-class>sclass2</servlet-class>\"+ \"  </servlet>\"+ \"</web-app>\";\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(mergeXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.merge(mergeWebXml);\n  assertTrue(WebXmlUtils.hasServlet(srcWebXml,\"s1\"));\n  assertTrue(WebXmlUtils.hasServlet(srcWebXml,\"s2\"));\n}\n", "docstring": "tests whether a single servlet is correctly merged into a descriptor that already contains the definition of an other servlet .", "partition": "test"}
{"idx": "3402", "code": "public RE extractRE() throws InterruptedException {\n  arden();\n  if (!coeffs.isEmpty()) {\n    throw new RuntimeException(\"production still has free variables\");\n  }\n  return unionREs(terms);\n}\n", "docstring": "extract the regular expression associated with this recursive production . fails if there are references to other productions in coeffs .", "partition": "test"}
{"idx": "3403", "code": "public void addResult(AMIdentity id,Map attrs){\n  searchResults.add(id);\n  resultsMap.put(id,attrs);\n}\n", "docstring": "adds an amidentity object to this search result .", "partition": "test"}
{"idx": "3404", "code": "public <T extends IntentionAction & LocalQuickFix>void registerBatchFix(@NotNull T fix,@Nullable TextRange range,@Nullable final HighlightDisplayKey key){\n  if (range == null) {\n    range=new TextRange(myStartOffset,myEndOffset);\n  }\n  if (myBatchFixes == null) {\n    myBatchFixes=new ArrayList<QuickFixInfo>();\n  }\n  myBatchFixes.add(new QuickFixInfo(fix,range,key));\n}\n", "docstring": "registers a quickfix which would be available during batch mode only , in particular during com . intellij . codeinspection . defaulthighlightvisitorbasedinspection run", "partition": "test"}
{"idx": "3405", "code": "protected void createFile(ZipEntry entry){\n  IPath pathname=new Path(entry.getName());\n  ZipEntry parent;\n  if (pathname.segmentCount() == 1) {\n    parent=root;\n  }\n else {\n    parent=(ZipEntry)directoryEntryCache.get(pathname.removeLastSegments(1));\n  }\n  addToChildren(parent,entry);\n}\n", "docstring": "creates a new file zip entry with the specified name .", "partition": "test"}
{"idx": "3406", "code": "public void testHasAttributes1() throws Throwable {\n  Document doc;\n  NodeList addrList;\n  Node addrNode;\n  boolean state;\n  doc=(Document)load(\"staff\",builder);\n  addrList=doc.getElementsByTagName(\"name\");\n  addrNode=addrList.item(0);\n  state=addrNode.hasAttributes();\n  assertFalse(\"throw_False\",state);\n}\n", "docstring": "runs the test case .", "partition": "test"}
{"idx": "3407", "code": "public void startDocument(XMLLocator locator,String encoding,NamespaceContext namespaceContext,Augmentations augs) throws XNIException {\n  fNamespaceContext=namespaceContext;\n  try {\n    if (fDocumentHandler != null) {\n      if (locator != null) {\n        fDocumentHandler.setDocumentLocator(new LocatorProxy(locator));\n      }\n      fDocumentHandler.startDocument();\n    }\n    if (fContentHandler != null) {\n      if (locator != null) {\n        fContentHandler.setDocumentLocator(new LocatorProxy(locator));\n      }\n      fContentHandler.startDocument();\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}\n", "docstring": "the start of the document .", "partition": "test"}
{"idx": "3408", "code": "@Override public String dumpWindowHierarchy(boolean compressed){\n  device.setCompressedLayoutHeirarchy(compressed);\n  try {\n    ByteArrayOutputStream os=new ByteArrayOutputStream();\n    device.dumpWindowHierarchy(os);\n    os.close();\n    return os.toString(\"UTF-8\");\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n  }\n finally {\n    device.setCompressedLayoutHeirarchy(false);\n  }\n  return null;\n}\n", "docstring": "helper method used for debugging to dump the current window \"'\" s layout hierarchy .", "partition": "test"}
{"idx": "3409", "code": "public void registerObserver(RuleChangesObserver observer){\n  observers.add(observer);\n}\n", "docstring": "registers an observer to be notified on routing rules changes .", "partition": "test"}
{"idx": "3410", "code": "private void sendUpdateHeartbeats(){\n  HeartbeatServiceLocal heartbeat=_bartender.getHeartbeatLocal();\n  if (heartbeat != null) {\n    heartbeat.updateHeartbeats();\n  }\n}\n", "docstring": "send a heartbeat with the updated pods to other servers in the cluster . this call wakes the heartbeat service to send the actual heartbeat .", "partition": "test"}
{"idx": "3411", "code": "public void serialize(String name,byte[] message,OutputStream out) throws IOException {\n  byte[] header=new byte[4 + COMMAND_LEN + 4+ 4];\n  uint32ToByteArrayBE(params.getPacketMagic(),header,0);\n  for (int i=0; i < name.length() && i < COMMAND_LEN; i++) {\n    header[4 + i]=(byte)(name.codePointAt(i) & 0xFF);\n  }\n  Utils.uint32ToByteArrayLE(message.length,header,4 + COMMAND_LEN);\n  byte[] hash=doubleDigest(message);\n  System.arraycopy(hash,0,header,4 + COMMAND_LEN + 4,4);\n  out.write(header);\n  out.write(message);\n  if (log.isDebugEnabled())   log.debug(\"Sending {} message: {}\",name,bytesToHexString(header) + bytesToHexString(message));\n}\n", "docstring": "writes message to to the output stream .", "partition": "test"}
{"idx": "3412", "code": "public SSLEngine initSslEngine(boolean client) throws Exception {\n  KeyStore keyStore=loadKeystore(properties.sslKeyStorePath(),properties.sslKeyStorePassword());\n  KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n  keyManagerFactory.init(keyStore,keyStoreKeyPass(properties));\n  KeyStore trustStore;\n  if (properties.sslTrustStorePath() != null) {\n    LOGGER.debug(\"Using separate trust store\");\n    trustStore=loadKeystore(properties.sslTrustStorePath(),properties.sslTrustStorePassword());\n  }\n else {\n    trustStore=keyStore;\n    LOGGER.debug(\"Using key store as trust store\");\n  }\n  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n  trustManagerFactory.init(trustStore);\n  KeyManager[] keyManagers=keyManagerFactory.getKeyManagers();\n  TrustManager[] trustManagers=trustManagerFactory.getTrustManagers();\n  SSLContext sslContext=SSLContext.getInstance(\"TLS\");\n  sslContext.init(keyManagers,trustManagers,null);\n  SSLEngine sslEngine=sslContext.createSSLEngine();\n  sslEngine.setUseClientMode(client);\n  sslEngine.setWantClientAuth(true);\n  sslEngine.setEnabledProtocols(sslEngine.getSupportedProtocols());\n  sslEngine.setEnabledCipherSuites(sslEngine.getSupportedCipherSuites());\n  sslEngine.setEnableSessionCreation(true);\n  return sslEngine;\n}\n", "docstring": "initializes an ssl engine .", "partition": "test"}
{"idx": "3413", "code": "public GetBufferedRandomAccessSource(IRandomAccessSource source){\n  this.source=source;\n  this.getBuffer=new byte[(int)Math.min(Math.max(source.length() / 4,1),4096)];\n  this.getBufferStart=-1;\n  this.getBufferEnd=-1;\n}\n", "docstring": "constructs a new offsetrandomaccesssource", "partition": "test"}
{"idx": "3414", "code": "public ArgParser(String pName){\n  programName=pName;\n  args=new Vector();\n  args.add(new HelpArg());\n}\n", "docstring": "create a parser for the named program . automatically adds the - help option .", "partition": "test"}
{"idx": "3415", "code": "@Override protected void drawAxisLine(Graphics2D g2,double cursor,Rectangle2D dataArea,RectangleEdge edge){\n  Line2D axisLine=null;\n  double c=cursor;\n  if (edge == RectangleEdge.TOP) {\n    axisLine=new Line2D.Double(dataArea.getX(),c,dataArea.getMaxX(),c);\n  }\n else   if (edge == RectangleEdge.BOTTOM) {\n    axisLine=new Line2D.Double(dataArea.getX(),c,dataArea.getMaxX(),c);\n  }\n else   if (edge == RectangleEdge.LEFT) {\n    axisLine=new Line2D.Double(c,dataArea.getY(),c,dataArea.getMaxY());\n  }\n else   if (edge == RectangleEdge.RIGHT) {\n    axisLine=new Line2D.Double(c,dataArea.getY(),c,dataArea.getMaxY());\n  }\n  g2.setPaint(getAxisLinePaint());\n  g2.setStroke(getAxisLineStroke());\n  Object saved=g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_NORMALIZE);\n  g2.draw(axisLine);\n  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,saved);\n  boolean drawUpOrRight=false;\n  boolean drawDownOrLeft=false;\n  if (this.positiveArrowVisible) {\n    if (this.inverted) {\n      drawDownOrLeft=true;\n    }\n else {\n      drawUpOrRight=true;\n    }\n  }\n  if (this.negativeArrowVisible) {\n    if (this.inverted) {\n      drawUpOrRight=true;\n    }\n else {\n      drawDownOrLeft=true;\n    }\n  }\n  if (drawUpOrRight) {\n    double x=0.0;\n    double y=0.0;\n    Shape arrow=null;\n    if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n      x=dataArea.getMaxX();\n      y=cursor;\n      arrow=this.rightArrow;\n    }\n else     if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n      x=cursor;\n      y=dataArea.getMinY();\n      arrow=this.upArrow;\n    }\n    AffineTransform transformer=new AffineTransform();\n    transformer.setToTranslation(x,y);\n    Shape shape=transformer.createTransformedShape(arrow);\n    g2.fill(shape);\n    g2.draw(shape);\n  }\n  if (drawDownOrLeft) {\n    double x=0.0;\n    double y=0.0;\n    Shape arrow=null;\n    if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n      x=dataArea.getMinX();\n      y=cursor;\n      arrow=this.leftArrow;\n    }\n else     if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n      x=cursor;\n      y=dataArea.getMaxY();\n      arrow=this.downArrow;\n    }\n    AffineTransform transformer=new AffineTransform();\n    transformer.setToTranslation(x,y);\n    Shape shape=transformer.createTransformedShape(arrow);\n    g2.fill(shape);\n    g2.draw(shape);\n  }\n}\n", "docstring": "draws an axis line at the current cursor position and edge .", "partition": "test"}
{"idx": "3416", "code": "public static void saveXStream(File saveTo,Object model,Instances header) throws Exception {\n  Vector<Object> v=new Vector<Object>();\n  v.add(model);\n  if (header != null) {\n    v.add(header);\n  }\n  v.trimToSize();\n  XStream.write(saveTo.getAbsolutePath(),v);\n}\n", "docstring": "save a model in xstream deep object serialized xml form .", "partition": "test"}
{"idx": "3417", "code": "private void sortAndCollapse(){\n  Collections.sort(mSpans);\n  mAddsSinceSort=0;\n  Iterator iter=mSpans.iterator();\n  Span span=null;\n  if (iter.hasNext()) {\n    span=(Span)iter.next();\n  }\n  while (iter.hasNext()) {\n    Span nextSpan=(Span)iter.next();\n    if (span.subsume(nextSpan)) {\n      iter.remove();\n    }\n else {\n      span=nextSpan;\n    }\n  }\n}\n", "docstring": "sort the spans in ascending order by their start position . after the spans are sorted collapse any spans that intersect into a single span . the result is a sorted , non - overlapping list of spans .", "partition": "test"}
{"idx": "3418", "code": "public int splitRandomly(ArrayModifiableDBIDs ind,int begin,int end,DoubleDataStore tpro,Random rand){\n  final int nele=end - begin;\n  DBIDArrayIter it=ind.iter();\n  double rs=tpro.doubleValue(it.seek(begin + rand.nextInt(nele)));\n  int minInd=begin, maxInd=end - 1;\n  while (minInd < maxInd) {\n    double currEle=tpro.doubleValue(it.seek(minInd));\n    if (currEle > rs) {\n      while (minInd < maxInd && tpro.doubleValue(it.seek(maxInd)) > rs) {\n        maxInd--;\n      }\n      if (minInd == maxInd) {\n        break;\n      }\n      ind.swap(minInd,maxInd);\n      maxInd--;\n    }\n    minInd++;\n  }\n  if (minInd == end - 1) {\n    minInd=(begin + end) >>> 1;\n  }\n  return minInd;\n}\n", "docstring": "split the data set randomly .", "partition": "test"}
{"idx": "3419", "code": "public static String noPrefix(String path,String prefix){\n  Objects.requireNonNull(path,\"path must not be null\");\n  Objects.requireNonNull(prefix,\"prefix must not be null\");\n  return path.startsWith(prefix) ? path.substring(prefix.length()) : path;\n}\n", "docstring": "drops a prefix from a path if it exists or returns original path if prefix does not match .", "partition": "test"}
{"idx": "3420", "code": "protected void publish() throws MqttException, IOException {\n  sampleClientPub=new SampleAsyncCallback(url,clientIdPub,cleanSession,quietMode,userName,password);\n  if (sampleClientPub != null) {\n    String topic=\"Sample/Java/v3\";\n    int qos=2;\n    String message=\"Message from async calback MQTTv3 Java client sample\";\n    try {\n      sampleClientPub.publish(topic,qos,message.getBytes());\n    }\n catch (    Throwable e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "publish / send a message to an mqtt server", "partition": "test"}
{"idx": "3421", "code": "public void remove(IAdaptable a){\n  children.remove(a);\n}\n", "docstring": "adds the given adaptable object to this list .", "partition": "test"}
{"idx": "3422", "code": "public static IntStream concat(IntStream a,IntStream b){\n  Objects.requireNonNull(a);\n  Objects.requireNonNull(b);\n  Spliterator.OfInt split=new Streams.ConcatSpliterator.OfInt(a.spliterator(),b.spliterator());\n  IntStream stream=StreamSupport.intStream(split,a.isParallel() || b.isParallel());\n  return stream.onClose(Streams.composedClose(a,b));\n}\n", "docstring": "creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream . the resulting stream is ordered if both of the input streams are ordered , and parallel if either of the input streams is parallel . when the resulting stream is closed , the close handlers for both input streams are invoked .", "partition": "test"}
{"idx": "3423", "code": "public LoginConfiguration forceAuth(String forceAuthReqParam){\n  forceAuth=Boolean.parseBoolean(forceAuthReqParam);\n  return this;\n}\n", "docstring": "sets the request \"'\" s forceauth parameter .", "partition": "test"}
{"idx": "3424", "code": "@MethodDesc(description=\"Stops the replicator service\",usage=\"stop\") public void stop() throws Exception {\n  try {\n    handleEventSynchronous(new StopEvent());\n    if (doneLatch != null) {\n      doneLatch.countDown();\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Stop operation failed\",e);\n    throw new Exception(e.toString());\n  }\n}\n", "docstring": "stop replicator node manager jmx service .", "partition": "test"}
{"idx": "3425", "code": "public boolean writeCharacteristic(String address,String serviceUUID,String characteristicUUID,byte[] value){\n  BluetoothGatt bluetoothGatt=mBluetoothGattMap.get(address);\n  if (bluetoothGatt != null) {\n    BluetoothGattService service=bluetoothGatt.getService(UUID.fromString(serviceUUID));\n    BluetoothGattCharacteristic characteristic=service.getCharacteristic(UUID.fromString(characteristicUUID));\n    characteristic.setValue(value);\n    return bluetoothGatt.writeCharacteristic(characteristic);\n  }\n  return false;\n}\n", "docstring": "write data to characteristic , and send to remote bluetooth le device .", "partition": "test"}
{"idx": "3426", "code": "public String linkForMessage(ProtoElement element){\n  if (isExternalFile(element.getFile())) {\n    String fullName=element.getFullName();\n    return String.format(\"[%s]{@link external:\\\"%s\\\"}\",fullName,fullName);\n  }\n else {\n    String simpleName=element.getSimpleName();\n    return String.format(\"[%s]{@link %s}\",simpleName,simpleName);\n  }\n}\n", "docstring": "returns the jsdoc format of link to the element .", "partition": "test"}
{"idx": "3427", "code": "public static <T>ArrayList<T> read(InputStream fileStream,String charsetName,ITransformer<String,T> transformer) throws FileNotFoundException {\n  Scanner scanner=new Scanner(fileStream,charsetName);\n  ArrayList<T> list=new ArrayList<>();\n  while (scanner.hasNextLine()) {\n    String line=scanner.nextLine();\n    list.add(transformer.transform(line));\n  }\n  scanner.close();\n  return list;\n}\n", "docstring": "this function reads an inputstream line - by - line and converts each line into an object using a transformer that is passed as a parameter .", "partition": "test"}
{"idx": "3428", "code": "public boolean remove(JsonElement element){\n  return elements.remove(element);\n}\n", "docstring": "removes the first occurrence of the specified element from this array , if it is present . if the array does not contain the element , it is unchanged .", "partition": "test"}
{"idx": "3429", "code": "public TSink<byte[]> sendBytes(TStream<byte[]> stream){\n  Objects.requireNonNull(stream,\"stream\");\n  return sendBinary(stream,null);\n}\n", "docstring": "send a stream \"'\" s byte [ ", "partition": "test"}
{"idx": "3430", "code": "private void sortBrokerItems(BrokerItem[] brokerItems,int sortType){\n  Arrays.sort(brokerItems,BrokerItem.getComparatoryByType(sortType));\n}\n", "docstring": "perform sorting according to sort type", "partition": "test"}
{"idx": "3431", "code": "protected boolean needToEscapeXMLSpecialCharacters(String hostEntityID,String remoteEntityID,String realm){\n  return true;\n}\n", "docstring": "decides whether it needs to escape xml special characters for attribute values or not .", "partition": "test"}
{"idx": "3432", "code": "private void updatePathConstraints(TestChromosome test){\n  List<BranchCondition> pathCondition=ConcolicExecution.getSymbolicPath(test);\n  pathConditions.put(test,pathCondition);\n}\n", "docstring": "calculate and store path constraints for an individual", "partition": "test"}
{"idx": "3433", "code": "public void test_journal_oneIndexNoData() throws IOException, InterruptedException, ExecutionException {\n  final File out=File.createTempFile(getName(),Options.JNL);\n  try {\n    final Journal src=getStore(getProperties());\n    try {\n      final String NAME=\"testIndex\";\n      src.registerIndex(new IndexMetadata(NAME,UUID.randomUUID()));\n      src.commit();\n      final Future<Journal> f=src.compact(out);\n      final Journal newJournal=f.get();\n      try {\n        assertNotNull(newJournal.getIndex(NAME));\n        AbstractBTreeTestCase.assertSameBTree(src.getIndex(NAME),newJournal.getIndex(NAME));\n      }\n  finally {\n        newJournal.destroy();\n      }\n    }\n  finally {\n      src.destroy();\n    }\n  }\n  finally {\n    out.delete();\n  }\n}\n", "docstring": "test of a journal on which a single index has been register ( and the journal committed ) but no data was written onto the index .", "partition": "test"}
{"idx": "3434", "code": "public static boolean p2pLoader(ClassLoader ldr){\n  return ldr instanceof GridDeploymentInfo;\n}\n", "docstring": "checks if class loader is an internal p2p class loader .", "partition": "test"}
{"idx": "3435", "code": "private static String removeSubTrailers(String decodedSubject){\n  int subStringStart=0;\n  int subStringEnd=decodedSubject.length();\n  int originalSize=decodedSubject.length();\n  int curPos=originalSize - 1;\n  while (true) {\n    char c=decodedSubject.charAt(curPos--);\n    if (c == WS) {\n      subStringEnd--;\n    }\n else {\n      if (subStringEnd > FWD_PARENS.length() && decodedSubject.endsWith(FWD_PARENS)) {\n        subStringEnd-=FWD_PARENS.length();\n      }\n      break;\n    }\n  }\n  decodedSubject=decodedSubject.substring(subStringStart,subStringEnd);\n  return decodedSubject;\n}\n", "docstring": "remove the remove_subj_trailers subj - trailer = \" ( fwd ) \" / wsp", "partition": "test"}
{"idx": "3436", "code": "boolean nextSource() throws IOException {\n  if (mSourceIt.hasNext()) {\n    final InputStream is=mSourceIt.next();\n    if (is == null) {\n      mSource=null;\n      return false;\n    }\n else {\n      mSource=new BufferedInputStream(is,FileUtils.BUFFERED_STREAM_SIZE);\n    }\n    mSourceClosed=false;\n    mInputBufferPosition=0;\n    mInputBufferLength=0;\n    mBufferLength=0;\n    mBufferPosition=0;\n    return true;\n  }\n  if (mSource != null) {\n    mSource.close();\n  }\n  mSource=null;\n  return false;\n}\n", "docstring": "step to the next input stream .", "partition": "test"}
{"idx": "3437", "code": "public static byte[] bitmapToBytes(Bitmap bm){\n  byte[] bytes=null;\n  if (bm != null) {\n    ByteArrayOutputStream baos=new ByteArrayOutputStream();\n    bm.compress(Bitmap.CompressFormat.PNG,100,baos);\n    bytes=baos.toByteArray();\n  }\n  return bytes;\n}\n", "docstring": "bitmap transfer to bytes", "partition": "test"}
{"idx": "3438", "code": "public static String inflate(String name){\n  return inflate(name,gPrefix);\n}\n", "docstring": "inflate a short name into a full gdata uri using gprefix ( ending in \" # \" ) . names that already look like uris are left alone . for example , \" foo \" becomes \" http : / / schemas . google . com / g / 2005 # foo \" .", "partition": "test"}
{"idx": "3439", "code": "public void addPriorityHandler(WarningHandler handler){\n  _priorityHandlers.add(handler);\n}\n", "docstring": "add a warning event handler . high priority handlers only get high priority warnings , and they are notified first . other handlers gets all warnings after high priority handlers are notified .", "partition": "test"}
{"idx": "3440", "code": "private void writeAttr(String name,String val) throws IOException {\n  writeAttr(name,val,true);\n}\n", "docstring": "writes the xml attribute name / val . a null val means that the attribute is missing .", "partition": "test"}
{"idx": "3441", "code": "final private String syntaxDef2SyntaxDesc(Attributes attrs) throws NamingException {\n  StringBuffer syntaxDesc=new StringBuffer(\"( \");\n  Attribute attr=null;\n  int count=0;\n  attr=attrs.get(NUMERICOID_ID);\n  if (attr != null) {\n    syntaxDesc.append(writeNumericOID(attr));\n    count++;\n  }\n else {\n    throw new ConfigurationException(\"Attribute type doesn\'t\" + \"have a numeric OID\");\n  }\n  attr=attrs.get(DESC_ID);\n  if (attr != null) {\n    syntaxDesc.append(writeQDString(attr));\n    count++;\n  }\n  if (count < attrs.size()) {\n    String attrId=null;\n    for (NamingEnumeration<? extends Attribute> ae=attrs.getAll(); ae.hasMoreElements(); ) {\n      attr=ae.next();\n      attrId=attr.getID();\n      if (attrId.equals(NUMERICOID_ID) || attrId.equals(DESC_ID)) {\n        continue;\n      }\n else {\n        syntaxDesc.append(writeQDStrings(attr));\n      }\n    }\n  }\n  syntaxDesc.append(\")\");\n  return syntaxDesc.toString();\n}\n", "docstring": "translate attributes that describe an attribute syntax definition into the string description as defined in rfc 2252 .", "partition": "test"}
{"idx": "3442", "code": "@Override public void write(Buffer buffer,boolean isEnd) throws IOException {\n  if (_s == null) {\n    buffer.free();\n    return;\n  }\n  try {\n    _needsFlush=true;\n    if (buffer.isDirect()) {\n      _totalWriteBytes+=buffer.length();\n      _s.write(buffer.direct());\n      return;\n    }\n    _totalWriteBytes+=buffer.length();\n    while (buffer.length() > 0) {\n      _writeBuffer.clear();\n      buffer.read(_writeBuffer);\n      _writeBuffer.flip();\n      _s.write(_writeBuffer);\n    }\n  }\n catch (  IOException e) {\n    IOException exn=ClientDisconnectException.create(this + \":\" + e,e);\n    try {\n      close();\n    }\n catch (    IOException e1) {\n    }\n    throw exn;\n  }\n finally {\n    buffer.free();\n  }\n}\n", "docstring": "writes an nio buffer to the socket .", "partition": "test"}
{"idx": "3443", "code": "private static void skipMemberValue(int tag,ByteBuffer buf){\nswitch (tag) {\ncase 'e':\n    buf.getInt();\n  break;\ncase '@':\nskipAnnotation(buf,true);\nbreak;\ncase '[':\nskipArray(buf);\nbreak;\ndefault :\nbuf.getShort();\n}\n}\n", "docstring": "skips the annotation member value at the current position in the specified byte buffer . the cursor of the byte buffer must point immediately after the tag in a \" member_value structure . \"", "partition": "test"}
{"idx": "3444", "code": "protected void recursiveNestedJoin(EventBean lookupEvent,int nestingOrderIndex,EventBean[] currentPath,Collection<EventBean[]> result,ExprEvaluatorContext exprEvaluatorContext){\n  List<EventBean[]> nestedResult=new LinkedList<EventBean[]>();\n  ExecNode nestedExecNode=childNodes.get(nestingOrderIndex);\n  nestedExecNode.process(lookupEvent,currentPath,nestedResult,exprEvaluatorContext);\n  boolean isLastStream=(nestingOrderIndex == nestingOrderLength - 1);\n  if (!isLastStream) {\n    for (    EventBean[] row : nestedResult) {\n      EventBean lookup=row[nestedStreams[nestingOrderIndex]];\n      recursiveNestedJoin(lookup,nestingOrderIndex + 1,row,result,exprEvaluatorContext);\n    }\n    return;\n  }\n  for (  EventBean[] row : nestedResult) {\n    result.add(row);\n  }\n}\n", "docstring": "recursive method to run through all child nodes and , for each result set tuple returned by a child node , execute the inner child of the child node until there are no inner child nodes .", "partition": "test"}
{"idx": "3445", "code": "public String generateMinimalMATSimConfig(){\n  Config config=new Config();\n  ConfigGroup ippcm=config.createModule(MatrixBasedPtRouterConfigGroup.GROUP_NAME);\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.PT_STOPS,this.ptStops);\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.USING_PT_STOPS,\"tRue\");\n  ippcm.addParam(MatrixBasedPtRouterConfigGroup.PT_TRAVEL_TIMES_AND_DISTANCES_SWITCH,this.useTravelTimesAndDistances);\n  ChangeModeConfigGroup changeModeConfig=ConfigUtils.addOrGetModule(config,ChangeModeConfigGroup.CONFIG_MODULE,ChangeModeConfigGroup.class);\n  String[] str={\"car\",\"pt\"};\n  changeModeConfig.setModes(str);\n  return writeConfigFile(config);\n}\n", "docstring": "generates the external matsim config file with the specified parameter settings", "partition": "test"}
{"idx": "3446", "code": "private int convertLocationToColumn(int x,int y){\n  if (cellWidth > 0) {\n    if (layoutOrientation == JList.VERTICAL) {\n      return 0;\n    }\n    Insets insets=list.getInsets();\n    int col;\n    if (isLeftToRight) {\n      col=(x - insets.left) / cellWidth;\n    }\n else {\n      col=(list.getWidth() - x - insets.right- 1) / cellWidth;\n    }\n    if (col < 0) {\n      return 0;\n    }\n else     if (col >= columnCount) {\n      return columnCount - 1;\n    }\n    return col;\n  }\n  return 0;\n}\n", "docstring": "returns the closest column to the passed in location .", "partition": "test"}
{"idx": "3447", "code": "public static List<File> findFilesInDir(File directory,FilenameFilter filter){\n  Vector<File> files=new Vector<File>();\n  File[] entries=directory.listFiles();\n  for (  File entry : entries) {\n    if (filter == null || filter.accept(directory,entry.getName())) {\n      files.add(entry);\n    }\n    if (entry.isDirectory()) {\n      files.addAll(findFilesInDir(entry,filter));\n    }\n  }\n  return files;\n}\n", "docstring": "given a java . io . file representing a directory , list all the files underneath that directory matching the given filenamefilter .", "partition": "test"}
{"idx": "3448", "code": "public String generateDrop(String table){\n  StringBuffer result=new StringBuffer();\n  result.append(\"DROP TABLE \");\n  result.append(table);\n  result.append(\";\\n\");\n  return result.toString();\n}\n", "docstring": "generate the drop statement for a table .", "partition": "test"}
{"idx": "3449", "code": "private void registerChildListeners(){\n  Iterator<PropertyChangeListener> iter=fChildListeners.iterator();\n  while (iter.hasNext()) {\n    PropertyChangeListener listener=iter.next();\n    listener.register();\n  }\n}\n", "docstring": "register the child listeners on the child preference stores .", "partition": "test"}
{"idx": "3450", "code": "private void refreshIndexForDimensionFields(String rowId,DimensionRow dimensionRow,DimensionRow dimensionRowOld){\n  try {\n    for (    DimensionField field : dimension.getDimensionFields()) {\n      if (field == dimension.getKey()) {\n        continue;\n      }\n      if (dimensionRowOld != null) {\n        String oldRowValue=dimensionRowOld.get(field);\n        String oldRowValueKey=DimensionStoreKeyUtils.getRowKey(field.getName(),oldRowValue);\n        String oldRowValuesKeysJson=keyValueStore.get(oldRowValueKey);\n        String[] oldRowValueSKeys=objectMapper.readValue(oldRowValuesKeysJson,String[].class);\n        Set<String> oldRowValuesKeySet=new LinkedHashSet<>(Arrays.asList(oldRowValueSKeys));\n        oldRowValuesKeySet.remove(rowId);\n        if (oldRowValuesKeySet.isEmpty()) {\n          keyValueStore.remove(oldRowValueKey);\n        }\n else {\n          String updatedOldRowValueSKeys=objectMapper.writeValueAsString(oldRowValuesKeySet);\n          keyValueStore.put(oldRowValueKey,updatedOldRowValueSKeys);\n        }\n      }\n      String rowValue=dimensionRow.get(field);\n      String rowValueKey=DimensionStoreKeyUtils.getRowKey(field.getName(),rowValue);\n      String rowValueSKeys=keyValueStore.get(rowValueKey);\n      Set<String> rowValueSKeySet=new LinkedHashSet<>();\n      if (rowValueSKeys != null) {\n        rowValueSKeySet.addAll(Arrays.asList(objectMapper.readValue(rowValueSKeys,String[].class)));\n      }\n      rowValueSKeySet.add(rowId);\n      String updatedRowValueSKeys=objectMapper.writeValueAsString(rowValueSKeySet);\n      keyValueStore.put(rowValueKey,updatedRowValueSKeys);\n    }\n  }\n catch (  IOException e) {\n    LOG.error(\"Exception while adding dimension description entry in key value store : {}\",e);\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "this method updates the store to allow point lookups using the non - key field ( s ) . it loops through all the fields for a dimension ( ignores the key field ) < p > for a new dimensionrow say id v1 and desc value1 a new entry is added in store < p > desc_value1_row_key - > [ id_v1_row_key ", "partition": "test"}
{"idx": "3451", "code": "public List<Instruction> reduceInstructions(final List<Instruction> instructions){\n  lock.lock();\n  try {\n    this.instructions=instructions;\n    stackSizeSimulator.buildStackSizes(instructions);\n    return reduceInstructionsInternal(instructions);\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "returns all instructions which are somewhat \" relevant \" for the returned object of the method . the instructions are visited backwards - starting from the return statement . load and store operations are handled as well .", "partition": "test"}
{"idx": "3452", "code": "protected boolean isLockedLocally(UUID newOwnerID){\n  return thisNode.equals(getOwnerNode()) || thisNode.equals(newOwnerID);\n}\n", "docstring": "checks if latest call to acquire / release was called on this node . should only be called from update method .", "partition": "test"}
{"idx": "3453", "code": "public void testCompareNegNeg2(){\n  byte aBytes[]={10,20,30,40,50,60,70,10,20,30};\n  byte bBytes[]={12,56,100,-2,-76,89,45,91,3,-15,35,26,3,91};\n  int aSign=-1;\n  int bSign=-1;\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  assertEquals(1,aNumber.compareTo(bNumber));\n}\n", "docstring": "compareto ( biginteger a ) . compare two negative numbers . the first is less in absolute value .", "partition": "test"}
{"idx": "3454", "code": "public void deletePoint(int position){\n  int renderType=poly.getRenderType();\n  Projection proj=getProjection();\n  boolean needToHookUp=false;\n  if (position <= 0 && isEnclosed()) {\n    enclose(false);\n    needToHookUp=true;\n  }\n  if (renderType == OMGraphic.RENDERTYPE_LATLON) {\n    Debug.message(\"eomg\",\"EditableOMPoly: removing point from lat/lon poly\");\n    if (proj != null) {\n      double[] ll=poly.getLatLonArray();\n      double[] newll=new double[ll.length - 2];\n      int actualPosition=(position == Integer.MAX_VALUE ? ll.length : position * 2);\n      if (actualPosition >= ll.length) {\n        System.arraycopy(ll,0,newll,0,ll.length - 2);\n        position=(ll.length - 2) / 2;\n      }\n else       if (actualPosition <= 0) {\n        System.arraycopy(ll,2,newll,0,ll.length - 2);\n        position=0;\n      }\n else {\n        System.arraycopy(ll,0,newll,0,actualPosition);\n        System.arraycopy(ll,actualPosition + 2,newll,actualPosition,ll.length - actualPosition - 2);\n      }\n      poly.setLocation(newll,poly.getUnits());\n    }\n  }\n else {\n    Debug.message(\"eomg\",\"EditableOMPoly: removing point from x/y or offset poly\");\n    int currentLength=poly.xs.length;\n    int[] newxs=new int[currentLength - 1];\n    int[] newys=new int[currentLength - 1];\n    if (position >= currentLength) {\n      System.arraycopy(poly.xs,0,newxs,0,currentLength - 1);\n      System.arraycopy(poly.ys,0,newys,0,currentLength - 1);\n      position=currentLength - 1;\n    }\n else     if (position <= 0) {\n      System.arraycopy(poly.xs,1,newxs,0,currentLength - 1);\n      System.arraycopy(poly.ys,1,newys,0,currentLength - 1);\n      position=0;\n    }\n else {\n      System.arraycopy(poly.xs,0,newxs,0,position);\n      System.arraycopy(poly.xs,position + 1,newxs,position,currentLength - position - 1);\n      System.arraycopy(poly.ys,0,newys,0,position);\n      System.arraycopy(poly.ys,position + 1,newys,position,currentLength - position - 1);\n    }\n    if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n      poly.setLocation(poly.lat,poly.lon,poly.getUnits(),newxs,newys);\n    }\n else {\n      poly.setLocation(newxs,newys);\n    }\n  }\n  if (proj != null) {\n    poly.regenerate(proj);\n  }\n  GrabPoint gp=(GrabPoint)polyGrabPoints.remove(position);\n  if (gpo != null && gp != null) {\n    gpo.removeGrabPoint(gp);\n  }\n  if (needToHookUp) {\n    enclose(true);\n  }\n}\n", "docstring": "delete a point at a certain point in the polygon coordinate list . if the position is less than zero , the deleted point will be the starting point . if the position is greater than the list of current points , the point will be deleted from the end of the poly .", "partition": "test"}
{"idx": "3455", "code": "@Override public boolean deleteLeftWord(){\n  mInputConnection.beginBatchEdit();\n  if (mInputConnection.getSelectedText(0) != null) {\n    mInputConnection.commitText(\"\",0);\n  }\n else {\n    CharSequence beforeCursor=mInputConnection.getTextBeforeCursor(MAX_DELETABLE_CONTEXT,0);\n    if (beforeCursor != null) {\n      int beforeCursorLength=beforeCursor.length();\n      Matcher m=WHITESPACE_AND_TOKEN.matcher(beforeCursor);\n      int lastIndex=0;\n      while (m.find()) {\n        lastIndex=beforeCursorLength == m.end() ? m.start() : m.end();\n      }\n      if (lastIndex > 0) {\n        mInputConnection.deleteSurroundingText(beforeCursorLength - lastIndex,0);\n      }\n else       if (beforeCursorLength < MAX_DELETABLE_CONTEXT) {\n        mInputConnection.deleteSurroundingText(beforeCursorLength,0);\n      }\n    }\n  }\n  mInputConnection.endBatchEdit();\n  return true;\n}\n", "docstring": "deletes all characters up to the leftmost whitespace from the cursor ( including the whitespace ) . if something is selected then delete the selection . todo : maybe expensive ?", "partition": "test"}
{"idx": "3456", "code": "public static double cdf(double val,double rate){\n  if (val < 0.) {\n    return 0.;\n  }\n  return 1 - Math.exp(-rate * val);\n}\n", "docstring": "cumulative density , static version", "partition": "test"}
{"idx": "3457", "code": "public static DataSet readContinuous(File file,char delimiter) throws IOException {\n  return readInContinuousData(file,delimiter,Collections.singleton(\"MULT\"));\n}\n", "docstring": "read in continuous dataset .", "partition": "test"}
{"idx": "3458", "code": "public static String generateNativeGuidForStoragePortFromIndication(String sourceInstanceSystemName,String portNetworkId){\n  String[] splitedString=sourceInstanceSystemName.split(Constants.PATH_DELIMITER_REGEX);\n  return String.format(\"%s+%s+PORT+%s\",splitedString[0],splitedString[1],portNetworkId);\n}\n", "docstring": "fc port value from indication sourceinstancesystemname : symmetrix + 000198700406 + fa - 1e iscsi port value from indication sourceinstancesystemname : symmetrix + 000198700406 + se - 1g", "partition": "test"}
{"idx": "3459", "code": "protected boolean arePathsContiguous(TreePath[] paths){\n  if (rowMapper == null || paths.length < 2)   return true;\n else {\n    BitSet bitSet=new BitSet(32);\n    int anIndex, counter, min;\n    int pathCount=paths.length;\n    int validCount=0;\n    TreePath[] tempPath=new TreePath[1];\n    tempPath[0]=paths[0];\n    min=rowMapper.getRowsForPaths(tempPath)[0];\n    for (counter=0; counter < pathCount; counter++) {\n      if (paths[counter] != null) {\n        tempPath[0]=paths[counter];\n        int[] rows=rowMapper.getRowsForPaths(tempPath);\n        if (rows == null) {\n          return false;\n        }\n        anIndex=rows[0];\n        if (anIndex == -1 || anIndex < (min - pathCount) || anIndex > (min + pathCount))         return false;\n        if (anIndex < min)         min=anIndex;\n        if (!bitSet.get(anIndex)) {\n          bitSet.set(anIndex);\n          validCount++;\n        }\n      }\n    }\n    int maxCounter=validCount + min;\n    for (counter=min; counter < maxCounter; counter++)     if (!bitSet.get(counter))     return false;\n  }\n  return true;\n}\n", "docstring": "returns true if the paths are contiguous , or this object has no rowmapper .", "partition": "test"}
{"idx": "3460", "code": "public FastStringReader(String s){\n  this.str=s;\n  this.length=s.length();\n}\n", "docstring": "creates a new string reader .", "partition": "test"}
{"idx": "3461", "code": "static void updateStyle(JTextComponent c,SeaGlassContext context,String prefix){\n  SeaGlassStyle style=(SeaGlassStyle)context.getStyle();\n  Color color=c.getCaretColor();\n  if (color == null || color instanceof UIResource) {\n    c.setCaretColor((Color)style.get(context,prefix + \".caretForeground\"));\n  }\n  Color fg=c.getForeground();\n  if (fg == null || fg instanceof UIResource) {\n    fg=style.getColorForState(context,ColorType.TEXT_FOREGROUND);\n    if (fg != null) {\n      c.setForeground(fg);\n    }\n  }\n  Object ar=style.get(context,prefix + \".caretAspectRatio\");\n  if (ar instanceof Number) {\n    c.putClientProperty(\"caretAspectRatio\",ar);\n  }\n  context.setComponentState(SELECTED | FOCUSED);\n  Color s=c.getSelectionColor();\n  if (s == null || s instanceof UIResource) {\n    c.setSelectionColor(style.getColor(context,ColorType.TEXT_BACKGROUND));\n  }\n  Color sfg=c.getSelectedTextColor();\n  if (sfg == null || sfg instanceof UIResource) {\n    c.setSelectedTextColor(style.getColor(context,ColorType.TEXT_FOREGROUND));\n  }\n  context.setComponentState(DISABLED);\n  Color dfg=c.getDisabledTextColor();\n  if (dfg == null || dfg instanceof UIResource) {\n    c.setDisabledTextColor(style.getColor(context,ColorType.TEXT_FOREGROUND));\n  }\n  Insets margin=c.getMargin();\n  if (margin == null || margin instanceof UIResource) {\n    margin=(Insets)style.get(context,prefix + \".margin\");\n    if (margin == null) {\n      margin=SeaGlassLookAndFeel.EMPTY_UIRESOURCE_INSETS;\n    }\n    c.setMargin(margin);\n  }\n  Caret caret=c.getCaret();\n  if (caret instanceof UIResource) {\n    Object o=style.get(context,prefix + \".caretBlinkRate\");\n    if (o != null && o instanceof Integer) {\n      Integer rate=(Integer)o;\n      caret.setBlinkRate(rate.intValue());\n    }\n  }\n}\n", "docstring": "private method to update styles .", "partition": "test"}
{"idx": "3462", "code": "@SuppressLint(\"DrawAllocation\") @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int maxWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int maxHeight=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.UNSPECIFIED)   maxWidth=Integer.MAX_VALUE;\n  if (heightMode == MeasureSpec.UNSPECIFIED)   maxHeight=Integer.MAX_VALUE;\n  int paddingLeft=getPaddingLeft();\n  int paddingTop=getPaddingTop();\n  int paddingRight=getPaddingRight();\n  int paddingBottom=getPaddingBottom();\n  int maxRightBound=maxWidth - paddingRight;\n  int maxBottomBound=maxHeight - paddingBottom;\n  int left;\n  int top;\n  int right;\n  int bottom;\n  int rightBound=paddingLeft;\n  int maxRightNoPadding=rightBound;\n  int bottomBound;\n  int lastMaxBottom=paddingTop;\n  int maxBottom=lastMaxBottom;\n  int childWidth;\n  int childHeight;\n  int lineStartIndex=0;\n  int lineEndIndex=0;\n  rectList.clear();\n  int childCount=getChildCount();\n  for (int index=0; index < childCount; index++) {\n    final View child=getChildAt(index);\n    child.measure(MeasureSpec.UNSPECIFIED,MeasureSpec.UNSPECIFIED);\n    if (child.getVisibility() == View.GONE)     continue;\n    final AutoWrapLayout.LayoutParams lp=(AutoWrapLayout.LayoutParams)child.getLayoutParams();\n    childWidth=child.getMeasuredWidth();\n    childHeight=child.getMeasuredHeight();\n    left=rightBound + lp.leftMargin;\n    right=left + childWidth;\n    rightBound=right + lp.rightMargin;\n    if (rightBound > maxRightBound) {\n      lineEndIndex=index;\n      adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,lineEndIndex);\n      if (maxBottom >= maxBottomBound)       break;\n      if (lineEndIndex == lineStartIndex) {\n        child.measure(MeasureSpec.makeMeasureSpec(maxWidth - paddingLeft - paddingRight- lp.leftMargin- lp.rightMargin,MeasureSpec.AT_MOST),MeasureSpec.UNSPECIFIED);\n        childWidth=child.getMeasuredWidth();\n        childHeight=child.getMeasuredHeight();\n      }\n      left=paddingLeft + lp.leftMargin;\n      right=left + childWidth;\n      rightBound=right + lp.rightMargin;\n      lastMaxBottom=maxBottom;\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n      lineStartIndex=index;\n    }\n else {\n      top=lastMaxBottom + lp.topMargin;\n      bottom=top + childHeight;\n      bottomBound=bottom + lp.bottomMargin;\n    }\n    if (rightBound > maxRightNoPadding)     maxRightNoPadding=rightBound;\n    if (bottomBound > maxBottom)     maxBottom=bottomBound;\n    Rect rect=new Rect();\n    rect.left=left;\n    rect.top=top;\n    rect.right=right;\n    rect.bottom=bottom;\n    rectList.add(rect);\n  }\n  adjustBaseLine(maxBottom - lastMaxBottom,lineStartIndex,rectList.size());\n  int measuredWidth;\n  int measuredHeight;\n  if (widthMode == MeasureSpec.EXACTLY)   measuredWidth=maxWidth;\n else   measuredWidth=maxRightNoPadding + paddingRight;\n  if (heightMode == MeasureSpec.EXACTLY)   measuredHeight=maxHeight;\n else {\n    measuredHeight=maxBottom + paddingBottom;\n    if (heightMode == MeasureSpec.AT_MOST)     measuredHeight=measuredHeight > maxHeight ? maxHeight : measuredHeight;\n  }\n  setMeasuredDimension(measuredWidth,measuredHeight);\n}\n", "docstring": "each row or line at least show one child horizontal only show child can show or partly show in parent", "partition": "test"}
{"idx": "3463", "code": "public final void wait() throws java.lang.InterruptedException {\n  wait(0);\n}\n", "docstring": "causes current thread to wait until another thread invokes the method or the method for this object . in other word \"'\" s this method behaves exactly as if it simply performs the call wait ( 0 ) . the current thread must own this object \"'\" s monitor . the thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object \"'\" s monitor to wake up either through a call to the notify method or the notifyall method . the thread then waits until it can re - obtain ownership of the monitor and resumes execution . this method should only be called by a thread that is the owner of this object \"'\" s monitor . see the notify method for a description of the ways in which a thread can become the owner of a monitor .", "partition": "test"}
{"idx": "3464", "code": "public QueryStringQueryBuilder field(String field,float boost){\n  if (fields == null) {\n    fields=new ArrayList<>();\n  }\n  fields.add(field);\n  if (fieldsBoosts == null) {\n    fieldsBoosts=new ObjectFloatHashMap<>();\n  }\n  fieldsBoosts.put(field,boost);\n  return this;\n}\n", "docstring": "adds a field to run the query string against with a specific boost .", "partition": "test"}
{"idx": "3465", "code": "protected void initStreamBufferSize(){\n  String streamBufferSizeParam=getInitParameter(\"streamBufferSize\");\n  setStreamBufferSize((streamBufferSizeParam == null) ? DEFAULT_STREAM_BUFFER_SIZE : Integer.parseInt(streamBufferSizeParam));\n  if (isDebug()) {\n    log(\"streamBufferSize: \" + getStreamBufferSize());\n  }\n}\n", "docstring": "initializer for property streambuffersize .", "partition": "test"}
{"idx": "3466", "code": "public void registerSensor(Sensor s,int i){\n  if ((i < 0) || (i > ((numInputCards() * bitsPerCard) - 1)) || (i > MAXSENSORS)) {\n    log.error(\"Unexpected sensor ordinal in registerSensor: \" + Integer.toString(i + 1));\n    return;\n  }\n  hasActiveSensors=true;\n  if (sensorArray[i] == null) {\n    sensorArray[i]=s;\n    if (lastUsedSensor < i) {\n      lastUsedSensor=i;\n    }\n  }\n else {\n    log.warn(\"multiple registration of same sensor: CS\" + Integer.toString((getNodeAddress() * SerialSensorManager.SENSORSPERUA) + i + 1));\n  }\n}\n", "docstring": "the numbers here are 0 to maxsensors , not 1 to maxsensors .", "partition": "test"}
{"idx": "3467", "code": "public static Number asNumber(String value,Supplier<Number> defaultValueProvider){\n  if (value != null) {\n    try {\n      return Short.valueOf(value);\n    }\n catch (    NumberFormatException e1) {\n      try {\n        return Integer.valueOf(value);\n      }\n catch (      NumberFormatException e2) {\n        try {\n          return Long.valueOf(value);\n        }\n catch (        NumberFormatException e3) {\n          try {\n            return Float.valueOf(value);\n          }\n catch (          NumberFormatException e4) {\n            try {\n              return Double.valueOf(value);\n            }\n catch (            NumberFormatException e5) {\n              try {\n                return new BigInteger(value);\n              }\n catch (              NumberFormatException e6) {\n                try {\n                  return new BigDecimal(value);\n                }\n catch (                NumberFormatException e7) {\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return defaultValueProvider != null ? defaultValueProvider.get() : null;\n}\n", "docstring": "parse the supplied string as a number .", "partition": "test"}
{"idx": "3468", "code": "public final void sample(){\n  long sum=_sum.getAndSet(0);\n  int count=_count.getAndSet(0);\n  if (count != 0)   _value=sum / (double)count;\n else   _value=0;\n}\n", "docstring": "return the probe \"'\" s next sample .", "partition": "test"}
{"idx": "3469", "code": "private String applyReplacement(final BidiMap replacement,String contents){\n  for (  Object key : replacement.keySet()) {\n    String attributeName=(String)key;\n    String attributeInitials=(String)replacement.get(key);\n    contents=contents.replaceAll(JSONSerialisation.jsonAttributeName(attributeName),JSONSerialisation.jsonAttributeName(attributeInitials));\n  }\n  return contents;\n}\n", "docstring": "perform the keyword substitution .", "partition": "test"}
{"idx": "3470", "code": "public KeyImpl(KerberosPrincipal principal,char[] password,String algorithm){\n  try {\n    PrincipalName princ=new PrincipalName(principal.getName());\n    EncryptionKey key=new EncryptionKey(password,princ.getSalt(),algorithm);\n    this.keyBytes=key.getBytes();\n    this.keyType=key.getEType();\n  }\n catch (  KrbException e) {\n    throw new IllegalArgumentException(e.getMessage());\n  }\n}\n", "docstring": "constructs a keyimpl from a password .", "partition": "test"}
{"idx": "3471", "code": "public static AnnotationBinding[] addStandardAnnotations(AnnotationBinding[] recordedAnnotations,long annotationTagBits,LookupEnvironment env){\n  int count=0;\n  if ((annotationTagBits & TagBits.AnnotationTargetMASK) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationRetentionMASK) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationDeprecated) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationDocumented) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationInherited) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationOverride) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationSuppressWarnings) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationPolymorphicSignature) != 0)   count++;\n  if ((annotationTagBits & TagBits.AnnotationSafeVarargs) != 0)   count++;\n  if (count == 0)   return recordedAnnotations;\n  int index=recordedAnnotations.length;\n  AnnotationBinding[] result=new AnnotationBinding[index + count];\n  System.arraycopy(recordedAnnotations,0,result,0,index);\n  if ((annotationTagBits & TagBits.AnnotationTargetMASK) != 0)   result[index++]=buildTargetAnnotation(annotationTagBits,env);\n  if ((annotationTagBits & TagBits.AnnotationRetentionMASK) != 0)   result[index++]=buildRetentionAnnotation(annotationTagBits,env);\n  if ((annotationTagBits & TagBits.AnnotationDeprecated) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_DEPRECATED,env);\n  if ((annotationTagBits & TagBits.AnnotationDocumented) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_ANNOTATION_DOCUMENTED,env);\n  if ((annotationTagBits & TagBits.AnnotationInherited) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_ANNOTATION_INHERITED,env);\n  if ((annotationTagBits & TagBits.AnnotationOverride) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE,env);\n  if ((annotationTagBits & TagBits.AnnotationSuppressWarnings) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_SUPPRESSWARNINGS,env);\n  if ((annotationTagBits & TagBits.AnnotationPolymorphicSignature) != 0)   result[index++]=buildMarkerAnnotationForMemberType(TypeConstants.JAVA_LANG_INVOKE_METHODHANDLE_$_POLYMORPHICSIGNATURE,env);\n  if ((annotationTagBits & TagBits.AnnotationSafeVarargs) != 0)   result[index++]=buildMarkerAnnotation(TypeConstants.JAVA_LANG_SAFEVARARGS,env);\n  return result;\n}\n", "docstring": "add the standard annotations encoded in the tag bits to the recorded annotations .", "partition": "test"}
{"idx": "3472", "code": "@Override public String toString(){\n  String result=\"RandomSplitResultProducer: \";\n  result+=getCompatibilityState();\n  if (m_Instances == null) {\n    result+=\": <null Instances>\";\n  }\n else {\n    result+=\": \" + Utils.backQuoteChars(m_Instances.relationName());\n  }\n  return result;\n}\n", "docstring": "gets a text descrption of the result producer .", "partition": "test"}
{"idx": "3473", "code": "public static void process(List<Packages> pkgList) throws Exception {\n  init();\n  String[] temps=templates.split(\",\");\n  String[] vmFiles=new String[temps.length];\n  for (int i=0; i < temps.length; i++) {\n    vmFiles[i]=temps[i] + \".vm\";\n  }\n  for (  Packages pkg : pkgList) {\n    for (    String vmFile : vmFiles) {\n      generator(vmFile,pkg);\n    }\n  }\n}\n", "docstring": "process main logic for create file", "partition": "test"}
{"idx": "3474", "code": "public boolean check(final Direction dir,final boolean facing){\n  if (this.dir != dir) {\n    return false;\n  }\n  if (this.facing != facing) {\n    return false;\n  }\n  final long now=System.currentTimeMillis();\n  if (now >= expiration) {\n    return false;\n  }\n  expiration=now + DELAY;\n  return true;\n}\n", "docstring": "check if a new direction matches the existing one , and if so , reset the expiration point .", "partition": "test"}
{"idx": "3475", "code": "private void parse(String path) throws Exception {\n  if (path != null) {\n    count=path.length();\n    data=new char[count];\n    path.getChars(0,count,data,0);\n  }\n  path();\n}\n", "docstring": "this method is used to parse the provided xpath expression . when parsing the expression this will trim any references to the root context , also any trailing slashes are removed . an exception is thrown if the path is invalid .", "partition": "test"}
{"idx": "3476", "code": "protected synchronized void readDontVerify() throws IOException, FileEncryptionException {\n  if (backingRandomAccessFile.length() < headerSize()) {\n    throw new FileEncryptionException(\"Invalid file header\");\n  }\n  long oldpos=backingRandomAccessFile.getFilePointer();\n  backingRandomAccessFile.seek(0);\n  byte[] header_data=new byte[headerSize() - FileHeader.AUTH_TAG_SIZE];\n  backingRandomAccessFile.read(header_data);\n  backingRandomAccessFile.seek(oldpos);\n  DataInputStream istream=new DataInputStream(new ByteArrayInputStream(header_data));\n  byte[] tmpmagic=new byte[PANBOX_FILE_MAGIC.length];\n  istream.read(tmpmagic);\n  if (!Arrays.equals(tmpmagic,PANBOX_FILE_MAGIC)) {\n    throw new FileEncryptionException(\"Invalid magic number in file header\");\n  }\n  byte[] tmpversion=new byte[PANBOX_FILE_VERSION.length];\n  istream.read(tmpversion);\n  if (!Arrays.equals(tmpversion,PANBOX_FILE_VERSION)) {\n    throw new FileEncryptionException(\"Invalid version in file header. Expected version is \" + PANBOX_FILE_VERSION.toString());\n  }\n  this.shareKeyVersion=istream.readInt();\n  istream.close();\n}\n", "docstring": "reads magic + share key version without verification", "partition": "test"}
{"idx": "3477", "code": "private boolean isMediaTypeSupported(String media){\n  for (int i=0; i < SUPPORTED_MEDIA_TYPES.length; i++) {\n    if (media.equalsIgnoreCase(SUPPORTED_MEDIA_TYPES[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the specified css media type is unsupported , false otherwise", "partition": "test"}
{"idx": "3478", "code": "private void export_dependencies(JCas jcas){\n  dependencies=new LinkedHashMap<Token,List<Dependency>>();\n  List<Token> nonGoverned=new ArrayList<Token>(nodes.keySet());\n  for (  Dependency dependency : select(jcas,Dependency.class)) {\n    Token governor=dependency.getGovernor();\n    Token dependent=dependency.getDependent();\n    List<Dependency> l=dependencies.get(governor);\n    if (l == null) {\n      dependencies.put(governor,new ArrayList<Dependency>());\n      l=dependencies.get(governor);\n    }\n    l.add(dependency);\n    nonGoverned.remove(dependent);\n  }\n  for (  Token t : nonGoverned) {\n    traverseDependents(t,\"\",-1);\n    writeToFile(\"component\",componentId,\"p\",\"dep\",\"dep\");\n    componentId++;\n  }\n}\n", "docstring": "traverse the dependency structure beginning from all \" roots \" , i . e . non - governed tokens .", "partition": "test"}
{"idx": "3479", "code": "public static boolean isNetworkAvailable(Context context){\n  ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo info=connectivityManager.getActiveNetworkInfo();\n  return info != null && info.isConnected();\n}\n", "docstring": "returns network availability status .", "partition": "test"}
{"idx": "3480", "code": "public static String randomRegexpishString(Random r){\n  return randomRegexpishString(r,20);\n}\n", "docstring": "returns a string thats \" regexpish \" ( contains lots of operators typically found in regular expressions ) if you call this enough times , you might get a valid regex !", "partition": "test"}
{"idx": "3481", "code": "public List<ExpectedPartitionValueEntity> createExpectedPartitionValueEntities(String partitionKeyGroupName,List<String> expectedPartitionValues){\n  PartitionKeyGroupEntity partitionKeyGroupEntity=partitionKeyGroupDao.getPartitionKeyGroupByName(partitionKeyGroupName);\n  if (partitionKeyGroupEntity == null) {\n    partitionKeyGroupEntity=partitionKeyGroupDaoTestHelper.createPartitionKeyGroupEntity(partitionKeyGroupName);\n  }\n  List<ExpectedPartitionValueEntity> expectedPartitionValueEntities=new ArrayList<>();\n  for (  String expectedPartitionValue : expectedPartitionValues) {\n    ExpectedPartitionValueEntity expectedPartitionValueEntity=new ExpectedPartitionValueEntity();\n    expectedPartitionValueEntity.setPartitionKeyGroup(partitionKeyGroupEntity);\n    expectedPartitionValueEntity.setPartitionValue(expectedPartitionValue);\n    expectedPartitionValueEntities.add(expectedPartitionValueDao.saveAndRefresh(expectedPartitionValueEntity));\n  }\n  return expectedPartitionValueEntities;\n}\n", "docstring": "creates and persists specified partition value entities . this method also creates and persists a partition key group entity , if it does not exist .", "partition": "test"}
{"idx": "3482", "code": "public String toString(){\n  return text();\n}\n", "docstring": "returns the text of this gpathresult .", "partition": "test"}
{"idx": "3483", "code": "public static LowMemoryWatcher register(@NotNull Runnable runnable){\n  return new LowMemoryWatcher(runnable);\n}\n", "docstring": "registers a runnable to run on low memory events", "partition": "test"}
{"idx": "3484", "code": "public Object extractHardRef(Object o){\n  SoftReference w=(SoftReference)o;\n  if (w != null) {\n    return w.get();\n  }\n  return null;\n}\n", "docstring": "extracts the hard reference from the soft / weak reference given", "partition": "test"}
{"idx": "3485", "code": "public static String formatLong(long number){\n  return intFormat.format(number);\n}\n", "docstring": "formats a long value . for example : input = 1234567 / output = 1 , 234 , 567 .", "partition": "test"}
{"idx": "3486", "code": "public synchronized int copyDirect(int pageId,OutputStream out) throws IOException {\n  byte[] buffer=new byte[pageSize];\n  if (pageId >= pageCount) {\n    return -1;\n  }\n  file.seek((long)pageId << pageSizeShift);\n  file.readFullyDirect(buffer,0,pageSize);\n  readCount++;\n  out.write(buffer,0,pageSize);\n  return pageId + 1;\n}\n", "docstring": "copy the next page to the output stream .", "partition": "test"}
{"idx": "3487", "code": "public void writeRawBytes(final byte[] value,int offset,int length) throws IOException {\n  if (limit - position >= length) {\n    System.arraycopy(value,offset,buffer,position,length);\n    position+=length;\n  }\n else {\n    throw new OutOfSpaceException(position,limit);\n  }\n}\n", "docstring": "write part of an array of bytes .", "partition": "test"}
{"idx": "3488", "code": "private void assertBackupStatus(final BackupStatus backupStatus){\n  Map<DistributedMember,Set<PersistentID>> backupMap=backupStatus.getBackedUpDiskStores();\n  assertFalse(backupMap.isEmpty());\n  for (  DistributedMember member : backupMap.keySet()) {\n    for (    PersistentID id : backupMap.get(member)) {\n      assertNotNull(id.getHost());\n      assertNotNull(id.getUUID());\n      assertNotNull(id.getDirectory());\n    }\n  }\n}\n", "docstring": "used to confirm valid backupstatus data . confirms fix for defect # 45657", "partition": "test"}
{"idx": "3489", "code": "@RequestMapping(value=\"/SAML2/Metadata/{tenant:.*}\") public void metadataError(Locale locale,@PathVariable(value=\"tenant\") String tenant,HttpServletResponse response) throws IOException {\n  logger.info(\"Metadata binding error! The client locale is {}, tenant is {}\",locale.toString(),tenant);\n  metadataDefaultTenantBindingError(locale,response);\n}\n", "docstring": "handle request sent with a wrong binding", "partition": "test"}
{"idx": "3490", "code": "public synchronized void checkState(State... requiredStates) throws IllegalStateException {\n  for (  State requiredState : requiredStates) {\n    if (requiredState.equals(currentState)) {\n      return;\n    }\n  }\n  throw new IllegalStateException(String.format(Locale.US,\"Expected states %s, but in state %s\",Lists.newArrayList(requiredStates),currentState));\n}\n", "docstring": "checks that the machine is in one of the given states . throws if it isn \"'\" t .", "partition": "test"}
{"idx": "3491", "code": "public void sortMovies(){\nsynchronized (movies) {\n    Utils.sortList(movies,MOVIE_SET_COMPARATOR);\n    movieIds.clear();\n    for (    Movie movie : movies) {\n      movieIds.add(movie.getDbId());\n    }\n  }\n  firePropertyChange(\"movies\",null,movies);\n}\n", "docstring": "sort movies inside this movie set by using either the sort title , release date or year .", "partition": "test"}
{"idx": "3492", "code": "public KeyValueListParser(String pairDelimiterRegex,String keyValDelimiterRegex){\n  pairDelimiter=Pattern.compile(pairDelimiterRegex);\n  keyValDelimiter=Pattern.compile(keyValDelimiterRegex);\n}\n", "docstring": "create a parser that uses the given regexes to parse a list of key value pairs .", "partition": "test"}
{"idx": "3493", "code": "private synchronized boolean pollStatsBroker(Destination queue){\n  statsMessageListener.setDestination(queue);\n  Timestamp timestamp=new Timestamp(System.currentTimeMillis());\n  LOGGER.debug(\"Setting the destination to \" + getQueueName(queue) + \" at \"+ timestamp);\n  jmsTemplate.execute(STATS_BROKER_DESTINATION + getQueueName(queue),new ProducerCallbackImpl(statsQueue));\n  try {\n    Thread.sleep(3 * 1000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return statsMessageListener.getStats() != null;\n}\n", "docstring": "poll the statistics broker plugin", "partition": "test"}
{"idx": "3494", "code": "public File makeAcceptable(File pathname){\n  if (accept(pathname)) {\n    return pathname;\n  }\n else {\n    return new File(pathname.getPath() + '.' + defaultExtension);\n  }\n}\n", "docstring": "appends the extension to the filename , in case it is missing .", "partition": "test"}
{"idx": "3495", "code": "public String jsTypeName(TypeRef typeRef){\nswitch (typeRef.getKind()) {\ncase TYPE_MESSAGE:\n    return \"Object\";\ncase TYPE_ENUM:\n  return \"number\";\ndefault :\n{\n  String name=PRIMITIVE_TYPE_NAMES.get(typeRef.getKind());\n  if (!Strings.isNullOrEmpty(name)) {\n    return name;\n  }\n  throw new IllegalArgumentException(\"unknown type kind: \" + typeRef.getKind());\n}\n}\n}\n", "docstring": "returns the name of js type for the given typeref .", "partition": "test"}
{"idx": "3496", "code": "public StateMachine createStateMachine(StateMachineDefinition stateMachineDefinition){\n  final Map<EventDefinition,EventData> eventDataMap=stateMachineDefinition.getEventDataMap();\n  Set<Event> allEvents=createAllEvents(eventDataMap);\n  Set<StateDefinition> stateDefinitions=stateMachineDefinition.getStates();\n  Set<State> states=new HashSet<>();\n  for (  StateDefinition stateDefinition : stateDefinitions) {\n    State state=convertStateDefinitionToState(stateDefinition);\n    states.add(state);\n  }\n  StateMachine stateMachine=new StateMachine(stateMachineDefinition.getVersion(),stateMachineDefinition.getName(),stateMachineDefinition.getDescription(),states,stateMachineDefinition.getCorrelationId());\n  stateMachinesDAO.create(stateMachine);\n  for (  Event event : allEvents) {\n    event.setStateMachineInstanceId(stateMachine.getId());\n    eventPersistenceService.persistEvent(event);\n  }\n  for (  State state : stateMachine.getStates()) {\n    auditDAO.create(new AuditRecord(stateMachine.getId(),state.getId(),0L,Status.initialized,null,null));\n  }\n  return stateMachine;\n}\n", "docstring": "converts state machine definition to state machine domain object and saves in db .", "partition": "test"}
{"idx": "3497", "code": "public void dispose(){\n  clearListeners();\n  if (attributes != null) {\n    attributes.clear();\n  }\n  removed(null);\n}\n", "docstring": "method called when layer detects that it has been removed from maphandler , assumes it \"'\" s being thrown away . use this method to let go of everything and to make any calls necessary to remove from listener lists that might not get picked up via maphandler calls .", "partition": "test"}
{"idx": "3498", "code": "public static terminal find(String with_name){\n  if (with_name == null)   return null;\n else   return (terminal)_all.get(with_name);\n}\n", "docstring": "lookup a terminal by name string .", "partition": "test"}
{"idx": "3499", "code": "public LayoutBlock createNewLayoutBlock(String systemName,String userName){\n  LayoutBlock block=null;\n  if (userName == null || userName.equals(\"\")) {\n    log.error(\"Attempt to create a LayoutBlock with no user name\");\n    return null;\n  }\n  block=getByUserName(userName);\n  if (block != null) {\n    return null;\n  }\n  String sName=\"\";\n  if (systemName == null) {\n    boolean found=true;\n    while (found) {\n      sName=\"ILB\" + blkNum;\n      blkNum++;\n      block=getBySystemName(sName);\n      if (block == null) {\n        found=false;\n      }\n    }\n  }\n else {\n    block=getBySystemName((systemName.toUpperCase()));\n    if (block != null) {\n      return null;\n    }\n    sName=systemName.toUpperCase();\n  }\n  block=new LayoutBlock(sName,userName);\n  register(block);\n  return block;\n}\n", "docstring": "method to create a new layoutblock if the layoutblock does not exist returns null if a layoutblock with the same systemname or username already exists , or if there is trouble creating a new layoutblock . note that since the username is used to address layoutblocks , the user name must be present . if the user name is not present , the new layoutblock is not created , and null is returned .", "partition": "test"}
{"idx": "3500", "code": "@Override public void modifyNonstaticJPedalParameters(final Map values) throws PdfException {\n  options.set(values);\n  if (values.containsKey(JPedalSettings.DISPLAY_BACKGROUND)) {\n  }\n}\n", "docstring": "allow user to alter certain values in software such as colour , please note all color and text highlighting values are static and common across the jvm", "partition": "test"}
{"idx": "3501", "code": "public static String escapeRegex(final String regex){\n  Matcher match=REGEX_CHARS.matcher(regex);\n  return match.replaceAll(\"\\\\\\\\$1\");\n}\n", "docstring": "this function will escape special characters within a string to ensure that the string will not be parsed as a regular expression . this is helpful with accepting using input that needs to be used in functions that take a regular expression as an argument ( such as string . replaceall ( ) , or string . split ( ) ) .", "partition": "test"}
{"idx": "3502", "code": "public CharBuffer(String string){\n  int length=string.length();\n  int capacity=length + MIN_CAPACITY;\n  init(new char[capacity],0,length);\n  string.getChars(0,length,buffer(),0);\n}\n", "docstring": "constructs a char buffer with the given initial string", "partition": "test"}
{"idx": "3503", "code": "private void updatePromoVisibility(float percentage){\n  if (isPromoAvailable()) {\n    mPromoVisible=true;\n    mPromoHeightPx=Math.round(MathUtils.clamp(percentage * mPromoContentHeightPx,0.f,mPromoContentHeightPx));\n    mPromoOpacity=percentage;\n  }\n else {\n    mPromoVisible=false;\n    mPromoHeightPx=0.f;\n    mPromoOpacity=0.f;\n  }\n}\n", "docstring": "updates the ui state for opt out promo .", "partition": "test"}
{"idx": "3504", "code": "private ValueGeometry(byte[] bytes,Geometry geometry){\n  this.bytes=bytes;\n  this.geometry=geometry;\n  this.hashCode=Arrays.hashCode(bytes);\n}\n", "docstring": "create a new geometry objects .", "partition": "test"}
{"idx": "3505", "code": "@Override public void do_after_propagation(){\n  for (  HeapInsIntervalManager im : new_pts.values()) {\n    im.flush();\n  }\n  new_pts=new HashMap<AllocNode,HeapInsIntervalManager>();\n}\n", "docstring": "remember to clean the is_new flag", "partition": "test"}
{"idx": "3506", "code": "private void finishCommon(){\n  if (!unknownSubjects.isEmpty()) {\n    if (statements.isEmpty() && restoredStatements.isEmpty()) {\n      throw new BadSubjectException(unknownSubjects.keySet(),uris);\n    }\n else {\n      log.info(\"Unrecognized subjects: {}.  Expected only sitelinks and subjects starting with {} and {}\",unknownSubjects.keySet(),uris.entityData(),uris.entity());\n    }\n  }\n  if (revisionId == null) {\n    throw new ContainedException(\"Didn\'t get a revision id for \" + statements);\n  }\n  if (lastModified == null) {\n    throw new ContainedException(\"Didn\'t get a last modified date for \" + statements);\n  }\n  for (  Pair<URI,Literal> dataStatement : dataStatements) {\n    statements.add(new StatementImpl(entityUriImpl,dataStatement.getLeft(),dataStatement.getRight()));\n  }\n  statements.addAll(restoredStatements);\n}\n", "docstring": "perform all munge completion tasks that are required no matter the configuration . its important that finishcommon be the last finish method called because it is the one that restores restoredstatments into the original statements collection .", "partition": "test"}
{"idx": "3507", "code": "public static final void showGUIMessage(final String user_message,final BufferedImage image,final String title){\n  if (image == null) {\n    return;\n  }\n  final ImagePanel display=new ImagePanel(image);\n  display.setLayout(new BorderLayout());\n  if (user_message != null) {\n    display.add(new JLabel(user_message),BorderLayout.SOUTH);\n  }\n  final int width=image.getWidth();\n  final int height=image.getHeight();\n  display.setSize(new Dimension(width + 10,height + 10));\n  JOptionPane.showConfirmDialog(contentPane,display,title,JOptionPane.DEFAULT_OPTION,JOptionPane.PLAIN_MESSAGE);\n}\n", "docstring": "display message if in gui mode", "partition": "test"}
{"idx": "3508", "code": "private void dynInit(){\n}\n", "docstring": "dynamic init . table layout , visual , listener", "partition": "test"}
{"idx": "3509", "code": "@Override public Path call() throws Exception {\n  final Set<FileVisitOption> options;\n  if (followLinks) {\n    options=EnumSet.of(FileVisitOption.FOLLOW_LINKS);\n  }\n else {\n    options=EnumSet.noneOf(FileVisitOption.class);\n  }\n  logger.info(String.format(\"Starting scan of: \\\"%s\\\".\",path));\n  try {\n    Files.walkFileTree(path,options,maxDepth,this);\n  }\n catch (  IOException e) {\n    logger.log(Level.SEVERE,String.format(\"Error while scanning path: \\\"%s\\\".\",path),e);\n    throw e;\n  }\n  logger.info(String.format(\"Completed scan of: \\\"%s\\\".\",path));\n  return path;\n}\n", "docstring": "recursively walks the file tree of a directory .", "partition": "test"}
{"idx": "3510", "code": "private void baselineLayout(int origin,int size){\n  int ascent;\n  int descent;\n  if (baselineAnchoredToTop) {\n    ascent=prefAscent;\n    descent=size - ascent;\n  }\n else {\n    ascent=size - prefDescent;\n    descent=prefDescent;\n  }\n  for (  Spring spring : springs) {\n    Alignment alignment=spring.getAlignment();\n    if (alignment == null || alignment == Alignment.BASELINE) {\n      int baseline=spring.getBaseline();\n      if (baseline >= 0) {\n        int springMax=spring.getMaximumSize(VERTICAL);\n        int springPref=spring.getPreferredSize(VERTICAL);\n        int height=springPref;\n        int y;\nswitch (spring.getBaselineResizeBehavior()) {\ncase CONSTANT_ASCENT:\n          y=origin + ascent - baseline;\n        height=Math.min(descent,springMax - baseline) + baseline;\n      break;\ncase CONSTANT_DESCENT:\n    height=Math.min(ascent,springMax - springPref + baseline) + (springPref - baseline);\n  y=origin + ascent + (springPref - baseline) - height;\nbreak;\ndefault :\ny=origin + ascent - baseline;\nbreak;\n}\nspring.setSize(VERTICAL,y,height);\n}\n else {\nsetChildSize(spring,VERTICAL,origin,size);\n}\n}\n else {\nsetChildSize(spring,VERTICAL,origin,size);\n}\n}\n}\n", "docstring": "lays out springs that have a baseline along the baseline . all others are centered .", "partition": "test"}
{"idx": "3511", "code": "public static int readInt(final JSONArray jsonArray,final int index,final boolean required,final boolean notNull) throws JSONException {\n  if (required) {\n    return jsonArray.getInt(index);\n  }\n  if (notNull && jsonArray.isNull(index)) {\n    throw new JSONException(String.format(Locale.US,NULL_VALUE_FORMAT_ARRAY,index));\n  }\n  int value=0;\n  if (!jsonArray.isNull(index)) {\n    value=jsonArray.getInt(index);\n  }\n  return value;\n}\n", "docstring": "reads the int value from the json array for specified index", "partition": "test"}
{"idx": "3512", "code": "private void validateStoragePolicySelection(StoragePolicySelection storagePolicySelection){\n  Assert.notNull(storagePolicySelection,\"A storage policy selection must be specified.\");\n  businessObjectDataHelper.validateBusinessObjectDataKey(storagePolicySelection.getBusinessObjectDataKey(),true,true);\n  storagePolicyHelper.validateStoragePolicyKey(storagePolicySelection.getStoragePolicyKey());\n  Assert.notNull(storagePolicySelection.getStoragePolicyVersion(),\"A storage policy version must be specified.\");\n}\n", "docstring": "validates the storage policy selection . this method also trims the request parameters .", "partition": "test"}
{"idx": "3513", "code": "@Override public String toString(){\n  StringBuffer text=new StringBuffer();\n  if (m_cobwebTree == null) {\n    return \"Cobweb hasn\'t been built yet!\";\n  }\n else {\n    m_cobwebTree.dumpTree(0,text);\n    return \"Number of merges: \" + m_numberMerges + \"\\nNumber of splits: \"+ m_numberSplits+ \"\\nNumber of clusters: \"+ numberOfClusters()+ \"\\n\"+ text.toString()+ \"\\n\\n\";\n  }\n}\n", "docstring": "returns a description of the clusterer as a string .", "partition": "test"}
{"idx": "3514", "code": "public static Object toArray(Collection<?> collection,Class<?> componentType){\n  if (componentType.isPrimitive()) {\n    Object array=Array.newInstance(componentType,collection.size());\n    int index=0;\n    for (    Object value : collection) {\n      Array.set(array,index++,value);\n    }\n    return array;\n  }\n  return collection.toArray((Object[])Array.newInstance(componentType,collection.size()));\n}\n", "docstring": "returns a new array of the given component type ( possibly a java primitive ) that is a copy of the content of the given collection .", "partition": "test"}
{"idx": "3515", "code": "GradleException formatViolationsFor(Formatter formatter,List<File> problemFiles) throws IOException {\n  return new GradleException(DiffMessageFormatter.messageFor(this,formatter,problemFiles));\n}\n", "docstring": "returns an exception which indicates problem files nicely .", "partition": "test"}
{"idx": "3516", "code": "public void labelDistances(Hypergraph<V,E> graph,V root){\n  labelDistances(graph,Collections.singleton(root));\n}\n", "docstring": "computes the distances of all the node from the specified root node . also keeps track of the predecessors of each node traversed as well as the order of nodes traversed .", "partition": "test"}
{"idx": "3517", "code": "public static java.lang.String toString(float d){\n  float m=Math.abs(d);\n  if (d == POSITIVE_INFINITY) {\n    return \"Infinity\";\n  }\n else   if (d == NEGATIVE_INFINITY) {\n    return \"-Infinity\";\n  }\n else   if (d == 0) {\n    return \"0.0\";\n  }\n else   if (m >= 1e-3 && m < 1e7) {\n    String str=toStringImpl(d,false);\n    char[] chars=str.toCharArray();\n    int i=chars.length - 1;\n    char c;\n    while (i >= 0 && (c=chars[i]) == \'0\') {\n      i--;\n    }\n    if (i < 0 || str.indexOf(\'.\') == -1) {\n      return str;\n    }\n else     if (chars[i] == \'.\' || chars[i] == \',\') {\n      i++;\n    }\n    return str.substring(0,i + 1);\n  }\n else {\n    return toStringImpl(d,true);\n  }\n}\n", "docstring": "returns a string representation for the specified float value . the argument is converted to a readable string format as follows . all characters and characters in strings mentioned below are ascii characters . if the argument is nan , the result is the string \" nan \" . otherwise , the result is a string that represents the sign and magnitude ( absolute value ) of the argument . if the sign is negative , the first character of the result is \"'\" - \"'\" ( \"'\" - \"'\" ) ; if the sign is positive , no sign character appears in the result . as for the magnitude m : if m is infinity , it is represented by the characters \" infinity \" ; thus , positive infinity produces the result \" infinity \" and negative infinity produces the result \" - infinity \" . if m is zero , it is represented by the characters \" 0 . 0 \" ; thus , negative zero produces the result \" - 0 . 0 \" and positive zero produces the result \" 0 . 0 \" . if m is greater than or equal to 10 - 3 but less than 107 , then it is represented as the integer part of m , in decimal form with no leading zeroes , followed by \"'\" . \"'\" ( . ) , followed by one or more decimal digits representing the fractional part of m . if m is less than 10 - 3 or not less than 107 , then it is represented in so - called \" computerized scientific notation . \" let n be the unique integer such that 10n = m 1 ; then let a be the mathematically exact quotient of m and 10n so that 1 a & lt10 . the magnitude is then represented as the integer part of a , as a single decimal digit , followed by \"'\" . \"'\" ( . ) , followed by decimal digits representing the fractional part of a , followed by the letter \"'\" e \"'\" ( e ) , followed by a representation of n as a decimal integer , as produced by the method of one argument . how many digits must be printed for the fractional part of m or a ? there must be at least one digit to represent the fractional part , and beyond that as many , but only as many , more digits as are needed to uniquely distinguish the argument value from adjacent values of type float . that is , suppose that x is the exact mathematical value represented by the decimal representation produced by this method for a finite nonzero argument f . then f must be the float value nearest to x ; or , if two float values are equally close to xthen f must be one of them and the least significant bit of the significand of f must be 0 .", "partition": "test"}
{"idx": "3518", "code": "public int position(){\n  return lineBuffer == null ? 0 : lineBuffer.length();\n}\n", "docstring": "gets the current column position of this log stream .", "partition": "test"}
{"idx": "3519", "code": "public final static HeaderElement parseHeaderElement(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=SaveHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  SaveParserCursor cursor=new SaveParserCursor(0,value.length());\n  return parser.parseHeaderElement(buffer,cursor);\n}\n", "docstring": "parses an element with the given parser .", "partition": "test"}
{"idx": "3520", "code": "public static List<Interval> sliceIntervals(Interval interval,TimeGrain timeGrain){\n  DateTime intervalEnd=interval.getEnd();\n  DateTime sliceStart=interval.getStart();\n  DateTime periodStart=timeGrain.roundFloor(sliceStart);\n  if (!sliceStart.equals(periodStart)) {\n    LOG.info(\"Interval {} is not aligned to TimeGrain {} starting {}\",interval,timeGrain,periodStart);\n    throw new IllegalArgumentException(\"Interval must be aligned to the TimeGrain starting \" + periodStart);\n  }\n  List<Interval> intervalSlices=new ArrayList<>();\n  while (sliceStart.isBefore(intervalEnd)) {\n    DateTime sliceEnd=DateTimeUtils.addTimeGrain(sliceStart,timeGrain);\n    Interval slicedInterval=new Interval(sliceStart,sliceEnd);\n    if (!interval.contains(slicedInterval)) {\n      LOG.info(\"Interval {} is not a multiple of TimeGrain {}\",interval,timeGrain);\n      throw new IllegalArgumentException(\"Interval must be a multiple of the TimeGrain\");\n    }\n    intervalSlices.add(slicedInterval);\n    sliceStart=sliceEnd;\n  }\n  LOG.debug(\"Sliced interval {} into {} slices of {} grain\",interval,intervalSlices.size(),timeGrain);\n  return intervalSlices;\n}\n", "docstring": "slices the intervals into smaller intervals of the timegrain duration .", "partition": "test"}
{"idx": "3521", "code": "public boolean isGerund(){\n  return typeString.startsWith(VERB_GERUND);\n}\n", "docstring": "determine if the expression contains a verb in gerund form .", "partition": "test"}
{"idx": "3522", "code": "private JsonObject createRequest(Map<String,Object> headers,String uri,HttpMethod method,JsonObject payload){\n  JsonObject request=new JsonObject();\n  JsonArray jsonHeaders=new JsonArray();\n  headers.forEach(null);\n  request.put(\"headers\",jsonHeaders);\n  request.put(\"uri\",uri);\n  request.put(\"method\",method.toString());\n  request.put(\"payload\",payload);\n  return request;\n}\n", "docstring": "creates a new request with the given parameters .", "partition": "test"}
{"idx": "3523", "code": "private long downloadTlogFiles(File tmpTlogDir,long latestGeneration) throws Exception {\n  LOG.info(\"Starting download of tlog files from master: \" + tlogFilesToDownload);\n  tlogFilesDownloaded=Collections.synchronizedList(new ArrayList<>());\n  long bytesDownloaded=0;\n  boolean status=tmpTlogDir.mkdirs();\n  if (!status) {\n    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\"Failed to create temporary tlog folder: \" + tmpTlogDir.getName());\n  }\n  for (  Map<String,Object> file : tlogFilesToDownload) {\n    String saveAs=(String)(file.get(ALIAS) == null ? file.get(NAME) : file.get(ALIAS));\n    localFileFetcher=new LocalFsFileFetcher(tmpTlogDir,file,saveAs,TLOG_FILE,latestGeneration);\n    currentFile=file;\n    localFileFetcher.fetchFile();\n    bytesDownloaded+=localFileFetcher.getBytesDownloaded();\n    tlogFilesDownloaded.add(new HashMap<>(file));\n  }\n  return bytesDownloaded;\n}\n", "docstring": "download all the tlog files to the temp tlog directory .", "partition": "test"}
{"idx": "3524", "code": "static WindowsFileAttributes readAttributes(long handle) throws WindowsException {\n  NativeBuffer buffer=NativeBuffers.getNativeBuffer(SIZEOF_FILE_INFORMATION);\n  try {\n    long address=buffer.address();\n    GetFileInformationByHandle(handle,address);\n    int reparseTag=0;\n    int fileAttrs=unsafe.getInt(address + OFFSETOF_FILE_INFORMATION_ATTRIBUTES);\n    if (isReparsePoint(fileAttrs)) {\n      int size=MAXIMUM_REPARSE_DATA_BUFFER_SIZE;\n      NativeBuffer reparseBuffer=NativeBuffers.getNativeBuffer(size);\n      try {\n        DeviceIoControlGetReparsePoint(handle,reparseBuffer.address(),size);\n        reparseTag=(int)unsafe.getLong(reparseBuffer.address());\n      }\n  finally {\n        reparseBuffer.release();\n      }\n    }\n    return fromFileInformation(address,reparseTag);\n  }\n  finally {\n    buffer.release();\n  }\n}\n", "docstring": "reads the attributes of an open file", "partition": "test"}
{"idx": "3525", "code": "protected void addAllForReplay(Collection<Participant> participants){\n  Iterator<Participant> it=participants.iterator();\n  while (it.hasNext()) {\n    Participant p=it.next();\n    replayCompletion(p);\n  }\n}\n", "docstring": "utility method for subclasses .", "partition": "test"}
{"idx": "3526", "code": "public static JPanel createCheckbox(String boxlabel,String[] buttons,boolean[] checked,ActionListener al){\n  JPanel jp=createPaletteJPanel(boxlabel);\n  for (int j=0; j < buttons.length; j++) {\n    JCheckBox jcb=new JCheckBox(buttons[j]);\n    jcb.setActionCommand(Integer.toString(j));\n    if (al != null)     jcb.addActionListener(al);\n    jcb.setSelected(checked[j]);\n    jp.add(jcb);\n  }\n  return jp;\n}\n", "docstring": "create a panel containing a checkbox .", "partition": "test"}
{"idx": "3527", "code": "public static void copy(DimensionsEvent aeDest,DimensionsEvent aeSrc){\n  GPOMutable destAggs=aeDest.getAggregates();\n  GPOMutable srcAggs=aeSrc.getAggregates();\n  if (srcAggs.getFieldsBoolean() != null) {\n    System.arraycopy(srcAggs.getFieldsBoolean(),0,destAggs.getFieldsBoolean(),0,srcAggs.getFieldsBoolean().length);\n  }\n  if (srcAggs.getFieldsCharacter() != null) {\n    System.arraycopy(srcAggs.getFieldsCharacter(),0,destAggs.getFieldsCharacter(),0,srcAggs.getFieldsCharacter().length);\n  }\n  if (srcAggs.getFieldsString() != null) {\n    System.arraycopy(srcAggs.getFieldsString(),0,destAggs.getFieldsString(),0,srcAggs.getFieldsString().length);\n  }\n  if (srcAggs.getFieldsShort() != null) {\n    System.arraycopy(srcAggs.getFieldsShort(),0,destAggs.getFieldsShort(),0,srcAggs.getFieldsShort().length);\n  }\n  if (srcAggs.getFieldsInteger() != null) {\n    System.arraycopy(srcAggs.getFieldsInteger(),0,destAggs.getFieldsInteger(),0,srcAggs.getFieldsInteger().length);\n  }\n  if (srcAggs.getFieldsLong() != null) {\n    System.arraycopy(srcAggs.getFieldsLong(),0,destAggs.getFieldsLong(),0,srcAggs.getFieldsLong().length);\n  }\n  if (srcAggs.getFieldsFloat() != null) {\n    System.arraycopy(srcAggs.getFieldsFloat(),0,destAggs.getFieldsFloat(),0,srcAggs.getFieldsFloat().length);\n  }\n  if (srcAggs.getFieldsDouble() != null) {\n    System.arraycopy(srcAggs.getFieldsDouble(),0,destAggs.getFieldsDouble(),0,srcAggs.getFieldsDouble().length);\n  }\n}\n", "docstring": "this is a utility method which copies the given src event to the given destination event .", "partition": "test"}
{"idx": "3528", "code": "public static double assignProbabilitiesToInstances(Relation<? extends NumberVector> relation,List<? extends EMClusterModel<?>> models,WritableDataStore<double[]> probClusterIGivenX){\n  final int k=models.size();\n  double emSum=0.;\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    NumberVector vec=relation.get(iditer);\n    double[] probabilities=new double[k];\n{\n      int i=0;\n      for (      EMClusterModel<?> m : models) {\n        probabilities[i]=m.estimateDensity(vec);\n        ++i;\n      }\n    }\n    double priorProbability=0.;\n    for (int i=0; i < k; i++) {\n      priorProbability+=probabilities[i];\n    }\n    double logP=Math.max(Math.log(priorProbability),MIN_LOGLIKELIHOOD);\n    emSum+=(logP == logP) ? logP : 0.;\n    double[] clusterProbabilities=new double[k];\n    if (priorProbability > 0.) {\n      for (int i=0; i < k; i++) {\n        clusterProbabilities[i]=probabilities[i] / priorProbability;\n      }\n    }\n    probClusterIGivenX.put(iditer,clusterProbabilities);\n  }\n  return emSum / relation.size();\n}\n", "docstring": "assigns the current probability values to the instances in the database and compute the expectation value of the current mixture of distributions . computed as the sum of the logarithms of the prior probability of each instance .", "partition": "test"}
{"idx": "3529", "code": "public static String asString(URI value){\n  return value != null ? value.toString() : null;\n}\n", "docstring": "gets the value of the uri as a string , returns null if the uri is null .", "partition": "test"}
{"idx": "3530", "code": "public Kernel(int offset,double[] values){\n  this.values=Arrays.copyOf(values,values.length);\n  this.offset=offset;\n}\n", "docstring": "creates a new kernel object with the specified offset and values .", "partition": "test"}
{"idx": "3531", "code": "private void initializeWorkList(){\n  for (  GVCongruenceClass c : B) {\n    if (c.size() == 1) {\n      continue;\n    }\n    Iterator<ValueGraphVertex> i=c.iterator();\n    ValueGraphVertex first=i.next();\n    while (i.hasNext()) {\n      ValueGraphVertex v=i.next();\n      if (!checkCongruence(first,v)) {\n        workList.push(c);\n        break;\n      }\n    }\n  }\n}\n", "docstring": "initialize the work list . a congruence class gets put on the work list if any two nodes in the class point to corresponding targets in separate partitions .", "partition": "test"}
{"idx": "3532", "code": "@Override protected void beforeModelLinked(EObject model,IDiagnosticConsumer diagnosticsConsumer){\n  ImportedNamesAdapter adapter=ImportedNamesAdapter.find(model.eResource());\n  if (adapter != null)   adapter.clear();\n  UnionMemberScope.clearCachedComposedMembers(model);\n}\n", "docstring": "removes the imported names before linking and cleans other caches attached to the ast .", "partition": "test"}
{"idx": "3533", "code": "protected abstract void addFile(String relativeFilename) throws CommandException ;\n", "docstring": "runs the dvcs command for adding a new file , e . g . \"'\" git add \"'\" .", "partition": "test"}
{"idx": "3534", "code": "public void treeExpanded(TreeExpansionEvent event){\n  inspectorWindow.updateView(Director.ALL);\n}\n", "docstring": "called whenever an item in the tree has been expanded .", "partition": "test"}
{"idx": "3535", "code": "public void convertInfixToPostfix(String infixExp) throws Exception {\n  m_originalInfix=infixExp;\n  infixExp=Utils.removeSubstring(infixExp,\" \");\n  infixExp=Utils.replaceSubstring(infixExp,\"log\",\"l\");\n  infixExp=Utils.replaceSubstring(infixExp,\"abs\",\"b\");\n  infixExp=Utils.replaceSubstring(infixExp,\"cos\",\"c\");\n  infixExp=Utils.replaceSubstring(infixExp,\"exp\",\"e\");\n  infixExp=Utils.replaceSubstring(infixExp,\"sqrt\",\"s\");\n  infixExp=Utils.replaceSubstring(infixExp,\"floor\",\"f\");\n  infixExp=Utils.replaceSubstring(infixExp,\"ceil\",\"h\");\n  infixExp=Utils.replaceSubstring(infixExp,\"rint\",\"r\");\n  infixExp=Utils.replaceSubstring(infixExp,\"tan\",\"t\");\n  infixExp=Utils.replaceSubstring(infixExp,\"sin\",\"n\");\n  StringTokenizer tokenizer=new StringTokenizer(infixExp,OPERATORS,true);\n  m_postFixExpVector=new Vector<ExpressionComponent>();\n  while (tokenizer.hasMoreTokens()) {\n    String tok=tokenizer.nextToken();\n    if (tok.length() > 1) {\n      handleOperand(tok);\n    }\n else {\n      if (isOperator(tok.charAt(0))) {\n        handleOperator(tok);\n      }\n else {\n        handleOperand(tok);\n      }\n    }\n    m_previousTok=tok;\n  }\n  while (!m_operatorStack.empty()) {\n    String popop=(String)(m_operatorStack.pop());\n    if (popop.charAt(0) == \'(\' || popop.charAt(0) == \')\') {\n      throw new Exception(\"Mis-matched parenthesis!\");\n    }\n    m_postFixExpVector.addElement(new Operator(popop.charAt(0)));\n  }\n}\n", "docstring": "converts a string containing a mathematical expression in infix form to postfix form . the result is stored in the vector m_postfixexpvector", "partition": "test"}
{"idx": "3536", "code": "public boolean hasItem(T object){\nsynchronized (mLock) {\n    return source.contains(object);\n  }\n}\n", "docstring": "determine if the object provide is in this adapter", "partition": "test"}
{"idx": "3537", "code": "private static boolean versionMatches(Integer v1,int v2){\n  if (v1 == null || v1 == 0 || v2 == 0) {\n    return true;\n  }\n  return v1.equals(v2);\n}\n", "docstring": "determines if a kvno matches another kvno . used in the method findkey ( etype , version , keys ) . always returns true if either input is null or zero , in case any side does not have kvno info available . note : zero is included because n / a is not a legal value for kvno in javax . security . auth . kerberos . kerberoskey . therefore , the info that the kvno is n / a might be lost when converting between encryptionkey and kerberoskey .", "partition": "test"}
{"idx": "3538", "code": "protected void onFailedClosingUrlConnection(URLConnection urlConnection,IOException cause){\n}\n", "docstring": "override if you want to get notified if the url connection fails to close . does nothing by default .", "partition": "test"}
{"idx": "3539", "code": "private void onSchemaComplexType(Element schemaComplexType,DatatypeElementFactory elementFactory){\n  Iterator<Element> iter=schemaComplexType.elementIterator(XSD_ATTRIBUTE);\n  while (iter.hasNext()) {\n    Element xsdAttribute=iter.next();\n    String name=xsdAttribute.attributeValue(\"name\");\n    QName qname=getQName(name);\n    XSDatatype dataType=dataTypeForXsdAttribute(xsdAttribute);\n    if (dataType != null) {\n      elementFactory.setAttributeXSDatatype(qname,dataType);\n    }\n  }\n  Element schemaSequence=schemaComplexType.element(XSD_SEQUENCE);\n  if (schemaSequence != null) {\n    onChildElements(schemaSequence,elementFactory);\n  }\n  Element schemaChoice=schemaComplexType.element(XSD_CHOICE);\n  if (schemaChoice != null) {\n    onChildElements(schemaChoice,elementFactory);\n  }\n  Element schemaAll=schemaComplexType.element(XSD_ALL);\n  if (schemaAll != null) {\n    onChildElements(schemaAll,elementFactory);\n  }\n}\n", "docstring": "processes an xml schema & lt ; complextypegt ; tag", "partition": "test"}
{"idx": "3540", "code": "private void pushAnnotatorsRef(String values){\n  annotatorsRef.push(annotatorsRef.peek());\n  setAnnotatorsRef(values);\n}\n", "docstring": "pushes a new level of annotators references and base the new one on the given values .", "partition": "test"}
{"idx": "3541", "code": "public String versionCompact(){\n  return properties.getProperty(\"version.compact\");\n}\n", "docstring": "returns the compact version string for this product , suitable for use in path names and similar cases .", "partition": "test"}
{"idx": "3542", "code": "private void sequenceQuery(QueryEntry entry,ServerSessionContext session,CompletableFuture<QueryResponse> future){\n  if (entry.getSequence() > session.getCommandSequence()) {\n    session.registerSequenceQuery(entry.getSequence(),null);\n  }\n else {\n    indexQuery(entry,future);\n  }\n}\n", "docstring": "sequences the given query .", "partition": "test"}
{"idx": "3543", "code": "public static <T>List<T> rest(List<T> l){\n  return l.subList(1,l.size());\n}\n", "docstring": "get a sublist of all of the elements in the list except for first .", "partition": "test"}
{"idx": "3544", "code": "public void findAndUndo(Object someObj){\n  if (someObj instanceof com.bbn.openmap.MapBean) {\n    logger.fine(\"ProjectionStack removing a MapBean.\");\n    MapBean map=getMapBean();\n    if (map != null && map == (MapBean)someObj) {\n      setMapBean(null);\n    }\n  }\n}\n", "docstring": "look at the object received in a maphandler status message and disconnect from it if necessary .", "partition": "test"}
{"idx": "3545", "code": "public Timestamp recalculateEstimatedCompletionDate(Long priority,Timestamp startDate){\n  if (exist()) {\n    getProductionRunRoutingTasks();\n    if (quantity == null)     getQuantity();\n    Timestamp endDate=null;\n    for (Iterator<GenericValue> iter=productionRunRoutingTasks.iterator(); iter.hasNext(); ) {\n      GenericValue routingTask=iter.next();\n      if (priority.compareTo(routingTask.getLong(\"priority\")) <= 0) {\n        long totalTime=ProductionRun.getEstimatedTaskTime(routingTask,quantity,dispatcher);\n        endDate=TechDataServices.addForward(TechDataServices.getTechDataCalendar(routingTask),startDate,totalTime);\n        routingTask.set(\"estimatedStartDate\",startDate);\n        routingTask.set(\"estimatedCompletionDate\",endDate);\n        startDate=endDate;\n      }\n    }\n    return endDate;\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "recalculated the estimatedcompletiondate property . use the quantity and the estimatedstartdate properties as entries parameters . < br / > read the listroutingtask and for each recalculated and update the estimatedstart and enddate in the object . < br / > no store in the database is done .", "partition": "test"}
{"idx": "3546", "code": "public void addDocumentType(DocumentType documentType){\n  mDocumentTypes.add(documentType);\n}\n", "docstring": "add a document type to the document type list .", "partition": "test"}
{"idx": "3547", "code": "private static Position nextTokenPos(Position pos,Token[][] spec){\n  if (pos == null) {\n    return null;\n  }\n  int nextItem=pos.item + 1;\n  if ((nextItem < spec[pos.line].length) && ((pos.line < pcalEnd.line) || (nextItem < pcalEnd.item))) {\n    return new Position(pos.line,nextItem);\n  }\n  int nextLine=pos.line + 1;\n  while ((nextLine < spec.length) && (spec[nextLine].length == 0)) {\n    nextLine++;\n  }\n  if ((nextLine < spec.length) && ((nextLine < pcalEnd.line) || ((nextLine == pcalEnd.line) && (0 < pcalEnd.item)))) {\n    return new Position(nextLine,0);\n  }\n  return null;\n}\n", "docstring": "returns the position of the next token after position pos in specification spec if that token exists and is in the pluscal algorithm ; otherwise , it returns null . for convenience it returns null if called with a null pos argument .", "partition": "test"}
{"idx": "3548", "code": "public void update(GL10 gl){\n  if (taskQueue.size() > 0) {\n    GLResorceTask res;\n    while ((res=taskQueue.poll()) != null) {\n      res.perform(gl);\n    }\n  }\n}\n", "docstring": "method is called from update cycle , perform all tasks in gl thread", "partition": "test"}
{"idx": "3549", "code": "public static double[] HPDInterval(double proportion,double[] x,int[] indices){\n  double minRange=Double.MAX_VALUE;\n  int hpdIndex=0;\n  final int diff=(int)Math.round(proportion * (double)x.length);\n  for (int i=0; i <= (x.length - diff); i++) {\n    final double minValue=x[indices[i]];\n    final double maxValue=x[indices[i + diff - 1]];\n    final double range=Math.abs(maxValue - minValue);\n    if (range < minRange) {\n      minRange=range;\n      hpdIndex=i;\n    }\n  }\n  return new double[]{x[indices[hpdIndex]],x[indices[hpdIndex + diff - 1]]};\n}\n", "docstring": "determine the highest posterior density for a list of values . the hpd is the smallest interval containing the required amount of elements .", "partition": "test"}
{"idx": "3550", "code": "private void checkIfDirectoriesExist(File[] disk_dirs){\n  DiskStoreFactoryImpl.checkIfDirectoriesExist(disk_dirs);\n}\n", "docstring": "checks if directories exist", "partition": "test"}
{"idx": "3551", "code": "public void addPortToAlreadyAllocatedContext(StoragePort port,StorageHADomain haDomain,StorageSystem.Type arrayType,String switchName){\n  String engine=getEngine(port,haDomain,arrayType);\n  if (engine != null) {\n    _alreadyAllocatedEngines.add(engine);\n  }\n  String directorType=getDirectorType(arrayType,haDomain);\n  if (directorType != null) {\n    _alreadyAllocatedDirectorTypes.add(directorType);\n  }\n  String director=getDirector(port,haDomain);\n  if (director != null) {\n    _alreadyAllocatedDirectors.add(director);\n  }\n  String cpu=getCpu(port,haDomain,arrayType);\n  if (cpu != null) {\n    _alreadyAllocatedCpus.add(cpu);\n  }\n  if (switchName != null) {\n    _alreadyAllocatedSwitches.add(switchName);\n  }\n}\n", "docstring": "allocates existing ports to the already allocated context ( only ) . these ports may be from different networks and are not necessarily part of the pool of ports we can allocate from .", "partition": "test"}
{"idx": "3552", "code": "public static void writeListOfLongs(List list,boolean hasLongIDs,DataOutput out) throws IOException {\n  if (list == null) {\n    out.writeInt(-1);\n  }\n else {\n    out.writeInt(list.size());\n    out.writeBoolean(hasLongIDs);\n    for (Iterator it=list.iterator(); it.hasNext(); ) {\n      Long l=(Long)it.next();\n      if (hasLongIDs) {\n        out.writeLong(l.longValue());\n      }\n else {\n        out.writeInt((int)l.longValue());\n      }\n    }\n  }\n}\n", "docstring": "write a set of long objects", "partition": "test"}
{"idx": "3553", "code": "public boolean isDefined(Object attrName){\n  return table.containsKey(attrName);\n}\n", "docstring": "tells whether a given attribute is defined .", "partition": "test"}
{"idx": "3554", "code": "private void showPreloadingStage(){\n  Stage preloadingStage=new Stage(StageStyle.UNDECORATED);\n  preloadingStage.initOwner(primaryStage);\n  preloadingStage.setScene(new PreloadingScene());\n  preloadingStage.show();\n  primaryStage.setOnShowing(null);\n}\n", "docstring": "shows preloading stage with scene while fxgl is being configured .", "partition": "test"}
{"idx": "3555", "code": "public void test_copyStream_fullBlock() throws IOException {\n  final String id=\"test\";\n  final int version=0;\n  Random r=new Random();\n  final byte[] expected=new byte[BLOCK_SIZE];\n  r.nextBytes(expected);\n  assertEquals(\"nbytes\",expected.length,repo.copyStream(id,version,new ByteArrayInputStream(expected)));\n  assertEquals(\"blockCount\",1,repo.getBlockCount(id,version));\n  assertSameIterator(\"block identifiers\",new Long[]{0L},repo.blocks(id,version));\n  assertEquals(\"data\",expected,read(repo.inputStream(id,version)));\n}\n", "docstring": "test copy of an stream containing exactly one block \"'\" s data .", "partition": "test"}
{"idx": "3556", "code": "private static int ipToBytes(String ip,byte[] bytes,boolean mustHave4) throws IPMatcherException {\n  String[] parts=ip.split(\"\\\\.\");\n  if (parts.length > 4 || mustHave4 && parts.length != 4) {\n    throw new IPMatcherException(\"Malformed IP specification \" + ip);\n  }\n  try {\n    for (int i=0; i < parts.length; i++) {\n      int p=Integer.parseInt(parts[i]);\n      if (p < 0 || p > 255) {\n        throw new IPMatcherException(\"Malformed IP specification \" + ip);\n      }\n      bytes[i]=(byte)(p < 128 ? p : p - 256);\n    }\n  }\n catch (  NumberFormatException nfe) {\n    throw new IPMatcherException(\"Malformed IP specification \" + ip,nfe);\n  }\n  return parts.length;\n}\n", "docstring": "fill out a given four - byte array with the ipv4 address specified in the given string", "partition": "test"}
{"idx": "3557", "code": "protected void reply(RequestContext context,String key,String message){\n  try {\n    HttpServletRequest request=context.getRequest();\n    String filename=request.getRemoteAddr();\n    end(filename,key,message);\n  }\n catch (  Exception e) {\n  }\n}\n", "docstring": "emits an \" end \" line for a successful reply .", "partition": "test"}
{"idx": "3558", "code": "protected void addHeaders(HttpURLConnection connection,String tenantId){\n  if (tenantId == null) {\n    tenantId=PropertyUtil.getProperty(PropertyUtil.HAWKULAR_TENANT);\n  }\n  if (tenantId != null) {\n    connection.setRequestProperty(HAWKULAR_TENANT,tenantId);\n  }\n  if (authorization == null && username != null) {\n    String authString=username + \":\" + password;\n    String encoded=encoder.encodeToString(authString.getBytes());\n    authorization=\"Basic \" + encoded;\n  }\n  if (authorization != null) {\n    connection.setRequestProperty(\"Authorization\",authorization);\n  }\n}\n", "docstring": "add the header values to the supplied connection .", "partition": "test"}
{"idx": "3559", "code": "public void addLongSelectionListener(SelectionListener listener){\n  if (listener == null)   throw new IllegalArgumentException();\n  if (hexEditControl == null) {\n    if (listOfLongListeners == null)     listOfLongListeners=new ArrayList<>();\n    listOfLongListeners.add(listener);\n  }\n else {\n    hexEditControl.addLongSelectionListener(listener);\n  }\n}\n", "docstring": "adds a long selection listener . events sent to the listener have long start and end points .", "partition": "test"}
{"idx": "3560", "code": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"{\");\n  boolean firstTime=true;\n  for (  Entry<Integer,String> entry : mCapabilities.entrySet()) {\n    if (firstTime) {\n      firstTime=false;\n    }\n else {\n      sb.append(\",\");\n    }\n    sb.append(entry.getKey());\n    sb.append(\":\\\"\");\n    sb.append(entry.getValue());\n    sb.append(\"\\\"\");\n    return mCapabilities.toString();\n  }\n  return sb.toString();\n}\n", "docstring": "convert to string for debugging", "partition": "test"}
{"idx": "3561", "code": "public Debug(String clientID,ClientComms comms){\n  this.clientID=clientID;\n  this.comms=comms;\n  log.setResourceName(clientID);\n}\n", "docstring": "set the debug facility up for a specific client", "partition": "test"}
{"idx": "3562", "code": "protected String alterCase(String value){\nswitch (getCase()) {\ncase UPPERCASE:\n    return value.toUpperCase();\ncase LOWERCASE:\n  return value.toLowerCase();\ndefault :\nreturn value;\n}\n}\n", "docstring": "alter the case of this element so that it is rendered according to whatever the value of case_type is . default is mixedcase", "partition": "test"}
{"idx": "3563", "code": "private boolean isAckRequired(){\n  return this.ackRequired;\n}\n", "docstring": "return true if a distributed ack message is required . on the client side of a transaction , this returns false , while returning true elsewhere .", "partition": "test"}
{"idx": "3564", "code": "void addReporter(String textReporter,int xx,int yy){\n  ReporterIcon l=new ReporterIcon(this);\n  l.setReporter(textReporter);\n  l.setLocation(xx,yy);\n  l.setSize(l.getPreferredSize().width,l.getPreferredSize().height);\n  l.setDisplayLevel(LABELS);\n  setDirty(true);\n  putItem(l);\n}\n", "docstring": "add a reporter icon to the panel", "partition": "test"}
{"idx": "3565", "code": "private void drawSelectionRectangle(Graphics2D g2){\n  if (this.selectionRectangle != null) {\n    if (this.fillSelectionRectangle) {\n      g2.setPaint(this.selectionFillPaint);\n      g2.fill(selectionRectangle);\n    }\n else {\n      g2.setPaint(this.selectionOutlinePaint);\n      g2.draw(selectionRectangle);\n    }\n  }\n}\n", "docstring": "draws zoom rectangle ( if present ) . the drawing is performed in xor mode , therefore when this method is called twice in a row , the second call will completely restore the state of the canvas .", "partition": "test"}
{"idx": "3566", "code": "public ConversionException(final Throwable cause){\n  super(cause.getMessage());\n  this.cause=cause;\n}\n", "docstring": "construct a new exception with the specified root cause .", "partition": "test"}
{"idx": "3567", "code": "private boolean hasConnectivityToAllSystems(Initiator initiator,Collection<URI> storageSystems,ExportGroup exportGroup){\n  return hasConnectivityToAllSystems(initiator,storageSystems,null,exportGroup);\n}\n", "docstring": "checks if an initiator has connectivity to a storage system in a varray .", "partition": "test"}
{"idx": "3568", "code": "private Derivation<TK,FV> constructDerivation(Derivation<TK,FV> markedNode,int sourceInputId,FeatureExtractor<TK,FV> featurizer,Scorer<FV> scorer,SearchHeuristic<TK,FV> heuristic,OutputSpace<TK,FV> outputSpace){\n  final List<Derivation<TK,FV>> nodes=new LinkedList<>();\n  Derivation<TK,FV> p=markedNode;\n  while (p != null) {\n    nodes.add(0,p);\n    p=p.parent;\n  }\n  p=markedNode.bestChild;\n  while (p != null) {\n    nodes.add(p);\n    p=p.bestChild;\n  }\n  Derivation<TK,FV> goalHyp=null;\n  for (  Derivation<TK,FV> node : nodes) {\n    goalHyp=goalHyp == null ? node : new Derivation<>(sourceInputId,node.rule,goalHyp.length,goalHyp,featurizer,scorer,heuristic,outputSpace);\n  }\n  return goalHyp;\n}\n", "docstring": "construct a new derivation from a node of interest .", "partition": "test"}
{"idx": "3569", "code": "public void testPlusMathContextPositive(){\n  String a=\"92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=41;\n  int precision=37;\n  RoundingMode rm=RoundingMode.FLOOR;\n  MathContext mc=new MathContext(precision,rm);\n  String c=\"929487820944884782312124789.8748298842\";\n  int cScale=10;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal res=aNumber.plus(mc);\n  assertEquals(\"incorrect value\",c,res.toString());\n  assertEquals(\"incorrect scale\",cScale,res.scale());\n}\n", "docstring": "plus ( mathcontext ) for a positive bigdecimal", "partition": "test"}
{"idx": "3570", "code": "private static IAbstractNode convertOr(final CommonTree ast) throws RecognitionException {\n  final List<IAbstractNode> children=new ArrayList<IAbstractNode>();\n  for (  final Object childObject : ast.getChildren()) {\n    children.add(convert((CommonTree)childObject));\n  }\n  return new CAbstractOrExpression(children);\n}\n", "docstring": "converts an antrl or ast into a filter or ast .", "partition": "test"}
{"idx": "3571", "code": "public JDialog displayPanelInWindow(final JPanel panel,String title){\n  JDialog frame=new GenericJDialog();\n  frame.setContentPane(panel);\n  frame.pack();\n  frame.setTitle(title);\n  frame.setVisible(true);\n  return frame;\n}\n", "docstring": "a copy of displaypanel except returning a subclass of window . here to temporarily resolve ongoing conflict between classes using generic frame and classes using window .", "partition": "test"}
{"idx": "3572", "code": "public Builder withTokenizer(Class<? extends TokenizerFactory> factory,Map<String,String> params) throws IOException {\n  Objects.requireNonNull(factory,\"Tokenizer factory may not be null\");\n  tokenizer.set(applyResourceLoader(newFactoryClassInstance(factory,applyDefaultParams(params))));\n  componentsAdded=true;\n  return this;\n}\n", "docstring": "uses the given tokenizer .", "partition": "test"}
{"idx": "3573", "code": "protected double computeAzimuthLabelOffset(double radius,double maxRadius){\n  return Math.asin(AZIMUTH_LABEL_OFFSET * maxRadius / radius);\n}\n", "docstring": "compute an angular offset to apply to a azimuth label . this angle will be added to the azimuth of the label \"'\" s azimuth in order to place the label a little bit to the side of the line that it applies to .", "partition": "test"}
{"idx": "3574", "code": "public void displayChanged(){\n  executeDisplayChangedOnEDT(getGraphicsConfiguration());\n}\n", "docstring": "from the displaychangedlistener interface ; called from x11graphicsdevice when the display mode has been changed .", "partition": "test"}
{"idx": "3575", "code": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  Calendar dateTime=new GregorianCalendar(GMT);\n  long localTime=value;\n  if (tzShift != null) {\n    localTime+=tzShift.longValue() * 60000;\n  }\n  dateTime.setTimeInMillis(localTime);\n  try {\n    appendInt(sb,dateTime.get(Calendar.YEAR),4);\n    sb.append('-');\n    appendInt(sb,dateTime.get(Calendar.MONTH) + 1,2);\n    sb.append('-');\n    appendInt(sb,dateTime.get(Calendar.DAY_OF_MONTH),2);\n    if (!dateOnly) {\n      sb.append('T');\n      appendInt(sb,dateTime.get(Calendar.HOUR_OF_DAY),2);\n      sb.append(':');\n      appendInt(sb,dateTime.get(Calendar.MINUTE),2);\n      sb.append(':');\n      appendInt(sb,dateTime.get(Calendar.SECOND),2);\n      if (dateTime.isSet(Calendar.MILLISECOND)) {\n        sb.append('.');\n        appendInt(sb,dateTime.get(Calendar.MILLISECOND),3);\n      }\n    }\n    if (tzShift != null) {\n      if (tzShift.intValue() == 0) {\n        sb.append('Z');\n      }\n else {\n        int absTzShift=tzShift.intValue();\n        if (tzShift > 0) {\n          sb.append('+');\n        }\n else {\n          sb.append('-');\n          absTzShift=-absTzShift;\n        }\n        int tzHours=absTzShift / 60;\n        int tzMinutes=absTzShift % 60;\n        appendInt(sb,tzHours,2);\n        sb.append(':');\n        appendInt(sb,tzMinutes,2);\n      }\n    }\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    throw new RuntimeException(e);\n  }\n  return sb.toString();\n}\n", "docstring": "formats the value as an xs : date or xs : datetime string .", "partition": "test"}
{"idx": "3576", "code": "private static Stream<Method> extractMethods(Class clazz){\n  try {\n    Method[] methods=clazz.getMethods();\n    if (methods.length > 0) {\n      return Stream.of(methods);\n    }\n  }\n catch (  Exception|Error e) {\n    LOG.warn(\"Problems loading class at startup: {}\",clazz,e);\n  }\n  return Stream.empty();\n}\n", "docstring": "extract a set of methods from a given class .", "partition": "test"}
{"idx": "3577", "code": "@Override public void updateServerAddress(Application application,String dockerManagerIP,String serverPort,String serverManagerPort){\n  String suffixCloudUnit=application.getSuffixCloudUnitIO();\n  JedisPool pool=null;\n  Jedis jedis=null;\n  try {\n    pool=new JedisPool(new JedisPoolConfig(),redisIp,Integer.parseInt(redisPort),3000);\n    jedis=pool.getResource();\n    String subNameSpace=concatSubNameSpace(application);\n    String key=subNameSpace + suffixCloudUnit;\n    String frontend=\"frontend:\" + key.toLowerCase();\n    jedis.lset(frontend,1,\"http://\" + dockerManagerIP + \":\"+ serverPort);\n    String frontendServerManager=\"frontend:manager-\" + key.toLowerCase();\n    jedis.lset(frontendServerManager,1,\"http://\" + dockerManagerIP + \":\"+ serverManagerPort);\n  }\n catch (  JedisConnectionException|UnsupportedEncodingException e) {\n    logger.error(\"HipacheRedisUtils Exception\",e);\n  }\n finally {\n    if (jedis != null) {\n      pool.destroy();\n    }\n  }\n}\n", "docstring": "update the server address", "partition": "test"}
{"idx": "3578", "code": "protected void remove(int itemPosition){\n  if (itemPosition >= 0 && itemPosition < getItemCount()) {\n    list.remove(itemPosition);\n  }\n}\n", "docstring": "remove an item from the adapter \"'\" s list .", "partition": "test"}
{"idx": "3579", "code": "protected String chooseRandomEnemys(){\n  final List<String> enemyList=new LinkedList<String>(enemyForces.keySet());\n  final int enemySize=enemyList.size();\n  final int position=Rand.rand(enemySize);\n  return enemyList.get(position);\n}\n", "docstring": "function for choosing random enemy from map", "partition": "test"}
{"idx": "3580", "code": "public boolean isRouteToDestValid(Block protecting,Block destination){\n  if (protecting == destination) {\n    log.debug(\"protecting and destination blocks are the same therefore we need to check if we have a valid neighbour\");\n    if (getAdjacency(protecting) != null) {\n      return true;\n    }\n  }\n else   if (getValidRoute(protecting,destination) != null) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "is the route to the destination block , going via our neighbouring block valid . ie does the block have a route registered via neighbour \" protecting \" to the destination block .", "partition": "test"}
{"idx": "3581", "code": "public void sortPools(List<StoragePool> storagePools){\n  _portMetricsProcessor.computeStoragePoolsAvgPortMetrics(storagePools);\n  Collections.sort(storagePools,_storagePoolComparator);\n}\n", "docstring": "sort list of storage pools based on its storage system \"'\" s average usage port metrics usage . its secondary sorting components are free and subscribed capacity", "partition": "test"}
{"idx": "3582", "code": "public RhythmGroup addOverlays(Collection<RhythmOverlay> overlays){\n  mOverlays.addAll(overlays);\n  if (mCurrentOverlayIndex == NO_OVERLAY) {\n    selectOverlay(0);\n  }\n  return this;\n}\n", "docstring": "add multiple rhythm overlays to this group", "partition": "test"}
{"idx": "3583", "code": "public static Resource forPath(final String path) throws UnknownResourceException {\n  Resource resource;\n  if (path.startsWith(ClasspathResource.PREFIX + \":\")) {\n    resource=new ClasspathResource(path);\n  }\n else   if (path.startsWith(FileResource.PREFIX + \":\")) {\n    resource=new FileResource(path);\n  }\n else {\n    resource=forPath(FileResource.PREFIX + \":\" + path);\n  }\n  return resource;\n}\n", "docstring": "creates an instance for a path prefixed by either classpath : or file : .", "partition": "test"}
{"idx": "3584", "code": "private static boolean isOlderThanLeopard(){\n  String version=System.getProperty(\"os.version\");\n  StringTokenizer tk=new StringTokenizer(version,\".\");\n  int major=Integer.parseInt(tk.nextToken());\n  int minor=Integer.parseInt(tk.nextToken());\n  return major == 10 && minor < 6;\n}\n", "docstring": "determines if this is running a mac osx lower than leopard", "partition": "test"}
{"idx": "3585", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>();\n  newVector.addElement(new Option(\"\\tNumber of trees to build.\\n\\t(default 100)\",\"I\",1,\"-I <number of trees>\"));\n  newVector.addElement(new Option(\"\\tNumber of features to consider (<1=int(log_2(#predictors)+1)).\\n\\t(default 0)\",\"K\",1,\"-K <number of features>\"));\n  newVector.addElement(new Option(\"\\tSeed for random number generator.\\n\" + \"\\t(default 1)\",\"S\",1,\"-S\"));\n  newVector.addElement(new Option(\"\\tThe maximum depth of the trees, 0 for unlimited.\\n\" + \"\\t(default 0)\",\"depth\",1,\"-depth <num>\"));\n  newVector.addElement(new Option(\"\\tDon\'t calculate the out of bag error.\",\"O\",0,\"-O\"));\n  newVector.addElement(new Option(\"\\tPrint the individual trees in the output\",\"print\",0,\"-print\"));\n  newVector.addElement(new Option(\"\\tNumber of execution slots.\\n\" + \"\\t(default 1 - i.e. no parallelism)\",\"num-slots\",1,\"-num-slots <num>\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "3586", "code": "public static String xmlContentEscape(String s){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < s.length(); i++) {\n    char c=s.charAt(i);\nswitch (c) {\ncase \'&\':\n      sb.append(\"&amp;\");\n    break;\ncase \'<\':\n  sb.append(\"&lt;\");\nbreak;\ncase \'\\000\':\ncase \'\\001\':\ncase \'\\002\':\ncase \'\\003\':\ncase \'\\004\':\ncase \'\\005\':\ncase \'\\006\':\ncase \'\\007\':\ncase \'\\010\':\ncase \'\\013\':\ncase \'\\014\':\ncase \'\\016\':\ncase \'\\017\':\ncase \'\\020\':\ncase \'\\021\':\ncase \'\\022\':\ncase \'\\023\':\ncase \'\\024\':\ncase \'\\025\':\ncase \'\\026\':\ncase \'\\027\':\ncase \'\\030\':\ncase \'\\031\':\ncase \'\\032\':\ncase \'\\033\':\ncase \'\\034\':\ncase \'\\035\':\ncase \'\\036\':\ncase \'\\037\':\nbreak;\ndefault :\nsb.append(c);\n}\n}\nreturn sb.toString();\n}\n", "docstring": "escape a string for use inside as xml element content . this escapes less - than and ampersand , only .", "partition": "test"}
{"idx": "3587", "code": "private void feedForward(Vec input,List<Vec> activations,List<Vec> derivatives){\n  Vec x=input;\n  for (int i=0; i < Ws.size(); i++) {\n    Matrix W_i=Ws.get(i);\n    Vec b_i=bs.get(i);\n    Vec a_i=activations.get(i);\n    a_i.zeroOut();\n    W_i.multiply(x,1,a_i);\n    a_i.mutableAdd(b_i);\n    a_i.applyFunction(f);\n    Vec d_i=derivatives.get(i);\n    a_i.copyTo(d_i);\n    d_i.applyFunction(f.getD());\n    x=a_i;\n  }\n}\n", "docstring": "feeds a vector through the network to get an output", "partition": "test"}
{"idx": "3588", "code": "private File findFile(File directory,String name) throws FileNotFoundException {\n  File file=new File(directory,name);\n  if (file.exists()) {\n    return file;\n  }\n  for (  String child : directory.list()) {\n    if (child.equalsIgnoreCase(name)) {\n      return new File(directory,child);\n    }\n  }\n  throw new FileNotFoundException(\"Missing file: \" + file);\n}\n", "docstring": "finds the named file in the named directory . this tries extra hard to avoid case - insensitive - naming problems , where the requested file is available in a different casing .", "partition": "test"}
{"idx": "3589", "code": "public static boolean compareResults(SolrClient controlClient,SolrClient cloudClient) throws SolrServerException, IOException {\n  return compareResults(controlClient,cloudClient,null,null);\n}\n", "docstring": "compares the results of the control and cloud clients .", "partition": "test"}
{"idx": "3590", "code": "public ArrayList<String> GetElementList(String xPathExpression){\n  try {\n    ArrayList<String> values=new ArrayList<String>();\n    List<?> nodeList=XPath.selectNodes(this.xmlDocument,xPathExpression);\n    Iterator<?> iter=nodeList.iterator();\n    while (iter.hasNext()) {\n      org.jdom.Element element=(org.jdom.Element)iter.next();\n      values.add(element.getText());\n    }\n    return values;\n  }\n catch (  Exception ex) {\n    LOG.error(\"Error in handler: \" + ex.getMessage(),ex);\n    return null;\n  }\n}\n", "docstring": "retrieves the text elements for a given xpath expression", "partition": "test"}
{"idx": "3591", "code": "public static CLContext createContextFromCurrentGL(){\n  RuntimeException first=null;\n  for (  CLPlatform platform : listPlatforms()) {\n    try {\n      CLContext ctx=platform.createContextFromCurrentGL();\n      if (ctx != null)       return ctx;\n    }\n catch (    RuntimeException ex) {\n      if (first == null)       first=ex;\n    }\n  }\n  throw new RuntimeException(\"Failed to create an OpenCL context based on the current OpenGL context\",first);\n}\n", "docstring": "creates an opencl context able to share entities with the current opengl context .", "partition": "test"}
{"idx": "3592", "code": "public void collapseTree(){\n  for (int i=1; i < tree.getRowCount(); ++i) {\n    tree.collapseRow(i);\n  }\n}\n", "docstring": "collapse the tree so that only the root node is visible .", "partition": "test"}
{"idx": "3593", "code": "static void queuePlayerCapeReplacement(AbstractClientPlayer player){\n  final String displayName=player.getDisplayNameString();\n  Logger.info(\"Queueing cape replacement for %s\",displayName);\n  THREAD_POOL.submit(null);\n}\n", "docstring": "queue the replacement of a player \"'\" s cape with the testmod3 cape . < p > in at least 100 milliseconds , the player \"'\" s cape will be replaced on the next iteration of the client \"'\" s main loop .", "partition": "test"}
{"idx": "3594", "code": "public void removeVetoableChangeListener(VetoableChangeListener listener){\n  if (listener != null) {\nsynchronized (this) {\n      if (vetoableSupport != null) {\n        vetoableSupport.removeVetoableChangeListener(listener);\n      }\n    }\n  }\n}\n", "docstring": "removes a vetoablechangelistener from the listener list . this method should be used to remove the vetoablechangelisteners that were registered for all vetoable properties of this class . < p > if listener is null , no exception is thrown and no action is performed .", "partition": "test"}
{"idx": "3595", "code": "public StreamThroughput(String statusMessagePrefix){\n  m_instanceCount=0;\n  m_sampleCount=0;\n  m_numSamples=0;\n  m_cumulativeTime=0;\n  m_startTime=System.currentTimeMillis();\n  m_statusMessagePrefix=statusMessagePrefix;\n}\n", "docstring": "construct a new streamthroughput", "partition": "test"}
{"idx": "3596", "code": "protected void parseCommand(final String... args){\n  for (  String arg : args) {\n    final Command command=Command.valueOfName(arg);\n    if (command != null) {\n      setCommand(command);\n      break;\n    }\n  }\n}\n", "docstring": "iterates the list of arguments in search of the target locator launcher command .", "partition": "test"}
{"idx": "3597", "code": "@RequestMapping(value=\"/{bookmarkId}\",method=RequestMethod.PUT) public ResponseEntity<Bookmark> editBookmark(@PathVariable(value=\"username\") String username,@PathVariable(value=\"bookmarkId\") int bookmarkId,@RequestBody String json) throws IOException, BookmarkNotFoundException, IllegalAccessException, InvocationTargetException {\n  Optional<Bookmark> optional=bookmarksRepository.findByIdAndUserUsername(bookmarkId,username);\n  if (optional.isPresent()) {\n    ObjectMapper mapper=new ObjectMapper();\n    Map<String,String> changeMap=mapper.readValue(json,HashMap.class);\n    Bookmark bookmark=optional.get();\n    BeanUtils.populate(bookmark,changeMap);\n    bookmark=bookmarksRepository.save(bookmark);\n    return new ResponseEntity<>(bookmark,HttpStatus.OK);\n  }\n else {\n    throw new BookmarkNotFoundException(\"Bookmark not found id = \" + bookmarkId);\n  }\n}\n", "docstring": "a method to edit a bookmark .", "partition": "test"}
{"idx": "3598", "code": "public static String convertFromUtf32(int[] text,int startPos,int endPos){\n  StringBuilder sb=new StringBuilder();\n  for (int i=startPos; i < endPos; i++) {\n    sb.append(convertFromUtf32ToCharArray(text[i]));\n  }\n  return sb.toString();\n}\n", "docstring": "/ converts a utf32 code point sequence to a string with the corresponding character ( s ) .", "partition": "test"}
{"idx": "3599", "code": "public void createBounds(){\n  if (isEmpty() || hasSingleElement()) {\n    mBounds=null;\n    return;\n  }\n  int l=Integer.MAX_VALUE;\n  int t=Integer.MAX_VALUE;\n  int r=0;\n  int b=0;\n  for (  Selection.Element selection : getElements()) {\n    ConstraintWidget w=selection.widget;\n    l=Math.min(w.getDrawX(),l);\n    t=Math.min(w.getDrawY(),t);\n    r=Math.max(w.getDrawRight(),r);\n    b=Math.max(w.getDrawBottom(),b);\n  }\n  ConstraintWidget bounds=new ConstraintWidget(l,t,r - l,b - t);\n  bounds.setCompanionWidget(WidgetCompanion.create(bounds));\n  mBounds=new Element(bounds);\n  updateOriginFromBounds();\n}\n", "docstring": "if the selection has more than one element , it will create a temporary element object as the bounds of the entire selection . we then use this bounds object to snap the full selection on screen .", "partition": "test"}
{"idx": "3600", "code": "public static Object[] findMethodWithListParameters(Object service,String methodName,List<?> args){\n  Object[] arguments=new Object[args.size()];\n  for (int i=0; i < args.size(); i++) {\n    arguments[i]=args.get(i);\n  }\n  return findMethodWithListParameters(service,methodName,arguments);\n}\n", "docstring": "returns ( method , params ) for the given service or ( null , null ) if no method was found .", "partition": "test"}
{"idx": "3601", "code": "static int firstIllegalCharacter(String source){\n  for (int i=0; i < source.length(); i++) {\n    if (isLegal(source.charAt(i)) == false) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "docstring": "utility method to find the first invalid character as per rfc 2396 section 2 . this helps us prevent creating excessive objects in the encode ( ) methods since most strings will not be encoded .", "partition": "test"}
{"idx": "3602", "code": "private CoderResult decodeByteBufferToCharacterBuffer(boolean endOfInput) throws DecodingException {\n  buffer.flip();\n  return decodeMoreBytesToCharacterBuffer(endOfInput);\n}\n", "docstring": "decodes contents of the byte buffer to the character buffer . the character buffer will be replaced by a larger one if required .", "partition": "test"}
{"idx": "3603", "code": "protected void newFastClockMinute(){\n  for (int i=delayedTrains.size() - 1; i >= 0; i--) {\n    ActiveTrain at=delayedTrains.get(i);\n    if ((!at.getStarted()) && at.getDelayedStart() != ActiveTrain.NODELAY) {\n      if (at.getDelayedStart() == ActiveTrain.TIMEDDELAY) {\n        if (isFastClockTimeGE(at.getDepartureTimeHr(),at.getDepartureTimeMin())) {\n          at.setStarted();\n          delayedTrains.remove(i);\n          if (_AutoAllocate) {\n            autoAllocate.scanAllocationRequestList(allocationRequests);\n          }\n        }\n      }\n    }\n else     if (at.getStarted() && at.getStatus() == ActiveTrain.READY && at.reachedRestartPoint()) {\n      if (isFastClockTimeGE(at.getRestartDepartHr(),at.getRestartDepartMin())) {\n        at.restart();\n        delayedTrains.remove(i);\n        if (_AutoAllocate) {\n          autoAllocate.scanAllocationRequestList(allocationRequests);\n        }\n      }\n    }\n  }\n}\n", "docstring": "handle activity that is triggered by the fast clock", "partition": "test"}
{"idx": "3604", "code": "public void add(final CreatureRespawnPoint point){\n  respawnPoints.add(point);\n}\n", "docstring": "add a creature respawn point to the zone .", "partition": "test"}
{"idx": "3605", "code": "private void loadOrgAccessRole(ArrayList<OrgAccess> list){\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  String sql=\"SELECT * FROM AD_Role_OrgAccess \" + \"WHERE AD_Role_ID=? AND IsActive=\'Y\'\";\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getAD_Role_ID());\n    rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRoleOrgAccess oa=new MRoleOrgAccess(getCtx(),rs,get_TrxName());\n      loadOrgAccessAdd(list,new OrgAccess(oa.getAD_Client_ID(),oa.getAD_Org_ID(),oa.isReadOnly()));\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n finally {\n    DB.close(rs,pstmt);\n  }\n}\n", "docstring": "load org access role", "partition": "test"}
{"idx": "3606", "code": "public void testBytesAsSource() throws Exception {\n  String JSON=\"[ 1, 2, 3, 4 ]\";\n  byte[] b=JSON.getBytes(\"UTF-8\");\n  int offset=50;\n  int len=b.length;\n  byte[] src=new byte[offset + len + offset];\n  System.arraycopy(b,0,src,offset,len);\n  JsonFactory jf=new JsonFactory();\n  JsonParser jp=jf.createJsonParser(src,offset,len);\n  assertToken(JsonToken.START_ARRAY,jp.nextToken());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(1,jp.getIntValue());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(2,jp.getIntValue());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(3,jp.getIntValue());\n  assertToken(JsonToken.VALUE_NUMBER_INT,jp.nextToken());\n  assertEquals(4,jp.getIntValue());\n  assertToken(JsonToken.END_ARRAY,jp.nextToken());\n  assertNull(jp.nextToken());\n  jp.close();\n}\n", "docstring": "simple unit test that verifies that passing in a byte array as source works as expected .", "partition": "test"}
{"idx": "3607", "code": "public String toString(Object value){\n  return toPrettyString(value);\n}\n", "docstring": "returns pretty string representation of the object .", "partition": "test"}
{"idx": "3608", "code": "@Override public List<Period> generateRollingPeriods(DateTimeUnit dateTimeUnit){\n  Calendar cal=getCalendar();\n  dateTimeUnit.setDay(1);\n  dateTimeUnit=cal.minusMonths(dateTimeUnit,11);\n  List<Period> periods=Lists.newArrayList();\n  for (int i=0; i < 12; i++) {\n    periods.add(createPeriod(dateTimeUnit,cal));\n    dateTimeUnit=cal.plusMonths(dateTimeUnit,1);\n  }\n  return periods;\n}\n", "docstring": "generates the last 12 months where the last one is the month which the given date is inside .", "partition": "test"}
{"idx": "3609", "code": "@SuppressWarnings(\"unchecked\") public synchronized T findCounter(Enum<?> counterKey) throws IllegalAccessException, InstantiationException {\n  T counter=cache.get(counterKey);\n  if (counter == null) {\n    counter=counterType.newInstance();\n    cache.put(counterKey,counter);\n  }\n  return counter;\n}\n", "docstring": "returns the counter associated with the key . creates it if it doesn \"'\" t exist .", "partition": "test"}
{"idx": "3610", "code": "public static Uri addMessageToUri(ContentResolver resolver,Uri uri,String address,String body,String subject,Long date,boolean read,boolean deliveryReport,long threadId){\n  ContentValues values=new ContentValues(7);\n  values.put(Sms.ADDRESS,address);\n  if (date != null) {\n    values.put(Sms.DATE,date);\n  }\n  values.put(Sms.READ,read ? Integer.valueOf(1) : Integer.valueOf(0));\n  values.put(Sms.SUBJECT,subject);\n  values.put(Sms.BODY,body);\n  if (deliveryReport) {\n    values.put(Sms.STATUS,Sms.STATUS_PENDING);\n  }\n  if (threadId != -1L) {\n    values.put(Sms.THREAD_ID,threadId);\n  }\n  return resolver.insert(uri,values);\n}\n", "docstring": "add an sms to the given uri with the specified thread id .", "partition": "test"}
{"idx": "3611", "code": "private void computeDoublesForAllZoomLevels(){\n  int numFrames=mSoundFile.getNumFrames();\n  int[] frameGains=mSoundFile.getFrameGains();\n  double[] smoothedGains=new double[numFrames];\n  if (numFrames == 1) {\n    smoothedGains[0]=frameGains[0];\n  }\n else   if (numFrames == 2) {\n    smoothedGains[0]=frameGains[0];\n    smoothedGains[1]=frameGains[1];\n  }\n else   if (numFrames > 2) {\n    smoothedGains[0]=(double)((frameGains[0] / 2.0) + (frameGains[1] / 2.0));\n    for (int i=1; i < numFrames - 1; i++) {\n      smoothedGains[i]=(double)((frameGains[i - 1] / 3.0) + (frameGains[i] / 3.0) + (frameGains[i + 1] / 3.0));\n    }\n    smoothedGains[numFrames - 1]=(double)((frameGains[numFrames - 2] / 2.0) + (frameGains[numFrames - 1] / 2.0));\n  }\n  double maxGain=1.0;\n  for (int i=0; i < numFrames; i++) {\n    if (smoothedGains[i] > maxGain) {\n      maxGain=smoothedGains[i];\n    }\n  }\n  double scaleFactor=1.0;\n  if (maxGain > 255.0) {\n    scaleFactor=255 / maxGain;\n  }\n  maxGain=0;\n  int gainHist[]=new int[256];\n  for (int i=0; i < numFrames; i++) {\n    int smoothedGain=(int)(smoothedGains[i] * scaleFactor);\n    if (smoothedGain < 0)     smoothedGain=0;\n    if (smoothedGain > 255)     smoothedGain=255;\n    if (smoothedGain > maxGain)     maxGain=smoothedGain;\n    gainHist[smoothedGain]++;\n  }\n  double minGain=0;\n  int sum=0;\n  while (minGain < 255 && sum < numFrames / 20) {\n    sum+=gainHist[(int)minGain];\n    minGain++;\n  }\n  sum=0;\n  while (maxGain > 2 && sum < numFrames / 100) {\n    sum+=gainHist[(int)maxGain];\n    maxGain--;\n  }\n  double[] heights=new double[numFrames];\n  double range=maxGain - minGain;\n  for (int i=0; i < numFrames; i++) {\n    double value=(smoothedGains[i] * scaleFactor - minGain) / range;\n    if (value < 0.0)     value=0.0;\n    if (value > 1.0)     value=1.0;\n    heights[i]=value * value;\n  }\n  algo(mSoundFile.getNumFrames());\n  totalZooms=algoValues.size() + 2;\n  mNumZoomLevels=totalZooms;\n  mLenByZoomLevel=new int[totalZooms];\n  mZoomFactorByZoomLevel=new double[totalZooms];\n  mValuesByZoomLevel=new double[totalZooms][];\n  mLenByZoomLevel[0]=numFrames * 2;\n  mZoomFactorByZoomLevel[0]=2.0;\n  mValuesByZoomLevel[0]=new double[mLenByZoomLevel[0]];\n  if (numFrames > 0) {\n    mValuesByZoomLevel[0][0]=0.5 * heights[0];\n    mValuesByZoomLevel[0][1]=heights[0];\n  }\n  for (int i=1; i < numFrames; i++) {\n    mValuesByZoomLevel[0][2 * i]=0.5 * (heights[i - 1] + heights[i]);\n    mValuesByZoomLevel[0][2 * i + 1]=heights[i];\n  }\n  mLenByZoomLevel[1]=numFrames;\n  mValuesByZoomLevel[1]=new double[mLenByZoomLevel[1]];\n  mZoomFactorByZoomLevel[1]=1.0;\n  for (int i=0; i < mLenByZoomLevel[1]; i++) {\n    mValuesByZoomLevel[1][i]=heights[i];\n  }\n  int location=0;\n  for (int j=2; j < totalZooms; j++) {\n    mLenByZoomLevel[j]=algoValues.get(location);\n    mValuesByZoomLevel[j]=new double[mLenByZoomLevel[j]];\n    mZoomFactorByZoomLevel[j]=mZoomFactorByZoomLevel[j - 1] / 1.5;\n    for (int i=0; i < mLenByZoomLevel[j]; i++) {\n      mValuesByZoomLevel[j][i]=0.5 * (mValuesByZoomLevel[j - 1][(int)(divisorValues.get(location) * i)] + mValuesByZoomLevel[j - 1][(int)(divisorValues.get(location) * i) + 1]);\n    }\n    location++;\n  }\n  Log.i(\"Scope\",\"Squeezed..!!\");\n  mInitialized=true;\n}\n", "docstring": "called once when a new sound file is added", "partition": "test"}
{"idx": "3612", "code": "@SuppressWarnings(\"unchecked\") private void expungeStaleEntries(){\nsynchronized (sync) {\n    ListWeakReference r;\n    while ((r=(ListWeakReference)queue.poll()) != null) {\n      ListEntry le=r.getListEntry();\n      int i=list.indexOf(le);\n      if (i != -1) {\n        list.remove(i);\n      }\n    }\n  }\n}\n", "docstring": "expunge stale entries from the list .", "partition": "test"}
{"idx": "3613", "code": "protected void work(final IResource resource,final List<WorkItem> resources,IProgressMonitor monitor){\n  IPreferenceStore store=FindbugsPlugin.getPluginPreferences(getProject());\n  boolean runAsJob=store.getBoolean(FindBugsConstants.KEY_RUN_ANALYSIS_AS_EXTRA_JOB);\n  FindBugsJob fbJob=new StartedFromBuilderJob(\"Finding bugs in \" + resource.getName() + \"...\",resource,resources);\n  if (runAsJob) {\n    if (DEBUG) {\n      FindbugsPlugin.log(\"cancelSimilarJobs\");\n    }\n    FindBugsJob.cancelSimilarJobs(fbJob);\n    if (DEBUG) {\n      FindbugsPlugin.log(\"scheduleAsSystem\");\n    }\n    fbJob.scheduleAsSystem();\n    if (DEBUG) {\n      FindbugsPlugin.log(\"done scheduleAsSystem\");\n    }\n  }\n else {\n    if (DEBUG) {\n      FindbugsPlugin.log(\"running fbJob\");\n    }\n    fbJob.run(monitor);\n    if (DEBUG) {\n      FindbugsPlugin.log(\"done fbJob\");\n    }\n  }\n}\n", "docstring": "run a findbugs analysis on the given resource as build job but not delaying the current java build", "partition": "test"}
{"idx": "3614", "code": "@Override public void onFullBackup(FullBackupDataOutput output) throws IOException {\n  if (mVolumes != null) {\n    if (DEBUG)     Slog.i(TAG,\"Backing up \" + mVolumes.length + \" shared volumes\");\n    HashSet<String> externalFilesDirFilter=new HashSet<String>();\n    final File externalAndroidRoot=new File(Environment.getExternalStorageDirectory(),Environment.DIRECTORY_ANDROID);\n    externalFilesDirFilter.add(externalAndroidRoot.getCanonicalPath());\n    for (int i=0; i < mVolumes.length; i++) {\n      StorageVolume v=mVolumes[i];\n      String domain=FullBackup.SHARED_PREFIX + i;\n      fullBackupFileTree(null,domain,v.getPath(),externalFilesDirFilter,output);\n    }\n  }\n}\n", "docstring": "full backup of the shared - storage filesystem", "partition": "test"}
{"idx": "3615", "code": "public static void removeConnectionList(Integer tab){\n  TABBED_CONNECTIONS.remove(tab.intValue());\n}\n", "docstring": "remove the list of connections at the supplied index", "partition": "test"}
{"idx": "3616", "code": "protected void paintRangeRings(Point2D originPnt,Point2D dest,Graphics graphics,MapBean theMap){\n  Geo originGeo=new Geo(originPnt.getY(),originPnt.getX(),true);\n  Geo destGeo=new Geo(dest.getY(),dest.getX(),true);\n  double distance=originGeo.distance(destGeo);\n  for (int i=1; i <= Math.max(1,numRings); i++) {\n    double ringDist=distance * (double)i;\n    paintCircle(originGeo,ringDist,graphics,theMap);\n    paintLabel(originGeo,ringDist,graphics,theMap);\n  }\n}\n", "docstring": "paints the circles and their labels on the given graphics .", "partition": "test"}
{"idx": "3617", "code": "public void translateAndAppendPending(int backoff) throws UnsupportedEncodingException {\n  int bufferEnd=current - backoff;\n  int len=bufferEnd - complete;\n  output.append(new String(input,offset + complete,len,charset));\n  complete=bufferEnd;\n}\n", "docstring": "translate pending bytes using selected character set . bytes are translated up to current position minus the backoff value .", "partition": "test"}
{"idx": "3618", "code": "@Override public Trie optimize(Trie orig){\n  List<CharSequence> cmds=orig.cmds;\n  List<Row> rows=new ArrayList<>();\n  List<Row> orows=orig.rows;\n  int remap[]=new int[orows.size()];\n  for (int j=orows.size() - 1; j >= 0; j--) {\n    liftUp(orows.get(j),orows);\n  }\n  Arrays.fill(remap,-1);\n  rows=removeGaps(orig.root,orows,new ArrayList<Row>(),remap);\n  return new Trie(orig.forward,remap[orig.root],cmds,rows);\n}\n", "docstring": "optimize ( eliminate rows with no content ) the given trie and return the reduced trie .", "partition": "test"}
{"idx": "3619", "code": "private Handler<Void> installAfterHandler(final HttpServerRequest request,final Buffer buffer,final List<Listener> afterListener){\n  Handler<Void> afterHandler=null;\n  return afterHandler;\n}\n", "docstring": "this handler is called after the self request ( original request ) is performed successfully . the handler calls all listener ( after ) , so this requests happen after the original request is performed .", "partition": "test"}
{"idx": "3620", "code": "private void tryShutdown(){\n  if (isClosing() && isOkToClose())   shutdown(closeFuture.get());\n}\n", "docstring": "close was signaled in closeasync ( ) but there were pending messages at that time . this method attempts the shutdown if the returned result cleared up the last pending message .", "partition": "test"}
{"idx": "3621", "code": "public StorageEntity createStorageEntity(String storageName,StoragePlatformEntity storagePlatformEntity,List<Attribute> attributes){\n  StorageEntity storageEntity=new StorageEntity();\n  storageEntity.setName(storageName);\n  storageEntity.setStoragePlatform(storagePlatformEntity);\n  if (!CollectionUtils.isEmpty(attributes)) {\n    List<StorageAttributeEntity> attributeEntities=new ArrayList<>();\n    storageEntity.setAttributes(attributeEntities);\n    for (    Attribute attribute : attributes) {\n      StorageAttributeEntity attributeEntity=new StorageAttributeEntity();\n      attributeEntities.add(attributeEntity);\n      attributeEntity.setStorage(storageEntity);\n      attributeEntity.setName(attribute.getName());\n      attributeEntity.setValue(attribute.getValue());\n    }\n  }\n  return storageDao.saveAndRefresh(storageEntity);\n}\n", "docstring": "creates and persists a new storage entity .", "partition": "test"}
{"idx": "3622", "code": "public void displayInfoLine(String infoLine,int labelDesignator){\n  if (infoLineHolder != null) {\n    setLabel((infoLine != null && infoLine.length() > 0) ? infoLine : fudgeString,labelDesignator);\n  }\n}\n", "docstring": "display a line of text in a designated info line .", "partition": "test"}
{"idx": "3623", "code": "public void testSignerStringIdentityScope() throws Exception {\n  Signer s=new SignerStub(\"sss4\",IdentityScope.getSystemScope());\n  assertNotNull(s);\n  assertEquals(\"sss4\",s.getName());\n  assertSame(IdentityScope.getSystemScope(),s.getScope());\n  assertNull(s.getPrivateKey());\n  try {\n    Signer s2=new SignerStub(\"sss4\",IdentityScope.getSystemScope());\n    fail(\"expected KeyManagementException not thrown\");\n  }\n catch (  KeyManagementException e) {\n  }\n  Signer s2=new SignerStub(null);\n  assertNull(s2.getName());\n}\n", "docstring": "verify signer ( string , identityscope ) creates instance", "partition": "test"}
{"idx": "3624", "code": "public static Object invokeStaticMethod(BshClassManager bcm,Class clas,String methodName,Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {\n  Interpreter.debug(\"invoke static Method\");\n  Method method=resolveExpectedJavaMethod(bcm,clas,null,methodName,args,true);\n  return invokeMethod(method,null,args);\n}\n", "docstring": "invoke a method known to be static . no object instance is needed and there is no possibility of the method being a bsh scripted method .", "partition": "test"}
{"idx": "3625", "code": "protected AbstractRegexNPAnnotator(String pattern,boolean caseSensitive,double confidence){\n  this(Pattern.compile(pattern,caseSensitive ? 0 : Pattern.CASE_INSENSITIVE),0,confidence);\n}\n", "docstring": "new instance , based on the supplied pattern . uses the whole matched regex as the entity text .", "partition": "test"}
{"idx": "3626", "code": "private static void removeLoopSafepoint(StructuredGraph graph){\n  LoopBeginNode loopBegin=findFirstLoop(graph);\n  loopBegin.disableSafepoint();\n}\n", "docstring": "remove the safepoint from the first loop in the test method , so only the safepoints on monitorenter and monitorexit remain in the loop . that way , we can make sure it deopts inside the monitorenter by invalidating the code while holding the lock .", "partition": "test"}
{"idx": "3627", "code": "protected abstract void bindItem(DataBoundViewHolder<T> holder,int position,List<Object> payloads);\n", "docstring": "override this method to handle binding your items into views", "partition": "test"}
{"idx": "3628", "code": "public static Date daysBefore(Date dateInst,int numDays){\n  if ((numDays <= 0) || (dateInst == null)) {\n    throw new IllegalArgumentException();\n  }\n  final Calendar cal=new GregorianCalendar();\n  cal.setTime(dateInst);\n  cal.add(Calendar.DAY_OF_YEAR,-numDays);\n  return cal.getTime();\n}\n", "docstring": "method to return a date instance which is exactly numdays days before the point in time designated by the input date .", "partition": "test"}
{"idx": "3629", "code": "public final int remainingCapacity(){\n  return Math.max(0,capacity - cache.size());\n}\n", "docstring": "gets the number of entries that can be added to this cache without the need for removing stale entries .", "partition": "test"}
{"idx": "3630", "code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeObject(conservativeApproximation);\n}\n", "docstring": "calls the super method and writes the conservative approximation of the knn distances of this entry to the specified stream .", "partition": "test"}
{"idx": "3631", "code": "int putData(Object data) throws FitsException {\n  long lsize=ArrayFuncs.computeLSize(data);\n  if (lsize > Integer.MAX_VALUE) {\n    throw new FitsException(\"FITS Heap > 2 G\");\n  }\n  int size=(int)lsize;\n  expandHeap(size);\n  ByteArrayOutputStream bo=new ByteArrayOutputStream(size);\n  try {\n    BufferedDataOutputStream o=new BufferedDataOutputStream(bo);\n    o.writeArray(data);\n    o.flush();\n    o.close();\n  }\n catch (  IOException e) {\n    throw new FitsException(\"Unable to write variable column length data\",e);\n  }\n  System.arraycopy(bo.toByteArray(),0,this.heap,this.heapSize,size);\n  int oldOffset=this.heapSize;\n  this.heapSize+=size;\n  return oldOffset;\n}\n", "docstring": "add some data to the heap .", "partition": "test"}
{"idx": "3632", "code": "public void paint(Graphics g){\n  try {\n    super.paint(g);\n  }\n catch (  Exception e) {\n  }\n  int focusedRow=getFocusedRow(true);\n  if (focusedRow != -1 && focusedRow < getRowCount()) {\n    Border rowBorder=UIManager.getBorder(\"Table.focusRowHighlightBorder\");\n    if (rowBorder != null) {\n      Rectangle rect=getCellRect(focusedRow,0,true);\n      rect.width=getWidth();\n      rowBorder.paintBorder(this,g,rect.x,rect.y,rect.width,rect.height);\n    }\n  }\n}\n", "docstring": "paints the table & a focused row border .", "partition": "test"}
{"idx": "3633", "code": "private void add(final JLabel label,final JTextField field){\n  panel.add(label);\n  panel.add(field);\n  if (previous == null) {\n    layout.putConstraint(SpringLayout.NORTH,panel,-SPACING,SpringLayout.NORTH,label);\n  }\n else {\n    layout.putConstraint(SpringLayout.NORTH,label,SPACING,SpringLayout.SOUTH,previous);\n  }\n  layout.putConstraint(SpringLayout.WEST,panel,-SPACING,SpringLayout.WEST,label);\n  layout.putConstraint(SpringLayout.SOUTH,panel,SPACING,SpringLayout.SOUTH,label);\n  layout.putConstraint(SpringLayout.EAST,field,-SPACING,SpringLayout.EAST,panel);\n  layout.putConstraint(SpringLayout.WEST,field,-(TEXT_FIELD_WIDTH + SPACING),SpringLayout.EAST,panel);\n  layout.putConstraint(SpringLayout.SOUTH,field,SPACING,SpringLayout.SOUTH,label);\n  previous=label;\n}\n", "docstring": "adds a label and a field combination .", "partition": "test"}
{"idx": "3634", "code": "private void onTrackPointStart(Attributes attributes){\n  latitude=attributes.getValue(ATTRIBUTE_LAT);\n  longitude=attributes.getValue(ATTRIBUTE_LON);\n  altitude=null;\n  time=null;\n}\n", "docstring": "on track point start .", "partition": "test"}
{"idx": "3635", "code": "public static byte[] combine(final List<byte[]> dataChunks){\n  int totalSize=0;\n  for (  final byte[] dataPart : dataChunks) {\n    totalSize+=dataPart.length;\n  }\n  final byte[] data=new byte[totalSize];\n  int index=0;\n  for (  final byte[] dataPart : dataChunks) {\n    System.arraycopy(dataPart,0,data,index,dataPart.length);\n    index+=dataPart.length;\n  }\n  return data;\n}\n", "docstring": "combines a list of byte arrays into one big byte array .", "partition": "test"}
{"idx": "3636", "code": "public void commit(IResource[] resources,String comment,boolean keepLocks,IProgressMonitor monitor) throws TeamException {\n  if (monitor == null) {\n    monitor=new NullProgressMonitor();\n  }\n  Map table=getProviderMapping(resources);\n  Set keySet=table.keySet();\n  monitor.beginTask(\"\",keySet.size() * 1000);\n  monitor.setTaskName(Policy.bind(\"RepositoryManager.committing\"));\n  Iterator iterator=keySet.iterator();\n  while (iterator.hasNext()) {\n    IProgressMonitor subMonitor=new SubProgressMonitor(monitor,1000);\n    SVNTeamProvider provider=(SVNTeamProvider)iterator.next();\n    List list=(List)table.get(provider);\n    IResource[] providerResources=(IResource[])list.toArray(new IResource[list.size()]);\n    provider.checkin(providerResources,comment,keepLocks,IResource.DEPTH_INFINITE,subMonitor);\n  }\n}\n", "docstring": "commit the given resources to their associated providers .", "partition": "test"}
{"idx": "3637", "code": "public boolean canSpawnWorkers(){\n  boolean canSpawnWorker=false;\n  if (verboseLogLevel > 5) {\n    Utilities.verboseLog(\"canSpawnWorkers - gridName: \" + gridName + \" tier : \"+ tier+ \" maxTierDepth: \"+ maxTierDepth+ \" lifeRemaing: \"+ lifeRemaining()+ \" maximumLifeMillis: \"+ maximumLifeMillis);\n  }\n  if (!gridName.equals(\"lsf\")) {\n    return false;\n  }\n  if (clusterState != null) {\n    Long timeSinceClusterLastUpdatedClusterState=System.currentTimeMillis() - clusterState.getLastUpdated();\n    Utilities.verboseLog(\"timeSinceClusterLastUpdatedClusterState: \" + timeSinceClusterLastUpdatedClusterState);\n    if (timeSinceClusterLastUpdatedClusterState > 2 * gridCheckInterval * 1000) {\n      Utilities.verboseLog(\"ClusterState is not uptodate:\" + clusterState.toString());\n      return false;\n    }\n  }\n else {\n    return false;\n  }\n  if (tier == maxTierDepth) {\n    return false;\n  }\n  if (lifeRemaining() < (maximumLifeMillis * 0.25)) {\n    return false;\n  }\nswitch (tier) {\ncase 1:\n    canSpawnWorker=true;\n  break;\ncase 2:\ncanSpawnWorker=true;\nbreak;\ncase 3:\ncanSpawnWorker=true;\nbreak;\ncase 4:\ncanSpawnWorker=true;\nbreak;\ndefault :\nif (gridThrottle) {\ncanSpawnWorker=false;\n}\n else {\ncanSpawnWorker=true;\n}\n}\nreturn canSpawnWorker;\n}\n", "docstring": "check if this worker can spawn any worker", "partition": "test"}
{"idx": "3638", "code": "public boolean equals(Object object){\n  if (object == null || !(object instanceof SessionID)) {\n    return false;\n  }\n  SessionID another=(SessionID)object;\n  return encryptedString.equals(another.encryptedString);\n}\n", "docstring": "compares this session id to the specified object . the result is true if and only if the argument is not null and the random string and server name are the same in both objects .", "partition": "test"}
{"idx": "3639", "code": "public static boolean areIdentical(String playerIdent,OfflinePlayer compareTo){\n  return playerIdent.equals(getIdentificationForAsString(compareTo));\n}\n", "docstring": "returns whether a given ident matches that of another offline player", "partition": "test"}
{"idx": "3640", "code": "protected String stringWithoutHeader(){\n  StringBuffer text=new StringBuffer();\n  for (int i=0; i < numInstances(); i++) {\n    text.append(instance(i));\n    if (i < numInstances() - 1) {\n      text.append('\\n');\n    }\n  }\n  return text.toString();\n}\n", "docstring": "returns the instances in the dataset as a string in arff format . strings are quoted if they contain whitespace characters , or if they are a question mark .", "partition": "test"}
{"idx": "3641", "code": "public final <T>void removeInternal(List<T> list,int position){\n  if (hasHeaderView() && position == 0)   return;\n  if (enableLoadMore() && position == getItemCount() - 1)   return;\n  if (list.size() > 0) {\nsynchronized (mLock) {\n      list.remove(hasHeaderView() ? position - 1 : position);\n    }\n    removeNotifyExternal(position);\n    notifyItemRemoved(position);\n  }\n}\n", "docstring": "remove a item of the list of the adapter", "partition": "test"}
{"idx": "3642", "code": "public AMPrimaryMastHeadViewBean(String name){\n  super(name);\n}\n", "docstring": "creates an instance of base view bean object .", "partition": "test"}
{"idx": "3643", "code": "public boolean consumedGesture(){\n  return reacted;\n}\n", "docstring": "returns true if the gesture was consumed by the server .", "partition": "test"}
{"idx": "3644", "code": "private void initializeLayer(List<Neuron> layer,NeuronUpdateRule nodeType,int nodes){\n  for (int i=0; i < nodes; i++) {\n    Neuron node=new Neuron(getParentNetwork(),nodeType);\n    layer.add(node);\n  }\n}\n", "docstring": "helper method to initialize a layer by adding the desired number of neurons with the desired neuron update rule .", "partition": "test"}
{"idx": "3645", "code": "public static double angle(Coordinate p){\n  return Math.atan2(p.y,p.x);\n}\n", "docstring": "returns the angle that the vector from ( 0 , 0 ) to p , relative to the positive x - axis . the angle is normalized to be in the range ( - pi , pi ", "partition": "test"}
{"idx": "3646", "code": "public void fireNeuronMoved(final Neuron moved){\n  for (  NeuronListener listener : neuronListeners) {\n    listener.neuronMoved(new NetworkEvent<Neuron>(this,moved));\n  }\n}\n", "docstring": "fire a network changed event to all registered model listeners .", "partition": "test"}
{"idx": "3647", "code": "public static X509Certificate createCertificateFromBytes(byte[] certBytes){\n  X509Certificate cert=null;\n  CertificateFactory certFactory;\n  try {\n    certFactory=CertificateFactory.getInstance(\"X.509\");\n    InputStream in=new ByteArrayInputStream(certBytes);\n    cert=(X509Certificate)certFactory.generateCertificate(in);\n  }\n catch (  CertificateException e) {\n    logger.warn(\"Excpetion caught in CryptCore.\" + \"createCertificateFromBytes, returning null\",e);\n  }\n  return cert;\n}\n", "docstring": "creates an x509 certificate for a given byte array", "partition": "test"}
{"idx": "3648", "code": "void handleSelectionChanged(String selection){\n  if (mDidExpandSelection) {\n    mDidExpandSelection=false;\n    return;\n  }\n  if (selection == null || selection.isEmpty()) {\n    scheduleInvalidTapNotification();\n    if (mSelectionType == SelectionType.TAP) {\n      resetSelectionStates();\n      return;\n    }\n  }\n  if (selection != null && !selection.isEmpty()) {\n    unscheduleInvalidTapNotification();\n  }\n  mSelectedText=selection;\n  if (mWasTapGestureDetected) {\n    mSelectionType=SelectionType.TAP;\n    handleSelection(selection,mSelectionType);\n    mWasTapGestureDetected=false;\n  }\n else {\n    mHandler.handleSelectionModification(selection,mX,mY);\n  }\n}\n", "docstring": "handles a change in the current selection .", "partition": "test"}
{"idx": "3649", "code": "public TermsAckParser parse() throws ParserConfigurationException, SAXException, ParseFailureException {\n  try {\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(mInputSource,this);\n    return this;\n  }\n catch (  IOException e) {\n    throw new ParseFailureException(\"Failed to parse input source!\",e);\n  }\n}\n", "docstring": "parse the terms ack information", "partition": "test"}
{"idx": "3650", "code": "public static String format(final String value,String... params){\n  validate(value,NULL_STRING_PREDICATE,NULL_STRING_MSG_SUPPLIER);\n  Pattern p=Pattern.compile(\"\\\\{(\\\\w+)\\\\}\");\n  Matcher m=p.matcher(value);\n  String result=value;\n  while (m.find()) {\n    int paramNumber=Integer.parseInt(m.group(1));\n    if (params == null || paramNumber >= params.length) {\n      throw new IllegalArgumentException(\"params does not have value for \" + m.group());\n    }\n    result=result.replace(m.group(),params[paramNumber]);\n  }\n  return result;\n}\n", "docstring": "formats a string using parameters", "partition": "test"}
{"idx": "3651", "code": "public Builder server(String server){\n  if (server.endsWith(\"/\") == false) {\n    server=server + \"/\";\n  }\n  this.server=server;\n  return this;\n}\n", "docstring": "set the server url to be used by parse . this method is only required if you intend to use a different api server than the one at api . parse . com .", "partition": "test"}
{"idx": "3652", "code": "private ResponsePacket executeCount(QueryTemplatePacket template,IJSpace space,Transaction txn) throws SQLException {\n  try {\n    template.setRouting(getRouting());\n    template.setExplainPlan(getExplainPlan());\n    int count=space.count(template,txn,getReadModifier());\n    ResponsePacket response=new ResponsePacket();\n    Object[][] values=new Object[1][1];\n    values[0][0]=count;\n    ResultEntry result=new ResultEntry(new String[]{getCountColumnName()},new String[]{getCountColumnLabel()},new String[]{\"\"},values);\n    response.setResultEntry(result);\n    return response;\n  }\n catch (  Exception e) {\n    if (_logger.isLoggable(Level.SEVERE)) {\n      _logger.log(Level.SEVERE,e.getMessage(),e);\n    }\n    throw new SQLException(\"Failed to execute count: \" + e,\"GSP\",-111);\n  }\n}\n", "docstring": "handle read query - check if it is a read query or a readmultiple and execute it", "partition": "test"}
{"idx": "3653", "code": "void deriveConfidenceValue(double baseCount){\n  if (Utils.isMissingValue(m_confidence) && !Utils.isMissingValue(baseCount) && baseCount > 0) {\n    m_confidence=m_recordCount / baseCount;\n  }\n}\n", "docstring": "backfit confidence value ( does nothing if the confidence value is already set ) .", "partition": "test"}
{"idx": "3654", "code": "public ModifiableSolrParams add(String name,String... val){\n  String[] old=vals.put(name,val);\n  if (old != null) {\n    if (val == null || val.length < 1) {\n      String[] both=new String[old.length + 1];\n      System.arraycopy(old,0,both,0,old.length);\n      both[old.length]=null;\n      vals.put(name,both);\n    }\n else {\n      String[] both=new String[old.length + val.length];\n      System.arraycopy(old,0,both,0,old.length);\n      System.arraycopy(val,0,both,old.length,val.length);\n      vals.put(name,both);\n    }\n  }\n  return this;\n}\n", "docstring": "add the given values to any existing name", "partition": "test"}
{"idx": "3655", "code": "public ByteArrayDataSource(InputStream is,String type){\n  try {\n    ByteArrayOutputStream os=new ByteArrayOutputStream();\n    int ch;\n    while ((ch=is.read()) != -1) {\n      os.write(ch);\n    }\n    m_data=os.toByteArray();\n  }\n catch (  IOException ioex) {\n    log.log(Level.WARNING,\"\",ioex);\n  }\n  if (type != null && type.length() > 0)   m_type=type;\n}\n", "docstring": "create a datasource from an input stream", "partition": "test"}
{"idx": "3656", "code": "public static int inflate(byte[] previous,int previousLength,byte[] current,int currentLength,byte[] result){\n  if (previous == null) {\n    System.arraycopy(current,0,result,0,currentLength);\n    return currentLength;\n  }\n  int length=0;\n  int start1=0;\n  int start2=0;\n  while (start1 < previousLength && start2 < currentLength) {\n    int end1=start1;\n    while (end1 < previousLength && previous[end1] != '\\t') {\n      end1++;\n    }\n    int end2=start2;\n    while (end2 < currentLength && current[end2] != '\\t') {\n      end2++;\n    }\n    if (current[start2] == '&' && end2 == start2 + 1) {\n      for (int i=start1; i < end1; i++)       result[length++]=previous[i];\n    }\n else {\n      for (int i=start2; i < end2; i++)       result[length++]=current[i];\n    }\n    if (end2 < currentLength)     result[length++]='\\t';\n    start1=end1 + 1;\n    start2=end2 + 1;\n  }\n  return length;\n}\n", "docstring": "inflate the current sam line by replacing all & by the corresponding field in the previous sam line", "partition": "test"}
{"idx": "3657", "code": "private void Legends(List<String> legends_list,List<Integer> color_code_list){\n  textPaint.setColor(Color.BLACK);\n  textPaint.setTextSize(20f);\n  int left=(int)(graphwidth * 0.1);\n  for (int i=0; i < legends_list.size(); i++) {\n    String label=legends_list.get(i);\n    float text_width=textPaint.measureText(label,0,label.length());\n    int color=color_code_list.get(i);\n    if (!((graphwidth - legendLeft) > (text_width + 60))) {\n      legendTop-=60;\n      legendLeft=left;\n    }\n    addLegends(canvas,color,legendTop,legendLeft,legendRight,legendBottom,label);\n    legendLeft+=((int)text_width + 60);\n  }\n}\n", "docstring": "this function calculates the position for each legend", "partition": "test"}
{"idx": "3658", "code": "private void fetchMetadata(TableMapLogEvent tableEvent) throws SQLException, ReplicatorException {\n  if (metadataCache == null)   metadataCache=new TableMetadataCache(5000);\n  Table table=metadataCache.retrieve(tableEvent.getDatabaseName(),tableEvent.getTableName());\n  if (table == null || table.getTableId() != tableEvent.getTableId()) {\n    prepareMetadataConnection();\n    table=metadataConnection.findTable(tableEvent.getDatabaseName(),tableEvent.getTableName(),false);\n    if (table != null) {\n      table.setTableId(tableEvent.getTableId());\n      metadataCache.store(table);\n    }\n  }\n else   if (logger.isDebugEnabled())   logger.debug(\"Table \" + tableEvent.getDatabaseName() + \".\"+ tableEvent.getTableName()+ \" found in cache.\");\n  if (table == null) {\n    logger.warn(\"No metadata found for table \" + tableEvent.getDatabaseName() + \".\"+ tableEvent.getTableName());\n  }\n else {\n    tableEvent.setTable(table);\n  }\n}\n", "docstring": "fetches metadata for the table from the cache or from the database if needed", "partition": "test"}
{"idx": "3659", "code": "public String encode(){\n  StringBuffer sb=new StringBuffer();\n  encode(sb);\n  return sb.toString();\n}\n", "docstring": "returns the encoded string representing the object type signature .", "partition": "test"}
{"idx": "3660", "code": "@Override public int read(byte[] buf,int offset,int len) throws IOException {\n  int available=_available;\n  if (available > 0) {\n    len=Math.min(len,available);\n    len=_next.read(buf,offset,len);\n    if (len > 0) {\n      _available-=len;\n    }\n  }\n else   if (available == 0) {\n    _available=readChunkLength();\n    if (_available > 0) {\n      len=Math.min(len,_available);\n      len=_next.read(buf,offset,len);\n      if (len > 0)       _available-=len;\n    }\n else {\n      _available=-1;\n      len=-1;\n    }\n  }\n else {\n    len=-1;\n  }\n  return len;\n}\n", "docstring": "reads more data from the input stream .", "partition": "test"}
{"idx": "3661", "code": "@Override public void flush(){\n  FlushTask task;\nsynchronized (logRecords) {\n    task=new FlushTask(new ArrayList<String>(logRecords));\n    logRecords.clear();\n  }\n  task.run();\n}\n", "docstring": "flushes the buffered logrecords .", "partition": "test"}
{"idx": "3662", "code": "public static ArrayList<Page> pageCreatorButtons(ArrayList<Page> pages,Item manualType){\n  ArrayList<Page> newPages=new ArrayList<>();\n  int pageAmount=pages.size();\n  int times=0;\n  while (pageAmount > 0) {\n    ArrayList<Page> pagesTemp=new ArrayList<>();\n    pagesTemp.addAll(pages.subList(7 * times,(pageAmount > 7 ? 7 + 7 * times : 7 * times + pageAmount)));\n    int height=0;\n    ArrayList<ManualWidgetBase> widgets=new ArrayList<>();\n    for (    Page page : pagesTemp) {\n      widgets.add(new ButtonWidget(15,10 + height,page));\n      height+=20;\n    }\n    newPages.add(new Page(\"index\" + times,(ArrayList<ManualWidgetBase>)widgets.clone(),false,manualType));\n    widgets.clear();\n    pagesTemp.clear();\n    pageAmount-=7;\n    times++;\n  }\n  return newPages;\n}\n", "docstring": "creates the button pages for a category", "partition": "test"}
{"idx": "3663", "code": "protected List<String> createNewExportMaskWorkflowForInitiators(List<URI> initiatorURIs,ExportGroup exportGroup,Workflow workflow,Map<URI,Integer> volumeMap,StorageSystem storage,String token,String previousStep) throws Exception {\n  List<String> newSteps=new ArrayList<>();\n  if (!initiatorURIs.isEmpty()) {\n    Map<String,List<URI>> computeResourceToInitiators=mapInitiatorsToComputeResource(exportGroup,initiatorURIs);\n    for (    Map.Entry<String,List<URI>> resourceEntry : computeResourceToInitiators.entrySet()) {\n      String computeKey=resourceEntry.getKey();\n      List<URI> computeInitiatorURIs=resourceEntry.getValue();\n      _log.info(String.format(\"New export masks for %s\",computeKey));\n      GenExportMaskCreateWorkflowResult result=generateDeviceSpecificExportMaskCreateWorkFlow(workflow,previousStep,storage,exportGroup,computeInitiatorURIs,volumeMap,token);\n      previousStep=result.getStepId();\n      newSteps.add(previousStep);\n    }\n  }\n  if (newSteps.isEmpty() && previousStep != null) {\n    newSteps.add(previousStep);\n  }\n  return newSteps;\n}\n", "docstring": "creates a new exportmask for host for the given initiators .", "partition": "test"}
{"idx": "3664", "code": "public boolean isLessThen(Percent Percent){\n  assertDefined();\n  BigDecimal thisValue=notNull(this);\n  BigDecimal parameter=notNull(Percent);\n  return (thisValue.compareTo(parameter) < 0);\n}\n", "docstring": "compares two percent objects .", "partition": "test"}
{"idx": "3665", "code": "@Override public URI toEdgeURI(final Object key){\n  return toURI(key.toString());\n}\n", "docstring": "override to allow for colons in the id without urlencoding them .", "partition": "test"}
{"idx": "3666", "code": "public static List<INaviProject> loadProjects(final AbstractSQLProvider provider,final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {\n  PostgreSQLDatabaseFunctions.checkArguments(provider,debuggerManager);\n  final CConnection connection=provider.getConnection();\n  final List<INaviProject> projects=new ArrayList<>();\n  if (!PostgreSQLHelpers.hasTable(connection,CTableNames.PROJECTS_TABLE)) {\n    return projects;\n  }\n  String query=\"SELECT id, name, description, creation_date, modification_date, \" + \" (SELECT count(*) FROM \" + CTableNames.ADDRESS_SPACES_TABLE + \" WHERE project_id = \"+ CTableNames.PROJECTS_TABLE+ \".id) \"+ \" AS addressspace_count FROM \"+ CTableNames.PROJECTS_TABLE;\n  try (ResultSet resultSet=connection.executeQuery(query,true)){\n    while (resultSet.next()) {\n      final int projectId=resultSet.getInt(\"id\");\n      final String name=PostgreSQLHelpers.readString(resultSet,\"name\");\n      final String description=PostgreSQLHelpers.readString(resultSet,\"description\");\n      final int addressSpaceCount=resultSet.getInt(\"addressspace_count\");\n      final Timestamp creationDate=resultSet.getTimestamp(\"creation_date\");\n      final Timestamp modificationDate=resultSet.getTimestamp(\"modification_date\");\n      final List<DebuggerTemplate> debuggers=PostgreSQLDatabaseFunctions.getAssignedDebuggers(connection,projectId,debuggerManager);\n      projects.add(new CProject(projectId,name,description == null ? \"\" : description,creationDate,modificationDate,addressSpaceCount,debuggers,provider));\n    }\n  }\n catch (  final SQLException e) {\n    throw new CouldntLoadDataException(e);\n  }\n  return new ArrayList<INaviProject>(projects);\n}\n", "docstring": "loads the projects of a database .", "partition": "test"}
{"idx": "3667", "code": "public String syllabify(String phoneString){\n  LinkedList<String> phoneList=splitIntoAllophones(phoneString);\n  syllabify(phoneList);\n  StringBuilder sb=new StringBuilder();\n  for (  String p : phoneList) {\n    if (sb.length() > 0)     sb.append(\" \");\n    sb.append(p);\n  }\n  return sb.toString();\n}\n", "docstring": "syllabify a phonetic string , marking syllable boundaries with dash characters in the output . if the input marks stressed vowels with a suffix \" 1 \" , these marks are removed , and single quotes ( \"'\" ) are inserted at the beginning of the corresponding syllable .", "partition": "test"}
{"idx": "3668", "code": "@Override protected Node removeFromFrontier(){\n  cleanUpFrontier();\n  Node result=frontier.remove();\n  updateMetrics(frontier.size());\n  setExplored(result);\n  return result;\n}\n", "docstring": "cleans up the head of the frontier , removes the first node of a non - explored state from the head of the frontier , adds it to the corresponding explored map , and returns the node .", "partition": "test"}
{"idx": "3669", "code": "public static boolean isFile(String path){\n  File f=new File(path);\n  return f.isFile();\n}\n", "docstring": "checks if the given path is a file", "partition": "test"}
{"idx": "3670", "code": "public boolean equals(Object object){\n  if (!(object instanceof ObjectInstance)) {\n    return false;\n  }\n  ObjectInstance val=(ObjectInstance)object;\n  if (!name.equals(val.getObjectName()))   return false;\n  if (className == null)   return (val.getClassName() == null);\n  return className.equals(val.getClassName());\n}\n", "docstring": "compares the current object instance with another object instance .", "partition": "test"}
{"idx": "3671", "code": "public ZookeeperEmbedded(int port){\n  this.port=port;\n  this.logDir=new File(System.getProperty(\"java.io.tmpdir\"),\"zk/logs/zookeeper-test-\" + port);\n}\n", "docstring": "create zookeeper testing server .", "partition": "test"}
{"idx": "3672", "code": "public BasicCondition(String variable,Value value,Relation relation){\n  this.variable=Template.create(variable);\n  this.templateValue=Template.create(value.toString());\n  this.groundValue=value;\n  this.relation=relation;\n}\n", "docstring": "creates a new basic condition , given a variable label , an expected value , and a relation to hold between the variable and its value", "partition": "test"}
{"idx": "3673", "code": "public static Set<String> readStopwordsPath(Path path,boolean lowercase) throws IOException {\n  return readStopwordsInputStream(Files.newInputStream(path),lowercase);\n}\n", "docstring": "read a file containing stopwords ( one per line ) . < p > empty lines and lines starting with ( \" # \" ) are filtered out .", "partition": "test"}
{"idx": "3674", "code": "@Override public String toString(){\n  StringBuilder sRep=new StringBuilder();\n  sRep.append(\'(\');\n  sRep.append(articleID);\n  sRep.append(\", \");\n  sRep.append(revisionCounter);\n  sRep.append(\", \");\n  sRep.append(timeStamp);\n  sRep.append(\", \");\n  sRep.append(revisionId);\n  if (revisionText != null) {\n    sRep.append(\", \");\n    sRep.append(revisionText.length());\n  }\n  sRep.append(\')\');\n  return sRep.toString();\n}\n", "docstring": "returns the string representation of this object .", "partition": "test"}
{"idx": "3675", "code": "protected void sendLogEvent(String component,String message,Callback<Object> callback){\n  String syslogMessage=String.format(Locale.US,\"<22>%s %s %s:%s\",getSysLogFormattedDate(),utils.getApplicationName(context),component,message);\n  sendDataOverUDP(syslogMessage,callback);\n}\n", "docstring": "create properly formatted message to send over udp that acts like a syslog message syslog format : \" & lt ; priority & gt ; timestamp orange_link blue_link : message \" details : http : / / en . wikipedia . org / wiki / syslog # priority", "partition": "test"}
{"idx": "3676", "code": "public static <T extends Throwable>T writeStackTraces(T throwable,StreamOutput out) throws IOException {\n  StackTraceElement[] stackTrace=throwable.getStackTrace();\n  out.writeVInt(stackTrace.length);\n  for (  StackTraceElement element : stackTrace) {\n    out.writeString(element.getClassName());\n    out.writeOptionalString(element.getFileName());\n    out.writeString(element.getMethodName());\n    out.writeVInt(element.getLineNumber());\n  }\n  Throwable[] suppressed=throwable.getSuppressed();\n  out.writeVInt(suppressed.length);\n  for (  Throwable t : suppressed) {\n    out.writeThrowable(t);\n  }\n  return throwable;\n}\n", "docstring": "serializes the given exceptions stacktrace elements as well as it \"'\" s suppressed exceptions to the given output stream .", "partition": "test"}
{"idx": "3677", "code": "public DistributedLogMultiStreamWriter build(){\n  Preconditions.checkArgument((null != _streams && !_streams.isEmpty()),\"No streams provided\");\n  Preconditions.checkNotNull(_client,\"No distributedlog client provided\");\n  Preconditions.checkNotNull(_codec,\"No compression codec provided\");\n  Preconditions.checkArgument(_firstSpeculativeTimeoutMs > 0 && _firstSpeculativeTimeoutMs <= _maxSpeculativeTimeoutMs && _speculativeBackoffMultiplier > 0 && _maxSpeculativeTimeoutMs < _requestTimeoutMs,\"Invalid speculative timeout settings\");\n  return new DistributedLogMultiStreamWriter(_streams,_client,Math.min(_bufferSize,MAX_LOGRECORDSET_SIZE),_flushIntervalMicros,_requestTimeoutMs,_firstSpeculativeTimeoutMs,_maxSpeculativeTimeoutMs,_speculativeBackoffMultiplier,_codec,_ticker,_executorService);\n}\n", "docstring": "build the multi stream writer .", "partition": "test"}
{"idx": "3678", "code": "private ImageElement(int AD_PrintFormatItem_ID){\n  loadAttachment(AD_PrintFormatItem_ID);\n}\n", "docstring": "create image from attachment", "partition": "test"}
{"idx": "3679", "code": "public ThreadRegisterValues(final ThreadRegisters values){\n  m_tid=values.getTid();\n  for (  final RegisterValue value : values.getRegisters()) {\n    m_values.add(new Register(value));\n  }\n}\n", "docstring": "creates a new thread register values object .", "partition": "test"}
{"idx": "3680", "code": "public LauncherDiscoveryRequestBuilder configurationParameters(Map<String,String> configurationParameters){\n  Preconditions.notNull(configurationParameters,\"configuration parameters map must not be null\");\n  configurationParameters.forEach(null);\n  return this;\n}\n", "docstring": "add all of the supplied configuration parameters to the request .", "partition": "test"}
{"idx": "3681", "code": "public void addAll(int index,int[] data){\n  int dataLen=data.length;\n  if (dataLen == 0) {\n    return;\n  }\n  int newcap=size + (int)(dataLen * 1.1) + 1;\n  ensureCapacity(newcap);\n  System.arraycopy(array,index,array,index + dataLen,size - index);\n  System.arraycopy(data,0,array,index,dataLen);\n  size+=dataLen;\n}\n", "docstring": "appends all of the elements in the specified array at the specified position in this list .", "partition": "test"}
{"idx": "3682", "code": "public int read(byte[] b) throws java.io.IOException {\n  return read(b,0,b.length);\n}\n", "docstring": "reads some number of bytes from the input stream and stores them into the buffer array b . the number of bytes actually read is returned as an integer . this method blocks until input data is available , end of file is detected , or an exception is thrown . if b is null , a nullpointerexception is thrown . if the length of b is zero , then no bytes are read and 0 is returned ; otherwise , there is an attempt to read at least one byte . if no byte is available because the stream is at end of file , the value - 1 is returned ; otherwise , at least one byte is read and stored into b . the first byte read is stored into element b [ 0 ", "partition": "test"}
{"idx": "3683", "code": "public void removeScanningCallback(OneSheeldScanningCallback scanningCallback){\n  if (scanningCallback != null && scanningCallbacks.contains(scanningCallback))   scanningCallbacks.remove(scanningCallback);\n}\n", "docstring": "remove a scanning callback .", "partition": "test"}
{"idx": "3684", "code": "public void paintRect(Graphics g,JComponent c,int x,int y,int w,int h){\n  Rectangle bounds=c.getBounds();\n  check(bounds);\n  g.drawImage(m_backImage,x,y,x + w,h + y,x,y,x + w,y + h,c);\n}\n", "docstring": "paint / copy background to component rectangle", "partition": "test"}
{"idx": "3685", "code": "@Override public final void sample(){\n  _value=_acquireCount.get() - _releaseCount.get();\n}\n", "docstring": "return the probe \"'\" s next average .", "partition": "test"}
{"idx": "3686", "code": "private boolean isPageBreak(int row){\n  for (int i=0; i < m_pageBreak.size(); i++) {\n    Integer rr=(Integer)m_pageBreak.get(i);\n    if (rr.intValue() + 1 == row)     return true;\n else     if (rr.intValue() > row)     return false;\n  }\n  return false;\n}\n", "docstring": "check for for pagebreak", "partition": "test"}
{"idx": "3687", "code": "public ExecutorService shutdown(){\n  pool.shutdown();\n  return pool;\n}\n", "docstring": "shuts down the internal thread pool . if you need to do more a advanced shutdown , the pool is returned .", "partition": "test"}
{"idx": "3688", "code": "public static boolean isPropositionSymbolIdentifierPart(char ch){\n  return Character.isJavaIdentifierPart(ch);\n}\n", "docstring": "determine if the given character is part of a proposition symbol .", "partition": "test"}
{"idx": "3689", "code": "public static void o(Zdiagmat D){\n  o(D,Parameters.OutputFieldWidth,Parameters.OutputFracPlaces);\n}\n", "docstring": "prints a zdiagmat in default format .", "partition": "test"}
{"idx": "3690", "code": "public int search(String txt){\n  int M=pat.length();\n  int N=txt.length();\n  int skip;\n  for (int i=0; i <= N - M; i+=skip) {\n    skip=0;\n    for (int j=M - 1; j >= 0; j--) {\n      if (pat.charAt(j) != txt.charAt(i + j)) {\n        skip=Math.max(1,j - right[txt.charAt(i + j)]);\n        break;\n      }\n    }\n    if (skip == 0)     return i;\n  }\n  return N;\n}\n", "docstring": "returns the index of the first occurrence of the pattern string in the text string .", "partition": "test"}
{"idx": "3691", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(2);\n  newVector.addElement(new Option(\"\\tSpecify list of columns to copy. First and last are valid\\n\" + \"\\tindexes. (default none)\",\"R\",1,\"-R <index1,index2-index4,...>\"));\n  newVector.addElement(new Option(\"\\tInvert matching sense (i.e. copy all non-specified columns)\",\"V\",0,\"-V\"));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "3692", "code": "public String toChars(int[] indices){\n  StringBuilder s=new StringBuilder(indices.length);\n  for (int i=0; i < indices.length; i++)   s.append(toChar(indices[i]));\n  return s.toString();\n}\n", "docstring": "returns the characters corresponding to the argument indices .", "partition": "test"}
{"idx": "3693", "code": "public static final String trunc(final String str,final int length){\n  if (str == null) {\n    return str;\n  }\n  if (str.length() <= length) {\n    return str;\n  }\n  return str.substring(0,length);\n}\n", "docstring": "truncate string to a given length .", "partition": "test"}
{"idx": "3694", "code": "public void clearTransactions(int fromHeight){\n  lock.lock();\n  try {\n    if (fromHeight == 0) {\n      unspent.clear();\n      spent.clear();\n      pending.clear();\n      dead.clear();\n      transactions.clear();\n    }\n else {\n      throw new UnsupportedOperationException();\n    }\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "deletes transactions which appeared above the given block height from the wallet , but does not touch the keys . this is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up .", "partition": "test"}
{"idx": "3695", "code": "@Override public boolean load(final Player player,final List<String> args){\n  groovyBinding.setVariable(\"player\",player);\n  if (args != null) {\n    groovyBinding.setVariable(\"args\",args.toArray(new String[args.size()]));\n  }\n else {\n    groovyBinding.setVariable(\"args\",new String[0]);\n  }\n  final GroovyShell interp=new GroovyShell(groovyBinding);\n  boolean ret=true;\n  preExecute(player,args);\n  try {\n    final File f=new File(groovyScript);\n    interp.evaluate(f);\n  }\n catch (  final Exception e) {\n    logger.error(\"Exception while sourcing file \" + groovyScript,e);\n    setMessage(e.getMessage());\n    ret=false;\n  }\ncatch (  final Error e) {\n    logger.error(\"Exception while sourcing file \" + groovyScript,e);\n    setMessage(e.getMessage());\n    ret=false;\n  }\n  postExecute(player,args,ret);\n  return (ret);\n}\n", "docstring": "initial load of this script .", "partition": "test"}
{"idx": "3696", "code": "@Override public boolean wasSuccessful(){\n  return isFinished() && getCurrentPoints() >= successThreashold;\n}\n", "docstring": "the attack is only successful if the xsw message is accepted .", "partition": "test"}
{"idx": "3697", "code": "void startLocatingPhone(){\n  Intent intent=new Intent(sContext,LocationService.class);\n  intent.setAction(LocationService.START_SERVICE);\n  intent.putExtra(\"to\",this.mAnswerTo);\n  sContext.startService(intent);\n}\n", "docstring": "starts the geolocation service", "partition": "test"}
{"idx": "3698", "code": "public void deleteResourceConfig(String clusterName,ResourceType resourceType,String dsName) throws ConfigurationException {\n  if (getClusterHome() == null) {\n    throw new ConfigurationException(\"No home directory found from which to configure resources.\");\n  }\n  File resources=getDir(getResourceConfigDirName(getClusterHome(),clusterName,resourceType));\n  String delFileName=resources.getAbsolutePath() + File.separator + dsName+ \".properties\";\n  delFile(delFileName);\n}\n", "docstring": "delete a specific resource configuration .", "partition": "test"}
{"idx": "3699", "code": "public BusMovement(BusMovement proto){\n  super(proto);\n  this.controlSystem=proto.controlSystem;\n  this.id=nextID++;\n  controlSystem.registerBus(this);\n  startMode=true;\n}\n", "docstring": "create a new instance from a prototype", "partition": "test"}
{"idx": "3700", "code": "private void createGui(){\n  for (  final IResultsPanel panel : m_factory) {\n    m_tabbedPane.addTab(panel.getTitle(),panel.getComponent());\n  }\n  add(m_tabbedPane,BorderLayout.CENTER);\n  m_tabbedPane.setVisible(true);\n}\n", "docstring": "creates the sub - components of the panel .", "partition": "test"}
{"idx": "3701", "code": "public static float generateRandomFloatBetween(float lowerLimit,float upperLimit){\n  return lowerLimit + ((upperLimit - lowerLimit) * _r.nextFloat());\n}\n", "docstring": "generates a random float between two limits . both limits are inclusive .", "partition": "test"}
{"idx": "3702", "code": "public SGenItemProviderAdapterFactory(){\n  supportedTypes.add(IEditingDomainItemProvider.class);\n  supportedTypes.add(IStructuredItemContentProvider.class);\n  supportedTypes.add(ITreeItemContentProvider.class);\n  supportedTypes.add(IItemLabelProvider.class);\n  supportedTypes.add(IItemPropertySource.class);\n}\n", "docstring": "this constructs an instance . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "3703", "code": "private void kdRangeSearch(int left,int right,int axis,O query,ModifiableDoubleDBIDList res,DBIDArrayIter iter,double radius){\n  if (right - left <= leafsize) {\n    for (iter.seek(left); iter.getOffset() < right; iter.advance()) {\n      double dist=norm.distance(query,relation.get(iter));\n      countObjectAccess();\n      countDistanceComputation();\n      if (dist <= radius) {\n        res.add(dist,iter);\n      }\n    }\n    return;\n  }\n  final int middle=(left + right) >>> 1;\n  O split=relation.get(iter.seek(middle));\n  countObjectAccess();\n  final double delta=split.doubleValue(axis) - query.doubleValue(axis);\n  final boolean onleft=(delta >= 0);\n  final boolean onright=(delta <= 0);\n  final boolean close=(Math.abs(delta) <= radius);\n  final int next=(axis + 1) % dims;\n  if (close) {\n    double dist=norm.distance(query,split);\n    countDistanceComputation();\n    if (dist <= radius) {\n      assert (iter.getOffset() == middle);\n      res.add(dist,iter);\n    }\n  }\n  if (left < middle && (onleft || close)) {\n    kdRangeSearch(left,middle,next,query,res,iter,radius);\n  }\n  if (middle + 1 < right && (onright || close)) {\n    kdRangeSearch(middle + 1,right,next,query,res,iter,radius);\n  }\n}\n", "docstring": "perform a knn search on the kd - tree .", "partition": "test"}
{"idx": "3704", "code": "private void connect(){\n  if (!connected) {\n    updateInfo();\n    String connectString=\"tcp://\" + connectAddress + \":\"+ connectPort;\n    if (clientId == null || clientId.length() < 1) {\n      out(getDate() + Messages.MqttClientView_15 + connectString+ Messages.MqttClientView_16);\n      return;\n    }\n    try {\n      if (firstConnect) {\n        mqttClient=new MqttClient(connectString,clientId);\n        mqttClient.setCallback(this);\n        firstConnect=false;\n      }\n    }\n catch (    MqttException e) {\n      out(getDate() + Messages.MqttClientView_17 + e.getMessage());\n      e.printStackTrace();\n    }\n    connOpts=new MqttConnectOptions();\n    connOpts.setCleanSession(cleanStart);\n    connOpts.setConnectionTimeout(30);\n    connOpts.setKeepAliveInterval(keepAlive);\n    if (username.length() > 0 && password.length() > 0) {\n      connOpts.setPassword(password.toCharArray());\n      connOpts.setUserName(username);\n    }\n    if (useWill) {\n      if (willTopic == null || willTopic.equals(\"\")) {\n        out(Messages.MqttClientView_19);\n        return;\n      }\n      connOpts.setWill(mqttClient.getTopic(willTopic),willMessage.getBytes(),willQos,willRetain);\n    }\n    try {\n      out(getDate() + Messages.MqttClientView_20 + connectString);\n      mqttClient.connect(connOpts);\n      connected=true;\n      out(getDate() + Messages.MqttClientView_21 + clientId);\n    }\n catch (    MqttException e) {\n      out(getDate() + Messages.MqttClientView_22 + e.getMessage());\n      e.printStackTrace();\n    }\n  }\n else {\n    out(Messages.MqttClientView_23);\n  }\n}\n", "docstring": "connects to the broker", "partition": "test"}
{"idx": "3705", "code": "synchronized void addTracer(Tracer tracer){\n  if (curTracers.add(tracer)) {\n    LOG.trace(toString() + \": adding tracer \" + tracer.toString());\n  }\n}\n", "docstring": "add a new tracer .", "partition": "test"}
{"idx": "3706", "code": "private void grow(){\n  int newCap=(entries.length << 1) + 1;\n  Object[] newEntries=new Object[newCap];\n  System.arraycopy(entries,0,newEntries,0,size);\n  entries=newEntries;\n}\n", "docstring": "expands capacity of internal arrays .", "partition": "test"}
{"idx": "3707", "code": "public void damage(double value){\n  setValue(Math.max(0,getValue() - value));\n}\n", "docstring": "damage component by given value .", "partition": "test"}
{"idx": "3708", "code": "@Ignore(\"Disabling due to bug #52347\") @Test public void testConcurrentEventsOnEmptyRegion(){\n  versionTestConcurrentEventsOnEmptyRegion();\n}\n", "docstring": "this tests the concurrency versioning system to ensure that event conflation happens correctly and that the statistic is being updated properly", "partition": "test"}
{"idx": "3709", "code": "public Graph(){\n  roots=new ArrayList<Node>();\n  nodes=new ArrayList<Node>();\n  string=\"\";\n}\n", "docstring": "constructs an empty graph", "partition": "test"}
{"idx": "3710", "code": "private static String trimVersion(String apiVersion){\n  if (apiVersion == null) {\n    return null;\n  }\n else {\n    String[] versionParts=apiVersion.split(\"/\");\n    return versionParts[versionParts.length - 1];\n  }\n}\n", "docstring": "separates apiversion for apigroup / apiversion combination .", "partition": "test"}
{"idx": "3711", "code": "@Override public void incomingObject(IAnalyzedInterval analyzedInterval) throws AdeException {\n  if (!m_percentilesWithEmptyIntervals && analyzedInterval.getNumUniqueMessageIds() == 0) {\n    return;\n  }\n  final double rawScore=calcRawScore(analyzedInterval);\n  if (!SeenHugeLogProb(analyzedInterval)) {\n    m_rawScores.add(rawScore);\n    ++m_intervalCount;\n  }\n}\n", "docstring": "if we do not use empty intervals to compute percentiles and there are no unique messages for this interval then we simply return . otherwise , we calculate the log probability score and add it to the list of raw scores as long as the probability isn \"'\" t a large valued probability as determined by \" mainscorerimpl . \"", "partition": "test"}
{"idx": "3712", "code": "public static String readFileAsString(File file,String encoding) throws IOException {\n  ByteBuffer buffer=readFile(file);\n  if (null == encoding) {\n    encoding=\"UTF-8\";\n  }\n  String converted=new String(buffer.array(),encoding);\n  return converted;\n}\n", "docstring": "new nio based method to read a file as a string with the given encoding .", "partition": "test"}
{"idx": "3713", "code": "public EmBayesEstimatorEditor(EmBayesEstimatorWrapper emBayesEstWrapper){\n  this(emBayesEstWrapper.getEstimateBayesIm(),emBayesEstWrapper.getDataSet());\n}\n", "docstring": "constructs a new bayes im editor from a bayes estimator wrapper .", "partition": "test"}
{"idx": "3714", "code": "public boolean needPreloadKey(int idx){\n  return preloadKeys != null && preloadKeys.get(idx);\n}\n", "docstring": "checks whether entry info should be sent to primary node from backup .", "partition": "test"}
{"idx": "3715", "code": "public int generateChallengeToken(InetSocketAddress address){\n  int token=random.nextInt();\n  challengeTokens.put(address,token);\n  return token;\n}\n", "docstring": "generate a new token .", "partition": "test"}
{"idx": "3716", "code": "@Override public void perform(IR ir){\n  for (Enumeration<BasicBlock> e=ir.getBasicBlocks(); e.hasMoreElements(); ) {\n    BasicBlock bb=e.nextElement();\n    if (bb.isEmpty())     continue;\n    container.counter2++;\n    if (bb.getInfrequent()) {\n      container.counter1++;\n      if (ir.options.FREQ_FOCUS_EFFORT)       continue;\n    }\n    for (Enumeration<Instruction> ie=bb.forwardInstrEnumerator(); ie.hasMoreElements(); ) {\n      Instruction s=ie.nextElement();\n      if (TypeCheck.conforms(s) && (invertNullAndTypeChecks(s) || pushTypeCheckBelowIf(s,ir))) {\n        ie=bb.forwardInstrEnumerator();\n      }\n    }\n  }\n}\n", "docstring": "main routine : perform the transformation .", "partition": "test"}
{"idx": "3717", "code": "public void runWithRetries(RetryableTask task) throws Exception {\n  boolean maxSleepIntervalHit=false;\n  for (int i=0; i < numAttempts; i++) {\n    try {\n      task.run();\n      return;\n    }\n catch (    Exception e) {\n      if (i == numAttempts - 1) {\n        throw e;\n      }\n      int sleepTime;\n      if (maxSleepIntervalHit) {\n        sleepTime=maxSleepInterval;\n      }\n else {\n        sleepTime=baseSleepInterval * (int)Math.pow(2,i);\n      }\n      LOG.error(\"Got an exception! Sleeping for \" + sleepTime + \" seconds and retrying.\",e);\n      try {\n        Thread.sleep(sleepTime * 1000);\n      }\n catch (      InterruptedException ie) {\n        LOG.error(\"Unexpected interruption!\",ie);\n        throw ie;\n      }\n    }\n  }\n}\n", "docstring": "run a task , retrying a fixed number of times if there is a failure .", "partition": "test"}
{"idx": "3718", "code": "public Object pack(){\n  if (collection) {\n    List l=(List)value;\n    if (Types.isArray(type)) {\n      Object[] o=(Object[])Array.newInstance(itemType,l.size());\n      l.toArray(o);\n      return o;\n    }\n  }\n  return value;\n}\n", "docstring": "based on accumulated value , produce a value for this property .", "partition": "test"}
{"idx": "3719", "code": "public void removeRequest(InterruptRequest interruptRequest){\nsynchronized (interruptRequestQueue) {\n    interruptRequestQueue.remove(interruptRequest);\n  }\n}\n", "docstring": "this is the way to remove a specific request object", "partition": "test"}
{"idx": "3720", "code": "@Override public final void onHeatmapFailed(){\n  updatePending=false;\n}\n", "docstring": "callback function when heatmap generation has failed", "partition": "test"}
{"idx": "3721", "code": "@SuppressLint(\"NewApi\") @Nullable public static Drawable inflate(boolean forceSystemHandlingWhenPossible,@NonNull Resources resources,@DrawableRes int id){\n  boolean systemHandling=isSystemHandling(forceSystemHandlingWhenPossible);\n  Log.d(LOG_TAG,String.format(\"Inflating resource with id #0x%s (system handling: %s)\",Integer.toHexString(id),systemHandling));\n  if (systemHandling) {\n    return resources.getDrawable(id,null);\n  }\n  try {\n    return VectorDrawable.create(resources,id);\n  }\n catch (  Resources.NotFoundException e) {\n    return null;\n  }\n}\n", "docstring": "inflate a drawable from a vector xml resource .", "partition": "test"}
{"idx": "3722", "code": "public static long objectFieldOffset(Field field){\n  return UNSAFE.objectFieldOffset(field);\n}\n", "docstring": "returns object field offset .", "partition": "test"}
{"idx": "3723", "code": "protected synchronized void write(long offset,byte[] b) throws IOException {\n  if (byteBuffer != null) {\n    byteBuffer.position((int)offset);\n    byteBuffer.put(b);\n  }\n else {\n    throw new IOException(\"Write failed, file \" + getPath() + \" not mapped for I/O\");\n  }\n}\n", "docstring": "writes bytes to the underlying rrd file on the disk", "partition": "test"}
{"idx": "3724", "code": "long timestamp(long timestamp){\n  this.timestamp=Math.max(this.timestamp,timestamp);\n  return this.timestamp;\n}\n", "docstring": "returns an updated executor timestamp .", "partition": "test"}
{"idx": "3725", "code": "public MaterialPackage(MaterialPackageBO materialPackageBO,List<GenericTrack> genericTracks){\n  super(materialPackageBO);\n  this.materialPackageBO=materialPackageBO;\n  this.genericTracks=Collections.unmodifiableList(genericTracks);\n}\n", "docstring": "instantiates a new materialpackage object", "partition": "test"}
{"idx": "3726", "code": "public Edge findEdgeInSameDirection(Coordinate p0,Coordinate p1){\n  for (int i=0; i < edges.size(); i++) {\n    Edge e=(Edge)edges.get(i);\n    Coordinate[] eCoord=e.getCoordinates();\n    if (matchInSameDirection(p0,p1,eCoord[0],eCoord[1]))     return e;\n    if (matchInSameDirection(p0,p1,eCoord[eCoord.length - 1],eCoord[eCoord.length - 2]))     return e;\n  }\n  return null;\n}\n", "docstring": "returns the edge which starts at p0 and whose first segment is parallel to p1", "partition": "test"}
{"idx": "3727", "code": "public void acquireProbabilities(final String string){\n  if (string.length() < 2) {\n    return;\n  }\n  for (int i=2; i < string.length(); ++i) {\n    final char previousChar=string.charAt(i - 2);\n    final char currentChar=string.charAt(i - 1);\n    final char nextChar=string.charAt(i);\n    final String key=previousChar + \"\" + currentChar;\n    if (!sequences.contains(key)) {\n      sequences.add(key);\n    }\n    HashMap<Character,Integer> probabilities=sequenceProbabilities.get(key);\n    if (probabilities == null) {\n      probabilities=new HashMap<>();\n      sequenceProbabilities.put(key,probabilities);\n    }\n    int existingValue=probabilities.getOrDefault(nextChar,0);\n    ++existingValue;\n    probabilities.put(nextChar,existingValue);\n  }\n}\n", "docstring": "parses the specified string to determine the probability of a character appearing after the previous two characters beginning with the third character in the string and ending with the last .", "partition": "test"}
{"idx": "3728", "code": "protected final void resolveIssue(HealthIssue healthIssue){\n  EventBus eventBus;\n  boolean wasIssueActive;\nsynchronized (mLock) {\n    if (mHealthEventBus == null) {\n      LOG.w(\"A health issue was resolved even though no event bus was registered to \" + \"handle it: %1$s.\",healthIssue.toString());\n      return;\n    }\n    eventBus=mHealthEventBus;\n    wasIssueActive=mActiveIssues.remove(healthIssue);\n  }\n  if (wasIssueActive) {\n    eventBus.post(healthIssue.resolved);\n  }\n}\n", "docstring": "marks as resolved the specified issue . < p / > < p > if the issue was not previously reported , this method does nothing .", "partition": "test"}
{"idx": "3729", "code": "private static boolean test(ODatabaseDocumentPool pool,String dbURL,String user,String password,boolean finalTry){\n  ODatabaseDocumentTx db=null;\n  try {\n    logger.info(\"Verifying the DB.\");\n    db=pool.acquire(dbURL,user,password);\n    Iterator<ODocument> iter=db.browseClass(\"config\");\n    if (iter.hasNext()) {\n      iter.next();\n    }\n  }\n catch (  OException ex) {\n    if (finalTry) {\n      logger.info(\"Exceptions encountered in verifying the DB\",ex);\n    }\n else {\n      logger.debug(\"DB exception in testing.\",ex);\n    }\n    return false;\n  }\n finally {\n    if (db != null) {\n      db.close();\n    }\n  }\n  return true;\n}\n", "docstring": "perform a basic access on the db for a rudimentary test", "partition": "test"}
{"idx": "3730", "code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    byte[] values=(byte[])newVal;\n    ByteBuffer buffer=ByteBuffer.wrap(values);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      valueSet.add(buffer.getInt());\n    }\n    return;\n  }\n else {\n    double value=new Double(newVal.toString());\n    agg(value);\n  }\n}\n", "docstring": "distinct count aggregate function which update the distinct count", "partition": "test"}
{"idx": "3731", "code": "private void displayEasterEgg(CommandSender sender){\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a74\\u2592\u00a74\\u2592\u00a7c\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a7c\\u2592\u00a7c\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a7c\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a70\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a78\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a78\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a76\\u2592\u00a76\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a78\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a70\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a74\\u2592\u00a76\\u2592\u00a76\\u2592\u00a76\\u2592\u00a76\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a78\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a76\\u2592\u00a76\\u2592\u00a76\\u2592\u00a76\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a76\\u2592\u00a76\\u2592\u00a74\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a78\\u2592\u00a78\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a7f\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a74\\u2592\u00a74\\u2592\u00a74\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a74\\u2592\u00a74\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a7f\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a74\\u2592\u00a74\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a74\\u2592\u00a74\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a7f\\u2592\u00a7f\\u2592\u00a77\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a74\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a78\\u2592\u00a78\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a70\\u2592\u00a70\\u2592\u00a70\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n  sender.sendMessage(StringEscapeUtils.unescapeJava(\"\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a77\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a75\\u2592\u00a77\\u2592\u00a7r\"));\n}\n", "docstring": "easter egg ; run it and you \"'\" ll see what all this mess is about !", "partition": "test"}
{"idx": "3732", "code": "public boolean isUnparsedEntity(String entityName){\n  Entity entity=(Entity)fEntities.get(entityName);\n  if (entity == null) {\n    return false;\n  }\n  return entity.isUnparsed();\n}\n", "docstring": "checks whether an entity given by name is unparsed .", "partition": "test"}
{"idx": "3733", "code": "protected void processFocusEvent(FocusEvent evt){\n  super.processFocusEvent(evt);\n  if (evt.getID() == FocusEvent.FOCUS_LOST) {\n    if (popup != null)     hidePopup();\n  }\n}\n", "docstring": "ensures that if we lose focus , the popup goes away .", "partition": "test"}
{"idx": "3734", "code": "@Override public synchronized void addRequestProperty(String key,String value){\n  if (connected || connecting)   throw new IllegalStateException(\"Already connected\");\n  if (key == null)   throw new NullPointerException(\"key is null\");\n  if (isExternalMessageHeaderAllowed(key,value)) {\n    requests.add(key,value);\n    if (!key.equalsIgnoreCase(\"Content-Type\")) {\n      userHeaders.add(key,value);\n    }\n  }\n}\n", "docstring": "adds a general request property specified by a key - value pair . this method will not overwrite existing values associated with the same key .", "partition": "test"}
{"idx": "3735", "code": "public void execute(AbortableTask task){\n  AbortingRunnable ar=new AbortingRunnable(task);\n  tasks.add(ar);\n  try {\n    exec.execute(ar);\n  }\n catch (  RejectedExecutionException e) {\n    tasks.remove(ar);\n    throw e;\n  }\n}\n", "docstring": "executes the task using the embedded executor .", "partition": "test"}
{"idx": "3736", "code": "default ByteBuffer serialize(T value){\n  ByteBuffer buffer=ByteBuffer.allocate(size(value));\n  serialize(value,buffer);\n  return buffer;\n}\n", "docstring": "serialize to a byte buffer", "partition": "test"}
{"idx": "3737", "code": "private void loadSubmissions(){\n  submissions.clear();\n  String[] users=JPlagCentral.usersList();\n  for (int i=0; i < users.length; i++) {\n    AccessStructure[] subm=JPlagCentral.listAccessStructures(users[i]);\n    if (subm != null && subm.length != 0) {\n      for (int j=0; j < subm.length; j++) {\n        submissions.add(subm[j]);\n      }\n    }\n  }\n}\n", "docstring": "used to actualize the vector containing all submissions", "partition": "test"}
{"idx": "3738", "code": "@SuppressWarnings(\"unused\") public boolean onTouchEvent(MotionEvent event){\n  try {\n    int pointerCount=multiTouchSupported ? (Integer)m_getPointerCount.invoke(event) : 1;\n    if (DEBUG)     Log.i(\"MultiTouch\",\"Got here 1 - \" + multiTouchSupported + \" \"+ mMode+ \" \"+ handleSingleTouchEvents+ \" \"+ pointerCount);\n    if (mMode == MODE_NOTHING && !handleSingleTouchEvents && pointerCount == 1)     return false;\n    if (DEBUG)     Log.i(\"MultiTouch\",\"Got here 2\");\n    int action=event.getAction();\n    int histLen=event.getHistorySize() / pointerCount;\n    for (int histIdx=0; histIdx <= histLen; histIdx++) {\n      boolean processingHist=histIdx < histLen;\n      if (!multiTouchSupported || pointerCount == 1) {\n        if (DEBUG)         Log.i(\"MultiTouch\",\"Got here 3\");\n        xVals[0]=processingHist ? event.getHistoricalX(histIdx) : event.getX();\n        yVals[0]=processingHist ? event.getHistoricalY(histIdx) : event.getY();\n        pressureVals[0]=processingHist ? event.getHistoricalPressure(histIdx) : event.getPressure();\n      }\n else {\n        if (DEBUG)         Log.i(\"MultiTouch\",\"Got here 4\");\n        int numPointers=Math.min(pointerCount,MAX_TOUCH_POINTS);\n        if (DEBUG && pointerCount > MAX_TOUCH_POINTS)         Log.i(\"MultiTouch\",\"Got more pointers than MAX_TOUCH_POINTS\");\n        for (int ptrIdx=0; ptrIdx < numPointers; ptrIdx++) {\n          int ptrId=(Integer)m_getPointerId.invoke(event,ptrIdx);\n          pointerIds[ptrIdx]=ptrId;\n          xVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalX.invoke(event,ptrIdx,histIdx) : m_getX.invoke(event,ptrIdx));\n          yVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalY.invoke(event,ptrIdx,histIdx) : m_getY.invoke(event,ptrIdx));\n          pressureVals[ptrIdx]=(Float)(processingHist ? m_getHistoricalPressure.invoke(event,ptrIdx,histIdx) : m_getPressure.invoke(event,ptrIdx));\n        }\n      }\n      decodeTouchEvent(pointerCount,xVals,yVals,pressureVals,pointerIds,processingHist ? MotionEvent.ACTION_MOVE : action,processingHist ? true : action != MotionEvent.ACTION_UP && (action & ((1 << ACTION_POINTER_INDEX_SHIFT) - 1)) != ACTION_POINTER_UP && action != MotionEvent.ACTION_CANCEL,processingHist ? event.getHistoricalEventTime(histIdx) : event.getEventTime());\n    }\n    return true;\n  }\n catch (  Exception e) {\n    Log.e(\"MultiTouchController\",\"onTouchEvent() failed\",e);\n    return false;\n  }\n}\n", "docstring": "process incoming touch events", "partition": "test"}
{"idx": "3739", "code": "public static Bit valueOf(String bit) throws NumberFormatException {\n  final int i=Integer.parseInt(bit);\n  if (i != 0 && i != 1) {\n    throw new NumberFormatException(\"Input \\\"\" + bit + \"\\\" must be 0 or 1.\");\n  }\n  return (i > 0) ? TRUE : FALSE;\n}\n", "docstring": "method to construct a bit for a given string expression .", "partition": "test"}
{"idx": "3740", "code": "public boolean next() throws EOFException {\n  if (limit >= fileSize) {\n    throw new EOFException(\"End of file was reached\");\n  }\n  if (mem.getLongVolatile(Structure.Limit) <= limit) {\n    return false;\n  }\n  byte commit=mem.getByteVolatile(limit);\n  byte rollback=mem.getByteVolatile(limit + Length.Commit);\n  if (rollback == Rollback.Set) {\n    limit+=Length.RecordHeader + recordSize;\n    timeoutCounter=0;\n    timerStart=0;\n    return false;\n  }\n  if (commit == Commit.Set) {\n    timeoutCounter=0;\n    timerStart=0;\n    return true;\n  }\n  timeoutCounter++;\n  if (timeoutCounter >= MAX_TIMEOUT_COUNT) {\n    if (timerStart == 0) {\n      timerStart=System.currentTimeMillis();\n    }\n else {\n      if (System.currentTimeMillis() - timerStart >= maxTimeout) {\n        mem.putByteVolatile(limit + Length.Commit,Rollback.Set);\n        limit+=Length.RecordHeader + recordSize;\n        timeoutCounter=0;\n        timerStart=0;\n        return false;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "steps forward to the next record if there \"'\" s one available . the method has a timeout for how long it will wait for the commit field to be set . when the timeout is reached it will set the roll back field and skip over the record .", "partition": "test"}
{"idx": "3741", "code": "private int composeComponent(int a,int b){\n  return Math.min(b + b * a / DIMMING_FACTOR,0xff);\n}\n", "docstring": "apply composition to an individual color component of a pixel .", "partition": "test"}
{"idx": "3742", "code": "public void removeTreeModelListener(TreeModelListener l){\n  treeModelListeners.removeElement(l);\n}\n", "docstring": "removes a listener previously added with addtreemodellistener ( ) .", "partition": "test"}
{"idx": "3743", "code": "public URIName(String name) throws IOException {\n  try {\n    uri=new URI(name);\n  }\n catch (  URISyntaxException use) {\n    throw new IOException(\"invalid URI name:\" + name,use);\n  }\n  if (uri.getScheme() == null) {\n    throw new IOException(\"URI name must include scheme:\" + name);\n  }\n  host=uri.getHost();\n  if (host != null) {\n    if (host.charAt(0) == \'[\') {\n      String ipV6Host=host.substring(1,host.length() - 1);\n      try {\n        hostIP=new IPAddressName(ipV6Host);\n      }\n catch (      IOException ioe) {\n        throw new IOException(\"invalid URI name (host \" + \"portion is not a valid IPv6 address):\" + name);\n      }\n    }\n else {\n      try {\n        hostDNS=new DNSName(host);\n      }\n catch (      IOException ioe) {\n        try {\n          hostIP=new IPAddressName(host);\n        }\n catch (        Exception ioe2) {\n          throw new IOException(\"invalid URI name (host \" + \"portion is not a valid DNS name, IPv4 address,\" + \" or IPv6 address):\"+ name);\n        }\n      }\n    }\n  }\n}\n", "docstring": "create the uriname object with the specified name .", "partition": "test"}
{"idx": "3744", "code": "public ProjectedStream addView(String namespace,String name,List<Expression> parameters){\n  views.add(View.create(namespace,name,parameters));\n  return this;\n}\n", "docstring": "adds a parameterized view to the stream .", "partition": "test"}
{"idx": "3745", "code": "protected int read(SpeechRecord recorder,byte[] buffer){\n  int len=buffer.length;\n  int numOfBytes=recorder.read(buffer,0,len);\n  int status=getStatus(numOfBytes,len);\n  if (status == 0) {\n    System.arraycopy(buffer,0,mRecording,mRecordedLength,numOfBytes);\n    mRecordedLength+=len;\n  }\n  return status;\n}\n", "docstring": "copy data from the given recorder into the given buffer , and append to the complete recording . public int read ( byte [ ", "partition": "test"}
{"idx": "3746", "code": "public void touch(){\n  candiesStore=null;\n}\n", "docstring": "cleans the candies store so that it will be read from file next time .", "partition": "test"}
{"idx": "3747", "code": "public ZoneRules toRules(String zoneId){\n  Objects.requireNonNull(zoneId,\"zoneId\");\n  if (windowList.isEmpty()) {\n    throw new IllegalStateException(\"No windows have been added to the builder\");\n  }\n  final List<ZoneOffsetTransition> standardTransitionList=new ArrayList<>(4);\n  final List<ZoneOffsetTransition> transitionList=new ArrayList<>(256);\n  final List<ZoneOffsetTransitionRule> lastTransitionRuleList=new ArrayList<>(2);\n  final TZWindow firstWindow=windowList.get(0);\n  ZoneOffset loopStandardOffset=firstWindow.standardOffset;\n  int loopSavings=0;\n  if (firstWindow.fixedSavingAmountSecs != null) {\n    loopSavings=firstWindow.fixedSavingAmountSecs;\n  }\n  final ZoneOffset firstWallOffset=ZoneOffset.ofTotalSeconds(loopStandardOffset.getTotalSeconds() + loopSavings);\n  LocalDateTime loopWindowStart=LocalDateTime.of(YEAR_MIN_VALUE,1,1,0,0);\n  ZoneOffset loopWindowOffset=firstWallOffset;\n  for (  TZWindow window : windowList) {\n    window.tidy(loopWindowStart.getYear());\n    Integer effectiveSavings=window.fixedSavingAmountSecs;\n    if (effectiveSavings == null) {\n      effectiveSavings=0;\n      for (      TZRule rule : window.ruleList) {\n        if (rule.toEpochSecond(loopStandardOffset,loopSavings) > loopWindowStart.toEpochSecond(loopWindowOffset)) {\n          break;\n        }\n        effectiveSavings=rule.savingAmountSecs;\n      }\n    }\n    if (loopStandardOffset.equals(window.standardOffset) == false) {\n      standardTransitionList.add(new ZoneOffsetTransition(LocalDateTime.ofEpochSecond(loopWindowStart.toEpochSecond(loopWindowOffset),0,loopStandardOffset),loopStandardOffset,window.standardOffset));\n      loopStandardOffset=window.standardOffset;\n    }\n    ZoneOffset effectiveWallOffset=ZoneOffset.ofTotalSeconds(loopStandardOffset.getTotalSeconds() + effectiveSavings);\n    if (loopWindowOffset.equals(effectiveWallOffset) == false) {\n      transitionList.add(new ZoneOffsetTransition(loopWindowStart,loopWindowOffset,effectiveWallOffset));\n    }\n    loopSavings=effectiveSavings;\n    for (    TZRule rule : window.ruleList) {\n      if (rule.isTransition(loopSavings)) {\n        ZoneOffsetTransition trans=rule.toTransition(loopStandardOffset,loopSavings);\n        if (trans.toEpochSecond() < loopWindowStart.toEpochSecond(loopWindowOffset) == false && trans.toEpochSecond() < window.createDateTimeEpochSecond(loopSavings)) {\n          transitionList.add(trans);\n          loopSavings=rule.savingAmountSecs;\n        }\n      }\n    }\n    for (    TZRule lastRule : window.lastRuleList) {\n      lastTransitionRuleList.add(lastRule.toTransitionRule(loopStandardOffset,loopSavings));\n      loopSavings=lastRule.savingAmountSecs;\n    }\n    loopWindowOffset=window.createWallOffset(loopSavings);\n    loopWindowStart=LocalDateTime.ofEpochSecond(window.createDateTimeEpochSecond(loopSavings),0,loopWindowOffset);\n  }\n  return new ZoneRules(firstWindow.standardOffset,firstWallOffset,standardTransitionList,transitionList,lastTransitionRuleList);\n}\n", "docstring": "completes the build converting the builder to a set of time - zone rules . < p > calling this method alters the state of the builder . further rules should not be added to this builder once this method is called .", "partition": "test"}
{"idx": "3748", "code": "public static int hash(Object o){\n  int h=o == null ? 0 : o instanceof byte[] ? Arrays.hashCode((byte[])o) : o.hashCode();\n  h+=(h << 15) ^ 0xffffcd7d;\n  h^=(h >>> 10);\n  h+=(h << 3);\n  h^=(h >>> 6);\n  h+=(h << 2) + (h << 14);\n  return h ^ (h >>> 16);\n}\n", "docstring": "gets hash code for a given object .", "partition": "test"}
{"idx": "3749", "code": "public void addParseTemplate(String parseTemplate){\n  parseTemplates.add(parseTemplate);\n}\n", "docstring": "adds a template which should be \" parsed \" while the parsing process .", "partition": "test"}
{"idx": "3750", "code": "private void attachImageFromCamera(){\n  try {\n    if (null != mShootedPicturePath) {\n      Uri uri=Uri.fromFile(new File(mShootedPicturePath));\n      try {\n        Bitmap previewBitmap=VectorApp.getSavedPickerImagePreview();\n        String thumbnailPath=getThumbnailPath(mShootedPicturePath);\n        int rotationAngle=ImageUtils.getRotationAngleForBitmap(VectorMediasPickerActivity.this,uri);\n        if (0 != rotationAngle) {\n          android.graphics.Matrix bitmapMatrix=new android.graphics.Matrix();\n          bitmapMatrix.postRotate(360 - rotationAngle);\n          previewBitmap=Bitmap.createBitmap(previewBitmap,0,0,previewBitmap.getWidth(),previewBitmap.getHeight(),bitmapMatrix,false);\n        }\n        File file=new File(thumbnailPath);\n        FileOutputStream outStream=new FileOutputStream(file);\n        previewBitmap.compress(Bitmap.CompressFormat.JPEG,50,outStream);\n        outStream.flush();\n        outStream.close();\n      }\n catch (      Exception e) {\n        Log.e(LOG_TAG,\"attachImageFromCamera fails to create thumbnail file\");\n      }\n      Bundle conData=new Bundle();\n      Intent intent=new Intent();\n      intent.setData(uri);\n      intent.putExtras(conData);\n      setResult(RESULT_OK,intent);\n    }\n  }\n catch (  Exception e) {\n    setResult(RESULT_CANCELED,null);\n  }\n finally {\n    VectorApp.setSavedCameraImagePreview(null);\n    finish();\n  }\n}\n", "docstring": "return the taken image from the camera to the calling activity . this method returns to the calling activity .", "partition": "test"}
{"idx": "3751", "code": "public ObjectName preRegister(MBeanServer server,ObjectName name) throws Exception {\n  setMBeanServer(server);\n  if (name == null) {\n    name=new ObjectName(server.getDefaultDomain() + \":\" + ServiceName.MLET);\n  }\n  this.mletObjectName=name;\n  return this.mletObjectName;\n}\n", "docstring": "allows the m - let to perform any operations it needs before being registered in the mbean server . if the objectname is null , the m - let provides a default name for its registration & lt ; defaultdomain & gt ; : type = mlet", "partition": "test"}
{"idx": "3752", "code": "static String matchStringOrThrow(Pattern p,ToDateParser params,Enum<?> aEnum){\n  String s=params.getInputStr();\n  Matcher matcher=p.matcher(s);\n  if (!matcher.find()) {\n    throwException(params,format(\"Issue happened when parsing token \'%s\'\",aEnum.name()));\n  }\n  return matcher.group(1);\n}\n", "docstring": "match the pattern , or if not possible throw an exception .", "partition": "test"}
{"idx": "3753", "code": "static ByteBuffer newByteBuffer(int capacity){\n  ByteBuffer newbb=ByteBuffer.allocate(capacity);\n  newbb.order(ByteOrder.LITTLE_ENDIAN);\n  return newbb;\n}\n", "docstring": "create a ` bytebuffer ` with a given capacity .", "partition": "test"}
{"idx": "3754", "code": "private void validateCollectionAttribute(CollectionAttribute collection,Set<String> allCollections){\n  if (collection == null || allCollections == null) {\n    return;\n  }\n  for (  RestMethod restMethod : collection.getMethods()) {\n    if (allCollections.contains(restMethod.getRestFullMethodName())) {\n      aspect.warning(SimpleLocation.TOPLEVEL,\"The rpc methods and the associated http paths are not following the guidelines. As a \" + \"result the derived rest collection \'%s\' contains a sub collection and a \" + \"method with the same name as \'%s\'. This can cause a failure to generate client \"+ \"library, since these names are used for generating artifacts in generated code.\",collection.getFullName(),restMethod.getRestMethodName());\n    }\n  }\n}\n", "docstring": "validates if the collection does not contain same named elements ( methods and resources ) .", "partition": "test"}
{"idx": "3755", "code": "public void putStringNoNull(String s){\n  ensureCapacity(s.length() * 2);\n  System.arraycopy(s.getBytes(),0,this.byteBuffer,this.position,s.length());\n  this.position+=s.length();\n}\n", "docstring": "put a string in the buffer . no null terminated .", "partition": "test"}
{"idx": "3756", "code": "public void externalEntityDecl(String name,XMLResourceIdentifier identifier,Augmentations augs) throws XNIException {\n  try {\n    if (fDeclHandler != null) {\n      String publicId=identifier.getPublicId();\n      String systemId=fResolveDTDURIs ? identifier.getExpandedSystemId() : identifier.getLiteralSystemId();\n      fDeclHandler.externalEntityDecl(name,publicId,systemId);\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}\n", "docstring": "an external entity declaration .", "partition": "test"}
{"idx": "3757", "code": "public HoltWintersModelBuilder alpha(double alpha){\n  this.alpha=alpha;\n  return this;\n}\n", "docstring": "alpha controls the smoothing of the data . alpha = 1 retains no memory of past values ( e . g . a random walk ) , while alpha = 0 retains infinite memory of past values ( e . g . the series mean ) . useful values are somewhere in between . defaults to 0 . 5 .", "partition": "test"}
{"idx": "3758", "code": "public static @CheckForNull ClassDescriptor createClassDescriptorFromFieldSignature(String signature){\n  int start=signature.indexOf('L');\n  if (start < 0) {\n    return null;\n  }\n  int end=signature.indexOf(';',start);\n  if (end < 0) {\n    return null;\n  }\n  return createClassDescriptor(signature.substring(start + 1,end));\n}\n", "docstring": "create a class descriptor from a field signature", "partition": "test"}
{"idx": "3759", "code": "private static ServiceTicketResponse checkGetNfcServiceTicketResponse(ServiceTicketResponse serviceTicketResponse) throws RpcException {\n  logger.info(\"Checking {}\",serviceTicketResponse);\nswitch (serviceTicketResponse.getResult()) {\ncase OK:\n    break;\ncase SYSTEM_ERROR:\n  throw new SystemErrorException(serviceTicketResponse.getError());\ncase NOT_FOUND:\nthrow new DatastoreNotFoundException(serviceTicketResponse.getError());\ndefault :\nthrow new RpcException(String.format(\"Unknown result: %s\",serviceTicketResponse.getError()));\n}\nreturn serviceTicketResponse;\n}\n", "docstring": "this method validates a serviceticketresponse object , raising an exception if the response reflects an operation failure .", "partition": "test"}
{"idx": "3760", "code": "public void schedule(TimerTask task,long delay){\n  if (delay < 0)   throw new IllegalArgumentException(\"Negative delay.\");\n  sched(task,System.currentTimeMillis() + delay,0);\n}\n", "docstring": "schedules the specified task for execution after the specified delay .", "partition": "test"}
{"idx": "3761", "code": "public void filledEllipse(double x,double y,double semiMajorAxis,double semiMinorAxis){\n  if (semiMajorAxis < 0)   throw new IllegalArgumentException(\"ellipse semimajor axis can\'t be negative\");\n  if (semiMinorAxis < 0)   throw new IllegalArgumentException(\"ellipse semiminor axis can\'t be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * semiMajorAxis);\n  double hs=factorY(2 * semiMinorAxis);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.fill(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "docstring": "draws an ellipse with given semimajor and semiminor axes , centered on ( x , y ) .", "partition": "test"}
{"idx": "3762", "code": "@Override public Cursor swapCursor(Cursor newCursor){\n  mAlphabetIndexer.setCursor(newCursor);\n  return super.swapCursor(newCursor);\n}\n", "docstring": "overrides swapcursor to move the new cursor into the alphabetindex as well as the cursoradapter .", "partition": "test"}
{"idx": "3763", "code": "public void lockFlushing(){\n  flushLock.lock();\n}\n", "docstring": "lock the flushing mechanism in order to prevent a thread flushing this buffer while another thread is doing a physiological operation .", "partition": "test"}
{"idx": "3764", "code": "public static boolean canBeRandomized(Class clazz){\n  return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.equals(String.class) || clazz.equals(IDiscordClient.class);\n}\n", "docstring": "checks if the class is supported to be randomized without recursion .", "partition": "test"}
{"idx": "3765", "code": "public static String generateNativeGuid(String deviceType,String serialNumber){\n  return String.format(\"%s+%s\",_deviceTypeMap.get(deviceType),serialNumber);\n}\n", "docstring": "the format of this native guid using the given devicetype & serialnumber .", "partition": "test"}
{"idx": "3766", "code": "public WritableRaster createWritableChild(int x,int y,int width,int height,int x0,int y0,int bandList[]){\n  if (x < this.minX) {\n    throw new RasterFormatException(\"x lies outside raster\");\n  }\n  if (y < this.minY) {\n    throw new RasterFormatException(\"y lies outside raster\");\n  }\n  if ((x + width < x) || (x + width > this.minX + this.width)) {\n    throw new RasterFormatException(\"(x + width) is outside of Raster\");\n  }\n  if ((y + height < y) || (y + height > this.minY + this.height)) {\n    throw new RasterFormatException(\"(y + height) is outside of Raster\");\n  }\n  SampleModel sm;\n  if (bandList != null)   sm=sampleModel.createSubsetSampleModel(bandList);\n else   sm=sampleModel;\n  int deltaX=x0 - x;\n  int deltaY=y0 - y;\n  return new ShortBandedRaster(sm,dataBuffer,new Rectangle(x0,y0,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),this);\n}\n", "docstring": "creates a writable subraster given a region of the raster . the x and y coordinates specify the horizontal and vertical offsets from the upper - left corner of this raster to the upper - left corner of the subraster . a subset of the bands of the parent raster may be specified . if this is null , then all the bands are present in the subraster . a translation to the subraster may also be specified . note that the subraster will reference the same databuffers as the parent raster , but using different offsets .", "partition": "test"}
{"idx": "3767", "code": "private void sortChildren(final JCriteriumTreeNode parentNode){\n  final List<JCriteriumTreeNode> operators=new ArrayList<JCriteriumTreeNode>();\n  final List<JCriteriumTreeNode> conditions=new ArrayList<JCriteriumTreeNode>();\n  final List<JCriteriumTreeNode> minus=new ArrayList<JCriteriumTreeNode>();\n  final Enumeration<?> children=parentNode.children();\n  while (children.hasMoreElements()) {\n    final JCriteriumTreeNode child=(JCriteriumTreeNode)children.nextElement();\n    final ICriterium type=child.getCriterium();\n    if (type instanceof CConditionCriterium) {\n      conditions.add(child);\n    }\n else {\n      operators.add(child);\n    }\n  }\n  parentNode.removeAllChildren();\n  for (  final JCriteriumTreeNode child : operators) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n  for (  final JCriteriumTreeNode child : conditions) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n  for (  final JCriteriumTreeNode child : minus) {\n    parentNode.add(child);\n    child.setParent(parentNode);\n  }\n}\n", "docstring": "sorts visible tree nodes .", "partition": "test"}
{"idx": "3768", "code": "public static int poisson(double lambda){\n  int k=0;\n  double p=1.0;\n  double L=Math.exp(-lambda);\n  do {\n    k++;\n    p*=uniform();\n  }\n while (p >= L);\n  return k - 1;\n}\n", "docstring": "return an integer with a poisson distribution with mean lambda .", "partition": "test"}
{"idx": "3769", "code": "public String build(String input){\n  inputString=input;\n  inputIndex=0;\n  inputLength=input.length();\n  outputString=new StringBuffer();\n  char nextChar;\n  while ((nextChar=get()) != 0 && outputString.length() < maxOutputLength) {\n    if (nextChar == \'/\') {\n      if (inputStartsWith(\"*!\")) {\n        String nextChars=peek(7);\n        boolean haveBangComment=false;\n        if (nextChars != null && nextChars.length() == 7) {\n          haveBangComment=true;\n          for (int i=2; i < nextChars.length(); i++) {\n            if (!Character.isDigit(nextChars.charAt(i))) {\n              haveBangComment=false;\n              break;\n            }\n          }\n        }\n        if (haveBangComment) {\n          skip(7);\n          String contents=getToDelimiter(\"*/\");\n          if (contents != null) {\n            put(contents);\n            skip(2);\n          }\n        }\n else {\n          put(nextChar);\n        }\n      }\n else       if (inputStartsWith(\"*\")) {\n        if (getToDelimiter(\"*/\") != null)         skip(2);\n      }\n else {\n        put(nextChar);\n      }\n    }\n else     if (nextChar == \'-\') {\n      if (inputStartsWith(\"-\")) {\n        String tail=peek(2);\n        if (tail == null) {\n          break;\n        }\n else {\n          if (Character.isWhitespace(tail.charAt(1))) {\n            String buf=getToEndOfLine();\n            skip(buf.length());\n            put(\' \');\n          }\n else           put(nextChar);\n        }\n      }\n else {\n        put(nextChar);\n      }\n    }\n else     if (nextChar == \'\\n\') {\n      put(\" \");\n    }\n else {\n      put(nextChar);\n    }\n  }\n  return outputString.toString();\n}\n", "docstring": "build a string for parsing .", "partition": "test"}
{"idx": "3770", "code": "public boolean isBuiltinSoundAvailable(String soundIdentifier){\n  return builtinSounds.containsKey(soundIdentifier);\n}\n", "docstring": "indicates whether a user installed or system sound is available", "partition": "test"}
{"idx": "3771", "code": "public Iterator<String> iterateSerializers(){\n  return serializers.iterator();\n}\n", "docstring": "iterate over view serializers", "partition": "test"}
{"idx": "3772", "code": "private static void checkKey(String key) throws MalformedObjectNameException {\n  if (key == null)   throw new NullPointerException(\"Invalid key (null)\");\n  final int len=key.length();\n  if (len == 0)   throw new MalformedObjectNameException(\"Invalid key (empty)\");\n  final char[] k=key.toCharArray();\n  final int endKey=parseKey(k,0);\n  if (endKey < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + k[endKey] + \"\'\");\n}\n", "docstring": "check if the supplied key is a valid key .", "partition": "test"}
{"idx": "3773", "code": "public abstract boolean isShutdown();\n", "docstring": "tells whether or not this asynchronous channel group is shutdown .", "partition": "test"}
{"idx": "3774", "code": "private void drawArc(Canvas canvas){\n  if (mCurrentDashMode.equals(DASH_MODE.DOWNLOAD)) {\n    mnIndeterminateStartPosition+=(1 - mnProgress) * mnStartSpeed;\n    if ((mnIndeterminateStartPosition > CIRCULAR_FACTOR) || (mnIndeterminateStartPosition < 0)) {\n      mnIndeterminateStartPosition=0;\n    }\n    Rect currRect=new Rect();\n    getLocalVisibleRect(currRect);\n    float nRingBoundaryInner=mnRingRadius - (mnRingWidth / 2) - (mnArcWidth / 2);\n    mArcRect.set(mnViewCenter - nRingBoundaryInner,mnViewCenter - nRingBoundaryInner,mnViewCenter + nRingBoundaryInner,mnViewCenter + nRingBoundaryInner);\n    mPaint.setColor(mArcColor);\n    mPaint.setStyle(Paint.Style.STROKE);\n    mPaint.setStrokeWidth(mnArcWidth);\n    mPaint.setStrokeCap(Paint.Cap.ROUND);\n    canvas.drawArc(mArcRect,mnIndeterminateStartPosition,mnArcLength,false,mPaint);\n  }\n}\n", "docstring": "draw the arc around the ring only for the download mode", "partition": "test"}
{"idx": "3775", "code": "public static String formatDateTime(java.util.Date date,String format,String locale,String timeZone){\n  SimpleDateFormat dateFormat=getDateFormat(format,locale,timeZone);\nsynchronized (dateFormat) {\n    return dateFormat.format(date);\n  }\n}\n", "docstring": "formats a date using a format string .", "partition": "test"}
{"idx": "3776", "code": "protected MessageDigest(String algorithm){\n  this.algorithm=algorithm;\n}\n", "docstring": "creates a message digest with the specified algorithm name .", "partition": "test"}
{"idx": "3777", "code": "private void createGui(){\n  final JPanel topPanel=new JPanel(new BorderLayout());\n  final JPanel innerTopPanel=new JPanel(new BorderLayout());\n  innerTopPanel.add(m_stdEditPanel);\n  topPanel.add(innerTopPanel);\n  final JPanel debuggerChooserPanel=new JPanel(new BorderLayout());\n  debuggerChooserPanel.setBorder(new TitledBorder(\"Project Debuggers\"));\n  m_checkedList=new JCheckedListbox<>(new Vector<DebuggerTemplate>(),false);\n  updateCheckedListPanel();\n  final JScrollPane debuggerScrollPane=new JScrollPane(m_checkedList);\n  m_checkedListPanel.add(debuggerScrollPane);\n  debuggerChooserPanel.add(m_checkedListPanel,BorderLayout.CENTER);\n  debuggerChooserPanel.setMinimumSize(new Dimension(0,128));\n  debuggerChooserPanel.setPreferredSize(new Dimension(0,128));\n  innerTopPanel.add(debuggerChooserPanel,BorderLayout.SOUTH);\n  final JPanel buttonPanel=new JPanel(new GridLayout(1,2));\n  buttonPanel.setBorder(new EmptyBorder(0,0,5,2));\n  buttonPanel.add(new JPanel());\n  buttonPanel.add(m_saveButton);\n  topPanel.add(buttonPanel,BorderLayout.SOUTH);\n  final JPanel bottomPanel=new CAddressSpacesTablePanel(m_table);\n  final JScrollPane scrollPane=new JScrollPane(m_table);\n  bottomPanel.setBorder(m_titledBorder);\n  setBorder(new EmptyBorder(0,0,0,1));\n  bottomPanel.add(scrollPane);\n  final JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topPanel,bottomPanel);\n  splitPane.setOneTouchExpandable(true);\n  splitPane.setDividerLocation(splitPane.getMinimumDividerLocation());\n  splitPane.setResizeWeight(0.5);\n  add(splitPane);\n}\n", "docstring": "creates the elements of this component .", "partition": "test"}
{"idx": "3778", "code": "private void copyACls(final List<AccessControlLevel> accessControlLevels2){\n  for (  AccessControlLevel acl : this.accessControlLevels) {\n    accessControlLevels2.add(new AccessControlLevel(acl));\n  }\n}\n", "docstring": "copy acls for new configuration .", "partition": "test"}
{"idx": "3779", "code": "public void put(ByteBuffer byteBuffer,int contentLength){\n  if (contentLength > (bytes.length - this.contentLength)) {\n    throw new IllegalArgumentException(\"contentLength is too large\");\n  }\n  byteBuffer.get(bytes,this.contentLength,contentLength);\n  this.contentLength+=contentLength;\n}\n", "docstring": "appends content from the specified bytebuffer to this bytearray", "partition": "test"}
{"idx": "3780", "code": "private void handleResponse(AvsResponse response){\n  boolean checkAfter=(avsQueue.size() == 0);\n  if (response != null) {\n    for (int i=response.size() - 1; i >= 0; i--) {\n      if (response.get(i) instanceof AvsReplaceAllItem || response.get(i) instanceof AvsReplaceEnqueuedItem) {\n        avsQueue.clear();\n        response.remove(i);\n      }\n    }\n    Log.i(TAG,\"Adding \" + response.size() + \" items to our queue\");\n    avsQueue.addAll(response);\n  }\n  if (checkAfter) {\n    checkQueue();\n  }\n}\n", "docstring": "handle the response sent back from alexa \"'\" s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen )", "partition": "test"}
{"idx": "3781", "code": "protected synchronized void request(String stream){\n  if (stream == null || stream.isEmpty()) {\n    return;\n  }\n  stream=stream.toLowerCase(Locale.ENGLISH);\n  FollowerInfo cachedInfo=cached.get(stream);\n  if (cachedInfo == null || checkTimePassed(cachedInfo)) {\n    if (type == Follower.Type.FOLLOWER) {\n      api.requestFollowers(stream);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      api.requestSubscribers(stream);\n    }\n  }\n else {\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(cachedInfo);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(cachedInfo);\n    }\n  }\n}\n", "docstring": "checks if there is info already cached and whether it is old enough to be updated , in which case it requests the data from the api .", "partition": "test"}
{"idx": "3782", "code": "boolean removeViewIfHidden(View view){\n  final int index=mCallback.indexOfChild(view);\n  if (index == -1) {\n    if (mHiddenViews.remove(view) && DEBUG) {\n      throw new IllegalStateException(\"view is in hidden list but not in view group\");\n    }\n    return true;\n  }\n  if (mBucket.get(index)) {\n    mBucket.remove(index);\n    mCallback.removeViewAt(index);\n    if (!mHiddenViews.remove(view) && DEBUG) {\n      throw new IllegalStateException(\"removed a hidden view but it is not in hidden views list\");\n    }\n    return true;\n  }\n  return false;\n}\n", "docstring": "removes a view from the viewgroup if it is hidden .", "partition": "test"}
{"idx": "3783", "code": "@Ignore(\"TODO: test is disabled\") @Test public void testPopulate1kbwrites(){\n  final byte[] value=new byte[ENTRY_SIZE];\n  Arrays.fill(value,(byte)77);\n  for (int i=0; i < OP_COUNT; i++) {\n    region.put(new Integer(i),value);\n  }\n  closeDown();\n}\n", "docstring": "currently not being executed for congo but after transition to jdk 1 . 5 , this test should be executed .", "partition": "test"}
{"idx": "3784", "code": "public void serialize(KXmlSerializer serializer) throws IOException {\n  serializer.startTag(ns,TAG);\n  serializeAttribute(serializer,NAME_ATTR,mName);\n  serializeAttribute(serializer,APP_PACKAGE_NAME_ATTR,mAppPackageName);\n  serializeAttribute(serializer,DIGEST_ATTR,getDigest());\n  if (SIGNATURE_TEST_PKG.equals(mName)) {\n    serializer.attribute(ns,\"signatureCheck\",\"true\");\n  }\n  mSuiteRoot.serialize(serializer);\n  serializer.endTag(ns,TAG);\n}\n", "docstring": "serialize this object and all its contents to xml .", "partition": "test"}
{"idx": "3785", "code": "public void rollback(Throwable t){\n  log.debug(\"  ROLLBACK: deleting \" + tempFile + \" due to \"+ t);\n  try {\n    fileContentStore.delete(tempFile,node);\n  }\n catch (  Exception e) {\n    t.addSuppressed(e);\n  }\n}\n", "docstring": "rollback the download ( delete the temporary file )", "partition": "test"}
{"idx": "3786", "code": "protected void parseGeometryString(){\n  int i=0;\n  byte[] bytes=geometryString.getBytes();\n  xgrav=new String(bytes,0,1);\n  for (i=2; i < bytes.length; i++) {\n    if ((bytes[i] == \'-\') || (bytes[i] == \'+\'))     break;\n  }\n  if (i == bytes.length)   return;\n  ygrav=(bytes[i] == \'-\') ? \"-\" : \"+\";\n  xpos=Integer.parseInt(new String(bytes,1,i - 1));\n  ++i;\n  ypos=Integer.parseInt(new String(bytes,i,bytes.length - i));\n}\n", "docstring": "parse x - like geometry string .", "partition": "test"}
{"idx": "3787", "code": "@Override protected final synchronized boolean writeData(ByteBuffer data){\n  AionServerPacket packet=sendMsgQueue.pollFirst();\n  if (packet == null) {\n    return false;\n  }\n  packet.setBuf(data);\n  packet.write(this);\n  return true;\n}\n", "docstring": "this method will be called by dispatcher , and will be repeated till return false .", "partition": "test"}
{"idx": "3788", "code": "protected boolean position(Projection proj){\n  if (proj == null) {\n    logger.fine(\"OMRasterObject: null projection in position!\");\n    return false;\n  }\n  projWidth=proj.getWidth();\n  projHeight=proj.getHeight();\nswitch (renderType) {\ncase RENDERTYPE_LATLON:\n    if (!proj.isPlotable(lat,lon)) {\n      if (DEBUG) {\n        logger.fine(\"OMRasterObject: point is not plotable!\");\n      }\n      setNeedToReposition(true);\n      return false;\n    }\n  point1=(Point)proj.forward(lat,lon,new Point());\nbreak;\ncase RENDERTYPE_XY:\npoint1=new Point(x,y);\nbreak;\ncase RENDERTYPE_OFFSET:\nif (!proj.isPlotable(lat,lon)) {\nif (DEBUG) {\nlogger.fine(\"OMRasterObject: point is not plotable!\");\n}\nsetNeedToReposition(true);\nreturn false;\n}\npoint1=(Point)proj.forward(lat,lon,new Point());\npoint1.x+=x;\npoint1.y+=y;\nbreak;\ncase RENDERTYPE_UNKNOWN:\nif (DEBUG) {\nlogger.fine(\"OMRasterObject.position(): ignoring unknown rendertype, wingin\' it\");\n}\nif (lat == 0 && lon == 0) {\nif (x == 0 && y == 0) {\nif (DEBUG) {\nlogger.fine(\"OMRasterObject.position(): Not enough info in object to place it reasonably.\");\n}\npoint1=new Point(-width,-height);\npoint2=new Point(0,0);\nreturn false;\n}\n else {\npoint1=new Point(x,y);\n}\n}\n else {\nif (!proj.isPlotable(lat,lon)) {\nlogger.fine(\"OMRasterObject: point is not plotable!\");\nreturn false;\n}\npoint1=(Point)proj.forward(lat,lon,new Point());\n}\nbreak;\n}\npoint2=new Point(0,0);\npoint2.x=point1.x + width;\npoint2.y=point1.y + height;\nsetNeedToReposition(false);\nreturn true;\n}\n", "docstring": "since the image doesn \"'\" t necessarily need to be regenerated when it is merely moved , raster objects have this function , called from generate ( ) and when a placement attribute is changed .", "partition": "test"}
{"idx": "3789", "code": "public synchronized int lastIndexOf(Object object,int location){\n  if (location < elementCount) {\n    if (object != null) {\n      for (int i=location; i >= 0; i--) {\n        if (object.equals(elementData[i])) {\n          return i;\n        }\n      }\n    }\n else {\n      for (int i=location; i >= 0; i--) {\n        if (elementData[i] == null) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  throw arrayIndexOutOfBoundsException(location,elementCount);\n}\n", "docstring": "searches in this vector for the index of the specified object . the search for the object starts at the specified location and moves towards the start of this vector .", "partition": "test"}
{"idx": "3790", "code": "public java.lang.StringBuffer insert(int offset,char c){\n  internal.insert(offset,c);\n  return this;\n}\n", "docstring": "inserts the string representation of the char argument into this string buffer . the second argument is inserted into the contents of this string buffer at the position indicated by offset . the length of this string buffer increases by one . the overall effect is exactly as if the argument were converted to a string by the method string . valueof ( char ) and the character in that string were then inserted into this stringbuffer object at the position indicated by offset . the offset argument must be greater than or equal to 0 , and less than or equal to the length of this string buffer .", "partition": "test"}
{"idx": "3791", "code": "protected void calculateDestination(IFile uxf,ICompilationUnit referencingCompilationUnit,Destination dest) throws CoreException {\n  IFile uxfDest=calculateImgDestination(uxf,referencingCompilationUnit);\n  if (uxfDest != null) {\n    dest.imgFileDestination=uxfDest;\n  }\n}\n", "docstring": "calculate the destination of the given umlet diagram . return null if the diagram reference does not need to be updated", "partition": "test"}
{"idx": "3792", "code": "@Override public void onEvent(ProjectEvent event){\n  if (event.getType() == ProjectEvent.EventType.UPDATED || event.getType() == ProjectEvent.EventType.CREATED) {\n    update(event);\n  }\n}\n", "docstring": "there is a change on the project that we \"'\" re monitoring , whatever the type of event is , we need to updated the runner .", "partition": "test"}
{"idx": "3793", "code": "protected abstract boolean onMouseClick(Point point);\n", "docstring": "called on left mouse single click .", "partition": "test"}
{"idx": "3794", "code": "private void remeasure(int width,int height){\n  MAX_UNEXPANDED_ALLDAY_HEIGHT=(int)(MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT * 4);\n  MAX_UNEXPANDED_ALLDAY_HEIGHT=Math.min(MAX_UNEXPANDED_ALLDAY_HEIGHT,height / 6);\n  MAX_UNEXPANDED_ALLDAY_HEIGHT=Math.max(MAX_UNEXPANDED_ALLDAY_HEIGHT,(int)MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT * 2);\n  mMaxUnexpandedAlldayEventCount=(int)(MAX_UNEXPANDED_ALLDAY_HEIGHT / MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT);\n  for (int day=0; day < mNumDays; day++) {\n    mEarliestStartHour[day]=25;\n    mHasAllDayEvent[day]=false;\n  }\n  int maxAllDayEvents=mMaxAlldayEvents;\n  mMinCellHeight=Math.max((height - DAY_HEADER_HEIGHT) / 24,(int)MIN_EVENT_HEIGHT);\n  if (mCellHeight < mMinCellHeight) {\n    mCellHeight=mMinCellHeight;\n  }\n  mFirstCell=DAY_HEADER_HEIGHT;\n  int allDayHeight=0;\n  if (maxAllDayEvents > 0) {\n    int maxAllAllDayHeight=height - DAY_HEADER_HEIGHT - MIN_HOURS_HEIGHT;\n    if (maxAllDayEvents == 1) {\n      allDayHeight=SINGLE_ALLDAY_HEIGHT;\n    }\n else     if (maxAllDayEvents <= mMaxUnexpandedAlldayEventCount) {\n      allDayHeight=maxAllDayEvents * MAX_HEIGHT_OF_ONE_ALLDAY_EVENT;\n      if (allDayHeight > MAX_UNEXPANDED_ALLDAY_HEIGHT) {\n        allDayHeight=MAX_UNEXPANDED_ALLDAY_HEIGHT;\n      }\n    }\n else {\n      if (mAnimateDayHeight != 0) {\n        allDayHeight=Math.max(mAnimateDayHeight,MAX_UNEXPANDED_ALLDAY_HEIGHT);\n      }\n else {\n        allDayHeight=(int)(maxAllDayEvents * MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT);\n        if (!mShowAllAllDayEvents && allDayHeight > MAX_UNEXPANDED_ALLDAY_HEIGHT) {\n          allDayHeight=(int)(mMaxUnexpandedAlldayEventCount * MIN_UNEXPANDED_ALLDAY_EVENT_HEIGHT);\n        }\n else         if (allDayHeight > maxAllAllDayHeight) {\n          allDayHeight=maxAllAllDayHeight;\n        }\n      }\n    }\n    mFirstCell=DAY_HEADER_HEIGHT + allDayHeight + ALLDAY_TOP_MARGIN;\n  }\n else {\n    mSelectionAllday=false;\n  }\n  mAlldayHeight=allDayHeight;\n  mGridAreaHeight=height - mFirstCell;\n  int allDayIconWidth=mExpandAlldayDrawable.getIntrinsicWidth();\n  mExpandAllDayRect.left=Math.max((mHoursWidth - allDayIconWidth) / 2,EVENT_ALL_DAY_TEXT_LEFT_MARGIN);\n  mExpandAllDayRect.right=Math.min(mExpandAllDayRect.left + allDayIconWidth,mHoursWidth - EVENT_ALL_DAY_TEXT_RIGHT_MARGIN);\n  mExpandAllDayRect.bottom=mFirstCell - EXPAND_ALL_DAY_BOTTOM_MARGIN;\n  mExpandAllDayRect.top=mExpandAllDayRect.bottom - mExpandAlldayDrawable.getIntrinsicHeight();\n  mNumHours=mGridAreaHeight / (mCellHeight + HOUR_GAP);\n  mEventGeometry.setHourHeight(mCellHeight);\n  final long minimumDurationMillis=(long)(MIN_EVENT_HEIGHT * DateUtils.MINUTE_IN_MILLIS / (mCellHeight / 60.0f));\n  Event.computePositions(mEvents,minimumDurationMillis);\n  mMaxViewStartY=HOUR_GAP + 24 * (mCellHeight + HOUR_GAP) - mGridAreaHeight;\n  if (DEBUG) {\n    Log.e(TAG,\"mViewStartY: \" + mViewStartY);\n    Log.e(TAG,\"mMaxViewStartY: \" + mMaxViewStartY);\n  }\n  if (mViewStartY > mMaxViewStartY) {\n    mViewStartY=mMaxViewStartY;\n    computeFirstHour();\n  }\n  if (mFirstHour == -1) {\n    initFirstHour();\n    mFirstHourOffset=0;\n  }\n  if (mFirstHourOffset >= mCellHeight + HOUR_GAP) {\n    mFirstHourOffset=mCellHeight + HOUR_GAP - 1;\n  }\n  mViewStartY=mFirstHour * (mCellHeight + HOUR_GAP) - mFirstHourOffset;\n  final int eventAreaWidth=mNumDays * (mCellWidth + DAY_GAP);\n  if (mSelectedEvent != null && mLastPopupEventID != mSelectedEvent.id) {\n    mPopup.dismiss();\n  }\n  mPopup.setWidth(eventAreaWidth - 20);\n  mPopup.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);\n}\n", "docstring": "measures the space needed for various parts of the view after loading new events . this can change if there are all - day events .", "partition": "test"}
{"idx": "3795", "code": "private void requestFragmenting(IgfsEntryInfo fileInfo){\n  IgfsFileMap map=fileInfo.fileMap();\n  assert map != null && !map.ranges().isEmpty();\n  Map<UUID,Collection<IgfsFileAffinityRange>> grpMap=U.newHashMap(map.ranges().size());\n  for (  IgfsFileAffinityRange range : map.ranges()) {\n    UUID nodeId=igfsCtx.data().affinityNode(range.affinityKey()).id();\n    Collection<IgfsFileAffinityRange> nodeRanges=grpMap.get(nodeId);\n    if (nodeRanges == null) {\n      nodeRanges=new LinkedList<>();\n      grpMap.put(nodeId,nodeRanges);\n    }\n    nodeRanges.addAll(range.split(igfsCtx.data().groupBlockSize()));\n  }\n  Collection<UUID> nodeIds=new IdentityHashSet(grpMap.keySet());\n  if (log.isDebugEnabled())   log.debug(\"Calculating fragmentizer groups for file [fileInfo=\" + fileInfo + \", nodeIds=\"+ nodeIds+ \']\');\n  Object old=fragmentingFiles.putIfAbsent(fileInfo.id(),nodeIds);\n  assert old == null;\n  for (  Map.Entry<UUID,Collection<IgfsFileAffinityRange>> entry : grpMap.entrySet()) {\n    UUID nodeId=entry.getKey();\n    IgfsFragmentizerRequest msg=new IgfsFragmentizerRequest(fileInfo.id(),entry.getValue());\n    try {\n      if (log.isDebugEnabled())       log.debug(\"Sending fragmentizer request to remote node [nodeId=\" + nodeId + \", fileId=\"+ fileInfo.id()+ \", msg=\"+ msg+ \']\');\n      sendWithRetries(nodeId,msg);\n    }\n catch (    IgniteCheckedException e) {\n      if (e.hasCause(ClusterTopologyCheckedException.class)) {\n        if (log.isDebugEnabled())         log.debug(\"Failed to send fragmentizer request to remote node (node left grid): \" + nodeId);\n      }\n else       U.error(log,\"Failed to send fragmentizer request to remote node [nodeId=\" + nodeId + \", msg=\"+ msg+ \']\',e);\n      nodeIds.remove(nodeId);\n    }\n  }\n  if (nodeIds.isEmpty()) {\n    if (log.isDebugEnabled())     log.debug(\"Got empty wait set for fragmentized file: \" + fileInfo);\n    fragmentingFiles.remove(fileInfo.id(),nodeIds);\n  }\n}\n", "docstring": "starts file fragmenting . will group file affinity ranges by nodes and send requests to each node . file will be considered processed when each node replied with success ( or error ) or left the grid .", "partition": "test"}
{"idx": "3796", "code": "public boolean showPreviousNotification(){\n  int i=getSelectedIndex();\n  if (i != -1 && i > 0) {\n    model.setSelectedItem(model.getElementAt(i - 1));\n    return true;\n  }\n  return false;\n}\n", "docstring": "scrolls to the previous notification .", "partition": "test"}
{"idx": "3797", "code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeBoolean(isLeaf);\n  out.writeInt(numEntries);\n}\n", "docstring": "calls the super method and writes the id of this node , the numentries and the entries array to the specified stream .", "partition": "test"}
{"idx": "3798", "code": "protected void addInputNode_internal(BNode inputNode){\n  if (inputNodes.containsKey(inputNode.getId())) {\n    log.warning(\"node \" + inputNode.getId() + \" already included in the input nodes of \"+ nodeId);\n  }\n  inputNodes.put(inputNode.getId(),inputNode);\n}\n", "docstring": "adds a new incoming relation to the node . this method should never be called outside the addrelation method , to ensure consistency between the input and output links .", "partition": "test"}
{"idx": "3799", "code": "public static void initialize(final CDatabaseConfiguration configuration) throws CouldntLoadDriverException, CouldntConnectException, SQLException {\n  checkDriver(configuration);\n  final String url=POSTGRES_DRIVER + \"//\" + configuration.getHost()+ \"/\"+ POSTGRES_DEFAULT_DB;\n  Connection connection=null;\n  try {\n    connection=DriverManager.getConnection(url,configuration.getUser(),configuration.getPassword());\n  }\n catch (  final SQLException exception) {\n    CUtilityFunctions.logException(exception);\n    throw new CouldntConnectException(exception,exception.getErrorCode(),exception.getSQLState());\n  }\n  final String statement=\"CREATE DATABASE \\\"\" + configuration.getName() + \"\\\"\";\n  final PreparedStatement preparedStatement=connection.prepareStatement(statement);\n  try {\n    preparedStatement.execute();\n  }\n  finally {\n    preparedStatement.close();\n    connection.close();\n  }\n}\n", "docstring": "initializes a new postgresql database", "partition": "test"}
{"idx": "3800", "code": "public List<FCEndpoint> showFcnsDatabase(Integer vsanId) throws NetworkDeviceControllerException {\n  Map<Integer,String> vsanToWwns=getVsanWwns(vsanId);\n  List<FCEndpoint> connections=new ArrayList<FCEndpoint>();\n  SSHPrompt[] prompts={SSHPrompt.MDS_POUND,SSHPrompt.MDS_GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  String cmd=MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.cmd\");\n  if (vsanId != null) {\n    cmd=cmd + MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.vsan.cmd\") + vsanId.toString()+ \"\\n\";\n  }\n else {\n    cmd=cmd + \"\\n\";\n  }\n  SSHPrompt prompt=sendWaitFor(cmd,defaultTimeout,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.VSAN.match\"),MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.portwwn.match\"),MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.nodewwn.match\"),MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.fabricportwwn.match\"),MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.ConnectedInterface.match\"),MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.SwitchName.match\"),MDSDialogProperties.getString(\"MDSDialog.showFcnsDatabase.deviceAlias.match\")};\n  String[] groups=new String[10];\n  FCEndpoint conn=null;\n  for (  String line : lines) {\n    int index=match(line,regex,groups,Pattern.CASE_INSENSITIVE);\nswitch (index) {\ncase 0:\n      conn=new FCEndpoint();\n    conn.setFabricId(groups[0]);\n  conn.setFcid(groups[1]);\nString fabricWwn=vsanToWwns.get(new Integer(groups[0]));\nif (fabricWwn != null) {\nconn.setFabricWwn(fabricWwn);\n}\nconnections.add(conn);\nbreak;\ncase 1:\nconn.setRemotePortName(groups[0]);\nbreak;\ncase 2:\nconn.setRemoteNodeName(groups[0]);\nbreak;\ncase 3:\nconn.setSwitchPortName(groups[0]);\nbreak;\ncase 4:\nconn.setSwitchInterface(groups[0]);\nbreak;\ncase 5:\nconn.setSwitchName(groups[0]);\nbreak;\ncase 6:\nconn.setRemotePortAlias(groups[0]);\n}\n}\nreturn connections;\n}\n", "docstring": "generates a set of fcportconnection entries for the specified vsan id ( or all vsans if vsanid is null ) .", "partition": "test"}
{"idx": "3801", "code": "public static void keytool(String cmd){\n  log.info(\"keytool \" + cmd);\n  ArrayList<String> list=new ArrayList<String>();\n  StringTokenizer st=new StringTokenizer(cmd,\" \");\n  String quoteBuffer=null;\n  while (st.hasMoreTokens()) {\n    String token=st.nextToken();\n    if (quoteBuffer == null) {\n      if (token.startsWith(\"\\\"\"))       quoteBuffer=token.substring(1);\n else       list.add(token);\n    }\n else     quoteBuffer+=\" \" + token;\n    if (token.endsWith(\"\\\"\")) {\n      String str=quoteBuffer.substring(0,quoteBuffer.length() - 1);\n      list.add(str);\n      quoteBuffer=null;\n    }\n  }\n  String[] args=new String[list.size()];\n  list.toArray(args);\n  try {\n    KeyTool.main(args);\n  }\n catch (  Exception e) {\n  }\n}\n", "docstring": "submit command to key tool", "partition": "test"}
{"idx": "3802", "code": "private void smoothSnapToPosition(int scrollY,int availableScrollHeight,AlphabeticalAppsList.FastScrollSectionInfo info){\n  mRv.removeCallbacks(mSmoothSnapNextFrameRunnable);\n  mRv.removeCallbacks(mFastScrollToTargetSectionRunnable);\n  trackAllChildViews();\n  if (mHasFastScrollTouchSettled) {\n    mCurrentFastScrollSection=info.sectionName;\n    mTargetFastScrollSection=null;\n    updateTrackedViewsFastScrollFocusState();\n  }\n else {\n    mCurrentFastScrollSection=null;\n    mTargetFastScrollSection=info.sectionName;\n    mHasFastScrollTouchSettled=false;\n    updateTrackedViewsFastScrollFocusState();\n    mRv.postDelayed(mFastScrollToTargetSectionRunnable,mHasFastScrollTouchSettledAtLeastOnce ? REPEAT_TOUCH_SETTLING_DURATION : INITIAL_TOUCH_SETTLING_DURATION);\n  }\n  int newScrollY=Math.min(availableScrollHeight,mRv.getPaddingTop() + mRv.getTop(info.fastScrollToItem.rowIndex));\n  int numFrames=mFastScrollFrames.length;\n  for (int i=0; i < numFrames; i++) {\n    mFastScrollFrames[i]=(newScrollY - scrollY) / numFrames;\n  }\n  mFastScrollFrameIndex=0;\n  mRv.postOnAnimation(mSmoothSnapNextFrameRunnable);\n}\n", "docstring": "smoothly snaps to a given position . we do this manually by calculating the keyframes ourselves and animating the scroll on the recycler view .", "partition": "test"}
{"idx": "3803", "code": "private void updatePropertyToValue2() throws Exception {\n  properties.put(TEST_KEY,TEST_VALUE_2);\n  updatePropertiesFile();\n}\n", "docstring": "updates the key in the persistent property store to \" value 2 \" .", "partition": "test"}
{"idx": "3804", "code": "public void unassignServices(String universalId,Set serviceNames) throws AMConsoleException {\n  if ((serviceNames != null) && !serviceNames.isEmpty()) {\n    String[] params=new String[2];\n    params[0]=universalId;\n    String currentSvc=\"\";\n    try {\n      AMIdentity amid=IdUtils.getIdentity(getUserSSOToken(),universalId);\n      for (Iterator iter=serviceNames.iterator(); iter.hasNext(); ) {\n        currentSvc=(String)iter.next();\n        params[1]=currentSvc;\n        logEvent(\"ATTEMPT_IDENTITY_UNASSIGN_SERVICE\",params);\n        amid.unassignService(currentSvc);\n        logEvent(\"SUCCEED_IDENTITY_UNASSIGN_SERVICE\",params);\n      }\n    }\n catch (    SSOException e) {\n      String[] paramsEx={universalId,currentSvc,getErrorString(e)};\n      logEvent(\"SSO_EXCEPTION_IDENTITY_UNASSIGN_SERVICE\",paramsEx);\n      debug.warning(\"EntitiesModelImpl.unassignServices\",e);\n      throw new AMConsoleException(getErrorString(e));\n    }\ncatch (    IdRepoException e) {\n      String[] paramsEx={universalId,currentSvc,getErrorString(e)};\n      logEvent(\"IDM_EXCEPTION_IDENTITY_UNASSIGN_SERVICE\",paramsEx);\n      debug.warning(\"EntitiesModelImpl.unassignServices\",e);\n      throw new AMConsoleException(getErrorString(e));\n    }\n  }\n}\n", "docstring": "unassigns services from an entity .", "partition": "test"}
{"idx": "3805", "code": "private static Address GetFloatArrayElements(JNIEnvironment env,int arrayJREF,Address isCopyAddress){\n  if (traceJNI)   VM.sysWrite(\"JNI called: GetFloatArrayElements  \\n\");\n  RuntimeEntrypoints.checkJNICountDownToGC();\n  try {\n    float[] sourceArray=(float[])env.getJNIRef(arrayJREF);\n    int size=sourceArray.length;\n    if (MemoryManager.willNeverMove(sourceArray)) {\n      JNIGenericHelpers.setBoolStar(isCopyAddress,false);\n      return Magic.objectAsAddress(sourceArray);\n    }\n else {\n      Address copyBuffer=sysCall.sysMalloc(size << LOG_BYTES_IN_FLOAT);\n      if (copyBuffer.isZero()) {\n        env.recordException(new OutOfMemoryError());\n        return Address.zero();\n      }\n      Memory.memcopy(copyBuffer,Magic.objectAsAddress(sourceArray),size << LOG_BYTES_IN_FLOAT);\n      JNIGenericHelpers.setBoolStar(isCopyAddress,true);\n      return copyBuffer;\n    }\n  }\n catch (  Throwable unexpected) {\n    if (traceJNI)     unexpected.printStackTrace(System.err);\n    env.recordException(unexpected);\n    return Address.zero();\n  }\n}\n", "docstring": "getfloatarrayelements : get all the elements of a float array", "partition": "test"}
{"idx": "3806", "code": "@Override public int parse(DateTimeParseContext context,CharSequence text,int position){\n  int length=text.length();\n  if (position > length) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (position == length) {\n    return ~position;\n  }\n  char nextChar=text.charAt(position);\n  if (nextChar == '+' || nextChar == '-') {\n    return parseOffsetBased(context,text,position,position,OffsetIdPrinterParser.INSTANCE_ID_Z);\n  }\n else   if (length >= position + 2) {\n    char nextNextChar=text.charAt(position + 1);\n    if (context.charEquals(nextChar,'U') && context.charEquals(nextNextChar,'T')) {\n      if (length >= position + 3 && context.charEquals(text.charAt(position + 2),'C')) {\n        return parseOffsetBased(context,text,position,position + 3,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n      }\n      return parseOffsetBased(context,text,position,position + 2,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n    }\n else     if (context.charEquals(nextChar,'G') && length >= position + 3 && context.charEquals(nextNextChar,'M') && context.charEquals(text.charAt(position + 2),'T')) {\n      return parseOffsetBased(context,text,position,position + 3,OffsetIdPrinterParser.INSTANCE_ID_ZERO);\n    }\n  }\n  PrefixTree tree=getTree(context);\n  ParsePosition ppos=new ParsePosition(position);\n  String parsedZoneId=tree.match(text,ppos);\n  if (parsedZoneId == null) {\n    if (context.charEquals(nextChar,'Z')) {\n      context.setParsed(ZoneOffset.UTC);\n      return position + 1;\n    }\n    return ~position;\n  }\n  context.setParsed(ZoneId.of(parsedZoneId));\n  return ppos.getIndex();\n}\n", "docstring": "this implementation looks for the longest matching string . for example , parsing etc / gmt - 2 will return etc / gmc - 2 rather than just etc / gmc although both are valid .", "partition": "test"}
{"idx": "3807", "code": "private void prepareTransfers() throws LibUsbException {\n  if (mAvailableTransfers == null) {\n    mAvailableTransfers=new LinkedTransferQueue<>();\n    for (int x=0; x < TRANSFER_BUFFER_POOL_SIZE; x++) {\n      Transfer transfer=LibUsb.allocTransfer();\n      if (transfer == null) {\n        throw new LibUsbException(\"couldn\'t allocate transfer\",LibUsb.ERROR_NO_MEM);\n      }\n      final ByteBuffer buffer=ByteBuffer.allocateDirect(mBufferSize);\n      LibUsb.fillBulkTransfer(transfer,mDeviceHandle,USB_ENDPOINT,buffer,BufferProcessor.this,\"Buffer\",USB_TIMEOUT_US);\n      mAvailableTransfers.add(transfer);\n    }\n  }\n}\n", "docstring": "prepares ( allocates ) a set of transfer buffers for use in transferring data from the tuner via the bulk interface", "partition": "test"}
{"idx": "3808", "code": "private void outputFullLines() throws IOException {\n  for (; ; ) {\n    int leftLen=leftBuf.indexOf(\"\\n\");\n    if (leftLen < 0) {\n      return;\n    }\n    int rightLen=rightBuf.indexOf(\"\\n\");\n    if (rightLen < 0) {\n      return;\n    }\n    if (leftLen != 0) {\n      out.write(leftBuf.substring(0,leftLen));\n    }\n    if (rightLen != 0) {\n      writeSpaces(out,leftWidth - leftLen);\n      out.write(rightBuf.substring(0,rightLen));\n    }\n    out.write(\'\\n\');\n    leftBuf.delete(0,leftLen + 1);\n    rightBuf.delete(0,rightLen + 1);\n  }\n}\n", "docstring": "outputs to the final destination as many full line pairs as there are in the pending output , removing those lines from their respective buffers . this method terminates when at least one of the two column buffers is empty .", "partition": "test"}
{"idx": "3809", "code": "@Secured public void addPay_Simple(long userId,BigDecimal amount,Date created,PaymentType payType,String details,boolean updateCache) throws ConcurrentUpdateSqlException, Exception {\n  checkAccessFor_ADMIN();\n  amount=amount.abs();\n  long id=universal.nextSeqFor(payments);\n  PaymentExt payment=PaymentExt.createSystemPayment(id,userId,amount,created,payType,details);\n  BigDecimal newVal=doPayment(userId,payment,updateCache);\n  log.info(\"pay added: userId=\" + userId + (newVal != null ? \", newBalance=\" + newVal : \"\")+ \", req=\"+ getReqInfoStr());\n}\n", "docstring": "positive amount . no unblocks if blocked", "partition": "test"}
{"idx": "3810", "code": "private void removeAllObjects(){\n  logger.debug(\"CLEANING screen object list\");\n  texts.clear();\n}\n", "docstring": "remove all map objects .", "partition": "test"}
{"idx": "3811", "code": "public Builder deleteDisplayName(){\n  deleteFields.add(\"displayName\");\n  return this;\n}\n", "docstring": "deletes the display name of a existing user", "partition": "test"}
{"idx": "3812", "code": "private void waitForIteratorsCleared(IgniteCache<String,Integer> cache,int secs) throws InterruptedException {\n  for (int i=0; i < secs; i++) {\n    try {\n      cache.size();\n      checkIteratorsCleared();\n    }\n catch (    AssertionFailedError e) {\n      if (i == 9) {\n        for (int j=0; j < gridCount(); j++)         executeOnLocalOrRemoteJvm(j,new PrintIteratorStateTask());\n        throw e;\n      }\n      log.info(\"Iterators not cleared, will wait\");\n      Thread.sleep(1000);\n    }\n  }\n}\n", "docstring": "checks iterators are cleared .", "partition": "test"}
{"idx": "3813", "code": "public void addLifecycleListener(LifecycleListener lifecycleListener){\n  if (!lifecycleListeners.contains(lifecycleListener)) {\n    lifecycleListeners.add(lifecycleListener);\n  }\n}\n", "docstring": "adds a listener for all of this controller \"'\" s lifecycle events", "partition": "test"}
{"idx": "3814", "code": "boolean destroyVolume(boolean force){\n  NaElement elem=new NaElement(\"volume-destroy\");\n  elem.addNewChild(\"force\",Boolean.toString(force));\n  elem.addNewChild(\"name\",name);\n  try {\n    server.invokeElem(elem);\n    return true;\n  }\n catch (  Exception e) {\n    String msg=\"Failed to destroy volume: \" + name;\n    log.error(msg,e);\n    throw new NetAppException(msg,e);\n  }\n}\n", "docstring": "destroys a volume , releasing all storage blocks assigned to it .", "partition": "test"}
{"idx": "3815", "code": "private boolean validateCooldownSetting(String appId,AutoScalerPolicyTrigger policyTrigger,String triggerId){\n  AutoScalingDataStore stateStore=AutoScalingDataStoreFactory.getAutoScalingDataStore();\n  AppAutoScaleState appState=null;\n  appState=stateStore.getScalingState(appId);\n  if (appState == null) {\n    return true;\n  }\n else   if ((appState.getInstanceCountState() != ScalingStateManager.SCALING_STATE_COMPLETED) && (appState.getInstanceCountState() != ScalingStateManager.SCALING_STATE_FAILED)) {\n    long lastStartTime=appState.getLastActionStartTime();\n    long currentTime=System.currentTimeMillis();\n    boolean timeExpired=(currentTime - lastStartTime) > this.eventTimeout;\n    if (timeExpired) {\n      logger.debug(\"True: Last scaling action is not completed but it\'s time expired for application \" + appId + \".\");\n      return true;\n    }\n    logger.debug(\"False: Last scaling action is not completed for application \" + appId + \".\");\n    return false;\n  }\n else {\n    long cooldownEndtime=appState.getLastActionEndTime() + 1000L * getCooldownSecs(policyTrigger,triggerId);\n    if (System.currentTimeMillis() < cooldownEndtime) {\n      logger.debug(\"False: It\'s cooldown time for application \" + appId + \". No scaling in action.\");\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "checks if the app should be scaled in / out according to cooldown settings", "partition": "test"}
{"idx": "3816", "code": "private long convertToBytes(int megaBytes){\n  long bytes=megaBytes;\n  bytes=bytes * 1024 * 1024;\n  return bytes;\n}\n", "docstring": "takes an int which is supposed to be in megabytes and converts it to a long . this conversion takes into account that multiplication can lead to integer . max_value being exceeded", "partition": "test"}
{"idx": "3817", "code": "private String generateZonesetCloneName(String zonesetToClone){\n  try {\n    Thread.sleep(1000);\n  }\n catch (  InterruptedException ex) {\n    _log.warn(ex.getLocalizedMessage());\n  }\n  Calendar cal=Calendar.getInstance();\n  DateFormat dateFormat=new SimpleDateFormat(\"MMddyy-HHmmss\");\n  String dateString=dateFormat.format(cal.getTime());\n  String longName=MDSDialogProperties.getString(\"MDSDialog.zonesetCloneLongName.cmd\");\n  if (!longName.contains(\"!MDSDialog.zonesetCloneLongName.cmd!\")) {\n    return longName;\n  }\n  return \"ViPR-\" + zonesetToClone + \"-\"+ dateString;\n}\n", "docstring": "generate a unique name for the zoneset clone . the format of the zoneset clone name is \" vipr - < existing_zone > - mmddyy - hhmmss \" mmddyy and hhmmss refer to the date and the time - stamp that will help identify when the clone was taken .", "partition": "test"}
{"idx": "3818", "code": "protected abstract void writeSignatureBlock(byte[] signature,OutputStream out) throws IOException ;\n", "docstring": "write a . rsa file with a digital signature .", "partition": "test"}
{"idx": "3819", "code": "private StringBuffer buildSelectQuery(String schemaName,String tableName,ArrayList<OneRowChange.ColumnSpec> keys,ArrayList<OneRowChange.ColumnVal> keyValues){\n  StringBuffer stmt=new StringBuffer();\n  stmt.append(\"SELECT * FROM \");\n  stmt.append(conn.getDatabaseObjectName(schemaName) + \".\" + conn.getDatabaseObjectName(tableName));\n  stmt.append(\" WHERE \");\n  printColumnSpec(stmt,keys,keyValues,PrintMode.ASSIGNMENT,\" AND \");\n  return stmt;\n}\n", "docstring": "constructs a sql statement template later used for prepared statement .", "partition": "test"}
{"idx": "3820", "code": "public static boolean isUriKey(String key){\n  return key.endsWith(\".url\") || key.endsWith(\".uri\");\n}\n", "docstring": "this method determines if the supplied key relates to a uri .", "partition": "test"}
{"idx": "3821", "code": "public synchronized void addOFChannelHandlerAndSendRole(OFChannelHandler h){\n  connectedChannelHandlers.add(h);\n  h.sendRoleRequest(this.role);\n}\n", "docstring": "add a newly connected ofchannelhandler . the channel handler is added we send the current role to the channel handler . all subsequent role changes will be send to all connected", "partition": "test"}
{"idx": "3822", "code": "public boolean send(byte[] bytes){\n  if (!connected)   return false;\n  try {\n    outputStream.write(bytes);\n    outputStream.flush();\n    return true;\n  }\n catch (  IOException e) {\n    connected=false;\n    Log.e(TAG,\"Fail to send data\");\n    return false;\n  }\n finally {\n    if (!connected) {\n      closeConnection();\n    }\n  }\n}\n", "docstring": "send array of bytes to bluetooth output stream .", "partition": "test"}
{"idx": "3823", "code": "public void addTailArg(String arg){\n  _tailArgs.add(arg);\n}\n", "docstring": "adds an arg after the command and any options .", "partition": "test"}
{"idx": "3824", "code": "private String translateBytesToString(byte[] bytes,long format,Transferable localeTransferable) throws IOException {\n  Long lFormat=Long.valueOf(format);\n  String charset=getBestCharsetForTextFormat(lFormat,localeTransferable);\n  String eoln=(String)nativeEOLNs.get(lFormat);\n  Integer terminators=(Integer)nativeTerminators.get(lFormat);\n  int count;\n  if (terminators != null) {\n    int numTerminators=terminators.intValue();\n    search:     for (count=0; count < (bytes.length - numTerminators + 1); count+=numTerminators) {\n      for (int i=count; i < count + numTerminators; i++) {\n        if (bytes[i] != 0x0) {\n          continue search;\n        }\n      }\n      break search;\n    }\n  }\n else {\n    count=bytes.length;\n  }\n  String converted=new String(bytes,0,count,charset);\n  if (eoln != null) {\n    char[] buf=converted.toCharArray();\n    char[] eoln_arr=eoln.toCharArray();\n    converted=null;\n    int j=0;\n    boolean match;\n    for (int i=0; i < buf.length; ) {\n      if (i + eoln_arr.length > buf.length) {\n        buf[j++]=buf[i++];\n        continue;\n      }\n      match=true;\n      for (int k=0, l=i; k < eoln_arr.length; k++, l++) {\n        if (eoln_arr[k] != buf[l]) {\n          match=false;\n          break;\n        }\n      }\n      if (match) {\n        buf[j++]='\\n';\n        i+=eoln_arr.length;\n      }\n else {\n        buf[j++]=buf[i++];\n      }\n    }\n    converted=new String(buf,0,j);\n  }\n  return converted;\n}\n", "docstring": "translating either a byte array or an inputstream into an string . strip terminators and search - and - replace eoln . native to java string conversion", "partition": "test"}
{"idx": "3825", "code": "public InlineURIHandler(final String namespace){\n  this.namespace=namespace;\n  this.len=namespace.length();\n}\n", "docstring": "create a handler for the supplied namespace prefix - the handler will be invoked iff it is the registered handler having the longest prefix lte to the actual uri .", "partition": "test"}
{"idx": "3826", "code": "private double[] CalcVariableCoef(Variogram variogram,KrigingPoint p,List<KrigingPoint> NNPoints){\n  int n=NNPoints.size();\n  double[] mat=new double[n + 1];\n  double dist=0.0;\n  for (int i=0; i < n; i++) {\n    dist=Math.sqrt(Math.abs(Math.pow(NNPoints.get(i).x - p.x,2)) + Math.abs(Math.pow(NNPoints.get(i).y - p.y,2)));\n    mat[i]=getTheoreticalSVValue(dist,variogram);\n  }\n  mat[n]=1;\n  return mat;\n}\n", "docstring": "calculates the d matrix for kriging system", "partition": "test"}
{"idx": "3827", "code": "public static Object deserialization(String filePath){\n  ObjectInputStream in=null;\n  try {\n    in=new ObjectInputStream(new FileInputStream(filePath));\n    Object o=in.readObject();\n    in.close();\n    return o;\n  }\n catch (  FileNotFoundException e) {\n    throw new RuntimeException(\"FileNotFoundException occurred. \",e);\n  }\ncatch (  ClassNotFoundException e) {\n    throw new RuntimeException(\"ClassNotFoundException occurred. \",e);\n  }\ncatch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    IOUtils.close(in);\n  }\n}\n", "docstring": "deserialization object from file .", "partition": "test"}
{"idx": "3828", "code": "public void updateEnd(Logger log){\n  m_instanceCount++;\n  m_sampleCount++;\n  double end=System.currentTimeMillis();\n  double temp=end - m_updateStart;\n  m_cumulativeTime+=temp;\n  boolean toFastToMeasure=false;\n  if ((end - m_startTime) >= m_sampleTime) {\n    computeUpdate(end);\n    if (log != null) {\n      log.statusMessage(m_statusMessagePrefix + \"Processed \" + m_instanceCount+ \" insts @ \"+ m_avInstsPerSec / m_numSamples + \" insts/sec\" + (toFastToMeasure ? \"*\" : \"\"));\n    }\n    m_sampleCount=0;\n    m_cumulativeTime=0;\n    m_startTime=System.currentTimeMillis();\n  }\n}\n", "docstring": "register a throughput measurement end point . collects counts and statistics . will update the status area for the kf step in question if the sample period has elapsed .", "partition": "test"}
{"idx": "3829", "code": "public boolean shouldInclude(final Path path){\n  return includeMatchers.size() == 0 || matches(path,includeMatchers);\n}\n", "docstring": "check whether a path should be included .", "partition": "test"}
{"idx": "3830", "code": "public ArrayList<MechSummary> generateUnits(int num,UnitFilter filter){\n  ArrayList<MechSummary> retVal=new ArrayList<>();\n  for (int i=0; i < num; i++) {\n    MechSummary ms=generateUnit(filter);\n    if (ms != null) {\n      retVal.add(ms);\n    }\n  }\n  return retVal;\n}\n", "docstring": "selects a number of units from the table with a filter .", "partition": "test"}
{"idx": "3831", "code": "static public Automaton concatenate(Automaton a1,Automaton a2){\n  return concatenate(Arrays.asList(a1,a2));\n}\n", "docstring": "returns an automaton that accepts the concatenation of the languages of the given automata . < p > complexity : linear in total number of states .", "partition": "test"}
{"idx": "3832", "code": "public void contentsChanged(ListDataEvent e){\n  Object oldSelection=selectedItemReminder;\n  Object newSelection=dataModel.getSelectedItem();\n  if (oldSelection == null || !oldSelection.equals(newSelection)) {\n    selectedItemChanged();\n    if (!selectingItem) {\n      fireActionEvent();\n    }\n  }\n}\n", "docstring": "this method is public as an implementation side effect . do not call or override .", "partition": "test"}
{"idx": "3833", "code": "protected void adjustCanopies(double[] densities){\n  if (m_numClustersRequested < 0) {\n    assignCanopiesToCanopyCenters();\n    m_trainingData=new Instances(m_canopies,0);\n    return;\n  }\n  if (m_canopies.numInstances() > m_numClustersRequested) {\n    int[] sortedIndexes=Utils.stableSort(densities);\n    Instances finalCanopies=new Instances(m_canopies,0);\n    int count=0;\n    for (int i=sortedIndexes.length - 1; count < m_numClustersRequested; i--) {\n      finalCanopies.add(m_canopies.instance(sortedIndexes[i]));\n      count++;\n    }\n    m_canopies=finalCanopies;\n    List<double[][]> tempCanopyCenters=new ArrayList<double[][]>();\n    List<double[]> tempT2Dists=new ArrayList<double[]>();\n    List<double[]> tempMissings=new ArrayList<double[]>();\n    count=0;\n    for (int i=sortedIndexes.length - 1; count < finalCanopies.numInstances(); i--) {\n      tempCanopyCenters.add(m_canopyCenters.get(sortedIndexes[i]));\n      tempT2Dists.add(m_canopyT2Density.get(sortedIndexes[i]));\n      tempMissings.add(m_canopyNumMissingForNumerics.get(sortedIndexes[i]));\n      count++;\n    }\n    m_canopyCenters=tempCanopyCenters;\n    m_canopyT2Density=tempT2Dists;\n    m_canopyNumMissingForNumerics=tempMissings;\n  }\n else   if (m_canopies.numInstances() < m_numClustersRequested && m_trainingData != null && m_trainingData.numInstances() > 0) {\n    Random r=new Random(getSeed());\n    for (int i=0; i < 10; i++) {\n      r.nextInt();\n    }\n    HashMap<DecisionTableHashKey,Integer> initC=new HashMap<DecisionTableHashKey,Integer>();\n    DecisionTableHashKey hk=null;\n    for (int i=0; i < m_canopies.numInstances(); i++) {\n      try {\n        hk=new DecisionTableHashKey(m_canopies.instance(i),m_canopies.numAttributes(),true);\n        initC.put(hk,null);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n    }\n    for (int j=m_trainingData.numInstances() - 1; j >= 0; j--) {\n      int instIndex=r.nextInt(j + 1);\n      try {\n        hk=new DecisionTableHashKey(m_trainingData.instance(instIndex),m_trainingData.numAttributes(),true);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n      if (!initC.containsKey(hk)) {\n        Instance newInstance=m_trainingData.instance(instIndex);\n        m_canopies.add(newInstance);\n        double[] density=new double[1];\n        density[0]=1.0;\n        m_canopyT2Density.add(density);\n        double[][] center=new double[newInstance.numAttributes()][0];\n        double[] numMissingNumerics=new double[newInstance.numAttributes()];\n        updateCanopyCenter(newInstance,center,numMissingNumerics);\n        m_canopyCenters.add(center);\n        m_canopyNumMissingForNumerics.add(numMissingNumerics);\n        initC.put(hk,null);\n      }\n      m_trainingData.swap(j,instIndex);\n      if (m_canopies.numInstances() == m_numClustersRequested) {\n        break;\n      }\n    }\n  }\n  assignCanopiesToCanopyCenters();\n  m_trainingData=new Instances(m_canopies,0);\n}\n", "docstring": "adjust the final number of canopies to match the user - requested number ( if possible )", "partition": "test"}
{"idx": "3834", "code": "protected void createFromHValues(int[] hValues,int partitions){\n  Arrays.sort(hValues);\n  this.splits=new int[partitions];\n  int maxH=0x7fffffff;\n  for (int i=0; i < splits.length; i++) {\n    int quantile=(int)((long)(i + 1) * hValues.length / partitions);\n    this.splits[i]=quantile == hValues.length ? maxH : hValues[quantile];\n  }\n}\n", "docstring": "create a hilbertcurvepartitioner from a list of points", "partition": "test"}
{"idx": "3835", "code": "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n  iInstant=(LocalDateTime)oos.readObject();\n  DateTimeFieldType type=(DateTimeFieldType)oos.readObject();\n  iField=type.getField(iInstant.getChronology());\n}\n", "docstring": "reads the property from a safe serialization format .", "partition": "test"}
{"idx": "3836", "code": "private String convertUserInputIntoAFullyQualifiedPath(final String userInput){\n  if (FileUtils.denotesAbsolutePath(userInput)) {\n    return userInput;\n  }\n  if (userInput.startsWith(HOME_DIRECTORY_SYMBOL)) {\n    Assert.notNull(home,\"Home directory could not be determined from system properties\");\n    if (userInput.length() > 1) {\n      return home + userInput.substring(1);\n    }\n  }\n  String fullPath=getWorkingDirectoryAsString() + userInput;\n  return fullPath;\n}\n", "docstring": "if the user input starts with a tilde character ( ~ ) , replace the tilde character with the user \"'\" s home directory . if the user input does not start with a tilde , simply return the original user input without any changes if the input specifies an absolute path , or return an absolute path based on the working directory if the input specifies a relative path .", "partition": "test"}
{"idx": "3837", "code": "public byte readByte() throws IOException {\n  return dis.readByte();\n}\n", "docstring": "read a byte from the input stream .", "partition": "test"}
{"idx": "3838", "code": "protected static byte[] hkdfExpand(byte[] ikm,byte[] salt,byte[] info,int length) throws InvalidKeyException, NoSuchAlgorithmException {\n  HKDFBytesGenerator hkdf=new HKDFBytesGenerator(new SHA256Digest());\n  hkdf.init(new HKDFParameters(ikm,salt,info));\n  byte[] okm=new byte[length];\n  hkdf.generateBytes(okm,0,length);\n  return okm;\n}\n", "docstring": "convenience method for computing the hmac key derivation function . the real work is offloaded to bouncycastle .", "partition": "test"}
{"idx": "3839", "code": "public boolean isEmoteIgnored(Emoticon emote){\n  return ignoredEmotes.contains(emote.code);\n}\n", "docstring": "check if the given emote is on the list of ignored emotes . compares the emote code to the codes on the list .", "partition": "test"}
{"idx": "3840", "code": "public boolean isPropertyAllowed(Name name){\n  return propertiesAllowed.contains(name);\n}\n", "docstring": "is the given word the name of an allowed css property ?", "partition": "test"}
{"idx": "3841", "code": "@SuppressWarnings(\"unchecked\") public void readFile(String fileName) throws JDOMException, IOException {\n  if (checkFile(fileName)) {\n    Element root=rootFromName(fileName);\n    Element roster;\n    if (root == null) {\n      log.warn(\"consist file could not be read\");\n      return;\n    }\n    roster=root.getChild(\"roster\");\n    if (roster == null) {\n      log.debug(\"consist file does not contain a roster entry\");\n      return;\n    }\n    Iterator<Element> consistIterator=root.getDescendants(new ElementFilter(\"consist\"));\n    try {\n      Element consist;\n      do {\n        consist=consistIterator.next();\n        consistFromXml(consist);\n      }\n while (consistIterator.hasNext());\n    }\n catch (    NoSuchElementException nde) {\n      log.debug(\"end of consist list\");\n    }\n  }\n else {\n    log.info(\"Consist file does not exist.  One will be created if necessary.\");\n  }\n}\n", "docstring": "read all consists from a file .", "partition": "test"}
{"idx": "3842", "code": "public void testConstructorSignBytesZeroNull2(){\n  byte aBytes[]={};\n  int aSign=0;\n  byte rBytes[]={0};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=aNumber.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",0,aNumber.signum());\n}\n", "docstring": "create a zero number from a sign and an array of zero length . the sign is 0 .", "partition": "test"}
{"idx": "3843", "code": "private int accept(FileDescriptor ssfd,FileDescriptor newfd,InetSocketAddress[] isaa) throws IOException {\n  return accept0(ssfd,newfd,isaa);\n}\n", "docstring": "accept a connection on a socket .", "partition": "test"}
{"idx": "3844", "code": "protected void transcode(File file,Transcoder transcoder) throws IOException, TranscoderException {\n  transcoder.addTranscodingHint(XMLAbstractTranscoder.KEY_XML_PARSER_VALIDATING,Boolean.FALSE);\n  SVGDocument doc=cloneDocument();\n  TranscoderInput input=new TranscoderInput(doc);\n  OutputStream out=new BufferedOutputStream(new FileOutputStream(file));\n  TranscoderOutput output=new TranscoderOutput(out);\n  transcoder.transcode(input,output);\n  out.flush();\n  out.close();\n}\n", "docstring": "transcode a document into a file using the given transcoder .", "partition": "test"}
{"idx": "3845", "code": "@Override public Document newDocument(){\n  return new mf.org.apache.xerces.dom.DocumentImpl();\n}\n", "docstring": "non - preferred : use the getdomimplementation ( ) method instead of this one to get a dom level 2 domimplementation object and then use dom level 2 methods to create a dom document object .", "partition": "test"}
{"idx": "3846", "code": "@HLEFunction(nid=0xD1E0A01E,version=150,checkInsideInterrupt=true) public int __sceSasSetGrain(int sasCore,int grain){\n  checkSasHandleGood(sasCore);\n  grainSamples=grain;\n  return 0;\n}\n", "docstring": "set the number of samples generated by one __scesascore call .", "partition": "test"}
{"idx": "3847", "code": "public void handleTblRequestHandlerListButtonAddRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    SCSAML2SOAPBindingRequestHandlerListAddViewBean vb=(SCSAML2SOAPBindingRequestHandlerListAddViewBean)getViewBean(SCSAML2SOAPBindingRequestHandlerListAddViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n}\n", "docstring": "handles add request handler request .", "partition": "test"}
{"idx": "3848", "code": "protected static void drawDataPoint(double x,double y,double xprev,double yprev,int size,int shape,Graphics gx){\n  drawDataPoint(x,y,size,shape,gx);\n  gx.drawLine((int)x,(int)y,(int)xprev,(int)yprev);\n}\n", "docstring": "draws a data point at a given set of panel coordinates at a given size and connects a line to the previous point .", "partition": "test"}
{"idx": "3849", "code": "static boolean chunkSet(InternalDistributedMember recipient,Set set,int CHUNK_SIZE_IN_BYTES,boolean includeValues,ObjectIntProcedure proc) throws IOException {\n  Iterator it=set.iterator();\n  boolean keepGoing=true;\n  boolean sentLastChunk=false;\n  final HeapDataOutputStream mos=new HeapDataOutputStream(InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048,recipient.getVersionObject());\n  do {\n    mos.reset();\n    int avgItemSize=0;\n    int itemCount=0;\n    while ((mos.size() + avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES && it.hasNext()) {\n      Object key=it.next();\n      DataSerializer.writeObject(key,mos);\n      itemCount++;\n      avgItemSize=mos.size() / itemCount;\n    }\n    DataSerializer.writeObject((Object)null,mos);\n    int lastMsg=it.hasNext() ? 0 : 1;\n    keepGoing=proc.executeWith(mos,lastMsg);\n    sentLastChunk=lastMsg == 1 && keepGoing;\n  }\n while (keepGoing && it.hasNext());\n  return sentLastChunk;\n}\n", "docstring": "serialize the given set \"'\" s elments into byte [ ", "partition": "test"}
{"idx": "3850", "code": "private int[] parseMetaDataInformation() throws UserError {\n  int[] selectedColumns=new int[metaData.size()];\n  Set<String> usedColumnNames=new HashSet<>();\n  int columnIndex=0;\n  int usedColumnIndex=0;\n  for (  ColumnMetaData column : metaData) {\n    if (!column.isRemoved()) {\n      selectedColumns[usedColumnIndex]=columnIndex;\n      usedColumnIndex++;\n      String columnName=column.getName();\n      if (!usedColumnNames.contains(columnName)) {\n        usedColumnNames.add(columnName);\n      }\n else {\n        throw new UserError(null,\"data_import.non_unique_column_name\",columnName);\n      }\n    }\n    columnIndex++;\n  }\n  int[] attributeColumns=Arrays.copyOf(selectedColumns,usedColumnIndex);\n  return attributeColumns;\n}\n", "docstring": "goes once through the metadata , checks which columns are removed and checks that the remaining columns have unique names .", "partition": "test"}
{"idx": "3851", "code": "static Field findField(Object instance,String name) throws NoSuchFieldException {\n  for (Class<?> clazz=instance.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    try {\n      Field field=clazz.getDeclaredField(name);\n      if (!field.isAccessible()) {\n        field.setAccessible(true);\n      }\n      return field;\n    }\n catch (    NoSuchFieldException e) {\n    }\n  }\n  throw new NoSuchFieldException(\"Field \" + name + \" not found in \"+ instance.getClass());\n}\n", "docstring": "locates a given field anywhere in the class inheritance hierarchy .", "partition": "test"}
{"idx": "3852", "code": "private void addDumpFile(){\n  addDumpFile(dumpFile);\n}\n", "docstring": "add the set dumpfilestream to the tree", "partition": "test"}
{"idx": "3853", "code": "private static boolean dateByOrdinal(DateTimeFormatterBuilder bld,Collection<DateTimeFieldType> fields,boolean extended,boolean strictISO){\n  boolean reducedPrec=false;\n  if (fields.remove(DateTimeFieldType.year())) {\n    bld.append(yearElement());\n    if (fields.remove(DateTimeFieldType.dayOfYear())) {\n      appendSeparator(bld,extended);\n      bld.appendDayOfYear(3);\n    }\n else {\n      reducedPrec=true;\n    }\n  }\n else   if (fields.remove(DateTimeFieldType.dayOfYear())) {\n    bld.appendLiteral('-');\n    bld.appendDayOfYear(3);\n  }\n  return reducedPrec;\n}\n", "docstring": "creates a date using the ordinal date format . specification reference : 5 . 2 . 2 .", "partition": "test"}
{"idx": "3854", "code": "public boolean isPageInRange(int pageNumber){\n  for (int ind=0; ind < sequenceStarts.size(); ind++) {\n    if (sequenceStarts.get(ind) <= pageNumber && pageNumber <= sequenceEnds.get(ind))     return true;\n  }\n  return false;\n}\n", "docstring": "checks if a given page is present in the range built so far .", "partition": "test"}
{"idx": "3855", "code": "@SuppressWarnings(\"unchecked\") public static <T extends DimensionalItemObject>List<T> asTypedList(Collection<DimensionalItemObject> collection){\n  List<T> list=new ArrayList<>();\n  if (collection != null) {\n    for (    DimensionalItemObject object : collection) {\n      list.add((T)object);\n    }\n  }\n  return list;\n}\n", "docstring": "returns a list typed with the desired erasure based on the given collection . this operation implies an unchecked cast and it is the responsibility of the caller to make sure the cast is valid . a copy of the given list will be returned .", "partition": "test"}
{"idx": "3856", "code": "public PutIndexTemplateRequest aliases(XContentBuilder source){\n  return aliases(source.bytes());\n}\n", "docstring": "sets the aliases that will be associated with the index when it gets created", "partition": "test"}
{"idx": "3857", "code": "void addNewTable(String name,int tdefPageNumber,Short type,String linkedDbName,String linkedTableName) throws IOException {\n  addTable(name,Integer.valueOf(tdefPageNumber),type,linkedDbName,linkedTableName);\n  addToSystemCatalog(name,tdefPageNumber,type,linkedDbName,linkedTableName,_tableParentId);\n  addToAccessControlEntries(tdefPageNumber,_tableParentId,_newTableSIDs);\n}\n", "docstring": "adds a newly created table to the relevant internal database structures .", "partition": "test"}
{"idx": "3858", "code": "public static String hashpw(byte[] password0,final String salt){\n  BCrypt B;\n  String real_salt;\n  byte passwordb[]=null, saltb[], hashed[];\n  char minor=(char)0;\n  int rounds, off=0;\n  final StringBuffer rs=new StringBuffer();\n  if (salt.charAt(0) != \'$\' || salt.charAt(1) != \'2\') {\n    throw new IllegalArgumentException(\"Invalid salt version\");\n  }\n  if (salt.charAt(2) == \'$\') {\n    off=3;\n  }\n else {\n    minor=salt.charAt(2);\n    if (minor != \'a\' || salt.charAt(3) != \'$\') {\n      throw new IllegalArgumentException(\"Invalid salt revision\");\n    }\n    off=4;\n  }\n  if (salt.charAt(off + 2) > \'$\') {\n    throw new IllegalArgumentException(\"Missing salt rounds\");\n  }\n  rounds=Integer.parseInt(salt.substring(off,off + 2));\n  real_salt=salt.substring(off + 3,off + 25);\n  try {\n    if (minor >= (byte)\'a\') {\n      passwordb=Arrays.copyOf(password0,password0.length + 1);\n      passwordb[passwordb.length - 1]=(byte)0;\n    }\n else {\n      passwordb=Arrays.copyOf(password0,password0.length);\n    }\n    saltb=decode_base64(real_salt,BCRYPT_SALT_LEN);\n    B=new BCrypt();\n    hashed=B.crypt_raw(passwordb,saltb,rounds,bf_crypt_ciphertext.clone());\n  }\n  finally {\n    if (password0 != null) {\n      Arrays.fill(password0,(byte)\'\\0\');\n      password0=null;\n    }\n    if (passwordb != null) {\n      Arrays.fill(passwordb,(byte)\'\\0\');\n      passwordb=null;\n    }\n  }\n  rs.append(\"$2\");\n  if (minor >= \'a\') {\n    rs.append(minor);\n  }\n  rs.append(\"$\");\n  if (rounds < 10) {\n    rs.append(\"0\");\n  }\n  if (rounds > 30) {\n    throw new IllegalArgumentException(\"rounds exceeds maximum (30)\");\n  }\n  rs.append(Integer.toString(rounds));\n  rs.append(\"$\");\n  rs.append(encode_base64(saltb,saltb.length));\n  rs.append(encode_base64(hashed,bf_crypt_ciphertext.length * 4 - 1));\n  return rs.toString();\n}\n", "docstring": "hash a password using the openbsd bcrypt scheme", "partition": "test"}
{"idx": "3859", "code": "public void removeListener(@NotNull ConfigurationListener listener){\n  if (myListeners != null) {\n    myListeners.remove(listener);\n    if (myListeners.isEmpty()) {\n      myListeners=null;\n    }\n  }\n}\n", "docstring": "removes a listener such that it is no longer notified of changes", "partition": "test"}
{"idx": "3860", "code": "public void doWindowOpen(){\n  doConnect();\n}\n", "docstring": "this method is fired after the tab has been created and placed in the tab controller .", "partition": "test"}
{"idx": "3861", "code": "public boolean schedule(Runnable task,ClassLoader loader){\n  boolean isPriority=false;\n  boolean isQueue=true;\n  boolean isWake=true;\n  return scheduleImpl(task,loader,MAX_EXPIRE,isPriority,isQueue,isWake);\n}\n", "docstring": "schedules a new task .", "partition": "test"}
{"idx": "3862", "code": "public static int hash2(int hash,Object x,Object y){\n  return 0x20000000 | (hash + 7 * System.identityHashCode(x) + 11 * System.identityHashCode(y));\n}\n", "docstring": "utility method to combine a base hash with the identity hash of one or more objects .", "partition": "test"}
{"idx": "3863", "code": "public static double[] parseVectorString(String vectorString){\n  String[] parsedString=vectorString.split(\",\");\n  double[] vector=new double[parsedString.length];\n  for (int j=0; j < parsedString.length; j++) {\n    double val=Utils.doubleParsable(parsedString[j]);\n    vector[j]=Double.isNaN(val) ? 0 : val;\n  }\n  return vector;\n}\n", "docstring": "converts a string representation of a vector ( e . g . \" 1 , 0 , 0 , 1 , 0 \" ) into a double array . invalid characters are converted to 0 .", "partition": "test"}
{"idx": "3864", "code": "public String globalInfo(){\n  return \"A filter that removes a range of\" + \" attributes from the dataset. Will \" + \"re-order the remaining attributes \"+ \"if invert matching sense is turned \"+ \"on and the attribute column indices \"+ \"are not specified in ascending order.\";\n}\n", "docstring": "returns a string describing this filter", "partition": "test"}
{"idx": "3865", "code": "public static <T>Stream<T> concat(Stream<? extends T> a,Stream<? extends T> b){\n  Objects.requireNonNull(a);\n  Objects.requireNonNull(b);\n  @SuppressWarnings(\"unchecked\") Spliterator<T> split=new Streams.ConcatSpliterator.OfRef<>((Spliterator<T>)a.spliterator(),(Spliterator<T>)b.spliterator());\n  Stream<T> stream=StreamSupport.stream(split,a.isParallel() || b.isParallel());\n  return stream.onClose(Streams.composedClose(a,b));\n}\n", "docstring": "creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream . the resulting stream is ordered if both of the input streams are ordered , and parallel if either of the input streams is parallel . when the resulting stream is closed , the close handlers for both input streams are invoked .", "partition": "test"}
{"idx": "3866", "code": "@Ignore @Test public void test_DR_PGS_4NODES_2NODESDOWN_Validate_Receiver() throws Exception {\n  Integer lnPort=(Integer)vm0.invoke(null);\n  Integer nyPort=(Integer)vm1.invoke(null);\n  createCacheInVMs(nyPort,vm2,vm3);\n  createReceiverInVMs(vm2,vm3);\n  createCacheInVMs(lnPort,vm4,vm5,vm6,vm7);\n  vm4.invoke(null);\n  vm5.invoke(null);\n  vm6.invoke(null);\n  vm7.invoke(null);\n  vm4.invoke(null);\n  vm5.invoke(null);\n  vm6.invoke(null);\n  vm7.invoke(null);\n  startSenderInVMs(\"ln\",vm4,vm5,vm6,vm7);\n  vm2.invoke(null);\n  vm3.invoke(null);\n  vm4.invoke(null);\n  vm5.invoke(null);\n  vm6.invoke(null);\n  vm7.invoke(null);\n  Thread.sleep(60000);\n{\n    AsyncInvocation inv1=vm7.invokeAsync(null);\n    Thread.sleep(1000);\n    AsyncInvocation inv2=vm4.invokeAsync(null);\n    Thread.sleep(2000);\n    AsyncInvocation inv3=vm6.invokeAsync(null);\n    Thread.sleep(1500);\n    AsyncInvocation inv4=vm5.invokeAsync(null);\n    try {\n      inv1.join();\n      inv2.join();\n      inv3.join();\n      inv4.join();\n    }\n catch (    Exception e) {\n      Assert.fail(\"UnExpected Exception\",e);\n    }\n  }\n  vm6.invoke(null);\n  vm7.invoke(null);\n  vm2.invoke(null);\n}\n", "docstring": "below test is disabled intentionally 1 > in this release 8 . 0 , for rolling upgrade support queue name is changed to old style 2 > common parallel sender for different non colocated regions is not supported in 8 . 0 so no need to bother about parallelgatewaysenderqueue # convertpathtoname 3 > we have to enabled it in next release 4 > version based rolling upgrade support should be provided . based on the version of the gemfire qstring should be used between 8 . 0 and version prior to 8 . 0", "partition": "test"}
{"idx": "3867", "code": "@Override public char next(){\n  ++docPos;\n  if (docPos < segmentEnd || segmentEnd >= doc.getLength()) {\n    return text.next();\n  }\n  try {\n    doc.getText(segmentEnd,doc.getLength() - segmentEnd,text);\n  }\n catch (  BadLocationException e) {\n    throw new RuntimeException(e);\n  }\n  segmentEnd+=text.count;\n  return text.current();\n}\n", "docstring": "increments the iterator \"'\" s index by one and returns the character at the new index .", "partition": "test"}
{"idx": "3868", "code": "private void adjustRowHeights(JTable table){\n  for (int row=0; row < table.getRowCount(); row++) {\n    int rowHeight=table.getRowHeight();\n    for (int column=0; column < table.getColumnCount(); column++) {\n      Component comp=table.prepareRenderer(table.getCellRenderer(row,column),row,column);\n      rowHeight=Math.max(rowHeight,comp.getPreferredSize().height);\n    }\n    table.setRowHeight(row,rowHeight);\n  }\n}\n", "docstring": "adjust the row heights of a table based on the table contents .", "partition": "test"}
{"idx": "3869", "code": "public List<URI> volumeURIs(List<URI> uris,boolean delete,boolean remediate,ValCk... checks){\n  List<URI> remediatedURIs=new ArrayList<URI>();\n  List<Volume> volumes=dbClient.queryObject(Volume.class,uris);\n  List<Volume> remediatedVolumes=volumes(volumes,delete,remediate,checks);\n  for (  Volume volume : remediatedVolumes) {\n    remediatedURIs.add(volume.getId());\n  }\n  return remediatedURIs;\n}\n", "docstring": "validates a list of volumes", "partition": "test"}
{"idx": "3870", "code": "private FormatString[] parse(String s){\n  ArrayList<FormatString> al=new ArrayList<>();\n  Matcher m=fsPattern.matcher(s);\n  for (int i=0, len=s.length(); i < len; ) {\n    if (m.find(i)) {\n      if (m.start() != i) {\n        checkText(s,i,m.start());\n        al.add(new FixedString(s.substring(i,m.start())));\n      }\n      al.add(new FormatSpecifier(m));\n      i=m.end();\n    }\n else {\n      checkText(s,i,len);\n      al.add(new FixedString(s.substring(i)));\n      break;\n    }\n  }\n  return al.toArray(new FormatString[al.size()]);\n}\n", "docstring": "finds format specifiers in the format string .", "partition": "test"}
{"idx": "3871", "code": "private void updateIndexColumnButtons(){\n  indexRemoveButton.setEnabled(false);\n  indexUpButton.setEnabled(false);\n  indexDownButton.setEnabled(false);\n  int index=selectedColumns.getSelectionIndex();\n  if (index >= 0) {\n    indexRemoveButton.setEnabled(true);\n    if (index > 0) {\n      indexUpButton.setEnabled(true);\n    }\n else     if (index < selectedColumns.getItemCount() - 1) {\n      indexDownButton.setEnabled(true);\n    }\n  }\n}\n", "docstring": "updates status of index column up / down buttons .", "partition": "test"}
{"idx": "3872", "code": "public String urlForPOISearch(String tag,BoundingBox bb,int limit,int timeout){\n  StringBuilder s=new StringBuilder();\n  s.append(mService + \"?data=\");\n  String sBB=\"(\" + bb.getLatSouth() + \",\"+ bb.getLonWest()+ \",\"+ bb.getLatNorth()+ \",\"+ bb.getLonEast()+ \")\";\n  String data=\"[out:json][timeout:\" + timeout + \"];(\"+ \"node[\"+ tag+ \"]\"+ sBB+ \";\"+ \"way[\"+ tag+ \"]\"+ sBB+ \";\"+ \"relation[\"+ tag+ \"]\"+ sBB+ \";\"+ \");out qt center \"+ limit+ \" tags;\";\n  Log.d(BonusPackHelper.LOG_TAG,\"data=\" + data);\n  s.append(URLEncoder.encode(data));\n  return s.toString();\n}\n", "docstring": "build the url to search for elements having a specific osm tag ( key = value ) , within a bounding box . elements will be osm nodes , ways and relations . ways and relations will have no geometry , only their center . < br > usage : urlforpoisearch ( \" amenity = cinema \" , map . getboundingbox ( ) , 200 , 30 ) ; < br >", "partition": "test"}
{"idx": "3873", "code": "public void waitForDecodingToFinish(){\n  while (isDecoding) {\n    try {\n      Thread.sleep(100);\n    }\n catch (    final InterruptedException e) {\n      LogWriter.writeLog(\"Exception: \" + e.getMessage());\n      isDecoding=false;\n    }\n  }\n}\n", "docstring": "wait for decoding to finish", "partition": "test"}
{"idx": "3874", "code": "private static String wikiToPlainText(String content){\n  content=content.replaceAll(\"\\\\[\\\\[[iI]mage:[^\\\\]]*\\\\]\\\\]\",\"\");\n  content=content.replaceAll(\"(?s)<!--.*?-->\",\"\");\n  content=content.replaceAll(\"(?s)<ref>.*?</ref>\",\"\");\n  content=content.replaceAll(\"(?s)\\\\{\\\\{([^{}]*?\\\\{\\\\{[^{}]*?\\\\}\\\\})+[^{}].*?\\\\}\\\\}\",\"\");\n  content=content.replaceAll(\"(?s)\\\\{\\\\{.*?\\\\}\\\\}\",\"\");\n  content=content.replaceAll(\"(?s)\\\\{\\\\|.*?\\\\|\\\\}\",\"\");\n  content=content.replaceAll(\"\\\\[\\\\[[^\\\\]]*\\\\|\",\"\");\n  content=content.replaceAll(\"\\\\[\\\\[\",\"\");\n  content=content.replaceAll(\"\\\\]\\\\]\",\"\");\n  content=content.replaceAll(\"(?s)<.*?>\",\"\");\n  content=content.trim();\n  final int size=content.length();\n  int endOfFirstParagraph=content.indexOf(\"\\n\",50);\n  if (endOfFirstParagraph < 0) {\n    endOfFirstParagraph=size;\n  }\n  content=content.substring(0,Math.min(endOfFirstParagraph,1024));\n  return content;\n}\n", "docstring": "extract plain text from wikipedia article content .", "partition": "test"}
{"idx": "3875", "code": "private static int createPackedParams(SunGraphics2D sg2d,GlyphList gl){\n  return (((gl.usePositions() ? 1 : 0) << OFFSET_POSITIONS) | ((gl.isSubPixPos() ? 1 : 0) << OFFSET_SUBPIXPOS) | ((gl.isRGBOrder() ? 1 : 0) << OFFSET_RGBORDER)| ((sg2d.lcdTextContrast & 0xff) << OFFSET_CONTRAST));\n}\n", "docstring": "packs the given parameters into a single int value in order to save space on the rendering queue . note that most of these parameters are only used for rendering lcd - optimized text , but conditionalizing this work wouldn \"'\" t make any impact on performance , so we will pack those parameters even in the non - lcd case .", "partition": "test"}
{"idx": "3876", "code": "public static int update(String sql,Object[] args){\n  Connection c=null;\n  PreparedStatement p=null;\n  try {\n    c=getConnection();\n    if (c == null)     return -1;\n    p=c.prepareStatement(sql);\n    int order=1;\n    if (args != null) {\n      for (int i=0; i < args.length; i++) {\n        Object o=args[i];\n        setParameter(p,order++,o);\n      }\n    }\n    return p.executeUpdate();\n  }\n catch (  Exception e) {\n    if (log.isErrorEnabled())     log.error(sql + toString(args),e);\n  }\n finally {\n    close(p,c);\n  }\n  return 0;\n}\n", "docstring": "update the data using the sql sentence .", "partition": "test"}
{"idx": "3877", "code": "public boolean isLockSubject(){\n  return true;\n}\n", "docstring": "if entryholder is used as lockobject ( for example in all_in_cache ) - its the lock subject itself", "partition": "test"}
{"idx": "3878", "code": "@Override public int hashCode(){\n  int code=0;\n  if (fPublicId != null) {\n    code+=fPublicId.hashCode();\n  }\n  if (fLiteralSystemId != null) {\n    code+=fLiteralSystemId.hashCode();\n  }\n  if (fBaseSystemId != null) {\n    code+=fBaseSystemId.hashCode();\n  }\n  if (fExpandedSystemId != null) {\n    code+=fExpandedSystemId.hashCode();\n  }\n  if (fNamespace != null) {\n    code+=fNamespace.hashCode();\n  }\n  return code;\n}\n", "docstring": "returns a hash code for this object .", "partition": "test"}
{"idx": "3879", "code": "public QuickActionView addAction(Action action){\n  checkShown();\n  mActions.add(action);\n  return this;\n}\n", "docstring": "adds an action to the quickactionview", "partition": "test"}
{"idx": "3880", "code": "protected boolean display(File helpFile) throws HelpException {\n  if (helpFile.exists()) {\n    loadAndWrite(helpFile);\n    return true;\n  }\n else {\n    File notFound=new File(helpDir,NOT_FOUND);\n    if (notFound.exists())     loadAndWrite(notFound);\n else     throw new HelpException(\"Topic not found, try \'help\' for more information\");\n    return false;\n  }\n}\n", "docstring": "displays the requested help file if it is found . if not , we first try to display the default not found message . if that is not available , we display a default message .", "partition": "test"}
{"idx": "3881", "code": "public Point2D either(){\n  return best1;\n}\n", "docstring": "returns one of the points in the closest pair of points .", "partition": "test"}
{"idx": "3882", "code": "private static void removeTable(Connection conn,String name) throws SQLException {\n  name=name.replace(\'.\',\'_\');\n  Statement stat=conn.createStatement();\n  stat.execute(\"DROP TABLE \" + name);\n  DBUtil.commitEL(conn);\n}\n", "docstring": "remove a table from the memory database", "partition": "test"}
{"idx": "3883", "code": "public boolean containsCategory(String category){\n  return !hiddenBugCategorySet.contains(category);\n}\n", "docstring": "returns false if the given category is hidden in the project filter settings .", "partition": "test"}
{"idx": "3884", "code": "public static boolean isVolumeFullCopySource(Volume volume,DbClient dbClient){\n  boolean isFullCopySource=false;\n  StringSet fullCopyIds=volume.getFullCopies();\n  if ((fullCopyIds != null) && (!fullCopyIds.isEmpty())) {\n    Iterator<String> fullCopyIdsIter=fullCopyIds.iterator();\n    while (fullCopyIdsIter.hasNext()) {\n      URI fullCopyURI=URI.create(fullCopyIdsIter.next());\n      Volume fullCopyVolume=dbClient.queryObject(Volume.class,fullCopyURI);\n      if ((fullCopyVolume != null) && (!fullCopyVolume.getInactive())) {\n        isFullCopySource=true;\n      }\n    }\n  }\n  return isFullCopySource;\n}\n", "docstring": "determine if the passed volume is a source volume for any full copies .", "partition": "test"}
{"idx": "3885", "code": "@Override public void assertEquals(String message,Object expectedObj,Object actualObj){\n  LinearRegressionModel expected=(LinearRegressionModel)expectedObj;\n  LinearRegressionModel actual=(LinearRegressionModel)actualObj;\n  message=message + \" - Linear Regression Model \\\"\" + actual.getSource()+ \"\\\" does not match the expected Model\";\n  Assert.assertArrayEquals(message + \" : coefficients are not equal\",expected.getCoefficients(),actual.getCoefficients(),1E-15);\n  Assert.assertArrayEquals(message + \" : probabilities are not equal\",expected.getProbabilities(),actual.getProbabilities(),1E-15);\n  Assert.assertArrayEquals(message + \" : selected attributes are not equal\",expected.getSelectedAttributeNames(),actual.getSelectedAttributeNames());\n  Assert.assertArrayEquals(message + \" : selected attributes are not equal\",expected.getSelectedAttributes(),actual.getSelectedAttributes());\n  Assert.assertArrayEquals(message + \" : standard errors are not equal\",expected.getStandardErrors(),actual.getStandardErrors(),1E-15);\n  Assert.assertArrayEquals(message + \" : standardized coefficients are not equal\",expected.getStandardizedCoefficients(),actual.getStandardizedCoefficients(),1E-15);\n  Assert.assertArrayEquals(message + \" : tolerances are not equal\",expected.getTolerances(),actual.getTolerances(),1E-15);\n  Assert.assertArrayEquals(message + \" : t statistics are not equal\",expected.getTStats(),actual.getTStats(),1E-15);\n}\n", "docstring": "tests two linearregression models by comparing all values", "partition": "test"}
{"idx": "3886", "code": "public void testQuorumSucceed(){\n  quorum.succeed();\n  quorum.fail();\n  assertEquals(callbackResult.get(),0);\n  quorum.fail();\n  quorum.succeed();\n  assertEquals(callbackResult.get(),1);\n}\n", "docstring": "tests a successful quorum .", "partition": "test"}
{"idx": "3887", "code": "public void requestAfterExplanation(@NonNull String[] permissions){\n  ArrayList<String> permissionsToRequest=new ArrayList<>();\n  for (  String permissionName : permissions) {\n    if (isPermissionDeclined(permissionName)) {\n      permissionsToRequest.add(permissionName);\n    }\n else {\n      permissionCallback.onPermissionPreGranted(permissionName);\n    }\n  }\n  if (permissionsToRequest.isEmpty())   return;\n  permissions=permissionsToRequest.toArray(new String[permissionsToRequest.size()]);\n  context.requestPermissions(permissions,REQUEST_PERMISSIONS);\n}\n", "docstring": "to be called when explanation is presented to the user", "partition": "test"}
{"idx": "3888", "code": "static void pauseThread(long duration){\n  try {\n    Thread.sleep(duration);\n  }\n catch (  Exception e) {\n    s_logger.warn(\"Exception while trying to sleep\",e);\n  }\n}\n", "docstring": "simple puts the thread to sleep for the passed duration .", "partition": "test"}
{"idx": "3889", "code": "final public void println(String v){\n  try {\n    _out.println(v);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "writes a string followed by a newline .", "partition": "test"}
{"idx": "3890", "code": "public int read(char cbuf[],int offset,int length) throws IOException {\n  return sd.read(cbuf,offset,length);\n}\n", "docstring": "reads characters into a portion of an array .", "partition": "test"}
{"idx": "3891", "code": "public int read() throws IOException {\n  int val;\n  if ((val=is.read()) < 0) {\n    return -1;\n  }\nswitch (val & 0xf0) {\ncase 0xc0:\ncase 0xd0:\n    val=((val & 0x1f) << 6) | (is.read() & 0x3f);\n  break;\ncase 0xe0:\nval=((val & 0x0f) << 12) | ((is.read() & 0x3f) << 6) | (is.read() & 0x3f);\nbreak;\ncase 0xf0:\nthrow new UnsupportedEncodingException();\ndefault :\nbreak;\n}\nreturn val;\n}\n", "docstring": "reads a single character .", "partition": "test"}
{"idx": "3892", "code": "private static boolean CallNonvirtualBooleanMethodV(JNIEnvironment env,int objJREF,int classJREF,int methodID,Address argAddress) throws Exception {\n  if (traceJNI)   VM.sysWrite(\"JNI called: CallNonvirtualBooleanMethodV  \\n\");\n  RuntimeEntrypoints.checkJNICountDownToGC();\n  try {\n    Object obj=env.getJNIRef(objJREF);\n    Object returnObj=JNIHelpers.invokeWithVarArg(obj,methodID,argAddress,TypeReference.Boolean,true);\n    return Reflection.unwrapBoolean(returnObj);\n  }\n catch (  Throwable unexpected) {\n    if (traceJNI)     unexpected.printStackTrace(System.err);\n    env.recordException(unexpected);\n    return false;\n  }\n}\n", "docstring": "callnonvirtualbooleanmethodv : invoke a virtual method that returns a boolean value", "partition": "test"}
{"idx": "3893", "code": "private boolean rContainsRMInstruction(ProgramBlock pb,String varName){\n  if (pb instanceof WhileProgramBlock) {\n    WhileProgramBlock tmp=(WhileProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocks())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof IfProgramBlock) {\n    IfProgramBlock tmp=(IfProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocksIfBody())     if (rContainsRMInstruction(c,varName))     return true;\n    for (    ProgramBlock c : tmp.getChildBlocksElseBody())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof ForProgramBlock) {\n    ForProgramBlock tmp=(ForProgramBlock)pb;\n    for (    ProgramBlock c : tmp.getChildBlocks())     if (rContainsRMInstruction(c,varName))     return true;\n  }\n else   if (pb instanceof FunctionProgramBlock) {\n  }\n else {\n    for (    Instruction inst : pb.getInstructions()) {\n      String instStr=inst.toString();\n      if (instStr.contains(\"rmfilevar\" + Lop.OPERAND_DELIMITOR + varName) || instStr.contains(\"rmvar\" + Lop.OPERAND_DELIMITOR + varName)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "determines if the given program block includes a rmvar or rmfilevar instruction for the given varname .", "partition": "test"}
{"idx": "3894", "code": "public ProjectImporter(final File rootFolder){\n  assertNotNull(\"Root folder cannot be null.\",rootFolder);\n  assertTrue(\"Root folder does not exist: \" + rootFolder,rootFolder.exists());\n  assertTrue(\"Root folder must be a folder. But was a file: \" + rootFolder,rootFolder.isDirectory());\n  assertTrue(\"Root folder directory content cannot be read: \" + rootFolder,rootFolder.canRead());\n  assertTrue(\"No files were found in the directory: \" + rootFolder,null != rootFolder.listFiles());\n  this.rootFolder=rootFolder;\n}\n", "docstring": "creates a project importer with the root folder of all projects that has to be imported for the test .", "partition": "test"}
{"idx": "3895", "code": "public void testDoubles() throws Exception {\n  double[] values=new double[]{Double.NEGATIVE_INFINITY,-2.3E25,-1.0E15,-1.0,-1.0E-1,-1.0E-2,-0.0,+0.0,1.0E-2,1.0E-1,1.0,1.0E15,2.3E25,Double.POSITIVE_INFINITY,Double.NaN};\n  long[] encoded=new long[values.length];\n  for (int i=0; i < values.length; i++) {\n    encoded[i]=NumericUtils.doubleToSortableLong(values[i]);\n    assertTrue(\"forward and back conversion should generate same double\",Double.compare(values[i],NumericUtils.sortableLongToDouble(encoded[i])) == 0);\n  }\n  for (int i=1; i < encoded.length; i++) {\n    assertTrue(\"check sort order\",encoded[i - 1] < encoded[i]);\n  }\n}\n", "docstring": "check various sorted values of doubles ( including extreme values ) check for correct ordering of the encoded bytes and that values round - trip .", "partition": "test"}
{"idx": "3896", "code": "public static boolean isRegistered(Class<?> clazz){\n  return regModules.containsKey(clazz.getName());\n}\n", "docstring": "has this class already been registered .", "partition": "test"}
{"idx": "3897", "code": "private static Pair<String,String> offsetASR(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2,final String immediateNodeValue){\n  final String address=environment.getNextVariableString();\n  final String index=environment.getNextVariableString();\n  final String tmpVar=environment.getNextVariableString();\n  long baseOffset=offset;\n  if (immediateNodeValue.equals(\"0\")) {\n    final String isZeroCondition=environment.getNextVariableString();\n    final String tmpVar1=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dw,registerNodeValue2,wd,String.valueOf(-31),dw,tmpVar1));\n    instructions.add(ReilHelpers.createBisz(baseOffset++,dw,tmpVar1,bt,isZeroCondition));\n    instructions.add(ReilHelpers.createSub(baseOffset++,dw,String.valueOf(0x0L),bt,isZeroCondition,dw,index));\n  }\n else {\n    final String tmpVar1=environment.getNextVariableString();\n    final String tmpVar2=environment.getNextVariableString();\n    final String tmpVar3=environment.getNextVariableString();\n    final String tmpVar4=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue2,dw,String.valueOf(0x80000000L),dw,tmpVar1));\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dw,tmpVar1,dw,\"-\" + immediateNodeValue,dw,tmpVar2));\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dw,String.valueOf(0x80000000L),dw,\"-\" + immediateNodeValue,dw,tmpVar3));\n    instructions.add(ReilHelpers.createSub(baseOffset++,dw,tmpVar2,dw,tmpVar3,qw,tmpVar4));\n    instructions.add(ReilHelpers.createAnd(baseOffset++,qw,tmpVar4,dw,dWordBitMask,dw,index));\n  }\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue1,dw,index,dw,tmpVar));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dw,tmpVar,dw,dWordBitMask,dw,address));\n  return new Pair<String,String>(address,registerNodeValue1);\n}\n", "docstring": "operation : [ < rn > , + / - < rm > , asr # < shift_imm > ", "partition": "test"}
{"idx": "3898", "code": "public Class<?> loadClass(String name) throws ClassNotFoundException {\n  return Class.forName(name);\n}\n", "docstring": "return the class with the given name .", "partition": "test"}
{"idx": "3899", "code": "public void waitForOperations(){\n  operator.waitForOperations();\n}\n", "docstring": "wait for the bucket operator to complete any pending asynchronous operations .", "partition": "test"}
{"idx": "3900", "code": "protected boolean isAllTestComponentsInTarget(Geometry testGeom){\n  List coords=ComponentCoordinateExtracter.getCoordinates(testGeom);\n  for (Iterator i=coords.iterator(); i.hasNext(); ) {\n    Coordinate p=(Coordinate)i.next();\n    int loc=targetPointLocator.locate(p);\n    if (loc == Location.EXTERIOR)     return false;\n  }\n  return true;\n}\n", "docstring": "tests whether all components of the test geometry are contained in the target geometry . handles both linear and point components .", "partition": "test"}
{"idx": "3901", "code": "private Object createInner(SimpleObject post,RequestContext context) throws ResponseException {\n  try {\n    String xml=completeXform(convertUuidsToIds(post));\n    File file=File.createTempFile(\"projectbuendia\",null);\n    processor.processXForm(xml,file.getAbsolutePath(),true,context.getRequest());\n  }\n catch (  IOException e) {\n    throw new GenericRestException(\"Error storing xform data\",e);\n  }\ncatch (  ResponseException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new ConversionException(\"Error processing xform data\",e);\n  }\n  Encounter encounter=guessEncounterFromXformSubmission(post);\n  if (encounter == null) {\n    return post;\n  }\n  SimpleObject returnJson=new SimpleObject();\n  EncounterResource.populateJsonProperties(encounter,returnJson);\n  return returnJson;\n}\n", "docstring": "accepts a submitted form instance .", "partition": "test"}
{"idx": "3902", "code": "public Endpoint(URI endpointUrl,SecurityMode... modes){\n  if (modes == null || endpointUrl == null)   throw new IllegalArgumentException(\"null arg\");\n  for (  SecurityMode m : modes) {\n    if (m == null)     throw new IllegalArgumentException(\"null arg\");\n    hash=13 * hash + m.hashCode();\n  }\n  this.endpointUrl=endpointUrl.toString();\n  this.modes=modes;\n  this.endpointConfiguration=EndpointConfiguration.defaults();\n  hash=13 * hash + endpointUrl.hashCode();\n}\n", "docstring": "create a new endpoint .", "partition": "test"}
{"idx": "3903", "code": "protected Value parseValue() throws IOException, RDFParseException, RDFHandlerException {\n  int c=peekCodePoint();\n  if (c == \'<\') {\n    return parseURI();\n  }\n else   if (c == \':\' || TurtleUtil.isPrefixStartChar(c)) {\n    return parseQNameOrBoolean();\n  }\n else   if (c == \'_\') {\n    return parseNodeID();\n  }\n else   if (c == \'\"\' || c == \'\\\'\') {\n    return parseQuotedLiteral();\n  }\n else   if (ASCIIUtil.isNumber(c) || c == \'.\' || c == \'+\' || c == \'-\') {\n    return parseNumber();\n  }\n else   if (c == -1) {\n    throwEOFException();\n    return null;\n  }\n else {\n    reportFatalError(\"Expected an RDF value here, found \'\" + new String(Character.toChars(c)) + \"\'\");\n    return null;\n  }\n}\n", "docstring": "parses an rdf value . this method parses uriref , qname , node id , quoted literal , integer , double and boolean .", "partition": "test"}
{"idx": "3904", "code": "public TimeSeriesCollection(){\n  this(null,TimeZone.getDefault());\n}\n", "docstring": "constructs an empty dataset , tied to the default timezone .", "partition": "test"}
{"idx": "3905", "code": "public static <E>List<E> of(E e1,E e2,E e3){\n  List<E> list=new ArrayList<>();\n  list.add(e1);\n  list.add(e2);\n  list.add(e3);\n  return list;\n}\n", "docstring": "returns a list of the given elements , in order .", "partition": "test"}
{"idx": "3906", "code": "@Override public void addAttribute(String name,float value){\n  String str=Float.toString(value);\n  if (str.endsWith(\".0\"))   str=str.substring(0,str.length() - 2);\n  current.setAttribute(name,str);\n}\n", "docstring": "adds an attribute to current element of the dom document .", "partition": "test"}
{"idx": "3907", "code": "@RequestMapping(value=\"/container/{containerId}/application/{applicationName}\",method=RequestMethod.POST) @ResponseBody public JsonResponse createDirectory(@PathVariable final String containerId,@PathVariable final String applicationName,@RequestParam(\"path\") String path) throws ServiceException, CheckException, IOException {\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"containerId:\" + containerId);\n    logger.debug(\"applicationName:\" + applicationName);\n    logger.debug(\"path:\" + path);\n  }\n  fileService.createDirectory(applicationName,containerId,path);\n  return new HttpOk();\n}\n", "docstring": "create resources ( files and folders ) into a container for a path", "partition": "test"}
{"idx": "3908", "code": "public void fill_ellipse_arr(PlaEllipse[] p_ellipse_arr,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  if (p_ellipse_arr.length <= 0)   return;\n  GeneralPath draw_path=new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n  for (  PlaEllipse curr_ellipse : p_ellipse_arr) {\n    Point2D center=coordinate_transform.board_to_screen(curr_ellipse.center);\n    double bigger_radius=coordinate_transform.board_to_screen(curr_ellipse.bigger_radius);\n    if (!point_near_rectangle(center.getX(),center.getY(),(Rectangle)p_g.getClip(),bigger_radius)) {\n      continue;\n    }\n    double smaller_radius=coordinate_transform.board_to_screen(curr_ellipse.smaller_radius);\n    Ellipse2D draw_ellipse=new Ellipse2D.Double(center.getX() - bigger_radius,center.getY() - smaller_radius,2 * bigger_radius,2 * smaller_radius);\n    double rotation=coordinate_transform.board_to_screen_angle(curr_ellipse.rotation);\n    AffineTransform affine_transform=new AffineTransform();\n    affine_transform.rotate(rotation,center.getX(),center.getY());\n    Shape rotated_ellipse=affine_transform.createTransformedShape(draw_ellipse);\n    draw_path.append(rotated_ellipse,false);\n  }\n  Graphics2D g2=(Graphics2D)p_g;\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_path);\n}\n", "docstring": "draws the interiour of an array of ellipses . ellipses contained in an other ellipse are treated as holes .", "partition": "test"}
{"idx": "3909", "code": "@Override public void zoomDomainAxes(double factor,PlotRenderingInfo state,Point2D source){\n}\n", "docstring": "multiplies the range on the domain axis / axes by the specified factor .", "partition": "test"}
{"idx": "3910", "code": "private void refreshChallengeCounts(){\n  mDueChallengeCounts=mDueChallengeLogic.getDueChallengeCounts(mCategories);\n}\n", "docstring": "reloads the due challenge counts from the database .", "partition": "test"}
{"idx": "3911", "code": "public Identity(final int dim){\n  this(dim,EnumSet.noneOf(Address.Flags.class));\n}\n", "docstring": "creates an identity matrix", "partition": "test"}
{"idx": "3912", "code": "private ImageData awtToSwt(final BufferedImage bufferedImage,final int width,final int height){\n  final int[] awtPixels=new int[width * height];\n  final ImageData swtImageData=new ImageData(width,height,24,PALETTE_DATA);\n  swtImageData.transparentPixel=TRANSPARENT_COLOR;\n  final int step=swtImageData.depth / 8;\n  final byte[] data=swtImageData.data;\n  bufferedImage.getRGB(0,0,width,height,awtPixels,0,width);\n  for (int i=0; i < height; i++) {\n    int idx=(0 + i) * swtImageData.bytesPerLine + 0 * step;\n    for (int j=0; j < width; j++) {\n      final int rgb=awtPixels[j + i * width];\n      for (int k=swtImageData.depth - 8; k >= 0; k-=8) {\n        data[idx++]=(byte)(rgb >> k & 0xFF);\n      }\n    }\n  }\n  return swtImageData;\n}\n", "docstring": "transform a java2d bufferedimage to a swt image .", "partition": "test"}
{"idx": "3913", "code": "public static boolean isUnlimitedStrengthPolicyAvailable(){\n  try {\n    return Cipher.getMaxAllowedKeyLength(\"AES\") >= 256;\n  }\n catch (  final NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return false;\n}\n", "docstring": "helper method to check whether the jvm has the unlimited strength policy installed", "partition": "test"}
{"idx": "3914", "code": "private void fillStackTrace(StringBuffer buffer,StackTraceElement[] elements){\n  for (int index=0; index < elements.length; index++) {\n    buffer.append(elements[index]);\n    buffer.append(\"\\n\");\n  }\n}\n", "docstring": "creates a printing stacktrace from the given elements .", "partition": "test"}
{"idx": "3915", "code": "public static boolean isFileTypeSupported(int fileType){\n  List providers=getMidiFileWriters();\n  for (int i=0; i < providers.size(); i++) {\n    MidiFileWriter writer=(MidiFileWriter)providers.get(i);\n    if (writer.isFileTypeSupported(fileType)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "indicates whether file writing support for the specified midi file type is provided by the system .", "partition": "test"}
{"idx": "3916", "code": "public void modify(SSOToken token,String objName,ModificationItem[] mods) throws SMSException, SSOException {\n  if ((objName == null) || (objName.length() == 0) || (mods == null)|| (mods.length == 0)) {\n    throw new IllegalArgumentException(\"SMSFlatFileObject.modify: \" + \"One or more arguments is null or empty\");\n  }\n  String objKey=objName.toLowerCase();\n  String filepath=null;\n  mRWLock.readRequest();\n  try {\n    filepath=mNameMap.getProperty(objKey);\n    if (filepath == null) {\n      String errmsg=\"SMSFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n  }\n  finally {\n    mRWLock.readDone();\n  }\n  mRWLock.writeRequest();\n  try {\n    filepath=mNameMap.getProperty(objKey);\n    if (filepath == null) {\n      String errmsg=\"SMSFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    File filehandle=new File(filepath);\n    if (!filehandle.isFile()) {\n      String errmsg=\"SMSFlatFileObject.modify: Attributes file for object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    Properties props=loadProperties(filehandle,objName);\n    boolean hasSunXmlKeyValue=(props.getProperty(SMSEntry.ATTR_XML_KEYVAL) == null) ? false : true;\n    for (int i=0; i < mods.length; i++) {\n      modifyValues(objName,mods[i],props);\n    }\n    saveProperties(props,filehandle,objName);\n    if (!hasSunXmlKeyValue) {\n      hasSunXmlKeyValue=(props.getProperty(SMSEntry.ATTR_XML_KEYVAL) == null) ? false : true;\n    }\n    if (hasSunXmlKeyValue) {\n      deleteSunXmlKeyValFiles(filehandle.getParentFile());\n      Set xmlKeyVals=toValSet(SMSEntry.ATTR_XML_KEYVAL,props.getProperty(SMSEntry.ATTR_XML_KEYVAL));\n      createSunXmlKeyValFiles(filehandle.getParentFile(),xmlKeyVals);\n    }\n  }\n  finally {\n    mRWLock.writeDone();\n  }\n}\n", "docstring": "modify the attributes for the given configuration object .", "partition": "test"}
{"idx": "3917", "code": "private AMSetupDSConfig(){\n  Map map=ServicesDefaultValues.getDefaultValues();\n  dsManager=(String)map.get(SetupConstants.CONFIG_VAR_DS_MGR_DN);\n  suffix=(String)map.get(SetupConstants.CONFIG_VAR_ROOT_SUFFIX);\n  dsHostName=(String)map.get(SetupConstants.CONFIG_VAR_DIRECTORY_SERVER_HOST);\n  dsPort=(String)map.get(SetupConstants.CONFIG_VAR_DIRECTORY_SERVER_PORT);\n  dsAdminPwd=(String)map.get(SetupConstants.CONFIG_VAR_DS_MGR_PWD);\n  basedir=(String)map.get(SetupConstants.CONFIG_VAR_BASE_DIR);\n  deployuri=(String)map.get(SetupConstants.CONFIG_VAR_SERVER_URI);\n}\n", "docstring": "constructs a new instance .", "partition": "test"}
{"idx": "3918", "code": "private void makeItems(int fingerPosition,List<View> viewList){\n  if (fingerPosition >= viewList.size()) {\n    return;\n  }\n  for (int i=0; i < viewList.size(); i++) {\n    int translationY=Math.min(Math.max(Math.abs(fingerPosition - i) * intervalHeight,10),maxTranslationHeight);\n    updateItemHeightAnimator(viewList.get(i),translationY);\n  }\n}\n", "docstring": "calculates every icon \"'\" s height needed and start animation", "partition": "test"}
{"idx": "3919", "code": "private boolean pathIsWindows(String path){\n  if (path != null && path.length() > 1) {\n    return (Character.isLetter(path.charAt(0)) && path.charAt(1) == \':\') || (path.startsWith(\"//\") || path.startsWith(\"\\\\\\\\\"));\n  }\n  return false;\n}\n", "docstring": "returns true if the path is on windows .", "partition": "test"}
{"idx": "3920", "code": "public boolean isSegmentBalanced(){\n  if (m_lines.size() == 0 || m_doc.isMultiCurrency())   return true;\n  MAcctSchemaElement[] elements=m_acctSchema.getAcctSchemaElements();\n  for (int i=0; i < elements.length; i++) {\n    MAcctSchemaElement ase=elements[i];\n    if (ase.isBalanced() && !isSegmentBalanced(ase.getElementType()))     return false;\n  }\n  return true;\n}\n", "docstring": "are all segments balanced", "partition": "test"}
{"idx": "3921", "code": "Attributes parseAttributes() throws JasperException {\n  AttributesImpl attrs=new AttributesImpl();\n  reader.skipSpaces();\n  while (parseAttribute(attrs))   reader.skipSpaces();\n  return attrs;\n}\n", "docstring": "attributes : : = ( s attribute ) * s ?", "partition": "test"}
{"idx": "3922", "code": "public static byte[] readBinaryFile(File sourceFile){\n  byte[] result=null;\n  try {\n    BufferedInputStream input;\n    input=new BufferedInputStream(new FileInputStream(sourceFile));\n    int num=input.available();\n    result=new byte[num];\n    input.read(result,0,num);\n    input.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    result=null;\n  }\n  return result;\n}\n", "docstring": "reads a binary input file into a byte array", "partition": "test"}
{"idx": "3923", "code": "@SuppressWarnings(\"rawtypes\") public void test_streamAPI(){\n  final List<IBindingSet> expectedSolutions=new ArrayList<IBindingSet>();\n{\n    final IBindingSet expected=new ListBindingSet();\n    expected.set(Var.var(\"x\"),new Constant<IV>(termId));\n    expectedSolutions.add(expected);\n  }\n{\n    final IBindingSet expected=new ListBindingSet();\n    expected.set(Var.var(\"x\"),new Constant<IV>(termId));\n    expected.set(Var.var(\"y\"),new Constant<IV>(blobIV));\n    expectedSolutions.add(expected);\n  }\n  doEncodeDecodeTest(expectedSolutions);\n}\n", "docstring": "unit test of the stream - oriented api .", "partition": "test"}
{"idx": "3924", "code": "public void addTerm(SplitCondition condition){\n  terms.add(condition);\n}\n", "docstring": "this method adds a condition to the conjunction in the rule \"'\" s head", "partition": "test"}
{"idx": "3925", "code": "public void removeIndexInterval(int index0,int index1){\n  int rmMinIndex=Math.min(index0,index1);\n  int rmMaxIndex=Math.max(index0,index1);\n  int gapLength=(rmMaxIndex - rmMinIndex) + 1;\n  for (int i=rmMinIndex; i <= maxIndex; i++) {\n    setState(i,value.get(i + gapLength));\n  }\n  int leadIndex=this.leadIndex;\n  if (leadIndex == 0 && rmMinIndex == 0) {\n  }\n else   if (leadIndex > rmMaxIndex) {\n    leadIndex=this.leadIndex - gapLength;\n  }\n else   if (leadIndex >= rmMinIndex) {\n    leadIndex=rmMinIndex - 1;\n  }\n  int anchorIndex=this.anchorIndex;\n  if (anchorIndex == 0 && rmMinIndex == 0) {\n  }\n else   if (anchorIndex > rmMaxIndex) {\n    anchorIndex=this.anchorIndex - gapLength;\n  }\n else   if (anchorIndex >= rmMinIndex) {\n    anchorIndex=rmMinIndex - 1;\n  }\n  if (leadIndex != this.leadIndex || anchorIndex != this.anchorIndex) {\n    updateLeadAnchorIndices(anchorIndex,leadIndex);\n  }\n  fireValueChanged();\n}\n", "docstring": "remove the indices in the interval index0 , index1 ( inclusive ) from the selection model . this is typically called to sync the selection model width a corresponding change in the data model . note that ( as always ) index0 need not be & lt ; = index1 .", "partition": "test"}
{"idx": "3926", "code": "public void rebuildEventList(boolean resetSelected){\n  if (logger.isLoggable(Level.FINE)) {\n    logger.fine(\"rebuilding list\");\n  }\n  allEvents=null;\n  activeEvents=null;\n  hideDetails();\n  initInterface(getActiveEvents(),resetSelected);\n  highlightCurrentEvent(currentTime);\n  firePropertyChange(ActiveEventsProperty,null,getActiveEvents());\n}\n", "docstring": "this is the method that rebuilds the list of visible events .", "partition": "test"}
{"idx": "3927", "code": "public DiskStoreFactory createDiskStoreFactory(){\n  return new DiskStoreFactoryImpl(this);\n}\n", "docstring": "create diskstore factory with default attributes", "partition": "test"}
{"idx": "3928", "code": "public static boolean deleteDirectorySubdirectories(String rootDirectory){\n  if ((rootDirectory == null)) {\n    return false;\n  }\n  boolean didSuccessfullyDeleteAllDirectories=true;\n  try {\n    List<File> files=getListOfFilesInADirectory(rootDirectory);\n    for (    File file : files) {\n      if (file.isDirectory()) {\n        boolean deleteSuccess=deleteDirectoryAndContents(file);\n        if (!deleteSuccess) {\n          logger.debug(\"Warning - failed to delete \" + file.getAbsolutePath());\n          didSuccessfullyDeleteAllDirectories=false;\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.debug(e.toString() + System.lineSeparator() + StackTrace.getStringFromStackTrace(e));\n    return false;\n  }\n  return didSuccessfullyDeleteAllDirectories;\n}\n", "docstring": "this is a quiet method . only deletes directories . will fail if the directories have files in them .", "partition": "test"}
{"idx": "3929", "code": "public void put(byte[] buffer,int offset,int count){\n  if (count > (bytes.length - this.contentLength)) {\n    throw new IllegalArgumentException(\"buffer is too large\");\n  }\n  System.arraycopy(buffer,offset,bytes,this.contentLength,count);\n  this.contentLength+=count;\n}\n", "docstring": "puts content from the specified byte array to this bytearray", "partition": "test"}
{"idx": "3930", "code": "private void markReserved(int ropReg,int category){\n  reservedRopRegs.set(ropReg,ropReg + category,true);\n}\n", "docstring": "marks a range of rop registers as \" reserved for a local variable . \"", "partition": "test"}
{"idx": "3931", "code": "public static void registerDefaultResolvers(){\nsynchronized (resolverList) {\n    resolverList.add(new ResourceResolver(new ResolverFragment()));\n    resolverList.add(new ResourceResolver(new ResolverLocalFilesystem()));\n    resolverList.add(new ResourceResolver(new ResolverXPointer()));\n    resolverList.add(new ResourceResolver(new ResolverDirectHTTP()));\n  }\n}\n", "docstring": "this method registers the default resolvers .", "partition": "test"}
{"idx": "3932", "code": "private boolean processAuthenticationResponse(final HttpMethod method){\n  LOG.trace(\"enter HttpMethodBase.processAuthenticationResponse(\" + \"HttpState, HttpConnection)\");\n  try {\nswitch (method.getStatusCode()) {\ncase HttpStatus.SC_UNAUTHORIZED:\n      return processWWWAuthChallenge(method);\ncase HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED:\n    return processProxyAuthChallenge(method);\ndefault :\n  return false;\n}\n}\n catch (Exception e) {\nif (LOG.isErrorEnabled()) {\nLOG.error(e.getMessage(),e);\n}\nreturn false;\n}\n}\n", "docstring": "processes a response that requires authentication", "partition": "test"}
{"idx": "3933", "code": "private void release(ByteArray byteArray){\nsynchronized (syncRoot) {\n    if (availableByteArrays.size() >= maxAvailableArraysCount) {\n      return;\n    }\n    if (!availableByteArrays.contains(byteArray)) {\n      availableByteArrays.add(byteArray);\n    }\n  }\n}\n", "docstring": "releases specified byte array", "partition": "test"}
{"idx": "3934", "code": "public Pipeline(){\n}\n", "docstring": "constructs an empty pipeline", "partition": "test"}
{"idx": "3935", "code": "@Override public void drawRangeMarker(Graphics2D g2,CategoryPlot plot,ValueAxis axis,Marker marker,Rectangle2D dataArea){\n  if (marker instanceof ValueMarker) {\n    ValueMarker vm=(ValueMarker)marker;\n    double value=vm.getValue();\n    Range range=axis.getRange();\n    if (!range.contains(value)) {\n      return;\n    }\n    final Composite savedComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    PlotOrientation orientation=plot.getOrientation();\n    double v=axis.valueToJava2D(value,dataArea,plot.getRangeAxisEdge());\n    Line2D line=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      line=new Line2D.Double(v,dataArea.getMinY(),v,dataArea.getMaxY());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      line=new Line2D.Double(dataArea.getMinX(),v,dataArea.getMaxX(),v);\n    }\n else {\n      throw new IllegalStateException();\n    }\n    g2.setPaint(marker.getPaint());\n    g2.setStroke(marker.getStroke());\n    g2.draw(line);\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coordinates=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,line.getBounds2D(),marker.getLabelOffset(),LengthAdjustmentType.EXPAND,anchor);\n      Rectangle2D rect=TextUtils.calcAlignedStringBounds(label,g2,(float)coordinates.getX(),(float)coordinates.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(rect);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtils.drawAlignedString(label,g2,(float)coordinates.getX(),(float)coordinates.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(savedComposite);\n  }\n else   if (marker instanceof IntervalMarker) {\n    IntervalMarker im=(IntervalMarker)marker;\n    double start=im.getStartValue();\n    double end=im.getEndValue();\n    Range range=axis.getRange();\n    if (!(range.intersects(start,end))) {\n      return;\n    }\n    final Composite savedComposite=g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,marker.getAlpha()));\n    double start2d=axis.valueToJava2D(start,dataArea,plot.getRangeAxisEdge());\n    double end2d=axis.valueToJava2D(end,dataArea,plot.getRangeAxisEdge());\n    double low=Math.min(start2d,end2d);\n    double high=Math.max(start2d,end2d);\n    PlotOrientation orientation=plot.getOrientation();\n    Rectangle2D rect=null;\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      low=Math.max(low,dataArea.getMinX());\n      high=Math.min(high,dataArea.getMaxX());\n      rect=new Rectangle2D.Double(low,dataArea.getMinY(),high - low,dataArea.getHeight());\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      low=Math.max(low,dataArea.getMinY());\n      high=Math.min(high,dataArea.getMaxY());\n      rect=new Rectangle2D.Double(dataArea.getMinX(),low,dataArea.getWidth(),high - low);\n    }\n    Paint p=marker.getPaint();\n    if (p instanceof GradientPaint) {\n      GradientPaint gp=(GradientPaint)p;\n      GradientPaintTransformer t=im.getGradientPaintTransformer();\n      if (t != null) {\n        gp=t.transform(gp,rect);\n      }\n      g2.setPaint(gp);\n    }\n else {\n      g2.setPaint(p);\n    }\n    g2.fill(rect);\n    if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n      if (orientation == PlotOrientation.VERTICAL) {\n        Line2D line=new Line2D.Double();\n        double x0=dataArea.getMinX();\n        double x1=dataArea.getMaxX();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(x0,start2d,x1,start2d);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(x0,end2d,x1,end2d);\n          g2.draw(line);\n        }\n      }\n else {\n        Line2D line=new Line2D.Double();\n        double y0=dataArea.getMinY();\n        double y1=dataArea.getMaxY();\n        g2.setPaint(im.getOutlinePaint());\n        g2.setStroke(im.getOutlineStroke());\n        if (range.contains(start)) {\n          line.setLine(start2d,y0,start2d,y1);\n          g2.draw(line);\n        }\n        if (range.contains(end)) {\n          line.setLine(end2d,y0,end2d,y1);\n          g2.draw(line);\n        }\n      }\n    }\n    String label=marker.getLabel();\n    RectangleAnchor anchor=marker.getLabelAnchor();\n    if (label != null) {\n      Font labelFont=marker.getLabelFont();\n      g2.setFont(labelFont);\n      Point2D coords=calculateRangeMarkerTextAnchorPoint(g2,orientation,dataArea,rect,marker.getLabelOffset(),marker.getLabelOffsetType(),anchor);\n      Rectangle2D r=TextUtils.calcAlignedStringBounds(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n      g2.setPaint(marker.getLabelBackgroundColor());\n      g2.fill(r);\n      g2.setPaint(marker.getLabelPaint());\n      TextUtilities.drawAlignedString(label,g2,(float)coords.getX(),(float)coords.getY(),marker.getLabelTextAnchor());\n    }\n    g2.setComposite(savedComposite);\n  }\n}\n", "docstring": "draws a marker for the range axis .", "partition": "test"}
{"idx": "3936", "code": "private void init(){\n  acceptableMethods=new ArrayList<>();\n  acceptableMethods.add(new NoAuthenticationRequiredMethod());\n  acceptableMethods.add(new GssApiMethod());\n  acceptableMethods.add(new UsernamePasswordMethod());\n}\n", "docstring": "constructs a socks5 instance without any parameter .", "partition": "test"}
{"idx": "3937", "code": "private boolean lockOrder(Order order){\n  lock.lock();\n  try {\n    return activeOrders.add(order.getId());\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "attempts the lock the order . if the order is already active this returns false .", "partition": "test"}
{"idx": "3938", "code": "public void put(Buffer buffer){\n  if (buffer.getLength() <= 2) {\n    return;\n  }\n  byte[] currentRtpPacketData=((byte[])buffer.getData());\n  H264RtpHeaders h264RtpHeaders=new H264RtpHeaders(currentRtpPacketData);\n  if (h264RtpHeaders.getFUI_F()) {\n    return;\n  }\n  if (reassembledData == null) {\n    timestamp=buffer.getTimestamp();\n    format=buffer.getFormat();\n    seqNumber=buffer.getSequenceNumber();\n    reassembledDataNALHeader=h264RtpHeaders.getNALHeader();\n    reassembledData=new byte[JavaPacketizer.H264_MAX_RTP_PKTS][H264_FRAME_PACKET_SIZE];\n    reassembledDataSize=new int[JavaPacketizer.H264_MAX_RTP_PKTS];\n    reassembledDataHasStart=false;\n    reassembledDataHasEnd=false;\n  }\n  int posSeq=(int)(buffer.getSequenceNumber() & VIDEO_DECODER_MAX_PAYLOADS_CHUNKS_MASK);\n  int payloadStartPosition=h264RtpHeaders.getHeaderSize();\n  int payloadLength=buffer.getLength() - h264RtpHeaders.getHeaderSize();\n  if (h264RtpHeaders.getFUI_TYPE() == H264RtpHeaders.AVC_NALTYPE_FUA) {\n    reassembledDataHasStart|=(h264RtpHeaders.getFUH_S());\n    reassembledDataHasEnd|=(h264RtpHeaders.getFUH_E());\n    reassembledDataPosSeqStart=((h264RtpHeaders.getFUH_S()) ? posSeq : reassembledDataPosSeqStart);\n    reassembledDataPosSeqEnd=((h264RtpHeaders.getFUH_E()) ? posSeq : reassembledDataPosSeqEnd);\n  }\n  reassembledDataSize[posSeq]=payloadLength;\n  reassembledDataFullSize+=payloadLength;\n  System.arraycopy(currentRtpPacketData,payloadStartPosition,reassembledData[posSeq],0,payloadLength);\n  videoOrientation=buffer.getVideoOrientation();\n}\n", "docstring": "add the buffer ( which contains a fragment ) to the assembler .", "partition": "test"}
{"idx": "3939", "code": "public static final void writeStringArrayXml(String[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"string-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  for (int i=0; i < N; i++) {\n    out.startTag(null,\"item\");\n    out.attribute(null,\"value\",val[i]);\n    out.endTag(null,\"item\");\n  }\n  out.endTag(null,\"string-array\");\n}\n", "docstring": "flatten a string [ ", "partition": "test"}
{"idx": "3940", "code": "private void unifyUsernameByName(Map<String,List<LogCommitInfo>> devNameMap){\n  for (  Entry<String,List<LogCommitInfo>> entry : devNameMap.entrySet()) {\n    List<String> userNames=getUserNamesList(entry.getValue());\n    if (userNames.size() > 1) {\n      String newUserName=getNewUserName(userNames);\n      for (      LogCommitInfo commit : entry.getValue()) {\n        commit.setUserName(newUserName);\n      }\n    }\n  }\n}\n", "docstring": "treat similar name aliases", "partition": "test"}
{"idx": "3941", "code": "@SuppressWarnings(\"unchecked\") public JdbcData(Connection connection,String table,boolean buffered){\n  this.connection=connection;\n  this.table=table;\n  setBuffered(buffered);\n  try {\n    setColumnTypes(getJdbcColumnTypes());\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "initializes a new instance to query the data from a specified table using a specified jdbc connection . it is assumed the table columns are constant during the connection .", "partition": "test"}
{"idx": "3942", "code": "public SecureELFFormatter(){\n  String timestampGeneratorClass=lmanager.getProperty(LogConstants.SECURE_TIMESTAMP_GENERATOR);\n  try {\n    Class clz=Class.forName(timestampGeneratorClass);\n    secureTimestampGenerator=(ITimestampGenerator)clz.newInstance();\n  }\n catch (  ClassNotFoundException cnfe) {\n    Debug.error(\"SecureELFFormatter: TimeStamp Generator Class \" + \"not found\",cnfe);\n  }\ncatch (  InstantiationException ie) {\n    Debug.error(\"SecureELFFormatter: Timestamp Generator Could \" + \"not be Instantiated\",ie);\n  }\ncatch (  IllegalAccessException iae) {\n    Debug.error(\"SecureELFFormatter: Timestamp Generator Could \" + \"not be Instantiated\",iae);\n  }\n}\n", "docstring": "returns a elf formatter", "partition": "test"}
{"idx": "3943", "code": "public static byte[] readData(final URL url) throws IOException {\n  try (InputStream input=url.openStream()){\n    return readData(input);\n  }\n }\n", "docstring": "reads all the data from the supplied url into a byte array .", "partition": "test"}
{"idx": "3944", "code": "public static EnergyNetwork initNetwork(){\n  Random random=new Random(System.currentTimeMillis());\n  int id=random.nextInt();\n  while (usedIds.contains(id)) {\n    id=random.nextInt();\n  }\n  ;\n  EnergyNetwork net=new EnergyNetwork();\n  usedIds.add(id);\n  net.networkID=id;\n  return net;\n}\n", "docstring": "create a new network and get an id", "partition": "test"}
{"idx": "3945", "code": "public static String toKilobytes(long bytes){\n  if (bytes < 0)   return \"? \" + GENERAL_UNIT_KILOBYTES;\n  long kbytes=bytes / 1024;\n  if ((bytes & 512) != 0 || (bytes > 0 && bytes < 1024))   kbytes++;\n  return NUMBER_FORMAT0.format(kbytes) + GENERAL_UNIT_KILOBYTES;\n}\n", "docstring": "this static method converts the passed in number of bytes into a kilobyte string grouping digits with locale - dependant thousand separator and with \" kb \" locale - dependant unit at the end .", "partition": "test"}
{"idx": "3946", "code": "private PendingIntent createRequestPendingIntent(@NonNull String pendingIntentClassName){\n  PendingIntent pendingIntent=null;\n  try {\n    Class classOfPendingIntent=Class.forName(pendingIntentClassName);\n    if (classOfPendingIntent != null) {\n      Intent intent=new Intent(mContext,classOfPendingIntent);\n      pendingIntent=PendingIntent.getService(mContext,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);\n    }\n  }\n catch (  ClassNotFoundException e) {\n    e.printStackTrace();\n  }\n  return pendingIntent;\n}\n", "docstring": "create a pending intent from the storable fence", "partition": "test"}
{"idx": "3947", "code": "void testString(){\n  String a=randomString();\n  if (returnNew) {\n    String b=StringUtils.fromCacheOrNew(a);\n    try {\n      assertEquals(a,b);\n    }\n catch (    Exception e) {\n      TestBase.logError(\"error\",e);\n    }\n    if (a != null && a == b && a.length() > 0) {\n      throw new AssertionError(\"a=\" + System.identityHashCode(a) + \" b=\"+ System.identityHashCode(b));\n    }\n  }\n else {\n    String b;\n    if (useIntern) {\n      b=a == null ? null : a.intern();\n    }\n else {\n      b=StringUtils.cache(a);\n    }\n    try {\n      assertEquals(a,b);\n    }\n catch (    Exception e) {\n      TestBase.logError(\"error\",e);\n    }\n  }\n}\n", "docstring": "test one string operation using the string cache .", "partition": "test"}
{"idx": "3948", "code": "public void configs(SwtPlatform... platforms){\n  configs(Arrays.asList(platforms));\n}\n", "docstring": "adds the given location to be the target for artifacts .", "partition": "test"}
{"idx": "3949", "code": "protected int checkIPRange(){\n  int retVal=0;\n  String ipVersion;\n  String ipType;\n  Map<String,String> holdDetails;\n  for (  String nextIP : IPRangeRange) {\n    try {\n      holdDetails=checkIPVersion(nextIP);\n    }\n catch (    IllegalArgumentException e) {\n      if (debug.warningEnabled()) {\n        debug.warning(\"{}.checkIPRange: IP type could not be validated. IP={}\",ADAPTIVE,nextIP,e);\n      }\n      continue;\n    }\n    ipVersion=holdDetails.get(IP_Version);\n    ipType=holdDetails.get(IP_TYPE);\n    if (ipVersion.equalsIgnoreCase(IP_V6) && ValidateIPaddress.isIPv6(clientIP)) {\n      if (debug.messageEnabled()) {\n        debug.message(\"{}.checkIPRange: {} --> {}\",ADAPTIVE,clientIP,nextIP);\n        debug.message(\"IP version is: {}\",IP_V6);\n        debug.message(\"Client IP is: {}\",IPv6Address.fromString(clientIP));\n      }\n      if (ipType.equalsIgnoreCase(\"Range\")) {\n        String first=holdDetails.get(IP_START);\n        String last=holdDetails.get(IP_END);\n        IPv6AddressRange iPv6AddressRange=IPv6AddressRange.fromFirstAndLast(IPv6Address.fromString(first),IPv6Address.fromString(last));\n        if (iPv6AddressRange.contains(IPv6Address.fromString(clientIP))) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n else       if (ipType.equalsIgnoreCase(\"CIDR\")) {\n        IPv6Network iPv6Network=IPv6Network.fromString(nextIP);\n        if (iPv6Network.contains(IPv6Address.fromString(clientIP))) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n else {\n        IPv6Address iPv6AddressNextIP=IPv6Address.fromString(nextIP);\n        if (iPv6AddressNextIP.compareTo(IPv6Address.fromString(clientIP)) == 0) {\n          retVal=IPRangeScore;\n          break;\n        }\n      }\n    }\n else     if (ipVersion.equalsIgnoreCase(IP_V4) && ValidateIPaddress.isIPv4(clientIP)) {\n      if (debug.messageEnabled()) {\n        debug.message(\"{}.checkIPRange: {} --> {}\",ADAPTIVE,clientIP,nextIP);\n        debug.message(\"IP version is: {}\",IP_V4);\n        debug.message(\"Client IP is: {}\",clientIP);\n      }\n      IPRange theRange=new IPRange(nextIP);\n      if (theRange.inRange(clientIP)) {\n        retVal=IPRangeScore;\n        break;\n      }\n    }\n  }\n  if (!IPRangeInvert) {\n    retVal=IPRangeScore - retVal;\n  }\n  return retVal;\n}\n", "docstring": "check to see if the ip address is within the ranges specified range can be in the form of : x . x . x . x / yy or x . x . x . x - y . y . y . y . or x : x : x : x : x : x : x : x / yy or x : x : x : x : x : x : x : x - y : y : y : y : y : y : y : y there can be multiple ranges passed in", "partition": "test"}
{"idx": "3950", "code": "private View fillFromSelection(int selectedLeft,int childrenLeft,int childrenRight){\n  if (DEBUG)   Log.i(TAG,\"fillFromSelection() selectedLeft: \" + selectedLeft + \" childrenLeft: \"+ childrenLeft+ CHILDREN_RIGHT+ childrenRight+ M_FIRST_POSITION+ mFirstPosition);\n  final int fadingEdgeLength=getHorizontalFadingEdgeLength();\n  final int selectedPosition=mSelectedPosition;\n  final int numRows=mNumRows;\n  final int horizontalSpacing=mHorizontalSpacing;\n  int columnStart;\n  int columnEnd=-1;\n  if (!mStackFromBottom) {\n    columnStart=selectedPosition - (selectedPosition % numRows);\n  }\n else {\n    int invertedSelection=mItemCount - 1 - selectedPosition;\n    columnEnd=mItemCount - 1 - (invertedSelection - (invertedSelection % numRows));\n    columnStart=Math.max(0,columnEnd - numRows + 1);\n  }\n  View sel;\n  View referenceView;\n  int leftSelectionPixel=getLeftSelectionPixel(childrenLeft,fadingEdgeLength,columnStart);\n  int rightSelectionPixel=getRightSelectionPixel(childrenRight,fadingEdgeLength,numRows,columnStart);\n  sel=makeColumn(mStackFromBottom ? columnEnd : columnStart,selectedLeft,true);\n  mFirstPosition=columnStart;\n  referenceView=mReferenceView;\n  adjustForLeftFadingEdge(referenceView,leftSelectionPixel,rightSelectionPixel);\n  adjustForRightFadingEdge(referenceView,leftSelectionPixel,rightSelectionPixel);\n  if (!mStackFromBottom) {\n    fillLeft(columnStart - numRows,referenceView.getLeft() - horizontalSpacing);\n    adjustViewsLeftOrRight();\n    fillRight(columnStart + numRows,referenceView.getRight() + horizontalSpacing);\n  }\n else {\n    fillRight(columnEnd + numRows,referenceView.getRight() + horizontalSpacing);\n    adjustViewsLeftOrRight();\n    fillLeft(columnStart - 1,referenceView.getLeft() - horizontalSpacing);\n  }\n  return sel;\n}\n", "docstring": "fills the grid based on positioning the new selection at a specific location . the selection may be moved so that it does not intersect the faded edges . the grid is then filled upwards and downwards from there .", "partition": "test"}
{"idx": "3951", "code": "@Override public ShapeTileSimplex to_Simplex(){\n  if (is_empty())   return ShapeTileSimplex.EMPTY;\n  ArrayList<PlaLineInt> line_arr=new ArrayList<PlaLineInt>(4);\n  line_arr.add(new PlaLineInt(box_ll,PlaDirection.RIGHT));\n  line_arr.add(new PlaLineInt(box_ur,PlaDirection.UP));\n  line_arr.add(new PlaLineInt(box_ur,PlaDirection.LEFT));\n  line_arr.add(new PlaLineInt(box_ll,PlaDirection.DOWN));\n  return new ShapeTileSimplex(line_arr);\n}\n", "docstring": "returns an object of class simplex defining the same shape", "partition": "test"}
{"idx": "3952", "code": "private void injectContent(Inject injectContent) throws IOException, MojoExecutionException {\n  Map<Pattern,File> contents=getContentsMap(injectContent.getContents());\n  File tmpFile=ioFactory.createTemporaryFile(injectContent.getDestinationFile());\n  BufferedReader reader=null;\n  BufferedWriter writer=null;\n  try {\n    reader=ioFactory.newReader(injectContent.getDestinationFile());\n    writer=ioFactory.newWriter(tmpFile);\n    String line;\n    while ((line=reader.readLine()) != null) {\n      File content=doesLineMatchId(contents,line);\n      if (content != null) {\n        ioFactory.writeContent(writer,content,getContentConverter(injectContent));\n      }\n else {\n        ioFactory.writeLine(writer,line);\n      }\n    }\n  }\n  finally {\n    if (reader != null) {\n      reader.close();\n    }\n    if (writer != null) {\n      writer.flush();\n      writer.close();\n    }\n  }\n  ioFactory.moveTo(tmpFile,injectContent.getDestinationFile());\n}\n", "docstring": "injects the configured content files into the destination file .", "partition": "test"}
{"idx": "3953", "code": "private static boolean createBooleanSetting(final Map<String,String> rawSettings,final String settingName,final boolean defaultValue){\n  final String settingString=rawSettings.get(settingName);\n  if (settingString == null) {\n    return defaultValue;\n  }\n else {\n    try {\n      return Boolean.parseBoolean(settingString);\n    }\n catch (    final NumberFormatException exception) {\n      CUtilityFunctions.logException(exception);\n      return defaultValue;\n    }\n  }\n}\n", "docstring": "turns a settings string value into a boolean value .", "partition": "test"}
{"idx": "3954", "code": "private MarshalledWrapper lookupDo(Template tmpl){\n  if (isEmpty(tmpl.serviceTypes) || tmpl.serviceID != null) {\n    ItemIter iter=matchingItems(tmpl);\n    if (iter.hasNext())     return iter.next().service;\n    return null;\n  }\n  List services=matchingServices(tmpl.serviceTypes);\n  long now=System.currentTimeMillis();\n  int slen=services.size();\n  if (slen == 0)   return null;\n  int srand=Math.abs(random.nextInt() % slen);\n  for (int i=0; i < slen; i++) {\n    SvcReg reg=(SvcReg)services.get((i + srand) % slen);\n    if (reg.leaseExpiration > now && matchAttributes(tmpl,reg.item))     return reg.item.service;\n  }\n  return null;\n}\n", "docstring": "the code that does the real work of lookup . as a special case , if the template specifies at least one service type to match , and there are multiple items that match the template , then we make a random pick among them , in an attempt to load balance use of \" equivalent \" services and avoid starving any of them .", "partition": "test"}
{"idx": "3955", "code": "@Override public boolean runAfter(List tasks,int size){\n  for (int i=0; i < size; i++) {\n    CacheTask t=(CacheTask)tasks.get(i);\n    if (t instanceof RegisterListenerTask || t instanceof LookupTask) {\n      ProxyReg otherReg=t.getProxyReg();\n      if (reg.equals(otherReg)) {\n        if (thisTaskSeqN > t.getSeqN())         return true;\n      }\n    }\n  }\n  return super.runAfter(tasks,size);\n}\n", "docstring": "returns true if the current instance of this task must be run after at least one task in the task manager queue . the criteria for determining what value to return : if the task list contains any registerlistenertasks or lookuptasks associated with this task \"'\" s lookup service ( proxyreg ) , and if those tasks were queued prior to this task ( have lower sequence numbers ) , then run those tasks before this task ( return true ) . additionally , if the task list contains any other serviceidtasks associated with this task \"'\" s service id which were queued prior to this task , then run those tasks before this task . if the criteria outlined above is not satisfied , then this task can be run immediately ( return false ) . this method was added to address bug id 6291851 .", "partition": "test"}
{"idx": "3956", "code": "String generateKey() throws OracleException {\n  byte[] data=null;\n  try {\n    data=HashFuncs.getRandom();\n  }\n catch (  Exception e) {\n    if (OracleLog.isLoggingEnabled())     log.warning(e.toString());\n  }\n  if (data == null) {\n    data=fetchGuid();\n  }\n  if (data == null) {\n    throw SODAUtils.makeException(SODAMessage.EX_UNABLE_TO_CREATE_UUID);\n  }\n  return (ByteArray.rawToHex(data));\n}\n", "docstring": "generate a uuid key string", "partition": "test"}
{"idx": "3957", "code": "public double[] arrayCopy(){\n  double[] array=new double[length()];\n  for (  IndexValue iv : this)   array[iv.getIndex()]=iv.getValue();\n  return array;\n}\n", "docstring": "creates a new array that contains all the values of this vector in the appropriate indices", "partition": "test"}
{"idx": "3958", "code": "public static void delete(Path path){\n  if (path != null) {\n    path=path.toAbsolutePath();\n    if (inTargetDir(path)) {\n      try {\n        IoUtil.delete(path);\n      }\n catch (      IOException e) {\n        printError(\"Unable to remove \'\" + path.toAbsolutePath() + \"\'\",e);\n      }\n    }\n else {\n      printError(\"Will not remove directory that is outside test target area: \" + path);\n    }\n  }\n}\n", "docstring": "a method that will delete a file or folder only if it is within the \"'\" target \"'\" directory ( for safety ) . folders are removed recursively .", "partition": "test"}
{"idx": "3959", "code": "private void initPattern(){\n  StringBuffer patternTemplateRegex=new StringBuffer();\n  logger.debug(\"Get placeholder matcher\");\n  Matcher placeholderMatcher=getPlaceholderMatcher();\n  logger.debug(\"Replace all placeholder with regex group capture\");\n  while (placeholderMatcher.find()) {\n    String group=placeholderMatcher.group(1);\n    if (!groups.contains(group)) {\n      logger.trace(\"New group found, add it, replace with a capture group\");\n      groups.add(group);\n      String groupRegex=getGroupRegex(group);\n      placeholderMatcher.appendReplacement(patternTemplateRegex,Matcher.quoteReplacement(\"(?<\" + group + \">\"+ groupRegex+ \")\"));\n    }\n else {\n      logger.trace(\"Existing group found, replace with a back reference\");\n      placeholderMatcher.appendReplacement(patternTemplateRegex,Matcher.quoteReplacement(\"\\\\k<\" + group + \">\"));\n    }\n  }\n  placeholderMatcher.appendTail(patternTemplateRegex);\n  String patternRegex=patternTemplateRegex.toString();\n  logger.debug(\"pattern:\" + patternRegex);\n  pattern=Pattern.compile(patternRegex);\n}\n", "docstring": "initialize the pattern to match files .", "partition": "test"}
{"idx": "3960", "code": "protected void newLine(PrintWriter file,String string,boolean isManifest){\n  String[] lines=string.split(NEW_LINE);\n  for (  String line : lines) {\n    String[] words=line.split(SPACE);\n    StringBuffer sb=new StringBuffer();\n    for (    String word : words) {\n      if (checkStringLength(sb.toString() + word,isManifest)) {\n        sb.append(word + SPACE);\n      }\n else {\n        sb.setLength(sb.length() - 1);\n        addLine(file,sb.toString());\n        sb=new StringBuffer(word + SPACE);\n      }\n    }\n    if (sb.length() > 0) {\n      sb.setLength(sb.length() - 1);\n    }\n    addLine(file,sb.toString());\n  }\n}\n", "docstring": "writes a string to a file . checks for string length , and will automatically wrap lines .", "partition": "test"}
{"idx": "3961", "code": "protected boolean updateAttachmentPoint(){\n  boolean moved=false;\n  this.oldAPs=attachmentPoints;\n  if (attachmentPoints == null || attachmentPoints.isEmpty())   return false;\n  List<AttachmentPoint> apList=new ArrayList<AttachmentPoint>();\n  if (attachmentPoints != null)   apList.addAll(attachmentPoints);\n  Map<Long,AttachmentPoint> newMap=getAPMap(apList);\n  if (newMap == null || newMap.size() != apList.size()) {\n    moved=true;\n  }\n  if (moved) {\n    log.info(\"updateAttachmentPoint: ap {}  newmap {} \",attachmentPoints,newMap);\n    List<AttachmentPoint> newAPList=new ArrayList<AttachmentPoint>();\n    if (newMap != null)     newAPList.addAll(newMap.values());\n    this.attachmentPoints=newAPList;\n  }\n  return moved;\n}\n", "docstring": "update the known attachment points . this method is called whenever topology changes . the method returns true if there \"'\" s any change to the list of attachment points - - which indicates a possible device move .", "partition": "test"}
{"idx": "3962", "code": "public List<SoftWrapImpl> removeStartingFrom(int offset){\n  int startIndex=getSoftWrapIndex(offset);\n  if (startIndex < 0) {\n    startIndex=-startIndex - 1;\n  }\n  if (startIndex >= myWraps.size()) {\n    return Collections.emptyList();\n  }\n  List<SoftWrapImpl> tail=myWraps.subList(startIndex,myWraps.size());\n  List<SoftWrapImpl> result=new ArrayList<SoftWrapImpl>(tail);\n  tail.clear();\n  return result;\n}\n", "docstring": "removes soft wraps with offsets equal or larger than a given offset from storage .", "partition": "test"}
{"idx": "3963", "code": "public static String formatDps(final double dps){\n  return \"(\" + String.format(\"%.2f\",dps) + \" dps)\";\n}\n", "docstring": "formats given dps ( = damage per second ) to a readable string . with braces .", "partition": "test"}
{"idx": "3964", "code": "public static String truncate(String string,int length){\n  if (string.length() > length) {\n    string=string.substring(0,length);\n  }\n  return string;\n}\n", "docstring": "sets the maximum length of the string . longer strings will be simply truncated .", "partition": "test"}
{"idx": "3965", "code": "private boolean checkDisband(Legion legion){\n  if (legion.isDisbanding()) {\n    if ((System.currentTimeMillis() / 1000) > legion.getDisbandTime()) {\n      disbandLegion(legion);\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "method that checks if a legion is disbanding", "partition": "test"}
{"idx": "3966", "code": "public static void downto(float self,Number to,@ClosureParams(FirstParam.class) Closure closure){\n  float to1=to.floatValue();\n  if (self >= to1) {\n    for (float i=self; i >= to1; i--) {\n      closure.call(i);\n    }\n  }\n else   throw new GroovyRuntimeException(\"The argument (\" + to + \") to downto() cannot be greater than the value (\"+ self+ \") it\'s called on.\");\n}\n", "docstring": "iterates from this number down to the given number , inclusive , decrementing by one each time .", "partition": "test"}
{"idx": "3967", "code": "protected void parseDOMAttributes(Element element) throws SAML2Exception {\n  requestId=element.getAttribute(SAML2Constants.ID);\n  validateID(requestId);\n  version=element.getAttribute(SAML2Constants.VERSION);\n  validateVersion(version);\n  String issueInstantStr=element.getAttribute(SAML2Constants.ISSUE_INSTANT);\n  validateIssueInstant(issueInstantStr);\n  destinationURI=element.getAttribute(SAML2Constants.DESTINATION);\n  consent=element.getAttribute(SAML2Constants.CONSENT);\n}\n", "docstring": "parses attributes of the docuemnt element for this object .", "partition": "test"}
{"idx": "3968", "code": "public static InputStream streamFromString(String location) throws IOException {\n  InputStream is=null;\n  URL url=urlFromString(location,null,false);\n  if (url != null) {\n    is=url.openStream();\n  }\n else {\n    File f=new File(location);\n    if (f.exists())     is=new FileInputStream(f);\n  }\n  if (is == null) {\n    return null;\n  }\n else   if (isGZipFile(location)) {\n    return new GZIPInputStream(is);\n  }\n else {\n    return is;\n  }\n}\n", "docstring": "get an input string corresponding to the given location string . the string will first be resolved to a url and an input stream will be requested from the url connection . if this fails , the location will be resolved against the file system . also , if a gzip file is found , the input stream will also be wrapped by a gzipinputstream . if the location string can not be resolved , a null value is returned", "partition": "test"}
{"idx": "3969", "code": "public void add(T item){\nsynchronized (lock) {\n    items.add(identifiedItemFactory.create(item));\n  }\n  notifyDataSetChanged();\n}\n", "docstring": "adds the specified item at the end of the array .", "partition": "test"}
{"idx": "3970", "code": "private void copyACLs(List<UnManagedCifsShareACL> origACLList,List<CifsShareACL> shareACLList,FileShare fileshare){\n  CifsShareACL shareACL=null;\n  for (  UnManagedCifsShareACL origACL : origACLList) {\n    shareACL=new CifsShareACL();\n    shareACL.setId(URIUtil.createId(CifsShareACL.class));\n    shareACL.setUser(origACL.getUser());\n    shareACL.setPermission(origACL.getPermission());\n    shareACL.setShareName(origACL.getShareName());\n    shareACL.setFileSystemId(fileshare.getId());\n    shareACLList.add(shareACL);\n    _logger.info(\"share ACLs details {}\",shareACL.toString());\n  }\n}\n", "docstring": "copy unmanaged cifs share into new cifs share acls", "partition": "test"}
{"idx": "3971", "code": "public ResourceListParser parse() throws ParserConfigurationException, SAXException, ParseFailureException {\n  try {\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    parser.parse(mInputSource,this);\n    return this;\n  }\n catch (  IOException e) {\n    throw new ParseFailureException(\"Failed to parse input source!\",e);\n  }\n}\n", "docstring": "parse the resource list", "partition": "test"}
{"idx": "3972", "code": "public Builder deleteEntitlements(){\n  deleteFields.add(\"entitlements\");\n  return this;\n}\n", "docstring": "deletes all entitlements of a existing user", "partition": "test"}
{"idx": "3973", "code": "protected void incorporateSignedProperties() throws DSSException {\n  signedPropertiesDom=DSSXMLUtils.addElement(documentDom,qualifyingPropertiesDom,XAdES,XADES_SIGNED_PROPERTIES);\n  signedPropertiesDom.setAttribute(ID,\"xades-\" + deterministicId);\n  incorporateSignedSignatureProperties();\n}\n", "docstring": "creates the signedproperties dom object element .", "partition": "test"}
{"idx": "3974", "code": "public static float mean(float[] data,int[] inds){\n  float mean=0;\n  for (int i=0; i < inds.length; i++) {\n    if (Float.isNaN(data[inds[i]]))     throw new IllegalArgumentException(\"NaN not allowed in mean calculation\");\n    mean+=data[inds[i]];\n  }\n  mean/=inds.length;\n  return mean;\n}\n", "docstring": "compute the mean of all elements in the array with given indices . no missing values ( nan ) are allowed .", "partition": "test"}
{"idx": "3975", "code": "public int depth(){\n  return pointer;\n}\n", "docstring": "get the depth of the stack .", "partition": "test"}
{"idx": "3976", "code": "public Result doComparisonTest(Properties properties) throws Exception {\n  final long timeout=Long.parseLong(properties.getProperty(TestOptions.TIMEOUT));\n  final int ntrials=Integer.parseInt(properties.getProperty(TestOptions.NTRIALS));\n  final int nclients=Integer.parseInt(properties.getProperty(TestOptions.NCLIENTS));\n  final double percentReaders=Double.parseDouble(properties.getProperty(TestOptions.PERCENT_READERS));\n  final double percentWritersWillFlush=Double.parseDouble(properties.getProperty(TestOptions.PERCENT_WRITER_WILL_FLUSH));\n  final int reclen=Integer.parseInt(properties.getProperty(TestOptions.RECLEN));\n  final int nwritesPerTask=Integer.parseInt(properties.getProperty(TestOptions.NWRITES));\n  final int nreadsPerTask=Integer.parseInt(properties.getProperty(TestOptions.NREADS));\n  final AtomicInteger nerr=new AtomicInteger();\n  final Result result=doMRMWTest(store,timeout,ntrials,nclients,percentReaders,percentWritersWillFlush,reclen,nwritesPerTask,nreadsPerTask,nerr);\n  return result;\n}\n", "docstring": "setup and run a test .", "partition": "test"}
{"idx": "3977", "code": "private void cmd_import(){\n  JFileChooser jc=new JFileChooser();\n  jc.setDialogTitle(Msg.getMsg(Env.getCtx(),\"Import\"));\n  jc.setDialogType(JFileChooser.OPEN_DIALOG);\n  jc.setFileSelectionMode(JFileChooser.FILES_ONLY);\n  if (jc.showOpenDialog(this) != JFileChooser.APPROVE_OPTION)   return;\n  StringBuffer sb=new StringBuffer();\n  try {\n    InputStreamReader in=new InputStreamReader(new FileInputStream(jc.getSelectedFile()));\n    char[] cbuf=new char[1024];\n    int count;\n    while ((count=in.read(cbuf)) > 0)     sb.append(cbuf,0,count);\n    in.close();\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,\"HTMLEditor.import\" + e.getMessage());\n    return;\n  }\n  setHtmlText(sb.toString());\n}\n", "docstring": "import text from file", "partition": "test"}
{"idx": "3978", "code": "private List<String> fetchFileCosIdList() throws SOSFailure {\n  final String methodName=\"fetchFileCosIdList(): \";\n  log.trace(methodName + \"Entry\");\n  final String FILE_COS_URI=\"/file/vpools\";\n  List<String> fileCosIdList=new ArrayList<String>();\n  try {\n    CoSList cosElemList=_client.queryObject(FILE_COS_URI,CoSList.class);\n    if (cosElemList != null && cosElemList.getCosElements() != null) {\n      for (      CoSElement elem : cosElemList.getCosElements()) {\n        if (elem != null) {\n          fileCosIdList.add(elem.getId());\n        }\n      }\n    }\n    log.trace(methodName + \"File CoS Ids: \" + fileCosIdList);\n    if (cosElemList != null && fileCosIdList != null) {\n      log.trace(methodName + \"Exit returning cos list of size[\" + fileCosIdList.size()+ \"]\");\n      return fileCosIdList;\n    }\n    log.trace(methodName + \"Exit returning cos list of size[0]\");\n    return new ArrayList<String>();\n  }\n catch (  NoSuchAlgorithmException e) {\n    log.error(methodName + \"NoSuchAlgorithmException occured\",e);\n    throw new SOSFailure(e);\n  }\ncatch (  UniformInterfaceException e) {\n    log.error(methodName + \"UniformInterfaceException occured\",e);\n    throw new SOSFailure(e);\n  }\n}\n", "docstring": "returns list of file cos ids", "partition": "test"}
{"idx": "3979", "code": "public void monitor(ScalingStateMonitorTask task){\n  taskQueue.add(task);\n  startMonitor();\n}\n", "docstring": "adds a monitor task to the queue", "partition": "test"}
{"idx": "3980", "code": "public final double sampleMax(){\n  long max=_max.getAndSet(0);\n  return _scale * max;\n}\n", "docstring": "return the probe \"'\" s next sample .", "partition": "test"}
{"idx": "3981", "code": "private static void writeFile(File file,List<String> lines) throws IOException {\n  if (!file.exists())   file.createNewFile();\n  FileWriter fw=new FileWriter(file);\n  BufferedWriter Bw=new BufferedWriter(fw);\n  PrintWriter pw=new PrintWriter(Bw);\n  for (  String line : lines)   pw.println(line);\n  Bw.close();\n  fw.close();\n  pw.close();\n}\n", "docstring": "writes the lines given in input in file .", "partition": "test"}
{"idx": "3982", "code": "public synchronized boolean verifyChunkAuthTag(int chunkIdx,byte[] chunkAuthTag) throws FileEncryptionException {\n  if ((chunkIdx < 0) || (chunkAuthTag == null) || (chunkAuthTag.length != backEncRandomAccessFile.CHUNK_TLEN)) {\n    throw new FileEncryptionException(\"Invalid auth tag parameter given!\");\n  }\n else {\n    byte[] storedAuthTag=atagList.get(chunkIdx);\n    if (storedAuthTag == null || !Arrays.equals(chunkAuthTag,storedAuthTag)) {\n      return false;\n    }\n else {\n      return true;\n    }\n  }\n}\n", "docstring": "verifies if the given chunk authentication tag equals the one in the authentication tag list , but does not verify if the complete list of all authentication tags is valid w . r . t . the central file authentication tag", "partition": "test"}
{"idx": "3983", "code": "public <AnnotationType extends Annotation>void register(MethodBinder<AnnotationType> methodBinder){\n  Set<AnnotatedMethod<AnnotationType>> annotatedMethods=AnnotatedMethods.get(methodBinder.getAnnotationClass(),annotatedType);\n  if (!annotatedMethods.isEmpty()) {\n    objectBinders.add(new AnnotatedMethodBinder<>(methodBinder,annotatedMethods));\n  }\n}\n", "docstring": "update the cache with this binder", "partition": "test"}
{"idx": "3984", "code": "private Document parseRouteFile() throws Exception {\n  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n  factory.setNamespaceAware(true);\n  DocumentBuilder builder=factory.newDocumentBuilder();\n  return builder.parse(routeFile);\n}\n", "docstring": "parse the spring integration route file and return dom document .", "partition": "test"}
{"idx": "3985", "code": "public void removeDTEDDirectoryHandler(DTEDDirectoryHandler handler){\n  directories.remove(handler);\n}\n", "docstring": "remove a dted directoryhandler from the list used for the dtedframecache .", "partition": "test"}
{"idx": "3986", "code": "public default void addFile(final ContentProvider contentProvider,final String fileName,final EntryInformation entryInformation) throws IOException {\n  addFile(contentProvider,fileName,entryInformation,Optional.empty());\n}\n", "docstring": "add a file to the binary package", "partition": "test"}
{"idx": "3987", "code": "private Vector<SnmpVarBind> splitFrom(Vector<SnmpVarBind> original,int limit){\n  int max=original.size();\n  Vector<SnmpVarBind> result=new Vector<>(max - limit);\n  int i=limit;\n  for (Enumeration<SnmpVarBind> e=original.elements(); e.hasMoreElements(); --i) {\n    SnmpVarBind var=e.nextElement();\n    if (i > 0)     continue;\n    result.addElement(new SnmpVarBind(var.oid,var.value));\n  }\n  return result;\n}\n", "docstring": "this method creates a new vector which does not contain the first element up to the specified limit .", "partition": "test"}
{"idx": "3988", "code": "public static void initUrbanSimZoneWriter(Config config){\n  UrbanSimParameterConfigModuleV3 module=(UrbanSimParameterConfigModuleV3)config.getModule(UrbanSimParameterConfigModuleV3.GROUP_NAME);\n  try {\n    log.info(\"Initializing UrbanSimParcelCSVWriter ...\");\n    parcelWriter=IOUtils.getBufferedWriter(module.getMATSim4OpusTemp() + FILE_NAME);\n    log.info(\"Writing data into \" + module.getMATSim4OpusTemp() + FILE_NAME+ \" ...\");\n    parcelWriter.write(InternalConstants.PARCEL_ID + \",\" + ACCESSIBILITY_BY_FREESPEED+ \",\"+ ACCESSIBILITY_BY_CAR+ \",\"+ ACCESSIBILITY_BY_BIKE+ \",\"+ ACCESSIBILITY_BY_WALK+ \",\"+ ACCESSIBILITY_BY_PT);\n    parcelWriter.newLine();\n    log.info(\"... done!\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "writes the header for zones csv file", "partition": "test"}
{"idx": "3989", "code": "public final void delayTask(@NotNull TransactionRunnable task){\n  myDelayedTasks.add(task);\n}\n", "docstring": "delay task to be executed after refresh", "partition": "test"}
{"idx": "3990", "code": "private static <T>int migrateAll(Migration<T> migration) throws Exception {\n  int migrated=0;\n  for (  T entity : migration.getAllEntities()) {\n    try {\n      if (migration.isMigrated(entity))       continue;\n    }\n catch (    Exception x) {\n      LOG.error(\"Couldn\'t check if the entity \'{}\' is migrated due to occurred error\",entity);\n      throw x;\n    }\n    try {\n      migration.migrate(entity);\n    }\n catch (    Exception x) {\n      LOG.error(\"Error migrating the entity \'{}\",entity);\n      throw x;\n    }\n    migrated++;\n  }\n  return migrated;\n}\n", "docstring": "migrates entities and skips those which are already migrated .", "partition": "test"}
{"idx": "3991", "code": "private void captureDifferentString(String oldString,String newString,Map<String,String> map,String appName){\n  Reject.ifNull(appName);\n  Reject.ifNull(map);\n  if (oldString == null ? newString != null : !oldString.equals(newString)) {\n    map.put(appName,newString);\n  }\n}\n", "docstring": "adds entries to the passed in map , using the supplied appname as the key . the value is a new , empty set if both oldset and newset are null , or newset if the contents of oldset and newset differ . if the two sets are the same , no entries are added to the map .", "partition": "test"}
{"idx": "3992", "code": "@Override protected void drawXLabels(List<Double> xLabels,Double[] xTextLabelLocations,Canvas canvas,Paint paint,int left,int top,int bottom,double xPixelsPerUnit,double minX,double maxX){\n  int length=xLabels.size();\n  if (length > 0) {\n    boolean showLabels=mRenderer.isShowLabels();\n    boolean showGridY=mRenderer.isShowGridY();\n    DateFormat format=getDateFormat(xLabels.get(0),xLabels.get(length - 1));\n    for (int i=0; i < length; i++) {\n      long label=Math.round(xLabels.get(i));\n      float xLabel=(float)(left + xPixelsPerUnit * (label - minX));\n      if (showLabels) {\n        paint.setColor(mRenderer.getXLabelsColor());\n        canvas.drawLine(xLabel,bottom,xLabel,bottom + mRenderer.getLabelsTextSize() / 3,paint);\n        drawText(canvas,format.format(new Date(label)),xLabel,bottom + mRenderer.getLabelsTextSize() * 4 / 3,paint,mRenderer.getXLabelsAngle());\n      }\n      if (showGridY) {\n        paint.setColor(mRenderer.getGridColor());\n        canvas.drawLine(xLabel,bottom,xLabel,top,paint);\n      }\n    }\n  }\n  drawXTextLabels(xTextLabelLocations,canvas,paint,true,left,top,bottom,xPixelsPerUnit,minX,maxX);\n}\n", "docstring": "the graphical representation of the labels on the x axis .", "partition": "test"}
{"idx": "3993", "code": "public static String encodeToString(byte[] src){\n  if (src == null) {\n    return null;\n  }\n  if (src.length == 0) {\n    return \"\";\n  }\n  String result;\n  try {\n    result=new String(delegate.encode(src),DEFAULT_CHARSET.displayName());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new IllegalStateException(e);\n  }\n  return result;\n}\n", "docstring": "base64 - encode the given byte array to a string .", "partition": "test"}
{"idx": "3994", "code": "public static void chunkTaskSync(RegionWrapper region,final RunnableVal<int[]> task){\n  final int p1x=region.minX;\n  final int p1z=region.minZ;\n  final int p2x=region.maxX;\n  final int p2z=region.maxZ;\n  final int bcx=p1x >> 4;\n  final int bcz=p1z >> 4;\n  final int tcx=p2x >> 4;\n  final int tcz=p2z >> 4;\n  task.value=new int[7];\n  for (int x=bcx; x <= tcx; x++) {\n    for (int z=bcz; z <= tcz; z++) {\n      task.value[0]=x;\n      task.value[1]=z;\n      task.value[2]=task.value[0] << 4;\n      task.value[3]=task.value[1] << 4;\n      task.value[4]=task.value[2] + 15;\n      task.value[5]=task.value[3] + 15;\n      task.value[6]=0;\n      if (task.value[0] == bcx) {\n        task.value[2]=p1x;\n        task.value[6]=1;\n      }\n      if (task.value[0] == tcx) {\n        task.value[4]=p2x;\n        task.value[6]=1;\n      }\n      if (task.value[1] == bcz) {\n        task.value[3]=p1z;\n        task.value[6]=1;\n      }\n      if (task.value[1] == tcz) {\n        task.value[5]=p2z;\n        task.value[6]=1;\n      }\n      task.run();\n    }\n  }\n}\n", "docstring": "the int [ ", "partition": "test"}
{"idx": "3995", "code": "public ElsaSerializerPojo make(){\n  return new ElsaSerializerPojo(objectStack,singletons,registeredSers,registeredSerHeaders,registeredDeser,unknownClassNotification,new ElsaClassInfoResolver.ArrayBased(classes.toArray(new Class[0])));\n}\n", "docstring": "creates new serializer with configuration from this builder", "partition": "test"}
{"idx": "3996", "code": "private void loadBinary(InputStream is) throws IOException {\n  if (is instanceof FileInputStream) {\n    FileInputStream fis=(FileInputStream)is;\n    FileChannel fc=fis.getChannel();\n    MappedByteBuffer bb=fc.map(FileChannel.MapMode.READ_ONLY,0,(int)fc.size());\n    bb.load();\n    loadBinary(bb);\n    is.close();\n  }\n else {\n    loadBinary(new DataInputStream(is));\n  }\n}\n", "docstring": "loads a binary file from the input stream .", "partition": "test"}
{"idx": "3997", "code": "private static boolean isTwoSlotType(ClassNode type){\n  return type == ClassHelper.long_TYPE || type == ClassHelper.double_TYPE;\n}\n", "docstring": "returns true for long and double", "partition": "test"}
{"idx": "3998", "code": "public SpecificationRunnerBuilder sections(String[] paramSections){\n  Collections.addAll(this.sections,paramSections);\n  return this;\n}\n", "docstring": "you can add sections to filter the input specification , so livingdoc will only execute the specified sections .", "partition": "test"}
{"idx": "3999", "code": "private void consumeCRLF() throws DecodingException {\n  char next=nextChar();\n  if (next != '\\n') {\n    consumeChar('\\r');\n  }\n  consumeChar('\\n');\n}\n", "docstring": "consumes a crlf from the request . todo : this is too liberal , the spec insists on \\ r \\ n for new lines .", "partition": "test"}
{"idx": "4000", "code": "private String processLogoutRequest(LogoutState t,LogoutRequest logoutRequest,SessionManager sessionManager) throws SamlServiceException {\n  String sessionId=null;\n  List<SessionIndex> sessionList=logoutRequest.getSessionIndexes();\n  Validate.notNull(sessionList,\"sessionList\");\n  Validate.isTrue(sessionList.size() > 0);\n  for (  SessionIndex sessionIndex : sessionList) {\n    Validate.notNull(sessionIndex);\n    String participantSession=sessionIndex.getSessionIndex();\n    Validate.notNull(participantSession,\"participantSession\");\n    Session session=sessionManager.getByParticipant(participantSession);\n    if (session == null) {\n      throw new SamlServiceException(\"Server session not found\");\n    }\n    if (!session.containsSessionParticipantUrl(t.getIssuerValue())) {\n      throw new SamlServiceException(\"Issuer URL does not match session participant URL\");\n    }\n    if (sessionId == null) {\n      sessionId=session.getId();\n    }\n else {\n      if (!sessionId.equals(session.getId())) {\n        throw new SamlServiceException(\"Participant requested multiple server sessions to be terminated\");\n      }\n    }\n  }\n  return sessionId;\n}\n", "docstring": "process logoutrequest return the session found or throw samlserviceexception", "partition": "test"}
{"idx": "4001", "code": "public boolean equals(Object o){\n  if (o instanceof CoverageIntVdt) {\n    CoverageIntVdt civ=(CoverageIntVdt)o;\n    return ((attribute == civ.attribute) && (value == civ.value));\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "override the equals method . two coverageintvdts are equal if and only iff their respective attribute and value members are equal .", "partition": "test"}
{"idx": "4002", "code": "public void accept(final Path file) throws InterruptedException {\n  logger.info(String.format(\"Sending to thread pool; will queue if full: \\\"%s\\\".\",file));\n  permits.acquire();\n  executor.execute(new ConsumerTask(file));\n}\n", "docstring": "consume a file . jobs are put in an bounded queue and executed in serial , in a separate thread . this method blocks when the queue bound is reached to avoid flooding the consumer .", "partition": "test"}
{"idx": "4003", "code": "private Activity checkActivity(){\n  Activity activity=mActivity.get();\n  if (activity == null) {\n    throw new IllegalStateException(\"No activity set. Either subclass PermisoActivity or call Permiso.setActivity() in onCreate() and onResume() of your Activity.\");\n  }\n  return activity;\n}\n", "docstring": "ensures that our weakreference to the activity is still valid . if it isn \"'\" t , throw an exception saying that the activity needs to be set .", "partition": "test"}
{"idx": "4004", "code": "@Override public synchronized void start(){\n  LOGGER.info(\"Starting the C2MON alive timer mechanism.\");\n  timer=new Timer(\"C2MON-alive-timer\");\n  timer.schedule(this,INITIAL_SCAN_DELAY,SCAN_INTERVAL);\n  running=true;\n}\n", "docstring": "starts the timer . alive timers will be checked from then on .", "partition": "test"}
{"idx": "4005", "code": "public boolean isLandingPage(URL url){\n  if (url.getQuery() != null) {\n    return false;\n  }\n else {\n    return landingPageSuffix(url) != \"\";\n  }\n}\n", "docstring": "calculates whether the url is a landing page or not", "partition": "test"}
{"idx": "4006", "code": "protected static void writeRowCountDefinitions(TableCreator creator,ByteBuffer buffer){\n  writeRowCountDefinitions(creator,buffer,creator.getIndexCount());\n}\n", "docstring": "writes the index row count definitions into a table definition buffer .", "partition": "test"}
{"idx": "4007", "code": "public void init(){\n  _tokenMgmtExecutor.scheduleWithFixedDelay(new ExpiredTokenCleaner(),1,_maxLifeValuesHolder.getMaxTokenIdleTimeInMins(),TimeUnit.MINUTES);\n  _tokenMgmtExecutor.scheduleWithFixedDelay(new TokenKeysUpdater(),1,FOREIGN_TOKEN_KEYS_BUNDLE_REFRESH_RATE_IN_MINS,TimeUnit.MINUTES);\n}\n", "docstring": "initializer , startup the background expired token deletion thread and key updater thread ( no op unless multi vdc )", "partition": "test"}
{"idx": "4008", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return PATH;\ncase 2:\n  return OFFSET_LBA;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "4009", "code": "public String toString(){\n  return \"BeanMap<\" + String.valueOf(bean) + \">\";\n}\n", "docstring": "renders a string representation of this object .", "partition": "test"}
{"idx": "4010", "code": "private void sign(final byte[] contentBytes,final ByteArrayOutputStream mimeContent) throws Exception {\n  String algId=conf.getSignatureAlgorithmId();\n  String keyId=conf.getActiveSigningKey();\n  log.debug(\"Signing directory with signing key \'{}\' \" + \"and signing algorithm \'{}\'\",keyId,algId);\n  String signature=signHelper(keyId,algId,contentBytes);\n  mimeContent.write(envelopeHeader.getBytes());\n  try (MultipartEncoder encoder=new MultipartEncoder(mimeContent,envelopeBoundary)){\n    encoder.startPart(mpMixedContentType(dataBoundary));\n    encoder.write(contentBytes);\n    String algURI=CryptoUtils.getSignatureAlgorithmURI(algId);\n    String hashURI=hashCalculator.getAlgoURI();\n    Path verificatioCertPath=conf.getCertPath(keyId);\n    encoder.startPart(MimeTypes.BINARY,new String[]{HEADER_CONTENT_TRANSFER_ENCODING + \": base64\",HEADER_SIG_ALGO_ID + \": \" + algURI,HEADER_VERIFICATION_CERT_HASH + \": \" + getVerificationCertHash(verificatioCertPath)+ \"; \"+ HEADER_HASH_ALGORITHM_ID+ \"=\"+ hashURI});\n    encoder.write(signature.getBytes());\n  }\n   log.debug(\"Generated signed directory:\\n{}\\n\",mimeContent.toString());\n  Files.write(tempConfPath,mimeContent.toByteArray());\n  log.debug(\"Written signed directory to \'{}\'\",tempConfPath);\n}\n", "docstring": "signs the global configuration directory content .", "partition": "test"}
{"idx": "4011", "code": "private boolean nextItemIs(String match) throws IOException {\n  int c;\n  while (isWhiteSpace(c=buf.get())) {\n  }\n  for (int i=0; i < match.length(); i++) {\n    if (i > 0) {\n      c=buf.get();\n    }\n    if (c != match.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "requires the next few characters ( after whitespace ) to match the argument .", "partition": "test"}
{"idx": "4012", "code": "public static Object deserializeObject(final byte[] objBytes,final ClassLoader loader) throws IOException, ClassNotFoundException {\n  ObjectInputStream objIn=null;\n  try {\n    objIn=new ClassLoaderObjectInputStream(new ByteArrayInputStream(objBytes),loader);\n    return objIn.readObject();\n  }\n  finally {\n    close(objIn);\n  }\n}\n", "docstring": "convenience method to de - serialize a byte array back into an object who \"'\" s class type is resolved by the specific classloader . < p / >", "partition": "test"}
{"idx": "4013", "code": "public IntervalImpl(int serialNum,long startIntervalDateTime,double coverageFactor,FramingFlowType intervalDataType,ISource source,IIntervalClassification intervalClassification,Version adeVersion) throws AdeInternalException {\n  a_adeVersion=adeVersion;\n  if (startIntervalDateTime < 0) {\n    throw new IllegalArgumentException(String.format(\"Interval start time must be \" + \"greater than 0! Failed creating new interval with parameters: serialNum=%d, \" + \"startIntervalDateTime=%d, coverageFactor=%s, intervalDataType=%s, source=%s, \"+ \"intervalClassification=%s, adeVersion=%s\",serialNum,startIntervalDateTime,coverageFactor,intervalDataType,source,intervalClassification,adeVersion));\n  }\n  m_startIntervalTime=startIntervalDateTime;\n  m_framingFlowType=intervalDataType;\n  m_serialNum=serialNum;\n  m_intervalClassification=intervalClassification;\n  if (m_intervalClassification == null) {\n    m_intervalClassification=IntervalClassificationEnum.REGULAR;\n  }\n  m_messageSummaryMap=new TreeMap<Integer,IMessageSummary>();\n  m_endIntervalTime=m_startIntervalTime + m_framingFlowType.getDuration();\n  m_source=source;\n  if (coverageFactor <= 0 || coverageFactor > 1) {\n    throw new AdeInternalException(\"Interval coverage factor must be between 0 (exclusive) and 1 (inclusive), but currently is: \" + coverageFactor);\n  }\n  m_coverageFactor=coverageFactor;\n}\n", "docstring": "this is used to build partial intervals .", "partition": "test"}
{"idx": "4014", "code": "public static boolean isTrue(Map<String,Object> dict,String key){\n  return isTrue(dict,key,false);\n}\n", "docstring": "returns true if the dictionary contains true for the given key or false if no value is defined for the key .", "partition": "test"}
{"idx": "4015", "code": "protected ShoppingCartItem(){\n}\n", "docstring": "cannot create shopping cart item with no parameters", "partition": "test"}
{"idx": "4016", "code": "private void initMapLayer(){\n  float zoom=getInitZoom(mapView.getWidth(),mapView.getHeight(),image.getWidth(),image.getHeight());\n  Log.i(TAG,Float.toString(zoom));\n  mapView.setCurrentZoom(zoom,0,0);\n  float width=mapView.getWidth() - zoom * image.getWidth();\n  float height=mapView.getHeight() - zoom * image.getHeight();\n  mapView.translate(width / 2,height / 2);\n}\n", "docstring": "init map image layer", "partition": "test"}
{"idx": "4017", "code": "public static double sampleSkew(int size,double moment3,double sampleVariance){\n  int n=size;\n  double s=Math.sqrt(sampleVariance);\n  double m3=moment3 * n;\n  return n * m3 / ((n - 1) * (n - 2) * s* s* s);\n}\n", "docstring": "returns the sample skew of a data sequence . ref : r . r . sokal , f . j . rohlf , biometry : the principles and practice of statistics in biological research ( w . h . freeman and company , new york , 1998 , 3rd edition ) p . 114 - 115 .", "partition": "test"}
{"idx": "4018", "code": "private String extractSpan(String spans,int start,int end) throws IndexOutOfBoundsException {\n  int offset=getFirstSpanOffset(spans);\n  assert (start >= offset);\n  assert (end >= offset);\n  spans+=HTML_OPEN_SPAN;\n  int substart=getSpanPos(spans,start - offset);\n  int subend=getSpanPos(spans,end - offset + 1);\n  return spans.substring(substart,subend);\n}\n", "docstring": "helper function for uploadnewnertask2 : extract certain token spans from the html token spans that the crowdflower job task1 uses to display a text fragment . it is used to cut out a named entity from html token spans .", "partition": "test"}
{"idx": "4019", "code": "public void finished(long chainLength){\n  currentState=chainLength;\n  if (loggers != null) {\n    for (    Logger logger : loggers) {\n      logger.log(currentState);\n      logger.stopLogging();\n    }\n  }\n  if (showOperatorAnalysis) {\n    showOperatorAnalysis(System.out);\n  }\n  if (operatorAnalysisFile != null) {\n    try {\n      PrintStream out=new PrintStream(new FileOutputStream(operatorAnalysisFile));\n      showOperatorAnalysis(out);\n      out.flush();\n      out.close();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "cleans up when the chain finishes ( possibly early ) .", "partition": "test"}
{"idx": "4020", "code": "protected void positiveClose(){\n  freeContent();\n}\n", "docstring": "method stub for sub classes do not call from fxdialog e . g . when a user press the \" ok \" button", "partition": "test"}
{"idx": "4021", "code": "public InputStreamReader(java.io.InputStream is,java.lang.String enc) throws java.io.UnsupportedEncodingException {\n  internal=is;\n  this.enc=enc.intern();\n}\n", "docstring": "create an inputstreamreader that uses the named character encoding . is - an inputstreamenc - the name of a supported character encoding - if the named encoding is not supported", "partition": "test"}
{"idx": "4022", "code": "public int serverDelivery(Object message,Object consumer,int deliveryCount) throws Exception {\n  ProtonServerSenderContext protonSender=serverSenders.get(consumer);\n  if (protonSender != null) {\n    return protonSender.deliverMessage(message,deliveryCount);\n  }\n  return 0;\n}\n", "docstring": "the consumer object from the broker or the key used to store the sender", "partition": "test"}
{"idx": "4023", "code": "public static String decode(AbstractMessage msg,Boolean ext,int header){\n  if (ext == false) {\n    return decode(msg);\n  }\n  return \"Bootloader Message Type: \" + header;\n}\n", "docstring": "return a string representation of a decoded cbus message", "partition": "test"}
{"idx": "4024", "code": "private Instance votedReclassifyExample(Instance example) throws Exception {\n  int classVotes[]=new int[getNumClasses()];\n  for (int i=0; i < classVotes.length; i++) {\n    classVotes[i]=0;\n  }\n  for (Enumeration<RuleList> e=new WekaEnumeration<RuleList>(m_DecisionList); e.hasMoreElements(); ) {\n    RuleList rl=e.nextElement();\n    int classValue=(int)rl.classifyInstance(example);\n    if (classValue >= 0) {\n      classVotes[classValue]++;\n    }\n  }\n  int maxVote=0;\n  int vote=-1;\n  for (int i=0; i < classVotes.length; i++) {\n    if (classVotes[i] > maxVote) {\n      maxVote=classVotes[i];\n      vote=i;\n    }\n  }\n  if (vote >= 0) {\n    example.setClassValue(vote);\n  }\n else {\n    throw new Exception(\"Error in instance classification.\");\n  }\n  return example;\n}\n", "docstring": "classify example with maximum vote the following way . with every rule in the decisionlist , it is evaluated if the given instance could be the class of the rule . finally the class value that receives the highest number of votes is assigned to the example .", "partition": "test"}
{"idx": "4025", "code": "public final int hashCode(){\n  return System.identityHashCode(this);\n}\n", "docstring": "the hash code for all sunhints . value objects will be the same as the system identity code of the object as defined by the system . identityhashcode ( ) method .", "partition": "test"}
{"idx": "4026", "code": "private BigQueryIO(){\n}\n", "docstring": "disallow construction of utility class .", "partition": "test"}
{"idx": "4027", "code": "private boolean keyChainContainsPrivateKey(Collection<ECKey> keyChain,ECKey keyToAdd){\n  if (keyChain == null || keyToAdd == null) {\n    return false;\n  }\n else {\n    for (    ECKey loopKey : keyChain) {\n      if (Arrays.equals(keyToAdd.getPrivKeyBytes(),loopKey.getPrivKeyBytes())) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n", "docstring": "this method is here because there is no equals on eckey .", "partition": "test"}
{"idx": "4028", "code": "public ScriptBuilder data(byte[] data){\n  if (data.length == 0)   return smallNum(0);\n else   return data(chunks.size(),data);\n}\n", "docstring": "adds a copy of the given byte array as a data element ( i . e . pushdata ) at the end of the program .", "partition": "test"}
{"idx": "4029", "code": "private void writeUserRegistry(LocalContainer container,File configDir,Map<String,String> users,Map<String,List<String>> groups) throws IOException {\n  File usersXML=new File(configDir,\"cargo-users.xml\");\n  PrintStream writer=ServerConfigUtils.open(usersXML);\n  writer.println(\"  <basicRegistry id=\\\"basic\\\">\");\n  for (  Map.Entry<String,String> user : users.entrySet()) {\n    writer.print(\"    <user name=\\\"\");\n    writer.print(user.getKey());\n    writer.print(\"\\\" password=\\\"\");\n    writer.print(user.getValue());\n    writer.println(\"\\\"/>\");\n  }\n  for (  Map.Entry<String,List<String>> group : groups.entrySet()) {\n    writer.print(\"    <group name=\\\"\");\n    writer.print(group.getKey());\n    writer.println(\"\\\">\");\n    for (    String member : group.getValue()) {\n      writer.print(\"      <member name=\\\"\");\n      writer.print(member);\n      writer.println(\"\\\"/>\");\n    }\n    writer.println(\"    </group>\");\n  }\n  writer.println(\"  </basicRegistry>\");\n  ServerConfigUtils.close(writer);\n}\n", "docstring": "this method writes a user registry xml", "partition": "test"}
{"idx": "4030", "code": "@GenIgnore static Record createRecord(String name,String address,Class itf,JsonObject metadata){\n  return createRecord(name,address,itf.getName(),metadata);\n}\n", "docstring": "sugar method to creates a record for this type . < p > the java interface is added to the metadata in the ` service . interface ` key .", "partition": "test"}
{"idx": "4031", "code": "public StopwatchCPU(){\n  threadTimer=ManagementFactory.getThreadMXBean();\n  start=threadTimer.getCurrentThreadCpuTime();\n}\n", "docstring": "initializes a new stopwatch .", "partition": "test"}
{"idx": "4032", "code": "public synchronized byte[] lookupAudio(String inputtype,String locale,String voice,String outputparams,String style,String effects,String inputtext) throws SQLException {\n  if (inputtype == null || locale == null || voice == null || inputtext == null) {\n    throw new NullPointerException(\"Null argument\");\n  }\n  byte[] audio=null;\n  String query=\"Select outputaudio FROM marycache WHERE inputtype = \'\" + inputtype + \"\' AND outputtype = \'AUDIO\' AND locale = \'\"+ locale+ \"\' AND voice = \'\"+ voice+ \"\' AND outputparams = \'\"+ outputparams+ \"\' AND style = \'\"+ style+ \"\' AND effects = \'\"+ effects+ \"\' AND inputtext = ?\";\n  PreparedStatement st=connection.prepareStatement(query);\n  st.setString(1,inputtext);\n  ResultSet results=st.executeQuery();\n  if (results.next()) {\n    audio=results.getBytes(1);\n  }\n  return audio;\n}\n", "docstring": "carry out a lookup in the cache with the given parameters , for a request with output type audio .", "partition": "test"}
{"idx": "4033", "code": "public void addCondition(final Condition condition){\n  conditions.add(condition);\n  condition.setId(conditionIdCounter++);\n}\n", "docstring": "will add the condition to the list .", "partition": "test"}
{"idx": "4034", "code": "public static byte[] readBytesFromByteBuffer(ByteBuffer byteBuffer){\n  byte[] buffer=new byte[byteBuffer.remaining()];\n  byteBuffer.get(buffer);\n  return buffer;\n}\n", "docstring": "reads the remaining bytes in a bytebuffer into a byte [ ", "partition": "test"}
{"idx": "4035", "code": "public void findPackageAndClass() throws IOException {\n  packageName=null;\n  className=null;\n  LineNumberReader reader=new LineNumberReader(new FileReader(inputFile));\n  try {\n    while (className == null || packageName == null) {\n      String line=reader.readLine();\n      if (line == null)       break;\n      if (packageName == null) {\n        Matcher matcher=PACKAGE_PATTERN.matcher(line);\n        if (matcher.find()) {\n          packageName=matcher.group(1);\n        }\n      }\n      if (className == null) {\n        Matcher matcher=CLASS_PATTERN.matcher(line);\n        if (matcher.find()) {\n          className=matcher.group(1);\n        }\n      }\n    }\n    if (className == null) {\n      className=\"Yylex\";\n    }\n  }\n  finally {\n    reader.close();\n  }\n}\n", "docstring": "peek into . flex file to get package and class name", "partition": "test"}
{"idx": "4036", "code": "public static Set<URI> fetchRPTargetVirtualPools(DbClient dbClient){\n  Set<URI> rpProtectedTargetVPools=new HashSet<URI>();\n  try {\n    List<URI> vpoolProtectionSettingsURIs=dbClient.queryByType(VpoolProtectionVarraySettings.class,true);\n    Iterator<VpoolProtectionVarraySettings> vPoolProtectionSettingsItr=dbClient.queryIterativeObjects(VpoolProtectionVarraySettings.class,vpoolProtectionSettingsURIs,true);\n    while (vPoolProtectionSettingsItr.hasNext()) {\n      VpoolProtectionVarraySettings rSetting=vPoolProtectionSettingsItr.next();\n      if (null != rSetting && !NullColumnValueGetter.isNullURI(rSetting.getVirtualPool())) {\n        rpProtectedTargetVPools.add(rSetting.getVirtualPool());\n      }\n    }\n  }\n catch (  Exception ex) {\n    _log.error(\"Exception occurred while fetching RP enabled virtualpools\",ex);\n  }\n  return rpProtectedTargetVPools;\n}\n", "docstring": "fetch the rp protected target virtual pool uris .", "partition": "test"}
{"idx": "4037", "code": "public int cardinality(){\n  int sum=0;\n  for (  long l : this.data)   sum+=Long.bitCount(l);\n  return sum;\n}\n", "docstring": "compute the number of bits set to 1", "partition": "test"}
{"idx": "4038", "code": "private String deEscapeLiteral(String lit){\n  return lit.replaceAll(\"\\\\\\\\\\\"\",\"\\\"\");\n}\n", "docstring": "de - escapes a literal . the only escaped character processed is the double quotation mark .", "partition": "test"}
{"idx": "4039", "code": "public static void i(String msg,Object... args){\n  if (!allowI)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "docstring": "send an info log message", "partition": "test"}
{"idx": "4040", "code": "public DNewKeyStoreType(JFrame parent){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  setTitle(res.getString(\"DNewKeyStoreType.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dnewkeystoretype dialog .", "partition": "test"}
{"idx": "4041", "code": "private int insertTestDataLocalDTTypes(PreparedStatement pstmt) throws Exception {\n  pstmt.setInt(1,1);\n  pstmt.setDate(2,testSqlDate);\n  pstmt.setTime(3,testSqlTime);\n  pstmt.setTimestamp(4,testSqlTimeStamp);\n  pstmt.setTimestamp(5,testSqlTimeStamp);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,2);\n  pstmt.setObject(2,testLocalDate);\n  pstmt.setObject(3,testLocalTime);\n  pstmt.setObject(4,testLocalDateTime);\n  pstmt.setObject(5,testLocalDateTime);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,3);\n  pstmt.setObject(2,testLocalDate,JDBCType.DATE);\n  pstmt.setObject(3,testLocalTime,JDBCType.TIME);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.TIMESTAMP);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.TIMESTAMP);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,4);\n  pstmt.setObject(2,testLocalDate,JDBCType.DATE,10);\n  pstmt.setObject(3,testLocalTime,JDBCType.TIME,8);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.TIMESTAMP,20);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.TIMESTAMP,20);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,5);\n  pstmt.setObject(2,testLocalDate,JDBCType.VARCHAR);\n  pstmt.setObject(3,testLocalTime,JDBCType.VARCHAR);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.VARCHAR);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.VARCHAR);\n  assertEquals(1,pstmt.executeUpdate());\n  pstmt.setInt(1,6);\n  pstmt.setObject(2,testLocalDate,JDBCType.VARCHAR,10);\n  pstmt.setObject(3,testLocalTime,JDBCType.VARCHAR,8);\n  pstmt.setObject(4,testLocalDateTime,JDBCType.VARCHAR,20);\n  pstmt.setObject(5,testLocalDateTime,JDBCType.VARCHAR,20);\n  assertEquals(1,pstmt.executeUpdate());\n  if (pstmt instanceof CallableStatement) {\n    CallableStatement cstmt=(CallableStatement)pstmt;\n    cstmt.setInt(\"id\",7);\n    cstmt.setDate(\"d\",testSqlDate);\n    cstmt.setTime(\"t\",testSqlTime);\n    cstmt.setTimestamp(\"dt\",testSqlTimeStamp);\n    cstmt.setTimestamp(\"ts\",testSqlTimeStamp);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",8);\n    cstmt.setObject(\"d\",testLocalDate);\n    cstmt.setObject(\"t\",testLocalTime);\n    cstmt.setObject(\"dt\",testLocalDateTime);\n    cstmt.setObject(\"ts\",testLocalDateTime);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",9);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.DATE);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.TIME);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.TIMESTAMP);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.TIMESTAMP);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",10);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.DATE,10);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.TIME,8);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.TIMESTAMP,20);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.TIMESTAMP,20);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",11);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.VARCHAR);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.VARCHAR);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.VARCHAR);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.VARCHAR);\n    assertEquals(1,cstmt.executeUpdate());\n    cstmt.setInt(\"id\",12);\n    cstmt.setObject(\"d\",testLocalDate,JDBCType.VARCHAR,10);\n    cstmt.setObject(\"t\",testLocalTime,JDBCType.VARCHAR,8);\n    cstmt.setObject(\"dt\",testLocalDateTime,JDBCType.VARCHAR,20);\n    cstmt.setObject(\"ts\",testLocalDateTime,JDBCType.VARCHAR,20);\n    assertEquals(1,cstmt.executeUpdate());\n    return 12;\n  }\n  return 6;\n}\n", "docstring": "helper method for * setobject * tests . insert data into the given preparedstatement , or any of its subclasses , with the following structure : 1 - ` id ` int 2 - ` d ` date ( or any kind of * char ) 3 - ` t ` time ( or any kind of * char ) 4 - ` dt ` datetime ( or any kind of * char ) 5 - ` ts ` timestamp ( or any kind of * char )", "partition": "test"}
{"idx": "4042", "code": "public void removeListener(final L listener){\n  Validate.notNull(listener,\"Listener object cannot be null.\");\n  listeners.remove(listener);\n}\n", "docstring": "unregisters an event listener .", "partition": "test"}
{"idx": "4043", "code": "public void run(){\n  start();\n  try {\n    while (true) {\n      Thread.sleep(interval);\n      processConfigMessages();\n    }\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n    log.warn(\"Got interrupt in config manager thread, so shutting down\");\n  }\n finally {\n    log.info(\"Stopping the config manager\");\n    stop();\n  }\n}\n", "docstring": "this method is an infinite loop that periodically checks if there are any new messages in the job coordinator stream , and reads them if they exist . then it reacts accordingly based on the configuration that is being set . the method the calls the start ( ) method to initialized the system , runs in a infinite loop , and calls the stop ( ) method at the end to stop the consumer and the system", "partition": "test"}
{"idx": "4044", "code": "private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getName(),getMask(actions));\n}\n", "docstring": "readobject is called to restore the state of the servicepermission from a stream .", "partition": "test"}
{"idx": "4045", "code": "public int predBlockIndexForSourcesIndex(int sourcesIndex){\n  return operands.get(sourcesIndex).blockIndex;\n}\n", "docstring": "gets the index of the pred block associated with the registerspec at the particular getsources ( ) index .", "partition": "test"}
{"idx": "4046", "code": "void appendProgramDescription(final WrappingStringBuilder wb){\n  if (!mProgramDescription.equals(\"\")) {\n    wb.append(LS);\n    wb.setWrapIndent(0);\n    wb.wrapTextWithNewLines(mProgramDescription);\n  }\n}\n", "docstring": "append the description text for this program , if one exists .", "partition": "test"}
{"idx": "4047", "code": "public static byte[] decode(String s) throws java.io.IOException {\n  return decode(s,NO_OPTIONS);\n}\n", "docstring": "decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .", "partition": "test"}
{"idx": "4048", "code": "@SuppressWarnings(\"deprecation\") private static final URL toURL(String location,boolean file){\n  if (file) {\n    File f=new File(location);\n    if (f.exists()) {\n      try {\n        return f.toURL();\n      }\n catch (      MalformedURLException murl) {\n        return null;\n      }\n    }\n else {\n      return null;\n    }\n  }\n else {\n    return getURL(location);\n  }\n}\n", "docstring": "makes a url out of a location , as either a file or a resource .", "partition": "test"}
{"idx": "4049", "code": "protected Object parseValue(String string){\n  int openParen=string.indexOf(\"(\");\n  String type=string.substring(0,openParen);\n  String value=string.substring(openParen + 1,string.length() - 1);\n  if (type.equals(\"String\")) {\n    return value;\n  }\n else   if (type.equals(\"Float\")) {\n    return new Float(Float.parseFloat(value));\n  }\n else   if (type.equals(\"Integer\")) {\n    return new Integer(Integer.parseInt(value));\n  }\n else   if (type.equals(\"List\")) {\n    StringTokenizer tok=new StringTokenizer(value,\",\");\n    int size=tok.countTokens();\n    int[] values=new int[size];\n    for (int i=0; i < size; i++) {\n      float fval=Float.parseFloat(tok.nextToken());\n      values[i]=Math.round(fval);\n    }\n    return values;\n  }\n else {\n    throw new Error(\"Unknown type: \" + type);\n  }\n}\n", "docstring": "coerces a string into a value .", "partition": "test"}
{"idx": "4050", "code": "@Override public void update(List<EnvVar> dataList){\n  envVarList.clear();\n  if (dataList == null) {\n    for (    EnvVar envVar : builtInEnvVarMap.values()) {\n      envVarList.add(envVar);\n    }\n  }\n else {\n    for (    EnvVar envVar : dataList) {\n      if (builtInEnvVarMap.containsKey(envVar.getName())) {\n        envVarList.add(new EnvVar(envVar,true));\n      }\n else {\n        envVarList.add(new EnvVar(envVar,false));\n      }\n    }\n  }\n  setEnvironmentVariableValues();\n}\n", "docstring": "update the environment variables .", "partition": "test"}
{"idx": "4051", "code": "public void makeClass(String str,boolean caseless){\n  for (int i=0; i < str.length(); i++)   makeClass(str.charAt(i),caseless);\n}\n", "docstring": "creates a new character class for each character of the specified string .", "partition": "test"}
{"idx": "4052", "code": "protected void notifyTimestampsToGateways(EntryEventImpl event){\n  VersionTagHolder updateTimeStampEvent=new VersionTagHolder(event.getVersionTag());\n  updateTimeStampEvent.setOperation(Operation.UPDATE_VERSION_STAMP);\n  updateTimeStampEvent.setKeyInfo(event.getKeyInfo());\n  updateTimeStampEvent.setGenerateCallbacks(false);\n  updateTimeStampEvent.distributedMember=event.getDistributedMember();\n  updateTimeStampEvent.setNewEventId(getSystem());\n  if (event.getRegion() instanceof BucketRegion) {\n    BucketRegion br=(BucketRegion)event.getRegion();\n    PartitionedRegion pr=br.getPartitionedRegion();\n    updateTimeStampEvent.setRegion(pr);\n    if (pr.isParallelWanEnabled()) {\n      br.handleWANEvent(updateTimeStampEvent);\n    }\n    if (pr.isInitialized()) {\n      pr.notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,updateTimeStampEvent);\n    }\n  }\n else {\n    updateTimeStampEvent.setRegion(event.getRegion());\n    notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,updateTimeStampEvent);\n  }\n}\n", "docstring": "this notifies all wan sites about updated timestamp on local site .", "partition": "test"}
{"idx": "4053", "code": "public Token nextRegex(Pattern pattern){\n  if (!hasNextRegex(pattern))   throw new IllegalStateException(\"No more occurrences found!\");\n  Matcher matcher=anyMentionPattern.matcher(remaining);\n  if (!matcher.find())   throw new IllegalStateException(\"Couldn\'t find any matches!\");\n  final int start=currentPosition + matcher.start();\n  final int end=currentPosition + matcher.end();\n  stepTo(end);\n  return new Token(this,start,end);\n}\n", "docstring": "returns the next occurrence of the regular expression , stepping forward the tokenizer to the next line .", "partition": "test"}
{"idx": "4054", "code": "public String asString() throws IOException {\n  long len=getContentLength();\n  ByteArrayOutputStream buf;\n  if (0 < len) {\n    buf=new ByteArrayOutputStream((int)len);\n  }\n else {\n    buf=new ByteArrayOutputStream();\n  }\n  writeTo(buf);\n  return decode(buf.toByteArray(),getCharacterEncoding());\n}\n", "docstring": "return a copy of the result as a string . < p > the default version of this method copies the result into a temporary byte array and then tries to decode it using the configured encoding .", "partition": "test"}
{"idx": "4055", "code": "public void execute() throws IOException {\n  String key=\"mqtt-\" + (System.currentTimeMillis() / 1000);\n  String b64Key=Base64.encode(key);\n  sendHandshakeRequest(b64Key);\n  receiveHandshakeResponse(b64Key);\n}\n", "docstring": "executes a websocket handshake . will throw an ioexception if the handshake fails", "partition": "test"}
{"idx": "4056", "code": "public void calculateMin(double min){\n  if (this.min == -1) {\n    this.min=min;\n  }\n else {\n    this.min=Math.min(this.min,min);\n  }\n}\n", "docstring": "sets the minimum and deals with the - 1 initialization ! .", "partition": "test"}
{"idx": "4057", "code": "private void emitUntil(@Nonnegative int taskCountAllowed) throws IOException {\n  try {\n    while (emitQueue.size() > taskCountAllowed) {\n      Future<byte[]> future=emitQueue.remove();\n      byte[] toWrite=future.get();\n      blockSizes.add(toWrite.length);\n      out.write(toWrite);\n    }\n    tryEmit();\n  }\n catch (  ExecutionException e) {\n    throw new IOException(e);\n  }\ncatch (  InterruptedException e) {\n    throw new InterruptedIOException();\n  }\n}\n", "docstring": "emits any opportunistically available blocks . furthermore , emits blocks until the number of executing tasks is less than taskcountallowed .", "partition": "test"}
{"idx": "4058", "code": "public void testAuditCompleted(){\n}\n", "docstring": "test of auditcompleted method , of class auditservicethreadqueueimpl .", "partition": "test"}
{"idx": "4059", "code": "public static void scaleRectAboutCenter(Rect r,float scale){\n  if (scale != 1.0f) {\n    int cx=r.centerX();\n    int cy=r.centerY();\n    r.offset(-cx,-cy);\n    r.left=(int)(r.left * scale + 0.5f);\n    r.top=(int)(r.top * scale + 0.5f);\n    r.right=(int)(r.right * scale + 0.5f);\n    r.bottom=(int)(r.bottom * scale + 0.5f);\n    r.offset(cx,cy);\n  }\n}\n", "docstring": "scales a rect about its centroid", "partition": "test"}
{"idx": "4060", "code": "private static CharHandler parseUnprintableExtCodes(String[] codeStrings){\n  if (codeStrings.length != 1) {\n    throw new IllegalStateException(\"Unexpected code strings \" + Arrays.asList(codeStrings));\n  }\n  byte[] bytes=codesToBytes(codeStrings[0],true);\n  if (bytes.length != 1) {\n    throw new IllegalStateException(\"Unexpected code strings \" + Arrays.asList(codeStrings));\n  }\n  return new UnprintableExtCharHandler(bytes[0]);\n}\n", "docstring": "returns a unprintableextcharhandler parsed from the given index code strings .", "partition": "test"}
{"idx": "4061", "code": "public void updatePendingList(){\n  while (mPendingList.size() > 0 && activeListHasRoom()) {\n    DownloadInfoRunnable pending=mPendingList.get(0);\n    pending.changeStatusState(new ActiveState(pending));\n  }\n}\n", "docstring": "check if there are pending downloads and if so move the top one up to the active list .", "partition": "test"}
{"idx": "4062", "code": "@SuppressWarnings(\"unused\") public static float valueRangeLimit(float value,float startValue,float endValue){\n  if (value < Math.min(startValue,endValue))   return Math.min(startValue,endValue);\n  if (value > Math.max(startValue,endValue))   return Math.max(startValue,endValue);\n  return value;\n}\n", "docstring": "limit number within a values range . this method not consider the sign and the upper and lower values limit order .", "partition": "test"}
{"idx": "4063", "code": "public static boolean isConnected(NetType netType,NetworkInfo networkInfo){\n  if (netType == NetType.Any && networkInfo != null && isConnected(networkInfo))   return true;\n else   if (netType == NetType.Wifi && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo))   return true;\n else   if (netType == NetType.Mobile && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo))   return true;\n  return false;\n}\n", "docstring": "according to the different type of network to determine whether the network connection .", "partition": "test"}
{"idx": "4064", "code": "public void deleteItem(int position){\n  if (!isDataListEmpty() && position >= 0 && position < mDataList.size()) {\n    mDataList.remove(position);\n    notifyItemRemoved(position);\n  }\n}\n", "docstring": "delete an item by position", "partition": "test"}
{"idx": "4065", "code": "private int calculateGraidentChannel(int sourceChannel,int destChannel,int distance,int offset){\n  if (sourceChannel == destChannel) {\n    return sourceChannel;\n  }\n  float ratio=((float)offset) / ((float)distance);\n  int pos=(int)(Math.abs(sourceChannel - destChannel) * ratio);\n  if (sourceChannel > destChannel) {\n    return sourceChannel - pos;\n  }\n else {\n    return sourceChannel + pos;\n  }\n}\n", "docstring": "converts the color channel value according to the offest within the distance", "partition": "test"}
{"idx": "4066", "code": "private void applyImageMatrix(float width,float height,boolean center,boolean animate){\n  if (mBitmap != null && width > 0 && height > 0) {\n    mImageMatrix.reset();\n    mImageMatrix.postTranslate((width - mBitmap.getWidth()) / 2,(height - mBitmap.getHeight()) / 2);\n    mapImagePointsByImageMatrix();\n    if (mDegreesRotated > 0) {\n      mImageMatrix.postRotate(mDegreesRotated,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n      mapImagePointsByImageMatrix();\n    }\n    float scale=Math.min(width / BitmapUtils.getRectWidth(mImagePoints),height / BitmapUtils.getRectHeight(mImagePoints));\n    if (mScaleType == ScaleType.FIT_CENTER || (mScaleType == ScaleType.CENTER_INSIDE && scale < 1) || (scale > 1 && mAutoZoomEnabled)) {\n      mImageMatrix.postScale(scale,scale,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n      mapImagePointsByImageMatrix();\n    }\n    mImageMatrix.postScale(mZoom,mZoom,BitmapUtils.getRectCenterX(mImagePoints),BitmapUtils.getRectCenterY(mImagePoints));\n    mapImagePointsByImageMatrix();\n    RectF cropRect=mCropOverlayView.getCropWindowRect();\n    cropRect.offset(-mZoomOffsetX * mZoom,-mZoomOffsetY * mZoom);\n    if (center) {\n      mZoomOffsetX=width > BitmapUtils.getRectWidth(mImagePoints) ? 0 : Math.max(Math.min(width / 2 - cropRect.centerX(),-BitmapUtils.getRectLeft(mImagePoints)),getWidth() - BitmapUtils.getRectRight(mImagePoints)) / mZoom;\n      mZoomOffsetY=height > BitmapUtils.getRectHeight(mImagePoints) ? 0 : Math.max(Math.min(height / 2 - cropRect.centerY(),-BitmapUtils.getRectTop(mImagePoints)),getHeight() - BitmapUtils.getRectBottom(mImagePoints)) / mZoom;\n    }\n else {\n      mZoomOffsetX=Math.min(Math.max(mZoomOffsetX * mZoom,-cropRect.left),-cropRect.right + width) / mZoom;\n      mZoomOffsetY=Math.min(Math.max(mZoomOffsetY * mZoom,-cropRect.top),-cropRect.bottom + height) / mZoom;\n    }\n    mImageMatrix.postTranslate(mZoomOffsetX * mZoom,mZoomOffsetY * mZoom);\n    cropRect.offset(mZoomOffsetX * mZoom,mZoomOffsetY * mZoom);\n    mCropOverlayView.setCropWindowRect(cropRect);\n    mapImagePointsByImageMatrix();\n    if (animate) {\n      mAnimation.setEndState(mImagePoints,mImageMatrix);\n      mImageView.startAnimation(mAnimation);\n    }\n else {\n      mImageView.setImageMatrix(mImageMatrix);\n    }\n    updateImageBounds(false);\n  }\n}\n", "docstring": "apply matrix to handle the image inside the image view .", "partition": "test"}
{"idx": "4067", "code": "public static void addStartupListener(StartUpListener s){\n  m_StartupListeners.add(s);\n}\n", "docstring": "add a listener to be notified when startup is complete .", "partition": "test"}
{"idx": "4068", "code": "public static void closeQuiet(@Nullable SelectionKey rsrc){\n  if (rsrc != null)   closeQuiet(rsrc.channel());\n}\n", "docstring": "quietly closes given resource ignoring possible checked exceptions .", "partition": "test"}
{"idx": "4069", "code": "public CompletableFuture<NewFile> run(){\n  LOG.log(Level.FINE,\"starting optimized file creation for {0} files\",files.size());\n  CompletableFuture<NewFile> fileCreation=new CompletableFuture<>();\n  final List<TSData> fjpFiles=this.files;\n  TASK_POOL.execute(null);\nsynchronized (OUTSTANDING) {\n    OUTSTANDING.add(fileCreation);\n  }\n  this.files=new LinkedList<>();\n  return fileCreation;\n}\n", "docstring": "start creating the optimized file . this operation resets the state of the optimizer task , so it can be re - used for subsequent invocations .", "partition": "test"}
{"idx": "4070", "code": "private static Key createDESKey(byte[] bytes,int offset){\n  byte[] keyBytes=new byte[7];\n  System.arraycopy(bytes,offset,keyBytes,0,7);\n  byte[] material=new byte[8];\n  material[0]=keyBytes[0];\n  material[1]=(byte)(keyBytes[0] << 7 | (keyBytes[1] & 0xff) >>> 1);\n  material[2]=(byte)(keyBytes[1] << 6 | (keyBytes[2] & 0xff) >>> 2);\n  material[3]=(byte)(keyBytes[2] << 5 | (keyBytes[3] & 0xff) >>> 3);\n  material[4]=(byte)(keyBytes[3] << 4 | (keyBytes[4] & 0xff) >>> 4);\n  material[5]=(byte)(keyBytes[4] << 3 | (keyBytes[5] & 0xff) >>> 5);\n  material[6]=(byte)(keyBytes[5] << 2 | (keyBytes[6] & 0xff) >>> 6);\n  material[7]=(byte)(keyBytes[6] << 1);\n  oddParity(material);\n  return new SecretKeySpec(material,\"DES\");\n}\n", "docstring": "creates a des encryption key from the given key material .", "partition": "test"}
{"idx": "4071", "code": "protected JsOutput newJsOutput(Module m) throws IOException {\n  return new JsOutput(m,isCompilingLanguageModule());\n}\n", "docstring": "this exists solely so that the web ide can override it and use a different jsoutput", "partition": "test"}
{"idx": "4072", "code": "public String text(){\n  StringBuilder sb=new StringBuilder();\n  for (  Node node : nodes) {\n    sb.append(node.getTextContent());\n  }\n  return sb.toString();\n}\n", "docstring": "gets the combined text contents of each element in the set of matched elements , including their descendants . text is html decoded for text nodes .", "partition": "test"}
{"idx": "4073", "code": "private boolean scanExpr(SymbolTable symbolTable,Tokens tokens,String data,int currentOffset,int endOffset) throws XNIException {\n  int ch;\n  int openParen=0;\n  int closeParen=0;\n  int nameOffset, dataOffset;\n  boolean isQName=false;\n  String name=null;\n  String prefix=null;\n  String schemeData=null;\n  StringBuffer schemeDataBuff=new StringBuffer();\n  while (true) {\n    if (currentOffset == endOffset) {\n      break;\n    }\n    ch=data.charAt(currentOffset);\n    while (ch == \' \' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n      if (++currentOffset == endOffset) {\n        break;\n      }\n      ch=data.charAt(currentOffset);\n    }\n    if (currentOffset == endOffset) {\n      break;\n    }\n    byte chartype=(ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\nswitch (chartype) {\ncase CHARTYPE_OPEN_PAREN:\n      addToken(tokens,Tokens.XPTRTOKEN_OPEN_PAREN);\n    openParen++;\n  ++currentOffset;\nbreak;\ncase CHARTYPE_CLOSE_PAREN:\naddToken(tokens,Tokens.XPTRTOKEN_CLOSE_PAREN);\ncloseParen++;\n++currentOffset;\nbreak;\ncase CHARTYPE_CARRET:\ncase CHARTYPE_COLON:\ncase CHARTYPE_DIGIT:\ncase CHARTYPE_EQUAL:\ncase CHARTYPE_LETTER:\ncase CHARTYPE_MINUS:\ncase CHARTYPE_NONASCII:\ncase CHARTYPE_OTHER:\ncase CHARTYPE_PERIOD:\ncase CHARTYPE_SLASH:\ncase CHARTYPE_UNDERSCORE:\ncase CHARTYPE_WHITESPACE:\nif (openParen == 0) {\nnameOffset=currentOffset;\ncurrentOffset=scanNCName(data,endOffset,currentOffset);\nif (currentOffset == nameOffset) {\nreportError(\"InvalidShortHandPointer\",new Object[]{data});\nreturn false;\n}\nif (currentOffset < endOffset) {\nch=data.charAt(currentOffset);\n}\n else {\nch=-1;\n}\nname=symbolTable.addSymbol(data.substring(nameOffset,currentOffset));\nprefix=XMLSymbols.EMPTY_STRING;\nif (ch == \':\') {\nif (++currentOffset == endOffset) {\nreturn false;\n}\nch=data.charAt(currentOffset);\nprefix=name;\nnameOffset=currentOffset;\ncurrentOffset=scanNCName(data,endOffset,currentOffset);\nif (currentOffset == nameOffset) {\nreturn false;\n}\nif (currentOffset < endOffset) {\nch=data.charAt(currentOffset);\n}\n else {\nch=-1;\n}\nisQName=true;\nname=symbolTable.addSymbol(data.substring(nameOffset,currentOffset));\n}\nif (currentOffset != endOffset) {\naddToken(tokens,Tokens.XPTRTOKEN_SCHEMENAME);\ntokens.addToken(prefix);\ntokens.addToken(name);\nisQName=false;\n}\n else if (currentOffset == endOffset) {\naddToken(tokens,Tokens.XPTRTOKEN_SHORTHAND);\ntokens.addToken(name);\nisQName=false;\n}\ncloseParen=0;\nbreak;\n}\n else if (openParen > 0 && closeParen == 0 && name != null) {\ndataOffset=currentOffset;\ncurrentOffset=scanData(data,schemeDataBuff,endOffset,currentOffset);\nif (currentOffset == dataOffset) {\nreportError(\"InvalidSchemeDataInXPointer\",new Object[]{data});\nreturn false;\n}\nif (currentOffset < endOffset) {\nch=data.charAt(currentOffset);\n}\n else {\nch=-1;\n}\nschemeData=symbolTable.addSymbol(schemeDataBuff.toString());\naddToken(tokens,Tokens.XPTRTOKEN_SCHEMEDATA);\ntokens.addToken(schemeData);\nopenParen=0;\nschemeDataBuff.delete(0,schemeDataBuff.length());\n}\n else {\nreturn false;\n}\n}\n}\nreturn true;\n}\n", "docstring": "scans the xpointer expression", "partition": "test"}
{"idx": "4074", "code": "public void addLine(int startLine,String sourceFile,int repeatCount,int outputLine,int outputIncrement){\n  _lines.add(new Line(startLine,sourceFile,repeatCount,outputLine,outputIncrement));\n}\n", "docstring": "adds a line from the smap", "partition": "test"}
{"idx": "4075", "code": "public String(StringBuffer stringbuffer){\n  offset=0;\nsynchronized (stringbuffer) {\n    value=stringbuffer.shareValue();\n    count=stringbuffer.length();\n  }\n}\n", "docstring": "creates a string from the contents of a stringbuffer .", "partition": "test"}
{"idx": "4076", "code": "public static Range iterateToFindDomainBounds(XYDataset dataset,List visibleSeriesKeys,boolean includeInterval){\n  ParamChecks.nullNotPermitted(dataset,\"dataset\");\n  ParamChecks.nullNotPermitted(visibleSeriesKeys,\"visibleSeriesKeys\");\n  double minimum=Double.POSITIVE_INFINITY;\n  double maximum=Double.NEGATIVE_INFINITY;\n  if (includeInterval && dataset instanceof IntervalXYDataset) {\n    IntervalXYDataset ixyd=(IntervalXYDataset)dataset;\n    Iterator iterator=visibleSeriesKeys.iterator();\n    while (iterator.hasNext()) {\n      Comparable seriesKey=(Comparable)iterator.next();\n      int series=dataset.indexOf(seriesKey);\n      int itemCount=dataset.getItemCount(series);\n      for (int item=0; item < itemCount; item++) {\n        double xvalue=ixyd.getXValue(series,item);\n        double lvalue=ixyd.getStartXValue(series,item);\n        double uvalue=ixyd.getEndXValue(series,item);\n        if (!Double.isNaN(xvalue)) {\n          minimum=Math.min(minimum,xvalue);\n          maximum=Math.max(maximum,xvalue);\n        }\n        if (!Double.isNaN(lvalue)) {\n          minimum=Math.min(minimum,lvalue);\n        }\n        if (!Double.isNaN(uvalue)) {\n          maximum=Math.max(maximum,uvalue);\n        }\n      }\n    }\n  }\n else {\n    Iterator iterator=visibleSeriesKeys.iterator();\n    while (iterator.hasNext()) {\n      Comparable seriesKey=(Comparable)iterator.next();\n      int series=dataset.indexOf(seriesKey);\n      int itemCount=dataset.getItemCount(series);\n      for (int item=0; item < itemCount; item++) {\n        double x=dataset.getXValue(series,item);\n        if (!Double.isNaN(x)) {\n          minimum=Math.min(minimum,x);\n          maximum=Math.max(maximum,x);\n        }\n      }\n    }\n  }\n  if (minimum == Double.POSITIVE_INFINITY) {\n    return null;\n  }\n else {\n    return new Range(minimum,maximum);\n  }\n}\n", "docstring": "returns the range of x - values in the specified dataset for the data items belonging to the visible series .", "partition": "test"}
{"idx": "4077", "code": "public LibertyManagerClient(){\n}\n", "docstring": "constructs the libertymanager client", "partition": "test"}
{"idx": "4078", "code": "private void checkComplianceAttributes(AttrSet attrSet,boolean ignoreCompliance) throws AMException {\n  if (!ignoreCompliance && ComplianceServicesImpl.isComplianceUserDeletionEnabled()) {\n    complianceImpl.verifyAttributes(attrSet);\n  }\n}\n", "docstring": "checks for compliance related attributes if applicable . the check can be over - ridden by setting the ignorecompliance to true", "partition": "test"}
{"idx": "4079", "code": "private void updateZoningMap(UnManagedExportMask mask,List<Initiator> initiators,List<StoragePort> storagePorts){\n  ZoneInfoMap zoningMap=networkDeviceController.getInitiatorsZoneInfoMap(initiators,storagePorts);\n  for (  ZoneInfo zoneInfo : zoningMap.values()) {\n    log.info(\"Found zone: {} for initiator {} and port {}\",new Object[]{zoneInfo.getZoneName(),zoneInfo.getInitiatorWwn(),zoneInfo.getPortWwn()});\n  }\n  mask.setZoningMap(zoningMap);\n}\n", "docstring": "set mask zoning map", "partition": "test"}
{"idx": "4080", "code": "public InvitationStatus waitInvitationAnswer(){\n  return waitInvitationAnswer(mRingingPeriod);\n}\n", "docstring": "wait session invitation answer", "partition": "test"}
{"idx": "4081", "code": "private boolean moveWithinSelectedRange(JTable table,int dx,int dy,ListSelectionModel rsm,ListSelectionModel csm){\n  int totalCount;\n  int minX, maxX, minY, maxY;\n  boolean rs=table.getRowSelectionAllowed();\n  boolean cs=table.getColumnSelectionAllowed();\n  if (rs && cs) {\n    totalCount=table.getSelectedRowCount() * table.getSelectedColumnCount();\n    minX=csm.getMinSelectionIndex();\n    maxX=csm.getMaxSelectionIndex();\n    minY=rsm.getMinSelectionIndex();\n    maxY=rsm.getMaxSelectionIndex();\n  }\n else   if (rs) {\n    totalCount=table.getSelectedRowCount();\n    minX=0;\n    maxX=table.getColumnCount() - 1;\n    minY=rsm.getMinSelectionIndex();\n    maxY=rsm.getMaxSelectionIndex();\n  }\n else   if (cs) {\n    totalCount=table.getSelectedColumnCount();\n    minX=csm.getMinSelectionIndex();\n    maxX=csm.getMaxSelectionIndex();\n    minY=0;\n    maxY=table.getRowCount() - 1;\n  }\n else {\n    totalCount=0;\n    minX=maxX=minY=maxY=0;\n  }\n  boolean stayInSelection;\n  if (totalCount == 0 || (totalCount == 1 && table.isCellSelected(leadRow,leadColumn))) {\n    stayInSelection=false;\n    maxX=table.getColumnCount() - 1;\n    maxY=table.getRowCount() - 1;\n    minX=Math.min(0,maxX);\n    minY=Math.min(0,maxY);\n  }\n else {\n    stayInSelection=true;\n  }\n  if (dy == 1 && leadColumn == -1) {\n    leadColumn=minX;\n    leadRow=-1;\n  }\n else   if (dx == 1 && leadRow == -1) {\n    leadRow=minY;\n    leadColumn=-1;\n  }\n else   if (dy == -1 && leadColumn == -1) {\n    leadColumn=maxX;\n    leadRow=maxY + 1;\n  }\n else   if (dx == -1 && leadRow == -1) {\n    leadRow=maxY;\n    leadColumn=maxX + 1;\n  }\n  leadRow=Math.min(Math.max(leadRow,minY - 1),maxY + 1);\n  leadColumn=Math.min(Math.max(leadColumn,minX - 1),maxX + 1);\n  do {\n    calcNextPos(dx,minX,maxX,dy,minY,maxY);\n  }\n while (stayInSelection && !table.isCellSelected(leadRow,leadColumn));\n  return stayInSelection;\n}\n", "docstring": "called to move within the selected range of the given jtable . this method uses the table \"'\" s notion of selection , which is important to allow the user to navigate between items visually selected on screen . this notion may or may not be the same as what could be determined by directly querying the selection models . it depends on certain table properties ( such as whether or not row or column selection is allowed ) . when performing modifications , it is recommended that caution be taken in order to preserve the intent of this method , especially when deciding whether to query the selection models or interact with jtable directly .", "partition": "test"}
{"idx": "4082", "code": "private double[][] xPrime(int t){\n  double[][] x=new double[1][getNumLags() * numVars];\n  for (int i=0; i < getNumLags(); i++) {\n    double[][] yPrime=yPrime(t - i - 1);\n    System.arraycopy(yPrime[0],0,x[0],i * numVars,numVars);\n  }\n  return x;\n}\n", "docstring": "constructs the x ( t ) vector .", "partition": "test"}
{"idx": "4083", "code": "public void omitLessFreq(){\n  if (name == null)   return;\n  int threshold=n_words[0] / LESS_FREQ_RATIO;\n  if (threshold < MINIMUM_FREQ)   threshold=MINIMUM_FREQ;\n  Set<String> keys=freq.keySet();\n  int roman=0;\n  for (Iterator<String> i=keys.iterator(); i.hasNext(); ) {\n    String key=i.next();\n    int count=freq.get(key);\n    if (count <= threshold) {\n      n_words[key.length() - 1]-=count;\n      i.remove();\n    }\n else {\n      if (key.matches(\"^[A-Za-z]$\")) {\n        roman+=count;\n      }\n    }\n  }\n  if (roman < n_words[0] / 3) {\n    Set<String> keys2=freq.keySet();\n    for (Iterator<String> i=keys2.iterator(); i.hasNext(); ) {\n      String key=i.next();\n      if (key.matches(\".*[A-Za-z].*\")) {\n        n_words[key.length() - 1]-=freq.get(key);\n        i.remove();\n      }\n    }\n  }\n}\n", "docstring": "eliminate below less frequency n - grams and noise latin alphabets", "partition": "test"}
{"idx": "4084", "code": "public static PublicKeySelector fromString(String type){\n  if (type != null) {\n    for (    PublicKeySelector keySelector : PublicKeySelector.values()) {\n      if (type.equalsIgnoreCase(keySelector.type)) {\n        return keySelector;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "translates a string into a token endpoint auth method type .", "partition": "test"}
{"idx": "4085", "code": "public static void describeShapeDetail(Shape shape,double flattening){\n  PathIterator pi2=shape.getPathIterator(null);\n  FlatteningPathIterator pi=new FlatteningPathIterator(pi2,flattening);\n  double[] coords=new double[6];\n  int pointCount=0;\n  Debug.output(\" -- start describeShapeDetail with flattening[\" + flattening + \"]\");\n  while (!pi.isDone()) {\n    int type=pi.currentSegment(coords);\n    Debug.output(\" Shape point [\" + type + \"] (\"+ (pointCount++)+ \") \"+ coords[0]+ \", \"+ coords[1]);\n    pi.next();\n  }\n  Debug.output(\" -- end (\" + pointCount + \")\");\n}\n", "docstring": "utility method that iterates over a shape object and prints out the points . the flattening is used for a flatteningpathiterator , controlling the scope of the path traversal .", "partition": "test"}
{"idx": "4086", "code": "protected static String shortenClassname(String nam,char c){\n  final int lastdot=nam.lastIndexOf(c);\n  if (lastdot >= 0) {\n    nam=nam.substring(lastdot + 1);\n  }\n  return nam;\n}\n", "docstring": "shorten the class name .", "partition": "test"}
{"idx": "4087", "code": "@Override public void flip(X11ComponentPeer peer,Component target,VolatileImage xBackBuffer,int x1,int y1,int x2,int y2,BufferCapabilities.FlipContents flipAction){\n  if (flipAction == BufferCapabilities.FlipContents.COPIED) {\n    SurfaceManager vsm=SurfaceManager.getManager(xBackBuffer);\n    SurfaceData sd=vsm.getPrimarySurfaceData();\n    if (sd instanceof GLXVSyncOffScreenSurfaceData) {\n      GLXVSyncOffScreenSurfaceData vsd=(GLXVSyncOffScreenSurfaceData)sd;\n      SurfaceData bbsd=vsd.getFlipSurface();\n      Graphics2D bbg=new SunGraphics2D(bbsd,Color.black,Color.white,null);\n      try {\n        bbg.drawImage(xBackBuffer,0,0,null);\n      }\n  finally {\n        bbg.dispose();\n      }\n    }\n else {\n      Graphics g=peer.getGraphics();\n      try {\n        g.drawImage(xBackBuffer,x1,y1,x2,y2,x1,y1,x2,y2,null);\n      }\n  finally {\n        g.dispose();\n      }\n      return;\n    }\n  }\n else   if (flipAction == BufferCapabilities.FlipContents.PRIOR) {\n    return;\n  }\n  OGLSurfaceData.swapBuffers(peer.getContentWindow());\n  if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {\n    Graphics g=xBackBuffer.getGraphics();\n    try {\n      g.setColor(target.getBackground());\n      g.fillRect(0,0,xBackBuffer.getWidth(),xBackBuffer.getHeight());\n    }\n  finally {\n      g.dispose();\n    }\n  }\n}\n", "docstring": "performs the native glx flip operation for the given target component .", "partition": "test"}
{"idx": "4088", "code": "public boolean addProperty(OwlProperty property){\n  property.addRestriction(this);\n  return properties.add(property);\n}\n", "docstring": "add \" onproperty p \" information , and tell p to point back here .", "partition": "test"}
{"idx": "4089", "code": "void onMoved(){\n  double diff=System.currentTimeMillis() - timeStamp;\n  timeStamp=0;\n  if (diff > DISCARD_THRESHOLD) {\n    return;\n  }\n  double recentJitter=0;\n  double sum=0.0;\n  for (int i=0; i < VECTOR_LENGTH; i++) {\n    double old=times[i];\n    double avg=(diff + old) / 2;\n    recentJitter+=Math.abs(old - diff);\n    times[i]=avg;\n    diff=old;\n    sum+=avg;\n  }\n  recentJitter/=8;\n  jitter=(jitter + 2.0 * Math.max(jitter,recentJitter) + recentJitter) / 4.0;\n  prediction=TURN_LENGTH / (sum / VECTOR_LENGTH + jitter);\n  WtWindowManager wm=WtWindowManager.getInstance();\n  wm.setProperty(SPEED_PROPERTY,Double.toString(prediction));\n  wm.setProperty(JITTER_PROPERTY,Double.toString(jitter));\n}\n", "docstring": "called when the user moves . marks the end of a timing instance .", "partition": "test"}
{"idx": "4090", "code": "public ServiceID(DataInput in) throws IOException {\n  this.mostSig=in.readLong();\n  this.leastSig=in.readLong();\n}\n", "docstring": "reads in 16 bytes in standard network byte order .", "partition": "test"}
{"idx": "4091", "code": "public void onEnterElementConsumed(String uri,String localName,String qname,Attributes atts) throws SAXException {\n  attStack.push(currentAtts=new AttributesImpl(atts));\n  nsEffectiveStack.push(new Integer(nsEffectivePtr));\n  nsEffectivePtr=namespaces.size();\n}\n", "docstring": "called by the generated handler code when an enter element event is consumed . < p > pushes a new attribute set . < p > note that attributes are not pushed at the startelement method , because the processing of the enterelement event can trigger other attribute events and etc . < p > this method will be called from one of handlers when it truely consumes the enterelement event .", "partition": "test"}
{"idx": "4092", "code": "protected int[] readColorTable(final int ncolors){\n  final int nbytes=3 * ncolors;\n  int[] tab=null;\n  final byte[] c=new byte[nbytes];\n  try {\n    rawData.get(c);\n    tab=new int[256];\n    int i=0;\n    int j=0;\n    while (i < ncolors) {\n      final int r=(c[j++]) & 0xff;\n      final int g=(c[j++]) & 0xff;\n      final int b=(c[j++]) & 0xff;\n      tab[i++]=0xff000000 | (r << 16) | (g << 8)| b;\n    }\n  }\n catch (  final BufferUnderflowException e) {\n    Log.w(TAG,\"Format Error Reading Color Table\",e);\n    status=STATUS_FORMAT_ERROR;\n  }\n  return tab;\n}\n", "docstring": "reads color table as 256 rgb integer values", "partition": "test"}
{"idx": "4093", "code": "@SneakyThrows public void addKeyToKeystore(KeyStore keyStore,X509Certificate cert,RSAPrivateKey privateKey,String alias,String password){\n  KeyStore.PasswordProtection pass=new KeyStore.PasswordProtection(password.toCharArray());\n  Certificate[] certificateChain={cert};\n  keyStore.setEntry(alias,new KeyStore.PrivateKeyEntry(privateKey,certificateChain),pass);\n}\n", "docstring": "based on a public certificate , private key , alias and password , this method will load the certificate and private key as an entry into the keystore , and it will set the provided alias and password to the keystore entry .", "partition": "test"}
{"idx": "4094", "code": "public boolean needsReload(File file){\n  return fFilesToReoad.contains(file);\n}\n", "docstring": "returns true if the given indicator file needs to be reloaded .", "partition": "test"}
{"idx": "4095", "code": "protected int drawLegend(Canvas canvas,DefaultRenderer renderer,String[] titles,int left,int right,int y,int width,int height,int legendSize,Paint paint,boolean calculate){\n  float size=32;\n  if (renderer.isShowLegend()) {\n    float currentX=left;\n    float currentY=y + height - legendSize + size;\n    paint.setTextAlign(Component.LEFT);\n    paint.setTextSize(renderer.getLegendTextSize());\n    int sLength=Math.min(titles.length,renderer.getSeriesRendererCount());\n    for (int i=0; i < sLength; i++) {\n      SimpleSeriesRenderer r=renderer.getSeriesRendererAt(i);\n      final float lineSize=getLegendShapeWidth(i);\n      if (r.isShowLegendItem()) {\n        String text=titles[i];\n        if (titles.length == renderer.getSeriesRendererCount()) {\n          paint.setColor(r.getColor());\n        }\n else {\n          paint.setColor(ColorUtil.LTGRAY);\n        }\n        float[] widths=new float[text.length()];\n        paint.getTextWidths(text,widths);\n        float sum=0;\n        for (        float value : widths) {\n          sum+=value;\n        }\n        float extraSize=lineSize + 10 + sum;\n        float currentWidth=currentX + extraSize;\n        if (i > 0 && getExceed(currentWidth,renderer,right,width)) {\n          currentX=left;\n          currentY+=renderer.getLegendTextSize();\n          size+=renderer.getLegendTextSize();\n          currentWidth=currentX + extraSize;\n        }\n        if (getExceed(currentWidth,renderer,right,width)) {\n          float maxWidth=right - currentX - lineSize- 10;\n          if (isVertical(renderer)) {\n            maxWidth=width - currentX - lineSize- 10;\n          }\n          int nr=paint.breakText(text,true,maxWidth,widths);\n          text=text.substring(0,nr) + \"...\";\n        }\n        if (!calculate) {\n          drawLegendShape(canvas,r,currentX,currentY,i,paint);\n          drawString(canvas,text,currentX + lineSize + 5,currentY + 5,paint);\n        }\n        currentX+=extraSize;\n      }\n    }\n  }\n  return Math.round(size + renderer.getLegendTextSize());\n}\n", "docstring": "draws the chart legend .", "partition": "test"}
{"idx": "4096", "code": "public PutRepositoryRequest source(byte[] repositoryDefinition){\n  return source(repositoryDefinition,0,repositoryDefinition.length);\n}\n", "docstring": "parses repository definition . json , smile and yaml formats are supported", "partition": "test"}
{"idx": "4097", "code": "private void disableButtons(){\n  setFireEnabled(false);\n  setSkipEnabled(false);\n  setTwistEnabled(false);\n  setNextEnabled(false);\n  butDone.setEnabled(false);\n  setFlipArmsEnabled(false);\n  setFireModeEnabled(false);\n  setNextTargetEnabled(false);\n}\n", "docstring": "disables all buttons in the interface", "partition": "test"}
{"idx": "4098", "code": "public boolean isAdditiveNumber(String num){\n  int n=num.length();\n  for (int i=1; i <= n / 2; i++) {\n    if (num.charAt(0) == '0' && i > 1) {\n      return false;\n    }\n    BigInteger num1=new BigInteger(num.substring(0,i));\n    for (int j=1; Math.max(i,j) <= n - i - j; j++) {\n      if (num.charAt(i) == '0' && j > 1) {\n        break;\n      }\n      BigInteger num2=new BigInteger(num.substring(i,i + j));\n      if (isAdditiveNumber(num1,num2,i + j,num)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "recursive . generate the first and second of the sequence , check if the rest of the string match the sum recursively . i is the length of first number , j is the length of thgste second .", "partition": "test"}
{"idx": "4099", "code": "@Override public void write(String str){\n  int start=0;\n  while (start < str.length()) {\n    int end=Math.min(start + MAX_MESSAGE_LENGTH,str.length());\n    Log.i(TAG,str.substring(start,end));\n    start=end;\n  }\n}\n", "docstring": "writes the given string to android logcat .", "partition": "test"}
{"idx": "4100", "code": "private CarbonDictionarySortInfo createColumnSortInfo(CarbonDictionarySortModel[] dictionarySortModels){\n  int[] sortIndex;\n  int[] sortIndexInverted;\n  Arrays.sort(dictionarySortModels);\n  sortIndex=new int[dictionarySortModels.length];\n  sortIndexInverted=new int[dictionarySortModels.length];\n  for (int i=0; i < dictionarySortModels.length; i++) {\n    CarbonDictionarySortModel dictionarySortModel=dictionarySortModels[i];\n    sortIndex[i]=dictionarySortModel.getKey();\n    sortIndexInverted[dictionarySortModel.getKey() - 1]=i + 1;\n  }\n  dictionarySortModels=null;\n  List<Integer> sortIndexList=convertToList(sortIndex);\n  List<Integer> sortIndexInvertedList=convertToList(sortIndexInverted);\n  return new CarbonDictionarySortInfo(sortIndexList,sortIndexInvertedList);\n}\n", "docstring": "the method prepares the sort_index and sort_index_inverted data", "partition": "test"}
{"idx": "4101", "code": "private void addFeature(JsonNode feature,int index){\n  PointFeature feat=null;\n  try {\n    feat=PointFeature.fromJsonNode(feature);\n  }\n catch (  EmptyPolygonException e) {\n    LOG.warn(\"Empty MultiPolygon, skipping.\");\n    return;\n  }\ncatch (  UnsupportedGeometryException e) {\n    LOG.warn(e.message);\n    return;\n  }\n  if (feat == null) {\n    return;\n  }\n  addFeature(feat,index);\n}\n", "docstring": "add one geojson feature to this freeformpointset from a jackson node tree . com . bedatadriven . geojson only exposed its streaming geometry parser as a public method . i made its tree parser public as well . geotools also has a geojson parser called geometryjson ( which otp wraps in geojsondeserializer ) but it consumes straight text , not a jackson model or streaming parser .", "partition": "test"}
{"idx": "4102", "code": "public BitString(final String value){\n  this(value.length());\n  for (int i=0; i < value.length(); i++) {\n    if (value.charAt(i) == \'1\') {\n      setBit(value.length() - (i + 1),true);\n    }\n else     if (value.charAt(i) != \'0\') {\n      throw new IllegalArgumentException(\"Illegal character at position \" + i);\n    }\n  }\n}\n", "docstring": "initialises the bit string from a character string of 1s and 0s in big - endian order .", "partition": "test"}
{"idx": "4103", "code": "public void sort(Comparator<Individual> comparator){\n  Collections.sort(individuals,comparator);\n}\n", "docstring": "sorts the individuals in ascending order according to their performance , thus the best one will be in last position .", "partition": "test"}
{"idx": "4104", "code": "public void write(Writer writer) throws Exception {\n  writer.write(toString());\n  writer.flush();\n}\n", "docstring": "writes the current dom document into the given writer .", "partition": "test"}
{"idx": "4105", "code": "public static boolean isCglibRenamedMethod(Method renamedMethod){\n  String name=renamedMethod.getName();\n  if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\n    int i=name.length() - 1;\n    while (i >= 0 && Character.isDigit(name.charAt(i))) {\n      i--;\n    }\n    return ((i > CGLIB_RENAMED_METHOD_PREFIX.length()) && (i < name.length() - 1) && (name.charAt(i) == '$'));\n  }\n  return false;\n}\n", "docstring": "determine whether the given method is a cglib \"'\" renamed \"'\" method , following the pattern \" cglib $ methodname $ 0 \" .", "partition": "test"}
{"idx": "4106", "code": "public PWResetException(String bundleName,String errCode,Object[] args){\n  super(bundleName,errCode,args);\n  errList=new ArrayList(1);\n  errList.add(getMessage());\n}\n", "docstring": "creates a password reset exception object with localizable error message .", "partition": "test"}
{"idx": "4107", "code": "public static String[] unionArrays(String[] array1,String[] array2){\n  if (array1 == null) {\n    return array2;\n  }\n  if (array2 == null) {\n    return array1;\n  }\n  Set<String> set=new LinkedHashSet<>();\n  set.addAll(Arrays.asList(array1));\n  set.addAll(Arrays.asList(array2));\n  return set.toArray(new String[set.size()]);\n}\n", "docstring": "returns a union of 2 arrays , ensuring that each string exists only once .", "partition": "test"}
{"idx": "4108", "code": "boolean isStateChange(XDecoratedPeer window,XPropertyEvent e){\n  if (!window.isShowing()) {\n    stateLog.finer(\"Window is not showing\");\n    return false;\n  }\n  int wm_state=window.getWMState();\n  if (wm_state == XUtilConstants.WithdrawnState) {\n    stateLog.finer(\"WithdrawnState\");\n    return false;\n  }\n else {\n    if (stateLog.isLoggable(PlatformLogger.Level.FINER)) {\n      stateLog.finer(\"Window WM_STATE is \" + wm_state);\n    }\n  }\n  boolean is_state_change=false;\n  if (e.get_atom() == XA_WM_STATE.getAtom()) {\n    is_state_change=true;\n  }\n  for (  XStateProtocol proto : getProtocols(XStateProtocol.class)) {\n    is_state_change|=proto.isStateChange(e);\n    if (stateLog.isLoggable(PlatformLogger.Level.FINEST)) {\n      stateLog.finest(proto + \": is state changed = \" + is_state_change);\n    }\n  }\n  return is_state_change;\n}\n", "docstring": "\\ notice window state change when wm changes a property on the window . . . \\", "partition": "test"}
{"idx": "4109", "code": "@Override public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException {\n  Node xpathOwnerNode=(Node)xctxt.getOwnerObject();\n  if (xpathOwnerNode == null) {\n    return null;\n  }\n  int xpathOwnerNodeDTM=xctxt.getDTMHandleFromNode(xpathOwnerNode);\n  int currentNode=xctxt.getCurrentNode();\n  DTM dtm=xctxt.getDTM(currentNode);\n  int docContext=dtm.getDocument();\n  if (DTM.NULL == docContext) {\n    error(xctxt,XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOC,null);\n  }\n{\n    Document currentDoc=XMLUtils.getOwnerDocument(dtm.getNode(currentNode));\n    Document xpathOwnerDoc=XMLUtils.getOwnerDocument(xpathOwnerNode);\n    if (currentDoc != xpathOwnerDoc) {\n      throw new TransformerException(I18n.translate(\"xpath.funcHere.documentsDiffer\"));\n    }\n  }\n  XNodeSet nodes=new XNodeSet(xctxt.getDTMManager());\n  NodeSetDTM nodeSet=nodes.mutableNodeset();\n{\n    int hereNode=DTM.NULL;\nswitch (dtm.getNodeType(xpathOwnerNodeDTM)) {\ncase Node.ATTRIBUTE_NODE:\ncase Node.PROCESSING_INSTRUCTION_NODE:\n{\n        hereNode=xpathOwnerNodeDTM;\n        nodeSet.addNode(hereNode);\n        break;\n      }\ncase Node.TEXT_NODE:\n{\n      hereNode=dtm.getParent(xpathOwnerNodeDTM);\n      nodeSet.addNode(hereNode);\n      break;\n    }\ndefault :\n  break;\n}\n}\nnodeSet.detach();\nreturn nodes;\n}\n", "docstring": "the here function returns a node - set containing the attribute or processing instruction node or the parent element of the text node that directly bears the xpath expression . this expression results in an error if the containing xpath expression does not appear in the same xml document against which the xpath expression is being evaluated .", "partition": "test"}
{"idx": "4110", "code": "public List<LocalTime> top(int n){\n  List<LocalTime> top=new ArrayList<>();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values,ReverseIntComparator.instance());\n  for (int i=0; i < n && i < values.length; i++) {\n    top.add(PackedLocalTime.asLocalTime(values[i]));\n  }\n  return top;\n}\n", "docstring": "returns the largest ( \" top \" ) n values in the column", "partition": "test"}
{"idx": "4111", "code": "public static String grabClass(String signature){\n  Matcher matcher=sigRE.matcher(signature);\n  boolean b=matcher.matches();\n  if (!b && matcher.groupCount() != 4)   logger.error(\"Bad method signature: {}\",signature);\n  return matcher.group(1);\n}\n", "docstring": "grab the class from the signature", "partition": "test"}
{"idx": "4112", "code": "public TimeSeriesMetricDeltaSet(Stream<Entry<Tags,MetricValue>> td){\n  values_=Any2.right(td.collect(Collectors.toMap(null,null,null,null)));\n}\n", "docstring": "create a metricdelta set for tagged metrics and initialize it with the given collection .", "partition": "test"}
{"idx": "4113", "code": "@Override public final E nextElement(){\n  E result=m_Vector.get(m_Counter);\n  m_Counter++;\n  if (m_Counter == m_SpecialElement) {\n    m_Counter++;\n  }\n  return result;\n}\n", "docstring": "returns the next element .", "partition": "test"}
{"idx": "4114", "code": "private ByteString escapeBytes(final ByteString value){\n  if (!needEscaping(value)) {\n    return value;\n  }\n  final ByteStringBuilder builder=new ByteStringBuilder();\n  for (int i=0; i < value.length(); i++) {\n    final byte b=value.byteAt(i);\n    if (isByteToEscape(b)) {\n      builder.appendByte(DN.NORMALIZED_ESC_BYTE);\n    }\n    builder.appendByte(b);\n  }\n  return builder.toByteString();\n}\n", "docstring": "return a new byte string with bytes 0x00 , 0x01 and 0x02 escaped . < p > these bytes are reserved to represent respectively the rdn separator , the ava separator and the escape byte in a normalized byte string .", "partition": "test"}
{"idx": "4115", "code": "public InputBuilder<T> repeatAll(int times){\n  List<T> toAppend=new ArrayList<>();\n  for (int i=0; i < times; i++) {\n    toAppend.addAll(input);\n  }\n  input.addAll(toAppend);\n  return this;\n}\n", "docstring": "repeat the current input list", "partition": "test"}
{"idx": "4116", "code": "@SuppressWarnings(\"unused\") public void handleButton3Request(RequestInvocationEvent event){\n  backTrail();\n  try {\n    String name=(String)getPageSessionAttribute(SAVE_VB_NAME);\n    ViewBean vb=getViewBean(Class.forName(name));\n    passPgSessionMap(vb);\n    vb.forwardTo(getRequestContext());\n  }\n catch (  ClassNotFoundException e) {\n    debug.warning(\"AbstractAuditViewBean.handleButton3Request:\",e);\n  }\n}\n", "docstring": "called on request from the ui to return to the previous page .", "partition": "test"}
{"idx": "4117", "code": "public IonException(Throwable cause){\n  super(cause.getMessage(),cause);\n}\n", "docstring": "constructs a new exception with the given cause , copying the message from the cause into this instance .", "partition": "test"}
{"idx": "4118", "code": "public final double distance(){\n  return Math.sqrt(distance_square());\n}\n", "docstring": "the \" size \" of the line from 0 , 0 to x , y", "partition": "test"}
{"idx": "4119", "code": "@Override public void done(){\n  super.done();\n  if (mNumTestsExpected > mNumTestsRun) {\n    handleTestRunFailed(String.format(\"Test run incomplete. Expected %d tests, received %d\",mNumTestsExpected,mNumTestsRun));\n  }\n else   if (mTestRunInProgress) {\n    handleTestRunFailed(\"No test results\");\n  }\n}\n", "docstring": "called by parent when adb session is complete .", "partition": "test"}
{"idx": "4120", "code": "public MersenneTwister(){\n  mt=new int[N];\n  setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n}\n", "docstring": "creates a new random number generator . < p > the instance is initialized using the current time plus the system identity hash code of this instance as the seed .", "partition": "test"}
{"idx": "4121", "code": "private void verifyTimestamp(X509Certificate cert) throws CertPathValidatorException {\n  String msg=\"timestamp\";\n  if (debug != null)   debug.println(\"---checking \" + msg + \":\"+ date.toString()+ \"...\");\n  try {\n    cert.checkValidity(date);\n  }\n catch (  CertificateExpiredException e) {\n    throw new CertPathValidatorException(msg + \" check failed\",e,null,-1,BasicReason.EXPIRED);\n  }\ncatch (  CertificateNotYetValidException e) {\n    throw new CertPathValidatorException(msg + \" check failed\",e,null,-1,BasicReason.NOT_YET_VALID);\n  }\n  if (debug != null)   debug.println(msg + \" verified.\");\n}\n", "docstring": "internal method to verify the timestamp on a certificate", "partition": "test"}
{"idx": "4122", "code": "public static byte[] encryptPassword(final String password,final byte[] seed) throws NoSuchAlgorithmException {\n  if (password == null || password.equals(\"\")) {\n    return new byte[0];\n  }\n  final MessageDigest messageDigest=MessageDigest.getInstance(\"SHA-1\");\n  final byte[] stage1=messageDigest.digest(password.getBytes());\n  messageDigest.reset();\n  final byte[] stage2=messageDigest.digest(stage1);\n  messageDigest.reset();\n  messageDigest.update(seed);\n  messageDigest.update(stage2);\n  final byte[] digest=messageDigest.digest();\n  final byte[] returnBytes=new byte[digest.length];\n  for (int i=0; i < digest.length; i++) {\n    returnBytes[i]=(byte)(stage1[i] ^ digest[i]);\n  }\n  return returnBytes;\n}\n", "docstring": "encrypts a password < p > protocol for authentication is like this : 1 . mysql server sends a random array of bytes ( the seed ) 2 . client makes a sha1 digest of the password 3 . client hashes the output of 2 4 . client digests the seed 5 . client updates the digest with the output from 3 6 . an xor of the output of 5 and 2 is sent to server 7 . server does the same thing and verifies that the scrambled passwords match", "partition": "test"}
{"idx": "4123", "code": "public int rows(){\n  return rows;\n}\n", "docstring": "returns the number of rows of the receiver .", "partition": "test"}
{"idx": "4124", "code": "public static String array2hex(final byte[] array){\n  return byteArray2String(array,\"0x\",\", \",true,16);\n}\n", "docstring": "a byte array into its hex string representation", "partition": "test"}
{"idx": "4125", "code": "private byte[] writeCheckedBytes(MessageNano proto){\n  BackupProtos.CheckedMessage wrapper=new BackupProtos.CheckedMessage();\n  wrapper.payload=MessageNano.toByteArray(proto);\n  CRC32 checksum=new CRC32();\n  checksum.update(wrapper.payload);\n  wrapper.checksum=checksum.getValue();\n  return MessageNano.toByteArray(wrapper);\n}\n", "docstring": "wrap a proto in a checkedmessage and compute the checksum .", "partition": "test"}
{"idx": "4126", "code": "public double reduceTo(int width,int height,double limit){\n  int w=getIconWidth();\n  int h=getIconHeight();\n  double scale=1.0;\n  if (w > width) {\n    scale=((double)width) / w;\n  }\n  if (h > height) {\n    scale=Math.min(scale,((double)height) / h);\n  }\n  if (scale < 1) {\n    if (limit > 0.0) {\n      scale=Math.max(scale,limit);\n    }\n    AffineTransform t=AffineTransform.getScaleInstance(scale,scale);\n    transformImage((int)Math.ceil(scale * w),(int)Math.ceil(scale * h),t,null);\n  }\n  return scale;\n}\n", "docstring": "if necessary , reduce this image to within \"'\" width \"'\" x \"'\" height \"'\" dimensions . limit the reduction by \"'\" limit \"'\"", "partition": "test"}
{"idx": "4127", "code": "public void installBuiltinSound(String soundIdentifier,InputStream data) throws IOException {\n  builtinSounds.put(soundIdentifier,convertBuiltinSound(data));\n}\n", "docstring": "installs a replacement sound as the builtin sound responsible for the given sound identifier ( this will override the system sound if such a sound exists ) .", "partition": "test"}
{"idx": "4128", "code": "private Integer countFragmentFilteredPages(List<String> templateFragments,boolean whitelist) throws WikiApiException {\n  try {\n    int count=0;\n    PreparedStatement statement=null;\n    ResultSet result=null;\n    try {\n      StringBuffer sqlString=new StringBuffer();\n      StringBuffer subconditions=new StringBuffer();\n      sqlString.append(\"SELECT distinct(count(*)) FROM \" + GeneratorConstants.TABLE_TPLID_TPLNAME + \" as tpl, \"+ GeneratorConstants.TABLE_TPLID_PAGEID+ \" AS p WHERE tpl.templateId = p.templateId \"+ (whitelist ? \"AND\" : \"AND NOT\")+ \" (\");\n      for (      @SuppressWarnings(\"unused\") String fragment : templateFragments) {\n        if (subconditions.length() != 0) {\n          subconditions.append(\"OR \");\n        }\n        subconditions.append(\"tpl.templateName LIKE ?\");\n      }\n      sqlString.append(subconditions);\n      sqlString.append(\")\");\n      statement=connection.prepareStatement(sqlString.toString());\n      int curIdx=1;\n      for (      String fragment : templateFragments) {\n        fragment=fragment.toLowerCase();\n        fragment=fragment.trim();\n        fragment=fragment.replaceAll(\" \",\"_\");\n        statement.setString(curIdx++,fragment + \"%\");\n      }\n      result=execute(statement);\n      if (result == null) {\n        return 0;\n      }\n      if (result.next()) {\n        count=result.getInt(1);\n      }\n    }\n  finally {\n      if (statement != null) {\n        statement.close();\n      }\n      if (result != null) {\n        result.close();\n      }\n    }\n    return count;\n  }\n catch (  Exception e) {\n    throw new WikiApiException(e);\n  }\n}\n", "docstring": "returns the number of all pages that contain a template the name of which starts with any of the the given strings .", "partition": "test"}
{"idx": "4129", "code": "public static int findName(String name,int[] table){\n  for (int i=0; i < table.length; i++) {\n    if (name.equals(getName(table[i]))) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "docstring": "get the encoding value of a glyph given its name and a charset .", "partition": "test"}
{"idx": "4130", "code": "private static Bitmap transform(Matrix scaler,Bitmap source,int targetWidth,int targetHeight,int options){\n  Log.i(TAG,\"transform --1--\");\n  boolean scaleUp=(options & 0x1) != 0;\n  boolean recycle=(options & 0x2) != 0;\n  int deltaX=source.getWidth() - targetWidth;\n  int deltaY=source.getHeight() - targetHeight;\n  if (!scaleUp && (deltaX < 0 || deltaY < 0)) {\n    Log.i(TAG,\"transform --2--\");\n    Bitmap b2=Bitmap.createBitmap(targetWidth,targetHeight,Bitmap.Config.ARGB_8888);\n    Canvas c=new Canvas(b2);\n    int deltaXHalf=Math.max(0,deltaX / 2);\n    int deltaYHalf=Math.max(0,deltaY / 2);\n    Rect src=new Rect(deltaXHalf,deltaYHalf,deltaXHalf + Math.min(targetWidth,source.getWidth()),deltaYHalf + Math.min(targetHeight,source.getHeight()));\n    int dstX=(targetWidth - src.width()) / 2;\n    int dstY=(targetHeight - src.height()) / 2;\n    Rect dst=new Rect(dstX,dstY,targetWidth - dstX,targetHeight - dstY);\n    c.drawBitmap(source,src,dst,null);\n    if (recycle) {\n      source.recycle();\n    }\n    c.setBitmap(null);\n    Log.i(TAG,\"transform --3--\");\n    return b2;\n  }\n  float bitmapWidthF=source.getWidth();\n  float bitmapHeightF=source.getHeight();\n  Log.i(TAG,\"bitmapWidthF:\" + bitmapWidthF + \",bitmapHeightF:\"+ bitmapHeightF);\n  float bitmapAspect=bitmapWidthF / bitmapHeightF;\n  float viewAspect=(float)targetWidth / targetHeight;\n  Log.i(TAG,\"targetWidth:\" + targetWidth + \",targetHeight:\"+ targetHeight);\n  if (bitmapAspect > viewAspect) {\n    float scale=targetHeight / bitmapHeightF;\n    if (scale < .9F || scale > 1F) {\n      scaler.setScale(scale,scale);\n    }\n else {\n      scaler=null;\n    }\n  }\n else {\n    float scale=targetWidth / bitmapWidthF;\n    if (scale < .9F || scale > 1F) {\n      scaler.setScale(scale,scale);\n    }\n else {\n      scaler=null;\n    }\n  }\n  Bitmap b1;\n  if (scaler != null) {\n    Log.i(TAG,\"transform --3.1--\");\n    b1=Bitmap.createBitmap(source,0,0,source.getWidth(),source.getHeight(),scaler,true);\n  }\n else {\n    Log.i(TAG,\"transform --3.2--\");\n    b1=source;\n  }\n  if (recycle && b1 != source) {\n    Log.i(TAG,\"transform --4--\");\n    source.recycle();\n  }\n  int dx1=Math.max(0,b1.getWidth() - targetWidth);\n  int dy1=Math.max(0,b1.getHeight() - targetHeight);\n  Bitmap b2=Bitmap.createBitmap(b1,dx1 / 2,dy1 / 2,targetWidth,targetHeight);\n  if (b2 != b1) {\n    if (recycle || b1 != source) {\n      Log.i(TAG,\"transform --5--\");\n      b1.recycle();\n    }\n  }\n  Log.i(TAG,\"transform --6--\");\n  if (b2 == null) {\n    Log.i(TAG,\"transform --7--\");\n  }\n  return b2;\n}\n", "docstring": "transform source bitmap to targeted width and height", "partition": "test"}
{"idx": "4131", "code": "private void scoreTrackResults(Collection<Track> tracks,SearchQuery query,Collection<ScoredResult> output){\n  for (  Track track : tracks) {\n    double score=scoreTrackResult(query,track);\n    output.add(new ScoredResult(track,score));\n  }\n}\n", "docstring": "scores a collection of track results .", "partition": "test"}
{"idx": "4132", "code": "private Long currentTime(){\n  return System.currentTimeMillis() / 1000;\n}\n", "docstring": "returns a current time seconds from epoch .", "partition": "test"}
{"idx": "4133", "code": "private static byte[] encode(double latitude,double longitude){\n  byte[] bytes=new byte[2 * Integer.BYTES];\n  NumericUtils.intToSortableBytes(encodeLatitude(latitude),bytes,0);\n  NumericUtils.intToSortableBytes(encodeLongitude(longitude),bytes,Integer.BYTES);\n  return bytes;\n}\n", "docstring": "sugar encodes a single point as a byte array", "partition": "test"}
{"idx": "4134", "code": "public static void putLongVolatile(Object obj,long off,long val){\n  UNSAFE.putLongVolatile(obj,off,val);\n}\n", "docstring": "stores long value with volatile semantic .", "partition": "test"}
{"idx": "4135", "code": "public void circle(double x,double y,double r){\n  if (r < 0)   throw new IllegalArgumentException(\"circle radius can\'t be negative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * r);\n  double hs=factorY(2 * r);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "docstring": "draws a circle of radius r , centered on ( x , y ) .", "partition": "test"}
{"idx": "4136", "code": "final public void println(double v){\n  Writer out=this.out;\n  if (out == null)   return;\n  print(v);\n  try {\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}\n", "docstring": "prints a double followed by a newline .", "partition": "test"}
{"idx": "4137", "code": "public void writeSI32(int value) throws IOException {\n  flushBits();\n  out.write(value & 0xff);\n  out.write(value >> 8);\n  out.write(value >> 16);\n  out.write(value >> 24);\n  bytesWritten+=4;\n}\n", "docstring": "write a 32 bit signed value", "partition": "test"}
{"idx": "4138", "code": "private static void map(final StringBuilder buffer,final ByteSequence sequence,final boolean trim,final boolean foldCase){\n  final String value=sequence.toString();\n  for (int i=0; i < value.length(); i++) {\n    final char c=value.charAt(i);\n    if (MAP_2_NULL.contains(c)) {\n      continue;\n    }\n    if (MAP_2_SPACE.contains(c)) {\n      if (canMapToSpace(buffer,trim)) {\n        buffer.append(SPACE_CHAR);\n      }\n      continue;\n    }\n    if (foldCase) {\n      final String mapping=CASE_MAP_TABLE.get(c);\n      if (mapping != null) {\n        buffer.append(mapping);\n        continue;\n      }\n    }\n    buffer.append(c);\n  }\n}\n", "docstring": "checks each character and replaces it with its mapping .", "partition": "test"}
{"idx": "4139", "code": "public void addButtonPressedListener(FieldConfigStringButtonInterface listener){\n  if (buttonPressedListenerList == null) {\n    buttonPressedListenerList=new ArrayList<FieldConfigStringButtonInterface>();\n  }\n  buttonPressedListenerList.add(listener);\n}\n", "docstring": "adds the button pressed listener .", "partition": "test"}
{"idx": "4140", "code": "private void fillXMLAttribute(Attributes att,int index){\n  fillQName(fAttributeQName,att.getURI(index),att.getLocalName(index),att.getQName(index));\n  String type=att.getType(index);\n  fAttributes.addAttributeNS(fAttributeQName,(type != null) ? type : XMLSymbols.fCDATASymbol,att.getValue(index));\n}\n", "docstring": "adds an attribute to the xmlattributes object .", "partition": "test"}
{"idx": "4141", "code": "public JComponent createPropertyGUI(PropertyConsumer pc){\n  this.propertyConsumer=pc;\n  Properties props=new Properties();\n  props=pc.getProperties(props);\n  Properties info=new Properties();\n  info=pc.getPropertyInfo(info);\n  String prefix=pc.getPropertyPrefix();\n  return createPropertyGUI(prefix,props,info);\n}\n", "docstring": "creates a jcomponent with the properties to be changed . this component is suitable for inclusion into a gui .", "partition": "test"}
{"idx": "4142", "code": "public long copy(String filename,OutputStream out,long offset,long size) throws IOException, InterruptedException {\n  if (size < 0) {\n    return 0;\n  }\n  BufferedInputStream is=new BufferedInputStream(getFileInputStream(filename));\n  byte[] buf=new byte[64 * 1024];\n  int bytesRead;\n  long pos=0;\n  long remaining=size;\n  try {\n    if (offset != 0) {\n      is.skip(offset);\n      pos+=offset;\n    }\n    while (remaining != 0) {\n      int max=buf.length;\n      if (max > remaining) {\n        max=(int)remaining;\n      }\n      bytesRead=is.read(buf,0,max);\n      if (bytesRead == -1) {\n        break;\n      }\n      out.write(buf,0,bytesRead);\n      pos+=bytesRead;\n      remaining-=bytesRead;\n    }\n    out.flush();\n  }\n catch (  Exception e) {\n    out.flush();\n  }\n finally {\n    try {\n      is.close();\n    }\n catch (    Exception e) {\n    }\n  }\n  return pos;\n}\n", "docstring": "copies the given file to the output stream continously , i . e . not stop when end of file is reached , but rather wait for additional data to be appended to the file .", "partition": "test"}
{"idx": "4143", "code": "private static void deserializeHeader(KdbHeader kdbHeader,DataInput dataInput) throws IOException {\n  kdbHeader.setFlags(dataInput.readInt());\n  kdbHeader.setVersion(dataInput.readInt());\n  byte[] buffer=new byte[16];\n  dataInput.readFully(buffer);\n  kdbHeader.setMasterSeed(buffer);\n  buffer=new byte[16];\n  dataInput.readFully(buffer);\n  kdbHeader.setEncryptionIv(buffer);\n  kdbHeader.setGroupCount(dataInput.readInt());\n  kdbHeader.setEntryCount(dataInput.readInt());\n  byte[] buffer32=new byte[32];\n  dataInput.readFully(buffer32);\n  kdbHeader.setContentHash(buffer32);\n  buffer32=new byte[32];\n  dataInput.readFully(buffer32);\n  kdbHeader.setTransformSeed(buffer32);\n  kdbHeader.setTransformRounds(dataInput.readInt());\n}\n", "docstring": "deserialize a header from a source into the supplied kdbheader", "partition": "test"}
{"idx": "4144", "code": "public List<JCAnnotation> transformAnnotations(OutputElement target,Tree.Declaration annotated){\n  EnumSet<OutputElement> outputs;\n  if (annotated instanceof Tree.AnyClass) {\n    outputs=AnnotationUtil.outputs((Tree.AnyClass)annotated);\n  }\n else   if (annotated instanceof Tree.AnyInterface) {\n    outputs=AnnotationUtil.outputs((Tree.AnyInterface)annotated);\n  }\n else   if (annotated instanceof Tree.TypeAliasDeclaration) {\n    outputs=AnnotationUtil.outputs((Tree.TypeAliasDeclaration)annotated);\n  }\n else   if (annotated instanceof Tree.Constructor) {\n    outputs=AnnotationUtil.outputs((Tree.Constructor)annotated);\n  }\n else   if (annotated instanceof Tree.Enumerated) {\n    outputs=AnnotationUtil.outputs((Tree.Enumerated)annotated);\n  }\n else   if (annotated instanceof Tree.AnyMethod) {\n    outputs=AnnotationUtil.outputs((Tree.AnyMethod)annotated);\n  }\n else   if (annotated instanceof Tree.AttributeDeclaration) {\n    outputs=AnnotationUtil.outputs((Tree.AttributeDeclaration)annotated);\n  }\n else   if (annotated instanceof Tree.AttributeGetterDefinition) {\n    outputs=AnnotationUtil.outputs((Tree.AttributeGetterDefinition)annotated);\n  }\n else   if (annotated instanceof Tree.AttributeSetterDefinition) {\n    outputs=AnnotationUtil.outputs((Tree.AttributeSetterDefinition)annotated);\n  }\n else   if (annotated instanceof Tree.ObjectDefinition) {\n    outputs=AnnotationUtil.outputs((Tree.ObjectDefinition)annotated);\n  }\n else {\n    throw BugException.unhandledNodeCase(annotated);\n  }\n  return transform(annotated.getDeclarationModel(),target,annotated.getAnnotationList(),outputs);\n}\n", "docstring": "transform the annotations on the given annotated declaration for inclusion on the given target element type", "partition": "test"}
{"idx": "4145", "code": "public boolean areAllPermissionsGranted(){\n  return deniedPermissionResponses.isEmpty();\n}\n", "docstring": "returns whether the user has granted all the requested permission", "partition": "test"}
{"idx": "4146", "code": "private String fetchCharsetFromCache(Client client,Locale loc){\n  Map cCache=(Map)charsetCache.get(client.getClientType());\n  String val=null;\n  if (cCache != null) {\n    val=(String)cCache.get(loc);\n  }\n  return val;\n}\n", "docstring": "fetches the charset to be used for any given locale from cache", "partition": "test"}
{"idx": "4147", "code": "public void addControlRoll(PilotingRollData control){\n  controlRolls.addElement(control);\n}\n", "docstring": "adds a pending control roll to the list for this phase .", "partition": "test"}
{"idx": "4148", "code": "void processAddOnChanges(Window caller,AddOnDependencyChecker.AddOnChangesResult changes){\n  if (addonsDialog != null) {\n    addonsDialog.setDownloadingUpdates();\n  }\n  if (getView() != null) {\n    Set<AddOn> addOns=new HashSet<>(changes.getUninstalls());\n    addOns.addAll(changes.getOldVersions());\n    Set<Extension> extensions=new HashSet<>();\n    extensions.addAll(changes.getUnloadExtensions());\n    extensions.addAll(changes.getSoftUnloadExtensions());\n    if (!warnUnsavedResourcesOrActiveActions(caller,addOns,extensions,true)) {\n      return;\n    }\n  }\n  uninstallAddOns(caller,changes.getUninstalls(),false);\n  Set<AddOn> allAddons=new HashSet<>(changes.getNewVersions());\n  allAddons.addAll(changes.getInstalls());\n  for (  AddOn addOn : allAddons) {\n    if (addonsDialog != null) {\n      addonsDialog.notifyAddOnDownloading(addOn);\n    }\n    downloadAddOn(addOn);\n  }\n}\n", "docstring": "processes the given add - on changes .", "partition": "test"}
{"idx": "4149", "code": "public void rederiveColor(){\n  Color src=UIManager.getColor(uiDefaultParentName);\n  if (src != null) {\n    float[] tmp=Color.RGBtoHSB(src.getRed(),src.getGreen(),src.getBlue(),null);\n    tmp[0]=clamp(tmp[0] + hOffset);\n    tmp[1]=clamp(tmp[1] + sOffset);\n    tmp[2]=clamp(tmp[2] + bOffset);\n    int alpha=clamp(src.getAlpha() + aOffset);\n    argbValue=(Color.HSBtoRGB(tmp[0],tmp[1],tmp[2]) & 0xFFFFFF) | (alpha << 24);\n  }\n else {\n    float[] tmp=new float[3];\n    tmp[0]=clamp(hOffset);\n    tmp[1]=clamp(sOffset);\n    tmp[2]=clamp(bOffset);\n    int alpha=clamp(aOffset);\n    argbValue=(Color.HSBtoRGB(tmp[0],tmp[1],tmp[2]) & 0xFFFFFF) | (alpha << 24);\n  }\n}\n", "docstring": "recalculate the derived color from the uimanager parent color and offsets", "partition": "test"}
{"idx": "4150", "code": "public void onIdleBegin(){\n  _idleCount.incrementAndGet();\n}\n", "docstring": "called by the thread before going into the idle state .", "partition": "test"}
{"idx": "4151", "code": "private void addSpan(CacheSpan span){\n  TreeSet<CacheSpan> spansForKey=cachedSpans.get(span.key);\n  if (spansForKey == null) {\n    spansForKey=new TreeSet<CacheSpan>();\n    cachedSpans.put(span.key,spansForKey);\n  }\n  spansForKey.add(span);\n  totalSpace+=span.length;\n  notifySpanAdded(span);\n}\n", "docstring": "adds a cached span to the in - memory representation .", "partition": "test"}
{"idx": "4152", "code": "public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (!(obj instanceof URIName)) {\n    return false;\n  }\n  URIName other=(URIName)obj;\n  return uri.equals(other.getURI());\n}\n", "docstring": "compares this name with another , for equality .", "partition": "test"}
{"idx": "4153", "code": "void repaintChildren(){\n  for (  Component child : panel.getComponents()) {\n    child.repaint();\n  }\n}\n", "docstring": "request repainting of all the child panels .", "partition": "test"}
{"idx": "4154", "code": "private static String readComment(String input,int index){\n  String comment=null;\n  Matcher matcher=COMMENT_PATTERN.matcher(input.substring(index));\n  if (matcher.find()) {\n    comment=matcher.group(1);\n    comment=comment.substring(1);\n  }\n  return comment;\n}\n", "docstring": "reads the first comment line from the input , and returns the comment line ( including the line break character ) without the leading \" # \" .", "partition": "test"}
{"idx": "4155", "code": "public static int findNext(String str,char separator,char escapeChar,int start,StringBuilder split){\n  int numPreEscapes=0;\n  for (int i=start; i < str.length(); i++) {\n    char curChar=str.charAt(i);\n    if (numPreEscapes == 0 && curChar == separator) {\n      return i;\n    }\n else {\n      split.append(curChar);\n      numPreEscapes=(curChar == escapeChar) ? (++numPreEscapes) % 2 : 0;\n    }\n  }\n  return -1;\n}\n", "docstring": "finds the first occurrence of the separator character ignoring the escaped separators starting from the index . note the substring between the index and the position of the separator is passed .", "partition": "test"}
{"idx": "4156", "code": "private static String guessContentType(String url){\n  url=url.toLowerCase();\n  if (url.endsWith(\".webm\")) {\n    return \"video/webm\";\n  }\n else   if (url.endsWith(\".mp4\")) {\n    return \"video/mp4\";\n  }\n else   if (url.matches(\".*\\\\.jpe?g\")) {\n    return \"image/jpeg\";\n  }\n else   if (url.endsWith(\".png\")) {\n    return \"image/png\";\n  }\n else   if (url.endsWith(\".gif\")) {\n    return \"image/gif\";\n  }\n else {\n    return \"application/octet-stream\";\n  }\n}\n", "docstring": "guess a content type from the url .", "partition": "test"}
{"idx": "4157", "code": "public static String extractCSVOutputLineDomain(String csvOut){\n  String tokens[]=csvOut.split(\",(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\",-1);\n  return tokens[1];\n}\n", "docstring": "used for testing - - input is a full csv line : < freq , domain , ip , ts , opt : generic >", "partition": "test"}
{"idx": "4158", "code": "public void connect(){\n  connect(this.logWriter);\n}\n", "docstring": "connects to the currently configured system .", "partition": "test"}
{"idx": "4159", "code": "public static boolean doCacheHeaderValidation(final SolrQueryRequest solrReq,final HttpServletRequest req,final Method reqMethod,final HttpServletResponse resp){\n  if (Method.POST == reqMethod || Method.OTHER == reqMethod) {\n    return false;\n  }\n  final long lastMod=HttpCacheHeaderUtil.calcLastModified(solrReq);\n  final String etag=HttpCacheHeaderUtil.calcEtag(solrReq);\n  resp.setDateHeader(\"Last-Modified\",lastMod);\n  resp.setHeader(\"ETag\",etag);\n  if (checkETagValidators(req,resp,reqMethod,etag)) {\n    return true;\n  }\n  if (checkLastModValidators(req,resp,lastMod)) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "sets http response cache validator headers appropriately and validates the http request against these using any conditional request headers . if the request contains conditional headers , and those headers indicate a match with the current known state of the system , this method will return \" true \" indicating that a 304 status code can be returned , and no further processing is needed .", "partition": "test"}
{"idx": "4160", "code": "public IvrZoneset showActiveIvrZoneset() throws NetworkDeviceControllerException {\n  List<IvrZoneset> zonesets=showIvrZonesets(true);\n  return zonesets.isEmpty() ? null : zonesets.get(0);\n}\n", "docstring": "collect the active ivr zoneset , and its zones , members", "partition": "test"}
{"idx": "4161", "code": "@SuppressWarnings(\"unchecked\") public static <K>ImmutableArray<K> empty(){\n  return (ImmutableArray<K>)EMPTY;\n}\n", "docstring": "get an empty immutable array .", "partition": "test"}
{"idx": "4162", "code": "public void replaceNonOptionalNonMinusNodesWith(final List<IGroupMemberNode> ordered,final boolean recomputeDefinitelyProduced){\n  nonOptionalNonMinusNodes.clear();\n  nonOptionalNonMinusNodes.addAll(ordered);\n  if (recomputeDefinitelyProduced) {\n    recomputeDefinitelyProduced();\n  }\n}\n", "docstring": "the new ordered list of non - optional non - minus nodes . if recomputeddefinitelyproduced variables is set to false , the definitely produced variables will not be recomputed ( this is a performance tweak which can be exploited when reordering the nodes only , for instance ) .", "partition": "test"}
{"idx": "4163", "code": "public static String toString(Accountable a){\n  StringBuilder sb=new StringBuilder();\n  toString(sb,a,0);\n  return sb.toString();\n}\n", "docstring": "returns a string description of an accountable and any nested resources . this is intended for development and debugging .", "partition": "test"}
{"idx": "4164", "code": "@Override public int hashCode(){\n  return type << 16 | value.hashCode() << 8 | otherValue.hashCode();\n}\n", "docstring": "returns a hash code for this node .", "partition": "test"}
{"idx": "4165", "code": "protected void deleteTypeVertex(AtlasVertex instanceVertex,DataTypes.TypeCategory typeCategory,boolean force) throws AtlasException {\nswitch (typeCategory) {\ncase STRUCT:\ncase TRAIT:\n    deleteTypeVertex(instanceVertex,force);\n  break;\ncase CLASS:\ndeleteEntities(Collections.singletonList(instanceVertex));\nbreak;\ndefault :\nthrow new IllegalStateException(\"Type category \" + typeCategory + \" not handled\");\n}\n}\n", "docstring": "deletes a type vertex - can be entity ( class type ) or just vertex ( struct / trait type )", "partition": "test"}
{"idx": "4166", "code": "public static List<String> readToList(Reader r) throws IOException {\n  try (BufferedReader in=new BufferedReader(r)){\n    List<String> l=new ArrayList<>();\n    String line=null;\n    while ((line=in.readLine()) != null)     l.add(line);\n    return Collections.unmodifiableList(l);\n  }\n }\n", "docstring": "read the reader line for line and return the result in a list", "partition": "test"}
{"idx": "4167", "code": "@SuppressWarnings(\"unchecked\") public void addCacheContext(GridCacheContext cacheCtx) throws IgniteCheckedException {\n  if (ctxMap.containsKey(cacheCtx.cacheId())) {\n    GridCacheContext<K,V> existing=ctxMap.get(cacheCtx.cacheId());\n    throw new IgniteCheckedException(\"Failed to start cache due to conflicting cache ID \" + \"(change cache name and restart grid) [cacheName=\" + cacheCtx.name() + \", conflictingCacheName=\"+ existing.name()+ \']\');\n  }\n  CacheStoreManager mgr=cacheCtx.store();\n  if (mgr.configured() && mgr.isLocal())   locStoreCnt.incrementAndGet();\n  ctxMap.put(cacheCtx.cacheId(),cacheCtx);\n}\n", "docstring": "adds cache context to shared cache context .", "partition": "test"}
{"idx": "4168", "code": "protected static boolean isCglibGetCallbacks(AnnotatedMethod am){\n  Class<?> rt=am.getRawType();\n  if (rt == null || !rt.isArray()) {\n    return false;\n  }\n  Class<?> compType=rt.getComponentType();\n  Package pkg=compType.getPackage();\n  if (pkg != null) {\n    String pname=pkg.getName();\n    if (pname.startsWith(\"net.sf.cglib\") || pname.startsWith(\"org.hibernate.repackage.cglib\")) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "this method was added to address [ jackson - 53 ", "partition": "test"}
{"idx": "4169", "code": "public int compareTo(NamedMediaType other){\n  return _name.compareTo(other._name);\n}\n", "docstring": "compares this namedmediatype to another .", "partition": "test"}
{"idx": "4170", "code": "public boolean isModified(){\nsynchronized (this) {\n    if (_isChecking || _isModified) {\n      return _isModified;\n    }\n    _isChecking=true;\n  }\n  try {\n    long now;\n    now=CurrentTime.currentTime();\n    if (now < _lastCheckTime + _checkInterval)     return _isModified;\n    _lastCheckTime=now;\n    for (int i=_dependencyList.size() - 1; i >= 0; i--) {\n      Dependency dependency=_dependencyList.get(i);\n      if (dependency.isModified()) {\n        dependency.logModified(log());\n        _isModified=true;\n        return _isModified;\n      }\n    }\n    return _isModified;\n  }\n  finally {\n    _isChecking=false;\n  }\n}\n", "docstring": "returns true if the underlying dependencies have changed .", "partition": "test"}
{"idx": "4171", "code": "protected ReplacedElement newIrreplaceableImageElement(int cssWidth,int cssHeight){\n  BufferedImage missingImage;\n  ReplacedElement mre;\n  try {\n    missingImage=ImageUtil.createCompatibleBufferedImage(cssWidth,cssHeight,BufferedImage.TYPE_INT_RGB);\n    Graphics2D g=missingImage.createGraphics();\n    g.setColor(Color.BLACK);\n    g.setBackground(Color.WHITE);\n    g.setFont(new Font(\"Serif\",Font.PLAIN,12));\n    g.drawString(\"Missing\",0,12);\n    g.dispose();\n    mre=new ImageReplacedElement(missingImage,cssWidth,cssHeight);\n  }\n catch (  Exception e) {\n    mre=new EmptyReplacedElement(cssWidth < 0 ? 0 : cssWidth,cssHeight < 0 ? 0 : cssHeight);\n  }\n  return mre;\n}\n", "docstring": "returns a replacedelement for some element in the stream which should be replaceable , but is not . this might be the case for an element like img , where the source isn \"'\" t provided .", "partition": "test"}
{"idx": "4172", "code": "public boolean greaterThan(FXGVersion version){\n  return (compareTo(version) > 0);\n}\n", "docstring": "compares whether this fxgversion \"'\" s value is greater than the value of the version parameter .", "partition": "test"}
{"idx": "4173", "code": "@Override public DataSource createDataSource(Properties properties) throws SQLException {\n  Properties propertiesCopy=new Properties();\n  if (properties != null) {\n    propertiesCopy.putAll(properties);\n  }\n  rejectUnsupportedOptions(propertiesCopy);\n  rejectPoolingOptions(propertiesCopy);\n  JdbcDataSource dataSource=new JdbcDataSource();\n  setupH2DataSource(dataSource,propertiesCopy);\n  return dataSource;\n}\n", "docstring": "creates a basic data source .", "partition": "test"}
{"idx": "4174", "code": "public Set<String> find(T object){\n  if (!locations.containsKey(object)) {\n    locations.put(object,new HashSet<>());\n  }\n  return Collections.unmodifiableSet(locations.get(object));\n}\n", "docstring": "find the names of a given object .", "partition": "test"}
{"idx": "4175", "code": "private void scrollCurrentItemToCenter(){\n  final ViewItem currItem=mViewItems[BUFFER_CENTER];\n  if (currItem == null) {\n    return;\n  }\n  final int currentViewCenter=currItem.getCenterX();\n  if (mController.isScrolling() || mIsUserScrolling || isCurrentItemCentered()) {\n    Log.d(TAG,\"[fling] mController.isScrolling() - \" + mController.isScrolling());\n    return;\n  }\n  int snapInTime=(int)(SNAP_IN_CENTER_TIME_MS * ((float)Math.abs(mCenterX - currentViewCenter)) / mDrawArea.width());\n  Log.d(TAG,\"[fling] Scroll to center.\");\n  mController.scrollToPosition(currentViewCenter,snapInTime,false);\n}\n", "docstring": "keep the current item in the center . this functions does not check if the current item is null .", "partition": "test"}
{"idx": "4176", "code": "public void addMetaObject(MetaObject object){\n  for (int k=0; k < MetaObjects.size(); ++k) {\n    if (MetaObjects.get(k) == null) {\n      MetaObjects.set(k,object);\n      return;\n    }\n  }\n  MetaObjects.add(object);\n}\n", "docstring": "add a metaobject to the state .", "partition": "test"}
{"idx": "4177", "code": "public boolean remove(String word){\n  return m_Words.remove(word);\n}\n", "docstring": "removes the word from the stopword list", "partition": "test"}
{"idx": "4178", "code": "public synchronized void addRecentItem(T item){\n  item=fromString(toString(item));\n  if (m_RecentItems.size() > 0) {\n    if (item.equals(m_RecentItems.get(0)))     return;\n  }\n  m_RecentItems.remove(item);\n  m_RecentItems.add(0,item);\n  while (m_RecentItems.size() > m_MaxCount)   m_RecentItems.remove(m_RecentItems.size() - 1);\n  if (m_IgnoreChanges)   return;\n  writeProps();\n  updateMenu();\n  notifyRecentItemListenersOfAdd(item);\n}\n", "docstring": "adds the item to the internal list .", "partition": "test"}
{"idx": "4179", "code": "public void testInvokeAll2() throws InterruptedException {\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    List<Future<String>> r=e.invokeAll(new ArrayList<Callable<String>>());\n    assertTrue(r.isEmpty());\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "invokeall ( empty collection ) returns empty collection", "partition": "test"}
{"idx": "4180", "code": "public void cfgPackage(ConfigurationValue cfgval,String name,String desc){\n  packages.add(new PackageInfo(name,desc));\n  packageNames.add(name);\n}\n", "docstring": "assigns description to a package", "partition": "test"}
{"idx": "4181", "code": "@Override public void close() throws IOException {\n  input.close();\n}\n", "docstring": "closes this stream . this implementation closes the source stream .", "partition": "test"}
{"idx": "4182", "code": "private void createBlockMirrorData(String name,int numBlockMirrors) throws Exception {\n  Volume volume=new Volume();\n  URI volumeURI=URIUtil.createId(Volume.class);\n  testVolumeURIs.add(volumeURI);\n  volume.setId(volumeURI);\n  volume.setLabel(\"blockMirrorVolume\");\n  URI cgUri=createBlockConsistencyGroup(\"blockMirrorVolume-cg\");\n  volume.setConsistencyGroup(cgUri);\n  _dbClient.createObject(volume);\n  for (int i=1; i <= numBlockMirrors; i++) {\n    BlockMirror blockMirror=new BlockMirror();\n    URI blockMirrorURI=URIUtil.createId(BlockMirror.class);\n    testBlockMirrorURIs.add(blockMirrorURI);\n    blockMirror.setId(blockMirrorURI);\n    blockMirror.setLabel(name + i);\n    blockMirror.setConsistencyGroup(cgUri);\n    _dbClient.createObject(blockMirror);\n  }\n}\n", "docstring": "creates the blockobject blockmirror data .", "partition": "test"}
{"idx": "4183", "code": "@Override public synchronized void start(){\n  if (running) {\n    return;\n  }\n  LOGGER.info(\"Starting server\");\n  if (endpoints.isEmpty()) {\n    int port=config.getInt(NetworkConfig.Keys.COAP_PORT);\n    LOGGER.log(Level.INFO,\"No endpoints have been defined for server, setting up server endpoint on default port {0}\",port);\n    addEndpoint(new CoapEndpoint(port,this.config));\n  }\n  int started=0;\n  for (  Endpoint ep : endpoints) {\n    try {\n      ep.start();\n      ++started;\n    }\n catch (    IOException e) {\n      LOGGER.log(Level.SEVERE,\"Cannot start server endpoint [\" + ep.getAddress() + \"]\",e);\n    }\n  }\n  if (started == 0) {\n    throw new IllegalStateException(\"None of the server endpoints could be started\");\n  }\n else {\n    running=true;\n  }\n}\n", "docstring": "starts the server by starting all endpoints this server is assigned to . each endpoint binds to its port . if no endpoint is assigned to the server , an endpoint is started on the port defined in the config .", "partition": "test"}
{"idx": "4184", "code": "public boolean retainAll(AbstractFloatList other){\n  if (other.size() == 0) {\n    if (size == 0)     return false;\n    setSize(0);\n    return true;\n  }\n  int limit=other.size() - 1;\n  int j=0;\n  for (int i=0; i < size; i++) {\n    if (other.indexOfFromTo(getQuick(i),0,limit) >= 0)     setQuick(j++,getQuick(i));\n  }\n  boolean modified=(j != size);\n  setSize(j);\n  return modified;\n}\n", "docstring": "retains ( keeps ) only the elements in the receiver that are contained in the specified other list . in other words , removes from the receiver all of its elements that are not contained in the specified other list .", "partition": "test"}
{"idx": "4185", "code": "protected void clearResult(){\n  md.clearResult();\n  localizationResult.setText(\"<HTML>Result: <BR><BR><BR></HTML>\");\n}\n", "docstring": "clears the result that may has been set .", "partition": "test"}
{"idx": "4186", "code": "public static <T>String toString(Collection<T> collection){\n  if (collection == null) {\n    return \"null\";\n  }\n  if (collection.isEmpty()) {\n    return \"\";\n  }\n  StringBuilder buf=new StringBuilder();\n  String delimiter=\"\";\n  for (  T t : collection) {\n    if (t == null) {\n      continue;\n    }\n    buf.append(delimiter);\n    buf.append(t);\n    delimiter=\", \";\n  }\n  return buf.toString();\n}\n", "docstring": "returns a list of the elements invoking tostring on non - null elements .", "partition": "test"}
{"idx": "4187", "code": "public static float between(float val,float min,float max){\n  return Math.max(Math.min(val,max),min);\n}\n", "docstring": "check if value within allowed range .", "partition": "test"}
{"idx": "4188", "code": "public static StringBuffer replaceString(StringBuffer buffer,String[] parameters){\n  int placeHolderPosition=-1;\n  String placeHolder=null;\n  for (int i=0; i < parameters.length; i++) {\n    if (parameters[i] == null) {\n      break;\n    }\n    placeHolder=\"%\" + (i + 1) + \"%\";\n    placeHolderPosition=buffer.indexOf(placeHolder);\n    if (placeHolderPosition != -1) {\n      buffer.replace(placeHolderPosition,placeHolderPosition + placeHolder.length(),parameters[i]);\n    }\n else {\n      break;\n    }\n  }\n  return buffer;\n}\n", "docstring": "replaces the place holders by parameters", "partition": "test"}
{"idx": "4189", "code": "private static int lookupQualSelector(XMPNode arrayNode,String qualName,String qualValue,int aliasForm) throws XMPException {\n  if (XML_LANG.equals(qualName)) {\n    qualValue=Utils.normalizeLangValue(qualValue);\n    int index=XMPNodeUtils.lookupLanguageItem(arrayNode,qualValue);\n    if (index < 0 && (aliasForm & AliasOptions.PROP_ARRAY_ALT_TEXT) > 0) {\n      XMPNode langNode=new XMPNode(ARRAY_ITEM_NAME,null);\n      XMPNode xdefault=new XMPNode(XML_LANG,X_DEFAULT,null);\n      langNode.addQualifier(xdefault);\n      arrayNode.addChild(1,langNode);\n      return 1;\n    }\n else {\n      return index;\n    }\n  }\n else {\n    for (int index=1; index < arrayNode.getChildrenLength(); index++) {\n      XMPNode currItem=arrayNode.getChild(index);\n      for (Iterator it=currItem.iterateQualifier(); it.hasNext(); ) {\n        XMPNode qualifier=(XMPNode)it.next();\n        if (qualName.equals(qualifier.getName()) && qualValue.equals(qualifier.getValue())) {\n          return index;\n        }\n      }\n    }\n    return -1;\n  }\n}\n", "docstring": "searches for a qualifier selector in a node : [ ? qualname = \" value \" ", "partition": "test"}
{"idx": "4190", "code": "public boolean isMultipleAllowed(String frameID){\n  return multipleFrames.contains(frameID);\n}\n", "docstring": "are multiple occurrences of frame allowed", "partition": "test"}
{"idx": "4191", "code": "public String[] parseConfiguration(File xmlFile) throws SAXException, IOException {\n  Document document=builder.parse(xmlFile);\n  return (parseConfiguration(document));\n}\n", "docstring": "parse an xml configuration from a file", "partition": "test"}
{"idx": "4192", "code": "private double empiricalHSIC(TetradMatrix Ky,TetradMatrix Kx,TetradMatrix Kz,int m){\n  TetradMatrix Kyx=Ky.times(Kx);\n  TetradMatrix Kyz=Ky.times(Kz);\n  TetradMatrix Kzx=Kz.times(Kx);\n  TetradMatrix Kzreg=Kz.copy();\n  for (int i=0; i < m; i++) {\n    double ent=(Kzreg.get(i,i) + this.regularizer);\n    Kzreg.set(i,i,ent);\n  }\n  TetradMatrix A=Kzreg.inverse();\n  Kzreg=A.times(A);\n  TetradMatrix Kyzzregzx=new TetradMatrix(m,m);\n  A=Kyz.times(Kzreg);\n  Kyzzregzx=A.times(Kzx);\n  TetradMatrix Kyzzregzxzzregz=Kyzzregzx.copy();\n  Kyzzregzxzzregz=Kyzzregzx.times(Kz);\n  A=Kyzzregzxzzregz.times(Kzreg);\n  Kyzzregzxzzregz=A.times(Kz);\n  double empHSIC=0.0;\n  for (int i=0; i < m; i++) {\n    empHSIC+=Kyx.get(i,i);\n    empHSIC+=(-2 * Kyzzregzx.get(i,i));\n    empHSIC+=Kyzzregzxzzregz.get(i,i);\n  }\n  empHSIC/=Math.pow(m - 1,2);\n  double Bz=0.0;\n  for (int i=0; i < (m - 1); i++) {\n    for (int j=(i + 1); j < m; j++) {\n      Bz+=Math.pow(Kz.get(i,j),2);\n      Bz+=Math.pow(Kz.get(j,i),2);\n    }\n  }\n  Bz=(m * (m - 1)) / Bz;\n  empHSIC*=Bz;\n  return empHSIC;\n}\n", "docstring": "empirical conditional hilbert - schmidt dependence measure y and x given z", "partition": "test"}
{"idx": "4193", "code": "public void create(String[] rpfFilePaths,String outputFile) throws MakeTocException {\n  create(rpfFilePaths,outputFile,false);\n}\n", "docstring": "create a a . toc file specificed by the frame file list , at the location specified .", "partition": "test"}
{"idx": "4194", "code": "private synchronized void postEvent(EventInfo eventInfo){\n  eventQueue.add(eventInfo);\n  notifyAll();\n}\n", "docstring": "queue the given event in the event queue .", "partition": "test"}
{"idx": "4195", "code": "private void processBmpImage(BufferedImage image){\n  if (!isError) {\n    File outputFile=new File(path,prefix + (numPage + 1) + \".bmp\");\n    try {\n      ImageIO.write(image,\"bmp\",outputFile);\n      addTempFile(outputFile);\n      addScanFile(outputFile);\n      numPage++;\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n      endProcess(true,false);\n    }\n  }\n}\n", "docstring": "procesa el escaneo de una imagen en modo nativo", "partition": "test"}
{"idx": "4196", "code": "public PathHandler(String path){\n  this(Paths.get(path));\n}\n", "docstring": "convenience method to create a path . calls init ( ) automatically .", "partition": "test"}
{"idx": "4197", "code": "public boolean loadLines(){\n  boolean result=false;\n  try {\n    m_parser.parse(new InputSource(m_reader),this);\n    result=true;\n    m_success=true;\n  }\n catch (  SAXException e) {\n    m_errorMessage=\"ErrorParsingData\";\n    m_errorDescription=e.getMessage();\n  }\ncatch (  IOException e) {\n    m_errorMessage=\"ErrorReadingData\";\n    m_errorDescription=e.getMessage();\n  }\n  return result;\n}\n", "docstring": "read statementlines from inputstream .", "partition": "test"}
{"idx": "4198", "code": "private void loadIgnoreFile(final String srcFolder){\n  ignoreFile=IgnoreFile.load(srcFolder);\n  if (ignoreFile == null) {\n    loadDefaultExcludePattern(srcFolder);\n  }\n}\n", "docstring": "load ignore file using . tfignore file from users ; if user does not specify . tfignore , using ours !", "partition": "test"}
{"idx": "4199", "code": "public boolean removeArg(final BOp arg){\n  if (arg == null)   throw new IllegalArgumentException();\n  if (arg == this)   throw new IllegalArgumentException();\n  if (args.remove(arg)) {\n    mutation();\n    return true;\n  }\n  return false;\n}\n", "docstring": "remove the 1st occurrence of the argument ( core mutation method ) .", "partition": "test"}
{"idx": "4200", "code": "public static boolean looksLikeAListStyleType(String val){\n  return LIST_TYPES.indexOf(val) >= 0;\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "4201", "code": "public PKCS10Attribute(PKCS9Attribute attr){\n  this.attributeId=attr.getOID();\n  this.attributeValue=attr.getValue();\n}\n", "docstring": "constructs an attribute from pkcs9 attribute .", "partition": "test"}
{"idx": "4202", "code": "public void createNote(Note note){\n  SQLiteDatabase db=getWritableDatabase();\n  String spannableAsHtml=Html.toHtml(note.getSpannable());\n  String date=dt.format(new Date());\n  ContentValues values=new ContentValues();\n  values.put(KEY_SPANNABLE_NOTE,spannableAsHtml);\n  values.put(KEY_NOTE_TITLE,note.getTitle());\n  values.put(KEY_IMAGE,BitmapConverter.getBytes(note.getImage()));\n  values.put(KEY_DATE_UPDATED,date);\n  db.insert(TABLE_NOTES,null,values);\n  db.close();\n}\n", "docstring": "method used to put note object into database", "partition": "test"}
{"idx": "4203", "code": "void addNext(Node<T> n){\n  nextNodes.add(n);\n  Collections.sort(nextNodes,isVertical ? verticalComparator : horizontalComparator);\n}\n", "docstring": "adds a \" next \" node ( node to the right or bottom ) to this divider \"'\" s list of next nodes .", "partition": "test"}
{"idx": "4204", "code": "protected void configDialogPropertyChange(PropertyChangeEvent event){\n  log.debug(\"internal config dialog handler\");\n  firePropertyChange(PropertyChangeID.CONFIG_CHANGE,event.getOldValue(),event.getNewValue());\n}\n", "docstring": "callback for the config dialog", "partition": "test"}
{"idx": "4205", "code": "public final String readUTF() throws IOException {\n  return decodeUTF(readUnsignedShort());\n}\n", "docstring": "see the general contract of the readutf method of datainput . bytes for this operation are read from the contained input stream .", "partition": "test"}
{"idx": "4206", "code": "private void myAdd(LinkedList<Integer> l,int i){\n  l.add(i);\n}\n", "docstring": "for debugging purposes , it \"'\" s useful to insert print statements here .", "partition": "test"}
{"idx": "4207", "code": "public static RepaintManager currentManager(Component c){\n  return currentManager(AppContext.getAppContext());\n}\n", "docstring": "return the repaintmanager for the calling thread given a component .", "partition": "test"}
{"idx": "4208", "code": "private boolean isRecoverPointInitiator(String portWWN){\n  return portWWN.contains(RECOVERPOINT_INITIATOR_PREFIX);\n}\n", "docstring": "determines if the given port wwn is a recoverpoint initiator .", "partition": "test"}
{"idx": "4209", "code": "@Override public void send(Buffer buffer){\n  _outProxy.write(_outWriter,buffer,false);\n}\n", "docstring": "initialization when the websocket completes .", "partition": "test"}
{"idx": "4210", "code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase EipPackage.ROUTE__OWNED_ENDPOINTS:\n    return ownedEndpoints != null && !ownedEndpoints.isEmpty();\ncase EipPackage.ROUTE__OWNED_CHANNELS:\n  return ownedChannels != null && !ownedChannels.isEmpty();\ncase EipPackage.ROUTE__NAME:\nreturn NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);\ncase EipPackage.ROUTE__EXCHANGE_TYPE:\nreturn exchangeType != EXCHANGE_TYPE_EDEFAULT;\n}\nreturn super.eIsSet(featureID);\n}\n", "docstring": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "4211", "code": "public void addSection(final Section SECTION){\n  if (null == SECTION)   return;\n  sections.add(SECTION);\n  Collections.sort(sections,new SectionComparator());\n  fireUpdateEvent(SECTION_EVENT);\n}\n", "docstring": "adds the given section to the list of sections . sections in the medusa library usually are less eye - catching than areas .", "partition": "test"}
{"idx": "4212", "code": "private int calculatePreferredWrapPosition(@NotNull Editor editor,@NotNull CharSequence text,int tabSize,int spaceSize,int startLineOffset,int endLineOffset,int targetRangeEndOffset){\n  boolean hasTabs=false;\n  boolean canOptimize=true;\n  boolean hasNonSpaceSymbols=false;\n  loop:   for (int i=startLineOffset; i < Math.min(endLineOffset,targetRangeEndOffset); i++) {\n    char c=text.charAt(i);\nswitch (c) {\ncase '\\t':\n{\n        hasTabs=true;\n        if (hasNonSpaceSymbols) {\n          canOptimize=false;\n          break loop;\n        }\n      }\ncase ' ':\n    break;\ndefault :\n  hasNonSpaceSymbols=true;\n}\n}\nif (!hasTabs) {\nreturn wrapPositionForTextWithoutTabs(startLineOffset,endLineOffset,targetRangeEndOffset);\n}\n else if (canOptimize) {\nreturn wrapPositionForTabbedTextWithOptimization(text,tabSize,startLineOffset,endLineOffset,targetRangeEndOffset);\n}\n else {\nreturn wrapPositionForTabbedTextWithoutOptimization(editor,text,spaceSize,startLineOffset,endLineOffset,targetRangeEndOffset);\n}\n}\n", "docstring": "checks if it \"'\" s worth to try to wrap target line ( it \"'\" s long enough ) and tries to calculate preferred wrap position .", "partition": "test"}
{"idx": "4213", "code": "public void addAll(OVector v){\n  expandFor(size + v.size - 1,null);\n  System.arraycopy(v.vector,0,vector,size - v.size,v.size);\n}\n", "docstring": "adds all the values in the given vector to the end of this vector , expanding its capacity as necessary .", "partition": "test"}
{"idx": "4214", "code": "public static void pipeAll(InputStream inStr,OutputStream outStr) throws IOException {\n  byte[] bs=new byte[BUFFER_SIZE];\n  int numRead;\n  while ((numRead=inStr.read(bs,0,bs.length)) >= 0) {\n    outStr.write(bs,0,numRead);\n  }\n}\n", "docstring": "write the full contents of instr to the destination stream outstr .", "partition": "test"}
{"idx": "4215", "code": "protected abstract boolean validateNumber(ConversationContext context,Number input);\n", "docstring": "validates a number , for use cases where you may need the number to be within a range", "partition": "test"}
{"idx": "4216", "code": "public void sendMessageUntilStopCount(int stopCount){\n  for (int i=processedWorkerCount; i < workers.size(); ++i) {\n    ActorRef worker=workers.get(i);\n    try {\n      Thread.sleep(1L);\n    }\n catch (    InterruptedException e) {\n      logger.error(\"sleep exception \" + e + \" details: \",e);\n    }\n    worker.tell(OperationWorkerMsgType.PROCESS_REQUEST,originalManager);\n    processedWorkerCount++;\n    if (processedWorkerCount > stopCount) {\n      return;\n    }\n    logger.debug(\"REQ_SENT: {} / {} taskId {}\",processedWorkerCount,requestTotalCount,taskIdTrim);\n  }\n}\n", "docstring": "note that if there is sleep in this method .", "partition": "test"}
{"idx": "4217", "code": "public static ArrayList<String> stringToArrayList(String string){\n  return new ArrayList<>(Arrays.asList(string.split(\",\")));\n}\n", "docstring": "make arraylist from \" , \" separated string", "partition": "test"}
{"idx": "4218", "code": "private String pickCharset(){\n  if (charset != null) {\n    return charset;\n  }\n else   if (utf8Supported) {\n    return \"UTF-8\";\n  }\n else {\n    return System.getProperty(\"file.encoding\");\n  }\n}\n", "docstring": "returns the name of the charset that should be used in textual transmissions .", "partition": "test"}
{"idx": "4219", "code": "public void addLayer(final LayerDefinition layer){\n  layer.setMap(this);\n  layers.add(layer);\n}\n", "docstring": "adds a new layer to the map .", "partition": "test"}
{"idx": "4220", "code": "private List<Rule> readRules(Reader reader) throws IOException, IllegalArgumentException {\n  BufferedReader in=new BufferedReader(reader);\n  List<Rule> rules=new ArrayList<Rule>();\n  String line;\n  while ((line=in.readLine()) != null) {\n    if (line.length() == 0) {\n      continue;\n    }\n    line=line.trim();\n    char first=line.charAt(0);\n    boolean sign=false;\nswitch (first) {\ncase \'+\':\n      sign=true;\n    break;\ncase \'-\':\n  sign=false;\nbreak;\ncase \' \':\ncase \'\\n\':\ncase \'#\':\ncontinue;\ndefault :\nthrow new IOException(\"Invalid first character: \" + line);\n}\nString regex=line.substring(1);\nif (LOG.isTraceEnabled()) {\nLOG.trace(\"Adding rule [\" + regex + \"]\");\n}\nRule rule=createRule(sign,regex);\nrules.add(rule);\n}\nreturn rules;\n}\n", "docstring": "read the specified file of rules .", "partition": "test"}
{"idx": "4221", "code": "@Override public void write(char c[],int off,int len){\n  if ((off < 0) || (off > c.length) || (len < 0)|| ((off + len) > c.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return;\n  }\n  int newcount=count + len;\n  if (newcount > buf.length) {\n    buf=Arrays.copyOf(buf,Math.max(buf.length << 1,newcount));\n  }\n  System.arraycopy(c,off,buf,count,len);\n  count=newcount;\n}\n", "docstring": "writes characters to the buffer .", "partition": "test"}
{"idx": "4222", "code": "@Deprecated public static EpisodeMatchingResult detectEpisodeFromFilename(File file){\n  LOGGER.debug(\"Detect episodes/seasons from file \" + file.getName());\n  EpisodeMatchingResult result=new EpisodeMatchingResult();\n  String fileName=file.getName();\n  result=parseString(fileName);\n  Collections.sort(result.episodes);\n  Matcher matcher=stackingMarkerPattern.matcher(result.name);\n  result.stackingMarkerFound=matcher.matches();\n  LOGGER.debug(\"returning result \" + result);\n  return result;\n}\n", "docstring": "detect episode from filename .", "partition": "test"}
{"idx": "4223", "code": "public static TypedOperation createArrayCreation(ArrayType arrayType){\n  List<Type> typeList=new ArrayList<>();\n  typeList.add(JavaTypes.INT_TYPE);\n  TypeTuple inputTypes=new TypeTuple(typeList);\n  return new TypedTermOperation(new ArrayCreation(arrayType),inputTypes,arrayType);\n}\n", "docstring": "creates a simple array creation operation for the given type .", "partition": "test"}
{"idx": "4224", "code": "public void fireEvent(final SPARQLUpdateEvent e){\n  if (isReadOnly())   throw new UnsupportedOperationException();\n  if (e == null)   throw new IllegalArgumentException();\n  if (listeners.isEmpty()) {\n    return;\n  }\n  final ISPARQLUpdateListener[] a=listeners.toArray(new ISPARQLUpdateListener[0]);\n  for (  ISPARQLUpdateListener l : a) {\n    final ISPARQLUpdateListener listener=l;\n    try {\n      listener.updateEvent(e);\n    }\n catch (    Throwable t) {\n      if (InnerCause.isInnerCause(t,InterruptedException.class)) {\n        throw new RuntimeException(t);\n      }\n      log.error(t,t);\n    }\n  }\n}\n", "docstring": "send an event to all registered listeners .", "partition": "test"}
{"idx": "4225", "code": "public PreferenceBuilder<PreferenceClass> prefType(Class<PreferenceClass> prefType){\n  if (!VALID_TYPES.contains(prefType)) {\n    throw new IllegalArgumentException(\"The specified type: \" + prefType + \" is not supported in preferences\");\n  }\n  this.prefType=prefType;\n  return this;\n}\n", "docstring": "the type of preference to retrieve", "partition": "test"}
{"idx": "4226", "code": "protected boolean isNumeric(String text){\n  text=text.trim();\n  int tlen=text.length();\n  for (int i=0; i < tlen; i++) {\n    if (Character.isDigit(text.charAt(i)) == false) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "utility method for subclasses to determine if an entire string is digits", "partition": "test"}
{"idx": "4227", "code": "public static boolean isChar(String desc){\n  return desc.endsWith(\"C\");\n}\n", "docstring": "tells whether a given type is a char", "partition": "test"}
{"idx": "4228", "code": "public RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {\n  decode(encoded);\n  RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(),e);\n}\n", "docstring": "construct a key from its encoding . used by rsakeyfactory .", "partition": "test"}
{"idx": "4229", "code": "public boolean isClientAuthentication(){\n  return clientAuthentication;\n}\n", "docstring": "returns a boolean flag to determine if this message will be sent to a server that requires client authentication .", "partition": "test"}
{"idx": "4230", "code": "private JPanel createImageFilePanel(){\n  JPanel panel=new JPanel();\n  panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));\n  panel.add(imageFileName);\n  panel.add(Box.createHorizontalStrut(6));\n  panel.add(new JButton(openImageFile));\n  return panel;\n}\n", "docstring": "create and return the image file panel .", "partition": "test"}
{"idx": "4231", "code": "void writeLine(BufferedWriter writer,String line) throws IOException {\n  writer.write(line);\n  writer.newLine();\n}\n", "docstring": "writes the given line with the given writer , followed by a new line .", "partition": "test"}
{"idx": "4232", "code": "public Layer childAt(int index){\n  return children.get(index);\n}\n", "docstring": "returns the layer at the specified index . layers are ordered in terms of their depth and will be returned in this order , with 0 being the layer on bottom .", "partition": "test"}
{"idx": "4233", "code": "public static Function<Value,Value> ofValue(){\n  return VALUE;\n}\n", "docstring": "the identity function for value conversion - returns the value untouched .", "partition": "test"}
{"idx": "4234", "code": "public static String removeQuotes(String s){\n  if (s == null) {\n    return null;\n  }\n  String trimmed=s.trim();\n  if (trimmed.length() == 0) {\n    return trimmed;\n  }\n  int i=nextNonQuoteIndex(trimmed,0,true);\n  int j=nextNonQuoteIndex(trimmed,trimmed.length() - 1,false);\n  return trimmed.substring(i,j + 1);\n}\n", "docstring": "trims white spaces and remove quotes from the string .", "partition": "test"}
{"idx": "4235", "code": "public DBasicConstraints(JDialog parent,byte[] value) throws IOException {\n  super(parent);\n  setTitle(res.getString(\"DBasicConstraints.Title\"));\n  initComponents();\n  prepopulateWithValue(value);\n}\n", "docstring": "creates a new dbasicconstraints dialog .", "partition": "test"}
{"idx": "4236", "code": "public FloatColumn(int nrows,int capacity,float defaultValue){\n  super(float.class,new Float(defaultValue));\n  if (capacity < nrows) {\n    throw new IllegalArgumentException(\"Capacity value can not be less than the row count.\");\n  }\n  m_values=new float[capacity];\n  Arrays.fill(m_values,defaultValue);\n  m_size=nrows;\n}\n", "docstring": "create a new floatcolumn .", "partition": "test"}
{"idx": "4237", "code": "void readPRJ() throws IOException {\n  while (true) {\n    String S=isr.readLine();\n    if (S == null)     return;\n    if (S.startsWith(\"EOP\"))     return;\n  }\n}\n", "docstring": "read prj records ( in fact does nothing )", "partition": "test"}
{"idx": "4238", "code": "private void checkAlterPeriodConverters() throws SecurityException {\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n  }\n}\n", "docstring": "checks whether the user has permission \"'\" convertermanager . alterperiodconverters \"'\" .", "partition": "test"}
{"idx": "4239", "code": "public boolean equals(final ArtifactCoordinates obj){\n  return this == obj || obj != null && groupId.equals(obj.groupId) && artifactId.equals(obj.artifactId) && version.equals(obj.version) && classifier.equals(obj.classifier);\n}\n", "docstring": "determine whether this coordinates object equals the target object .", "partition": "test"}
{"idx": "4240", "code": "public void importFromChange(Change sourceChange){\n  if (sourceChange.revision() > 0) {\n    this.revisionId=new NumericLiteralImpl(sourceChange.revision());\n  }\n  if (sourceChange.timestamp() != null) {\n    Date date=sourceChange.timestamp();\n    Calendar c=Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"),Locale.ROOT);\n    c.setTime(date);\n    this.lastModified=new LiteralImpl(DatatypeConverter.printDate(c),XMLSchema.DATETIME);\n  }\n}\n", "docstring": "import revision data from change object .", "partition": "test"}
{"idx": "4241", "code": "protected PrintWriter lineFileOut(Document doc){\n  return lineFileOut;\n}\n", "docstring": "selects output line file by written doc . default : original output line file .", "partition": "test"}
{"idx": "4242", "code": "@Override public Query newFuzzyQuery(String text,int fuzziness){\n  if (settings.lowercaseExpandedTerms()) {\n    text=text.toLowerCase(settings.locale());\n  }\n  BooleanQuery.Builder bq=new BooleanQuery.Builder();\n  bq.setDisableCoord(true);\n  for (  Map.Entry<String,Float> entry : weights.entrySet()) {\n    try {\n      Query q=new FuzzyQuery(new Term(entry.getKey(),text),fuzziness);\n      q.setBoost(entry.getValue());\n      bq.add(q,BooleanClause.Occur.SHOULD);\n    }\n catch (    RuntimeException e) {\n      rethrowUnlessLenient(e);\n    }\n  }\n  return super.simplify(bq.build());\n}\n", "docstring": "dispatches to lucene \"'\" s simplequeryparser \"'\" s newfuzzyquery , optionally lowercasing the term first", "partition": "test"}
{"idx": "4243", "code": "public CallChainInfo(SootMethod m,Stmt s,String type){\n  this.type=type;\n  this.link=\"as_call\";\n  this.method=m;\n  this.stmt=s;\n  calls=1;\n  if (type.equals(\"syscall\"))   syscalls=1;\n}\n", "docstring": "creates a call from stmt s to sootmethod m", "partition": "test"}
{"idx": "4244", "code": "public void startPlayback(){\n  Log.d(TAG,\">> startPlayback\");\n  if (null == mRecordFile) {\n    Log.e(TAG,\"no file to playback!\");\n    return;\n  }\n  mPlayer=new MediaPlayer();\n  try {\n    mPlayer.setDataSource(mRecordFile.getAbsolutePath());\n    Log.d(TAG,\"MediaPlayer.setDataSource(\" + mRecordFile.getAbsolutePath() + \")\");\n    mPlayer.setOnCompletionListener(this);\n    mPlayer.setOnErrorListener(this);\n    mPlayer.prepare();\n    Log.d(TAG,\"MediaPlayer.prepare()\");\n    mPlayer.start();\n  }\n catch (  IOException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\ncatch (  IllegalArgumentException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\ncatch (  SecurityException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\ncatch (  IllegalStateException e) {\n    Log.e(TAG,\"Exception while trying to playback recording file: \" + e);\n    setError(ERROR_PLAYER_INTERNAL);\n    return;\n  }\n  setState(STATE_PLAYBACK);\n  Log.d(TAG,\"<< startPlayback\");\n}\n", "docstring": "play current recorded file , if failed notify error message to caller , if success update fm recorder state", "partition": "test"}
{"idx": "4245", "code": "public static void notEmpty(String string,String msg){\n  if (string == null || string.length() == 0)   throw new IllegalArgumentException(msg);\n}\n", "docstring": "validates that the string is not empty", "partition": "test"}
{"idx": "4246", "code": "public static void resetContext(){\n  contexts.set(null);\n}\n", "docstring": "resets the current context", "partition": "test"}
{"idx": "4247", "code": "public static Object convertToParameterValues(Object object){\n  Collection<Object> collection;\n  if (object instanceof Object[]) {\n    collection=Arrays.asList((Object[])object);\n  }\n else   if (object instanceof Collection) {\n    collection=(Collection<Object>)object;\n  }\n else {\n    LOGGER.warn(\"Unable to convert value, ignoring\");\n    return new Object[]{};\n  }\n  List<Object> s=new LinkedList<Object>();\n  for (  Object o : collection) {\n    Object converted=convertToParameterValue(o);\n    if (converted instanceof Object[]) {\n      s.addAll(Arrays.asList((Object[])converted));\n    }\n else {\n      s.add(converted);\n    }\n  }\n  return s.toArray(new Object[s.size()]);\n}\n", "docstring": "converts an array / collection of values ( the object ) to a parameter values array . resources should not be converted . use via converttoparametervalue ( to deal with non - lists )", "partition": "test"}
{"idx": "4248", "code": "public boolean logoutUser(String username,HttpServletRequest req){\n  return logoutUser(username,req,true,true);\n}\n", "docstring": "basic internal api call to authsvc to logout a user .", "partition": "test"}
{"idx": "4249", "code": "public static Operation createOperationToUpdateOrCreateNetworkInterface(ComputeState existingComputeState,NetworkInterfaceState networkInterface,List<String> tenantLinks,StatelessService service,boolean isPublic){\n  String existingInterfaceLink=getExistingNetworkInterfaceLink(existingComputeState,isPublic);\n  Operation networkInterfaceOperation=null;\n  if (existingInterfaceLink == null) {\n    networkInterfaceOperation=createPostOperation(service,networkInterface,NetworkInterfaceService.FACTORY_LINK);\n  }\n else {\n    networkInterfaceOperation=createPatchOperation(service,networkInterface,existingInterfaceLink);\n  }\n  return networkInterfaceOperation;\n}\n", "docstring": "compares the ip addresses of the instance on aws and maps those to the network interfaces in the system . 1 ) if an existing mapping is found for a private or public interface then it is updated . 2 ) else a new mapping is creating . 3 ) the string \" public - interface / private - interfaces \" is embedded in the document self link along with the uuid to avoid collisions while save some extra lookups during updates .", "partition": "test"}
{"idx": "4250", "code": "public CodeSourceFacade(final CodeSource codeSource){\n  this.location=codeSource.getLocation();\n  final Certificate[] certificates=codeSource.getCertificates();\n  if (null == certificates || 0 == certificates.length) {\n    LOGGER.warning(String.format(\"no certificate found for %s\",codeSource));\n    this.firstCertificate=null;\n    return;\n  }\n  this.firstCertificate=(X509Certificate)certificates[0];\n}\n", "docstring": "creates a new code source .", "partition": "test"}
{"idx": "4251", "code": "public JdpBroadcaster(InetAddress address,InetAddress srcAddress,int port,int ttl) throws IOException, JdpException {\n  this.addr=address;\n  this.port=port;\n  ProtocolFamily family=(address instanceof Inet6Address) ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n  channel=DatagramChannel.open(family);\n  channel.setOption(StandardSocketOptions.SO_REUSEADDR,true);\n  channel.setOption(StandardSocketOptions.IP_MULTICAST_TTL,ttl);\n  if (srcAddress != null) {\n    NetworkInterface interf=NetworkInterface.getByInetAddress(srcAddress);\n    try {\n      channel.bind(new InetSocketAddress(srcAddress,0));\n    }\n catch (    UnsupportedAddressTypeException ex) {\n      throw new JdpException(\"Unable to bind to source address\");\n    }\n    channel.setOption(StandardSocketOptions.IP_MULTICAST_IF,interf);\n  }\n}\n", "docstring": "create a new broadcaster", "partition": "test"}
{"idx": "4252", "code": "public void close() throws IOException {\n  rrdFile.close();\n}\n", "docstring": "closes this database stream and releases any associated system resources .", "partition": "test"}
{"idx": "4253", "code": "public Vector rotateInDegree(double degree){\n  return rotateInRadian(Math.toRadians(degree));\n}\n", "docstring": "return a new instance of vector rotated from the given number of degrees .", "partition": "test"}
{"idx": "4254", "code": "public static String toString(final URI uri,final Charset encoding) throws IOException {\n  return IOUtils.toString(uri.toURL(),Charsets.toCharset(encoding));\n}\n", "docstring": "gets the contents at the given uri .", "partition": "test"}
{"idx": "4255", "code": "public void put(int fieldNumber,FieldData data){\n  int i=binarySearch(fieldNumber);\n  if (i >= 0) {\n    mData[i]=data;\n  }\n else {\n    i=~i;\n    if (i < mSize && mData[i] == DELETED) {\n      mFieldNumbers[i]=fieldNumber;\n      mData[i]=data;\n      return;\n    }\n    if (mGarbage && mSize >= mFieldNumbers.length) {\n      gc();\n      i=~binarySearch(fieldNumber);\n    }\n    if (mSize >= mFieldNumbers.length) {\n      int n=idealIntArraySize(mSize + 1);\n      int[] nkeys=new int[n];\n      FieldData[] nvalues=new FieldData[n];\n      System.arraycopy(mFieldNumbers,0,nkeys,0,mFieldNumbers.length);\n      System.arraycopy(mData,0,nvalues,0,mData.length);\n      mFieldNumbers=nkeys;\n      mData=nvalues;\n    }\n    if (mSize - i != 0) {\n      System.arraycopy(mFieldNumbers,i,mFieldNumbers,i + 1,mSize - i);\n      System.arraycopy(mData,i,mData,i + 1,mSize - i);\n    }\n    mFieldNumbers[i]=fieldNumber;\n    mData[i]=data;\n    mSize++;\n  }\n}\n", "docstring": "adds a mapping from the specified fieldnumber to the specified data , replacing the previous mapping if there was one .", "partition": "test"}
{"idx": "4256", "code": "void hideBorder(){\n  Insets insets=getInsets();\n  setBorder(BorderFactory.createEmptyBorder(insets.top,insets.left,insets.bottom,insets.right));\n}\n", "docstring": "hide the special border of the title bar .", "partition": "test"}
{"idx": "4257", "code": "public void remove(String btxn){\nsynchronized (filterMap) {\n    FilterProcessor oldfp=filterMap.get(btxn);\n    if (oldfp != null) {\n      globalExclusionFilters.remove(oldfp);\n      btxnFilters.remove(oldfp);\n    }\n  }\n}\n", "docstring": "this method removes the business transaction .", "partition": "test"}
{"idx": "4258", "code": "public void add(double weight,double x,double y){\n  observations.add(new WeightedObservedPoint(weight,x,y));\n}\n", "docstring": "adds a point to the sample .", "partition": "test"}
{"idx": "4259", "code": "public boolean addTagId(final Long tagId){\n  if (tagId != null && tagId > 0) {\n    return tagIds.add(tagId);\n  }\n  return false;\n}\n", "docstring": "adds the given tag id to this request .", "partition": "test"}
{"idx": "4260", "code": "public void supportTlsIntolerantServer(SSLSocket socket){\n  socket.setEnabledProtocols(new String[]{\"SSLv3\"});\n}\n", "docstring": "attempt a secure connection with basic functionality to maximize compatibility . currently this uses ssl 3 . 0 .", "partition": "test"}
{"idx": "4261", "code": "@SuppressLint(\"NewApi\") @TargetApi(Build.VERSION_CODES.KITKAT) private static Platform findPlatform(){\n  try {\n    try {\n      Class.forName(\"com.android.org.conscrypt.OpenSSLSocketImpl\");\n    }\n catch (    ClassNotFoundException e) {\n      Class.forName(\"org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl\");\n    }\n    OptionalMethod<Socket> setUseSessionTickets=new OptionalMethod<>(null,\"setUseSessionTickets\",boolean.class);\n    OptionalMethod<Socket> setHostname=new OptionalMethod<>(null,\"setHostname\",String.class);\n    Method trafficStatsTagSocket=null;\n    Method trafficStatsUntagSocket=null;\n    OptionalMethod<Socket> getAlpnSelectedProtocol=null;\n    OptionalMethod<Socket> setAlpnProtocols=null;\n    try {\n      Class<?> trafficStats=Class.forName(\"android.net.TrafficStats\");\n      trafficStatsTagSocket=trafficStats.getMethod(\"tagSocket\",Socket.class);\n      trafficStatsUntagSocket=trafficStats.getMethod(\"untagSocket\",Socket.class);\n      try {\n        Class.forName(\"android.net.Network\");\n        getAlpnSelectedProtocol=new OptionalMethod<>(byte[].class,\"getAlpnSelectedProtocol\");\n        setAlpnProtocols=new OptionalMethod<>(null,\"setAlpnProtocols\",byte[].class);\n      }\n catch (      ClassNotFoundException ignored) {\n      }\n    }\n catch (    ClassNotFoundException|NoSuchMethodException ignored) {\n    }\n    return new Android(setUseSessionTickets,setHostname,trafficStatsTagSocket,trafficStatsUntagSocket,getAlpnSelectedProtocol,setAlpnProtocols);\n  }\n catch (  ClassNotFoundException ignored) {\n  }\n  try {\n    String negoClassName=\"org.eclipse.jetty.alpn.ALPN\";\n    Class<?> negoClass=Class.forName(negoClassName);\n    Class<?> providerClass=Class.forName(negoClassName + \"$Provider\");\n    Class<?> clientProviderClass=Class.forName(negoClassName + \"$ClientProvider\");\n    Class<?> serverProviderClass=Class.forName(negoClassName + \"$ServerProvider\");\n    Method putMethod=negoClass.getMethod(\"put\",SSLSocket.class,providerClass);\n    Method getMethod=negoClass.getMethod(\"get\",SSLSocket.class);\n    Method removeMethod=negoClass.getMethod(\"remove\",SSLSocket.class);\n    return new JdkWithJettyBootPlatform(putMethod,getMethod,removeMethod,clientProviderClass,serverProviderClass);\n  }\n catch (  ClassNotFoundException|NoSuchMethodException ignored) {\n  }\n  return new Platform();\n}\n", "docstring": "attempt to match the host runtime to a capable platform implementation .", "partition": "test"}
{"idx": "4262", "code": "public static List<ExecutionEntity> orderFromRootToLeaf(Collection<ExecutionEntity> executions){\n  List<ExecutionEntity> orderedList=new ArrayList<ExecutionEntity>(executions.size());\n  HashSet<String> previousIds=new HashSet<String>();\n  for (  ExecutionEntity execution : executions) {\n    if (execution.getParentId() == null) {\n      orderedList.add(execution);\n      previousIds.add(execution.getId());\n    }\n  }\n  while (orderedList.size() < executions.size()) {\n    for (    ExecutionEntity execution : executions) {\n      if (!previousIds.contains(execution.getId()) && previousIds.contains(execution.getParentId())) {\n        orderedList.add(execution);\n        previousIds.add(execution.getId());\n      }\n    }\n  }\n  return orderedList;\n}\n", "docstring": "takes in a collection of executions belonging to the same process instance . orders the executions in a list , first elements are the leaf , last element is the root elements .", "partition": "test"}
{"idx": "4263", "code": "public void initTKF91(){\n  int iNumNodes=iParent.length;\n  double iBeta[]=new double[iNumNodes];\n  iB=new double[iNumNodes];\n  iE=new double[iNumNodes];\n  iH=new double[iNumNodes];\n  iN=new double[iNumNodes];\n  iInitial=1.0;\n  for (int i=0; i < iNumNodes; i++) {\n    if (i == iNumNodes - 1) {\n      iBeta[i]=1.0 / iMu;\n      iH[i]=0.0;\n    }\n else {\n      iBeta[i]=Math.exp((iLambda - iMu) * iTau[i]);\n      iBeta[i]=(1.0 - iBeta[i]) / (iMu - iLambda * iBeta[i]);\n      iH[i]=Math.exp(-iMu * iTau[i]) * (1.0 - iLambda * iBeta[i]);\n    }\n    iB[i]=iLambda * iBeta[i];\n    iE[i]=iMu * iBeta[i];\n    iN[i]=(1.0 - iMu * iBeta[i]) * (1.0 - iB[i]) - iH[i];\n    iInitial*=(1.0 - iB[i]);\n  }\n}\n", "docstring": "populates the ib , ie , ih and in arrays , and iinitial value", "partition": "test"}
{"idx": "4264", "code": "public static String serializeExpression(Node s){\n  if (s instanceof ASTTerm) {\n    ASTTerm a=(ASTTerm)s;\n    return (a.isNotFlag() ? \"!\" : \"\") + \" \" + a.getTerm();\n  }\n  String prefix=\"\";\n  String suffix=\"\";\n  String join=\" \";\n  if (s instanceof ASTExpression) {\n    ASTExpression a=(ASTExpression)s;\n    prefix=(a.isNotFlag() ? \"!\" : \"\") + \"(\";\n    suffix=\")\";\n    join=\" \" + a.getType() + \" \";\n  }\n  List<String> children=new ArrayList<String>();\n  for (int i=0; i < s.jjtGetNumChildren(); i++) {\n    children.add(serializeExpression(s.jjtGetChild(i)));\n  }\n  return prefix + StringUtils.join(children,join) + suffix;\n}\n", "docstring": "serialize a node ( and it \"'\" s children ) to a parsable string .", "partition": "test"}
{"idx": "4265", "code": "private void defineInternalFrameMenuButtons(UIDefaults d){\n  String p=\"InternalFrame:InternalFrameTitlePane:\\\"InternalFrameTitlePane.menuButton\\\"\";\n  String c=PAINTER_PREFIX + \"TitlePaneMenuButtonPainter\";\n  d.put(p + \".WindowNotFocused\",new TitlePaneMenuButtonWindowNotFocusedState());\n  d.put(p + \".contentMargins\",new InsetsUIResource(0,0,0,0));\n  d.put(p + \"[Enabled].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_ENABLED));\n  d.put(p + \"[Disabled].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_DISABLED));\n  d.put(p + \"[MouseOver].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_MOUSEOVER));\n  d.put(p + \"[Pressed].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_PRESSED));\n  d.put(p + \"[Enabled+WindowNotFocused].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_ENABLED_WINDOWNOTFOCUSED));\n  d.put(p + \"[MouseOver+WindowNotFocused].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_MOUSEOVER_WINDOWNOTFOCUSED));\n  d.put(p + \"[Pressed+WindowNotFocused].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_PRESSED_WINDOWNOTFOCUSED));\n  d.put(p + \".icon\",new SeaGlassIcon(p,\"iconPainter\",19,18));\n}\n", "docstring": "initialize the internal frame menu button settings .", "partition": "test"}
{"idx": "4266", "code": "public static Workflow.Method restoreFromCloneMethod(URI storage,List<URI> clone,Boolean updateOpStatus,boolean isCG){\n  return new Workflow.Method(\"restoreFromCloneStep\",storage,clone,updateOpStatus,isCG);\n}\n", "docstring": "return a workflow . method for restorevolume", "partition": "test"}
{"idx": "4267", "code": "@Override public synchronized void removeDataSourceListener(DataSourceListener dsl){\n  m_dataSourceListeners.remove(dsl);\n}\n", "docstring": "remove a datasource listener", "partition": "test"}
{"idx": "4268", "code": "public String rightStr(String str,int length){\n  return str.substring(Math.max(0,str.length() - length));\n}\n", "docstring": "returns a substring of the given string , representing the \"'\" length \"'\" most - right characters", "partition": "test"}
{"idx": "4269", "code": "public void clearNameInUnoccupiedBlocks(){\n  for (int i=0; i < mBlockEntries.size(); i++) {\n    Block b=mBlockEntries.get(i);\n    if (b.getState() == Block.UNOCCUPIED) {\n      b.setValue(\"  \");\n    }\n  }\n}\n", "docstring": "this function clears the block values for blocks in this section .", "partition": "test"}
{"idx": "4270", "code": "public static Object unserialize(Data data){\n  try {\n    Class clazz=(Class)Class.forName((String)data.get(\"class\"));\n    if (clazz.isEnum()) {\n      return Enum.valueOf(clazz,data.get(\"value\"));\n    }\n else     if (clazz == Vector3D.class) {\n      return new Vector3D(data.get(\"x\"),data.get(\"y\"),data.get(\"z\"));\n    }\n else     if (clazz == Vector2D.class) {\n      return new Vector2D(data.get(\"x\"),(double)data.get(\"y\"));\n    }\n else {\n      return unserialize(clazz,data);\n    }\n  }\n catch (  Exception e) {\n    throw new DataException(e);\n  }\n}\n", "docstring": "loads an object from its stored data , with an unknown class . the class of the object must be stored within the data .", "partition": "test"}
{"idx": "4271", "code": "public static void onGridStop() throws InterruptedException {\nsynchronized (mux) {\n    if (gridCnt == 0)     return;\n    --gridCnt;\n    Thread timer0=timer;\n    if (gridCnt == 0 && timer0 != null) {\n      timer=null;\n      timer0.interrupt();\n      timer0.join();\n    }\n  }\n}\n", "docstring": "stops clock timer if all nodes into jvm were stopped .", "partition": "test"}
{"idx": "4272", "code": "public void pushTemplateFolder(@NotNull String folderName) throws IOException {\n  myLastTemplateFolders.push(resolveName(folderName));\n}\n", "docstring": "resolve the foldername and push the resulting folder as the last template folder .", "partition": "test"}
{"idx": "4273", "code": "public void printDepthFirst(){\n  print(new DepthFirstEnumerator(_firstNode));\n}\n", "docstring": "print , to system . out , the basic blocks in depth first order .", "partition": "test"}
{"idx": "4274", "code": "protected void drawHorizontalBezier(Canvas c,ILineDataSet dataSet){\n  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());\n  int entryCount=dataSet.getEntryCount();\n  Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);\n  Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);\n  int diff=(entryFrom == entryTo) ? 1 : 0;\n  int minx=Math.max(dataSet.getEntryIndex(entryFrom) - diff,0);\n  int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryIndex(entryTo) + 1),entryCount);\n  float phaseX=Math.max(0.f,Math.min(1.f,mAnimator.getPhaseX()));\n  float phaseY=mAnimator.getPhaseY();\n  cubicPath.reset();\n  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);\n  if (size - minx >= 2) {\n    Entry prev=dataSet.getEntryForIndex(minx);\n    Entry cur=prev;\n    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);\n    for (int j=minx + 1, count=Math.min(size,entryCount); j < count; j++) {\n      prev=dataSet.getEntryForIndex(j - 1);\n      cur=dataSet.getEntryForIndex(j);\n      final float cpx=(float)(prev.getXIndex()) + (float)(cur.getXIndex() - prev.getXIndex()) / 2.0f;\n      cubicPath.cubicTo(cpx,prev.getVal() * phaseY,cpx,cur.getVal() * phaseY,cur.getXIndex(),cur.getVal() * phaseY);\n    }\n  }\n  if (dataSet.isDrawFilledEnabled()) {\n    cubicFillPath.reset();\n    cubicFillPath.addPath(cubicPath);\n    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);\n  }\n  mRenderPaint.setColor(dataSet.getColor());\n  mRenderPaint.setStyle(Paint.Style.STROKE);\n  trans.pathValueToPixel(cubicPath);\n  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);\n  mRenderPaint.setPathEffect(null);\n}\n", "docstring": "draws a cubic line .", "partition": "test"}
{"idx": "4275", "code": "public void addEvent(SimEvent newEvent){\n  double eventTime=newEvent.eventTime();\n  if (eventTime >= maxTime) {\n    list.add(newEvent);\n    maxTime=eventTime;\n    return;\n  }\n  ListIterator<SimEvent> iterator=list.listIterator();\n  SimEvent event;\n  while (iterator.hasNext()) {\n    event=iterator.next();\n    if (event.eventTime() > eventTime) {\n      iterator.previous();\n      iterator.add(newEvent);\n      return;\n    }\n  }\n  list.add(newEvent);\n}\n", "docstring": "adds a new event to the queue . adding a new event to the queue preserves the temporal order of the events .", "partition": "test"}
{"idx": "4276", "code": "public DbSchemaEjbGenerator(GeneratedTables genTables,SchemaElement schemaElement){\n  this(genTables,schemaElement,CollectionType.COLLECTION,false,false,false);\n}\n", "docstring": "creates a generator for a set of beans .", "partition": "test"}
{"idx": "4277", "code": "@Override public void initialize(){\n  board=null;\nswitch (simPaneCtrl.getParamValueIndex(PARAM_INIT_CONF)) {\ncase 0:\n    board=new EightPuzzleBoard(new int[]{1,2,5,3,4,0,6,7,8});\n  break;\ncase 1:\nboard=new EightPuzzleBoard(new int[]{1,4,2,7,5,8,3,0,6});\nbreak;\ncase 2:\nboard=new EightPuzzleBoard(new int[]{0,8,7,6,5,4,3,2,1});\nbreak;\ncase 3:\nboard=new EightPuzzleBoard(new int[]{0,1,2,3,4,5,6,7,8});\nRandom r=new Random(System.currentTimeMillis());\nfor (int i=0; i < 200; i++) {\nswitch (r.nextInt(4)) {\ncase 0:\nboard.moveGapUp();\nbreak;\ncase 1:\nboard.moveGapDown();\nbreak;\ncase 2:\nboard.moveGapLeft();\nbreak;\ncase 3:\nboard.moveGapRight();\nbreak;\n}\n}\n}\nstateViewCtrl.initialize(board);\n}\n", "docstring": "displays the initialized board on the state view .", "partition": "test"}
{"idx": "4278", "code": "private void initTreeMap(){\n  if (entityType == null) {\n    entityType=\"Mouse\";\n  }\n  if (entityType.equalsIgnoreCase(\"Circle\")) {\n    imageMap=RotatingEntityManager.getCircle();\n  }\n  if (entityType.equalsIgnoreCase(\"Mouse\")) {\n    imageMap=RotatingEntityManager.getMouse();\n  }\n else   if (entityType.equalsIgnoreCase(\"Amy\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"amy\",20);\n  }\n else   if (entityType.equalsIgnoreCase(\"Arnold\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"arno\",20);\n  }\n else   if (entityType.equalsIgnoreCase(\"Boy\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"boy\",20);\n  }\n else   if (entityType.equalsIgnoreCase(\"Cow\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"cow\",25);\n  }\n else   if (entityType.equalsIgnoreCase(\"Girl\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"girl\",20);\n  }\n else   if (entityType.equalsIgnoreCase(\"Lion\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"lion\",15);\n  }\n else   if (entityType.equalsIgnoreCase(\"Susi\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"susi\",20);\n  }\n else   if (entityType.equalsIgnoreCase(\"Jake\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"jake\",20);\n  }\n else   if (entityType.equalsIgnoreCase(\"Steve\")) {\n    imageMap=RotatingEntityManager.getRotatingTileset(\"steve\",20);\n  }\n  update();\n}\n", "docstring": "initialize the tree map , which associates angles with images / animations .", "partition": "test"}
{"idx": "4279", "code": "public static File locateReplicatorHomeDir(){\n  if (replicatorHomeDir == null) {\n    String replicatorHome=System.getProperty(HOME_DIR);\n    if (replicatorHome == null)     replicatorHome=System.getProperty(\"user.dir\");\n    replicatorHomeDir=new File(replicatorHome);\n    if (!replicatorHomeDir.isDirectory()) {\n      throw new ServerRuntimeException(\"Replicator home does not exist or is invalid: \" + replicatorHomeDir);\n    }\n  }\n  return replicatorHomeDir;\n}\n", "docstring": "find and return the replicator home directory .", "partition": "test"}
{"idx": "4280", "code": "public StringData(String data){\n  m_data=data;\n}\n", "docstring": "creates a transferable capable of transferring the specified string .", "partition": "test"}
{"idx": "4281", "code": "void writeRepeatedSqr(DD xdd){\n  if (xdd.ge(DD.valueOf(1)))   throw new IllegalArgumentException(\"Argument must be < 1\");\n  int count=0;\n  while (xdd.doubleValue() > 1e-300) {\n    count++;\n    if (count == 100)     count=count;\n    double x=xdd.doubleValue();\n    DD xSqr=xdd.sqr();\n    String s=xSqr.toString();\n    DD xSqr2=DD.parse(s);\n    xdd=xSqr;\n  }\n}\n", "docstring": "this routine simply tests for robustness of the tostring function .", "partition": "test"}
{"idx": "4282", "code": "public java.lang.StringBuffer append(float f){\n  internal.append(f);\n  return this;\n}\n", "docstring": "appends the string representation of the float argument to this string buffer . the argument is converted to a string as if by the method string . valueof , and the characters of that string are then appended to this string buffer .", "partition": "test"}
{"idx": "4283", "code": "public static final void open(File file) throws NoSuchMethodException {\n  if (Platform.isMacOSX()) {\n    execArgs(\"open\",file.getAbsolutePath());\n  }\n else   if (Platform.isWindows()) {\n    if (file.isDirectory()) {\n      execArgs(\"explorer\",file.getAbsolutePath());\n    }\n else {\n      execArgs(\"start\",file.getAbsolutePath());\n    }\n  }\n else   if (Platform.isUnix() && hasUnixCommand(\"gnome-open\")) {\n    execArgs(\"gnome-open\",file.toString());\n  }\n else   if (Platform.isUnix() && hasUnixCommand(\"konqueror\")) {\n    execArgs(\"konqueror\",file.toString());\n  }\n else   if (Platform.isSolaris() && file.isDirectory()) {\n    execArgs(\"/usr/dt/bin/dtfile\",\"-folder\",file.getAbsolutePath());\n  }\n else {\n    throw new NoSuchMethodException(\"Cannot open files on this platform\");\n  }\n}\n", "docstring": "opens a file with the default system action .", "partition": "test"}
{"idx": "4284", "code": "@Override public String testDestination(Location destination,Track track){\n  String status=super.testDestination(destination,track);\n  if (!status.equals(Track.OKAY)) {\n    return status;\n  }\n  if (track == null) {\n    return status;\n  }\n  return track.checkSchedule(this);\n}\n", "docstring": "used to determine if a car can be set out at a destination ( location ) . track is optional . in addition to all of the tests that testlocation performs , spurs with schedules are also checked .", "partition": "test"}
{"idx": "4285", "code": "private static String[] norm(String path){\n  String[] elements=path.split(\"[/\\\\\\\\]\");\n  ArrayList<String> stack=new ArrayList<String>();\n  for (  String e : elements) {\n    if (e.isEmpty() || e.equals(\".\"))     continue;\n    if (e.equals(\"..\")) {\n      if (!stack.isEmpty())       stack.remove(stack.size() - 1);\n else       return null;\n      continue;\n    }\n    stack.add(e);\n  }\n  return stack.toArray(new String[stack.size()]);\n}\n", "docstring": "process a path into an array of folders", "partition": "test"}
{"idx": "4286", "code": "static Random random(){\n  if (null == LUCENE_TEST_CASE) {\n    return null;\n  }\n else {\n    try {\n      Method randomMethod=LUCENE_TEST_CASE.getMethod(\"random\");\n      return (Random)randomMethod.invoke(null);\n    }\n catch (    Exception e) {\n      throw new IllegalStateException(\"Unable to use reflection to invoke LuceneTestCase.random()\",e);\n    }\n  }\n}\n", "docstring": "returns a random to be used by the current thread if available , otherwise returns null .", "partition": "test"}
{"idx": "4287", "code": "protected String record(String deployment){\n  deployments.add(deployment);\n  return deployment;\n}\n", "docstring": "record the fact that something was deployed , resulting in the given deployment id . useful for cleaning up resources in an implementation - specific way in subclasses .", "partition": "test"}
{"idx": "4288", "code": "protected void onBeforeStart(BundleContext ctx){\n}\n", "docstring": "this method is called before ignite initialises . < p > the default implementation is empty . override it to introduce custom logic .", "partition": "test"}
{"idx": "4289", "code": "private static void shutDownMySQLAbandonedConnectionCleanupThread(ClassLoader classLoader){\n  try {\n    Class<?> mysqlCleanupThreadClass;\n    try {\n      mysqlCleanupThreadClass=classLoader.loadClass(\"com.mysql.jdbc.AbandonedConnectionCleanupThread\");\n    }\n catch (    ClassNotFoundException e) {\n      LOG.trace(\"Failed to load MySQL abandoned connection cleanup thread class. Presuming DB App is \" + \"not being run with MySQL and ignoring\",e);\n      return;\n    }\n    Method shutdownMethod=mysqlCleanupThreadClass.getMethod(\"shutdown\");\n    shutdownMethod.invoke(null);\n    LOG.debug(\"Successfully shutdown MySQL connection cleanup thread.\");\n  }\n catch (  Throwable e) {\n    LOG.warn(\"Failed to shutdown MySQL connection cleanup thread. Ignoring.\",e);\n  }\n}\n", "docstring": "shuts down a cleanup thread com . mysql . jdbc . abandonedconnectioncleanupthread that mysql driver fails to destroy if this is not done , the thread keeps a reference to the classloader , thereby causing ooms or too many open files", "partition": "test"}
{"idx": "4290", "code": "public void write(byte[] buffer){\n  if (isFinal) {\n    log.warning(\"attempting to write to a final SpeechData object\");\n    return;\n  }\n  byte[] newData=new byte[data.length + buffer.length];\n  System.arraycopy(data,0,newData,0,data.length);\n  System.arraycopy(buffer,0,newData,data.length,buffer.length);\n  data=newData;\n}\n", "docstring": "expands the current speech data by appending a new buffer of audio data", "partition": "test"}
{"idx": "4291", "code": "public String parse(String controlTemplate,Context controlContext) throws Exception {\n  this.controlContext=controlContext;\n  fillContextDefaults(this.controlContext);\n  fillContextProperties(this.controlContext);\n  Template template=getTemplate(controlTemplate,inputEncoding);\n  StringWriter sw=new StringWriter();\n  template.merge(controlContext,sw);\n  return sw.toString();\n}\n", "docstring": "parse the control template and merge it with the control context . this is the starting point in texen .", "partition": "test"}
{"idx": "4292", "code": "protected boolean onCreateCustomFromTag(XmlPullParser parser,T parent,final AttributeSet attrs) throws XmlPullParserException {\n  return false;\n}\n", "docstring": "before this inflater tries to create an item from the tag , this method will be called . the parser will be pointing to the start of a tag , you must stop parsing and return when you reach the end of this element !", "partition": "test"}
{"idx": "4293", "code": "public static long writeFile(String path,byte[] jpeg,ExifInterface exif) throws IOException {\n  if (!createDirectoryIfNeeded(path)) {\n    Log.e(TAG,\"Failed to create parent directory for file: \" + path);\n    return -1;\n  }\n  if (exif != null) {\n    exif.writeExif(jpeg,path);\n    File f=new File(path);\n    return f.length();\n  }\n else {\n    return writeFile(path,jpeg);\n  }\n}\n", "docstring": "writes the jpeg data to a file . if there \"'\" s exif info , the exif header will be added .", "partition": "test"}
{"idx": "4294", "code": "private boolean checkForImageServers(){\n  boolean imageServerExists=true;\n  List<URI> imageServerURIList=_dbClient.queryByType(ComputeImageServer.class,true);\n  ArrayList<URI> tempList=Lists.newArrayList(imageServerURIList.iterator());\n  if (tempList.isEmpty()) {\n    imageServerExists=false;\n  }\n  return imageServerExists;\n}\n", "docstring": "check if there are image servers in the system", "partition": "test"}
{"idx": "4295", "code": "public void removeExtension(String ext){\nsynchronized (exts) {\n    ext=ext.toLowerCase();\n    exts.remove(ext);\n  }\n}\n", "docstring": "this method removes an extension to the recognizer .", "partition": "test"}
{"idx": "4296", "code": "public void addObserver(Observer observer){\n  if (observer == null) {\n    throw new NullPointerException(\"observer == null\");\n  }\nsynchronized (this) {\n    if (!observers.contains(observer))     observers.add(observer);\n  }\n}\n", "docstring": "adds the specified observer to the list of observers . if it is already registered , it is not added a second time .", "partition": "test"}
{"idx": "4297", "code": "protected double distance(int i,int k,int[] designations){\n  return Math.sqrt(Math.max(selfK[i] - 2.0 / ownes[k] * evalSumK(i,k,designations) + meanSqrdNorms[k] * normConsts[k],0));\n}\n", "docstring": "computes the distance between one data point and a specified mean", "partition": "test"}
{"idx": "4298", "code": "public StringBuffer format(Object pat,StringBuffer result,FieldPosition fpos){\n  String pattern=processPattern((String)pat);\n  int lastOffset=0;\n  for (int i=0; i <= maxOffset; ++i) {\n    int offidx=offsets[i];\n    result.append(pattern.substring(lastOffset,offsets[i]));\n    lastOffset=offidx;\n    String key=arguments[i];\n    String obj;\n    if (key.length() > 0) {\n      obj=formatObject(processKey(key));\n    }\n else {\n      result.append(this.ldel);\n      result.append(this.rdel);\n      continue;\n    }\n    if (obj == null) {\n      String lessgreedy=ldel + key;\n      int fromright=lessgreedy.lastIndexOf(ldel);\n      if (fromright > 0) {\n        String newkey=lessgreedy.substring(fromright + ldel.length());\n        String newsubst=formatObject(processKey(newkey));\n        if (newsubst != null) {\n          obj=lessgreedy.substring(0,fromright) + newsubst;\n        }\n      }\n    }\n    if (obj == null) {\n      if (throwex) {\n        throw new IllegalArgumentException(\"ObjectForKey\");\n      }\n else {\n        obj=ldel + key + rdel;\n      }\n    }\n    result.append(obj);\n  }\n  result.append(pattern.substring(lastOffset,pattern.length()));\n  return result;\n}\n", "docstring": "formats the parsed string by inserting table \"'\" s values .", "partition": "test"}
{"idx": "4299", "code": "void release(Object owner,Field field){\n  Map<String,Integer> fields=owners.get(owner);\n  if (fields != null) {\n    release();\n    Integer count=fields.get(field.toGenericString());\n    if (--count > 0) {\n      fields.put(field.toGenericString(),count);\n    }\n else {\n      fields.remove(field.toGenericString());\n    }\n  }\n  if (fields != null && fields.isEmpty()) {\n    owners.remove(owner);\n  }\n}\n", "docstring": "release an instance injected as a field of an object", "partition": "test"}
{"idx": "4300", "code": "public static List<DashboardDto> transformToDto(List<Dashboard> dashboards){\n  if (dashboards == null) {\n    throw new WebApplicationException(\"Null entity object cannot be converted to Dto object.\",Status.INTERNAL_SERVER_ERROR);\n  }\n  List<DashboardDto> result=new ArrayList<DashboardDto>();\n  for (  Dashboard dashboard : dashboards) {\n    result.add(transformToDto(dashboard));\n  }\n  return result;\n}\n", "docstring": "converts list of alert entity objects to list of alertdto objects .", "partition": "test"}
{"idx": "4301", "code": "static Executor screenExecutor(Executor e){\n  if (!useCommonPool && e == ForkJoinPool.commonPool())   return asyncPool;\n  if (e == null)   throw new NullPointerException();\n  return e;\n}\n", "docstring": "null - checks user executor argument , and translates uses of commonpool to asyncpool in case parallelism disabled .", "partition": "test"}
{"idx": "4302", "code": "public void addGroupPropertiesListener(GroupPropertiesListener groupPropertiesListener){\n  groupPropertiesListeners.add(groupPropertiesListener);\n}\n", "docstring": "adds a group properties listener .", "partition": "test"}
{"idx": "4303", "code": "public static void editGlobalFunctionComment(final AbstractSQLProvider provider,final INaviFunction function,final Integer commentId,final Integer userId,final String newComment) throws CouldntSaveDataException {\n  PostgreSQLCommentFunctions.editComment(provider,commentId,userId,newComment);\n}\n", "docstring": "edits a global function comment .", "partition": "test"}
{"idx": "4304", "code": "public synchronized void clearSessions(Context context,Boolean clearCredentials){\nsynchronized (instance) {\n    while (mMXSessions.size() > 0) {\n      clearSession(context,mMXSessions.get(0),clearCredentials);\n    }\n  }\n}\n", "docstring": "clear any existing session .", "partition": "test"}
{"idx": "4305", "code": "public boolean doesEntryExists(SSOToken token,String entryDN){\n  try {\n    PersistentObject po=UMSObject.getObject(internalToken,new Guid(entryDN));\n  }\n catch (  UMSException ue) {\n    if (entryDN.indexOf(\"agents\") < 0) {\n      if (debug.messageEnabled()) {\n        debug.message(\"DirectoryServicesImpl.doesProfileExist(): + \" + \"Exception caught: \",ue);\n      }\n    }\n    return false;\n  }\n  return true;\n}\n", "docstring": "checks if the entry exists in the directory .", "partition": "test"}
{"idx": "4306", "code": "private static char[] yy_unpack_cmap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 86) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "docstring": "unpacks the compressed character translation table .", "partition": "test"}
{"idx": "4307", "code": "private static int hashWrapperName(String xn){\n  if (xn.length() < 3) {\n    return 0;\n  }\n  return (3 * xn.charAt(1) + xn.charAt(2)) % 16;\n}\n", "docstring": "class name to wrapper hash , derived from wrapper . hashwrap ( )", "partition": "test"}
{"idx": "4308", "code": "private void createPRWithTotalNumPropSetList(List vmList,int startIndexForRegion,int endIndexForRegion,int localMaxMemory,int redundancy){\n  Iterator nodeIterator=vmList.iterator();\n  while (nodeIterator.hasNext()) {\n    VM vm=(VM)nodeIterator.next();\n    vm.invoke(createMultiplePRWithTotalNumBucketPropSet(prPrefix,startIndexForRegion,endIndexForRegion,redundancy,localMaxMemory,11));\n  }\n}\n", "docstring": "this function creates a partition region with total_buckets_num_property set to 11 .", "partition": "test"}
{"idx": "4309", "code": "public Zdiagmat(Zmat A,int k) throws JampackException {\n  Parameters.BaseIndexNotChangeable=true;\n  basex=Parameters.BaseIndex;\n  if (k >= 0) {\n    if (k >= A.ncol) {\n      throw new JampackException(\"Diagonal out of range.\");\n    }\n    order=Math.min(A.nrow,A.ncol - k);\n    re=new double[order];\n    im=new double[order];\n    for (int i=0; i < order; i++) {\n      re[i]=A.re[i][i + k];\n      im[i]=A.im[i][i + k];\n    }\n  }\n else {\n    k=-k;\n    if (k >= A.nrow) {\n      throw new JampackException(\"Diagonal out of range.\");\n    }\n    order=Math.min(A.nrow - k,A.ncol);\n    re=new double[order];\n    im=new double[order];\n    for (int i=0; i < order; i++) {\n      re[i]=A.re[i + k][i];\n      im[i]=A.im[i + k][i];\n    }\n  }\n  getProperties();\n}\n", "docstring": "constructs a zdiagmat and initializes it to the diagonal of a zmat .", "partition": "test"}
{"idx": "4310", "code": "public void buildNetwork(){\n  Neuron firstNeuron=new Neuron(network,DEFAULT_NEURON_TYPE);\n  List<Neuron> currentLayer=new ArrayList<Neuron>();\n  firstNeuron.setPosition(initialPosition);\n  currentLayer.add(firstNeuron);\n  int numNeuronsLastLayer=(int)Math.pow(numBrachesPerNeuron,numLayers);\n  double totalSpace=numNeuronsLastLayer * horizontalSpacing;\n  for (int layerIndex=1; layerIndex <= numLayers; layerIndex++) {\n    List<Neuron> tempList=new ArrayList<Neuron>();\n    double layerSpacing=totalSpace / (int)Math.pow(numBrachesPerNeuron,layerIndex);\n    double branchWidth=layerSpacing * (numBrachesPerNeuron - 1);\n    for (    Neuron baseNeuron : currentLayer) {\n      network.addNeuron(baseNeuron);\n      double initialXOffset=branchWidth / 2;\n      for (int j=0; j < numBrachesPerNeuron; j++) {\n        Neuron targetNeuron=new Neuron(network,new LinearRule());\n        targetNeuron.setLocation(baseNeuron.getX() - initialXOffset + (j * layerSpacing),initialPosition.y - (layerIndex * verticalSpacing));\n        tempList.add(targetNeuron);\n        network.addNeuron(targetNeuron);\n        targetNeuron.setUpdatePriority(layerIndex);\n        Synapse synapse=new Synapse(network,baseNeuron,targetNeuron,new StaticSynapseRule());\n        network.addSynapse(synapse);\n      }\n    }\n    currentLayer=tempList;\n  }\n}\n", "docstring": "create the cascading network .", "partition": "test"}
{"idx": "4311", "code": "private static boolean areEqual(int fromIndex,CharSequence left,CharSequence right){\n  if (left == right)   return true;\n  if ((left == null) || (right == null))   return false;\n  int n=left.length();\n  if (right.length() != n)   return false;\n  for (int i=n; i > fromIndex; ) {\n    if (Character.toUpperCase(left.charAt(--i)) != Character.toUpperCase(right.charAt(i)))     return false;\n  }\n  return true;\n}\n", "docstring": "check for equality of the two characters sequences starting at the specified index", "partition": "test"}
{"idx": "4312", "code": "public Enumeration productions(){\n  return _productions.elements();\n}\n", "docstring": "access to productions with this non terminal on the lhs .", "partition": "test"}
{"idx": "4313", "code": "public void addTightSourceNode(ASTNode reference){\n  fTightSourceRangeNodes.add(reference);\n  List<StructuralPropertyDescriptor> properties=reference.structuralPropertiesForType();\n  for (Iterator<StructuralPropertyDescriptor> iterator=properties.iterator(); iterator.hasNext(); ) {\n    StructuralPropertyDescriptor descriptor=iterator.next();\n    if (descriptor.isChildProperty()) {\n      ASTNode child=(ASTNode)reference.getStructuralProperty(descriptor);\n      if (child != null && isExtending(child,reference)) {\n        addTightSourceNode(child);\n      }\n    }\n else     if (descriptor.isChildListProperty()) {\n      List<? extends ASTNode> children=(List<? extends ASTNode>)reference.getStructuralProperty(descriptor);\n      for (Iterator<? extends ASTNode> iterator2=children.iterator(); iterator2.hasNext(); ) {\n        ASTNode child=iterator2.next();\n        if (isExtending(child,reference)) {\n          addTightSourceNode(child);\n        }\n      }\n    }\n  }\n}\n", "docstring": "add the given node to the set of \" tight \" nodes .", "partition": "test"}
{"idx": "4314", "code": "protected boolean isEventDisabled(XEvent e){\nswitch (e.get_type()) {\ncase XConstants.ConfigureNotify:\n    return true;\ncase XConstants.EnterNotify:\ncase XConstants.LeaveNotify:\n  return true;\ndefault :\nreturn super.isEventDisabled(e);\n}\n}\n", "docstring": "end of i n s e t s c o d e", "partition": "test"}
{"idx": "4315", "code": "public DJarInfo(JFrame parent) throws IOException {\n  this(parent,res.getString(\"DJarInfo.Title\"),ModalityType.DOCUMENT_MODAL);\n}\n", "docstring": "creates new djarinfo dialog where the parent is a frame .", "partition": "test"}
{"idx": "4316", "code": "protected void transformPointArrayNoTouch(float[] pts){\n  mMatrixValueToPx.mapPoints(pts);\n  mMatrixOffset.mapPoints(pts);\n}\n", "docstring": "transform an array of points with all matrixes except the touch matrix - - > use this if the transformed values are not effected by touch gestures", "partition": "test"}
{"idx": "4317", "code": "private void convertEscapedFunction(final StringBuilder target,final CharSequence escapedFunction) throws FBSQLParseException {\n  final String templateResult=FBEscapedFunctionHelper.convertTemplate(escapedFunction.toString(),mode);\n  target.append(templateResult != null ? templateResult : escapedFunction);\n}\n", "docstring": "this method converts escaped function to a server function call . actually we do not change anything here , we hope that all udf are defined .", "partition": "test"}
{"idx": "4318", "code": "public void addListener(ImsSessionListener listener){\n  mListeners.add(listener);\n}\n", "docstring": "add a listener for receiving events", "partition": "test"}
{"idx": "4319", "code": "public static IPath stampToPath(final long stamp){\n  fgCalendar.setTimeInMillis(stamp);\n  final StringBuffer buffer=new StringBuffer(256);\n  buffer.append(fgCalendar.get(Calendar.YEAR));\n  buffer.append(IPath.SEPARATOR);\n  buffer.append(fgCalendar.get(Calendar.MONTH) + 1);\n  buffer.append(IPath.SEPARATOR);\n  buffer.append(fgCalendar.get(Calendar.WEEK_OF_YEAR));\n  return new Path(buffer.toString());\n}\n", "docstring": "returns a path representing the history part for the specified time stamp .", "partition": "test"}
{"idx": "4320", "code": "public void printUserMessage(UserMessage message){\n  User user=message.user;\n  boolean ignored=message.ignored_compact;\n  if (ignored) {\n    printCompact(\"IGNORED\",user);\n    return;\n  }\n  Color color=message.color;\n  boolean action=message.action;\n  String text=message.text;\n  TagEmotes emotes=message.emotes;\n  boolean highlighted=message.highlighted;\n  if (message.whisper && message.action) {\n    color=StyleConstants.getForeground(styles.info());\n    highlighted=true;\n  }\n  closeCompactMode();\n  MutableAttributeSet style;\n  if (highlighted) {\n    style=styles.highlight(color);\n  }\n else {\n    style=styles.standard();\n  }\n  print(getTimePrefix(),style);\n  printUser(user,action,message.whisper,message.id);\n  if (!highlighted && action && styles.actionColored()) {\n    style=styles.standard(user.getDisplayColor());\n  }\n  printSpecials(text,user,style,emotes,false,message.bits > 0);\n  printNewline();\n}\n", "docstring": "output a regular message from a user .", "partition": "test"}
{"idx": "4321", "code": "public boolean connectImpl(String address,int port) throws IOException {\n  _socketTimeout=600000;\n  _nativeFd=-1;\n  _isClosed.set(false);\nsynchronized (_writeLock) {\n    boolean isConnect=nativeConnect(_socketFd,address,port);\n    return isConnect;\n  }\n}\n", "docstring": "creates the new server socket .", "partition": "test"}
{"idx": "4322", "code": "public static boolean isAccessModifier(String str){\n  return str.equals(\"static\") || str.equals(\"public\") || str.equals(\"protected\")|| str.equals(\"private\")|| str.equals(\"final\")|| str.equals(\"transient\");\n}\n", "docstring": "returns true if str is an access modifier , false otherwise .", "partition": "test"}
{"idx": "4323", "code": "protected void handleAppendRequestFailure(MemberState member,AppendRequest request,Throwable error){\n  failAttempt(member,error);\n}\n", "docstring": "handles an append failure .", "partition": "test"}
{"idx": "4324", "code": "public List<AddressItem> loadAllDeepFromCursor(Cursor cursor){\n  int count=cursor.getCount();\n  List<AddressItem> list=new ArrayList<AddressItem>(count);\n  if (cursor.moveToFirst()) {\n    if (identityScope != null) {\n      identityScope.lock();\n      identityScope.reserveRoom(count);\n    }\n    try {\n      do {\n        list.add(loadCurrentDeep(cursor,false));\n      }\n while (cursor.moveToNext());\n    }\n  finally {\n      if (identityScope != null) {\n        identityScope.unlock();\n      }\n    }\n  }\n  return list;\n}\n", "docstring": "reads all available rows from the given cursor and returns a list of new imageto objects .", "partition": "test"}
{"idx": "4325", "code": "public static String decode(byte[] utf8) throws CharacterCodingException {\n  return decode(ByteBuffer.wrap(utf8),true);\n}\n", "docstring": "converts the provided byte array to a string using the utf - 8 encoding . if the input is malformed , replace by a default value .", "partition": "test"}
{"idx": "4326", "code": "private Map<String,String> attributesToLowerCase(){\n  Map<String,String> lowerCaseAttributes=new LinkedHashMap<String,String>();\n  for (  String key : attributes.keySet()) {\n    lowerCaseAttributes.put(key.toLowerCase(),attributes.get(key));\n  }\n  return lowerCaseAttributes;\n}\n", "docstring": "returns a copy of the set of attributes for this node with lowercase names", "partition": "test"}
{"idx": "4327", "code": "public byte[] readNextPart() throws JPlagException {\n  if (remainingBytes == 0) {\n    throw new JPlagException(\"downloadException\",\"There\'s nothing left to be downloaded!\",\"\");\n  }\n  try {\n    FileInputStream in=new FileInputStream(file);\n    in.skip(filesize - remainingBytes);\n    int partsize=remainingBytes;\n    if (partsize > 81920)     partsize=81920;\n    byte[] data=new byte[partsize];\n    in.read(data);\n    in.close();\n    remainingBytes-=partsize;\n    return data;\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    throw new JPlagException(\"downloadException\",\"Unable to read\" + \" submission part from server!\",\"\");\n  }\n}\n", "docstring": "reads the next part of the related file", "partition": "test"}
{"idx": "4328", "code": "public boolean isMultiLineTabbed(){\n  return multiLineTab;\n}\n", "docstring": "whether using the tab key indents the selected lines of code", "partition": "test"}
{"idx": "4329", "code": "protected void computeParameters(){\n  if (m_SumOfWeights > 0) {\n    m_Mean=m_SumOfValues / m_SumOfWeights;\n    double stdDev=Math.sqrt(Math.abs(m_SumOfValuesSq - m_Mean * m_SumOfValues) / m_SumOfWeights);\n    if (stdDev > 1e-10) {\n      m_StandardDev=Math.max(m_Precision / (2 * 3),stdDev);\n    }\n  }\n}\n", "docstring": "compute the parameters of the distribution", "partition": "test"}
{"idx": "4330", "code": "public String translateDataType(String sourceVendorName,String targetVendorName,String dataType,int size,int scale){\n  return getDataType(targetVendorName,getDataTypeID(sourceVendorName,dataType),size,scale);\n}\n", "docstring": "translate data type from source to target database", "partition": "test"}
{"idx": "4331", "code": "public static List<ShapeRecord> rectangle(double startx,double starty,double width,double height,double radiusX,double radiusY,double topLeftRadiusX,double topLeftRadiusY,double topRightRadiusX,double topRightRadiusY,double bottomLeftRadiusX,double bottomLeftRadiusY,double bottomRightRadiusX,double bottomRightRadiusY){\n  List<ShapeRecord> shapeRecords=new ArrayList<ShapeRecord>();\n  if (radiusX == 0.0) {\n    radiusY=radiusX=0;\n  }\n else   if (radiusY == 0.0) {\n    radiusY=radiusX;\n  }\n  if (radiusX > width / 2.0)   radiusX=width / 2.0;\n  if (radiusY > height / 2.0)   radiusY=height / 2.0;\n  double[] topLeftRadius=getCornerRadius(topLeftRadiusX,topLeftRadiusY,radiusX,radiusY,width,height);\n  topLeftRadiusX=topLeftRadius[0];\n  topLeftRadiusY=topLeftRadius[1];\n  double[] topRightRadius=getCornerRadius(topRightRadiusX,topRightRadiusY,radiusX,radiusY,width,height);\n  topRightRadiusX=topRightRadius[0];\n  topRightRadiusY=topRightRadius[1];\n  double[] bottomLeftRadius=getCornerRadius(bottomLeftRadiusX,bottomLeftRadiusY,radiusX,radiusY,width,height);\n  bottomLeftRadiusX=bottomLeftRadius[0];\n  bottomLeftRadiusY=bottomLeftRadius[1];\n  double[] bottomRightRadius=getCornerRadius(bottomRightRadiusX,bottomRightRadiusY,radiusX,radiusY,width,height);\n  bottomRightRadiusX=bottomRightRadius[0];\n  bottomRightRadiusY=bottomRightRadius[1];\n  double c0=0.923879532511;\n  double c1=0.382683432365;\n  double c3=0.707106781187;\n  double rx=bottomRightRadiusX;\n  double ry=bottomRightRadiusY;\n  double tx=rx / 0.923879532511;\n  double ty=ry / 0.923879532511;\n  double dx, currentx;\n  double dy, currenty;\n  dx=startx + width - rx;\n  dy=starty + height - ry;\n  shapeRecords.add(move((dx + rx),dy));\n  currentx=(dx + rx);\n  currenty=dy;\n  if (bottomRightRadiusX != 0.0) {\n    shapeRecords.add(curvedEdge(currentx,currenty,(dx + c0 * tx),(dy + c1 * ty),(dx + c3 * rx),(dy + c3 * ry)));\n    shapeRecords.add(curvedEdge((dx + c3 * rx),(dy + c3 * ry),(dx + c1 * tx),(dy + c0 * ty),dx,(dy + ry)));\n    currentx=dx;\n    currenty=dy + ry;\n  }\n  rx=bottomLeftRadiusX;\n  ry=bottomLeftRadiusY;\n  tx=rx / 0.923879532511;\n  ty=ry / 0.923879532511;\n  dx=startx + rx;\n  dy=starty + height - ry;\n  shapeRecords.addAll(straightEdge(currentx,currenty,dx,(dy + ry)));\n  currentx=dx;\n  currenty=dy + ry;\n  if (bottomLeftRadiusX != 0.0) {\n    shapeRecords.add(curvedEdge(currentx,currenty,(dx - c1 * tx),(dy + c0 * ty),(dx - c3 * rx),(dy + c3 * ry)));\n    shapeRecords.add(curvedEdge((dx - c3 * rx),(dy + c3 * ry),(dx - c0 * tx),(dy + c1 * ty),(dx - rx),dy));\n    currentx=dx - rx;\n    currenty=dy;\n  }\n  rx=topLeftRadiusX;\n  ry=topLeftRadiusY;\n  tx=rx / 0.923879532511;\n  ty=ry / 0.923879532511;\n  dx=startx + rx;\n  dy=starty + ry;\n  shapeRecords.addAll(straightEdge(currentx,currenty,(dx - rx),dy));\n  currentx=dx - rx;\n  currenty=dy;\n  if (topLeftRadiusX != 0.0) {\n    shapeRecords.add(curvedEdge(currentx,currenty,(dx - c0 * tx),(dy - c1 * ty),(dx - c3 * rx),(dy - c3 * ry)));\n    shapeRecords.add(curvedEdge((dx - c3 * rx),(dy - c3 * ry),(dx - c1 * tx),(dy - c0 * ty),dx,(dy - ry)));\n    currentx=dx;\n    currenty=dy - ry;\n  }\n  rx=topRightRadiusX;\n  ry=topRightRadiusY;\n  tx=rx / 0.923879532511;\n  ty=ry / 0.923879532511;\n  dx=startx + width - rx;\n  dy=starty + ry;\n  shapeRecords.addAll(straightEdge(currentx,currenty,dx,(dy - ry)));\n  currentx=dx;\n  currenty=dy - ry;\n  if (topRightRadiusX != 0.0) {\n    shapeRecords.add(curvedEdge(currentx,currenty,(dx + c1 * tx),(dy - c0 * ty),(dx + c3 * rx),(dy - c3 * ry)));\n    shapeRecords.add(curvedEdge((dx + c3 * rx),(dy - c3 * ry),(dx + c0 * tx),(dy - c1 * ty),(dx + rx),dy));\n    currentx=(dx + rx);\n    currenty=dy;\n  }\n  rx=bottomRightRadiusX;\n  ry=bottomRightRadiusY;\n  tx=rx / 0.923879532511;\n  ty=ry / 0.923879532511;\n  dx=startx + width - rx;\n  dy=starty + height - ry;\n  shapeRecords.addAll(straightEdge(currentx,currenty,(dx + rx),dy));\n  return shapeRecords;\n}\n", "docstring": "creates a list of shaperecord to draw a rectangle from the given origin ( startx , starty ) for the specified width and height ( in pixels ) and radiusx and radiusy for rounded corners .", "partition": "test"}
{"idx": "4332", "code": "public static int findGlobalValleyLocation(double[] data){\n  double min=Double.NaN;\n  int imin=-1;\n  for (int i=0; i < data.length; i++) {\n    if (Double.isNaN(data[i]))     continue;\n    if (Double.isNaN(min) || data[i] < min) {\n      min=data[i];\n      imin=i;\n    }\n  }\n  return imin;\n}\n", "docstring": "find the minimum of all elements in the array , ignoring elements that are nan .", "partition": "test"}
{"idx": "4333", "code": "protected void moveDownSelected(){\n  int selectedIndex=table.getSelectedRow();\n  if (selectedIndex > -1) {\n    int index=data.moveDown(indexToModel(selectedIndex));\n    setRowSelected(indexToView(index));\n  }\n}\n", "docstring": "moves the selected item down in the model ( and table ) . this can behave kind of odd when the table is filtered or sorted automatically , so it should not be used then .", "partition": "test"}
{"idx": "4334", "code": "JarWithFile(PathImpl backing){\n  super(backing);\n}\n", "docstring": "creates a new jar .", "partition": "test"}
{"idx": "4335", "code": "public List<Runnable> shutdownNow(){\n  logger.info(\"Shutting down scanner immediately.\");\n  return executor.shutdownNow();\n}\n", "docstring": "shut down the scanner , interrupting running tasks and cancelling waiting ones .", "partition": "test"}
{"idx": "4336", "code": "public static List<String> toRelativePaths(@NotNull VirtualFile root,@NotNull final Collection<FilePath> filePaths){\n  ArrayList<String> rc=new ArrayList<String>(filePaths.size());\n  for (  FilePath path : filePaths) {\n    rc.add(relativePath(root,path));\n  }\n  return rc;\n}\n", "docstring": "covert list of files to relative paths", "partition": "test"}
{"idx": "4337", "code": "private void handleUnlockOrInstall(){\n  if (isFinishing()) {\n    return;\n  }\nswitch (mKeyStore.state()) {\ncase UNINITIALIZED:\n{\n      ensureKeyGuard();\n      return;\n    }\ncase LOCKED:\n{\n    new UnlockDialog();\n    return;\n  }\ncase UNLOCKED:\n{\n  if (!checkKeyGuardQuality()) {\n    new ConfigureKeyGuardDialog();\n    return;\n  }\n  installIfAvailable();\n  finish();\n  return;\n}\n}\n}\n", "docstring": "based on the current state of the keystore and key guard , try to make progress on unlocking or installing to the keystore .", "partition": "test"}
{"idx": "4338", "code": "private void offsetStartTimeIfNecessary(Time startTime,Time endTime,String rrule,CalendarEventModel model){\n  if (rrule == null || rrule.isEmpty()) {\n    return;\n  }\n  mEventRecurrence.parse(rrule);\n  if (mEventRecurrence.freq != EventRecurrence.WEEKLY) {\n    return;\n  }\n  if (mEventRecurrence.byday.length > mEventRecurrence.bydayCount) {\n    return;\n  }\n  int closestWeekday=Integer.MAX_VALUE;\n  int weekstart=EventRecurrence.day2TimeDay(mEventRecurrence.wkst);\n  int startDay=startTime.weekDay;\n  for (int i=0; i < mEventRecurrence.bydayCount; i++) {\n    int day=EventRecurrence.day2TimeDay(mEventRecurrence.byday[i]);\n    if (day == startDay) {\n      return;\n    }\n    if (day < weekstart) {\n      day+=7;\n    }\n    if (day > startDay && (day < closestWeekday || closestWeekday < startDay)) {\n      closestWeekday=day;\n    }\n    if (closestWeekday == Integer.MAX_VALUE || closestWeekday < startDay) {\n      if (day < closestWeekday) {\n        closestWeekday=day;\n      }\n    }\n  }\n  if (closestWeekday < startDay) {\n    closestWeekday+=7;\n  }\n  int daysOffset=closestWeekday - startDay;\n  startTime.monthDay+=daysOffset;\n  endTime.monthDay+=daysOffset;\n  long newStartTime=startTime.normalize(true);\n  long newEndTime=endTime.normalize(true);\n  model.mStart=newStartTime;\n  model.mEnd=newEndTime;\n}\n", "docstring": "if the recurrence rule is such that the event start date doesn \"'\" t actually fall in one of the recurrences , then push the start date up to the first actual instance of the event .", "partition": "test"}
{"idx": "4339", "code": "public Vector3 ceil(){\n  return new Vector3(Math.ceil(x),Math.ceil(y),Math.ceil(z));\n}\n", "docstring": "rounds the x , y , and z values of this vector3 up to the nearest integer value .", "partition": "test"}
{"idx": "4340", "code": "private void cleanUpFrontier(){\n  while (!frontier.isEmpty() && isExplored(frontier.element()))   frontier.remove();\n}\n", "docstring": "helper method which removes nodes of already explored states from the head of the frontier .", "partition": "test"}
{"idx": "4341", "code": "private void parseAttributes(TypedArray a){\n  barWidth=(int)a.getDimension(R.styleable.ProgressWheel_pwBarWidth,barWidth);\n  rimWidth=(int)a.getDimension(R.styleable.ProgressWheel_pwRimWidth,rimWidth);\n  spinSpeed=(int)a.getDimension(R.styleable.ProgressWheel_pwSpinSpeed,spinSpeed);\n  barLength=(int)a.getDimension(R.styleable.ProgressWheel_pwBarLength,barLength);\n  delayMillis=a.getInteger(R.styleable.ProgressWheel_pwDelayMillis,delayMillis);\n  if (delayMillis < 0) {\n    delayMillis=10;\n  }\n  if (a.hasValue(R.styleable.ProgressWheel_pwText)) {\n    setText(a.getString(R.styleable.ProgressWheel_pwText));\n  }\n  barColor=a.getColor(R.styleable.ProgressWheel_pwBarColor,barColor);\n  textColor=a.getColor(R.styleable.ProgressWheel_pwTextColor,textColor);\n  rimColor=a.getColor(R.styleable.ProgressWheel_pwRimColor,rimColor);\n  circleColor=a.getColor(R.styleable.ProgressWheel_pwCircleColor,circleColor);\n  contourColor=a.getColor(R.styleable.ProgressWheel_pwContourColor,contourColor);\n  textSize=(int)a.getDimension(R.styleable.ProgressWheel_pwTextSize,textSize);\n  contourSize=a.getDimension(R.styleable.ProgressWheel_pwContourSize,contourSize);\n  a.recycle();\n}\n", "docstring": "parse the attributes passed to the view from the xml", "partition": "test"}
{"idx": "4342", "code": "public static byte[] concatenate(byte[] a,byte[] b){\n  byte[] output=new byte[a.length + b.length];\n  System.arraycopy(a,0,output,0,a.length);\n  System.arraycopy(b,0,output,a.length,b.length);\n  return output;\n}\n", "docstring": "concatenates two byte arrays .", "partition": "test"}
{"idx": "4343", "code": "public static boolean isBeforeToday(Calendar _calendar){\n  return _calendar.before(Calendar.getInstance());\n}\n", "docstring": "allows to know if a given calendar instance is set before today", "partition": "test"}
{"idx": "4344", "code": "public static ViewItemGroup buildLoginUI(ModelApplication modelApp,Activity activity){\n  ViewItemGroup viewItems=new ViewItemGroup(activity);\n  TextView usernameText=new TextView(activity);\n  usernameText.setText(R.string.username);\n  viewItems.addView(usernameText);\n  ViewItemFactory viewItemFactory=ViewItemFactory.instance();\n  ViewItem usernameItem=viewItemFactory.create(LoginViewID.USERNAME,viewItemFactory.TEXT_DATATYPE_DB_ID,activity);\n  viewItems.addViewItem(usernameItem,new OmniText(modelApp.getUsername()));\n  TextView passwordText=new TextView(activity);\n  passwordText.setText(R.string.password);\n  viewItems.addView(passwordText);\n  ViewItem passwordItem=viewItemFactory.create(LoginViewID.PASSWORD,viewItemFactory.PASSWORD_INPUT_DATATYPE_DB_ID,activity);\n  viewItems.addViewItem(passwordItem,new OmniPasswordInput(modelApp.getPassword()));\n  return viewItems;\n}\n", "docstring": "build a standard login ui with username and password fields", "partition": "test"}
{"idx": "4345", "code": "public void unMapVolumeFromSCSIInitiator(String volumeId,String initiatorId) throws Exception {\n  String uri=ScaleIOConstants.getUnmapVolumeToScsiInitiatorURI(volumeId);\n  ScaleIOUnmapVolumeToScsiInitiator unmapParm=new ScaleIOUnmapVolumeToScsiInitiator();\n  unmapParm.setScsiInitiatorId(initiatorId);\n  post(URI.create(uri),getJsonForEntity(unmapParm));\n}\n", "docstring": "unmap the volume from scsi initiator", "partition": "test"}
{"idx": "4346", "code": "public Collection<T> asCollection(){\n  return this.list;\n}\n", "docstring": "returns the underlying collection .", "partition": "test"}
{"idx": "4347", "code": "private static void addQuarterArc(Path2D.Float path,float x1,float y1,float x2,float y2,float curvature,boolean verticalStart){\n  boolean down=y1 < y2;\n  boolean left=x1 > x2;\n  float cx1=0;\n  float cy1=0;\n  float cx2=0;\n  float cy2=0;\n  if (verticalStart) {\n    cx1=x1;\n    cy2=y2;\n    if (left) {\n      cx2=x1 - curvature;\n    }\n else {\n      cx2=x1 + curvature;\n    }\n    if (down) {\n      cy1=y2 - curvature;\n    }\n else {\n      cy1=y2 + curvature;\n    }\n  }\n else {\n    cx2=x2;\n    cy1=y1;\n    if (left) {\n      cx1=x2 + curvature;\n    }\n else {\n      cx1=x2 - curvature;\n    }\n    if (down) {\n      cy2=y1 + curvature;\n    }\n else {\n      cy2=y1 - curvature;\n    }\n  }\n  path.curveTo(cx1,cy1,cx2,cy2,x2,y2);\n}\n", "docstring": "add a quarter circular path to a given path object , starting from ( x1 , y1 ) to ( x2 , y2 ) .", "partition": "test"}
{"idx": "4348", "code": "@Override public void parse(String content,Node block){\n  this.block=block;\n  this.input=content.trim();\n  this.index=0;\n  this.lastDelimiter=null;\n  this.lastBracket=null;\n  boolean moreToParse;\n  do {\n    moreToParse=parseInline();\n  }\n while (moreToParse);\n  processDelimiters(null);\n  mergeTextNodes(block.getFirstChild(),block.getLastChild());\n}\n", "docstring": "parse content in block into inline children , using reference map to resolve references .", "partition": "test"}
{"idx": "4349", "code": "public static void random(byte[] b,int offset,int length){\n  checkPositionIndex(offset,b.length,\"offset\");\n  checkArgument(length > 0,\"length must be greater than 0\");\n  checkPositionIndex(offset + length,b.length,\"offset + length\");\n  byte[] buf=new byte[length];\n  RNG.nextBytes(buf);\n  System.arraycopy(buf,0,b,offset,length);\n}\n", "docstring": "fill given array with random bytes at the specified position .", "partition": "test"}
{"idx": "4350", "code": "public void removeAllScanningCallbacks(){\n  scanningCallbacks.clear();\n}\n", "docstring": "removes all scanning callbacks .", "partition": "test"}
{"idx": "4351", "code": "public int read(byte[] buf,int off,int len) throws TTransportException {\n  if (inputStream_ == null) {\n    throw new TTransportException(TTransportException.NOT_OPEN,\"Cannot read from null inputStream\");\n  }\n  int bytesRead;\n  try {\n    bytesRead=inputStream_.read(buf,off,len);\n  }\n catch (  IOException iox) {\n    throw new TTransportException(TTransportException.UNKNOWN,iox);\n  }\n  if (bytesRead < 0) {\n    throw new TTransportException(TTransportException.END_OF_FILE);\n  }\n  return bytesRead;\n}\n", "docstring": "reads from the underlying input stream if not null .", "partition": "test"}
{"idx": "4352", "code": "public void handleManagerCreation() throws ManagementException {\n  if (!isServiceInitialised(\"handleManagerCreation\")) {\n    return;\n  }\n  ObjectName managerMBeanName=MBeanJMXAdapter.getManagerName();\n  ManagerMBeanBridge bridge=new ManagerMBeanBridge(service);\n  ManagerMXBean bean=new ManagerMBean(bridge);\n  service.registerInternalMBean(bean,managerMBeanName);\n}\n", "docstring": "assumption is always cache and membermbean has been will be created first", "partition": "test"}
{"idx": "4353", "code": "@SuppressWarnings(\"unused\") private boolean checkSetShape(Shape oldShape,Shape newShape){\n  Shape currentShape=getShape();\n  assert oldShape != newShape : \"Wrong old shape assumption?\";\n  assert newShape != currentShape : \"Redundant shape change? shape=\" + currentShape;\n  assert oldShape == currentShape || oldShape.getParent() == currentShape : \"Out-of-order shape change?\" + \"\\nparentShape=\" + currentShape + \"\\noldShape=\"+ oldShape+ \"\\nnewShape=\"+ newShape;\n  return true;\n}\n", "docstring": "check whether fast transition is valid .", "partition": "test"}
{"idx": "4354", "code": "protected boolean isFileVisible(File file){\n  if (file == null || !file.exists() || !file.canRead() || file.isHidden()) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if the given file is visible", "partition": "test"}
{"idx": "4355", "code": "public static String[] append(final String[] a,final String... b){\n  final int alen=a.length;\n  final int blen=b.length;\n  final String[] res=Arrays.copyOf(a,alen + blen);\n  System.arraycopy(b,0,res,alen,blen);\n  return res;\n}\n", "docstring": "append strings to an array creating a new array for the result .", "partition": "test"}
{"idx": "4356", "code": "public void delete() throws AMException, SSOException {\n  delete(false);\n}\n", "docstring": "removes and destroys the object .", "partition": "test"}
{"idx": "4357", "code": "public String(byte[] bytes,int off,int len,java.lang.String enc) throws java.io.UnsupportedEncodingException {\n  this(bytesToChars(bytes,off,len,enc));\n}\n", "docstring": "construct a new string by converting the specified subarray of bytes using the specified character encoding . the length of the new string is a function of the encoding , and hence may not be equal to the length of the subarray . bytes - the bytes to be converted into charactersoff - index of the first byte to convertlen - number of bytes to convertenc - the name of a character encoding - if the named encoding is not supported jdk1 . 1", "partition": "test"}
{"idx": "4358", "code": "private boolean initializeSearchItemset(BitVector bv,int[] scratchi,int[] iters){\n  for (int i=0; i < scratchi.length; i++) {\n    iters[i]=(i == 0) ? bv.iter() : bv.iterAdvance(iters[i - 1]);\n    if (iters[i] < 0) {\n      return false;\n    }\n    scratchi[i]=bv.iterDim(iters[i]);\n  }\n  return true;\n}\n", "docstring": "initialize the scratch itemset .", "partition": "test"}
{"idx": "4359", "code": "private Rectangle computeEditorBounds(){\n  if (row == -1 || column == -1)   return new Rectangle(0,0,0,0);\n  Rectangle cell=grid.getCellBounds(column,row);\n  Rectangle area=grid.getClientArea();\n  if (cell.x < area.x + area.width) {\n    if (cell.x + cell.width > area.x + area.width) {\n      cell.width=area.x + area.width - cell.x;\n    }\n  }\n  Rectangle editorRect=new Rectangle(cell.x,cell.y,minimumWidth,minimumHeight);\n  if (grabHorizontal) {\n    editorRect.width=Math.max(cell.width,minimumWidth);\n  }\n  if (grabVertical) {\n    editorRect.height=Math.max(cell.height,minimumHeight);\n  }\n  if (horizontalAlignment == SWT.RIGHT) {\n    editorRect.x+=cell.width - editorRect.width;\n  }\n else   if (horizontalAlignment == SWT.LEFT) {\n  }\n else {\n    editorRect.x+=(cell.width - editorRect.width) / 2;\n  }\n  if (verticalAlignment == SWT.BOTTOM) {\n    editorRect.y+=cell.height - editorRect.height;\n  }\n else   if (verticalAlignment == SWT.TOP) {\n  }\n else {\n    editorRect.y+=(cell.height - editorRect.height) / 2;\n  }\n  return editorRect;\n}\n", "docstring": "returns the bounds of the editor .", "partition": "test"}
{"idx": "4360", "code": "public int read(byte[] buffer,int offset,int length) throws IOException {\n  throw new UnsupportedOperationException(String.valueOf(this));\n}\n", "docstring": "reads the next chunk from the stream .", "partition": "test"}
{"idx": "4361", "code": "public Cuboid(World world,int x1,int y1,int z1,int x2,int y2,int z2){\n  this.worldName=world.getName();\n  this.x1=Math.min(x1,x2);\n  this.x2=Math.max(x1,x2);\n  this.y1=Math.min(y1,y2);\n  this.y2=Math.max(y1,y2);\n  this.z1=Math.min(z1,z2);\n  this.z2=Math.max(z1,z2);\n}\n", "docstring": "construct a cuboid in the given world and xyz co - ordinates", "partition": "test"}
{"idx": "4362", "code": "@SuppressWarnings({\"SuspiciousNameCombination\"}) public double logMarginalLikelihoodSmoothed(List<Double> v,double delta,double Pdata){\n  final double logDelta=StrictMath.log(delta);\n  final double logInvDelta=StrictMath.log(1.0 - delta);\n  final int n=v.size();\n  final double logN=StrictMath.log(n);\n  final double offset=logInvDelta - Pdata;\n  double bottom=logN + logDelta - logInvDelta;\n  double top=bottom + Pdata;\n  for (int i=0; i < n; i++) {\n    double weight=-LogTricks.logSum(logDelta,offset + v.get(i));\n    top=LogTricks.logSum(top,weight + v.get(i));\n    bottom=LogTricks.logSum(bottom,weight);\n  }\n  return top - bottom;\n}\n", "docstring": "calculates the log marginal likelihood of a model using newton and raftery \"'\" s smoothed estimator", "partition": "test"}
{"idx": "4363", "code": "public boolean isNewMessage(){\n  if (message == null) {\n    throw new IllegalStateException(\"no message present\");\n  }\n  return message.startsWith(\"new(\") || message.equals(\"new\");\n}\n", "docstring": "returns true if the message starts with & quot ; new ( & quot ; or if it equals & quot ; new & quot ;", "partition": "test"}
{"idx": "4364", "code": "private void installProperties(){\n  System.setProperty(\"http.agent\",UserAgentGenerator.getUserAgent());\n  if (OSUtils.isMacOSX()) {\n    System.setProperty(\"apple.laf.useScreenMenuBar\",\"true\");\n  }\n}\n", "docstring": "installs any system properties .", "partition": "test"}
{"idx": "4365", "code": "private void loadRecipients(int addressType,HashSet<String> recipients,HashMap<Integer,EncodedStringValue[]> addressMap,boolean excludeMyNumber){\n  EncodedStringValue[] array=addressMap.get(addressType);\n  if (array == null) {\n    return;\n  }\n  if (excludeMyNumber && array.length == 1) {\n    return;\n  }\n  String myNumber=excludeMyNumber ? mTelephonyManager.getLine1Number() : null;\n  for (  EncodedStringValue v : array) {\n    if (v != null) {\n      String number=v.getString();\n      if ((myNumber == null || !PhoneNumberUtils.compare(number,myNumber)) && !recipients.contains(number)) {\n        recipients.add(number);\n      }\n    }\n  }\n}\n", "docstring": "for a given address type , extract the recipients from the headers .", "partition": "test"}
{"idx": "4366", "code": "private String scriptFromDisk(String name){\n  name=name.replace(\'\\\\\',\'/\');\n  final char SEP=\';\';\n  String pkgPart=\"\";\n  String pathPart=\"\";\n  String namePart=\"\";\n  int at=name.indexOf(SEP);\n  if (at > -1) {\n    int nextAt=name.indexOf(SEP,at + 1);\n    if (nextAt > -1) {\n      pathPart=name.substring(0,at);\n      pkgPart=name.substring(at + 1,nextAt);\n      namePart=name.substring(nextAt + 1);\n    }\n else {\n      pathPart=name.substring(0,at);\n      namePart=name.substring(at + 1);\n    }\n  }\n else {\n    at=name.lastIndexOf(\'/\');\n    if (at > -1) {\n      int mx=name.lastIndexOf(\"/mx/\");\n      if (mx > -1) {\n        pathPart=name.substring(0,mx);\n        pkgPart=name.substring(mx + 1,at);\n      }\n else {\n        pathPart=name.substring(0,at);\n      }\n      namePart=name.substring(at + 1);\n    }\n else {\n      pathPart=\".\";\n      namePart=name;\n    }\n  }\n  String script=null;\n  try {\n    Charset realEncoding=null;\n    Charset bomEncoding=null;\n    InputStream in=locateScriptFile(pathPart,pkgPart,namePart);\n    if (in != null) {\n      try {\n        BufferedInputStream bis=new BufferedInputStream(in);\n        bomEncoding=getEncodingFromBOM(bis);\n        script=pullInSource(bis,bomEncoding);\n        realEncoding=getEncodingFromXMLDirective(script);\n      }\n  finally {\n        try {\n          in.close();\n        }\n catch (        IOException e) {\n        }\n      }\n    }\n    if (realEncoding != null && !realEncoding.equals(bomEncoding)) {\n      in=locateScriptFile(pathPart,pkgPart,namePart);\n      if (in != null) {\n        try {\n          BufferedInputStream bis=new BufferedInputStream(in);\n          getEncodingFromBOM(bis);\n          script=pullInSource(bis,realEncoding);\n        }\n  finally {\n          try {\n            in.close();\n          }\n catch (          IOException e) {\n          }\n        }\n      }\n    }\n  }\n catch (  FileNotFoundException fnf) {\n    fnf.printStackTrace();\n  }\n  return script;\n}\n", "docstring": "scan the disk looking for the location of where the source resides . may also peel open a swd file looking for the source file .", "partition": "test"}
{"idx": "4367", "code": "@PrePersist public void prePersist(){\n  lockTime=System.currentTimeMillis();\n}\n", "docstring": "used to automatically update the timestamp of locks .", "partition": "test"}
{"idx": "4368", "code": "public LibPadstack add(String p_name,ShapeConvex[] p_shapes,boolean p_attach_allowed,boolean p_placed_absolute){\n  int pad_no=count() + 1;\n  LibPadstack new_padstack=new LibPadstack(p_name,pad_no,p_shapes,p_attach_allowed,p_placed_absolute);\n  padstack_list.add(new_padstack);\n  return new_padstack;\n}\n", "docstring": "appends a new padstack with the input shapes to this padstacks . p_shapes is an array of dimension board layer_count . p_attach_allowed indicates if vias of the own net are allowed to overlap with this padstack if p_placed_absolute is false , the layers of the padstack are mirrored , if it is placed on the back side .", "partition": "test"}
{"idx": "4369", "code": "protected ArgsBase(){\n  _argv=null;\n  _env=null;\n}\n", "docstring": "for the commandmanager init .", "partition": "test"}
{"idx": "4370", "code": "@Override public void startContentModel(String elementName,Augmentations augs) throws XNIException {\n  if (fValidation) {\n    fDTDElementDeclName=elementName;\n    fMixedElementTypes.clear();\n  }\n  if (fDTDGrammar != null)   fDTDGrammar.startContentModel(elementName,augs);\n  if (fDTDContentModelHandler != null) {\n    fDTDContentModelHandler.startContentModel(elementName,augs);\n  }\n}\n", "docstring": "the start of a content model . depending on the type of the content model , specific methods may be called between the call to the startcontentmodel method and the call to the endcontentmodel method .", "partition": "test"}
{"idx": "4371", "code": "public OMRangeRings(LatLonPoint center,double radius,Length units,int nverts){\n  super(center,radius,units,nverts);\n  centerPoint=createCenterPoint();\n  form.setMaximumFractionDigits(2);\n}\n", "docstring": "create an omrangerings with a lat / lon center and a physical distance radius . rendertype is rendertype_latlon .", "partition": "test"}
{"idx": "4372", "code": "public static InputSource createInputSource(String s){\n  try {\n    return new InputSource(new ByteArrayInputStream(s.getBytes(\"UTF-8\")));\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "create an inputsource form a string .", "partition": "test"}
{"idx": "4373", "code": "public static String toDebugString(final long socketIdentifier){\n  final int ipBits=(int)socketIdentifier;\n  final int port=extractPortNumber(socketIdentifier);\n  final int inode=(int)(socketIdentifier >> 48);\n  return Integer.toHexString(ipBits) + \":\" + port+ \"/\"+ inode;\n}\n", "docstring": "generates a vaguely human - readable format for a given socket identifier .", "partition": "test"}
{"idx": "4374", "code": "@Override public void onAlbumUpdate(ProviderIdentifier provider,final Album a) throws RemoteException {\n  if (a == null) {\n    Log.w(TAG,\"Provider returned a null album\");\n    return;\n  }\n  Album cached=mCache.getAlbum(a.getRef());\n  boolean modified=false;\n  if (cached == null) {\n    mCache.putAlbum(provider,a);\n    cached=a;\n    modified=true;\n  }\n else   if (!cached.isLoaded() || !cached.isIdentical(a)) {\n    cached.setName(a.getName());\n    cached.setYear(a.getYear());\n    cached.setIsLoaded(a.isLoaded());\n    cached.setProvider(a.getProvider());\n    if (cached.getSongsCount() != a.getSongsCount()) {\n      Iterator<String> songsIt=a.songs();\n      while (songsIt.hasNext()) {\n        String songRef=songsIt.next();\n        cached.addSong(songRef);\n      }\n    }\n    modified=true;\n  }\n  if (cached.getProvider() == null) {\n    Log.e(TAG,\"Provider for \" + cached.getRef() + \" is null!\");\n  }\n  if (modified) {\n    Iterator<String> songs=a.songs();\n    while (songs.hasNext()) {\n      String songRef=songs.next();\n      Song song=retrieveSong(songRef,a.getProvider());\n      if (song != null && song.isLoaded()) {\n        String artistRef=song.getArtist();\n        if (artistRef != null) {\n          Artist artist=retrieveArtist(artistRef,song.getProvider());\n          if (artist != null) {\n            artist.addAlbum(a.getRef());\n          }\n else {\n            if (DEBUG)             Log.e(TAG,\"Artist is null!\");\n          }\n        }\n      }\n else {\n        if (DEBUG)         Log.e(TAG,\"Song is null!\");\n      }\n    }\n    postAlbumForUpdate(cached);\n  }\n}\n", "docstring": "called by the providers when the details of an album have been updated .", "partition": "test"}
{"idx": "4375", "code": "public static String readFromFile(final File path) throws IOException {\n  FileInputStream fis=null;\n  try {\n    fis=new FileInputStream(path);\n    return readFromFile(fis);\n  }\n  finally {\n    if (fis != null) {\n      fis.close();\n    }\n  }\n}\n", "docstring": "read contents of a file .", "partition": "test"}
{"idx": "4376", "code": "public static int XToTileX(int x,int tileGridXOffset,int tileWidth){\n  x-=tileGridXOffset;\n  if (x < 0) {\n    x+=1 - tileWidth;\n  }\n  return x / tileWidth;\n}\n", "docstring": "converts a pixel \"'\" s x coordinate into a horizontal tile index relative to a given tile grid layout specified by its x offset and tile width .", "partition": "test"}
{"idx": "4377", "code": "public Input(String name,@InputType int type,@Alignment int align,Connection connection){\n  mName=name;\n  mType=type;\n  mAlign=align;\n  mConnection=connection;\n  if (mConnection != null) {\n    mConnection.setInput(this);\n  }\n}\n", "docstring": "creates a new input that can be added to a block .", "partition": "test"}
{"idx": "4378", "code": "public static BshClassManager createClassManager(Interpreter interpreter){\n  BshClassManager manager;\n  if (Capabilities.classExists(\"java.lang.ref.WeakReference\") && Capabilities.classExists(\"java.util.HashMap\") && Capabilities.classExists(\"bsh.classpath.ClassManagerImpl\"))   try {\n    Class clas=Class.forName(\"bsh.classpath.ClassManagerImpl\");\n    manager=(BshClassManager)clas.newInstance();\n  }\n catch (  Exception e) {\n    throw new InterpreterError(\"Error loading classmanager: \" + e);\n  }\n else   manager=new BshClassManager();\n  if (interpreter == null)   interpreter=new Interpreter();\n  manager.declaringInterpreter=interpreter;\n  return manager;\n}\n", "docstring": "create a new instance of the class manager . class manager instnaces are now associated with the interpreter .", "partition": "test"}
{"idx": "4379", "code": "public void requestLastLoginTime(){\n  operations.add(PasswordPolicyStateOperationType.GET_LAST_LOGIN_TIME);\n}\n", "docstring": "returns the last login time .", "partition": "test"}
{"idx": "4380", "code": "public static Stream<String> wordsOf(String text){\n  requireNonNull(text);\n  return WORDS.splitAsStream(text);\n}\n", "docstring": "creates and returns a stream of the words in the given text . words are a group of characters separated by one or more white spaces .", "partition": "test"}
{"idx": "4381", "code": "public Joiner match(String field,Object... value){\n  return match(field,Arrays.asList(value));\n}\n", "docstring": "filter the matching objects for the one ( s ) whoose named field is equal to value . if the field is a collection , matches when any value in the collection matches value .", "partition": "test"}
{"idx": "4382", "code": "private String removeYouTubeMarkup(String plot){\n  if (plot == null)   return null;\n  return plot.replaceAll(\"\\\\[.*\\\\]\",\"\");\n}\n", "docstring": "removes some markup that appears on the plot for youtube videos", "partition": "test"}
{"idx": "4383", "code": "private String createDashArrayString(List<Float> dashesArray){\n  StringBuilder sb=new StringBuilder();\n  if (dashesArray != null) {\n    int index=0;\n    for (    Float value : dashesArray) {\n      String str=Float.toString(value);\n      if (str.endsWith(\".0\")) {\n        sb.append(value.intValue());\n      }\n else {\n        sb.append(value);\n      }\n      if (index < dashesArray.size() - 1) {\n        sb.append(\" \");\n      }\n      index++;\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "creates the dash array string .", "partition": "test"}
{"idx": "4384", "code": "public long position(java.sql.Blob pattern,long start) throws SQLException {\n  return position(pattern.getBytes(0,(int)pattern.length()),start);\n}\n", "docstring": "finds the position of the given pattern in this blob .", "partition": "test"}
{"idx": "4385", "code": "protected synchronized T load() throws IOException {\n  long genLoaded=-1;\n  IOException ioe=null;\n  List<String> genFiles=new ArrayList<String>();\n  String[] files;\n  try {\n    files=dir.listAll();\n  }\n catch (  IOException ioe2) {\n    return null;\n  }\n  T loaded=null;\n  for (  String file : files) {\n    if (file.startsWith(prefix)) {\n      long gen=Long.parseLong(file.substring(prefix.length()));\n      if (genLoaded == -1 || gen > genLoaded) {\n        genFiles.add(file);\n        IndexInput in=dir.openInput(file,IOContext.DEFAULT);\n        try {\n          loaded=loadOne(in);\n        }\n catch (        IOException ioe2) {\n          if (ioe == null) {\n            ioe=ioe2;\n          }\n        }\n finally {\n          in.close();\n        }\n        genLoaded=gen;\n      }\n    }\n  }\n  if (genLoaded == -1) {\n    if (ioe != null) {\n      throw ioe;\n    }\n  }\n else {\n    if (genFiles.size() > 1) {\n      String curFileName=prefix + genLoaded;\n      for (      String file : genFiles) {\n        long gen=Long.parseLong(file.substring(prefix.length()));\n        if (canDelete(gen) && !curFileName.equals(file)) {\n          dir.deleteFile(file);\n        }\n      }\n    }\n    nextWriteGen=1 + genLoaded;\n  }\n  return loaded;\n}\n", "docstring": "loads the most recent generation file .", "partition": "test"}
{"idx": "4386", "code": "public static String readLine(InputStream in,String charset) throws IOException {\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n  while (true) {\n    int b=in.read();\n    if (b == -1) {\n      if (baos.size() == 0) {\n        return null;\n      }\n else {\n        break;\n      }\n    }\n    if (b == '\\n') {\n      break;\n    }\n    if (b != '\\r') {\n      baos.write(b);\n      continue;\n    }\n    int b2=in.read();\n    if (b2 == -1) {\n      baos.write(b);\n      break;\n    }\n    if (b2 == '\\n') {\n      break;\n    }\n    baos.write(b);\n    baos.write(b2);\n  }\n  return baos.toString(charset);\n}\n", "docstring": "read a line from the given stream .", "partition": "test"}
{"idx": "4387", "code": "public boolean checkTableExists(TableDefinition table){\n  String column=null;\n  for (  FieldDefinition field : table.getFields()) {\n    if (column == null) {\n      column=field.getName();\n    }\n else     if (field.isPrimaryKey()) {\n      column=field.getName();\n      break;\n    }\n  }\n  String sql=\"SELECT \" + column + \" FROM \"+ table.getFullName()+ \" WHERE \"+ column+ \" <> \"+ column;\n  DataReadQuery query=new DataReadQuery(sql);\n  query.setMaxRows(1);\n  try {\n    session.executeQuery(query);\n    return true;\n  }\n catch (  Exception notFound) {\n    return false;\n  }\n finally {\n  }\n}\n", "docstring": "check if the table exists by issuing a select .", "partition": "test"}
{"idx": "4388", "code": "private int processColon(int length){\n  if (_hasScheme) {\n    if (!readUserPass(length) && _buffer.length() > 0) {\n      _reader.goBack();\n      _buffer.delete(_buffer.length() - 1,_buffer.length());\n      int backtrackOnFail=_reader.getPosition() - _buffer.length() + length;\n      if (!readDomainName(_buffer.substring(length))) {\n        _reader.seek(backtrackOnFail);\n        readEnd(ReadEndState.InvalidUrl);\n      }\n      length=0;\n    }\n  }\n else   if (readScheme() && _buffer.length() > 0) {\n    _hasScheme=true;\n    length=_buffer.length();\n  }\n else   if (_buffer.length() > 0 && _options.hasFlag(UrlDetectorOptions.ALLOW_SINGLE_LEVEL_DOMAIN) && _reader.canReadChars(1)) {\n    _reader.goBack();\n    _buffer.delete(_buffer.length() - 1,_buffer.length());\n    readDomainName(_buffer.toString());\n  }\n else {\n    readEnd(ReadEndState.InvalidUrl);\n    length=0;\n  }\n  return length;\n}\n", "docstring": "we found a \" : \" and is now trying to read either scheme , username / password", "partition": "test"}
{"idx": "4389", "code": "public static boolean containsSqlScriptDelimiters(String script,String delim){\n  boolean inLiteral=false;\n  char[] content=script.toCharArray();\n  for (int i=0; i < script.length(); i++) {\n    if (content[i] == '\\'') {\n      inLiteral=!inLiteral;\n    }\n    if (!inLiteral && script.startsWith(delim,i)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "does the provided sql script contain the specified delimiter ?", "partition": "test"}
{"idx": "4390", "code": "public void compress(byte[] bytes,int off,int len,OutputStream os){\n  try {\n    os.write(bytes,off,len);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "writes the bytes on the output stream .", "partition": "test"}
{"idx": "4391", "code": "public void assertNotJoined(final UUID serviceId){\n  m_triggers.add(new QuorumEventInvariant(QuorumEventEnum.SERVICE_JOIN,serviceId));\n  if (isMember(m_quorum.getJoined(),serviceId))   broken();\n}\n", "docstring": "establish an invariant that the specified service is a not joined with the met quorum .", "partition": "test"}
{"idx": "4392", "code": "public final void print(String value){\n  try {\n    Element rootElement=workDoc.getDefaultRootElement();\n    int deleteLines=rootElement.getElementCount() - linesMax;\n    for (int index=0; index < deleteLines; index++) {\n      Element elem=rootElement.getElement(0);\n      workDoc.remove(elem.getStartOffset(),elem.getEndOffset());\n    }\n    workDoc.insertString(workDoc.getLength(),value,null);\n    textArea.setCaretPosition(workDoc.getLength());\n  }\n catch (  Exception exc) {\n    exc.printStackTrace();\n  }\n}\n", "docstring": "prints a string without adding a / n at the end .", "partition": "test"}
{"idx": "4393", "code": "private void addConnectionGroups(Collection<ConnectionGroup> connectionGroups){\n  for (  ConnectionGroup connectionGroup : connectionGroups) {\n    APIConnectionGroup parent=retrievedGroups.get(connectionGroup.getParentIdentifier());\n    if (parent != null) {\n      Collection<APIConnectionGroup> children=parent.getChildConnectionGroups();\n      if (children == null) {\n        children=new ArrayList<APIConnectionGroup>();\n        parent.setChildConnectionGroups(children);\n      }\n      APIConnectionGroup apiConnectionGroup=new APIConnectionGroup(connectionGroup);\n      retrievedGroups.put(connectionGroup.getIdentifier(),apiConnectionGroup);\n      children.add(apiConnectionGroup);\n    }\n else     logger.debug(\"Connection group \\\"{}\\\" cannot be added to the tree: parent \\\"{}\\\" does not actually exist.\",connectionGroup.getIdentifier(),connectionGroup.getParentIdentifier());\n  }\n}\n", "docstring": "adds each of the provided connection groups to the current tree as children of their respective parents . the parent connection groups must already be added .", "partition": "test"}
{"idx": "4394", "code": "public void loadMap(InputStream input,String groupID) throws Exception {\n  shapes=parser.parse(input,groupID);\n  boundaries=new ArrayList<Rect2D>(shapes.size());\n  for (  IGeometric2D shape : shapes) {\n    boundaries.add(shape.getBounds());\n  }\n}\n", "docstring": "loads a map input into this cartesian plot .", "partition": "test"}
{"idx": "4395", "code": "public void addDecoration(LineDecoration decoration){\n  if (decoration != null) {\n    decorations.add(decoration);\n  }\n}\n", "docstring": "add another line decoration into the composite line decoration . the new decoration will be appended to the existing decorations and is also the last drawn .", "partition": "test"}
{"idx": "4396", "code": "private String parseLinkTitle(){\n  String title=match(LINK_TITLE);\n  if (title != null) {\n    return Escaping.unescapeString(title.substring(1,title.length() - 1));\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "attempt to parse link title ( sans quotes ) , returning the string or null if no match .", "partition": "test"}
{"idx": "4397", "code": "public void recordSRDFOperation(DbClient dbClient,OperationTypeEnum opType,Operation.Status status,Object... extParam){\n  try {\n    boolean opStatus=(Operation.Status.ready == status) ? true : false;\n    String evType;\n    evType=opType.getEvType(opStatus);\n    String evDesc=opType.getDescription();\n    String opStage=AuditLogManager.AUDITOP_END;\n    _logger.info(\"opType: {} detail: {}\",opType.toString(),evType.toString() + \':\' + evDesc);\n    recordBourneSRDFEvent(dbClient,getId(),evType,status,evDesc);\n    String id=(String)extParam[0];\nswitch (opType) {\ncase CREATE_SRDF_LINK:\n      AuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\n    break;\ncase SUSPEND_SRDF_LINK:\n  AuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase DETACH_SRDF_LINK:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase PAUSE_SRDF_LINK:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase RESUME_SRDF_LINK:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase FAILOVER_SRDF_LINK:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase SWAP_SRDF_VOLUME:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase STOP_SRDF_LINK:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ncase SYNC_SRDF_LINK:\nAuditBlockUtil.auditBlock(dbClient,opType,opStatus,opStage,extParam);\nbreak;\ndefault :\n_logger.error(\"unrecognized SRDF operation type\");\n}\n}\n catch (Exception e) {\n_logger.error(\"Failed to record SRDF operation {}, err: {}\",opType.toString(),e);\n}\n}\n", "docstring": "record block volume related event and audit", "partition": "test"}
{"idx": "4398", "code": "@Override public void put(double val){\n  final double nn=this.n + 1.0;\n  final double delta=val - m1;\n  final double delta_nn=delta / nn;\n  final double delta_nn2=delta_nn * delta_nn;\n  final double inc=delta * delta_nn * this.n;\n  m4+=inc * delta_nn2 * (nn * nn - 3. * nn + 3.) + 6. * delta_nn2 * m2 - 4. * delta_nn * m3;\n  m3+=inc * delta_nn * (nn - 2) - 3. * delta_nn * m2;\n  m2+=inc;\n  m1+=delta_nn;\n  n=nn;\n  min=Math.min(min,val);\n  max=Math.max(max,val);\n}\n", "docstring": "add a single value with weight 1 . 0", "partition": "test"}
{"idx": "4399", "code": "public void close(){\n  this.closed=true;\n}\n", "docstring": "closes the command processor , canceling the current work if not finish", "partition": "test"}
{"idx": "4400", "code": "public int size(){\n  return m_RecentItems.size();\n}\n", "docstring": "returns the number of recent items currently stored .", "partition": "test"}
{"idx": "4401", "code": "public Destructurer(final Tree.Pattern that,final GenerateJsVisitor gen,final Set<Declaration> directAccess,final String expvar,boolean first,final boolean forAssert){\n  this.gen=gen;\n  jsw=gen == null ? null : gen.out;\n  names=gen == null ? null : gen.getNames();\n  this.directAccess=directAccess;\n  this.expvar=expvar;\n  this.first=first;\n  this.forAssert=forAssert;\n  that.visit(this);\n  if (jsw != null && !attribs.isEmpty()) {\n    for (    Value attr : attribs) {\n      jsw.write(\";\",names.self((TypeDeclaration)attr.getContainer()),\".\",names.name(attr),\"=\",names.name(attr));\n    }\n  }\n}\n", "docstring": "generate the code for the specified pattern . if null is passed instead of a generator , no code is output but the patterns are still visited and their declarations gathered .", "partition": "test"}
{"idx": "4402", "code": "@SuppressWarnings(\"unused\") public void handleTblSubConfigButtonDeleteRequest(RequestInvocationEvent event) throws ModelControlException {\n  submitCycle=true;\n  CCActionTable tbl=(CCActionTable)getChild(TBL_SUB_CONFIG);\n  tbl.restoreStateData();\n  CCActionTableModel tblModel=(CCActionTableModel)tbl.getModel();\n  Integer[] selected=tblModel.getSelectedRows();\n  SerializedField szCache=(SerializedField)getChild(SZ_CACHE);\n  List list=szCache.getSerializedObj();\n  Set<String> names=new HashSet<>(selected.length * 2);\n  for (  Integer index : selected) {\n    SMSubConfig sc=(SMSubConfig)list.get(index);\n    names.add(sc.getName());\n  }\n  try {\n    AbstractAuditModel model=(AbstractAuditModel)getModel();\n    model.deleteEventHandles(names);\n    if (selected.length == 1) {\n      setInlineAlertMessage(TYPE_INFO,INFORMATION_MESSAGE,\"event.handler.message.deleted\");\n    }\n else {\n      setInlineAlertMessage(TYPE_INFO,INFORMATION_MESSAGE,\"event.handler.message.deleted.plural\");\n    }\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(TYPE_ERROR,ERROR_MESSAGE,e.getMessage());\n  }\n  submitCycle=false;\n  forwardTo();\n}\n", "docstring": "called on request from the ui to delete an event handler .", "partition": "test"}
{"idx": "4403", "code": "private void init(){\n  setTitle(\"New Hopfield Network\");\n  hopPropertiesPanel=new HopfieldPropertiesPanel(networkPanel);\n  hopPropertiesPanel.fillFieldValues();\n  tabLogic.setLayout(new FlowLayout());\n  tabLogic.add(hopPropertiesPanel);\n  tabLayout.add(layoutPanel);\n  layoutPanel=new MainLayoutPanel(false,this);\n  tabbedPane.addTab(\"Logic\",tabLogic);\n  tabbedPane.addTab(\"Layout\",layoutPanel);\n  setContentPane(tabbedPane);\n  Action helpAction=new ShowHelpAction(hopPropertiesPanel.getHelpPath());\n  addButton(new JButton(helpAction));\n}\n", "docstring": "initializes all components used in dialog .", "partition": "test"}
{"idx": "4404", "code": "private double normVector(double[] z){\n  double sum=0;\n  for (int i=0; i < problem.getNumberOfObjectives(); i++) {\n    sum+=z[i] * z[i];\n  }\n  return Math.sqrt(sum);\n}\n", "docstring": "computes the norm of a vector .", "partition": "test"}
{"idx": "4405", "code": "public int hashCode(){\n  return 127 * factor.hashCode() + lag;\n}\n", "docstring": "probably should recheck this later .", "partition": "test"}
{"idx": "4406", "code": "public void deserializeArchivedVersions() throws RuntimeException {\n  System.out.println(\"Deserializing archived instances in \" + getArchiveDirectory() + \".\");\n  File archive=new File(getArchiveDirectory());\n  if (!archive.exists() || !archive.isDirectory()) {\n    return;\n  }\n  String[] listing=archive.list();\n  for (  String archiveName : listing) {\n    if (!(archiveName.endsWith(\".zip\"))) {\n      continue;\n    }\n    try {\n      File file=new File(getArchiveDirectory(),archiveName);\n      ZipFile zipFile=new ZipFile(file);\n      ZipEntry entry=zipFile.getEntry(\"class_fields.ser\");\n      InputStream inputStream=zipFile.getInputStream(entry);\n      ObjectInputStream objectIn=new ObjectInputStream(inputStream);\n      Map<String,List<String>> classFields=(Map<String,List<String>>)objectIn.readObject();\n      zipFile.close();\n      for (      String className : classFields.keySet()) {\n        List<String> fieldNames=classFields.get(className);\n        Class<?> clazz=Class.forName(className);\n        ObjectStreamClass streamClass=ObjectStreamClass.lookup(clazz);\n        if (streamClass == null) {\n          System.out.println();\n        }\n        for (        String fieldName : fieldNames) {\n          assert streamClass != null;\n          ObjectStreamField field=streamClass.getField(fieldName);\n          if (field == null) {\n            throw new RuntimeException(\"Field \'\" + fieldName + \"\' was dropped from class \'\"+ className+ \"\' as a serializable field! Please \"+ \"put it back!!!\"+ \"\\nIt used to be in \"+ className+ \" in this archive: \"+ archiveName+ \".\");\n          }\n        }\n      }\n    }\n catch (    ClassNotFoundException e) {\n      throw new RuntimeException(\"Could not read class_fields.ser in archive + \" + archiveName + \" .\",e);\n    }\ncatch (    IOException e) {\n      throw new RuntimeException(\"Problem reading archive\" + archiveName + \"; see cause.\",e);\n    }\n    System.out.println(\"...Deserializing instances in \" + archiveName + \"...\");\n    ZipEntry zipEntry=null;\n    try {\n      File file=new File(getArchiveDirectory(),archiveName);\n      FileInputStream in=new FileInputStream(file);\n      ZipInputStream zipinputstream=new ZipInputStream(in);\n      while ((zipEntry=zipinputstream.getNextEntry()) != null) {\n        if (!zipEntry.getName().endsWith(\".ser\")) {\n          continue;\n        }\n        ObjectInputStream objectIn=new ObjectInputStream(zipinputstream);\n        objectIn.readObject();\n        zipinputstream.closeEntry();\n      }\n      zipinputstream.close();\n    }\n catch (    ClassNotFoundException e) {\n      throw new RuntimeException(\"Could not read object zipped file \" + zipEntry.getName() + \" in archive \"+ archiveName+ \". \"+ \"Perhaps the class was renamed, moved to another package, or \"+ \"removed. In any case, please put it back where it was.\",e);\n    }\ncatch (    IOException e) {\n      throw new RuntimeException(\"Problem reading archive\" + archiveName + \"; see cause.\",e);\n    }\n  }\n  System.out.println(\"Finished deserializing archived instances.\");\n}\n", "docstring": "deserializes examplars stored in archives in getarchivedirectory ( ) .", "partition": "test"}
{"idx": "4407", "code": "private void convertMaximalToMinimalEdgeRings(List ringEdges){\n  for (Iterator i=ringEdges.iterator(); i.hasNext(); ) {\n    PolygonizeDirectedEdge de=(PolygonizeDirectedEdge)i.next();\n    long label=de.getLabel();\n    List intNodes=findIntersectionNodes(de,label);\n    if (intNodes == null)     continue;\n    for (Iterator iNode=intNodes.iterator(); iNode.hasNext(); ) {\n      Node node=(Node)iNode.next();\n      computeNextCCWEdges(node,label);\n    }\n  }\n}\n", "docstring": "convert the maximal edge rings found by the initial graph traversal into the minimal edge rings required by jts polygon topology rules .", "partition": "test"}
{"idx": "4408", "code": "public byte[] generateMAC(byte commandClass,byte[] ciphertext,byte sendingNode,byte receivingNode,byte[] iv) throws GeneralSecurityException {\n  traceHex(\"generateMAC ciphertext\",ciphertext);\n  traceHex(\"generateMAC iv\",iv);\n  int bufferSize=ciphertext.length + 4;\n  byte[] buffer=new byte[bufferSize];\n  byte[] tempAuth=new byte[16];\n  buffer[0]=commandClass;\n  buffer[1]=sendingNode;\n  buffer[2]=receivingNode;\n  buffer[3]=(byte)ciphertext.length;\n  System.arraycopy(ciphertext,0,buffer,4,ciphertext.length);\n  traceHex(\"generateMAC NetworkKey\",networkKey.getEncoded());\n  traceHex(\"generateMAC Raw Auth (minus IV)\",buffer);\n  Cipher encryptCipher=Cipher.getInstance(\"AES/ECB/NoPadding\");\n  encryptCipher.init(Cipher.ENCRYPT_MODE,authKey);\n  tempAuth=encryptCipher.doFinal(iv);\n  traceHex(\"generateMAC tmp1\",tempAuth);\n  byte[] encpck=new byte[16];\n  int block=0;\n  for (int i=0; i < bufferSize; i++) {\n    encpck[block]=buffer[i];\n    block++;\n    if (block == 16) {\n      for (int j=0; j < 16; j++) {\n        tempAuth[j]=(byte)(encpck[j] ^ tempAuth[j]);\n        encpck[j]=0;\n      }\n      Arrays.fill(encpck,(byte)0);\n      block=0;\n      encryptCipher.init(Cipher.ENCRYPT_MODE,authKey);\n      tempAuth=encryptCipher.doFinal(tempAuth);\n    }\n  }\n  if (block > 0) {\n    for (int i=0; i < 16; i++) {\n      tempAuth[i]=(byte)(encpck[i] ^ tempAuth[i]);\n    }\n    encryptCipher.init(Cipher.ENCRYPT_MODE,authKey);\n    tempAuth=encryptCipher.doFinal(tempAuth);\n  }\n  traceHex(\"generateMAC Computed Auth\",tempAuth);\n  byte[] mac=new byte[8];\n  System.arraycopy(tempAuth,0,mac,0,8);\n  return mac;\n}\n", "docstring": "generate the mac ( message authentication code ) from a security - encrypted message todo : public for testing - look to remove", "partition": "test"}
{"idx": "4409", "code": "public void removeEventListener(ImageSharingListener listener) throws RcsServiceNotAvailableException, RcsGenericException {\n  if (mApi == null) {\n    throw new RcsServiceNotAvailableException();\n  }\n  try {\n    WeakReference<IImageSharingListener> weakRef=mImageSharingListeners.remove(listener);\n    if (weakRef == null) {\n      return;\n    }\n    IImageSharingListener rcsListener=weakRef.get();\n    if (rcsListener != null) {\n      mApi.removeEventListener2(rcsListener);\n    }\n  }\n catch (  Exception e) {\n    RcsIllegalArgumentException.assertException(e);\n    throw new RcsGenericException(e);\n  }\n}\n", "docstring": "removes a listener on image sharing events", "partition": "test"}
{"idx": "4410", "code": "private void updateWaveFileSize() throws IOException {\n  ByteBuffer buffer=getUnsignedIntegerBuffer(mFileChannel.size() - 8);\n  mFileChannel.write(buffer,4);\n  ByteBuffer buffer2=getUnsignedIntegerBuffer(mFileChannel.size() - 44);\n  mFileChannel.write(buffer2,40);\n}\n", "docstring": "updates the overall and the chunk2 sizes", "partition": "test"}
{"idx": "4411", "code": "public boolean matches(String sa){\n  if (_length != sa.length())   return false;\n  char[] buffer=_buffer;\n  int offset=_offset;\n  for (int i=_length - 1; i >= 0; i--)   if (_buffer[_offset + i] != sa.charAt(i))   return false;\n  return true;\n}\n", "docstring": "returns true if the charsegment matches the string .", "partition": "test"}
{"idx": "4412", "code": "@Override public void mouseReleased(MouseEvent event){\n  if (event.getSource() == getComponentDecreaseSpinnerButton()) {\n    decreaseTimer.stop();\n  }\n else {\n    increaseTimer.stop();\n  }\n}\n", "docstring": "mousereleased , this will be called when the spinner button is released .", "partition": "test"}
{"idx": "4413", "code": "public double computeMaxClassValueUsingPercentFactorPerSeries(DefaultChartData chartData,String[] series,double[] percentFactorPerSeries){\n  double maxValue=0;\n  for (  String className : chartData.getClassNamesIncludingDisabled()) {\n    double total=0;\n    for (int i=0; i < series.length; i++) {\n      String seriesName=series[i];\n      if (transposedHeightsAdditive)       total+=percentFactorPerSeries[i] * chartData.getValueAsDouble(seriesName,className);\n else       total=Math.max(total,percentFactorPerSeries[i] * chartData.getValueAsDouble(seriesName,className));\n    }\n    if (total > maxValue) {\n      maxValue=total;\n    }\n  }\n  return 1.1 * maxValue;\n}\n", "docstring": "gets the max value for a given class in a transposed chart when using percentages", "partition": "test"}
{"idx": "4414", "code": "public int addChannel(Channel channel){\n  int index=-1;\nswitch (channel.getChannelType()) {\ncase STANDARD:\n    mChannels.add(channel);\n  index=mChannels.size() - 1;\nfireTableRowsInserted(index,index);\nbreak;\ncase TRAFFIC:\nmTrafficChannels.add(channel);\nindex=mChannels.size() - 1;\nbreak;\ndefault :\nbreak;\n}\nbroadcast(new ChannelEvent(channel,Event.NOTIFICATION_ADD));\nif (channel.getEnabled()) {\nbroadcast(new ChannelEvent(channel,Event.REQUEST_ENABLE));\n}\nreturn index;\n}\n", "docstring": "adds the channel to the model and broadcasts a channel add event", "partition": "test"}
{"idx": "4415", "code": "public static String join(Object... array){\n  if (array == null) {\n    return null;\n  }\n  if (array.length == 0) {\n    return StringPool.EMPTY;\n  }\n  if (array.length == 1) {\n    return String.valueOf(array[0]);\n  }\n  final StringBuilder sb=new StringBuilder(array.length * 16);\n  for (int i=0; i < array.length; i++) {\n    sb.append(array[i]);\n  }\n  return sb.toString();\n}\n", "docstring": "joins an array of objects into one string without separators .", "partition": "test"}
{"idx": "4416", "code": "public boolean hasTrait(final StoreTrait storeTrait){\n  final Set<StoreTrait> traits=getTraits();\n  return null != traits && traits.contains(storeTrait);\n}\n", "docstring": "returns true if the store can handle the provided trait and false if it cannot .", "partition": "test"}
{"idx": "4417", "code": "public void createSupply(MWMInOutBoundLine boundline,BigDecimal qtySupply){\n  MProduct product=MProduct.get(boundline.getCtx(),boundline.getM_Product_ID());\n  if (product.isBOM()) {\n    createMO(boundline,product,qtySupply);\n  }\n else   if (product.isPurchased()) {\n    createRequisition(boundline,product,qtySupply);\n  }\n}\n", "docstring": "create supply based in out bound line", "partition": "test"}
{"idx": "4418", "code": "@Override public void loadXML(Node stepnode,List<DatabaseMeta> databases,Map<String,Counter> counters) throws KettleXMLException {\n  try {\n    schemaName=XMLHandler.getTagValue(stepnode,\"schemaName\");\n    tabelName=XMLHandler.getTagValue(stepnode,\"TableName\");\n    mdkeySize=XMLHandler.getTagValue(stepnode,\"MDKeySize\");\n    measureCount=XMLHandler.getTagValue(stepnode,\"Measurecount\");\n    heirAndKeySize=XMLHandler.getTagValue(stepnode,\"HeirAndKeySize\");\n    cubeName=XMLHandler.getTagValue(stepnode,\"cubeName\");\n    groupByEnabled=XMLHandler.getTagValue(stepnode,\"isGroupByEnabled\");\n    aggregatorClassString=XMLHandler.getTagValue(stepnode,\"aggregatorClassString\");\n    aggregatorString=XMLHandler.getTagValue(stepnode,\"aggregatorString\");\n    factDimLensString=XMLHandler.getTagValue(stepnode,\"factDimLensString\");\n    levelAnddataTypeString=XMLHandler.getTagValue(stepnode,\"levelAnddataTypeString\");\n    currentRestructNumber=Integer.parseInt(XMLHandler.getTagValue(stepnode,\"currentRestructNumber\"));\n    partitionID=XMLHandler.getTagValue(stepnode,\"partitionID\");\n    segmentId=XMLHandler.getTagValue(stepnode,\"segmentId\");\n    taskNo=XMLHandler.getTagValue(stepnode,\"taskNo\");\n  }\n catch (  Exception e) {\n    throw new KettleXMLException(\"Unable to read step info from XML node\",e);\n  }\n}\n", "docstring": "load the values for this step from an xml node", "partition": "test"}
{"idx": "4419", "code": "public void readData(DataInput din) throws IOException {\n  reference=din.readUnsignedShort();\n}\n", "docstring": "readdata - - read the reference word .", "partition": "test"}
{"idx": "4420", "code": "public float dotProduct(DenseVector df){\n  float res=0.0f;\n  for (int i=0; i < Math.min(size,df.getLength()); i++) {\n    res+=u[i] * df.u[i];\n  }\n  return res;\n}\n", "docstring": "return the dot product to a dense feature vector", "partition": "test"}
{"idx": "4421", "code": "public static double stDev(final List<Double> list){\n  return Math.sqrt(variance(list));\n}\n", "docstring": "gets the standard deviation from a list of numbers .", "partition": "test"}
{"idx": "4422", "code": "public void trimToSize(){\n  if (size < array.length) {\n    int[] olddata=array;\n    array=new int[size];\n    System.arraycopy(olddata,0,array,0,size);\n  }\n}\n", "docstring": "trims the capacity of this instance to be the list \"'\" s current size . an application can use this operation to minimize the storage of some instance .", "partition": "test"}
{"idx": "4423", "code": "public static int compare(Date left,boolean right){\n  return compare(left,right ? 1D : 0D);\n}\n", "docstring": "compares a date with a boolean", "partition": "test"}
{"idx": "4424", "code": "private IBindingSet[] decodeNextChunk() throws IOException {\n  if (nsolutions == solutionSetCount) {\n    if (log.isDebugEnabled())     log.debug(\"Read solutionSet: name=\" + name + \", solutionSetSize=\"+ nsolutions);\n    return null;\n  }\n  in.readInt();\n  final int chunkSize=in.readInt();\n  final int byteLength=in.readInt();\n  final byte[] a=new byte[byteLength];\n  in.readFully(a);\n  final DataInputBuffer buf=new DataInputBuffer(a);\n  final IBindingSet[] t=new IBindingSet[chunkSize];\n  for (int i=0; i < chunkSize; i++) {\n    t[i]=decoder.decodeSolution(buf,true);\n    if (log.isTraceEnabled())     log.trace(\"Read: name=\" + name + \", solution=\"+ t[i]);\n  }\n  nsolutions+=chunkSize;\n  if (log.isTraceEnabled())   log.trace(\"Read chunk: name=\" + name + \", chunkSize=\"+ chunkSize+ \", bytesRead=\"+ (SolutionSetStreamEncoder.CHUNK_HEADER_SIZE + byteLength)+ \", solutionSetSize=\"+ nsolutions);\n  return t;\n}\n", "docstring": "read ahead and decode the next chunk of solutions .", "partition": "test"}
{"idx": "4425", "code": "public UDPClientSocket(Logger logger){\n  this.logger=logger;\n  try {\n    socket=new DatagramSocket();\n    socket.setBroadcast(true);\n    socket.setSendBufferSize(1024 * 1024 * 8);\n    socket.setReceiveBufferSize(1024 * 1024 * 8);\n    socket.setSoTimeout(1);\n  }\n catch (  SocketException e) {\n    logger.severe(\"**** FAILED TO CREATE SOCKET!\");\n    logger.severe(\"java.net.SocketException: \" + e.getMessage());\n    System.exit(1);\n  }\n}\n", "docstring": "create a new udp client socket with the specified logger .", "partition": "test"}
{"idx": "4426", "code": "public void multiplyAllValuesBy(final double multiplyBy,final int RoundType){\n  for (  final T t : keySet()) {\n    double val=mapValues.get(t);\nswitch (RoundType) {\ncase 1:\n      val=Math.floor(val * multiplyBy);\n    break;\ncase 2:\n  val=Math.round(val * multiplyBy);\nbreak;\ncase 3:\nval=Math.ceil(val * multiplyBy);\nbreak;\ndefault :\nval=val * multiplyBy;\nbreak;\n}\nput(t,(int)val);\n}\n}\n", "docstring": "will multiply all values by a given double . can be used to divide all numbers , if given a fractional double ( ie : to divide by 2 , use 0 . 5 as the double )", "partition": "test"}
{"idx": "4427", "code": "public static boolean isLevel(Level level){\n  if (level == null)   return false;\n  return level.intValue() >= s_currentLevel.intValue();\n}\n", "docstring": "is logging level logged", "partition": "test"}
{"idx": "4428", "code": "protected void computeFolderChildren(File folder,boolean isIncluded,String[] pkgName,ArrayList vChildren,char[][] inclusionPatterns,char[][] exclusionPatterns) throws JavaModelException {\n  if (isIncluded) {\n    IPackageFragment pkg=getPackageFragment(pkgName);\n    vChildren.add(pkg);\n  }\n  try {\n    File[] members=folder.listFiles();\n    boolean hasIncluded=isIncluded;\n    int length=members.length;\n    if (length > 0) {\n      JavaProject javaProject=(JavaProject)getJavaProject();\n      String sourceLevel=javaProject.getOption(JavaCore.COMPILER_SOURCE,true);\n      String complianceLevel=javaProject.getOption(JavaCore.COMPILER_COMPLIANCE,true);\n      for (int i=0; i < length; i++) {\n        File member=members[i];\n        String memberName=member.getName();\n        if (member.isDirectory()) {\n          if (Util.isValidFolderNameForPackage(memberName,sourceLevel,complianceLevel)) {\n            String[] newNames=Util.arrayConcat(pkgName,manager.intern(memberName));\n            boolean isMemberIncluded=false;\n            computeFolderChildren(member,isMemberIncluded,newNames,vChildren,inclusionPatterns,exclusionPatterns);\n          }\n        }\n else {\n          if (!hasIncluded && Util.isValidCompilationUnitName(memberName,sourceLevel,complianceLevel)) {\n            hasIncluded=true;\n            IPackageFragment pkg=getPackageFragment(pkgName);\n            vChildren.add(pkg);\n          }\n        }\n      }\n    }\n  }\n catch (  IllegalArgumentException e) {\n    throw new JavaModelException(e,IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST);\n  }\ncatch (  CoreException e) {\n    throw new JavaModelException(e);\n  }\n}\n", "docstring": "starting at this folder , create package fragments and add the fragments that are not exclused to the collection of children .", "partition": "test"}
{"idx": "4429", "code": "public static String quote(File input){\n  return quote(input.getAbsolutePath());\n}\n", "docstring": "quotes the absolute path of the given file iff it contains whitespace .", "partition": "test"}
{"idx": "4430", "code": "private void readFromNet() throws IgniteCheckedException {\n  try {\n    inNetBuf.clear();\n    int read=ch.read(inNetBuf);\n    if (read == -1)     throw new IgniteCheckedException(\"Failed to read remote node response (connection closed).\");\n  }\n catch (  IOException e) {\n    throw new IgniteCheckedException(\"Failed to write byte to socket.\",e);\n  }\n}\n", "docstring": "read data from net buffer .", "partition": "test"}
{"idx": "4431", "code": "synchronized void clear(){\n  maps=new Maps();\n  tombstones.clear();\n  ramBytesUsedCurrent.set(0);\n  if (mgr != null) {\n    mgr.removeListener(this);\n    mgr=null;\n  }\n}\n", "docstring": "called when this index is closed .", "partition": "test"}
{"idx": "4432", "code": "public synchronized void removeConsumer(ImageConsumer ic){\n  ics.removeElement(ic);\n}\n", "docstring": "remove an imageconsumer from the list of consumers interested in data for this image .", "partition": "test"}
{"idx": "4433", "code": "private void updateAperture(int newValue,long now){\n  int previous=targetAperture;\n  targetAperture=newValue;\n  targetAperture=Math.max(minAperture,targetAperture);\n  int maxAperture=Math.min(this.maxAperture,activeSockets.size() + activeFactories.size());\n  targetAperture=Math.min(maxAperture,targetAperture);\n  lastApertureRefresh=now;\n  pendings.reset((minPendings + maxPendings) / 2);\n  if (targetAperture != previous) {\n    logger.debug(\"Current pending={}, new target={}, previous target={}\",pendings.value(),targetAperture,previous);\n  }\n}\n", "docstring": "update the aperture value and ensure its value stays in the right range .", "partition": "test"}
{"idx": "4434", "code": "public I buildInvocation(Object protocolKey,I invocation) throws ConfigException {\n  Objects.requireNonNull(invocation);\n  invocation=buildInvocation(invocation);\n  LruCache<Object,I> invocationCache=_invocationCache;\n  if (invocationCache != null) {\n    I oldInvocation;\n    oldInvocation=invocationCache.get(protocolKey);\n    if (oldInvocation != null && !oldInvocation.isModified()) {\n      return oldInvocation;\n    }\n    if (invocation.getURLLength() < _maxURLLength) {\n      invocationCache.put(protocolKey,invocation);\n    }\n  }\n  return invocation;\n}\n", "docstring": "builds the invocation , saving its value keyed by the protocol key .", "partition": "test"}
{"idx": "4435", "code": "public void testKingCapture() throws ChessParseError {\n  Position pos=TextIO.readFEN(\"8/4k3/8/8/8/8/8/4RK2 b - - 0 1\");\n  pos.setWhiteMove(true);\n  List<String> strMoves=getMoveList(pos,false);\n  assertEquals(1,strMoves.size());\n  assertEquals(\"Re1xe7\",strMoves.get(0));\n  pos.setPiece(Position.getSquare(0,2),Piece.WBISHOP);\n  pos.setPiece(Position.getSquare(4,1),Piece.WPAWN);\n  strMoves=getMoveList(pos,false);\n  assertEquals(1,strMoves.size());\n  assertEquals(\"Ba3xe7\",strMoves.get(0));\n  pos.setPiece(Position.getSquare(1,3),Piece.WPAWN);\n  pos.setPiece(Position.getSquare(5,5),Piece.WPAWN);\n  strMoves=getMoveList(pos,false);\n  assertEquals(1,strMoves.size());\n  assertEquals(\"f6xe7\",strMoves.get(0));\n}\n", "docstring": "test that if king capture is possible , only a king capture move is returned in the move list .", "partition": "test"}
{"idx": "4436", "code": "public static BinaryMessage checkAndCorrect(BinaryMessage message,int startIndex){\n  boolean parityError=message.cardinality() % 2 != 0;\n  int syndrome=getSyndrome(message,startIndex);\n  if (syndrome == 0) {\n    if (parityError) {\n      message.flip(startIndex + 23);\n    }\n    message.setCRC(CRC.PASSED);\n    return message;\n  }\n  int original=message.getInt(0,22);\n  int index=-1;\n  int syndromeWeight=3;\n  int errors=0;\n  while (index < 23) {\n    if (index != -1) {\n      if (index > 0) {\n        message.flip(index - 1);\n      }\n      message.flip(index);\n      syndromeWeight=2;\n    }\n    syndrome=getSyndrome(message,startIndex);\n    if (syndrome > 0) {\n      for (int i=0; i < 23; i++) {\n        errors=Integer.bitCount(syndrome);\n        if (errors <= syndromeWeight) {\n          message.xor(12,11,syndrome);\n          message.rotateRight(i,startIndex,startIndex + 22);\n          if (index >= 0) {\n            errors++;\n          }\n          int corrected=message.getInt(0,22);\n          if (Integer.bitCount(original ^ corrected) > 3) {\n            message.setCRC(CRC.FAILED_CRC);\n            return message;\n          }\n          message.setCRC(CRC.PASSED);\n          return message;\n        }\n else {\n          message.rotateLeft(startIndex,startIndex + 22);\n          syndrome=getSyndrome(message,startIndex);\n        }\n      }\n      index++;\n    }\n  }\n  message.setCRC(CRC.FAILED_CRC);\n  return message;\n}\n", "docstring": "performs error detection and returns a corrected copy of the 24 - bit message that starts at the start index .", "partition": "test"}
{"idx": "4437", "code": "public static List<Object> validateAndEvaluate(String viewName,StatementContext statementContext,List<ExprNode> expressions) throws ViewParameterException {\n  List<Object> results=new ArrayList<Object>();\n  int expressionNumber=0;\n  StreamTypeService streamTypeService=new StreamTypeServiceImpl(statementContext.getEngineURI(),false);\n  for (  ExprNode expr : expressions) {\n    Object result=validateAndEvaluateExpr(viewName,statementContext,expr,streamTypeService,expressionNumber);\n    results.add(result);\n    expressionNumber++;\n  }\n  return results;\n}\n", "docstring": "validate the view parameter expressions and evaluate the expressions returning the result object .", "partition": "test"}
{"idx": "4438", "code": "@NotNull public static String parseRelativeDirectory(@NotNull String s) throws SvnBindException {\n  s=s.trim();\n  int length=s.length();\n  String result;\n  if (isUnescapedQuote(s,length - 1)) {\n    int index=lastUnescapedIndexOf(s,length - 1,\'\"\');\n    assertIndex(s,index,\"Could not find start quote\");\n    result=s.substring(index + 1,length - 1);\n  }\n else {\n    int index=lastUnescapedIndexOf(s,length,\' \');\n    assertIndex(s,index,\"Could not find separating space\");\n    result=s.substring(index + 1);\n  }\n  return unescape(result);\n}\n", "docstring": "parses relative directory from externals definition ( in format starting from svn 1 . 5 ) . restrictions for relative directory : - is at the end of externals definition separated from other parameters by \"'\" \"'\" char - could be quoted with \"'\" \" \"'\" char - certain chars could be escaped with \"'\" \\ \"'\" char", "partition": "test"}
{"idx": "4439", "code": "@Override public String generateURL(CategoryDataset dataset,int series,int category){\n  String url=this.prefix;\n  Comparable seriesKey=dataset.getRowKey(series);\n  Comparable categoryKey=dataset.getColumnKey(category);\n  boolean firstParameter=!url.contains(\"?\");\n  url+=firstParameter ? \"?\" : \"&amp;\";\n  try {\n    url+=this.seriesParameterName + \"=\" + URLEncoder.encode(seriesKey.toString(),\"UTF-8\");\n    url+=\"&amp;\" + this.categoryParameterName + \"=\"+ URLEncoder.encode(categoryKey.toString(),\"UTF-8\");\n  }\n catch (  UnsupportedEncodingException ex) {\n    throw new RuntimeException(ex);\n  }\n  return url;\n}\n", "docstring": "generates a url for a particular item within a series .", "partition": "test"}
{"idx": "4440", "code": "public boolean isIdleExpire(){\n  if (!_lifecycle.isActive())   return true;\n  long now=currentTimeActual();\n  long idleExpire=_threadIdleExpireTime.get();\n  int idleCount=_idleCount.get();\n  if (_idleMin < idleCount) {\n    long nextIdleExpire=now + _idleTimeout;\n    if (_idleMax < idleCount && _idleMin < _idleMax) {\n      _threadIdleExpireTime.compareAndSet(idleExpire,nextIdleExpire);\n      return true;\n    }\n else     if (idleExpire < now && _threadIdleExpireTime.compareAndSet(idleExpire,nextIdleExpire)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if the thread should expire instead of going to the idle state .", "partition": "test"}
{"idx": "4441", "code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  IdentitySubjectModel subjectModel=getSubjectModel();\n  PolicyModel model=(PolicyModel)getModel();\n  super.beginDisplay(event);\n  CCDropDownMenu menu=(CCDropDownMenu)getChild(FILTER_TYPE);\n  Map supportedEntityTypes=model.getSupportedEntityTypes(realmName);\n  OptionList entityTypes=createOptionList(supportedEntityTypes);\n  entityTypes.add(0,\"policy.subject.select.identity.type\",\"\");\n  menu.setOptions(entityTypes);\n  menu.setValue(\"\");\n  CCAddRemove child=(CCAddRemove)getChild(VALUES_MULTIPLE_CHOICE_VALUE);\n  child.restoreStateData();\n  OptionList selected=addRemoveModel.getSelectedOptionList();\n  OptionList possible=helper.createOptionList(model.getUserSSOToken(),model.getUserLocale(),this,getPossibleValues(subjectModel,realmName));\n  child.resetStateData();\n  addRemoveModel.setAvailableOptionList(possible);\n}\n", "docstring": "sets the values to ui model .", "partition": "test"}
{"idx": "4442", "code": "private void decode64(ByteBuffer infile,LongArrayPointer a){\n  byte[] nbitplanes=new byte[N03];\n  byte[] tmagic=new byte[2];\n  infile.get(tmagic);\n  if (tmagic[0] != CODE_MAGIC[0] || tmagic[1] != CODE_MAGIC[1]) {\n    throw new RuntimeException(\"Compression error\");\n  }\n  this.nx=infile.getInt();\n  this.ny=infile.getInt();\n  this.scale=infile.getInt();\n  long sumall=infile.getLong();\n  infile.get(nbitplanes);\n  dodecode64(infile,a,nbitplanes);\n  a.set(0,sumall);\n}\n", "docstring": "char * infile ; input file long * a ; address of output tiledimageoperation [ nx ", "partition": "test"}
{"idx": "4443", "code": "private static void createScript() throws Exception {\n  Class.forName(\"org.h2.Driver\");\n  Connection conn=DriverManager.getConnection(\"jdbc:h2:mem:test\");\n  Statement stat=conn.createStatement();\n  stat.execute(\"CREATE TABLE TEST(NAME VARCHAR)\");\n  stat.execute(\"INSERT INTO TEST VALUES(\'Hello World\')\");\n  stat.execute(\"SCRIPT TO \'script.sql\'\");\n  stat.close();\n  conn.close();\n}\n", "docstring": "create a script from a new database .", "partition": "test"}
{"idx": "4444", "code": "public void addJobGroupToNeverDelete(String group){\n  if (group != null)   jobGroupsToNeverDelete.add(group);\n}\n", "docstring": "add the given group to the list of job groups that will never be deleted by this processor , even if a pre - processing - command to delete the group is encountered .", "partition": "test"}
{"idx": "4445", "code": "private WebDoc createLayout(WebDoc doc,MWorkflow wf,int activeNode,MWFNode[] nodes,ArrayList nodes_ID,int[][] imageMap){\n  body b=doc.getBody();\n  b.addElement(printWorkflow(activeNode,wf,nodes,nodes_ID,imageMap));\n  b.addElement(new hr());\n  b.addElement(printDescription(activeNode,wf,nodes,nodes_ID));\n  b.addElement(new br());\n  b.addElement(printControlPanel(activeNode,wf,nodes,nodes_ID));\n  return doc;\n}\n", "docstring": "print the entire layout .", "partition": "test"}
{"idx": "4446", "code": "@Override public void requestPollRead(){\n  try {\n    requestLoop();\n  }\n catch (  Exception e) {\n    log.log(Level.WARNING,e.toString(),e);\n  }\n}\n", "docstring": "wake a connection from a select / poll keepalive .", "partition": "test"}
{"idx": "4447", "code": "public MultiMatchQueryBuilder field(String field){\n  fields.add(field);\n  return this;\n}\n", "docstring": "adds a field to run the multi match against .", "partition": "test"}
{"idx": "4448", "code": "void encode(OutputStream os,boolean include_h) throws IOException {\n  int q=params.q;\n  os.write(getEncoded(f));\n  if (params.basisType == NTRUSigningKeyGenerationParameters.BASIS_TYPE_STANDARD) {\n    IntegerPolynomial fPrimeInt=fPrime.toIntegerPolynomial();\n    for (int i=0; i < fPrimeInt.coeffs.length; i++) {\n      fPrimeInt.coeffs[i]+=q / 2;\n    }\n    os.write(fPrimeInt.toBinary(q));\n  }\n else {\n    os.write(getEncoded(fPrime));\n  }\n  if (include_h) {\n    os.write(h.toBinary(q));\n  }\n}\n", "docstring": "writes the basis to an output stream", "partition": "test"}
{"idx": "4449", "code": "private void signalNoAcks(){\n  lock.lock();\n  try {\n    allAcksRcvCond.signalAll();\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "signal that currenlty there are no more pending acks .", "partition": "test"}
{"idx": "4450", "code": "private static String arrayToString(int[] array){\n  StringBuilder sb=new StringBuilder();\n  boolean first=true;\n  for (  int i : array) {\n    if (first) {\n      first=false;\n    }\n else {\n      sb.append(\" \");\n    }\n    sb.append(i);\n  }\n  return sb.toString();\n}\n", "docstring": "converts an array into a string", "partition": "test"}
{"idx": "4451", "code": "public static byte[] copy(byte[] source,byte[] target){\n  int len=source.length;\n  if (len > target.length) {\n    target=new byte[len];\n  }\n  System.arraycopy(source,0,target,0,len);\n  return target;\n}\n", "docstring": "copy the contents of the source array to the target array . if the size if the target array is too small , a larger array is created .", "partition": "test"}
{"idx": "4452", "code": "public double greatCircleDistance(Location location){\n  if (location == null) {\n    throw new IllegalArgumentException(Logger.logMessage(Logger.ERROR,\"Location\",\"greatCircleDistance\",\"missingLocation\"));\n  }\n  double lat1Radians=Math.toRadians(this.latitude);\n  double lon1Radians=Math.toRadians(this.longitude);\n  double lat2Radians=Math.toRadians(location.latitude);\n  double lon2Radians=Math.toRadians(location.longitude);\n  if (lat1Radians == lat2Radians && lon1Radians == lon2Radians) {\n    return 0;\n  }\n  double a=Math.sin((lat2Radians - lat1Radians) / 2.0);\n  double b=Math.sin((lon2Radians - lon1Radians) / 2.0);\n  double c=a * a + Math.cos(lat1Radians) * Math.cos(lat2Radians) * b* b;\n  double distanceRadians=2.0 * Math.asin(Math.sqrt(c));\n  return Double.isNaN(distanceRadians) ? 0 : distanceRadians;\n}\n", "docstring": "computes the angular distance of the great circle path between this location and a specified location . in radians , this angle is the arc length of the segment between the two locations . to compute a distance in meters from this value , multiply the return value by the radius of the globe . this function uses a spherical model , not elliptical .", "partition": "test"}
{"idx": "4453", "code": "private List<InputSplit> parseManifest(FileSystem fs,Path manifestPath,JobConf job) throws IOException {\n  List<InputSplit> splits=null;\n  FSDataInputStream fp=fs.open(manifestPath);\n  JsonReader reader=new JsonReader(new InputStreamReader(fp,Charsets.UTF_8));\n  reader.beginObject();\n  while (reader.hasNext()) {\n    String name=reader.nextName();\nswitch (name) {\ncase VERSION_JSON_KEY:\n      job.set(DynamoDBConstants.EXPORT_FORMAT_VERSION,String.valueOf(reader.nextInt()));\n    break;\ncase ENTRIES_JSON_KEY:\n  splits=readEntries(reader,job);\nbreak;\ndefault :\nlog.info(\"Skipping a JSON key in the manifest file: \" + name);\nreader.skipValue();\nbreak;\n}\n}\nreader.endObject();\nif (splits == null) {\nreturn Collections.emptyList();\n}\nreturn splits;\n}\n", "docstring": "an example manifest file looks like { \" name \" : \" dynamodb - export \" , \" version \" : 3 , \" entries \" : [ { \" url \" : \" s3 : / / path / to / object / 92dd1414 - a049 - 4c68 - 88fb - a23acd44907e \" , \" mandatory \" : true } , { \" url \" : \" s3 : / / path / to / object / ba3f3535 - 7aa1 - 4f97 - a530 - e72938bf4b76 \" , \" mandatory \" : true } ", "partition": "test"}
{"idx": "4454", "code": "public void fireOperatorMoved(Operator operator){\n  List<Operator> list=new LinkedList<>();\n  list.add(operator);\n  fireOperatorsMoved(list);\n}\n", "docstring": "fire when an operator has been moved .", "partition": "test"}
{"idx": "4455", "code": "@Override public void modifyVariableId(String oldId,String newId){\n  if (baseVar.equals(oldId)) {\n    baseVar=newId.replace(\"\'\",\"\");\n  }\n}\n", "docstring": "replaces occurrences of the old variable identifier oldid with the new identifier newid .", "partition": "test"}
{"idx": "4456", "code": "public AddUserFields(){\n  m_attributeSpecs=new ArrayList<AttributeSpec>();\n}\n", "docstring": "constructs a new adduserfields", "partition": "test"}
{"idx": "4457", "code": "private Integer parseInt(String s,int flags){\n  if (convertColorNames(flags)) {\n    String c=Descriptor.convertColorName(s);\n    if (c != null) {\n      s=c;\n    }\n  }\n  try {\n    if (hasLeadingZeros(s)) {\n      return null;\n    }\n else {\n      return Integer.decode(s);\n    }\n  }\n catch (  NumberFormatException e) {\n    return null;\n  }\n}\n", "docstring": "we accept 0x and # prefixes .", "partition": "test"}
{"idx": "4458", "code": "protected void stopWorkers(Collection<WorkerThread> workers){\n  if (workers == null) {\n    workers=this.workers;\n  }\n  final Iterator<WorkerThread> iter=workers.iterator();\n  while (iter.hasNext()) {\n    final WorkerThread worker=iter.next();\n    if ((worker.getStatus() & (WorkerThread.sENDED | WorkerThread.sENDING)) == 0) {\n      worker.signalShutdown();\n      runningWorkers--;\n    }\n  }\n}\n", "docstring": "signals the given workers to end . note that this method does not validate that the signal is being acted upon .", "partition": "test"}
{"idx": "4459", "code": "public ArrayList<Mapping> cloneFrame(){\n  if (stack[top] == null)   return null;\n  ArrayList<Mapping> clone=new ArrayList<Mapping>();\n  for (Mapping map=topOfFrame(); map != null; map=next()) {\n    clone.add(map);\n  }\n  return clone;\n}\n", "docstring": "return a copy of the current frame . returns null if none are present .", "partition": "test"}
{"idx": "4460", "code": "private static int computeHashCode(int seed,Object... objects){\n  if (objects == null || objects.length == 0) {\n    return seed * HashCode.PRIME;\n  }\n  int hc=seed;\n  for (  Object object : objects) {\n    hc=HashCode.PRIME * hc;\n    if (object instanceof byte[]) {\n      hc+=Arrays.hashCode((byte[])object);\n    }\n else     if (object instanceof boolean[]) {\n      hc+=Arrays.hashCode((boolean[])object);\n    }\n else     if (object instanceof short[]) {\n      hc+=Arrays.hashCode((short[])object);\n    }\n else     if (object instanceof int[]) {\n      hc+=Arrays.hashCode((int[])object);\n    }\n else     if (object instanceof long[]) {\n      hc+=Arrays.hashCode((long[])object);\n    }\n else     if (object instanceof float[]) {\n      hc+=Arrays.hashCode((float[])object);\n    }\n else     if (object instanceof double[]) {\n      hc+=Arrays.hashCode((double[])object);\n    }\n else     if (object instanceof char[]) {\n      hc+=Arrays.hashCode((char[])object);\n    }\n else     if (object instanceof Object[]) {\n      hc+=Arrays.hashCode((Object[])object);\n    }\n else     if (object != null) {\n      hc+=object.hashCode();\n    }\n  }\n  return hc;\n}\n", "docstring": "compute a combined hash code from the supplied objects using the supplied seed .", "partition": "test"}
{"idx": "4461", "code": "protected float calculateStateTransitionPercentage(String name,boolean flapping){\n  int flapInterval=getFlapInterval(name);\n  LinkedList<Boolean> list=getFlaps(name);\n  float lowWeight=getFlapLowWeight(name);\n  float highWeight=getFlapHighWeight(name);\n  float weightRange=highWeight - lowWeight;\n  float result=0;\n  for (int i=list.size() - 1; i >= 0; i--) {\n    boolean thisFlap=list.get(i);\n    if (flapping != thisFlap) {\n      float weight=lowWeight + (weightRange * i / (flapInterval - 1));\n      result+=weight;\n    }\n  }\n  return result / flapInterval;\n}\n", "docstring": "calculate state transition percentage .", "partition": "test"}
{"idx": "4462", "code": "public static String mangleName(Method method,boolean isFull){\n  StringBuffer sb=new StringBuffer();\n  sb.append(method.getName());\n  Class[] params=method.getParameterTypes();\n  for (int i=0; i < params.length; i++) {\n    sb.append('_');\n    sb.append(mangleClass(params[i],isFull));\n  }\n  return sb.toString();\n}\n", "docstring": "creates a unique mangled method name based on the method name and the method parameters .", "partition": "test"}
{"idx": "4463", "code": "private void saveState(){\n  savedStartOffset=offsetAttribute.startOffset();\n  savedEndOffset=offsetAttribute.endOffset();\n  hasIllegalOffsets=(savedEndOffset - savedStartOffset != termAttribute.length());\n  savedType=typeAttribute.type();\n  if (savedBuffer.length < termAttribute.length()) {\n    savedBuffer=new char[ArrayUtil.oversize(termAttribute.length(),Character.BYTES)];\n  }\n  System.arraycopy(termAttribute.buffer(),0,savedBuffer,0,termAttribute.length());\n  iterator.text=savedBuffer;\n  hasSavedState=true;\n}\n", "docstring": "saves the existing attribute states", "partition": "test"}
{"idx": "4464", "code": "private void printOutDefinedIPs(List<String> definedIPs){\n  List<String> ipList=new ArrayList<>();\n  for (  String ip : definedIPs) {\n    if (ip.indexOf(\':\') != -1) {\n      ipList.add(\"|- IPv6: \" + ip);\n    }\n else {\n      ipList.add(\"|- IPv4: \" + ip);\n    }\n  }\n  Collections.sort(ipList);\n  for (  String ip : ipList) {\n    log.info(ip);\n  }\n}\n", "docstring": "prints out the given list of defined ip addresses . the example is : < p > | - ipv4 : 192 . 168 . 1 . 6 < br > | - ipv4 : 127 . 0 . 0 . 1 < br > | - ipv6 : fe80 : 0 : 0 : 0 : 221 : 5cff : fe1d : ffdf % 3 < br > | - ipv6 : 0 : 0 : 0 : 0 : 0 : 0 : 0 : 1 % 1", "partition": "test"}
{"idx": "4465", "code": "private void disposeCodec(IoSession session){\n  disposeEncoder(session);\n  disposeDecoder(session);\n  disposeDecoderOut(session);\n}\n", "docstring": "dispose the encoder , decoder , and the callback for the decoded messages .", "partition": "test"}
{"idx": "4466", "code": "@Override public Object parseObject(final String source,final ParsePosition pos){\n  return parser.parseObject(source,pos);\n}\n", "docstring": "uses the parser format instance .", "partition": "test"}
{"idx": "4467", "code": "@Override public default Stream<TimeSeriesCollection> stream(){\n  return StreamSupport.stream(spliterator(),false);\n}\n", "docstring": "stream the tsdata contents . the stream iterates collection in chronological order , without duplicate timestamps .", "partition": "test"}
{"idx": "4468", "code": "private ManifestModInfo registerMod(File file,Manifest manifest){\n  ManifestModInfo mod=loadMod(file,manifest);\n  if (mod != null) {\n    if (idMap.containsKey(mod.getModID())) {\n      ModInfo mod2=idMap.get(mod.getModID());\n      duplicates.put(mod.getModID(),mod);\n      duplicates.put(mod.getModID(),mod2);\n      log.error(\"Duplicate mod IDs for files \'%s\' and \'%s\'\",mod.getModFile(),mod2.getModFile());\n    }\n else {\n      modList.add(mod);\n      idMap.put(mod.getModID(),mod);\n    }\n  }\n  return mod;\n}\n", "docstring": "constructs and registers a mod .", "partition": "test"}
{"idx": "4469", "code": "protected Size2D arrangeNN(BlockContainer container,Graphics2D g2){\n  List blocks=container.getBlocks();\n  Block b=(Block)blocks.get(0);\n  Size2D s=b.arrange(g2,RectangleConstraint.NONE);\n  b.setBounds(new Rectangle2D.Double(0.0,0.0,s.width,s.height));\n  return new Size2D(s.width,s.height);\n}\n", "docstring": "arranges the blocks without any constraints . this puts all blocks into a single row .", "partition": "test"}
{"idx": "4470", "code": "public static boolean isContentType(String contentType,Message message){\n  if (contentType == null) {\n    return message.getContentType() == null;\n  }\n else {\n    return contentType.equals(message.getContentType());\n  }\n}\n", "docstring": "check whether the content - type field of the properties section ( if present ) in the given message matches the provided string ( where null matches if there is no content type present .", "partition": "test"}
{"idx": "4471", "code": "private static X509Certificate generateCertificate(String dn,int days,String applicationUri,KeyPair keys,org.opcfoundation.ua.transport.security.KeyPair issuerKeys,String... hostNames) throws GeneralSecurityException, IOException {\n  PrivateKey privkey=keys.getPrivate();\n  PublicKey publicKey=keys.getPublic();\n  return generateCertificate(dn,days,applicationUri,publicKey,privkey,issuerKeys,hostNames);\n}\n", "docstring": "create a x . 509 v3 certificate .", "partition": "test"}
{"idx": "4472", "code": "@SuppressWarnings(\"unused\") public void handleButton1Request(RequestInvocationEvent event) throws ModelControlException {\n  submitCycle=true;\n  AbstractAuditModel model=(AbstractAuditModel)getModel();\n  AMPropertySheet ps=(AMPropertySheet)getChild(PROPERTY_ATTRIBUTE);\n  String subConfigName=(String)getPageSessionAttribute(AUDIT_HANDLER_NAME);\n  try {\n    Map orig=model.getEventHandlerAttributeValues(subConfigName);\n    Map values=ps.getAttributeValues(orig,true,true,model);\n    model.setEventHandlerAttributeValues(subConfigName,values);\n    backToProfileViewBean();\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(TYPE_ERROR,ERROR_MESSAGE,e.getMessage());\n    forwardTo();\n  }\n}\n", "docstring": "handles next button request .", "partition": "test"}
{"idx": "4473", "code": "private String checkAllDependencies(HashMap<String,ModuleDescriptor> modlist){\n  for (  ModuleDescriptor md : modlist.values()) {\n    String res=checkDependencies(md,modlist);\n    if (!res.isEmpty()) {\n      return res;\n    }\n  }\n  return \"\";\n}\n", "docstring": "check that all dependencies are satisfied . usually called with a copy of the modules list , after making some change .", "partition": "test"}
{"idx": "4474", "code": "public void childrenRemoved(BeanContextMembershipEvent bcme){\n  for (Iterator it=bcme.iterator(); it.hasNext(); ) {\n    findAndUndo(it.next());\n  }\n}\n", "docstring": "beancontextmembership interface method . called by beancontext when children are being removed . unhooks itself from the objects that are being removed if they are contained within the frame .", "partition": "test"}
{"idx": "4475", "code": "public static void checkDirectoryIsWriteable(@NotNull File directory) throws IOException {\n  while (!directory.exists() || !directory.isDirectory()) {\n    directory=directory.getParentFile();\n  }\n  if (!directory.canWrite()) {\n    throw new IOException(\"Cannot write to folder: \" + directory.getAbsolutePath());\n  }\n}\n", "docstring": "find the first parent directory that exists and check if this directory is writeable .", "partition": "test"}
{"idx": "4476", "code": "public String toString(){\n  StringBuilder s=new StringBuilder();\n  boolean appended=false;\n  if (this.weeks != 0 || appended) {\n    appended=true;\n    s.append(this.weeks + \" Wochen \");\n  }\n  if (this.days != 0 || appended) {\n    appended=true;\n    s.append(this.days + \" Tage \");\n  }\n  if (this.hours != 0 || appended) {\n    appended=true;\n    s.append(this.hours + \" Stunden \");\n  }\n  if (this.minutes != 0 || appended) {\n    appended=true;\n    s.append(this.minutes + \" Minuten \");\n  }\n  if (this.seconds != 0 || appended) {\n    appended=true;\n    s.append(this.seconds + \" Sekunden \");\n  }\n  if (this.milliseconds != 0 || appended) {\n    appended=true;\n    s.append(this.milliseconds + \" Milisekunden\");\n  }\n  return s.toString();\n}\n", "docstring": "returns the textual description of the time value .", "partition": "test"}
{"idx": "4477", "code": "public static boolean isJavaKeyword(String name){\n  return tokens.contains(name);\n}\n", "docstring": "determines whether the given name is a java keyword", "partition": "test"}
{"idx": "4478", "code": "protected String extractImportUrl(final Matcher matcher){\n  return matcher.group(INDEX_URL);\n}\n", "docstring": "override this method to provide a custom way of extracting the imported resource url .", "partition": "test"}
{"idx": "4479", "code": "@Override public boolean equals(Object that){\n  if (this == that) {\n    return true;\n  }\n  if (that == null) {\n    return false;\n  }\n  if (getClass() != that.getClass()) {\n    return false;\n  }\n  Collator other=(Collator)that;\n  return ((strength == other.strength) && (decmp == other.decmp));\n}\n", "docstring": "compares the equality of two collators .", "partition": "test"}
{"idx": "4480", "code": "Type renameTypeAsType(Type type){\n  if (type == null) {\n    return null;\n  }\n  if (type.getSort() == Type.OBJECT) {\n    String in=type.getInternalName();\n    String newIn=renameInternalType(in);\n    if (newIn != in) {\n      return Type.getType(\"L\" + newIn + \";\");\n    }\n  }\n else   if (type.getSort() == Type.ARRAY) {\n    StringBuilder sb=new StringBuilder();\n    for (int n=type.getDimensions(); n > 0; n--) {\n      sb.append(\'[\');\n    }\n    sb.append(renameType(type.getElementType()));\n    return Type.getType(sb.toString());\n  }\n  return type;\n}\n", "docstring": "renames an object type , e . g . \" lcom . package . myclass ; \" or an array type that has an object element , e . g . \" [ lcom . package . myclass ; \" . this is like renametype ( ) except that it returns a type object . if the type doesn \"'\" t need to be renamed , returns the input type object .", "partition": "test"}
{"idx": "4481", "code": "public static void writeFileList(XMLOutput xmlOutput,String tagName,Iterable<File> listValues) throws IOException {\n  if (listValues != null) {\n    writeFileList(xmlOutput,tagName,listValues.iterator());\n  }\n}\n", "docstring": "write a list of strings to document as elements with given tag name .", "partition": "test"}
{"idx": "4482", "code": "public DPolicyConstraints(JDialog parent){\n  super(parent);\n  setTitle(res.getString(\"DPolicyConstraints.Title\"));\n  initComponents();\n}\n", "docstring": "creates a new dpolicyconstraints dialog .", "partition": "test"}
{"idx": "4483", "code": "@PreAuthorize(SpringEvalExpressions.HAS_AUTH_SYSTEM_ADMIN) @Override public ResponseEntity<Collection<String>> invalidateCaches(){\n  final Collection<String> cacheNames=cacheManager.getCacheNames();\n  LOGGER.info(\"Invalidating caches {}\",cacheNames);\n  cacheNames.forEach(null);\n  return ResponseEntity.ok(cacheNames);\n}\n", "docstring": "invalidates all caches for all tenants .", "partition": "test"}
{"idx": "4484", "code": "public static final void writeByteArrayXml(byte[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"byte-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int N=val.length;\n  out.attribute(null,\"num\",Integer.toString(N));\n  StringBuilder sb=new StringBuilder(val.length * 2);\n  for (int i=0; i < N; i++) {\n    int b=val[i];\n    int h=b >> 4;\n    sb.append(h >= 10 ? (\'a\' + h - 10) : (\'0\' + h));\n    h=b & 0xff;\n    sb.append(h >= 10 ? (\'a\' + h - 10) : (\'0\' + h));\n  }\n  out.text(sb.toString());\n  out.endTag(null,\"byte-array\");\n}\n", "docstring": "flatten a byte [ ", "partition": "test"}
{"idx": "4485", "code": "public void cancelRequestsByTAG(Object TAG,boolean mayInterruptIfRunning){\n  if (TAG == null) {\n    return;\n  }\n  for (  List<RequestHandle> requestList : requestMap.values()) {\n    if (requestList != null) {\n      for (      RequestHandle requestHandle : requestList) {\n        if (TAG.equals(requestHandle.getTag()))         requestHandle.cancel(mayInterruptIfRunning);\n      }\n    }\n  }\n}\n", "docstring": "allows you to cancel all requests currently in queue or running , by set tag , if passed tag is null , will not attempt to cancel any requests , if tag is null on requesthandle , it cannot be canceled by this call", "partition": "test"}
{"idx": "4486", "code": "public static void drawSnapHorizontalMargin(ViewTransform transform,Graphics2D g,int x1,int x2,int y1,String text,boolean textOver){\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=transform.getSwingDimension(4);\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int tw=(int)bounds.getWidth();\n  int offset=6 * CONNECTION_ARROW_SIZE;\n  if (x1 > x2) {\n    int temp=x1;\n    x1=x2;\n    x2=temp;\n  }\n  int w=((x2 - x1) - (tw + 2 * padding)) / 2;\n  if (w <= padding) {\n    g.drawLine(x1,y1,x2,y1);\n    if (textOver) {\n      offset=-1 * offset / 2;\n    }\n    g.drawString(text,x1 + w + padding,y1 + offset);\n  }\n else {\n    g.drawLine(x1,y1,x1 + w,y1);\n    g.drawLine(x2 - w,y1,x2,y1);\n    g.drawString(text,x1 + w + padding,(int)(y1 + (bounds.getHeight() / 2)));\n  }\n  g.drawLine(x1,y1 - CONNECTION_ARROW_SIZE,x1,y1 + CONNECTION_ARROW_SIZE);\n  g.drawLine(x2,y1 - CONNECTION_ARROW_SIZE,x2,y1 + CONNECTION_ARROW_SIZE);\n}\n", "docstring": "draw a snap horizontal margin indicator", "partition": "test"}
{"idx": "4487", "code": "public static GenericRecord subsetRecord(GenericRecord record,Schema subsetSchema){\n  return subsetRecord(record,subsetSchema,null);\n}\n", "docstring": "the subset of the original record that contains the values for the given subset schema .", "partition": "test"}
{"idx": "4488", "code": "static public void queueOperation(Context context,OperationInfo args){\n  args.calculateScheduledTime();\nsynchronized (sWorkQueue) {\n    sWorkQueue.add(args);\n    sWorkQueue.notify();\n  }\n  context.startService(new Intent(context,AsyncQueryServiceHelper.class));\n}\n", "docstring": "queues the operation for execution", "partition": "test"}
{"idx": "4489", "code": "private static Cell[] interpret(String string){\n  Cell[] cells=new Cell[9];\n  for (int i=0; i < string.length(); i++) {\n    int dig=string.charAt(i) - '1';\n    int col=dig % 3;\n    int row=dig / 3;\n    cells[i]=new Cell(col,row);\n  }\n  return cells;\n}\n", "docstring": "interpret string of digits into cells .", "partition": "test"}
{"idx": "4490", "code": "public Shape transform(Shape shape){\n  Rectangle2D bounds=shape.getBounds2D();\n  Point2D center=new Point2D.Double(bounds.getCenterX(),bounds.getCenterY());\n  Point2D newCenter=transform(center);\n  double dx=newCenter.getX() - center.getX();\n  double dy=newCenter.getY() - center.getY();\n  AffineTransform at=AffineTransform.getTranslateInstance(dx,dy);\n  return at.createTransformedShape(shape);\n}\n", "docstring": "return the supplied shape , translated to the coordinates that result from calling transform on its center", "partition": "test"}
{"idx": "4491", "code": "public void list(PrintWriter out,int indent){\n  for (int i=0; i < indent; i++) {\n    out.print(\" \");\n  }\n  out.println(this);\n}\n", "docstring": "prints out a list , starting at the specified indentation , to the specified print writer .", "partition": "test"}
{"idx": "4492", "code": "private void init(){\n  setTitle(\"New Competitive Group\");\n  compPropertiesPanel=CompetitivePropertiesPanel.createCompetitivePropertiesPanel(networkPanel,CompetitivePropsPanelType.CREATE_GROUP);\n  tabLogic.add(compPropertiesPanel);\n  layoutPanel=new MainLayoutPanel(false,this);\n  layoutPanel.setCurrentLayout(CompetitiveGroup.DEFAULT_LAYOUT);\n  tabLayout.add(layoutPanel);\n  tabbedPane.addTab(\"Logic\",tabLogic);\n  tabbedPane.addTab(\"Layout\",layoutPanel);\n  setContentPane(tabbedPane);\n  Action helpAction=new ShowHelpAction(compPropertiesPanel.getHelpPath());\n  addButton(new JButton(helpAction));\n}\n", "docstring": "initializes all components used in dialog .", "partition": "test"}
{"idx": "4493", "code": "public static RevocationStatus check(X509Certificate cert,X509Certificate issuerCert) throws IOException, CertPathValidatorException {\n  CertId certId=null;\n  URI responderURI=null;\n  try {\n    X509CertImpl certImpl=X509CertImpl.toImpl(cert);\n    responderURI=getResponderURI(certImpl);\n    if (responderURI == null) {\n      throw new CertPathValidatorException(\"No OCSP Responder URI in certificate\");\n    }\n    certId=new CertId(issuerCert,certImpl.getSerialNumberObject());\n  }\n catch (  CertificateException|IOException e) {\n    throw new CertPathValidatorException(\"Exception while encoding OCSPRequest\",e);\n  }\n  OCSPResponse ocspResponse=check(Collections.singletonList(certId),responderURI,issuerCert,null,null,Collections.<Extension>emptyList());\n  return (RevocationStatus)ocspResponse.getSingleResponse(certId);\n}\n", "docstring": "obtains the revocation status of a certificate using ocsp using the most common defaults . the ocsp responder uri is retrieved from the certificate \"'\" s aia extension . the ocsp responder certificate is assumed to be the issuer \"'\" s certificate ( or issued by the issuer ca ) .", "partition": "test"}
{"idx": "4494", "code": "public static CompositeType forAlphaComposite(AlphaComposite ac){\nswitch (ac.getRule()) {\ncase AlphaComposite.CLEAR:\n    return Clear;\ncase AlphaComposite.SRC:\n  if (ac.getAlpha() >= 1.0f) {\n    return SrcNoEa;\n  }\n else {\n    return Src;\n  }\ncase AlphaComposite.DST:\nreturn Dst;\ncase AlphaComposite.SRC_OVER:\nif (ac.getAlpha() >= 1.0f) {\nreturn SrcOverNoEa;\n}\n else {\nreturn SrcOver;\n}\ncase AlphaComposite.DST_OVER:\nreturn DstOver;\ncase AlphaComposite.SRC_IN:\nreturn SrcIn;\ncase AlphaComposite.DST_IN:\nreturn DstIn;\ncase AlphaComposite.SRC_OUT:\nreturn SrcOut;\ncase AlphaComposite.DST_OUT:\nreturn DstOut;\ncase AlphaComposite.SRC_ATOP:\nreturn SrcAtop;\ncase AlphaComposite.DST_ATOP:\nreturn DstAtop;\ncase AlphaComposite.XOR:\nreturn AlphaXor;\ndefault :\nthrow new InternalError(\"Unrecognized alpha rule\");\n}\n}\n", "docstring": "return a compositetype object for the specified alphacomposite rule .", "partition": "test"}
{"idx": "4495", "code": "private List findPhonemes(){\n  Set set=new HashSet();\n  for (int i=0; i < stateMachine.length; i++) {\n    if (stateMachine[i] instanceof FinalState) {\n      FinalState fstate=(FinalState)stateMachine[i];\n      if (fstate.phoneList != null) {\n        for (int j=0; j < fstate.phoneList.length; j++) {\n          set.add(fstate.phoneList[j]);\n        }\n      }\n    }\n  }\n  return new ArrayList(set);\n}\n", "docstring": "returns a list of all the phonemes used by the lts rules .", "partition": "test"}
{"idx": "4496", "code": "public static File removeParent(File parent,File file){\n  String absolutePath=file.getAbsolutePath();\n  String parentAbsolutePath=parent.getAbsolutePath();\n  String newPath=absolutePath.replace(parentAbsolutePath + \"/\",\"\");\n  return new File(newPath);\n}\n", "docstring": "convert a file into a relative path from a given parent . this is useful if you want to write out the file name into that parent directory .", "partition": "test"}
{"idx": "4497", "code": "public static boolean almostEqual(double a,double b,double delta){\n  return Math.abs(a - b) <= delta;\n}\n", "docstring": "check whether two floating point values match with a given precision .", "partition": "test"}
{"idx": "4498", "code": "private JsonWriter open(int empty,String openBracket) throws IOException {\n  beforeValue();\n  push(empty);\n  out.write(openBracket);\n  return this;\n}\n", "docstring": "enters a new scope by appending any necessary whitespace and the given bracket .", "partition": "test"}
{"idx": "4499", "code": "private double calculateLog(double value){\n  return Math.log(value) / this.baseLog;\n}\n", "docstring": "calculates the log of a given value .", "partition": "test"}
{"idx": "4500", "code": "@Override public boolean uploadFile(String source,String dest){\n  FileInputStream fis;\n  try {\n    File file=new File(source);\n    fis=new FileInputStream(file);\n    mDBApi.putFileOverwrite(dest,fis,file.length(),null);\n    fis.close();\n    return true;\n  }\n catch (  DropboxUnlinkedException e) {\n    Log.d(String.valueOf(R.string.app_name),\"User has unlinked.\",e);\n    return false;\n  }\ncatch (  DropboxException e) {\n    Log.d(String.valueOf(R.string.app_name),\"Something went wrong while uploading.\",e);\n    return false;\n  }\ncatch (  FileNotFoundException e) {\n    Log.d(String.valueOf(R.string.app_name),\"File not found.\",e);\n    return false;\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n    return false;\n  }\n}\n", "docstring": "uploads a file from source to the dropbox", "partition": "test"}
{"idx": "4501", "code": "private File createZipFileHandle() throws IOException {\n  File zipFile=File.createTempFile(\"test\",\"zip\",tmpOutputFolder.getRoot());\n  assertTrue(zipFile.delete());\n  return zipFile;\n}\n", "docstring": "create a file object to which we can safely zip a file .", "partition": "test"}
{"idx": "4502", "code": "public boolean isEmpty(){\n  return (tag == null || tag.isEmpty()) && images.size() == 0;\n}\n", "docstring": "determines whether the tag has no fields specified . < br > < p > if there are no images we return empty if either there is no vorbistag or if there is a vorbistag but it is empty", "partition": "test"}
{"idx": "4503", "code": "@SuppressWarnings(\"unchecked\") private void restoreBadges(){\n  Bundle restoredBundle=savedInstanceState;\n  if (restoredBundle != null) {\n    if (restoredBundle.containsKey(BADGE_FULL_TEXT_KEY)) {\n      shouldShowBadgeWithNinePlus=restoredBundle.getBoolean(BADGE_FULL_TEXT_KEY);\n    }\n    if (restoredBundle.containsKey(BUDGES_ITEM_BUNDLE_KEY)) {\n      badgeSaveInstanceHashMap=(HashMap<Integer,Object>)savedInstanceState.getSerializable(BUDGES_ITEM_BUNDLE_KEY);\n      if (badgeSaveInstanceHashMap != null) {\n        for (        Integer integer : badgeSaveInstanceHashMap.keySet()) {\n          BadgeHelper.forceShowBadge(badgeList.get(integer),(BadgeItem)badgeSaveInstanceHashMap.get(integer),shouldShowBadgeWithNinePlus);\n        }\n      }\n    }\n  }\n}\n", "docstring": "restore available badges from saveinstance", "partition": "test"}
{"idx": "4504", "code": "public void touch(){\n  touch=System.currentTimeMillis();\n  if (worker != null) {\n    worker.touch();\n  }\n}\n", "docstring": "touch the worker if you have a http connection that needs to wait .", "partition": "test"}
{"idx": "4505", "code": "public CatalogEntry(String name,Vector args) throws CatalogException {\n  Integer iType=(Integer)entryTypes.get(name);\n  if (iType == null) {\n    throw new CatalogException(CatalogException.INVALID_ENTRY_TYPE);\n  }\n  int type=iType.intValue();\n  try {\n    Integer iArgs=(Integer)entryArgs.get(type);\n    if (iArgs.intValue() != args.size()) {\n      throw new CatalogException(CatalogException.INVALID_ENTRY);\n    }\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    throw new CatalogException(CatalogException.INVALID_ENTRY_TYPE);\n  }\n  entryType=type;\n  this.args=args;\n}\n", "docstring": "construct a catalog entry of the specified type .", "partition": "test"}
{"idx": "4506", "code": "public void addMsgWaiting(MwiType type,int count,MwiProfile profile,boolean storeMessage){\n  if (count > 255) {\n    count=255;\n  }\n  messages_.add(new MsgWaiting(type,count,profile,storeMessage));\n}\n", "docstring": "adds a message waiting .", "partition": "test"}
{"idx": "4507", "code": "private void pushStack(int newTop){\n  if (stackSize == stack.length) {\n    int[] newStack=new int[stackSize * 2];\n    int[] newPathIndices=new int[stackSize * 2];\n    String[] newPathNames=new String[stackSize * 2];\n    System.arraycopy(stack,0,newStack,0,stackSize);\n    System.arraycopy(pathIndices,0,newPathIndices,0,stackSize);\n    System.arraycopy(pathNames,0,newPathNames,0,stackSize);\n    stack=newStack;\n    pathIndices=newPathIndices;\n    pathNames=newPathNames;\n  }\n  stack[stackSize++]=newTop;\n}\n", "docstring": "push a new scope on top of the scope stack", "partition": "test"}
{"idx": "4508", "code": "public void addGossipMember(GossipMember member){\n  gossipMembers.add(member);\n}\n", "docstring": "add a gossip member to the list of members to start with .", "partition": "test"}
{"idx": "4509", "code": "public boolean isCaseSensitive(){\n  return m_caseSensitiveBox.isSelected();\n}\n", "docstring": "returns the case sensitive search switch .", "partition": "test"}
{"idx": "4510", "code": "@Override public int hashCode(){\n  int hash=type.hashCode();\n  if (name != null)   hash^=name.hashCode();\n  if (actions != null)   hash^=actions.hashCode();\n  return hash;\n}\n", "docstring": "returns the hash code value for this object .", "partition": "test"}
{"idx": "4511", "code": "public SubConfigModelImpl(HttpServletRequest req,String serviceName,String parentId,Map map) throws AMConsoleException {\n  super(req,map);\n  this.serviceName=serviceName;\n  this.parentId=parentId;\n  subConfigMeta=new SubConfigMeta(serviceName,this);\n  subConfigMeta.setParentId(parentId);\n  displayName=subConfigMeta.getParentDisplayName();\n}\n", "docstring": "creates a simple model using default resource bundle .", "partition": "test"}
{"idx": "4512", "code": "@Override public boolean equals(Object obj){\n  if (!(obj instanceof PolynomialFunction2D)) {\n    return false;\n  }\n  PolynomialFunction2D that=(PolynomialFunction2D)obj;\n  return Arrays.equals(this.coefficients,that.coefficients);\n}\n", "docstring": "tests this function for equality with an arbitrary object .", "partition": "test"}
{"idx": "4513", "code": "public static int convertToColorInt(String a,String r,String g,String b,boolean useAlpha){\n  int alpha=useAlpha ? Integer.parseInt(a,16) : 0xff;\n  int red=Integer.parseInt(r,16);\n  int green=Integer.parseInt(g,16);\n  int blue=Integer.parseInt(b,16);\n  return Color.argb(useAlpha ? alpha : -1,red,green,blue);\n}\n", "docstring": "concerts a string color ( # ff882465 ) to an int color", "partition": "test"}
{"idx": "4514", "code": "@Override public void onAction(){\n  onAction(ActionType.PICK);\n}\n", "docstring": "perform the default action .", "partition": "test"}
{"idx": "4515", "code": "public AbstractBinaryTraversal(IBinaryTreeNode<T> node){\n  if (node == null) {\n    throw new NullPointerException(\"AbstractBinaryTraversal received null starting point\");\n  }\n  stack.add(new Moment(node,initialPhase()));\n  advance();\n}\n", "docstring": "start the traversal at the given node .", "partition": "test"}
{"idx": "4516", "code": "@Override public void endElement(String uri,String localName,String qName) throws SAXException {\n  if (qName.equals(TAG_ROOT)) {\n  }\n else   if (qName.equals(TAG_GROUP) || qName.equals(TAG_PROPERTY)) {\n    SettingsItem item=itemStack.remove(itemStack.size() - 1);\n    settingsItems.put(item.getKey(),item);\n  }\n else {\n    throw new SAXException(\"Unknown tag or usage: \" + localName);\n  }\n}\n", "docstring": "xml parser : closing xml tag .", "partition": "test"}
{"idx": "4517", "code": "public void cancelAll(){\n  endpoint.cancelAll();\n}\n", "docstring": "cancel all observer relations that this server has established with this \"'\" realtion \"'\" s endpoint .", "partition": "test"}
{"idx": "4518", "code": "@Override public double value(int attIndex){\n  int index=locateIndex(attIndex);\n  if ((index >= 0) && (m_Indices[index] == attIndex)) {\n    return m_AttValues[index];\n  }\n else {\n    return 0.0;\n  }\n}\n", "docstring": "returns an instance \"'\" s attribute value in internal format .", "partition": "test"}
{"idx": "4519", "code": "public void initialize(Context context,TimePickerDialog timePickerDialog,int initialHoursOfDay,int initialMinutes,boolean is24HourMode){\n  if (mTimeInitialized) {\n    Log.e(TAG,\"Time has already been initialized.\");\n    return;\n  }\n  mTimePickerDialog=timePickerDialog;\n  mIs24HourMode=is24HourMode;\n  mHideAmPm=mAccessibilityManager.isTouchExplorationEnabled() || mIs24HourMode;\n  mCircleView.initialize(context,mHideAmPm);\n  mCircleView.invalidate();\n  if (!mHideAmPm) {\n    mAmPmCirclesView.initialize(context,initialHoursOfDay < 12 ? AM : PM);\n    mAmPmCirclesView.invalidate();\n  }\n  Resources res=context.getResources();\n  int[] hours={12,1,2,3,4,5,6,7,8,9,10,11};\n  int[] hours_24={0,13,14,15,16,17,18,19,20,21,22,23};\n  int[] minutes={0,5,10,15,20,25,30,35,40,45,50,55};\n  String[] hoursTexts=new String[12];\n  String[] innerHoursTexts=new String[12];\n  String[] minutesTexts=new String[12];\n  for (int i=0; i < 12; i++) {\n    hoursTexts[i]=is24HourMode ? String.format(\"%02d\",hours_24[i]) : String.format(\"%d\",hours[i]);\n    innerHoursTexts[i]=String.format(\"%d\",hours[i]);\n    minutesTexts[i]=String.format(\"%02d\",minutes[i]);\n  }\n  mHourRadialTextsView.initialize(res,hoursTexts,(is24HourMode ? innerHoursTexts : null),mHideAmPm,true);\n  mHourRadialTextsView.setSelection(is24HourMode ? initialHoursOfDay : hours[initialHoursOfDay % 12]);\n  mHourRadialTextsView.invalidate();\n  mMinuteRadialTextsView.initialize(res,minutesTexts,null,mHideAmPm,false);\n  mMinuteRadialTextsView.setSelection(initialMinutes);\n  mMinuteRadialTextsView.invalidate();\n  setValueForItem(HOUR_INDEX,initialHoursOfDay);\n  setValueForItem(MINUTE_INDEX,initialMinutes);\n  int hourDegrees=(initialHoursOfDay % 12) * HOUR_VALUE_TO_DEGREES_STEP_SIZE;\n  mHourRadialSelectorView.initialize(context,mHideAmPm,is24HourMode,true,hourDegrees,isHourInnerCircle(initialHoursOfDay));\n  int minuteDegrees=initialMinutes * MINUTE_VALUE_TO_DEGREES_STEP_SIZE;\n  mMinuteRadialSelectorView.initialize(context,mHideAmPm,false,false,minuteDegrees,false);\n  mTimeInitialized=true;\n}\n", "docstring": "initialize the layout with starting values .", "partition": "test"}
{"idx": "4520", "code": "protected void decodeBitmapData(final GifFrame frame,byte[] dstPixels){\n  if (frame != null) {\n    rawData.position(frame.bufferFrameStart);\n  }\n  final int nullCode=-1;\n  final int npix=(frame == null) ? width * height : frame.iw * frame.ih;\n  int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;\n  if (dstPixels == null || dstPixels.length < npix) {\n    dstPixels=new byte[npix];\n  }\n  if (prefix == null) {\n    prefix=new short[MAX_STACK_SIZE];\n  }\n  if (suffix == null) {\n    suffix=new byte[MAX_STACK_SIZE];\n  }\n  if (pixelStack == null) {\n    pixelStack=new byte[MAX_STACK_SIZE + 1];\n  }\n  data_size=read();\n  clear=1 << data_size;\n  end_of_information=clear + 1;\n  available=clear + 2;\n  old_code=nullCode;\n  code_size=data_size + 1;\n  code_mask=(1 << code_size) - 1;\n  for (code=0; code < clear; code++) {\n    prefix[code]=0;\n    suffix[code]=(byte)code;\n  }\n  datum=bits=count=first=top=pi=bi=0;\n  for (i=0; i < npix; ) {\n    if (top == 0) {\n      if (bits < code_size) {\n        if (count == 0) {\n          count=readBlock();\n          if (count <= 0) {\n            break;\n          }\n          bi=0;\n        }\n        datum+=((block[bi]) & 0xff) << bits;\n        bits+=8;\n        bi++;\n        count--;\n        continue;\n      }\n      code=datum & code_mask;\n      datum>>=code_size;\n      bits-=code_size;\n      if ((code > available) || (code == end_of_information)) {\n        break;\n      }\n      if (code == clear) {\n        code_size=data_size + 1;\n        code_mask=(1 << code_size) - 1;\n        available=clear + 2;\n        old_code=nullCode;\n        continue;\n      }\n      if (old_code == nullCode) {\n        pixelStack[top++]=suffix[code];\n        old_code=code;\n        first=code;\n        continue;\n      }\n      in_code=code;\n      if (code == available) {\n        pixelStack[top++]=(byte)first;\n        code=old_code;\n      }\n      while (code > clear) {\n        pixelStack[top++]=suffix[code];\n        code=prefix[code];\n      }\n      first=(suffix[code]) & 0xff;\n      if (available >= MAX_STACK_SIZE) {\n        break;\n      }\n      pixelStack[top++]=(byte)first;\n      prefix[available]=(short)old_code;\n      suffix[available]=(byte)first;\n      available++;\n      if (((available & code_mask) == 0) && (available < MAX_STACK_SIZE)) {\n        code_size++;\n        code_mask+=available;\n      }\n      old_code=in_code;\n    }\n    top--;\n    dstPixels[pi++]=pixelStack[top];\n    i++;\n  }\n  for (i=pi; i < npix; i++) {\n    dstPixels[i]=0;\n  }\n}\n", "docstring": "decodes lzw image data into pixel array . adapted from john cristy \"'\" s bitmapmagick .", "partition": "test"}
{"idx": "4521", "code": "public synchronized String findValue(String k){\n  if (k == null) {\n    for (int i=nkeys; --i >= 0; )     if (keys[i] == null)     return values[i];\n  }\n else   for (int i=nkeys; --i >= 0; ) {\n    if (k.equalsIgnoreCase(keys[i]))     return values[i];\n  }\n  return null;\n}\n", "docstring": "find the value that corresponds to this key . it finds only the first occurrence of the key .", "partition": "test"}
{"idx": "4522", "code": "public boolean delete() throws IOException {\n  if (closed.compareAndSet(false,true)) {\n    close(false);\n    boolean success=allocatedNodesList.delete();\n    success&=nioFile.delete();\n    return success;\n  }\n  return false;\n}\n", "docstring": "closes the btree and then deletes its data files .", "partition": "test"}
{"idx": "4523", "code": "public static boolean hasNoPrefix(final AnnotatedTypeMirror annoType){\n  if (annoType == null) {\n    return true;\n  }\n  for (  AnnotationMirror mirror : annoType.getAnnotations()) {\n    if (!hasNoPrefix(mirror)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "checks to see if an annotated type has no prefix", "partition": "test"}
{"idx": "4524", "code": "public static void tryFormatSatisfiability(String format) throws IllegalFormatException {\n  @SuppressWarnings(\"unused\") String unused=String.format(format,(Object[])null);\n}\n", "docstring": "throws an exception if the format is not syntactically valid .", "partition": "test"}
{"idx": "4525", "code": "public static IgniteLogger logger(GridKernalContext ctx,AtomicReference<IgniteLogger> logRef,Class<?> cls){\n  IgniteLogger log=logRef.get();\n  if (log == null) {\n    logRef.compareAndSet(null,ctx.log(cls));\n    log=logRef.get();\n  }\n  return log;\n}\n", "docstring": "initializes logger into / from log reference passed in .", "partition": "test"}
{"idx": "4526", "code": "public static List<ConstraintViolation> check(Resource resource,ProgressMonitor monitor){\n  return check(resource,SPIN.constraint,null,monitor);\n}\n", "docstring": "checks all spin : constraints for a given resource .", "partition": "test"}
{"idx": "4527", "code": "public static boolean isValidImdbId(String imdbId){\n  if (StringUtils.isEmpty(imdbId)) {\n    return false;\n  }\n  return imdbId.matches(\"tt\\\\d{7}\");\n}\n", "docstring": "checks if is valid imdb id .", "partition": "test"}
{"idx": "4528", "code": "protected void showRecordedVideo(){\n  String absPath=mCurrentVideoFile.getAbsolutePath();\n  Intent intent=new Intent(this,PlayerActivity.class);\n  intent.putExtra(PlayerActivity.EXTRA_VIDEO_PATH,absPath);\n  startActivity(intent);\n  mCurrentVideoFile=null;\n}\n", "docstring": "move to the activity where we show the recorded video", "partition": "test"}
{"idx": "4529", "code": "private void write(Coordinate[] coords,int level,StringBuffer buf){\n  startLine(\"<coordinates>\",level,buf);\n  boolean isNewLine=false;\n  for (int i=0; i < coords.length; i++) {\n    if (i > 0) {\n      buf.append(TUPLE_SEPARATOR);\n    }\n    if (isNewLine) {\n      startLine(\"  \",level,buf);\n      isNewLine=false;\n    }\n    write(coords[i],buf);\n    if ((i + 1) % maxCoordinatesPerLine == 0 && i < coords.length - 1) {\n      buf.append(\"\\n\");\n      isNewLine=true;\n    }\n  }\n  buf.append(\"</coordinates>\\n\");\n}\n", "docstring": "takes a list of coordinates and converts it to kml . < br > 2d and 3d aware . terminates the coordinate output with a newline .", "partition": "test"}
{"idx": "4530", "code": "protected static boolean isIntendedException(Exception e,Class<?> clazz){\n  final String message=e.getMessage();\n  return (!TextUtils.isEmpty(message) && message.startsWith(clazz.getName()));\n}\n", "docstring": "checks if the exception is one of the intended server side exception that has been thrown over the aidl layer .", "partition": "test"}
{"idx": "4531", "code": "public static void swapPivot(DenseDoubleMatrix2D source,long diag,DenseDoubleMatrix2D s,DenseDoubleMatrix2D t){\n  long swapRow=diag;\n  long swapCol=diag;\n  double maxValue=Math.abs(source.getDouble(diag,diag));\n  long rows=source.getRowCount();\n  long cols=source.getColumnCount();\n  double abs=0;\n  for (long row=diag; row < rows; row++) {\n    for (long col=diag; col < cols; col++) {\n      abs=Math.abs(source.getDouble(row,col));\n      if (abs > maxValue) {\n        maxValue=abs;\n        swapRow=row;\n        swapCol=col;\n      }\n    }\n  }\n  if (swapRow != diag) {\n    swapRows(source,swapRow,diag);\n    swapRows(t,swapRow,diag);\n  }\n  if (swapCol != diag) {\n    swapCols(source,swapCol,diag);\n    swapCols(s,swapCol,diag);\n  }\n}\n", "docstring": "swap the matrices so that the largest value is on the pivot", "partition": "test"}
{"idx": "4532", "code": "public boolean canPopupOverlapTaskBar(){\n  boolean result=true;\n  try {\n    SecurityManager sm=System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPermission(SecurityConstants.AWT.SET_WINDOW_ALWAYS_ON_TOP_PERMISSION);\n    }\n  }\n catch (  SecurityException se) {\n    result=false;\n  }\n  return result;\n}\n", "docstring": "returns whether popup is allowed to be shown above the task bar . this is a default implementation of this method , which checks corresponding security permission .", "partition": "test"}
{"idx": "4533", "code": "public Job createJobForCreateCluster(String activitiXmlClasspathResourceName,List<Parameter> parameters) throws Exception {\n  return createJobForCreateCluster(activitiXmlClasspathResourceName,parameters,null);\n}\n", "docstring": "creates a job based on the specified activiti xml classpath resource location and defines a emr cluster definition .", "partition": "test"}
{"idx": "4534", "code": "public static List<String> findMainClasses(File rootDir) throws IOException {\n  List<String> ret=new ArrayList<>();\n  if (!rootDir.exists()) {\n    return ret;\n  }\n  if (!rootDir.isDirectory()) {\n    throw new IllegalArgumentException(String.format(\"Path %s is not a directory\",rootDir.getPath()));\n  }\n  findClasses(ret,rootDir,rootDir.getAbsolutePath() + \"/\");\n  return ret;\n}\n", "docstring": "find all classes below a certain directory which contain main ( ) classes", "partition": "test"}
{"idx": "4535", "code": "private static String validateXML(String string) throws IOException {\n  for (int i=0; i < string.length(); i++) {\n    char ch=string.charAt(i);\n    if (!(ch == 9 || ch == 10 || ch == 13 || ch >= 32))     throw new IOException(\"Character reference \\\"&#\" + Integer.toString(ch) + \"\\\" is an invalid XML character.\");\n  }\n  return string;\n}\n", "docstring": "validates whether the given string only contains valid xml characters .", "partition": "test"}
{"idx": "4536", "code": "public void readValues(){\n  readValues(false);\n}\n", "docstring": "read values from settings", "partition": "test"}
{"idx": "4537", "code": "protected static boolean isAccessCompatibleWithInstantRun(int access){\n  return ((access & Opcodes.ACC_ABSTRACT) == 0) && ((access & Opcodes.ACC_BRIDGE) == 0);\n}\n", "docstring": "defines when a method access flags are compatible with instantrun technology . < p > - if the method is a bridge method , we do not enable it for instantreload . it is most likely only calling a twin method ( same name , same parameters ) . - if the method is abstract , we don \"'\" t add a redirection .", "partition": "test"}
{"idx": "4538", "code": "public ThreadedListenerManager(ExecutorService pool){\n  managerNumber=MANAGER_COUNT.getAndIncrement();\n  this.pool=pool;\n}\n", "docstring": "configures with specified thread pool", "partition": "test"}
{"idx": "4539", "code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n  in.defaultReadObject();\n  if (choiceLimits.length != choiceFormats.length) {\n    throw new InvalidObjectException(\"limits and format arrays of different length.\");\n  }\n}\n", "docstring": "after reading an object from the input stream , do a simple verification to maintain class invariants .", "partition": "test"}
{"idx": "4540", "code": "private void computeOffsetSegment(LineSegment seg,int side,double distance,LineSegment offset){\n  int sideSign=side == Position.LEFT ? 1 : -1;\n  double dx=seg.p1.x - seg.p0.x;\n  double dy=seg.p1.y - seg.p0.y;\n  double len=Math.sqrt(dx * dx + dy * dy);\n  double ux=sideSign * distance * dx / len;\n  double uy=sideSign * distance * dy / len;\n  offset.p0.x=seg.p0.x - uy;\n  offset.p0.y=seg.p0.y + ux;\n  offset.p1.x=seg.p1.x - uy;\n  offset.p1.y=seg.p1.y + ux;\n}\n", "docstring": "compute an offset segment for an input segment on a given side and at a given distance . the offset points are computed in full double precision , for accuracy .", "partition": "test"}
{"idx": "4541", "code": "@SuppressWarnings(\"unchecked\") public synchronized E elementAt(int location){\n  if (location < elementCount) {\n    return (E)elementData[location];\n  }\n  throw arrayIndexOutOfBoundsException(location,elementCount);\n}\n", "docstring": "returns the element at the specified location in this vector .", "partition": "test"}
{"idx": "4542", "code": "private List<QoSRule> createQoSRules(JsonObject qosSettings){\n  List<QoSRule> rules=new ArrayList<>();\n  if (qosSettings.containsKey(JSON_FIELD_RULES)) {\n    JsonObject jsonRules=qosSettings.getJsonObject(JSON_FIELD_RULES);\n    for (    String urlPatternRegExp : jsonRules.fieldNames()) {\n      log.debug(\"Creating a new QoS rule object for URL pattern: \" + urlPatternRegExp);\n      JsonObject jsonRule=jsonRules.getJsonObject(urlPatternRegExp);\n      Pattern urlPattern=Pattern.compile(urlPatternRegExp);\n      QoSRule rule=new QoSRule(urlPattern);\n      boolean addRule=false;\n      if (jsonRule.containsKey(\"reject\")) {\n        addRule=true;\n        rule.setReject(jsonRule.getDouble(\"reject\"));\n      }\n      if (jsonRule.containsKey(\"warn\")) {\n        addRule=true;\n        rule.setWarn(jsonRule.getDouble(\"warn\"));\n      }\n      if (addRule) {\n        rules.add(rule);\n      }\n else {\n        log.warn(\"No or unknown QoS action defined for rule {}. This rule will not be loaded!\",urlPatternRegExp);\n      }\n    }\n  }\n  return rules;\n}\n", "docstring": "creates the qos rule objects from the given jsonobject and returns them in a list .", "partition": "test"}
{"idx": "4543", "code": "private static final byte[] toOctets(int identifier,String text){\n  byte[] s=text.getBytes(StandardCharsets.UTF_8);\n  byte[] base=OctetUtils.toOctets(AttributeType.VENDOR_SPECIFIC,identifier);\n  int maxTextSpace=Attribute.MAX_ATTRIBUTE_LENGTH - base.length;\n  byte[] octets;\n  if (s.length > maxTextSpace) {\n    octets=new byte[Attribute.MAX_ATTRIBUTE_LENGTH];\n    System.arraycopy(s,0,octets,base.length,Attribute.MAX_ATTRIBUTE_LENGTH - base.length);\n  }\n else {\n    octets=new byte[base.length + s.length];\n    System.arraycopy(s,0,octets,base.length,s.length);\n  }\n  System.arraycopy(base,0,octets,0,base.length);\n  octets[1]=(byte)octets.length;\n  return octets;\n}\n", "docstring": "custom implementation of tooctets to ensure a string value too long will be truncated properly in view of the space needed by the type , length , and identifier .", "partition": "test"}
{"idx": "4544", "code": "private Double formatDoubleValue(Double value,int places){\n  BigDecimal bd=new BigDecimal(value);\n  bd=bd.setScale(places,RoundingMode.HALF_UP);\n  return bd.doubleValue();\n}\n", "docstring": "this function returns decimals value for a double", "partition": "test"}
{"idx": "4545", "code": "@Override public void flush() throws IOException {\n  out.flush();\n}\n", "docstring": "flush all buffered data to the underlying output stream .", "partition": "test"}
{"idx": "4546", "code": "protected int moveOrCopyFiles(boolean move,String what,File[] destFiles,File[] sourceFiles){\n  int opCode=(move) ? OP_MOVE : OP_COPY;\n  mModifiedSrcFiles=(move) ? new ArrayList<String>() : null;\n  mModifiedDestFiles=new ArrayList<String>();\n  openLogfile();\n  onPreProcess(what,null,null,opCode);\n  int itemCount=0;\n  int pos=0;\n  int fileCount=destFiles.length;\n  while (pos < fileCount) {\n    File sourceFile=sourceFiles[pos];\n    File destFile=destFiles[pos];\n    File destRenamed=renameDuplicate(destFile);\n    if (osFileMoveOrCopy(move,destRenamed,sourceFile))     itemCount++;\n    log(((move) ? \"MOVE /y \" : \"COPY /y \"),getFilenameForLog(sourceFile),\" \",getFilenameForLog(destRenamed));\n    File sourceSidecar=getSidecar(sourceFile);\n    if (osFileExists(sourceSidecar)) {\n      File destSidecar=getSidecar(destRenamed);\n      if (osFileMoveOrCopy(move,destSidecar,sourceSidecar))       itemCount++;\n      log(((move) ? \"MOVE /y \" : \"COPY /y \"),getFilenameForLog(sourceSidecar),\" \",getFilenameForLog(destSidecar));\n    }\n    pos++;\n  }\n  int modifyCount=mModifiedDestFiles.size();\n  String[] modifiedSourceFiles=((mModifiedSrcFiles != null) && (mModifiedSrcFiles.size() > 0)) ? mModifiedSrcFiles.toArray(new String[modifyCount]) : null;\n  onPostProcess(what,modifiedSourceFiles,(modifyCount > 0) ? mModifiedDestFiles.toArray(new String[modifyCount]) : null,itemCount,sourceFiles.length,opCode);\n  closeLogFile();\n  return itemCount;\n}\n", "docstring": "does the copying . also used by unittesting", "partition": "test"}
{"idx": "4547", "code": "static boolean isCOctetStringValid(String value,int maxLength){\n  if (value == null)   return true;\n  if (value.length() >= maxLength)   return false;\n  return true;\n}\n", "docstring": "validate the c - octet string .", "partition": "test"}
{"idx": "4548", "code": "public Rectangle2D createProperBounds(double x1,double y1,double x2,double y2){\n  double x=Math.min(x1,x2);\n  double y=Math.min(y1,y2);\n  double w=Math.abs(x1 - x2);\n  double h=Math.abs(y1 - y2);\n  return new Rectangle2D.Double(x,y,w,h);\n}\n", "docstring": "create a bounding rectangle given the four coordinates , where the upper left corner of the rectangle is the minimum x , y values and the width and height are the difference between xs and ys .", "partition": "test"}
{"idx": "4549", "code": "public void addClearGraphDataButton(){\n  JButton clearButton=new JButton(\"Clear\");\n  clearButton.setAction(RasterPlotActions.getClearGraphAction(this));\n  buttonPanel.add(clearButton);\n}\n", "docstring": "add button for clearing graph data .", "partition": "test"}
{"idx": "4550", "code": "public static float normalizedLevenshteinDistance(String s,String t){\n  float d=levenshteinDistance(s,t);\n  int max=Math.max(s.length(),t.length());\n  return d / (float)max;\n}\n", "docstring": "from https : / / en . wikipedia . org / wiki / levenshtein_distance \" it is always at least the difference of the sizes of the two strings . \" \" it is at most the length of the longer string . \"", "partition": "test"}
{"idx": "4551", "code": "private void createFile(int number,String extention){\n  for (int i=0; i < number; i++) {\n    try {\n      BufferedWriter output=new BufferedWriter(new FileWriter(new File(textInputFolder + \"/File\" + String.valueOf(i)+ extention)));\n      try {\n        output.write(\"File number \");\n        output.write(String.valueOf(i));\n      }\n  finally {\n        output.close();\n      }\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "this private method just creates a number of files with a specific extension .", "partition": "test"}
{"idx": "4552", "code": "public boolean isAnimal(){\n  return typeString.contains(SUFFIX_ANIMAL);\n}\n", "docstring": "determine if the expression is an animal .", "partition": "test"}
{"idx": "4553", "code": "public void addNotification(PingNotification notification){\n  notifications.add(notification);\n}\n", "docstring": "adds a ping notification to the current list .", "partition": "test"}
{"idx": "4554", "code": "public List<Datastore> createNfsDatastore(ClusterComputeResource cluster,FileShareRestRep fileSystem,FileSystemExportParam export,URI datacenterId,String datastoreName){\n  addNfsDatastoreTag(fileSystem,export,datacenterId,datastoreName);\n  List<Datastore> datastores=Lists.newArrayList();\n  String fileServer=StringUtils.substringBefore(export.getMountPoint(),\":\");\n  String mountPath=StringUtils.substringAfter(export.getMountPoint(),\":\");\n  for (  HostSystem host : cluster.getHosts()) {\n    datastores.add(execute(new CreateNfsDatastore(host,fileServer,mountPath,datastoreName)));\n    addAffectedResource(fileSystem);\n    ExecutionUtils.clearRollback();\n  }\n  return datastores;\n}\n", "docstring": "creates an nfs datastore for the hosts in the cluster", "partition": "test"}
{"idx": "4555", "code": "private void checkSize(final int i){\n  if (i >= max_size) {\n    final int old_size=max_size;\n    max_size+=increment_size;\n    if (max_size <= i) {\n      max_size=i + increment_size + 2;\n    }\n    final String[] temp=items;\n    items=new String[max_size];\n    System.arraycopy(temp,0,items,0,old_size);\n    increment_size=incrementSize(increment_size);\n  }\n}\n", "docstring": "check the size of the array and increase if needed", "partition": "test"}
{"idx": "4556", "code": "public Album(Context context,Uri mediaUri){\n  super();\n  media.add(0,new Media(context,mediaUri));\n  setCurrentPhotoIndex(0);\n}\n", "docstring": "used for open an image from an unknown content storage", "partition": "test"}
{"idx": "4557", "code": "protected void initializeTaskDone(Set<TaskImageContainer> tasks,Optional<Runnable> runnableWhenDone){\n  Set<CaptureSession> sessionSet=new HashSet<>();\n  Map<CaptureSession,Integer> sessionTaskCount=new HashMap<>();\n  for (  TaskImageContainer task : tasks) {\n    sessionSet.add(task.mSession);\n    Integer currentCount=sessionTaskCount.get(task.mSession);\n    if (currentCount == null) {\n      sessionTaskCount.put(task.mSession,1);\n    }\n else {\n      sessionTaskCount.put(task.mSession,currentCount + 1);\n    }\n  }\nsynchronized (mShadowTaskMap) {\n    for (    CaptureSession captureSession : sessionSet) {\n      BlockSignalProtocol protocol=new BlockSignalProtocol();\n      protocol.setCount(sessionTaskCount.get(captureSession));\n      final ImageShadowTask shadowTask;\n      shadowTask=new ImageShadowTask(protocol,captureSession,runnableWhenDone);\n      mShadowTaskMap.put(captureSession,shadowTask);\n      mProcessingTaskConsumer.enqueueTask(shadowTask);\n    }\n  }\n}\n", "docstring": "for a given set of starting tasks , initialize the associated sessions with a proper blocking semaphore and value of number of tasks to be run . for each semaphore , a imageshadowtask will be instantiated and enqueued onto the selected processingserivcemanager .", "partition": "test"}
{"idx": "4558", "code": "public static String unquote(String name){\n  return isQuoted(name) ? name.substring(1,name.length() - 1) : name;\n}\n", "docstring": "return the unquoted version of name ( stripping the start and end \"'\" ` \"'\" characters if present ) .", "partition": "test"}
{"idx": "4559", "code": "public boolean hasLeader(String playerName){\n  return (leader != null) && leader.equals(playerName);\n}\n", "docstring": "is the specified player the leader of this group ?", "partition": "test"}
{"idx": "4560", "code": "private static <T>T reportJoin(Object r){\n  if (r instanceof AltResult) {\n    Throwable x;\n    if ((x=((AltResult)r).ex) == null)     return null;\n    if (x instanceof CancellationException)     throw (CancellationException)x;\n    if (x instanceof CompletionException)     throw (CompletionException)x;\n    throw new CompletionException(x);\n  }\n  @SuppressWarnings(\"unchecked\") T t=(T)r;\n  return t;\n}\n", "docstring": "decodes outcome to return result or throw unchecked exception .", "partition": "test"}
{"idx": "4561", "code": "public int write(final Protein protein) throws IOException {\n  checkEntryHierarchy();\n  if (entryHierarchy != null) {\n    for (    ProteinXref xref : protein.getCrossReferences()) {\n      final SimpleProtein simpleProtein=SimpleProtein.valueOf(protein,xref,entryHierarchy);\n      if (simpleProtein != null) {\n        final SimpleHash model=buildModelMap(simpleProtein,entryHierarchy);\n        Writer writer=null;\n        try {\n          final Template temp=freeMarkerConfig.getTemplate(freeMarkerTemplate);\n          checkTempDirectory(tempDirectory);\n          if (!tempDirectory.endsWith(File.separator)) {\n            tempDirectory=tempDirectory + File.separator;\n          }\n          UrlFriendlyIdGenerator gen=UrlFriendlyIdGenerator.getInstance();\n          String urlFriendlyId=gen.generate(xref.getIdentifier());\n          final Path newResultFile=Paths.get(tempDirectory + urlFriendlyId + \".svg\");\n          resultFiles.add(newResultFile);\n          writer=Files.newBufferedWriter(newResultFile,characterSet);\n          temp.process(model,writer);\n          writer.flush();\n        }\n catch (        TemplateException e) {\n          e.printStackTrace();\n        }\ncatch (        IOException e) {\n          e.printStackTrace();\n        }\n finally {\n          if (writer != null) {\n            writer.close();\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n", "docstring": "writes out protein view to an zipped and compressed html file .", "partition": "test"}
{"idx": "4562", "code": "public void testCasts(){\n  String sql_begin=\"SELECT \";\n  String[][] sql_tests=new String[][]{{\"cast(\'N\' as char)\",\"cast(\'N\' as char)\"},{\"cast(\'this is a string\' as nvarchar2(40))\",\"cast(\'this is a string\' as VARCHAR)\"},{\"cast(\'this is a string as a \'\'string\'\'\' as nvarchar2(40))\",\"cast(\'this is a string as a \'\'string\'\'\' as VARCHAR)\"},{\"cast(tbl.IsView as char)\",\"cast(tbl.IsView as char)\"},{\"cast(trunc(tbl.Updated,\'MONTH\') as date)\",\"cast(trunc(tbl.Updated,\'MONTH\') as TIMESTAMP)\"},{\"cast(NULL as nvarchar2(255))\",\"cast(NULL as VARCHAR)\"},{\"cast(NULL as number(10))\",\"cast(NULL as NUMERIC)\"}};\n  String sql_end=\" FROM AD_Table tbl\";\n  StringBuffer sql=new StringBuffer(sql_begin);\n  StringBuffer sqle=new StringBuffer(sql_begin);\n  for (int i=0; i < sql_tests.length; i++) {\n    if (i > 0) {\n      sql.append(\",\");\n      sqle.append(\",\");\n    }\n    sql.append(sql_tests[i][0]);\n    sqle.append(sql_tests[i][1]);\n  }\n  sql.append(sql_end);\n  sqle.append(sql_end);\n  String[] r=convert.convert(sql.toString());\n  assertEquals(sqle.toString(),r[0]);\n}\n", "docstring": "test bf [ 1824256 ", "partition": "test"}
{"idx": "4563", "code": "private boolean saveMacro(){\n  if (firstTime) {\n    try {\n      Thread.sleep(firstTimeSleep);\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n  firstTime=false;\n  byte[] macroAccy=new byte[macroSize];\n  int index=0;\n  int accyNum=0;\n  accyNum=getAccyRow(macroAccy,index,textAccy1,accyTextField1,cmdButton1);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy2,accyTextField2,cmdButton2);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy3,accyTextField3,cmdButton3);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy4,accyTextField4,cmdButton4);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy5,accyTextField5,cmdButton5);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy6,accyTextField6,cmdButton6);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy7,accyTextField7,cmdButton7);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  if (!isUsb) {\n    accyNum=getAccyRow(macroAccy,index,textAccy8,accyTextField8,cmdButton8);\n    if (accyNum < 0) {\n      return false;\n    }\n    if (accyNum > 0) {\n      index+=2;\n    }\n    accyNum=getAccyRow(macroAccy,index,textAccy9,accyTextField9,cmdButton9);\n    if (accyNum < 0) {\n      return false;\n    }\n    if (accyNum > 0) {\n      index+=2;\n    }\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy10,accyTextField10,cmdButton10);\n  if (accyNum < 0) {\n    JOptionPane.showMessageDialog(this,rb.getString(\"EnterMacroNumberLine10\"),rb.getString(\"NceMacro\"),JOptionPane.ERROR_MESSAGE);\n    return false;\n  }\n  processMemory(false,true,macroNum,macroAccy);\n  return true;\n}\n", "docstring": "writes all bytes to nce cs memory as long as there are no user input errors", "partition": "test"}
{"idx": "4564", "code": "public void writeIntoSPTKLF0File(String sptkFileName) throws IOException {\n  LEDataOutputStream lf0Data=new LEDataOutputStream(new BufferedOutputStream(new FileOutputStream(sptkFileName)));\n  for (int i=0; i < this.contour.length; i++) {\n    double f0Val=contour[i];\n    if (contour[i] == 0.0f) {\n      lf0Data.writeFloat(NEGATIVE_MAXIMUM);\n    }\n else {\n      lf0Data.writeFloat((float)Math.log(contour[i]));\n    }\n  }\n  lf0Data.flush();\n  lf0Data.close();\n}\n", "docstring": "write contour into a lf0 file in sptk format", "partition": "test"}
{"idx": "4565", "code": "public static Element find(Node parent,String name){\n  NodeList list=parent.getChildNodes();\n  for (int i=0; i < list.getLength(); i++) {\n    Node n=list.item(i);\n    if (n instanceof Element) {\n      Element e=(Element)n;\n      if (name.equals(e.getAttribute(\"id\"))) {\n        return e;\n      }\n    }\n    Element r=find(n,name);\n    if (r != null) {\n      return r;\n    }\n  }\n  return null;\n}\n", "docstring": "find an element by its \" id \" attribute ; null if no element is found .", "partition": "test"}
{"idx": "4566", "code": "public static RE mkStar(RE x){\n  if (x.equals(epsilon) || x.equals(empty)) {\n    return epsilon;\n  }\n  RE res=new RE(ReOp.STAR);\n  res.unaryArg=x;\n  return res;\n}\n", "docstring": "construct a regular expression matching the kleene closure of the language matched by the argument regular expression .", "partition": "test"}
{"idx": "4567", "code": "public void remove(final Object element){\n  Set oldSelection=new HashSet(selection);\n  boolean rv=selection.remove(element);\n  if (rv) {\n    fireSelectionChanged(oldSelection,selection);\n  }\n  oldSelection=null;\n}\n", "docstring": "remove the specified element from the selection .", "partition": "test"}
{"idx": "4568", "code": "@Override public void mouseClicked(MouseEvent evt){\n  delegate.mouseMoved(evt);\n}\n", "docstring": "pass mouseevent straight through to delegate", "partition": "test"}
{"idx": "4569", "code": "public void printf(Locale locale,String format,Object... args){\n  out.printf(locale,format,args);\n  out.flush();\n}\n", "docstring": "prints a formatted string to this output stream , using the specified locale , format string , and arguments , and then flushes this output stream .", "partition": "test"}
{"idx": "4570", "code": "public void testSortsAttributesBeforeElements() throws Exception {\n  XppDom dom1=XppFactory.buildDom(\"<dom x=\'a\'><a/></dom>\");\n  XppDom dom2=XppFactory.buildDom(\"<dom x=\'b\'><b/></dom>\");\n  assertEquals(-1,comparator.compare(dom1,dom2));\n  assertEquals(\"/dom[@x]\",xpath.get());\n  assertEquals(1,comparator.compare(dom2,dom1));\n  assertEquals(\"/dom[@x]\",xpath.get());\n}\n", "docstring": "tests comparison sorts attributes before elements .", "partition": "test"}
{"idx": "4571", "code": "public void addSuffix(DalvInsn insn){\n  suffix.add(insn);\n}\n", "docstring": "adds an instruction to the output suffix .", "partition": "test"}
{"idx": "4572", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(1);\n  newVector.addElement(new Option(\"\\tThe filename where output will be stored. Use - for stdout.\\n\" + \"\\t(default temp file)\",\"O\",1,\"-O <file name>\"));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options . .", "partition": "test"}
{"idx": "4573", "code": "private void closeSelector(){\n  if (selector.isOpen()) {\n    if (log.isDebugEnabled())     log.debug(\"Closing all listening sockets.\");\n    for (    SelectionKey key : selector.keys())     U.close(key.channel(),log);\n    if (log.isDebugEnabled())     log.debug(\"Closing NIO selector.\");\n    U.close(selector,log);\n  }\n}\n", "docstring": "close selector if needed .", "partition": "test"}
{"idx": "4574", "code": "public static Number sub(Number a,Number b){\n  if (isFloatingPoint(a) || isFloatingPoint(b)) {\n    return a.doubleValue() - b.doubleValue();\n  }\n else {\n    return a.longValue() - b.longValue();\n  }\n}\n", "docstring": "returns the value of subtracting the first from the second number .", "partition": "test"}
{"idx": "4575", "code": "public Builder requiredAttributes(final String... nameOrOIDs){\n  return requiredAttributes(Arrays.asList(nameOrOIDs));\n}\n", "docstring": "adds the provided required attributes .", "partition": "test"}
{"idx": "4576", "code": "private void showHistoryDialog(){\n  JBList commandsList=new JBList(HistoryUtils.getCommandsFromHistory());\n  commandsList.setCellRenderer(new HistoryListCellRenderer());\n  commandsList.setEmptyText(\"No data to display\");\n  commandsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  String[] buttons={\"OK\",\"Cancel\"};\n  int result=JOptionPane.showOptionDialog(toolWindowContent,commandsList,\"Command history\",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,buttons,buttons[0]);\n  if (result == 0) {\n    updateUiFromCommand((Command)commandsList.getSelectedValue());\n  }\n}\n", "docstring": "shows up history dialog", "partition": "test"}
{"idx": "4577", "code": "protected static byte[] read(InputStream is) throws IOException {\n  final boolean close=true;\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n  try {\n    int i;\n    while ((i=is.read()) != -1) {\n      baos.write(i);\n    }\n  }\n  finally {\n    try {\n      if (close) {\n        is.close();\n      }\n      baos.close();\n    }\n catch (    Exception ex) {\n      log.warn(\"Could not close input/output stream: \" + ex,ex);\n    }\n  }\n  return baos.toByteArray();\n}\n", "docstring": "read a stream into a byte [ ", "partition": "test"}
{"idx": "4578", "code": "public static <T>Streamable<T> fromPublisher(final Publisher<? extends T> publisher){\n  Objects.requireNonNull(publisher);\n  final SeqSubscriber<T> sub=SeqSubscriber.subscriber();\n  publisher.subscribe(sub);\n  return fromStream(sub.stream());\n}\n", "docstring": "construct a lazyfuturestream from an publisher", "partition": "test"}
{"idx": "4579", "code": "public ProtobufConnection(Listener<MessageType> handler,MessageType prototype,int maxMessageSize,int timeoutMillis){\n  this.handler=handler;\n  this.prototype=prototype;\n  this.maxMessageSize=Math.min(maxMessageSize,Integer.MAX_VALUE - 4);\n  setTimeoutEnabled(false);\n  setSocketTimeout(timeoutMillis);\n}\n", "docstring": "creates a new protobuf handler .", "partition": "test"}
{"idx": "4580", "code": "public Notification find(Integer notificationID){\n  Notification notification=new Notification(context,notificationID,null);\n  if (notification.getAttributes() == null)   notification.loadAttributesFromPreferences();\n  return notification;\n}\n", "docstring": "get a notification by its id .", "partition": "test"}
{"idx": "4581", "code": "public GreenGradient(int maxCount){\n  this.maxCount=maxCount;\n  factor=maxCount / Math.log(maxCount);\n}\n", "docstring": "setup the green gradient", "partition": "test"}
{"idx": "4582", "code": "public static void writeHistogram(TDoubleDoubleHashMap distr,String filename) throws FileNotFoundException, IOException {\n  BufferedWriter aWriter=IOUtils.getBufferedWriter(filename);\n  aWriter.write(\"bin\\tcount\");\n  aWriter.newLine();\n  double[] keys=distr.keys();\n  Arrays.sort(keys);\n  for (  double key : keys) {\n    aWriter.write(String.valueOf(key));\n    aWriter.write(\"\\t\");\n    aWriter.write(String.valueOf(distr.get(key)));\n    aWriter.newLine();\n  }\n  aWriter.close();\n}\n", "docstring": "writes a histogram as a tab - separated file with two columns : the first column indicates the bin key ( e . g . upper bin border ) , the second column displays the count / share values .", "partition": "test"}
{"idx": "4583", "code": "public static <T>CompletionStage<T> dereference(CompletionStage<? extends CompletionStage<T>> stage){\n  return stage.thenCompose(Identity.INSTANCE);\n}\n", "docstring": "this takes a stage of a stage of a value and returns a plain stage of a value .", "partition": "test"}
{"idx": "4584", "code": "public static Number plus(Character left,Number right){\n  return NumberNumberPlus.plus(Integer.valueOf(left),right);\n}\n", "docstring": "add a character and a number . the ordinal value of the character is used in the addition ( the ordinal value is the unicode value which for simple character sets is the ascii value ) . this operation will always create a new object for the result , while the operands remain unchanged .", "partition": "test"}
{"idx": "4585", "code": "public static String clipStringIfNecessary(JComponent c,FontMetrics fm,String string,int availTextWidth){\n  if ((string == null) || (string.equals(\"\"))) {\n    return \"\";\n  }\n  int textWidth=SwingUtilities2.stringWidth(c,fm,string);\n  if (textWidth > availTextWidth) {\n    return SwingUtilities2.clipString(c,fm,string,availTextWidth);\n  }\n  return string;\n}\n", "docstring": "clips the passed in string to the space provided .", "partition": "test"}
{"idx": "4586", "code": "public boolean removeElement(Object obj){\nsynchronized (actions) {\n    if (allowToChange) {\n      boolean result=actions.remove(obj);\n      if (actions.isEmpty()) {\n        if (headTask != null) {\n          cancel();\n        }\n      }\n      return result;\n    }\n  }\n  return false;\n}\n", "docstring": "removes an element from this instantrunnable .", "partition": "test"}
{"idx": "4587", "code": "public void addSlide(@NonNull Fragment fragment){\n  fragments.add(fragment);\n  addBackgroundColor(Color.TRANSPARENT);\n  pagerAdapter.notifyDataSetChanged();\n}\n", "docstring": "add a slide to the intro", "partition": "test"}
{"idx": "4588", "code": "private static FloatBuffer createVertexArray(float[] coords){\n  ByteBuffer bb=ByteBuffer.allocateDirect(coords.length * 4);\n  bb.order(ByteOrder.nativeOrder());\n  FloatBuffer fb=bb.asFloatBuffer();\n  fb.put(coords);\n  fb.position(0);\n  return fb;\n}\n", "docstring": "allocates a direct float buffer , and populates it with the vertex data .", "partition": "test"}
{"idx": "4589", "code": "protected void publish() throws MqttException, IOException {\n  sampleClientPub=new SampleAsyncWait(url,clientIdPub,cleanSession,quietMode,userName,password);\n  if (sampleClientPub != null) {\n    String topic=\"Sample/Java/v3\";\n    int qos=2;\n    String message=\"Message from async calback MQTTv3 Java client sample\";\n    try {\n      sampleClientPub.publish(topic,qos,message.getBytes());\n    }\n catch (    Throwable e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "publish / send a message to an mqtt server", "partition": "test"}
{"idx": "4590", "code": "private Object[] invWmSubBand(Image img,double[] wm,int n,double threshold){\n  int m=0;\n  double z=0.0;\n  double v=0.0;\n  for (int i=0; i < img.getWidth() * img.getHeight(); i++) {\n    if (img.getData()[i] > threshold) {\n      z+=(img.getData()[i] * wm[i % n]);\n      v+=Math.abs(img.getData()[i]);\n      m++;\n    }\n  }\n  return new Object[]{m,z,v};\n}\n", "docstring": "extracts the watermark data from subband", "partition": "test"}
{"idx": "4591", "code": "private static TungstenProperties loadSecurityPropertiesFromFile(String propertiesFileLocation) throws ConfigurationException {\n  TungstenProperties securityProps=null;\n  FileInputStream securityConfigurationFileInputStream=null;\n  if (propertiesFileLocation == null && ClusterConfiguration.getClusterHome() == null) {\n    throw new ConfigurationException(\"No cluster.home found from which to configure cluster resources.\");\n  }\n  File securityPropertiesFile;\n  if (propertiesFileLocation == null) {\n    File clusterConfDirectory=ClusterConfiguration.getDir(ClusterConfiguration.getGlobalConfigDirName(ClusterConfiguration.getClusterHome()));\n    securityPropertiesFile=new File(clusterConfDirectory.getPath(),SecurityConf.SECURITY_PROPERTIES_FILE_NAME);\n  }\n else {\n    securityPropertiesFile=new File(propertiesFileLocation);\n  }\n  try {\n    securityProps=new TungstenProperties();\n    securityConfigurationFileInputStream=new FileInputStream(securityPropertiesFile);\n    securityProps.load(securityConfigurationFileInputStream,true);\n    closeSecurityConfigurationFileInputStream(securityConfigurationFileInputStream);\n  }\n catch (  FileNotFoundException e) {\n    String msg=MessageFormat.format(\"Cannot find configuration file: {0}\",securityPropertiesFile.getPath());\n    logger.debug(msg,e);\n    throw new ConfigurationException(msg);\n  }\ncatch (  IOException e) {\n    String msg=MessageFormat.format(\"Cannot load configuration file: {0}.\\n Reason: {1}\",securityPropertiesFile.getPath(),e.getMessage());\n    logger.debug(msg,e);\n    throw new ConfigurationException(msg);\n  }\n finally {\n    closeSecurityConfigurationFileInputStream(securityConfigurationFileInputStream);\n  }\n  if (logger.isDebugEnabled()) {\n    logger.debug(MessageFormat.format(\": {0}\",securityPropertiesFile.getPath()));\n  }\n  securityProps.put(SecurityConf.SECURITY_PROPERTIES_PARENT_FILE_LOCATION,securityPropertiesFile.getAbsolutePath());\n  return securityProps;\n}\n", "docstring": "loads security related properties from a file . file location = { clusterhome } / conf / security . properties", "partition": "test"}
{"idx": "4592", "code": "private synchronized void clearScanFiles(){\n  if ((allFiles != null) && (allFiles.size() > 0)) {\n    Iterator it=allFiles.iterator();\n    File file=null;\n    while (it.hasNext()) {\n      file=(File)it.next();\n      file.delete();\n    }\n    allFiles.clear();\n  }\n}\n", "docstring": "limpia la lista de ficheros del escaneo", "partition": "test"}
{"idx": "4593", "code": "private void startFileBasedMerge() throws CarbonSortKeyAndGroupByException {\n  try {\n    executorService.shutdown();\n    executorService.awaitTermination(2,TimeUnit.DAYS);\n    dataSorterAndWriterExecutorService.shutdown();\n    dataSorterAndWriterExecutorService.awaitTermination(2,TimeUnit.DAYS);\n  }\n catch (  InterruptedException e) {\n    throw new CarbonSortKeyAndGroupByException(\"Problem while shutdown the server \",e);\n  }\n}\n", "docstring": "below method will be used to start file based merge", "partition": "test"}
{"idx": "4594", "code": "public DateTimeParseException(String message,CharSequence parsedData,int errorIndex){\n  super(message);\n  this.parsedString=parsedData.toString();\n  this.errorIndex=errorIndex;\n}\n", "docstring": "constructs a new exception with the specified message .", "partition": "test"}
{"idx": "4595", "code": "private boolean areParallelSiblings(Component source,Component target,int axis){\n  ComponentInfo sourceInfo=getComponentInfo(source);\n  ComponentInfo targetInfo=getComponentInfo(target);\n  Spring sourceSpring;\n  Spring targetSpring;\n  if (axis == HORIZONTAL) {\n    sourceSpring=sourceInfo.horizontalSpring;\n    targetSpring=targetInfo.horizontalSpring;\n  }\n else {\n    sourceSpring=sourceInfo.verticalSpring;\n    targetSpring=targetInfo.verticalSpring;\n  }\n  ArrayList sourcePath=tmpParallelSet;\n  sourcePath.clear();\n  Spring spring=sourceSpring.getParent();\n  while (spring != null) {\n    sourcePath.add(spring);\n    spring=spring.getParent();\n  }\n  spring=targetSpring.getParent();\n  while (spring != null) {\n    if (sourcePath.contains(spring)) {\n      sourcePath.clear();\n      while (spring != null) {\n        if (spring instanceof ParallelGroup) {\n          return true;\n        }\n        spring=spring.getParent();\n      }\n      return false;\n    }\n    spring=spring.getParent();\n  }\n  sourcePath.clear();\n  return false;\n}\n", "docstring": "returns true if the two components have a common parallelgroup ancestor along the particular axis .", "partition": "test"}
{"idx": "4596", "code": "protected Object readObjectImpl(Class cl) throws IOException {\n  try {\n    Object obj=cl.newInstance();\n    if (_refs == null)     _refs=new ArrayList();\n    _refs.add(obj);\n    HashMap fieldMap=getFieldMap(cl);\n    int code=read();\n    for (; code >= 0 && code != \'z\'; code=read()) {\n      unread();\n      Object key=readObject();\n      Field field=(Field)fieldMap.get(key);\n      if (field != null) {\n        Object value=readObject(field.getType());\n        field.set(obj,value);\n      }\n else {\n        Object value=readObject();\n      }\n    }\n    if (code != \'z\')     throw expect(\"map\",code);\n    try {\n      Method method=cl.getMethod(\"readResolve\",new Class[0]);\n      return method.invoke(obj,new Object[0]);\n    }\n catch (    Exception e) {\n    }\n    return obj;\n  }\n catch (  IOException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new IOExceptionWrapper(e);\n  }\n}\n", "docstring": "reads an object from the input stream . cl is known not to be a map .", "partition": "test"}
{"idx": "4597", "code": "protected static Pair<String,String> lsrImmediate(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue,final String immediateNodeValue){\n  final String shifterOperand=environment.getNextVariableString();\n  final String shifterCarryOut=environment.getNextVariableString();\n  long baseOffset=offset;\n  if (immediateNodeValue.equals(\"0\")) {\n    final String tmpVar1=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,registerNodeValue,wordSize,minusThirtyOneSet,wordSize,tmpVar1));\n    instructions.add(ReilHelpers.createAnd(baseOffset++,wordSize,tmpVar1,byteSize,oneSet,byteSize,shifterCarryOut));\n    return new Pair<String,String>(String.valueOf(0),shifterCarryOut);\n  }\n else {\n    final String tmpVar1=environment.getNextVariableString();\n    final String tmpVar2=environment.getNextVariableString();\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,registerNodeValue,wordSize,\"-\" + immediateNodeValue,qWordSize,tmpVar1));\n    instructions.add(ReilHelpers.createAnd(baseOffset++,qWordSize,tmpVar1,dWordSize,bitMaskAllBitsSet,dWordSize,shifterOperand));\n    instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,registerNodeValue,wordSize,String.valueOf(-(Integer.decode(immediateNodeValue) - 1)),dWordSize,tmpVar2));\n    instructions.add(ReilHelpers.createAnd(baseOffset++,dWordSize,tmpVar2,byteSize,oneSet,byteSize,shifterCarryOut));\n    return new Pair<String,String>(shifterOperand,shifterCarryOut);\n  }\n}\n", "docstring": "< rm > , lsr # < shift_imm > operation : if shift_imm = = 0 then shifter_operand = 0 shifter_carry_out = rm [ 31 ", "partition": "test"}
{"idx": "4598", "code": "public static PlainText plain(int text){\n  return plain(Integer.toString(text));\n}\n", "docstring": "creates a new plaintext component with the given int", "partition": "test"}
{"idx": "4599", "code": "public static boolean isToday(Calendar _calendar){\n  Calendar now=Calendar.getInstance();\n  if (now.get(Calendar.DAY_OF_MONTH) == _calendar.get(Calendar.DAY_OF_MONTH)) {\n    if (now.get(Calendar.MONTH) == _calendar.get(Calendar.MONTH)) {\n      if (now.get(Calendar.YEAR) == _calendar.get(Calendar.YEAR)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "allows to know if a given calendar instance is set today", "partition": "test"}
{"idx": "4600", "code": "public void start(){\n  managedPairs.add(createPort());\n  fixNames();\n  singlePorts.addObserver(observer,false);\n  for (  Ports<M> ports : multiPortsList) {\n    ports.addObserver(observer,false);\n  }\n}\n", "docstring": "creates an initial port and starts to listen .", "partition": "test"}
{"idx": "4601", "code": "protected void sprint(double doubleField){\n  sprint(String.valueOf(doubleField));\n}\n", "docstring": "pretty printing accumulator function for doubles", "partition": "test"}
{"idx": "4602", "code": "public static Bitmap convertYuvImageToBitmap(@NonNull final YuvImage yuvImage){\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  yuvImage.compressToJpeg(new Rect(0,0,yuvImage.getWidth(),yuvImage.getHeight()),100,out);\n  byte[] imageBytes=out.toByteArray();\n  try {\n    out.close();\n  }\n catch (  IOException e) {\n    Log.e(LOG_TAG,\"Exception while closing output stream\",e);\n  }\n  return BitmapFactory.decodeByteArray(imageBytes,0,imageBytes.length);\n}\n", "docstring": "note : this conversion procedure is sloppy and may result in jpeg compression artifacts", "partition": "test"}
{"idx": "4603", "code": "public Double read(String value){\n  return Double.valueOf(value);\n}\n", "docstring": "this method is used to convert the string value given to an appropriate representation . this is used when an object is being deserialized from the xml document and the value for the string representation is required .", "partition": "test"}
{"idx": "4604", "code": "private StoragePort assignPortBasedOnUsage(List<StoragePort> matchingTargetPorts,Map<StoragePort,Integer> portUsage){\n  StoragePort foundPort=null;\n  for (  StoragePort matchedPort : matchingTargetPorts) {\n    if (portUsage.get(matchedPort) == null) {\n      portUsage.put(matchedPort,0);\n    }\n    if (foundPort == null) {\n      foundPort=matchedPort;\n    }\n else {\n      if (portUsage.get(matchedPort) < portUsage.get(foundPort)) {\n        foundPort=matchedPort;\n      }\n    }\n  }\n  if (foundPort != null) {\n    portUsage.put(foundPort,portUsage.get(foundPort) + 1);\n  }\n  return foundPort;\n}\n", "docstring": "doing the best possible assignment . matched target ports should be assigned at least to one initiator .", "partition": "test"}
{"idx": "4605", "code": "public ExternalEvent nextEvent(){\n  if (queue.size() == 0) {\n    return new ExternalEvent(Double.MAX_VALUE);\n  }\n  ExternalEvent ee=queue.get(nextEventIndex);\n  nextEventIndex++;\n  if (nextEventIndex >= queue.size()) {\n    queue=readEvents(nrofPreload);\n    nextEventIndex=0;\n  }\n  return ee;\n}\n", "docstring": "returns the next event in the queue or externalevent with time of double . max_value if there are no events left", "partition": "test"}
{"idx": "4606", "code": "public void appendToBuffer(StringBuilder buf){\n  Iterator<double[]> iter=points.iterator();\n  while (iter.hasNext()) {\n    double[] data=iter.next();\n    for (int i=0; i < data.length; i++) {\n      if (i > 0) {\n        buf.append(\",\");\n      }\n      buf.append(data[i]);\n    }\n    if (iter.hasNext()) {\n      buf.append(\" \");\n    }\n  }\n}\n", "docstring": "append the polygon to the buffer .", "partition": "test"}
{"idx": "4607", "code": "public void updateComboBox(JComboBox<Track> box){\n  box.removeAllItems();\n  box.addItem(null);\n  List<Track> tracks=getTrackByNameList(null);\n  for (  Track track : tracks) {\n    box.addItem(track);\n  }\n}\n", "docstring": "updates a jcombobox with all of the track locations for this location .", "partition": "test"}
{"idx": "4608", "code": "public RefactoringSessionTransformer(final boolean projects){\n  fProjects=projects;\n}\n", "docstring": "creates a new refactoring session transformer .", "partition": "test"}
{"idx": "4609", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(2);\n  newVector.addElement(new Option(\"\\tIf set, classifier is run in debug mode and\\n\" + \"\\tmay output additional info to the console\",\"output-debug-info\",0,\"-output-debug-info\"));\n  newVector.addElement(new Option(\"\\tIf set, classifier capabilities are not checked before classifier is built\\n\" + \"\\t(use with caution).\",\"-do-not-check-capabilities\",0,\"-do-not-check-capabilities\"));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "4610", "code": "public CompareResult open(){\n  final ContentComparator[] comparatorArray=comparators.toArray(new ContentComparator[comparators.size()]);\n  final CustomCompareEditorInput input=new CustomCompareEditorInput(modified,original,ancestor,comparatorArray,compareConfiguration,externalCompareHandler);\n  if (compareConfiguration.isLeftEditable() || compareConfiguration.isRightEditable()) {\n    compareConfiguration.setProperty(\"org.eclipse.compare.internal.CONFIRM_SAVE_PROPERTY\",Boolean.FALSE);\n    input.setAlwaysDirty(alwaysDirty);\n  }\n  input.addSaveListener(new ProxyCompareSaveListener());\n  log.info(MessageFormat.format(\"Comparing {0} to {1}\",getLabelNOLOC(modified),getLabelNOLOC(original)));\n  compareUIType.openCompareUI(input);\n  final boolean contentsIdentical=(input.getCompareResult() == null);\n  final boolean contentsSaved=(input.getSavedContents().length > 0);\n  return new CompareResult(contentsIdentical,input.wasOKPressed(),contentsSaved);\n}\n", "docstring": "opens this compare operation , showing the compare ui , returning the result details of the comparison . note that the compare results only includes saved data from the results of opening the ui - that is , it will only include saved data from a synchronous comparison ( ie , in a dialog ) . if you use an asynchronous compare ui ( ie , an editor ) , you should hook up a save listener .", "partition": "test"}
{"idx": "4611", "code": "protected void addResource(String resource){\n  if (!StringUtils.isEmpty(resource)) {\n    resources.add(resource);\n  }\n}\n", "docstring": "import a resources into view", "partition": "test"}
{"idx": "4612", "code": "public static boolean isNumeric(String maybeNumeric){\n  return maybeNumeric != null && maybeNumeric.matches(\"[0-9]+\");\n}\n", "docstring": "checks whether a string contains only number or not using a regex . i like this approach since it doesn \"'\" t need to parse it into a numerical variable which may not fit into any particularly type", "partition": "test"}
{"idx": "4613", "code": "public void openKeyStore(File keyStoreFile,String defaultPassword){\n  try {\n    if (!keyStoreFile.isFile()) {\n      JOptionPane.showMessageDialog(frame,MessageFormat.format(res.getString(\"OpenAction.NotFile.message\"),keyStoreFile),res.getString(\"OpenAction.OpenKeyStore.Title\"),JOptionPane.WARNING_MESSAGE);\n      return;\n    }\n    if (isKeyStoreFileOpen(keyStoreFile)) {\n      JOptionPane.showMessageDialog(frame,MessageFormat.format(res.getString(\"OpenAction.NoOpenKeyStoreAlreadyOpen.message\"),keyStoreFile),res.getString(\"OpenAction.OpenKeyStore.Title\"),JOptionPane.WARNING_MESSAGE);\n      return;\n    }\n    Password password=(defaultPassword != null) ? new Password(defaultPassword.toCharArray()) : null;\n    KeyStore openedKeyStore=null;\n    boolean firstTry=true;\n    while (true) {\n      if (password == null) {\n        password=showPasswordDialog(keyStoreFile);\n      }\n      if (password == null) {\n        return;\n      }\n      try {\n        openedKeyStore=KeyStoreUtil.load(keyStoreFile,password);\n        break;\n      }\n catch (      KeyStoreLoadException klex) {\n        if (defaultPassword == null || !firstTry) {\n          int tryAgainChoice=showErrorMessage(keyStoreFile,klex);\n          if (tryAgainChoice == JOptionPane.NO_OPTION) {\n            return;\n          }\n        }\n      }\n      password.nullPassword();\n      password=null;\n      firstTry=false;\n    }\n    if (openedKeyStore == null) {\n      JOptionPane.showMessageDialog(frame,MessageFormat.format(res.getString(\"OpenAction.FileNotRecognisedType.message\"),keyStoreFile.getName()),res.getString(\"OpenAction.OpenKeyStore.Title\"),JOptionPane.WARNING_MESSAGE);\n      return;\n    }\n    kseFrame.addKeyStore(openedKeyStore,keyStoreFile,password);\n  }\n catch (  FileNotFoundException ex) {\n    JOptionPane.showMessageDialog(frame,MessageFormat.format(res.getString(\"OpenAction.NoReadFile.message\"),keyStoreFile),res.getString(\"OpenAction.OpenKeyStore.Title\"),JOptionPane.WARNING_MESSAGE);\n  }\ncatch (  Exception ex) {\n    DError.displayError(frame,ex);\n  }\n}\n", "docstring": "open the supplied keystore file from disk .", "partition": "test"}
{"idx": "4614", "code": "public final long addAndGet(long delta){\n  for (; ; ) {\n    long current=get();\n    long next=current + delta;\n    if (compareAndSet(current,next))     return next;\n  }\n}\n", "docstring": "atomically adds the given value to the current value .", "partition": "test"}
{"idx": "4615", "code": "private final void append(List<? super NameValuePair> l,final String k,final String v){\n  if (v != null)   l.add(new NameValuePair(k,v));\n}\n", "docstring": "appends a namevaluepair of k / v to l if v is non - null .", "partition": "test"}
{"idx": "4616", "code": "protected Properties createProperties(URL location) throws IOException {\n  InputStream is=null;\n  if (location != null) {\n    is=location.openStream();\n  }\n  Properties tmpProperties=new Properties();\n  if (is != null) {\n    tmpProperties.load(is);\n  }\n  return tmpProperties;\n}\n", "docstring": "reads the file at the given location and creates a properties file from the contents .", "partition": "test"}
{"idx": "4617", "code": "protected double calcPlanWeight(final T plan,final double maxScore){\n  if (plan.getScore() == null) {\n    return Double.NaN;\n  }\n  double weight=Math.exp(this.beta * (plan.getScore() - maxScore));\n  if (weight < MIN_WEIGHT)   weight=MIN_WEIGHT;\n  return weight;\n}\n", "docstring": "calculates the weight of a single plan .", "partition": "test"}
{"idx": "4618", "code": "void findValue(){\n  if (log.isDebugEnabled()) {\n    log.debug(\"findValue invoked on \" + label());\n  }\n  for (int i=0; i < _value.getItemCount(); i++) {\n    String choice=_value.getItemAt(i);\n    SettingList sl=choiceHash.get(choice);\n    if (sl.match()) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"  match in \" + i);\n      }\n      _value.setSelectedItem(choice);\n      return;\n    }\n  }\n  if (log.isDebugEnabled()) {\n    log.debug(\"   no match\");\n  }\n}\n", "docstring": "suspect underlying variables have changed value ; check . first match will succeed , so there should not be multiple matches possible . ( \" first match \" is defined in choice - sequence )", "partition": "test"}
{"idx": "4619", "code": "public java.lang.StringBuilder insert(int index,java.lang.String string){\n  if (string == null) {\n    string=\"null\";\n  }\n  int min=string.length();\n  if (min != 0) {\n    move(min,index);\n    string.getChars(0,min,value,index);\n    count+=min;\n  }\n  return this;\n}\n", "docstring": "inserts the string into this string buffer . the characters of the string argument are inserted , in order , into this string buffer at the indicated offset , moving up any characters originally above that position and increasing the length of this string buffer by the length of the argument . if str is null , then the four characters \" null \" are inserted into this string buffer . the character at index k in the new character sequence is equal to : the character at index k in the old character sequence , if k is less than offset the character at index k - offset in the argument str , if k is not less than offset but is less than offset + str . length ( ) the character at index k - str . length ( ) in the old character sequence , if k is not less than offset + str . length ( ) the offset argument must be greater than or equal to 0 , and less than or equal to the length of this string buffer .", "partition": "test"}
{"idx": "4620", "code": "public void mkdir(String key) throws IOException {\n  key=key.replace(\" \",\"\");\n  if (key.endsWith(\"/\") && !key.equals(\"/\")) {\n    throw new InvalidParameterException(\"Trailing slash not allowed in zookeeper path\");\n  }\n  String[] split=key.split(\"/\");\n  StringBuilder builder=new StringBuilder();\n  for (  String s : split) {\n    builder.append(s);\n    if (!s.isEmpty() && !exists(builder.toString())) {\n      zkState.set(builder.toString(),null);\n    }\n    builder.append(\"/\");\n  }\n}\n", "docstring": "creates the znode if it does not exist . will create parent directories .", "partition": "test"}
{"idx": "4621", "code": "public double calculateLog(double value){\n  return Math.log(value) / this.baseLog;\n}\n", "docstring": "calculates the log of the given value , using the current base .", "partition": "test"}
{"idx": "4622", "code": "public static Vector3 pow(Vector3 o,double power){\n  return new Vector3(Math.pow(o.x,power),Math.pow(o.y,power),Math.pow(o.z,power));\n}\n", "docstring": "raises the x , y , and z values of a vector3 to the given power .", "partition": "test"}
{"idx": "4623", "code": "public DatagramPacket responseReceive() throws IOException {\n  byte[] buf=new byte[1024];\n  DatagramPacket dp=new DatagramPacket(buf,buf.length);\n  datagramSocket.receive(dp);\n  return dp;\n}\n", "docstring": "used to receive ssdp response packet", "partition": "test"}
{"idx": "4624", "code": "@Override public void flush(){\n  flush(false);\n}\n", "docstring": "flushes page and it \"'\" s content stream . < br > < br > if the page belongs to the document which is tagged , page flushing also triggers flushing of the tags , which are considered to belong to the page . the logic that defines if the given tag ( structure element ) belongs to the page is the following : if all the marked content references ( dictionary or number references ) , that are the descenders of the given structure element , belong to the current page - the tag is considered to belong to the page . if tag has descenders from several pages - it is flushed , if all other pages except the current one are flushed .", "partition": "test"}
{"idx": "4625", "code": "public static float[] temperatureToRGB(int degreesK){\n  int k=MathUtils.constrain(degreesK,1000,20000);\n  float a=(k % 100) / 100.0f;\n  int i=((k - 1000) / 100) * 3;\n  return new float[]{interp(i,a),interp(i + 1,a),interp(i + 2,a)};\n}\n", "docstring": "convert a color temperature value ( in kelvin ) to a rgb units as floats . this can be used in a transform matrix or hardware gamma control .", "partition": "test"}
{"idx": "4626", "code": "public AdvancedStateMap.Builder withName(Function<PropertiesMap,String> mapper){\n  this.nameMapper=mapper;\n  return this;\n}\n", "docstring": "sets the state mapper to set the name to the value returned by the specified mapper", "partition": "test"}
{"idx": "4627", "code": "public synchronized void message(LocoNetMessage m){\n  int opCode=m.getOpCode();\nswitch (opCode) {\ncase LnConstants.OPC_PEER_XFER:\n    int src=m.getElement(2);\n  int dst=m.getElement(3) + m.getElement(4) * 256;\nint[] packet=m.getPeerXfrData();\nif (src == lowPart(LocoBufferAddress)) {\nString lbv=((packet[2] != 0) ? dotme(packet[2]) : \"1.0\");\nsetLBVersion(lbv);\n}\nif (dst == LocoBufferAddress && src == lowPart(unitAddress) && (packet[4] == unitSubAddress)) {\nstopTimer();\nreplyReceived();\nString fw=((packet[2] != 0) ? dotme(packet[2]) : \"1.3.2\");\nsetLIOVersion(fw);\nif (packet[0] == LocoIO.LOCOIO_SV_READ || reading) {\nif (lastOpCv >= 0 && lastOpCv <= 50) {\n  int data=(packet[2] != 0) ? packet[5] : packet[7];\n  int channel=(lastOpCv / 3) - 1;\n  if (channel < 0) {\n    log.warn(\"... channel is less than zero!!!\");\n    channel=0;\n  }\n  int type=lastOpCv - (channel * 3 + 3);\n  log.debug(\"... updating port \" + channel + \" SV\"+ type+ \"(\"+ (type == 1 ? \"value1\" : type == 2 ? \"value2\" : type == 0 ? \"mode\" : \"unknown\")+ \") = 0x\"+ Integer.toHexString(data));\n  if (type == 2) {\n    setV2(channel,data);\n    setMode(channel,\"<none>\");\n  }\n else   if (type == 1) {\n    setV1(channel,data);\n    setMode(channel,\"<none>\");\n  }\n else   if (type == 0) {\n    setSV(channel,data);\n    LocoIOMode lim=validmodes.getLocoIOModeFor(getSV(channel),getV1(channel),getV2(channel));\n    if (lim == null) {\n      setMode(channel,\"<none>\");\n      setAddr(channel,0);\n      log.debug(\"Could not find mode!\");\n    }\n else {\n      setMode(channel,lim.getFullMode());\n      setAddr(channel,validmodes.valuesToAddress(lim.getOpcode(),getSV(channel),getV1(channel),getV2(channel)));\n    }\n    log.debug(\"... decoded address (\" + \"cv=\" + Integer.toHexString(getSV(channel)) + \" \"+ \"v1=\"+ Integer.toHexString(getV1(channel))+ \" \"+ \"v2=\"+ Integer.toHexString(getV2(channel))+ \") \"+ \"is \"+ getAddr(channel)+ \"(0x\"+ Integer.toHexString(getAddr(channel))+ \")\");\n  }\n else {\n    log.warn(\"OPC_PEER_XFR: Type (\" + type + \") is not {0,1,2} for channel \"+ channel);\n  }\n}\n else {\n}\n}\nissueNextOperation();\nreturn;\n}\n else {\nreturn;\n}\ncase LnConstants.OPC_INPUT_REP:\nif (log.isDebugEnabled()) {\nlog.debug(LnConstants.OPC_NAME(opCode) + \" received\");\n}\nfor (int i=0; i < _numRows; i++) {\nif (capture[i]) {\nif (log.isDebugEnabled()) {\nlog.debug(\"row set for capture: \" + i);\n}\nint val1=m.getElement(1);\nint val2=m.getElement(2);\nsetAddr(i,((val2 & 0x0F) << 5) * 256 + ((val1 & 0x7f) << 1) | (((val2 & LnConstants.OPC_SW_REQ_DIR) == LnConstants.OPC_SW_REQ_DIR) ? 0x01 : 0x00));\ncapture[i]=false;\n}\n}\nreturn;\ncase LnConstants.OPC_SW_REQ:\nif (log.isDebugEnabled()) {\nlog.debug(LnConstants.OPC_NAME(opCode) + \" received\");\n}\nfor (int i=0; i < _numRows; i++) {\nif (capture[i]) {\nif (log.isDebugEnabled()) {\nlog.debug(\"row set for capture: \" + i);\n}\nint val1=m.getElement(1);\nint val2=m.getElement(2);\nint addr=LocoIO.SENSOR_ADR(val1,val2);\nsetAddr(i,addr);\ncapture[i]=false;\n}\n}\nreturn;\ndefault :\n}\n}\n", "docstring": "listen to the loconet . we \"'\" re listening for incoming opc_peer_xfr messages , which might be part of a read or write sequence . we \"'\" re also _sometimes_ listening for commands as part of a \" capture \" operation . < p > the incoming loconet opc_peer_xfr messages don \"'\" t retain any information about the cv number or whether it was a read or write operation . we store the data regardless of whether it was read or write , but we need to remember the cv number in the lastopcv member . < p >", "partition": "test"}
{"idx": "4628", "code": "public boolean handleExceptionFromServer(Writer writer,Reader reader,Throwable ex){\n  if (ex instanceof ClosedChannelException) {\n    if (_logger.isLoggable(Level.FINE))     _logger.log(Level.FINE,\"Connection with client closed from [\" + writer.getEndPointAddress() + \"] endpoint.\");\n    return true;\n  }\n  if (ex instanceof MarshalContextClearedException) {\n    if (_logger.isLoggable(Level.FINE))     _logger.log(Level.FINE,\"Marshal context have been cleared, probably because the exported service class loader has been unloaded, service incoming invocation from [\" + writer.getEndPointAddress() + \"] endpoint.\");\n    return true;\n  }\n  try {\n    String msg=\"LRMI Transport Protocol caught server exception caused by [\" + writer.getEndPointAddress() + \"] client.\";\n    if (ex instanceof LRMIUnhandledException) {\n      if (_logger.isLoggable(Level.FINE))       _logger.log(Level.FINE,msg,ex);\n      LRMIUnhandledException lrmiue=(LRMIUnhandledException)ex;\n      if (lrmiue.getStage() == Stage.DESERIALIZATION) {\n        reader.resetContext();\n      }\n      if (writer.isOpen())       writer.writeReply(new ReplyPacket(null,lrmiue));\n      return false;\n    }\n else     if (ex instanceof RuntimeException || ex instanceof InvalidClassException) {\n      if (_logger.isLoggable(Level.SEVERE))       _logger.log(Level.SEVERE,msg,ex);\n    }\n else     if (ex instanceof UnmarshalException) {\n      if (_logger.isLoggable(Level.WARNING))       _logger.log(Level.WARNING,msg,ex);\n    }\n else {\n      if (_logger.isLoggable(Level.FINE))       _logger.log(Level.FINE,msg,ex);\n    }\n    if (writer.isOpen())     writer.writeReply(new ReplyPacket(null,new ProtocolException(msg,ex)));\n    return true;\n  }\n catch (  Exception ex2) {\n    if (_logger.isLoggable(Level.FINE))     _logger.log(Level.FINE,\"Failed to send handledServerException to endpoint [\" + writer.getEndPointAddress() + \"] , the client disconnected from the server.\",ex);\n    return true;\n  }\n}\n", "docstring": "send if possible the catch server exception to the client", "partition": "test"}
{"idx": "4629", "code": "public String sprintf(){\n  final Iterator<ConversionSpecification> e=vFmt.iterator();\n  ConversionSpecification cs;\n  char c;\n  final StringBuilder sb=new StringBuilder();\n  while (e.hasNext()) {\n    cs=e.next();\n    c=cs.getConversionCharacter();\n    if (c == '\\0') {\n      sb.append(cs.getLiteral());\n    }\n else     if (c == '%') {\n      sb.append('%');\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "format nothing . just use the control string .", "partition": "test"}
{"idx": "4630", "code": "default String resourceName(String tableName,String type){\n  return String.format(RESOURCE_NAME,tableName,type);\n}\n", "docstring": "get the name of a relation between an object and a resource", "partition": "test"}
{"idx": "4631", "code": "protected void updateComboBoxesLoadChange(){\n  if (autoTrackCheckBox.isSelected()) {\n    updateLocationTrackComboBox();\n  }\n  if (autoDestinationTrackCheckBox.isSelected()) {\n    updateDestinationTrackComboBox();\n  }\n  if (autoFinalDestTrackCheckBox.isSelected()) {\n    updateFinalDestination();\n  }\n}\n", "docstring": "update locations if load changes . new load could change which track are allowed if auto selected . return when empty ( rwe ) always uses the default empty load of \" e \" .", "partition": "test"}
{"idx": "4632", "code": "public String removeClassColumnTipText(){\n  return \"Remove the class column (if set) from the data.\";\n}\n", "docstring": "returns the tip text for this property", "partition": "test"}
{"idx": "4633", "code": "public static String join(NamedValue[] values,String separator){\n  StringBuilder buff=new StringBuilder();\n  for (int i=0; i < values.length; i++) {\n    buff.append(values[i]);\n    if (i < values.length - 1)     buff.append(separator);\n  }\n  return buff.toString();\n}\n", "docstring": "joins multiple namedvalues into a single string", "partition": "test"}
{"idx": "4634", "code": "protected String sourceClass(Attribute c,double[] dist){\n  if (c.isNominal()) {\n    return Integer.toString(Utils.maxIndex(dist));\n  }\n else {\n    return Double.toString(dist[0]);\n  }\n}\n", "docstring": "returns the value as string out of the given distribution", "partition": "test"}
{"idx": "4635", "code": "public void done() throws IOException {\n  printer.flush();\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "4636", "code": "int requestGroupData(char groupNum){\n  setCurrDataGroup(groupNum);\n  currGrpItems=knownGrpItems.get(Integer.valueOf(getCurrDataGroup()));\n  char[] payLoad={groupNum};\n  return (writeTelegram(payLoad,CMD_GROUP_READ,null));\n}\n", "docstring": "send request to read group data", "partition": "test"}
{"idx": "4637", "code": "public long skip(long bytes) throws IOException {\n  if (closed) {\n    throw new IOException(\"The stream is closed.\");\n  }\n  int av=available();\n  if (av == 0) {\n    av=makeAvailable();\n    if (av == 0) {\n      return 0;\n    }\n  }\n  long res=Math.min(av,bytes);\n  head+=res;\n  return res;\n}\n", "docstring": "skips the given number of bytes .", "partition": "test"}
{"idx": "4638", "code": "protected void drawCenterText(Canvas c){\n  CharSequence centerText=mChart.getCenterText();\n  if (mChart.isDrawCenterTextEnabled() && centerText != null) {\n    PointF center=mChart.getCenterCircleBox();\n    float innerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();\n    RectF holeRect=mRectBuffer[0];\n    holeRect.left=center.x - innerRadius;\n    holeRect.top=center.y - innerRadius;\n    holeRect.right=center.x + innerRadius;\n    holeRect.bottom=center.y + innerRadius;\n    RectF boundingRect=mRectBuffer[1];\n    boundingRect.set(holeRect);\n    float radiusPercent=mChart.getCenterTextRadiusPercent() / 100f;\n    if (radiusPercent > 0.0) {\n      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);\n    }\n    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {\n      mCenterTextLastBounds.set(boundingRect);\n      mCenterTextLastValue=centerText;\n      float width=mCenterTextLastBounds.width();\n      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);\n    }\n    float layoutHeight=mCenterTextLayout.getHeight();\n    c.save();\n    if (Build.VERSION.SDK_INT >= 18) {\n      Path path=new Path();\n      path.addOval(holeRect,Path.Direction.CW);\n      c.clipPath(path);\n    }\n    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);\n    mCenterTextLayout.draw(c);\n    c.restore();\n  }\n}\n", "docstring": "draws the description text in the center of the pie chart makes most sense when center - hole is enabled", "partition": "test"}
{"idx": "4639", "code": "void addToPrototypeCallback();\n", "docstring": "generates a function that adds members to a prototype , then calls it .", "partition": "test"}
{"idx": "4640", "code": "public AllToAllPanel(AllToAll connector,NetworkPanel networkPanel){\n  super();\n  this.connection=connector;\n  allowSelfConnectPanel=new JPanel(new FlowLayout(FlowLayout.LEFT));\n  allowSelfConnectPanel.add(new JLabel(\" Allow Self Connections: \"));\n  allowSelfConnectPanel.add(allowSelfConnectChkBx);\n  fillFieldValues();\n  add(allowSelfConnectPanel);\n}\n", "docstring": "construct a new all to all panel .", "partition": "test"}
{"idx": "4641", "code": "private void allocate_sections(int p_section_count){\n  section_list.ensureCapacity(p_section_count);\n  while (section_list.size() < p_section_count) {\n    section_list.add(new MazeSearchElement());\n  }\n}\n", "docstring": "allocates and initializes p_section_count sections", "partition": "test"}
{"idx": "4642", "code": "public WeightDistribution(ColumnExampleTable columnTable,int[] selection,int attributeNumber){\n  calculateLabelWeights(columnTable,selection,attributeNumber);\n  leftLabelWeights=new double[totalLabelWeights.length];\n  leftWeight=0;\n  totalWeight=getTotalWeight(totalLabelWeights);\n  if (hasMissings) {\n    missingsWeight=getTotalWeight(missingsLabelWeights);\n    rightWeight=totalWeight - missingsWeight;\n    rightLabelWeights=arrayDifference(totalLabelWeights,missingsLabelWeights);\n  }\n else {\n    missingsWeight=0;\n    rightWeight=totalWeight;\n    rightLabelWeights=new double[totalLabelWeights.length];\n    System.arraycopy(totalLabelWeights,0,rightLabelWeights,0,totalLabelWeights.length);\n  }\n}\n", "docstring": "initializes the counting arrays with the start distribution .", "partition": "test"}
{"idx": "4643", "code": "public static String removeExtension(String fileName){\n  int index=fileName.lastIndexOf('.');\n  if (index == -1) {\n    return fileName;\n  }\n else {\n    return fileName.substring(0,index);\n  }\n}\n", "docstring": "removes the extensions of the given file name .", "partition": "test"}
{"idx": "4644", "code": "public void delete(String name) throws IOException {\n  if (name.equalsIgnoreCase(KEY_ID)) {\n    id=null;\n  }\n else {\n    throw new IOException(\"Attribute name not recognized by \" + \"CertAttrSet:SubjectKeyIdentifierExtension.\");\n  }\n  encodeThis();\n}\n", "docstring": "delete the attribute value .", "partition": "test"}
{"idx": "4645", "code": "public static DataFrame normalize(DataFrame dataFrame,double min,double max){\n  return normalize(dataFrame,min,max,Collections.<String>emptyList());\n}\n", "docstring": "scale based on min , max", "partition": "test"}
{"idx": "4646", "code": "private static void addLeafWithNonExistingParents(Spatial root,Spatial leaf){\n  if (!(root instanceof Node)) {\n    logger.log(Level.WARNING,\"Cannot add new Leaf {0} to {1}, is not a Node!\",new Object[]{leaf.getName(),root.getName()});\n    return;\n  }\n  for (Spatial s=leaf; s.getParent() != null; s=s.getParent()) {\n    Spatial parent=s.getParent();\n    Spatial other=findTaggedSpatial(root,parent);\n    if (other == null) {\n      continue;\n    }\n    if (other instanceof Node) {\n      logger.log(Level.INFO,\"Attaching {0} to {1} in root {2} to add leaf {3}\",new Object[]{s,other,root,leaf});\n      for (Spatial spt=leaf; spt != parent; spt=spt.getParent()) {\n        spt.setUserData(ORIGINAL_NAME,spt.getName());\n        spt.setUserData(ORIGINAL_PATH,getSpatialPath(spt));\n        spt=spt.getParent();\n      }\n      Node otherNode=(Node)other;\n      otherNode.attachChild(s);\n      logger.log(LogLevel.USERINFO,\"Attached Node {0} with leaf {0}\",new Object[]{other.getName(),leaf.getName()});\n      return;\n    }\n else {\n      logger.log(Level.WARNING,\"Cannot attach leaf {0} to found spatial {1} in root {2}, not a node.\",new Object[]{leaf,other,root});\n    }\n  }\n  logger.log(Level.WARNING,\"Could not attach new Leaf {0}, no root node found.\",leaf.getName());\n}\n", "docstring": "adds a leaf to a spatial , including all nonexisting parents .", "partition": "test"}
{"idx": "4647", "code": "private void adjustBlockListeners(List<OBlock> oldRange,List<OBlock> newRange,Tracker tracker){\n  Iterator<OBlock> iter=newRange.iterator();\n  while (iter.hasNext()) {\n    OBlock b=iter.next();\n    if (oldRange.contains(b)) {\n      oldRange.remove(b);\n      continue;\n    }\n    addBlockListener(b,tracker);\n  }\n  iter=oldRange.iterator();\n  while (iter.hasNext()) {\n    removeBlockListener(iter.next(),tracker);\n  }\n}\n", "docstring": "do venn diagram between the two sets . keep listeners held in common . add new listeners . remove old .", "partition": "test"}
{"idx": "4648", "code": "static public String hexEncode(byte[] aInput){\n  StringBuffer result=new StringBuffer();\n  final char[] digits={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n  for (int idx=0; idx < aInput.length; ++idx) {\n    byte b=aInput[idx];\n    result.append(digits[(b & 0xf0) >> 4]);\n    result.append(digits[b & 0x0f]);\n  }\n  return result.toString();\n}\n", "docstring": "the byte [ ", "partition": "test"}
{"idx": "4649", "code": "private static Size clampSize(Size original,double maxArea,Size maxSize){\n  if (original.getWidth() * original.getHeight() < maxArea && original.getWidth() < maxSize.getWidth() && original.getHeight() < maxSize.getHeight()) {\n    return original;\n  }\n  double ratio=Math.min(Math.sqrt(maxArea / original.area()),1.0f);\n  int width=(int)Math.round(original.width() * ratio);\n  int height=(int)Math.round(original.height() * ratio);\n  if (width > maxSize.width() || height > maxSize.height()) {\n    return computeFitWithinSize(original,maxSize);\n  }\n  return new Size(width,height);\n}\n", "docstring": "given a size , compute a value such that it will downscale the original size to fit within the maxsize bounding box and to be less than the provided area . this will never upscale sizes .", "partition": "test"}
{"idx": "4650", "code": "TCPChannel(TCPTransport tr,TCPEndpoint ep){\n  this.tr=tr;\n  this.ep=ep;\n}\n", "docstring": "create channel for endpoint .", "partition": "test"}
{"idx": "4651", "code": "@Override public final String toString(){\n  StringBuilder buffer=new StringBuilder();\n  buffer.append(\"Document<\");\n  for (int i=0; i < fields.size(); i++) {\n    IndexableField field=fields.get(i);\n    buffer.append(field.toString());\n    if (i != fields.size() - 1) {\n      buffer.append(\" \");\n    }\n  }\n  buffer.append(\">\");\n  return buffer.toString();\n}\n", "docstring": "prints the fields of a document for human consumption .", "partition": "test"}
{"idx": "4652", "code": "public static byte[] encode(byte[] data){\n  ByteArrayOutputStream bOut=new ByteArrayOutputStream();\n  try {\n    encoder.encode(data,0,data.length,bOut);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"exception encoding base64 string: \" + e);\n  }\n  return bOut.toByteArray();\n}\n", "docstring": "encode the input data producing a base 64 encoded byte array .", "partition": "test"}
{"idx": "4653", "code": "public static Face drawDir(Direction dir,MeshModel model,double minX,double minY,double minZ,double maxX,double maxY,double maxZ,CubeTextureCoordinates textureCoordinates){\nswitch (dir) {\ncase DOWN:\n    return drawDown(model,minX,minY,minZ,maxX,maxY,maxZ,textureCoordinates);\ncase UP:\n  return drawUp(model,minX,minY,minZ,maxX,maxY,maxZ,textureCoordinates);\ncase NORTH:\nreturn drawNorth(model,minX,minY,minZ,maxX,maxY,maxZ,textureCoordinates);\ncase SOUTH:\nreturn drawSouth(model,minX,minY,minZ,maxX,maxY,maxZ,textureCoordinates);\ncase EAST:\nreturn drawEast(model,minX,minY,minZ,maxX,maxY,maxZ,textureCoordinates);\ncase WEST:\nreturn drawWest(model,minX,minY,minZ,maxX,maxY,maxZ,textureCoordinates);\n}\nthrow new RenderException(\"Invalid draw direction!\");\n}\n", "docstring": "creates a face of the model in a specified direction", "partition": "test"}
{"idx": "4654", "code": "public MAVLinkMessage(MAVLinkSchema schema,ByteBuffer buffer) throws MAVLinkProtocolException, MAVLinkUnknownMessage, BufferUnderflowException {\n  if (buffer.remaining() < NON_PAYLOAD_LENGTH) {\n    throw new BufferUnderflowException();\n  }\n  int startPos=buffer.position();\n  byte startSign=buffer.get();\n  if (startSign != START_OF_FRAME) {\n    throw new MAVLinkProtocolException(String.format(\"Invalid start sign: %02x, should be %02x\",startSign,START_OF_FRAME));\n  }\n  int payloadLen=buffer.get() & 0xff;\n  if (buffer.remaining() < payloadLen + NON_PAYLOAD_LENGTH - 2) {\n    buffer.position(startPos);\n    throw new BufferUnderflowException();\n  }\n  sequence=buffer.get();\n  systemID=buffer.get() & 0xff;\n  componentID=buffer.get() & 0xff;\n  msgID=buffer.get() & 0xff;\n  this.schema=schema;\n  this.definition=schema.getMessageDefinition(msgID);\n  if (definition == null) {\n    buffer.position(buffer.position() + payloadLen + CRC_LENGTH);\n    throw new MAVLinkUnknownMessage(String.format(\"Unknown message: %s\",msgID));\n  }\n  if (payloadLen != definition.payloadLength) {\n    buffer.position(buffer.position() + payloadLen + CRC_LENGTH);\n    throw new MAVLinkUnknownMessage(String.format(\"Invalid payload len for msg %s (%s): %s, should be %s\",definition.name,msgID,payloadLen,definition.payloadLength));\n  }\n  this.payload=new byte[definition.payloadLength];\n  buffer.get(payload);\n  crc=Short.reverseBytes(buffer.getShort()) & 0xffff;\n  int endPos=buffer.position();\n  buffer.position(startPos);\n  int crcCalc=calculateCRC(buffer);\n  buffer.position(endPos);\n  if (crc != crcCalc) {\n    throw new MAVLinkUnknownMessage(String.format(\"CRC error for msg %s (%s): %02x, should be %02x\",definition.name,msgID,crc,crcCalc));\n  }\n  this.payloadBB=ByteBuffer.wrap(payload);\n  payloadBB.order(schema.getByteOrder());\n}\n", "docstring": "create message from buffer ( for parsing )", "partition": "test"}
{"idx": "4655", "code": "public static double log1p(final double x){\n  if (x == -1) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  if (x == Double.POSITIVE_INFINITY) {\n    return Double.POSITIVE_INFINITY;\n  }\n  if (x > 1e-6 || x < -1e-6) {\n    final double xpa=1 + x;\n    final double xpb=-(xpa - 1 - x);\n    final double[] hiPrec=new double[2];\n    final double lores=log(xpa,hiPrec);\n    if (Double.isInfinite(lores)) {\n      return lores;\n    }\n    final double fx1=xpb / xpa;\n    final double epsilon=0.5 * fx1 + 1;\n    return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n  }\n else {\n    final double y=(x * F_1_3 - F_1_2) * x + 1;\n    return y * x;\n  }\n}\n", "docstring": "computes log ( 1 + x ) .", "partition": "test"}
{"idx": "4656", "code": "protected ScriptBuilder bigNum(long num){\n  return bigNum(chunks.size(),num);\n}\n", "docstring": "adds the given number as a push data chunk . this is intended to use for negative numbers or values > 16 , and although it will accept numbers in the range 0 - 16 inclusive , the encoding would be considered non - standard .", "partition": "test"}
{"idx": "4657", "code": "public final void change_entries(BrdTracep p_obj,Polyline p_new_polyline,int p_keep_at_start_count,int p_keep_at_end_count){\n  int compensated_half_width=p_obj.get_half_width() + get_clearance_compensation(p_obj.clearance_idx(),p_obj.get_layer());\n  ArrayList<ShapeTile> changed_shapes=offset_shapes(p_new_polyline,compensated_half_width,p_keep_at_start_count,p_new_polyline.plaline_len(-1) - p_keep_at_end_count);\n  int old_shape_count=p_obj.tree_shape_count(this);\n  int new_shape_count=changed_shapes.size() + p_keep_at_start_count + p_keep_at_end_count;\n  AwtreeNodeLeaf[] new_leaf_arr=new AwtreeNodeLeaf[new_shape_count];\n  ShapeTile[] new_precalculated_tree_shapes=new ShapeTile[new_shape_count];\n  AwtreeNodeLeaf[] old_entries=p_obj.get_search_tree_entries(this);\n  for (int index=0; index < p_keep_at_start_count; ++index) {\n    new_leaf_arr[index]=old_entries[index];\n    new_precalculated_tree_shapes[index]=p_obj.get_tree_shape(this,index);\n  }\n  for (int index=p_keep_at_start_count; index < old_shape_count - p_keep_at_end_count; ++index) {\n    remove_leaf(old_entries[index]);\n  }\n  for (int i=0; i < p_keep_at_end_count; ++i) {\n    int new_index=new_shape_count - p_keep_at_end_count + i;\n    int old_index=old_shape_count - p_keep_at_end_count + i;\n    new_leaf_arr[new_index]=old_entries[old_index];\n    new_leaf_arr[new_index].shape_index_in_object=new_index;\n    new_precalculated_tree_shapes[new_index]=p_obj.get_tree_shape(this,old_index);\n  }\n  for (int index=p_keep_at_start_count; index < new_shape_count - p_keep_at_end_count; ++index) {\n    new_precalculated_tree_shapes[index]=changed_shapes.get(index - p_keep_at_start_count);\n  }\n  p_obj.set_precalculated_tree_shapes(new_precalculated_tree_shapes,this);\n  for (int index=p_keep_at_start_count; index < new_shape_count - p_keep_at_end_count; ++index) {\n    new_leaf_arr[index]=insert(p_obj,index);\n  }\n  p_obj.set_search_tree_entries(this,new_leaf_arr);\n}\n", "docstring": "changes the tree entries from p_keep_at_start_count + 1 to new_shape_count - 1 - keep_at_end_count to p_changed_entries . special implementation for change_trace for performance reasons", "partition": "test"}
{"idx": "4658", "code": "public void paintComponentBackground(Graphics g){\n  super.paintComponentBackground(g);\n  int clipX=g.getClipX();\n  int clipY=g.getClipY();\n  int clipW=g.getClipWidth();\n  int clipH=g.getClipHeight();\n  int width=getWidth();\n  int height=getHeight();\n  int y=getY();\n  if (infinite) {\n    int blockSize=getWidth() / 5;\n    int x=getX() + (int)((((float)value) / ((float)maxValue - minValue)) * (getWidth() - blockSize));\n    g.clipRect(x,y,blockSize,height - 1);\n  }\n else {\n    if (vertical) {\n      int actualHeight=(int)((((float)value) / ((float)maxValue - minValue)) * getHeight());\n      y+=height - actualHeight;\n    }\n else {\n      width=(int)((((float)value) / ((float)maxValue - minValue)) * getWidth());\n    }\n    g.clipRect(getX(),y,width,height);\n  }\n  paintingFull=true;\n  super.paintComponentBackground(g);\n  paintingFull=false;\n  g.setClip(clipX,clipY,clipW,clipH);\n  if (thumbImage != null && !infinite) {\n    if (!vertical) {\n      int xPos=getX() + width - thumbImage.getWidth() / 2;\n      xPos=Math.max(getX(),xPos);\n      xPos=Math.min(getX() + getWidth() - thumbImage.getWidth(),xPos);\n      g.drawImage(thumbImage,xPos,y + height / 2 - thumbImage.getHeight() / 2);\n    }\n else {\n      int yPos=y;\n      g.drawImage(thumbImage,getX() + width / 2 - thumbImage.getWidth() / 2,yPos);\n    }\n  }\n}\n", "docstring": "paint the progress indicator", "partition": "test"}
{"idx": "4659", "code": "public void addAction(EntityAction ea){\n  actions.addElement(ea);\n  processGameEvent(new GameNewActionEvent(this,ea));\n}\n", "docstring": "adds the specified action to the actions list for this phase .", "partition": "test"}
{"idx": "4660", "code": "public static JSONObject readJSONObject(final JSONArray jsonArray,final int index,final boolean required,final boolean notNull) throws JSONException {\n  if (required) {\n    return jsonArray.getJSONObject(index);\n  }\n  if (notNull && jsonArray.isNull(index)) {\n    throw new JSONException(String.format(Locale.US,NULL_VALUE_FORMAT_ARRAY,index));\n  }\n  JSONObject value=null;\n  if (!jsonArray.isNull(index)) {\n    value=jsonArray.getJSONObject(index);\n  }\n  return value;\n}\n", "docstring": "reads the json object value from the json array for specified index .", "partition": "test"}
{"idx": "4661", "code": "public static void waitElementToNotBePresent(SearchContext parent,By by,int waitInSeconds){\n  Preconditions.checkNotNull(parent);\n  Preconditions.checkNotNull(by);\n  try {\n    WebElementWait wait=new WebElementWait(parent,waitInSeconds);\n    wait.until(null);\n  }\n catch (  TimeoutException e) {\n    throw new TimeoutException(String.format(\"Element %s is still present after %s seconds\",by,waitInSeconds),e);\n  }\n}\n", "docstring": "will wait until no element identified by the by is present .", "partition": "test"}
{"idx": "4662", "code": "public final TestSubscriber assertTerminated(){\n  if (done.getCount() != 0) {\n    fail(\"\",\"Subscriber still running!\",errors);\n  }\n  long c=completions;\n  if (c > 1) {\n    fail(\"\",\"Terminated with multiple completions: \" + c,errors);\n  }\n  int s=errors.size();\n  if (s > 1) {\n    fail(\"\",\"Terminated with multiple errors: \" + s,errors);\n  }\n  if (c != 0 && s != 0) {\n    fail(\"\",\"Terminated with multiple completions and errors: \" + c,errors);\n  }\n  return this;\n}\n", "docstring": "assert that the testsubscriber terminated ( i . e . , the terminal latch reached zero ) .", "partition": "test"}
{"idx": "4663", "code": "public boolean isVimeoURLValid(){\n  String videoID=getExtractedIdentifier();\n  return videoID.length() > 0 && TextUtils.isDigitsOnly(videoID);\n}\n", "docstring": "check if a vimeo url has a valid identifier", "partition": "test"}
{"idx": "4664", "code": "private void updateDownloadedFiles(SQLiteDatabase db,String newAccountName,String oldAccountName){\n  String whereClause=ProviderTableMeta.FILE_ACCOUNT_OWNER + \"=? AND \" + ProviderTableMeta.FILE_STORAGE_PATH+ \" IS NOT NULL\";\n  Cursor c=db.query(ProviderTableMeta.FILE_TABLE_NAME,null,whereClause,new String[]{newAccountName},null,null,null);\n  try {\n    if (c.moveToFirst()) {\n      String oldAccountPath=FileStorageUtils.getSavePath(oldAccountName);\n      String newAccountPath=FileStorageUtils.getSavePath(newAccountName);\n      File oldAccountFolder=new File(oldAccountPath);\n      File newAccountFolder=new File(newAccountPath);\n      oldAccountFolder.renameTo(newAccountFolder);\n      do {\n        String oldPath=c.getString(c.getColumnIndex(ProviderTableMeta.FILE_STORAGE_PATH));\n        OCFile file=new OCFile(c.getString(c.getColumnIndex(ProviderTableMeta.FILE_PATH)));\n        String newPath=FileStorageUtils.getDefaultSavePathFor(newAccountName,file);\n        ContentValues cv=new ContentValues();\n        cv.put(ProviderTableMeta.FILE_STORAGE_PATH,newPath);\n        db.update(ProviderTableMeta.FILE_TABLE_NAME,cv,ProviderTableMeta.FILE_STORAGE_PATH + \"=?\",new String[]{oldPath});\n        Log_OC.v(\"SQL\",\"Updated path of downloaded file: old file name == \" + oldPath + \", new file name == \"+ newPath);\n      }\n while (c.moveToNext());\n    }\n  }\n  finally {\n    c.close();\n  }\n}\n", "docstring": "rename the local owncloud folder of one account to match the a rename of the account itself . updates the table of files in database so that the paths to the local files keep being the same .", "partition": "test"}
{"idx": "4665", "code": "public void dumpOptions(){\n  logger.info(\"\");\n  for (  Method getter : GetConfigurationInterface.class.getMethods()) {\n    String getterName=getter.getName();\n    try {\n      Object result=getter.invoke(ConfigurationManager.getCurrentProfile());\n      if (result instanceof Boolean) {\n        result=LocalizationHelper.getYesOrNo((Boolean)result);\n      }\n      if (result instanceof List) {\n        for (int i=0; i < ((List)result).size(); i++) {\n          assert ((List)result).get(i) instanceof CustomCatalogEntry;\n          CustomCatalogEntry c=((List<CustomCatalogEntry>)result).get(i);\n          String OptionName=Helper.pad(Localization.Main.getText(\"gui.tab6.label\") + \" [\" + (i + 1)+ \"], \"+ c.getAtTop().toString(),\' \',50) + \" : \";\n          logger.info(OptionName + c.getLabel() + \" (\"+ c.getValue().toString()+ \"), \"+ c.getAtTop().toString());\n        }\n      }\n else {\n        String optionName=getterName.substring(3);\n        dumpOption(optionName,result);\n      }\n    }\n catch (    IllegalAccessException e) {\n      logger.warn(\"\",e);\n    }\ncatch (    InvocationTargetException e) {\n      logger.warn(\"\",e);\n    }\n  }\n  logger.info(\"\");\n}\n", "docstring": "dump all the configuration options listed as get methods in the configuration interface .", "partition": "test"}
{"idx": "4666", "code": "private JsonNode parseLanguageResource(Resource resource) throws IOException {\n  InputStream stream=resource.asStream();\n  if (stream == null)   return null;\n  try {\n    JsonNode tree=mapper.readTree(stream);\n    return tree;\n  }\n  finally {\n    stream.close();\n  }\n}\n", "docstring": "parses the given language resource , returning the resulting jsonnode . if the resource cannot be read because it does not exist , null is returned .", "partition": "test"}
{"idx": "4667", "code": "public Collection<Tuple2<TransitionState,Double>> startStates(){\n  List<Tuple2<TransitionState,Double>> result=new ArrayList<Tuple2<TransitionState,Double>>();\n{\n    double score=Math.log(LINE_MRGN_PROB);\n    addNoSubGlyphStartState(result,new int[0],TransitionStateType.LMRGN,-1,score);\n  }\n  for (int destLanguage=0; destLanguage < numLanguages; ++destLanguage) {\n    SingleLanguageModel destLM=lm.get(destLanguage);\n    double destLanguagePrior=lm.languagePrior(destLanguage);\n    for (    int c : destLM.getActiveCharacters()) {\n      if (c != spaceCharIndex) {\n        double score=Math.log(1.0 - LINE_MRGN_PROB) + Math.log(getNgramProb(destLM,new int[0],c)) + Math.log(destLanguagePrior);\n        addGlyphStartStates(result,c,new int[]{c},TransitionStateType.TMPL,destLanguage,score);\n      }\n    }\n  }\n{\n    double totalSpaceProb=0.0;\n    for (int language=0; language < numLanguages; ++language)     totalSpaceProb+=getNgramProb(lm.get(language),new int[0],spaceCharIndex) * lm.languagePrior(language);\n    double score=Math.log(1.0 - LINE_MRGN_PROB) + Math.log(totalSpaceProb);\n    addNoSubGlyphStartState(result,new int[]{spaceCharIndex},TransitionStateType.TMPL,-1,score);\n  }\n  return result;\n}\n", "docstring": "make a collection of states that can be the start of a line . first possibility : l - margin , with no context . has probability line_mrgn_prob * prior prob of the language . ( 1 of this ) other possibilities : tmpl , with any individual single character c as context ( ~ 75 of these ) - probability is : 1 - line_mrgn_prob * probability of c with no context * prior prob of the language .", "partition": "test"}
{"idx": "4668", "code": "public boolean removeContainerAndCancelIfNecessary(ImageContainer container){\n  mContainers.remove(container);\n  if (mContainers.isEmpty()) {\n    mRequest.cancel();\n    return true;\n  }\n  return false;\n}\n", "docstring": "detatches the bitmap container from the request and cancels the request if no one is left listening .", "partition": "test"}
{"idx": "4669", "code": "public KernelDensityFunction(Collection<double[]> points){\n  this(points.toArray(new double[points.size()][]));\n}\n", "docstring": "creates a new kernel density function with the given points", "partition": "test"}
{"idx": "4670", "code": "private static Object cloneSerializableObject(Object o) throws IOException, ClassNotFoundException {\n  ByteArrayOutputStream b=new ByteArrayOutputStream();\n  ObjectOutputStream out=new ObjectOutputStream(b);\n  out.writeObject(o);\n  out.flush();\n  out.close();\n  ByteArrayInputStream bi=new ByteArrayInputStream(b.toByteArray());\n  ObjectInputStream in=new ObjectInputStream(bi);\n  return in.readObject();\n}\n", "docstring": "this methods provide cloning for serializable objects . mail attributes are serializable but not clonable so we need a deep copy", "partition": "test"}
{"idx": "4671", "code": "public ZipEntry(String name){\n  Objects.requireNonNull(name,\"name\");\n  if (name.length() > 0xFFFF) {\n    throw new IllegalArgumentException(\"entry name too long\");\n  }\n  this.name=name;\n}\n", "docstring": "creates a new zip entry with the specified name .", "partition": "test"}
{"idx": "4672", "code": "public void _testStatements() throws Exception {\n  Connection connection=getConnectionViaDriverManager();\n  connection.setAutoCommit(false);\n  try {\n    Statement stmt=connection.createStatement();\n    ResultSet rs=stmt.executeQuery(\"SELECT * FROM rdb$database\");\n    rs.close();\n    RandomSelector selector1=new RandomSelector(stmt,SELECT_TABLE_1,RECORD_COUNT);\n    RandomSelector selector2=new RandomSelector(stmt,SELECT_TABLE_2,RECORD_COUNT);\n    Thread thread1=new Thread(selector1,\"Selector 1\");\n    Thread thread2=new Thread(selector2,\"Selector 2\");\n    thread1.start();\n    thread2.start();\n    Thread.sleep(TEST_TIME_SECONDS * 1000);\n    selector1.stop();\n    selector2.stop();\n    thread1.join();\n    thread2.join();\n    stmt.close();\n  }\n  finally {\n    connection.close();\n  }\n}\n", "docstring": "test if single statement can be safely used in multiple transactions . the only visible outcome of this test case are messages in stderr that result set was closed . any other error message means test case failure .", "partition": "test"}
{"idx": "4673", "code": "void readDictionary(String filename,String suffix,InputStream res) throws IOException {\n  DictionaryNames nms=new DictionaryNames(filename,suffix);\n  BufferedReader in=new BufferedReader(new InputStreamReader(res));\n  String line;\n  while ((line=in.readLine()) != null) {\n    String[] terms=splitter.split(line);\n    if (terms.length > maxPhraseLength)     continue;\n    if (terms.length == 0)     continue;\n    GazEntry ge=gaz.get(terms[0]);\n    if (ge == null) {\n      gaz.put(terms[0],new GazEntry(terms,1,nms));\n    }\n else {\n      ge.addChild(terms,1,nms);\n    }\n  }\n  in.close();\n}\n", "docstring": "read the given dictionary file from the input stream .", "partition": "test"}
{"idx": "4674", "code": "private T matchTokens(String targetToken,String requestToken){\n  int wildcardIndex=0;\n  if (targetToken == null && requestToken == null) {\n    return exactMatch;\n  }\n  if (targetToken == null || requestToken == null) {\n    return noMatch;\n  }\n  int beginTargetIndex=0;\n  int beginRequestIndex=0;\n  String substr=null;\n  int targetTokenLength=targetToken.length();\n  int requestTokenLength=requestToken.length();\n  if (targetToken.indexOf(oneLevelWildcard,beginTargetIndex) != -1) {\n    while ((wildcardIndex=targetToken.indexOf(oneLevelWildcard,beginTargetIndex)) != -1) {\n      if (wildcardIndex > beginTargetIndex) {\n        substr=targetToken.substring(beginTargetIndex,wildcardIndex);\n        if ((beginRequestIndex=requestToken.indexOf(substr,beginRequestIndex)) == -1) {\n          return noMatch;\n        }\n        beginTargetIndex=beginTargetIndex + substr.length() + oneLevelWildcardLength;\n        beginRequestIndex=beginRequestIndex + substr.length();\n      }\n else {\n        if (wildcardIndex == beginTargetIndex) {\n          if (targetTokenLength == oneLevelWildcardLength) {\n            return wildcardMatch;\n          }\n else {\n            beginTargetIndex=beginTargetIndex + oneLevelWildcardLength;\n            continue;\n          }\n        }\n      }\n    }\n    if (beginTargetIndex >= targetTokenLength) {\n      return wildcardMatch;\n    }\n    String targetStr=targetToken.substring(beginTargetIndex,targetTokenLength);\n    String remRequest=requestToken.substring(beginRequestIndex,requestTokenLength);\n    int remRequestIndex=-1;\n    if ((remRequestIndex=remRequest.lastIndexOf(targetStr,remRequest.length() - 1)) == -1) {\n      return noMatch;\n    }\n else {\n      beginRequestIndex=beginRequestIndex + remRequestIndex;\n      if (beginRequestIndex + targetStr.length() >= requestTokenLength) {\n        return wildcardMatch;\n      }\n else {\n        return noMatch;\n      }\n    }\n  }\n else {\n    if (targetToken.equals(requestToken)) {\n      return exactMatch;\n    }\n  }\n  return noMatch;\n}\n", "docstring": "matches individual request and target tokens . this method is used to compare tokens in one level wild card compare to compare tokens between delimiter boundaries .", "partition": "test"}
{"idx": "4675", "code": "public void addVertex(ValueGraphVertex v){\n  if (vertices.add(v)) {\n    if (v.representsParameter()) {\n      nParameter++;\n    }\n    if (representativeV == null) {\n      representativeV=v;\n    }\n  }\n}\n", "docstring": "add a vertex to this congruence class .", "partition": "test"}
{"idx": "4676", "code": "public Set<String> files(){\n  if (setFiles == null) {\n    throw new IllegalStateException(\"files were not computed yet\");\n  }\n  return Collections.unmodifiableSet(setFiles);\n}\n", "docstring": "return all files referenced by this segmentinfo .", "partition": "test"}
{"idx": "4677", "code": "public static boolean isMac(){\n  String osName=System.getProperty(\"os.name\");\n  osName=osName.toLowerCase();\n  return osName.indexOf(\"mac\") != -1;\n}\n", "docstring": "do we run on apple", "partition": "test"}
{"idx": "4678", "code": "private boolean isAssignableFrom(Throwable concreteThrowable,Set<Class<? extends Throwable>> throwableClasses){\n  for (  Class<? extends Throwable> t : throwableClasses) {\n    if (t.isAssignableFrom(concreteThrowable.getClass())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "tests if concretethrowable . getclass is assignable to any of the classes in throwableclasses", "partition": "test"}
{"idx": "4679", "code": "protected void print(int v) throws IOException {\n  print(String.valueOf(v));\n}\n", "docstring": "prints an integer to the stream .", "partition": "test"}
{"idx": "4680", "code": "public Object2DoubleOpenHashMap<IntRBTreeSet> confidenceMap(){\n  List<ItemSet> itemSets=learn();\n  Object2DoubleOpenHashMap<IntRBTreeSet> confidenceMap=new Object2DoubleOpenHashMap<>(itemSets.size());\n  for (  ItemSet itemSet : itemSets) {\n    IntRBTreeSet itemSetCopy=new IntRBTreeSet(itemSet.items);\n    confidenceMap.put(itemSetCopy,itemSet.support / (double)setCount);\n  }\n  return confidenceMap;\n}\n", "docstring": "returns a map of associations and their confidence , where confidence is support for the itemset ( that is , the number of times it appears in the input data ) divided by the total number of sets ( i . e . , the percentage of input sets where it appears .", "partition": "test"}
{"idx": "4681", "code": "public static boolean isAllAlpha(String str){\n  if (str == null)   return false;\n  for (int i=str.length() - 1; i >= 0; i--) {\n    if (!Character.isLetter(str.charAt(i)))     return false;\n  }\n  return true;\n}\n", "docstring": "returns true if all characters in the string are letters", "partition": "test"}
{"idx": "4682", "code": "private void extract(int minsupp,int minlength,int maxlength,int item,int[] postfix,int plen,int[] buf2,int[] buf3,boolean destruct,Collector col){\n  if (header[item] == null) {\n    return;\n  }\n  if (header[item].sibling == null) {\n    if (header[item].count < minsupp) {\n      return;\n    }\n    extractLinear(header[item].count,minsupp,minlength,maxlength,item,postfix,plen,buf2,col);\n    if (destruct) {\n      Arrays.fill(header,null);\n    }\n    return;\n  }\n  int support=0;\n  for (FPNode cur=header[item]; cur != null; cur=cur.sibling) {\n    support+=cur.count;\n  }\n  if (support < minsupp) {\n    return;\n  }\n  Arrays.fill(buf3,0);\n  for (FPNode cur=header[item]; cur != null; cur=cur.sibling) {\n    for (FPNode parent=cur.parent; parent.key >= 0; parent=parent.parent) {\n      buf3[parent.key]+=cur.count;\n    }\n  }\n  final int mminlength=minlength - (plen + 1);\n  if (mminlength > 0) {\n    int fparents=0;\n    for (int i=0; i < item; i++) {\n      if (buf3[i] >= minsupp) {\n        fparents+=1;\n      }\n    }\n    if (fparents < mminlength) {\n      return;\n    }\n  }\n  final int last=item - 1;\n  FPTree proj=new FPTree(item);\n  for (FPNode cur=header[item]; cur != null; cur=cur.sibling) {\n    int j=buf2.length;\n    for (FPNode parent=cur.parent; parent.key >= 0; parent=parent.parent) {\n      if (buf3[parent.key] >= minsupp) {\n        buf2[--j]=parent.key;\n      }\n    }\n    if (buf2.length - j >= mminlength) {\n      proj.insert(proj,buf2,j,buf2.length,cur.count);\n    }\n  }\n  proj.reduceMemory();\n  postfix[plen++]=item;\n  if (plen >= minlength && plen <= maxlength) {\n    col.collect(support,postfix,0,plen);\n  }\n  for (int j=last; j >= 0; j--) {\n    proj.extract(minsupp,minlength,maxlength,j,postfix,plen,buf2,buf3,destruct,col);\n  }\n  if (destruct) {\n    header[item]=null;\n  }\n}\n", "docstring": "extract itemsets ending in the given item .", "partition": "test"}
{"idx": "4683", "code": "protected static int toDigit(char ch,int index) throws DSSException {\n  int digit=Character.digit(ch,16);\n  if (digit == -1) {\n    throw new DSSException(\"Illegal hexadecimal character \" + ch + \" at index \"+ index);\n  }\n  return digit;\n}\n", "docstring": "converts a hexadecimal character to an integer .", "partition": "test"}
{"idx": "4684", "code": "static void loadLibraryWithPath(String libName,ClassLoader loader,String libraryPath){\n  throw new Error(\"TODO - no reference DRLVM code\");\n}\n", "docstring": "this method must be provided by the vm vendor , as it is called by java . lang . system . load ( ) . system . load ( ) cannot call runtime . load ( ) because the library is loaded using the classloader of the calling method . loads and links the library specified by the argument . no security check is done .", "partition": "test"}
{"idx": "4685", "code": "public Enumeration listOptions(){\n  Vector newVector=new Vector();\n  newVector.addElement(new Option(\"\\tSpecify list of columns to use as MEKA class attributes. \'first\' and \'last\' are valid\\n\" + \"\\tindexes. (default: last)\",\"R\",1,\"-R <index1,index2-index4,...>\"));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "4686", "code": "public void save(File keyStore,String type,char[] password,char[] keyPassword,String caAlias) throws GeneralSecurityException, IOException {\n  KeyStore store=KeyStore.getInstance(type);\n  store.load(null,password);\n  store.setKeyEntry(caAlias,caKey,keyPassword,caCerts);\n  OutputStream out=new FileOutputStream(keyStore);\n  try {\n    store.store(out,password);\n  }\n catch (  IOException ioe) {\n    ioe.printStackTrace();\n  }\n finally {\n    out.close();\n  }\n}\n", "docstring": "saves the ca key and the certificate chain to the specified keystore", "partition": "test"}
{"idx": "4687", "code": "public OrQueryBuilder add(QueryBuilder filterBuilder){\n  filters.add(filterBuilder);\n  return this;\n}\n", "docstring": "adds a filter to the list of filters to \" or \" .", "partition": "test"}
{"idx": "4688", "code": "void update(long timeNanos,int rows){\n  count++;\n  executionTimeMinNanos=Math.min(timeNanos,executionTimeMinNanos);\n  executionTimeMaxNanos=Math.max(timeNanos,executionTimeMaxNanos);\n  rowCountMin=Math.min(rows,rowCountMin);\n  rowCountMax=Math.max(rows,rowCountMax);\n  double rowDelta=rows - rowCountMean;\n  rowCountMean+=rowDelta / count;\n  rowCountM2+=rowDelta * (rows - rowCountMean);\n  double timeDelta=timeNanos - executionTimeMeanNanos;\n  executionTimeMeanNanos+=timeDelta / count;\n  executionTimeM2Nanos+=timeDelta * (timeNanos - executionTimeMeanNanos);\n  executionTimeCumulativeNanos+=timeNanos;\n  rowCountCumulative+=rows;\n  lastUpdateTime=System.currentTimeMillis();\n}\n", "docstring": "update the statistics entry .", "partition": "test"}
{"idx": "4689", "code": "public void test_ctor_2() throws SailException {\n  final File file=new File(getName() + Options.JNL);\n  if (file.exists()) {\n    if (!file.delete()) {\n      fail(\"Could not delete file before test: \" + file);\n    }\n  }\n  final Properties properties=new Properties();\n  properties.setProperty(Options.FILE,file.toString());\n  final BigdataSail sail=new BigdataSail(properties);\n  try {\n    sail.initialize();\n    sail.shutDown();\n  }\n  finally {\n    if (!file.exists()) {\n      fail(\"Could not locate store: \" + file);\n      if (!file.delete()) {\n        fail(\"Could not delete file after test: \" + file);\n      }\n    }\n  }\n}\n", "docstring": "test create and shutdown of a named store .", "partition": "test"}
{"idx": "4690", "code": "@Override public String toString(){\n  String result;\n  result=null;\n  if (isObject()) {\n    if (isRoot()) {\n      result=\"JSON\";\n    }\n else     if (m_Name == null) {\n      result=\"<object>\";\n    }\n else {\n      result=escape(m_Name) + \" (Object)\";\n    }\n  }\n else   if (isArray()) {\n    if (m_Name == null) {\n      result=\"<array>\";\n    }\n else {\n      result=escape(m_Name) + \" (Array)\";\n    }\n  }\n else {\n    if (m_Name != null) {\n      result=escape(m_Name) + \": \" + escape(m_Value);\n    }\n else {\n      result=\"\" + m_Value;\n    }\n  }\n  return result;\n}\n", "docstring": "returns a string representation of the node .", "partition": "test"}
{"idx": "4691", "code": "public final boolean split_traces_keep_point(){\n  if (keep_point == null)   return false;\n  ItemSelectionFilter filter=new ItemSelectionFilter(ItemSelectionChoice.TRACES);\n  Collection<BrdItem> picked_items=r_board.pick_items(keep_point.keep_point,keep_point.on_layer,filter);\n  for (  BrdItem curr_item : picked_items) {\n    BrdTracep a_trace=(BrdTracep)curr_item;\n    int line_idx=a_trace.polyline_find_line_idx(keep_point.keep_point);\n    if (line_idx < 1)     continue;\n    ArrayList<BrdTracep> clean_list=a_trace.split_with_end_point(line_idx,keep_point.keep_point);\n    return clean_list.size() > 0;\n  }\n  return false;\n}\n", "docstring": "splits the traces containing this . keep_point if this . keep_point ! = null this actually splits the trace since lower down pieces are inserted in the board , if successful", "partition": "test"}
{"idx": "4692", "code": "public static byte[] flipAllBitsInPlace(byte[] bytes,int index,int length){\n  int endIndex=Math.min(bytes.length,index + length);\n  for (int i=index; i < endIndex; i++) {\n    bytes[i]=(byte)(bytes[i] ^ 0xff);\n  }\n  return bytes;\n}\n", "docstring": "this flips the bits in the range [ index , index + length ) and returns the same byte [ ", "partition": "test"}
{"idx": "4693", "code": "public CreateIndexRequest source(String source){\n  return source(source.getBytes(Charsets.UTF_8));\n}\n", "docstring": "sets the settings and mappings as a single source .", "partition": "test"}
{"idx": "4694", "code": "private void addUsers(User[] users,LocalConfiguration configuration){\n  for (  User user : users) {\n    configuration.addUser(user.createUser());\n  }\n}\n", "docstring": "add users to the configuration .", "partition": "test"}
{"idx": "4695", "code": "void tryToDrainBuffers(){\n  if (evictionLock.tryLock()) {\n    try {\n      drainStatus.lazySet(PROCESSING);\n      drainBuffers();\n    }\n  finally {\n      drainStatus.compareAndSet(PROCESSING,IDLE);\n      evictionLock.unlock();\n    }\n  }\n}\n", "docstring": "attempts to acquire the eviction lock and apply the pending operations , up to the amortized threshold , to the page replacement policy .", "partition": "test"}
{"idx": "4696", "code": "public static boolean copyFile(File source,File dest){\n  File parentDest=dest.getParentFile();\n  if (!parentDest.exists()) {\n    if (!createDirectory(parentDest.getAbsolutePath())) {\n      return false;\n    }\n  }\n  try {\n    Files.copy(source.toPath(),dest.toPath());\n    return true;\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    return false;\n  }\n}\n", "docstring": "copy source file to destination file . create directory if destination directory does not exist", "partition": "test"}
{"idx": "4697", "code": "public static String propertiesEncode(Properties pp){\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\n  try {\n    pp.store(bos,\"adempiere\");\n  }\n catch (  IOException e) {\n    log.log(Level.SEVERE,\"store\",e);\n  }\n  String result=new String(bos.toByteArray());\n  try {\n    result=URLEncoder.encode(result,MobileEnv.ENCODING);\n  }\n catch (  UnsupportedEncodingException e) {\n    log.log(Level.SEVERE,\"encode\" + MobileEnv.ENCODING,e);\n    String enc=System.getProperty(\"file.encoding\");\n    try {\n      result=URLEncoder.encode(result,enc);\n      log.info(\"encode: \" + enc);\n    }\n catch (    Exception ex) {\n      log.log(Level.SEVERE,\"encode\",ex);\n    }\n  }\n  return result;\n}\n", "docstring": "decode properties into string ( url encoded )", "partition": "test"}
{"idx": "4698", "code": "@Override public void generateRss(XmlWriter w,ExtensionProfile extProfile) throws IOException {\n  ArrayList<XmlWriter.Attribute> attrs=new ArrayList<XmlWriter.Attribute>(3);\n  if (mimeType != null) {\n    attrs.add(new XmlWriter.Attribute(\"type\",mimeType.getMediaType()));\n  }\n  if (uri != null) {\n    attrs.add(new XmlWriter.Attribute(\"url\",uri));\n  }\n  if (length != -1) {\n    attrs.add(new XmlWriter.Attribute(\"length\",Long.toString(length)));\n  }\n  w.simpleElement(Namespaces.rssNs,\"enclosure\",attrs,null);\n}\n", "docstring": "generates xml in the rss format .", "partition": "test"}
{"idx": "4699", "code": "public void testSortsElementsByName() throws Exception {\n  XppDom dom1=XppFactory.buildDom(\"<dom><a/></dom>\");\n  XppDom dom2=XppFactory.buildDom(\"<dom><b/></dom>\");\n  assertEquals(-1,comparator.compare(dom1,dom2));\n  assertEquals(\"/dom/a[0]?\",xpath.get());\n  assertEquals(1,comparator.compare(dom2,dom1));\n  assertEquals(\"/dom/b[0]?\",xpath.get());\n}\n", "docstring": "tests comparison of different elements .", "partition": "test"}
{"idx": "4700", "code": "public static boolean deleteDirectory(final File path){\n  if (path.exists()) {\n    File[] files=path.listFiles();\n    for (    File file : files) {\n      if (file.isDirectory()) {\n        deleteDirectory(file);\n      }\n else {\n        file.delete();\n      }\n    }\n  }\n  return path.delete();\n}\n", "docstring": "deletes directory with files .", "partition": "test"}
{"idx": "4701", "code": "public void morph(Component source,Component destination,int duration,Runnable onCompletion){\n  morph(source,destination,duration,false,onCompletion);\n}\n", "docstring": "morph is similar to the replace functionality where a component might be replaced with a component that isn \"'\" t within the container . however , unlike the replace functionality which uses a transition and assumes the position of the component ( and is hence quite flexible ) morph can move and resize the component . e . g . after entering text into a text field and pressing submit it can \" morph \" into a chat bubble located in a different part of the screen . < br > it is the responsibility of the caller to remove the source component ( if desired ) and revalidate the container when the animation completes .", "partition": "test"}
{"idx": "4702", "code": "private boolean startsNewHunk(String string){\n  if (string.length() == 0)   return true;\n  return isLegalChar(string.charAt(0));\n}\n", "docstring": "true if the string is the beginning of a new camel case hunk . false if it is not .", "partition": "test"}
{"idx": "4703", "code": "public void clearValues(){\n  valueMap.clear();\n}\n", "docstring": "removes all placeholder - value mappings .", "partition": "test"}
{"idx": "4704", "code": "private HashMap<String,byte[]> readChars(byte[] d){\n  HashMap<String,byte[]> hm=new HashMap<String,byte[]>();\n  int i=findSlashName(d,\"CharStrings\");\n  if (i < 0) {\n    return hm;\n  }\n  PSParser psp=new PSParser(d,i);\n  while (true) {\n    String s=psp.readThing();\n    char c=s.charAt(0);\n    if (c == \'/\') {\n      int len=Integer.parseInt(psp.readThing());\n      String go=psp.readThing();\n      if (go.equals(\"-|\") || go.equals(\"RD\")) {\n        psp.setLoc(psp.getLoc() + 1);\n        byte[] line=psp.getNEncodedBytes(len,password,lenIV);\n        hm.put(s.substring(1),line);\n      }\n    }\n else     if (s.equals(\"end\")) {\n      break;\n    }\n  }\n  return hm;\n}\n", "docstring": "get the character definitions of the font .", "partition": "test"}
{"idx": "4705", "code": "public void playFileForUser(String fileName,String userName) throws SoundPlaybackException {\n  if (userName == null || userName.isEmpty()) {\n    userName=appProperties.getProperty(\"username_to_join_channel\");\n  }\n  try {\n    Guild guild=getUsersGuild(userName);\n    joinUsersCurrentChannel(userName);\n    playFile(fileName,guild);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "joins the channel of the user provided and then plays a file .", "partition": "test"}
{"idx": "4706", "code": "@Deprecated public static void runFinalizersOnExit(boolean run){\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkExit(0);\n  }\nsynchronized (hooksList) {\n    finalizeOnExit=run;\n  }\n}\n", "docstring": "ensure that , when the virtual machine is about to exit , all objects are finalized . note that all finalization which occurs when the system is exiting is performed after all running threads have been terminated .", "partition": "test"}
{"idx": "4707", "code": "public double[][] predictIntervals(double conf){\n  updateMeanAndVariance();\n  double val=Statistics.normalInverse(1.0 - (1.0 - conf) / 2.0);\n  double[][] arr=new double[1][2];\n  arr[0][1]=m_Mean + val * Math.sqrt(m_Variance);\n  arr[0][0]=m_Mean - val * Math.sqrt(m_Variance);\n  return arr;\n}\n", "docstring": "returns the interval for the given confidence value .", "partition": "test"}
{"idx": "4708", "code": "public static boolean checkSHA(final String shaHash,final File file){\n  if (TextUtils.isEmpty(shaHash) || file == null || !FileUtils.isReadable(file)) {\n    Log.e(\"Given String is NULL or File is NULL or File is not readable\");\n    return false;\n  }\n  final String hash=getSHA(file);\n  if (hash == null) {\n    Log.e(\"calculated hash is NULL\");\n    return false;\n  }\n  return hash.equalsIgnoreCase(shaHash);\n}\n", "docstring": "checks if given hash is the same for given file - helps to detect file changes", "partition": "test"}
{"idx": "4709", "code": "public void addValueKeyName(String key){\n  valueKeyNames.add(key);\n}\n", "docstring": "add the key that should be treated as one of the value fields . the key must be in the input map", "partition": "test"}
{"idx": "4710", "code": "public Assignment update(Border border){\n  Arrays.sort(cs);\n  int j=1;\n  boolean found=(cs[0].core == border.core);\n  for (int i=1; i < cs.length; i++) {\n    if (cs[i].core != cs[i - 1].core) {\n      cs[j++]=cs[i];\n    }\n    found|=(cs[i].core == border.core);\n  }\n  if (found) {\n    if (j == 1) {\n      Border r=cs[0];\n      cs=null;\n      return r;\n    }\n    if (j < cs.length) {\n      cs=Arrays.copyOf(cs,j);\n    }\n    return this;\n  }\n  if (j + 1 != cs.length) {\n    cs=Arrays.copyOf(cs,j + 1);\n  }\n  cs[j]=border;\n  return this;\n}\n", "docstring": "add a new border to the existing borders .", "partition": "test"}
{"idx": "4711", "code": "public static String fromChar(int value){\n  if (value > 0xffff)   return null;\n  String name;\n  initialize();\n  name=(String)_byChar.get(new Integer(value));\n  return name;\n}\n", "docstring": "returns the name of an html character reference based on its character value . only valid for entities defined from character references . if no such character value was defined , return null .", "partition": "test"}
{"idx": "4712", "code": "public static List<String> splitLines(final String content){\n  if (content == null || content.length() == 0)   return Collections.emptyList();\n  String[] lines=content.split(\"[\\\\r]?\\\\n\");\n  return Arrays.asList(lines);\n}\n", "docstring": "split the supplied content into lines , returning each line as an element in the returned list .", "partition": "test"}
{"idx": "4713", "code": "@Override public void draw(Graphics2D g2,Rectangle2D area,Point2D anchor,PlotState state,PlotRenderingInfo info){\n  boolean b1=(area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n  boolean b2=(area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n  if (b1 || b2) {\n    return;\n  }\n  if (info != null) {\n    info.setPlotArea(area);\n  }\n  RectangleInsets insets=getInsets();\n  insets.trim(area);\n  drawChipGrid(g2,area);\n  drawWaferEdge(g2,area);\n}\n", "docstring": "draws the wafermap view .", "partition": "test"}
{"idx": "4714", "code": "public void addHole(EdgeRing holeER){\n  holeER.setShell(this);\n  LinearRing hole=holeER.getRing();\n  if (holes == null)   holes=new ArrayList();\n  holes.add(hole);\n}\n", "docstring": "adds a hole to the polygon formed by this ring .", "partition": "test"}
{"idx": "4715", "code": "private static void registerComponents(){\n  registerComponent(BarChartComponent.class,BarChartGui.class);\n  registerComponent(DocViewerComponent.class,DocViewerDesktopComponent.class);\n  registerComponent(ConsoleComponent.class,ConsoleDesktopComponent.class);\n  registerComponent(DisplayComponent.class,DisplayComponentDesktopGui.class);\n  registerComponent(DataWorldComponent.class,DataWorldDesktopComponent.class);\n  registerComponent(HistogramComponent.class,HistogramGui.class);\n  registerComponent(NetworkComponent.class,NetworkDesktopComponent.class);\n  registerComponent(OdorWorldComponent.class,OdorWorldDesktopComponent.class);\n  registerComponent(PieChartComponent.class,PieChartGui.class);\n  registerComponent(ProjectionComponent.class,ProjectionGui.class);\n  registerComponent(ReaderComponent.class,ReaderComponentDesktopGui.class);\n  registerComponent(ScatterPlotComponent.class,ScatterPlotGui.class);\n  registerComponent(TimeSeriesPlotComponent.class,TimeSeriesPlotGui.class);\n  registerComponent(RasterPlotComponent.class,RasterPlotGui.class);\n  registerComponent(VisionWorldComponent.class,VisionWorldDesktopComponent.class);\n  registerComponent(GameComponent.class,GameDesktopComponent.class);\n  registerComponent(DeviceInteractionComponent.class,DeviceInteractionDesktopComponent.class);\n}\n", "docstring": "create mappings from guicomponents to their gui wrappers .", "partition": "test"}
{"idx": "4716", "code": "private long skipInputBytes(long n) throws IOException {\n  cbLock.lock();\n  try {\n    return iis.skipBytes(n);\n  }\n  finally {\n    cbLock.unlock();\n  }\n}\n", "docstring": "this method is called from the native code in order to skip requested number of bytes in the input stream .", "partition": "test"}
{"idx": "4717", "code": "public byte[] generate64BitHashId() throws CryptoException {\n  try {\n    DERBitString publicKeyBitString=encodePublicKeyAsBitString(publicKey);\n    byte[] hash=DigestUtil.getMessageDigest(publicKeyBitString.getBytes(),DigestType.SHA1);\n    byte[] subHash=Arrays.copyOfRange(hash,12,20);\n    subHash[0]&=0x0F;\n    subHash[0]|=0x40;\n    return subHash;\n  }\n catch (  IOException ex) {\n    throw new CryptoException(res.getString(\"NoGenerateKeyIdentifier.exception.message\"),ex);\n  }\n}\n", "docstring": "generate 64 bit hash key identifier .", "partition": "test"}
{"idx": "4718", "code": "public static <C extends ConfigurationClient,S extends Configuration>CreateSubCommandHandler<C,S> create(SubCommandArgumentParser parser,ManagedObjectPath<?,?> p,OptionalRelationDefinition<C,S> r) throws ArgumentException {\n  return new CreateSubCommandHandler<>(parser,p,r,null,p.child(r));\n}\n", "docstring": "creates a new create - xxx sub - command for an optional relation .", "partition": "test"}
{"idx": "4719", "code": "public DSubjectInformationAccess(JDialog parent,byte[] value) throws IOException {\n  super(parent);\n  setTitle(res.getString(\"DSubjectInformationAccess.Title\"));\n  initComponents();\n  prepopulateWithValue(value);\n}\n", "docstring": "creates a new dsubjectinformationaccess dialog .", "partition": "test"}
{"idx": "4720", "code": "private Figure readLineElement(IXMLElement elem) throws IOException {\n  HashMap<AttributeKey,Object> a=new HashMap<AttributeKey,Object>();\n  readCoreAttributes(elem,a);\n  readTransformAttribute(elem,a);\n  readOpacityAttribute(elem,a);\n  readLineAttributes(elem,a);\n  if (FILL_COLOR.get(a) != null && STROKE_COLOR.get(a) == null) {\n    STROKE_COLOR.put(a,FILL_COLOR.get(a));\n  }\n  if (FILL_GRADIENT.get(a) != null && STROKE_GRADIENT.get(a) == null) {\n    STROKE_GRADIENT.put(a,FILL_GRADIENT.get(a));\n  }\n  FILL_COLOR.put(a,null);\n  FILL_GRADIENT.put(a,null);\n  double x1=toNumber(elem,readAttribute(elem,\"x1\",\"0\"));\n  double y1=toNumber(elem,readAttribute(elem,\"y1\",\"0\"));\n  double x2=toNumber(elem,readAttribute(elem,\"x2\",\"0\"));\n  double y2=toNumber(elem,readAttribute(elem,\"y2\",\"0\"));\n  Figure figure=factory.createLine(x1,y1,x2,y2,a);\n  elementObjects.put(elem,figure);\n  return figure;\n}\n", "docstring": "reads an svg \" line \" element .", "partition": "test"}
{"idx": "4721", "code": "public boolean isSetCallType(){\n  return __isset_bit_vector.get(__CALLTYPE_ISSET_ID);\n}\n", "docstring": "returns true if field calltype is set ( has been assigned a value ) and false otherwise", "partition": "test"}
{"idx": "4722", "code": "private IBuffer mapSource(SourceMapper mapper,IBinaryType info,IClassFile bufferOwner){\n  char[] contents=mapper.findSource(getType(),info);\n  if (contents != null) {\n    IBuffer buffer=BufferManager.createBuffer(bufferOwner);\n    if (buffer == null)     return null;\n    BufferManager bufManager=getBufferManager();\n    bufManager.addBuffer(buffer);\n    if (buffer.getCharacters() == null) {\n      buffer.setContents(contents);\n    }\n    buffer.addBufferChangedListener(this);\n    mapper.mapSource(getOuterMostEnclosingType(),contents,info);\n    return buffer;\n  }\n else {\n    IBuffer buffer=BufferManager.createNullBuffer(bufferOwner);\n    if (buffer == null)     return null;\n    BufferManager bufManager=getBufferManager();\n    bufManager.addBuffer(buffer);\n    buffer.addBufferChangedListener(this);\n    return buffer;\n  }\n}\n", "docstring": "loads the buffer via sourcemapper , and maps it in sourcemapper", "partition": "test"}
{"idx": "4723", "code": "public JFileDataStoreChooser(Shell parent,int style,final List<String> extensions){\n  this(parent,style,associations(extensions));\n}\n", "docstring": "create a dialog that filters for files with the specified extensions .", "partition": "test"}
{"idx": "4724", "code": "private void computeStaticLoadMetrics(AccessProfile accessProfile) throws BaseCollectionException {\n  URI storageSystemId=accessProfile.getSystemId();\n  StorageSystem storageSystem=null;\n  try {\n    storageSystem=_dbClient.queryObject(StorageSystem.class,storageSystemId);\n    _logger.info(\"started computeStaticLoadMetrics for storagesystem: {}\",storageSystem.getLabel());\n    VNXeApiClient client=getVnxUnityClient(accessProfile);\n    List<VNXeNasServer> nasServers=client.getNasServers();\n    for (    VNXeNasServer nasServer : nasServers) {\n      if ((nasServer.getMode() == VNXeNasServer.NasServerModeEnum.DESTINATION) || nasServer.getIsReplicationDestination()) {\n        _logger.debug(\"Found a replication destination NasServer\");\n        continue;\n      }\n      if (nasServer.getIsSystem()) {\n        continue;\n      }\n      VirtualNAS virtualNAS=findvNasByNativeId(storageSystem,nasServer.getId());\n      if (virtualNAS != null) {\n        _logger.info(\"Process db metrics for nas server : {}\",nasServer.getName());\n        StringMap dbMetrics=virtualNAS.getMetrics();\n        if (dbMetrics == null) {\n          dbMetrics=new StringMap();\n        }\n        StringMap tmpDbMetrics=populateDbMetrics(nasServer,client);\n        dbMetrics.putAll(tmpDbMetrics);\n        virtualNAS.setMetrics(dbMetrics);\n        _dbClient.updateObject(virtualNAS);\n      }\n    }\n  }\n catch (  Exception e) {\n    _logger.error(\"CollectStatisticsInformation failed. Storage system: {}\",storageSystemId,e);\n  }\n}\n", "docstring": "compute static load metrics .", "partition": "test"}
{"idx": "4725", "code": "public final short readShort() throws java.io.IOException {\n  readFully(scratch,0,2);\n  return (short)((scratch[0] << 8) | (scratch[1] & 0xff));\n}\n", "docstring": "see the general contract of the readshort method of datainput . bytes for this operation are read from the contained input stream .", "partition": "test"}
{"idx": "4726", "code": "public ReplicationJob createJobForCopyPartition(long auditLogId,long auditLogEntryCreateTime,HiveObjectSpec spec) throws StateUpdateException {\n  Map<String,String> extras=new HashMap<>();\n  extras.put(PersistedJobInfo.AUDIT_LOG_ID_EXTRAS_KEY,Long.toString(auditLogId));\n  extras.put(PersistedJobInfo.AUDIT_LOG_ENTRY_CREATE_TIME_KEY,Long.toString(auditLogEntryCreateTime));\n  List<String> partitionNames=new ArrayList<>();\n  partitionNames.add(spec.getPartitionName());\n  ReplicationOperation replicationOperation=ReplicationOperation.COPY_PARTITION;\n  PersistedJobInfo persistedJobInfo=jobInfoStore.resilientCreate(replicationOperation,ReplicationStatus.PENDING,Optional.empty(),srcCluster.getName(),spec,partitionNames,Optional.empty(),Optional.empty(),Optional.empty(),extras);\n  ReplicationTask replicationTask=new CopyPartitionTask(conf,destinationObjectFactory,objectConflictHandler,srcCluster,destCluster,spec,Optional.<Path>empty(),Optional.<Path>empty(),directoryCopier,true);\n  return new ReplicationJob(conf,replicationTask,onStateChangeHandler,persistedJobInfo);\n}\n", "docstring": "create a replication job to copy a partition .", "partition": "test"}
{"idx": "4727", "code": "public static void main(String... args) throws Exception {\n  String[] pages={\"quickstart.html\",\"installation.html\",\"tutorial.html\",\"features.html\",\"performance.html\",\"advanced.html\",\"grammar.html\",\"functions.html\",\"datatypes.html\",\"build.html\",\"history.html\",\"faq.html\"};\n  StringBuilder buff=new StringBuilder();\n  for (  String fileName : pages) {\n    String text=getContent(fileName);\n    for (    String page : pages) {\n      text=StringUtils.replaceAll(text,page + \"#\",\"#\");\n    }\n    text=disableRailroads(text);\n    text=removeHeaderFooter(fileName,text);\n    buff.append(text);\n  }\n  String finalText=buff.toString();\n  File output=new File(BASE_DIR,\"onePage.html\");\n  PrintWriter writer=new PrintWriter(new FileWriter(output));\n  writer.println(\"<html><head><meta http-equiv=\\\"Content-Type\\\" \" + \"content=\\\"text/html;charset=utf-8\\\" /><title>\");\n  writer.println(\"H2 Documentation\");\n  writer.println(\"</title><link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \" + \"href=\\\"stylesheetPdf.css\\\" /></head><body>\");\n  writer.println(\"<h1>H2 Database Engine</h1>\");\n  writer.println(\"<p>Version \" + Constants.getFullVersion() + \"</p>\");\n  writer.println(finalText);\n  writer.println(\"</body></html>\");\n  writer.close();\n}\n", "docstring": "this method is called when executing this application from the command line .", "partition": "test"}
{"idx": "4728", "code": "public static Map<String,Object> findOrders(DispatchContext dctx,Map<String,? extends Object> context){\n  return findOrders(dctx,context,false);\n}\n", "docstring": "scipio : stock findorders service .", "partition": "test"}
{"idx": "4729", "code": "public static boolean isFileExist(String filePath){\n  if (StringUtils.isBlank(filePath)) {\n    return false;\n  }\n  File file=new File(filePath);\n  return (file.exists() && file.isFile());\n}\n", "docstring": "indicates if this file represents a file on the underlying file system .", "partition": "test"}
{"idx": "4730", "code": "public static PronghornStage findStageByPath(GraphManager m,int... path){\n  int ordinal=path[0];\n  int i=0;\n  int limit=m.stageIdToStage.length;\n  while (i < limit) {\n    if (null != m.stageIdToStage[i]) {\n      if (-1 == m.multInputIds[m.stageIdToInputsBeginIdx[m.stageIdToStage[i].stageId]]) {\n        if (--ordinal <= 0) {\n          return findStageByPath(m,m.stageIdToStage[i],1,path);\n        }\n      }\n    }\n    i++;\n  }\n  throw new UnsupportedOperationException(\"Unable to find ordinal input stage of \" + path[0]);\n}\n", "docstring": "start with ordinal selection of input stages then ordinal selection of each output ring there after . todo : do generic return that extends pronghornstage", "partition": "test"}
{"idx": "4731", "code": "public static double[] calculateTStats(double[] coef,double[] stderror,int k){\n  double[] result=new double[k];\n  for (int i=0; i < k; i++) {\n    result[i]=coef[i] / stderror[i];\n  }\n  return result;\n}\n", "docstring": "returns an array of the t - statistic of each coefficient in a multiple linear regression model .", "partition": "test"}
{"idx": "4732", "code": "static void runBootstrappers(final CoreEarlyComponent early,final List<HeroicBootstrap> bootstrappers) throws Exception {\n  for (  final HeroicBootstrap bootstrap : bootstrappers) {\n    try {\n      bootstrap.run(early);\n    }\n catch (    Exception e) {\n      throw new Exception(\"Failed to run bootstrapper \" + bootstrap,e);\n    }\n  }\n}\n", "docstring": "this method basically goes through the list of bootstrappers registered by modules and runs them .", "partition": "test"}
{"idx": "4733", "code": "public static byte[] checkIndexHeaderID(DataInput in,byte[] expectedID) throws IOException {\n  byte id[]=new byte[StringHelper.ID_LENGTH];\n  in.readBytes(id,0,id.length);\n  if (!Arrays.equals(id,expectedID)) {\n    throw new CorruptIndexException(\"file mismatch, expected id=\" + StringHelper.idToString(expectedID) + \", got=\"+ StringHelper.idToString(id),in);\n  }\n  return id;\n}\n", "docstring": "expert : just reads and verifies the object id of an index header", "partition": "test"}
{"idx": "4734", "code": "protected void saveBuffer(String name){\n  StringBuffer sb=m_History.getNamedBuffer(name);\n  if (sb != null) {\n    if (m_SaveOut.save(sb)) {\n      m_Log.logMessage(\"Save successful.\");\n    }\n  }\n}\n", "docstring": "save the currently selected clusterer output to a file .", "partition": "test"}
{"idx": "4735", "code": "public List<Recommendation> scheduleStorage(VirtualArray srcVarray,Set<URI> requestedVPlexSystems,URI srcStorageSystem,VirtualPool srcVpool,boolean isHARequest,VirtualArray requestedHaVarray,VirtualPool haVpool,VirtualPoolCapabilityValuesWrapper capabilities,Project project,VpoolUse vpoolUse,Map<VpoolUse,List<Recommendation>> currentRecommendations){\n  _log.info(\"Executing VPlex high availability placement strategy\");\n  if (!isHARequest) {\n    return scheduleStorageForLocalVPLEXVolume(srcVarray,requestedVPlexSystems,srcStorageSystem,srcVpool,capabilities,project,vpoolUse,currentRecommendations);\n  }\n else {\n    return scheduleStorageForDistributedVPLEXVolume(srcVarray,requestedVPlexSystems,srcStorageSystem,srcVpool,requestedHaVarray,haVpool,capabilities,project,vpoolUse,currentRecommendations);\n  }\n}\n", "docstring": "get recommendations for resource placement based on the passed parameters .", "partition": "test"}
{"idx": "4736", "code": "@NotNull public static List<String> completeRelativePath(@NotNull String baseDir,@NotNull String shownBaseDir,@NotNull String relativePath){\n  List<String> result=Lists.newLinkedList();\n  String bashBaseDir=OSUtil.toBashCompatible(baseDir);\n  for (  String path : completeAbsolutePath(baseDir + File.separator + relativePath,Predicates.<File>alwaysTrue())) {\n    if (path.startsWith(bashBaseDir)) {\n      result.add(shownBaseDir + path.substring(bashBaseDir.length()));\n    }\n  }\n  return result;\n}\n", "docstring": "collect a list of relative paths . the start directory for the match is given as separate parameter .", "partition": "test"}
{"idx": "4737", "code": "protected boolean isFileSpecifyingModuleSpecifier(String specifier){\n  return specifier.length() > 0 && specifier.charAt(specifier.length() - 1) != IPath.SEPARATOR;\n}\n", "docstring": "returns true if the given module specifier is specifying a file . returns false for empty specifiers .", "partition": "test"}
{"idx": "4738", "code": "private void insertExpectedPoolSettingsPerTier(CIMObjectPath capabilitiesPath,Map<String,Object> keyMap){\n  List<String> expectedPoolSettingsTier=(List<String>)keyMap.get(Constants.VNXPOOLCAPABILITIES_TIER);\n  expectedPoolSettingsTier.add(capabilitiesPath.toString() + Constants.HYPHEN + Constants.NO_DATA_MOVEMENT);\n  expectedPoolSettingsTier.add(capabilitiesPath.toString() + Constants.HYPHEN + Constants.AUTO_TIER);\n  expectedPoolSettingsTier.add(capabilitiesPath.toString() + Constants.HYPHEN + Constants.HIGH_AVAILABLE_TIER);\n  expectedPoolSettingsTier.add(capabilitiesPath.toString() + Constants.HYPHEN + Constants.LOW_AVAILABLE_TIER);\n  expectedPoolSettingsTier.add(capabilitiesPath.toString() + Constants.HYPHEN + Constants.START_HIGH_THEN_AUTO_TIER);\n}\n", "docstring": "in vnx , 4 default policies are present , and this method creates expected settings per poolcapability .", "partition": "test"}
{"idx": "4739", "code": "private static final void transferStreams(InputStream source,OutputStream destination,String path,IProgressMonitor monitor) throws CoreException {\n  monitor=Policy.monitorFor(monitor);\n  try {\nsynchronized (buffer) {\n      while (true) {\n        int bytesRead=-1;\n        try {\n          bytesRead=source.read(buffer);\n        }\n catch (        IOException e) {\n          String msg=NLS.bind(Messages.failedReadDuringWrite,path);\n          Policy.error(EFS.ERROR_READ,msg,e);\n        }\n        try {\n          if (bytesRead == -1) {\n            destination.close();\n            break;\n          }\n          destination.write(buffer,0,bytesRead);\n        }\n catch (        IOException e) {\n          String msg=NLS.bind(Messages.couldNotWrite,path);\n          Policy.error(EFS.ERROR_WRITE,msg,e);\n        }\n        monitor.worked(1);\n      }\n    }\n  }\n  finally {\n    Policy.safeClose(source);\n    Policy.safeClose(destination);\n  }\n}\n", "docstring": "transfers the contents of an input stream to an output stream , using a large buffer .", "partition": "test"}
{"idx": "4740", "code": "private int pathPositionAtLevel(int orgUnitLevel){\n  return (orgUnitLevel - 1) * 12 + 2;\n}\n", "docstring": "returns the position within an orgunit path at which the orgunit uid will be found for a given orgunitlevel .", "partition": "test"}
{"idx": "4741", "code": "private int makeAvailable(){\n  if (pos != -1) {\n    return 0;\n  }\n  total+=tail - head - pad;\n  System.arraycopy(buffer,tail - pad,buffer,0,pad);\n  head=0;\n  tail=pad;\n  for (; ; ) {\n    int bytesRead=0;\n    try {\n      bytesRead=input.read(buffer,tail,bufSize - tail);\n    }\n catch (    IOException e) {\n      throw new RuntimeException(\"Error while reading multipart stream\");\n    }\n    if (bytesRead == -1) {\n      final String msg=\"Stream ended unexpectedly\";\n      throw new MalformedStreamException(msg);\n    }\n    tail+=bytesRead;\n    findSeparator();\n    int av=available();\n    if (av > 0 || pos != -1) {\n      return av;\n    }\n  }\n}\n", "docstring": "attempts to read more data .", "partition": "test"}
{"idx": "4742", "code": "protected void addNumericTrainClass(double classValue,double weight){\n  if (classValue > m_MaxTarget) {\n    m_MaxTarget=classValue;\n  }\n  if (classValue < m_MinTarget) {\n    m_MinTarget=classValue;\n  }\n  if (m_TrainClassVals == null) {\n    m_TrainClassVals=new double[100];\n    m_TrainClassWeights=new double[100];\n  }\n  if (m_NumTrainClassVals == m_TrainClassVals.length) {\n    double[] temp=new double[m_TrainClassVals.length * 2];\n    System.arraycopy(m_TrainClassVals,0,temp,0,m_TrainClassVals.length);\n    m_TrainClassVals=temp;\n    temp=new double[m_TrainClassWeights.length * 2];\n    System.arraycopy(m_TrainClassWeights,0,temp,0,m_TrainClassWeights.length);\n    m_TrainClassWeights=temp;\n  }\n  m_TrainClassVals[m_NumTrainClassVals]=classValue;\n  m_TrainClassWeights[m_NumTrainClassVals]=weight;\n  m_NumTrainClassVals++;\n}\n", "docstring": "adds a numeric ( non - missing ) training class value and weight to the buffer of stored values . also updates minimum and maximum target value .", "partition": "test"}
{"idx": "4743", "code": "private List<Group> parseGroups(JSONArray groups,String groupType) throws JSONException, AdeUsageException {\n  if (groups.length() == 0)   throw new AdeUsageException(\"No groups specified for group of type \" + groupType);\n  List<Group> currentGroups=new ArrayList<Group>();\n  for (int i=0; i < groups.length(); i++) {\n    JSONObject group=groups.getJSONObject(i);\n    String name=group.getString(\"name\");\n    String dataType=group.getString(\"dataType\");\n    short evalOrder=group.getShort(\"evaluationOrder\");\n    String ruleName=group.getString(\"ruleName\");\n    if (!verifyStringParam(name,200,\"[a-zA-Z0-9_ ]*\") || name.equalsIgnoreCase(\"unassigned\") || !validateDataType(dataType)|| evalOrder < 1 || !verifyStringParam(ruleName,200,\"[a-zA-Z0-9_ ]*\")) {\n      throw new AdeUsageException(\"Invalid parameters for a group of type \" + groupType + \" was specified\");\n    }\n    currentGroups.add(new Group(name,GroupType.valueOf(groupType),DataType.valueOf(dataType.toUpperCase()),evalOrder,ruleName));\n  }\n  validateEvaluationOrderAndName(currentGroups);\n  return currentGroups;\n}\n", "docstring": "main logic for parsing the groups from the json file . also does validation of the groups attributes .", "partition": "test"}
{"idx": "4744", "code": "public DoubleFft1d(int n){\n  if (n < 1) {\n    throw new IllegalArgumentException(\"n must be greater than 0\");\n  }\n  this.n=n;\n  if (!ConcurrencyUtils.isPowerOf2(n)) {\n    if (getReminder(n,factors) >= 211) {\n      plan=Plans.BLUESTEIN;\n      nBluestein=ConcurrencyUtils.nextPow2(n * 2 - 1);\n      bk1=new double[2 * nBluestein];\n      bk2=new double[2 * nBluestein];\n      this.ip=new int[2 + (int)Math.ceil(2 + (1 << (int)(Math.log(nBluestein + 0.5) / Math.log(2)) / 2))];\n      this.w=new double[nBluestein];\n      int twon=2 * nBluestein;\n      nw=ip[0];\n      if (twon > (nw << 2)) {\n        nw=twon >> 2;\n        makewt(nw);\n      }\n      nc=ip[1];\n      if (nBluestein > (nc << 2)) {\n        nc=nBluestein >> 2;\n        makect(nc,w,nw);\n      }\n      bluesteini();\n    }\n else {\n      plan=Plans.MIXED_RADIX;\n      wtable=new double[4 * n + 15];\n      wtable_r=new double[2 * n + 15];\n      cffti();\n      rffti();\n    }\n  }\n else {\n    plan=Plans.SPLIT_RADIX;\n    this.ip=new int[2 + (int)Math.ceil(2 + (1 << (int)(Math.log(n + 0.5) / Math.log(2)) / 2))];\n    this.w=new double[n];\n    int twon=2 * n;\n    nw=ip[0];\n    if (twon > (nw << 2)) {\n      nw=twon >> 2;\n      makewt(nw);\n    }\n    nc=ip[1];\n    if (n > (nc << 2)) {\n      nc=n >> 2;\n      makect(nc,w,nw);\n    }\n  }\n}\n", "docstring": "creates new instance of doublefft_1d .", "partition": "test"}
{"idx": "4745", "code": "@Override public void dragGestureRecognized(DragGestureEvent evt){\n  DragEntry dragEntry=kseFrame.dragSelectedEntry();\n  if (dragEntry == null) {\n    return;\n  }\n  ImageIcon icon=dragEntry.getImage();\n  Toolkit toolkit=Toolkit.getDefaultToolkit();\n  Dimension dim=toolkit.getBestCursorSize(icon.getIconWidth(),icon.getIconHeight());\n  BufferedImage buffImage=new BufferedImage(dim.width,dim.height,BufferedImage.TYPE_INT_ARGB_PRE);\n  icon.paintIcon(evt.getComponent(),buffImage.getGraphics(),0,0);\n  cursor=toolkit.createCustomCursor(buffImage,new Point(0,0),\"keystore-entry\");\n  evt.startDrag(cursor,new KeyStoreEntryTransferable(dragEntry),this);\n}\n", "docstring": "drag gesture recognized . start the drag off if valid .", "partition": "test"}
{"idx": "4746", "code": "public static boolean isIdentifierHelperChar(char ch){\n  return ':' == ch || '.' == ch || '-' == ch || '_' == ch;\n}\n", "docstring": "checks if specified character can be part of xml identifier ( tag name of attribute name ) and is not standard identifier character .", "partition": "test"}
{"idx": "4747", "code": "public void addHeader(String line){\n  header.add(line);\n}\n", "docstring": "add a header line to this result .", "partition": "test"}
{"idx": "4748", "code": "public static IAddress loadAddress(final ResultSet resultSet,final String columnName) throws SQLException {\n  Preconditions.checkNotNull(resultSet,\"IE00500: Result set argument can not be null\");\n  Preconditions.checkNotNull(columnName,\"IE00501: Column name argument can not be null\");\n  final String addressString=readString(resultSet,columnName);\n  return resultSet.wasNull() ? null : new CAddress(new BigInteger(addressString));\n}\n", "docstring": "loads an address value from the database .", "partition": "test"}
{"idx": "4749", "code": "private static String encode(String stringToEncode){\n  String encoded;\n  try {\n    encoded=URLEncoder.encode(stringToEncode,UTF_8);\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new MCApiRuntimeException(e);\n  }\n  encoded=encoded.replace(\"*\",\"%2A\");\n  encoded=encoded.replace(\"~\",\"%7E\");\n  encoded=encoded.replace(\"+\",\"%20\");\n  return encoded;\n}\n", "docstring": "formats the input string for inclusion in a url . account for the differences in how oauth encodes certain characters ( such as the space character ) .", "partition": "test"}
{"idx": "4750", "code": "protected static String guessType(File file){\n  String name=file.getName();\n  String suffix=name.substring(name.lastIndexOf(\".\") + 1);\n  return mimeMap.get(suffix.toLowerCase(Locale.ROOT));\n}\n", "docstring": "guesses the type of a file , based on file name suffix", "partition": "test"}
{"idx": "4751", "code": "public void testAdvanceAllTerms() throws Exception {\n  List<String> termsList=new ArrayList<>();\n  termsList.addAll(Arrays.asList(commonTerms));\n  termsList.addAll(Arrays.asList(mediumTerms));\n  termsList.addAll(Arrays.asList(rareTerms));\n  String terms[]=termsList.toArray(new String[0]);\n  for (int amount=25; amount < 200; amount+=25) {\n    for (int minNrShouldMatch=1; minNrShouldMatch <= terms.length; minNrShouldMatch++) {\n      Scorer expected=scorer(terms,minNrShouldMatch,Mode.DOC_VALUES);\n      Scorer actual=scorer(terms,minNrShouldMatch,Mode.SCORER);\n      assertAdvance(expected,actual,amount);\n      expected=scorer(terms,minNrShouldMatch,Mode.DOC_VALUES);\n      actual=scorer(terms,minNrShouldMatch,Mode.BULK_SCORER);\n      assertAdvance(expected,actual,amount);\n    }\n  }\n}\n", "docstring": "test advance with giant bq of all terms with varying minshouldmatch", "partition": "test"}
{"idx": "4752", "code": "public boolean isPublic(){\n  return Modifier.isPublic(getAccessFlags());\n}\n", "docstring": "returns true for a public class .", "partition": "test"}
{"idx": "4753", "code": "public boolean releaseEncumbranceBudget(final Map<String,Object> detailsMap){\n  if (detailsMap == null)   throw new ValidationException(Arrays.asList(new ValidationError(\"required input is null\",\"required input is null\")));\n  detailsMap.put(Constants.CONSUMEORRELEASE,false);\n  final BigDecimal bd=getDetails(detailsMap);\n  return bd.intValue() == 1;\n}\n", "docstring": "this api will be called for releasing the budget that was already allocated to some estimate or purchase order . on calling this the amount that was allocated to some entity will get released . budget available will be increased . < p > on modify of any entity they should first call the release budget and then call the consume budget . the budget usage table needs to be updated anytime this is invoked with the date and reference object number .", "partition": "test"}
{"idx": "4754", "code": "protected Transferable createLocaleTransferable(long[] formats) throws IOException {\n  return null;\n}\n", "docstring": "the clipboard must be opened .", "partition": "test"}
{"idx": "4755", "code": "public void putLength(int len) throws IOException {\n  if (len < 128) {\n    write((byte)len);\n  }\n else   if (len < (1 << 8)) {\n    write((byte)0x081);\n    write((byte)len);\n  }\n else   if (len < (1 << 16)) {\n    write((byte)0x082);\n    write((byte)(len >> 8));\n    write((byte)len);\n  }\n else   if (len < (1 << 24)) {\n    write((byte)0x083);\n    write((byte)(len >> 16));\n    write((byte)(len >> 8));\n    write((byte)len);\n  }\n else {\n    write((byte)0x084);\n    write((byte)(len >> 24));\n    write((byte)(len >> 16));\n    write((byte)(len >> 8));\n    write((byte)len);\n  }\n}\n", "docstring": "put the encoding of the length in the stream .", "partition": "test"}
{"idx": "4756", "code": "public void putGenericFontFamily(String familyName,Font font){\n  genericFontFamilies.put(familyName.toLowerCase(),font);\n}\n", "docstring": "adds a generic font family .", "partition": "test"}
{"idx": "4757", "code": "private boolean writeReference(Object value,NodeMap node){\n  String name=get(value);\n  int size=size();\n  if (name != null) {\n    node.put(refer,name);\n    return true;\n  }\n  String unique=String.valueOf(size);\n  node.put(mark,unique);\n  put(value,unique);\n  return false;\n}\n", "docstring": "this is used to write the xml element attributes representing the serialized object instance . if the object has already been serialized to the xml document then a reference attribute is inserted and this returns true , if not , then this will write a unique identity marker attribute and return false .", "partition": "test"}
{"idx": "4758", "code": "@Override public String format(DateTimeFormatter formatter){\n  Objects.requireNonNull(formatter,\"formatter\");\n  return formatter.format(this);\n}\n", "docstring": "formats this date - time using the specified formatter . < p > this date - time will be passed to the formatter to produce a string .", "partition": "test"}
{"idx": "4759", "code": "public @DottedClassName String toDottedClassName(){\n  return ClassName.toDottedClassName(className);\n}\n", "docstring": "get the name of the class in dotted format .", "partition": "test"}
{"idx": "4760", "code": "public DAddExtensions(JFrame parent,String title,X509ExtensionSet extensions,PublicKey authorityPublicKey,X500Name authorityCertName,BigInteger authorityCertSerialNumber,PublicKey subjectPublicKey){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  setTitle(res.getString(\"DAddExtensions.Title\"));\n  this.extensions=extensions;\n  this.authorityPublicKey=authorityPublicKey;\n  this.authorityCertName=authorityCertName;\n  this.authorityCertSerialNumber=authorityCertSerialNumber;\n  this.subjectPublicKey=subjectPublicKey;\n  initComponents();\n}\n", "docstring": "creates a new daddextensions dialog .", "partition": "test"}
{"idx": "4761", "code": "private void playNext(){\n  if (mediaType == Config.YOUTUBE_MEDIA_TYPE_VIDEO) {\n    seekVideo(0);\n    restartVideo();\n    return;\n  }\n  if (previousWasCalled) {\n    previousWasCalled=false;\n    iterator.next();\n  }\n  if (!iterator.hasNext()) {\n    iterator=youTubeVideos.listIterator();\n  }\n  videoItem=iterator.next();\n  nextWasCalled=true;\n  playVideo();\n}\n", "docstring": "plays next video in playlist", "partition": "test"}
{"idx": "4762", "code": "public static <T>T invokeMethod(Object obj,String name,Object... params) throws NoSuchMethodException {\n  Class[] paramTypes=getParamTypes(params);\n  final Class<?> aClass=obj.getClass();\n  Method method;\n  try {\n    method=aClass.getDeclaredMethod(name,paramTypes);\n  }\n catch (  NoSuchMethodException e) {\n    method=aClass.getMethod(name,paramTypes);\n  }\n  method.setAccessible(true);\n  try {\n    return (T)method.invoke(obj,params);\n  }\n catch (  IllegalAccessException|InvocationTargetException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "invokes a method by reflection .", "partition": "test"}
{"idx": "4763", "code": "public static RotateStream create(Path path){\nsynchronized (_streams) {\n    WeakReference<RotateStream> ref=_streams.get(path);\n    RotateStream stream=ref != null ? ref.get() : null;\n    if (stream == null) {\n      stream=new RotateStream(path);\n      _streams.put(path,new WeakReference<>(stream));\n    }\n    return stream;\n  }\n}\n", "docstring": "returns the rotate stream corresponding to this path", "partition": "test"}
{"idx": "4764", "code": "private void cleanUpHistory(){\n  if (!mHistoryOfNumbers.isEmpty() && mHistoryOfNumbers.size() >= MAX_HISTORY_SIZE) {\n    for (int i=0; i < Math.max(1,MAX_HISTORY_SIZE / 2); i++) {\n      mPreviousNumbers.remove(mHistoryOfNumbers.removeFirst());\n    }\n  }\n}\n", "docstring": "removes old tracks and cleans up the history preparing for new tracks to be added to the mapping", "partition": "test"}
{"idx": "4765", "code": "public LogMessage(String template,int code){\n  this(template,null,EMPTY_STRING_ARRAY,code,Optional.empty());\n}\n", "docstring": "construct a log message that does not involve any templating .", "partition": "test"}
{"idx": "4766", "code": "protected String action_translate(String act_string,int act_pos,Hashtable label_map,Hashtable label_types){\n  int id_start;\n  int pos;\n  int len;\n  String id_str;\n  boolean in_id;\n  StringBuffer result;\n  char buffer[];\n  if (act_string == null || act_string.length() == 0)   return act_string;\n  len=act_string.length();\n  result=new StringBuffer(len + 50);\n  buffer=new char[len + 1];\n  act_string.getChars(0,len,buffer,0);\n  buffer[len]='\\0';\n  in_id=false;\n  for (pos=id_start=0; pos <= len; pos++) {\n    if (in_id) {\n      if (!is_id_char(buffer[pos])) {\n        id_str=new String(buffer,id_start,pos - id_start);\n        result.append(label_translate(id_str,act_pos,label_map,label_types));\n        if (buffer[pos] != '\\0')         result.append(buffer,pos,1);\n        in_id=false;\n      }\n else {\n      }\n    }\n else {\n      if (is_id_start(buffer[pos])) {\n        in_id=true;\n        id_start=pos;\n      }\n else {\n        if (buffer[pos] != '\\0')         result.append(buffer,pos,1);\n      }\n    }\n  }\n  return result.toString();\n}\n", "docstring": "translate all the label names within an action string to appropriate code .", "partition": "test"}
{"idx": "4767", "code": "public boolean canLoad(){\n  return true;\n}\n", "docstring": "the command will only load if this condition is true . happens after injections .", "partition": "test"}
{"idx": "4768", "code": "protected boolean strictParseBoolean(String s){\n  if (s == null || s.isEmpty()) {\n    throw new IllegalArgumentException(\"empty string does not represent a valid boolean\");\n  }\n  if (s.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n  if (s.equalsIgnoreCase(\"false\")) {\n    return false;\n  }\n  throw new IllegalArgumentException(\"Invalid string representing a boolean: \" + s);\n}\n", "docstring": "we need this strict function because boolean . parseboolean silently ignores malformed strings", "partition": "test"}
{"idx": "4769", "code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase FunctionblockPackage.EVENT__NAME:\n    return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);\ncase FunctionblockPackage.EVENT__PROPERTIES:\n  return properties != null && !properties.isEmpty();\n}\nreturn super.eIsSet(featureID);\n}\n", "docstring": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "4770", "code": "private void initializeSourceCodeMap(String adaptedContent){\n  sourceCodeWithLine=new LinkedHashMap<>();\n  int lineNumber=1;\n  StringReader sr=new StringReader(adaptedContent);\n  BufferedReader br=new BufferedReader(sr);\n  String line;\n  try {\n    while ((line=br.readLine()) != null) {\n      sourceCodeWithLine.put(lineNumber,line);\n      lineNumber++;\n    }\n  }\n catch (  IOException ex) {\n    LOGGER.error(\"Error occured while initialize source code map \" + ex.getMessage());\n  }\n}\n", "docstring": "initialisation of a local map that handles each source code line , keyed by the line number", "partition": "test"}
{"idx": "4771", "code": "public Matrix U(){\n  return U.clone();\n}\n", "docstring": "return the left singular vectors", "partition": "test"}
{"idx": "4772", "code": "private boolean isFieldVisited(Object object,Field objectField,Field field){\n  Map<String,Set<String>> bag=visitedFields.get(object);\n  if (bag == null) {\n    return false;\n  }\n  String objectFiledKey=objectField == null ? \"\" : objectField.toGenericString();\n  Set<String> fields=bag.get(objectFiledKey);\n  return fields != null && fields.contains(field);\n}\n", "docstring": "indicates whether the field of a target object is visited", "partition": "test"}
{"idx": "4773", "code": "public void removeFromCompletedList(DownloadInfoRunnable downloadInfoRunnable){\n  mCompletedList.remove(downloadInfoRunnable);\n}\n", "docstring": "removes a download from the completed list .", "partition": "test"}
{"idx": "4774", "code": "protected void addShingledPhraseQueries(final BooleanQuery mainQuery,final List<Clause> clauses,final Collection<FieldParams> fields,int shingleSize,final float tiebreaker,final int slop) throws SyntaxError {\n  if (null == fields || fields.isEmpty() || null == clauses || clauses.size() < shingleSize)   return;\n  if (0 == shingleSize)   shingleSize=clauses.size();\n  final int lastClauseIndex=shingleSize - 1;\n  StringBuilder userPhraseQuery=new StringBuilder();\n  for (int i=0; i < clauses.size() - lastClauseIndex; i++) {\n    userPhraseQuery.append(\'\"\');\n    for (int j=0; j <= lastClauseIndex; j++) {\n      userPhraseQuery.append(clauses.get(i + j).val);\n      userPhraseQuery.append(\' \');\n    }\n    userPhraseQuery.append(\'\"\');\n    userPhraseQuery.append(\' \');\n  }\n  ExtendedSolrQueryParser pp=createEdismaxQueryParser(this,IMPOSSIBLE_FIELD_NAME);\n  pp.addAlias(IMPOSSIBLE_FIELD_NAME,tiebreaker,getFieldBoosts(fields));\n  pp.setPhraseSlop(slop);\n  pp.setRemoveStopFilter(true);\n  pp.makeDismax=true;\n  pp.minClauseSize=2;\n  Query phrase=pp.parse(userPhraseQuery.toString());\n  if (phrase != null) {\n    mainQuery.add(phrase,BooleanClause.Occur.SHOULD);\n  }\n}\n", "docstring": "modifies the main query by adding a new optional query consisting of shingled phrase queries across the specified clauses using the specified field = & gt ; boost mappings .", "partition": "test"}
{"idx": "4775", "code": "public String asXmlId(){\n  return DatatypeConverter.printHexBinary(tokenDigest.getValue());\n}\n", "docstring": "return an id conformant to xml id", "partition": "test"}
{"idx": "4776", "code": "private void updateInfo(){\n  m_updating=true;\n  nameField.setText(m_cc.getName());\n  appsHostField.setText(m_cc.getAppsHost());\n  appsPortField.setText(String.valueOf(m_cc.getAppsPort()));\n  bTestApps.setIcon(getStatusIcon(m_cc.isAppsServerOK(false)));\n  boolean rw=CConnection.isServerEmbedded() ? true : !m_cc.isAppsServerOK(false);\n  dbTypeLabel.setReadWrite(rw);\n  dbTypeField.setReadWrite(rw);\n  dbTypeField.setSelectedItem(m_cc.getType());\n  hostLabel.setReadWrite(rw);\n  hostField.setReadWrite(rw);\n  hostField.setText(m_cc.getDbHost());\n  portLabel.setReadWrite(rw);\n  dbPortField.setReadWrite(rw);\n  dbPortField.setText(String.valueOf(m_cc.getDbPort()));\n  sidLabel.setReadWrite(rw);\n  sidField.setReadWrite(rw);\n  sidField.setText(m_cc.getDbName());\n  dbUidLabel.setReadWrite(rw);\n  dbUidField.setReadWrite(rw);\n  dbUidField.setText(m_cc.getDbUid());\n  dbPwdField.setEditable(rw);\n  dbPwdField.setText(m_cc.getDbPwd());\n  cbBequeath.setReadWrite(rw);\n  cbBequeath.setEnabled(m_cc.isOracle());\n  cbBequeath.setSelected(m_cc.isBequeath());\n  boolean fwEnabled=rw && m_cc.isViaFirewall() && m_cc.isOracle();\n  cbFirewall.setReadWrite(rw && m_cc.isOracle());\n  cbFirewall.setSelected(m_cc.isViaFirewall());\n  fwHostLabel.setReadWrite(fwEnabled);\n  fwHostField.setReadWrite(fwEnabled);\n  fwHostField.setText(m_cc.getFwHost());\n  fwPortLabel.setReadWrite(fwEnabled);\n  fwPortField.setReadWrite(fwEnabled);\n  fwPortField.setText(String.valueOf(m_cc.getFwPort()));\n  bTestDB.setToolTipText(m_cc.getConnectionURL());\n  bTestDB.setIcon(getStatusIcon(m_cc.isDatabaseOK()));\n  m_updating=false;\n}\n", "docstring": "update fields from connection", "partition": "test"}
{"idx": "4777", "code": "public void createSnapshot() throws BackupException {\n  logger.debug(\"Creating snapshot: \" + this.snapshotName);\n  processHelper.exec(\"Creating file system snapshot\",lvcreateCmd);\n}\n", "docstring": "creates a new snapshot , which is assumed not to exist already .", "partition": "test"}
{"idx": "4778", "code": "public final Uri storeLogFile(final LogFile logFile,final int sessionId){\n  final ContentValues values=new ContentValues();\n  values.put(Schema.COL_MANUFACTURER,logFile.getManufacturer());\n  values.put(Schema.COL_MODEL,logFile.getModel());\n  values.put(Schema.COL_REVISION,logFile.getRevision());\n  values.put(Schema.COL_SWID,logFile.getSwid());\n  values.put(Schema.COL_SWVER,logFile.getSwVersion());\n  values.put(Schema.COL_TIMESTAMP,System.currentTimeMillis());\n  values.put(Schema.COL_SESSION_ID,sessionId);\n  return contentResolver.insert(ContentProvider.CONTENT_URI_LOGFILE,values);\n}\n", "docstring": "persists logfile in database .", "partition": "test"}
{"idx": "4779", "code": "public Map<String,String> merge(Map<String,String> curProps,Map<String,String> newProps) throws IOException {\n  Map<String,String> props=new HashMap<>(newProps);\n  for (  Map.Entry<String,String> e : curProps.entrySet()) {\n    String name=e.getKey();\n    String curValue=e.getValue();\n    if (props.containsKey(name)) {\n      props.put(name,curValue);\n    }\n  }\n  return props;\n}\n", "docstring": "merges two bunches of the properties from current and new configurations .", "partition": "test"}
{"idx": "4780", "code": "public Builder deletePreferredLanguage(){\n  deleteFields.add(\"preferredLanguage\");\n  return this;\n}\n", "docstring": "delete the preferred language of a existing user", "partition": "test"}
{"idx": "4781", "code": "public void onPrepared(MediaPlayer player){\n  mState=State.PLAYING;\n  updateNotification(String.format(getString(R.string.media_state_playing),mFile.getFileName()));\n  if (mMediaController != null) {\n    mMediaController.setEnabled(true);\n  }\n  player.seekTo(mStartPosition);\n  configAndStartMediaPlayer();\n  if (!mPlayOnPrepared) {\n    processPauseRequest();\n  }\n  if (mMediaController != null) {\n    mMediaController.updatePausePlay();\n  }\n}\n", "docstring": "called when media player is done preparing . time to start .", "partition": "test"}
{"idx": "4782", "code": "private void parseParameter(String token,String value){\n  if (token != null && value != null) {\n    if (token.equalsIgnoreCase(NONCE_TOKEN)) {\n      mNonce=value;\n      return;\n    }\n    if (token.equalsIgnoreCase(STALE_TOKEN)) {\n      parseStale(value);\n      return;\n    }\n    if (token.equalsIgnoreCase(OPAQUE_TOKEN)) {\n      mOpaque=value;\n      return;\n    }\n    if (token.equalsIgnoreCase(QOP_TOKEN)) {\n      mQop=value.toLowerCase();\n      return;\n    }\n    if (token.equalsIgnoreCase(ALGORITHM_TOKEN)) {\n      mAlgorithm=value.toLowerCase();\n      return;\n    }\n  }\n}\n", "docstring": "if the token is a known parameter name , parses and initializes the token value .", "partition": "test"}
{"idx": "4783", "code": "public void skip(int n) throws IOException {\n  dis.skip(n);\n}\n", "docstring": "skip a set amount of bytes .", "partition": "test"}
{"idx": "4784", "code": "public void toAllInRadius(WorldServer world,Vec3d pos,double radius){\n  double maxDistance=radius * radius + radius * radius + radius * radius;\n  toAll(world.getPlayers(EntityPlayerMP.class,null));\n}\n", "docstring": "sends this packet to all the players in the world within the radius", "partition": "test"}
{"idx": "4785", "code": "public static ECDHECryptography fromNamedCurveId(int supportedGroupId){\n  SupportedGroup group=SupportedGroup.fromId(supportedGroupId);\n  if (group == null) {\n    return null;\n  }\n else {\n    try {\n      return new ECDHECryptography(group.name());\n    }\n catch (    GeneralSecurityException e) {\n      LOGGER.log(Level.WARNING,\"Cannot create ephemeral keys for group [{0}]: {1}\",new Object[]{group.name(),e.getMessage()});\n      return null;\n    }\n  }\n}\n", "docstring": "creates an ephemeral ecdh key pair for a supported group ( named curve ) .", "partition": "test"}
{"idx": "4786", "code": "private static void addHeader(Message message,String name,String value){\n  Map<String,List<String>> protocolHeaders=CastUtils.cast((Map<?,?>)message.get(Message.PROTOCOL_HEADERS));\n  if (protocolHeaders == null) {\n    protocolHeaders=new TreeMap<String,List<String>>(String.CASE_INSENSITIVE_ORDER);\n    message.put(Message.PROTOCOL_HEADERS,protocolHeaders);\n  }\n  List<String> header=CastUtils.cast((List<?>)protocolHeaders.get(name));\n  if (header == null) {\n    header=new ArrayList<String>();\n    protocolHeaders.put(name,header);\n  }\n  if (header.size() == 0) {\n    header.add(value);\n  }\n else {\n    header.set(0,header.get(0) + \",\" + value);\n  }\n}\n", "docstring": "adds a value to a header . if the given header name is not currently set in the message , an entry is created with the given single value . if the header is already set , the value is appended to the first element of the list , following a comma .", "partition": "test"}
{"idx": "4787", "code": "private static void swilk(boolean[] init,double[] x,int n,int n1,int n2,double[] a,double[] w,double[] pw,int[] ifault){\n  pw[0]=1.0;\n  if (w[0] >= 0.0) {\n    w[0]=1.0;\n  }\n  double an=n;\n  ifault[0]=3;\n  int nn2=n / 2;\n  if (n2 < nn2) {\n    return;\n  }\n  ifault[0]=1;\n  if (n < 3) {\n    return;\n  }\n  if (!init[0]) {\n    if (n == 3) {\n      a[1]=SQRTH;\n    }\n else {\n      double an25=an + 0.25;\n      double summ2=0.0;\n      for (int i=1; i <= n2; ++i) {\n        a[i]=ppnd((i - TH) / an25);\n        summ2+=a[i] * a[i];\n      }\n      summ2*=2.0;\n      double ssumm2=Math.sqrt(summ2);\n      double rsn=1.0 / Math.sqrt(an);\n      double a1=poly(C1,6,rsn) - a[1] / ssumm2;\n      int i1;\n      double fac;\n      if (n > 5) {\n        i1=3;\n        double a2=-a[2] / ssumm2 + poly(C2,6,rsn);\n        fac=Math.sqrt((summ2 - 2.0 * a[1] * a[1] - 2.0 * a[2] * a[2]) / (1.0 - 2.0 * a1 * a1 - 2.0 * a2 * a2));\n        a[1]=a1;\n        a[2]=a2;\n      }\n else {\n        i1=2;\n        fac=Math.sqrt((summ2 - 2.0 * a[1] * a[1]) / (1.0 - 2.0 * a1 * a1));\n        a[1]=a1;\n      }\n      for (int i=i1; i <= nn2; ++i) {\n        a[i]=-a[i] / fac;\n      }\n    }\n    init[0]=true;\n  }\n  if (n1 < 3) {\n    return;\n  }\n  int ncens=n - n1;\n  ifault[0]=4;\n  if (ncens < 0 || (ncens > 0 && n < 20)) {\n    return;\n  }\n  ifault[0]=5;\n  double delta=ncens / an;\n  if (delta > 0.8) {\n    return;\n  }\n  double w1, xx;\n  if (w[0] < 0.0) {\n    w1=1.0 + w[0];\n    ifault[0]=0;\n  }\n else {\n    ifault[0]=6;\n    double range=x[n1] - x[1];\n    if (range < SMALL) {\n      return;\n    }\n    ifault[0]=7;\n    xx=x[1] / range;\n    double sx=xx;\n    double sa=-a[1];\n    int j=n - 1;\n    for (int i=2; i <= n1; ++i) {\n      double xi=x[i] / range;\n      sx+=xi;\n      if (i != j) {\n        sa+=sign(1,i - j) * a[Math.min(i,j)];\n      }\n      xx=xi;\n      --j;\n    }\n    ifault[0]=0;\n    if (n > 5000) {\n      ifault[0]=2;\n    }\n    sa/=n1;\n    sx/=n1;\n    double ssa=0.0;\n    double ssx=0.0;\n    double sax=0.0;\n    j=n;\n    double asa;\n    for (int i=1; i <= n1; ++i) {\n      if (i != j) {\n        asa=sign(1,i - j) * a[Math.min(i,j)] - sa;\n      }\n else {\n        asa=-sa;\n      }\n      double xsx=x[i] / range - sx;\n      ssa+=asa * asa;\n      ssx+=xsx * xsx;\n      sax+=asa * xsx;\n      --j;\n    }\n    double ssassx=Math.sqrt(ssa * ssx);\n    w1=(ssassx - sax) * (ssassx + sax) / (ssa * ssx);\n  }\n  w[0]=1.0 - w1;\n  if (n == 3) {\n    pw[0]=PI6 * (Math.asin(Math.sqrt(w[0])) - STQR);\n    return;\n  }\n  double y=Math.log(w1);\n  xx=Math.log(an);\n  double m=0.0;\n  double s=1.0;\n  if (n <= 11) {\n    double gamma=poly(G,2,an);\n    if (y >= gamma) {\n      pw[0]=SMALL;\n      return;\n    }\n    y=-Math.log(gamma - y);\n    m=poly(C3,4,an);\n    s=Math.exp(poly(C4,4,an));\n  }\n else {\n    m=poly(C5,4,xx);\n    s=Math.exp(poly(C6,3,xx));\n  }\n  if (ncens > 0) {\n    double ld=-Math.log(delta);\n    double bf=1.0 + xx * BF1;\n    double z90f=Z90 + bf * Math.pow(poly(C7,2,Math.pow(XX90,xx)),ld);\n    double z95f=Z95 + bf * Math.pow(poly(C8,2,Math.pow(XX95,xx)),ld);\n    double z99f=Z99 + bf * Math.pow(poly(C9,2,xx),ld);\n    double zfm=(z90f + z95f + z99f) / 3.0;\n    double zsd=(Z90 * (z90f - zfm) + Z95 * (z95f - zfm) + Z99 * (z99f - zfm)) / ZSS;\n    double zbar=zfm - zsd * ZM;\n    m+=zbar * s;\n    s*=zsd;\n  }\n  pw[0]=alnorm((y - m) / s,UPPER);\n}\n", "docstring": "algorithm as r94 appl . statist . ( 1995 ) vol . 44 , no . 4 < p > calculates shapiro - wilk normality test and p - value for sample sizes 3 < = n < = 5000 . handles censored or uncensored data . corrects as 181 , which was found to be inaccurate for n > 50 . < p > note : semi - strange porting kludge alert . fortran allows subroutine arguments to be modified by the called routine ( passed by reference , not value ) , and the original code for this routine makes use of that feature to return multiple results . to avoid changing the code any more than necessary , i \"'\" ve used java arrays to simulate this pass - by - reference feature . specifically , in the original code w , pw , and ifault are output results , not input parameters . pass in double [ 1 ", "partition": "test"}
{"idx": "4788", "code": "public String asString(){\n  StringBuilder buff=new StringBuilder();\n  for (int i=0; i < arrayLevel; i++) {\n    if (refCount) {\n      buff.append(\"ptr< \");\n    }\n    buff.append(\"array< \");\n  }\n  if (refCount) {\n    if (!classObj.isPrimitive) {\n      buff.append(\"ptr< \");\n    }\n  }\n  buff.append(classObj.toString());\n  if (refCount) {\n    if (!classObj.isPrimitive) {\n      buff.append(\" >\");\n    }\n  }\n  for (int i=0; i < arrayLevel; i++) {\n    if (refCount) {\n      buff.append(\" >\");\n    }\n else {\n      if (!classObj.isPrimitive) {\n        buff.append(\"*\");\n      }\n    }\n    buff.append(\" >\");\n  }\n  if (!refCount) {\n    if (isObject()) {\n      buff.append(\"*\");\n    }\n  }\n  return buff.toString();\n}\n", "docstring": "get the c + + code .", "partition": "test"}
{"idx": "4789", "code": "public List<JsonObject> executeParametrizedStatement(String statement,List<String> parameterNames,List<Object> parameterValues){\n  JsonObject namedParams=JsonObject.create();\n  for (int param=0; param < parameterNames.size(); param++) {\n    namedParams.put(parameterNames.get(param),parameterValues.get(param));\n  }\n  ParameterizedN1qlQuery query=N1qlQuery.parameterized(statement,namedParams);\n  return executeQuery(query);\n}\n", "docstring": "executes a n1ql statement with named parameters .", "partition": "test"}
{"idx": "4790", "code": "public final T endAll(){\n  while (!tagStack.isEmpty()) {\n    end();\n  }\n  return getSelf();\n}\n", "docstring": "closes all open tags .", "partition": "test"}
{"idx": "4791", "code": "public static Table createPartitionedTable(Configuration conf,HiveMetastoreClient ms,HiveObjectSpec tableSpec,TableType tableType,Path warehouseRoot) throws IOException, HiveMetastoreException {\n  Path tableLocation=getPathForHiveObject(warehouseRoot,tableSpec);\n  Table table=new Table();\n  table.setDbName(tableSpec.getDbName());\n  table.setTableName(tableSpec.getTableName());\n  Map<String,String> parameters=new HashMap<>();\n  parameters.put(HiveParameterKeys.TLDT,Long.toString(System.currentTimeMillis()));\n  table.setParameters(parameters);\n  table.setTableType(tableType.toString());\n  List<FieldSchema> partitionCols=new ArrayList<>();\n  partitionCols.add(new FieldSchema(\"ds\",\"string\",\"my ds comment\"));\n  partitionCols.add(new FieldSchema(\"hr\",\"string\",\"my hr comment\"));\n  table.setPartitionKeys(partitionCols);\n  StorageDescriptor sd=new StorageDescriptor();\n  List<FieldSchema> columns=new ArrayList<>();\n  columns.add(new FieldSchema(\"key\",\"string\",\"my comment\"));\n  sd.setCols(columns);\n  if (tableType == TableType.MANAGED_TABLE || tableType == TableType.EXTERNAL_TABLE) {\n    sd.setLocation(tableLocation.toString());\n  }\n  sd.setSerdeInfo(new SerDeInfo(\"LazySimpleSerde\",\"org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\",new HashMap<>()));\n  table.setSd(sd);\n  if (!ms.existsDb(table.getDbName())) {\n    ms.createDatabase(new Database(table.getDbName(),null,null,null));\n  }\n  ms.createTable(table);\n  return table;\n}\n", "docstring": "creates a table that is partitioned on ds and hr .", "partition": "test"}
{"idx": "4792", "code": "protected FormSpec(DefaultAlignment defaultAlignment,String encodedDescription){\n  this(defaultAlignment,Sizes.DEFAULT,NO_GROW);\n  parseAndInitValues(encodedDescription.toLowerCase(Locale.ENGLISH));\n}\n", "docstring": "constructs a formspec from the specified encoded description . the description will be parsed to set initial values .", "partition": "test"}
{"idx": "4793", "code": "public static <T>List<T> decode(InputStream data,Parser<T> parser) throws IOException {\n  CodedInputStream stream=CodedInputStream.newInstance(data);\n  List<T> list=new ArrayList<>();\n  while (!stream.isAtEnd()) {\n    int size=stream.readRawVarint32();\n    byte[] element=stream.readRawBytes(size);\n    T decoded=parser.parseFrom(element);\n    list.add(decoded);\n  }\n  return list;\n}\n", "docstring": "decode custom protobuf variable length array .", "partition": "test"}
{"idx": "4794", "code": "@Override public void drawItem(Graphics2D g2,XYItemRendererState state,Rectangle2D dataArea,PlotRenderingInfo info,XYPlot plot,ValueAxis domainAxis,ValueAxis rangeAxis,XYDataset dataset,int series,int item,CrosshairState crosshairState,int pass){\n  if ((!getPlotLines()) || ((!(domainAxis instanceof CyclicNumberAxis)) && (!(rangeAxis instanceof CyclicNumberAxis))) || (item <= 0)) {\n    super.drawItem(g2,state,dataArea,info,plot,domainAxis,rangeAxis,dataset,series,item,crosshairState,pass);\n    return;\n  }\n  double xn=dataset.getXValue(series,item - 1);\n  double yn=dataset.getYValue(series,item - 1);\n  if (Double.isNaN(yn)) {\n    super.drawItem(g2,state,dataArea,info,plot,domainAxis,rangeAxis,dataset,series,item,crosshairState,pass);\n    return;\n  }\n  double[] x=new double[2];\n  double[] y=new double[2];\n  x[0]=xn;\n  y[0]=yn;\n  xn=dataset.getXValue(series,item);\n  yn=dataset.getYValue(series,item);\n  if (Double.isNaN(yn)) {\n    return;\n  }\n  x[1]=xn;\n  y[1]=yn;\n  double xcycleBound=Double.NaN;\n  double ycycleBound=Double.NaN;\n  boolean xBoundMapping=false, yBoundMapping=false;\n  CyclicNumberAxis cnax=null, cnay=null;\n  if (domainAxis instanceof CyclicNumberAxis) {\n    cnax=(CyclicNumberAxis)domainAxis;\n    xcycleBound=cnax.getCycleBound();\n    xBoundMapping=cnax.isBoundMappedToLastCycle();\n    if ((x[0] != x[1]) && ((xcycleBound >= x[0]) && (xcycleBound <= x[1]) || (xcycleBound >= x[1]) && (xcycleBound <= x[0]))) {\n      double[] nx=new double[3];\n      double[] ny=new double[3];\n      nx[0]=x[0];\n      nx[2]=x[1];\n      ny[0]=y[0];\n      ny[2]=y[1];\n      nx[1]=xcycleBound;\n      ny[1]=(y[1] - y[0]) * (xcycleBound - x[0]) / (x[1] - x[0]) + y[0];\n      x=nx;\n      y=ny;\n    }\n  }\n  if (rangeAxis instanceof CyclicNumberAxis) {\n    cnay=(CyclicNumberAxis)rangeAxis;\n    ycycleBound=cnay.getCycleBound();\n    yBoundMapping=cnay.isBoundMappedToLastCycle();\n    if ((y[0] != y[1]) && ((ycycleBound >= y[0]) && (ycycleBound <= y[1]) || (ycycleBound >= y[1]) && (ycycleBound <= y[0]))) {\n      double[] nx=new double[x.length + 1];\n      double[] ny=new double[y.length + 1];\n      nx[0]=x[0];\n      nx[2]=x[1];\n      ny[0]=y[0];\n      ny[2]=y[1];\n      ny[1]=ycycleBound;\n      nx[1]=(x[1] - x[0]) * (ycycleBound - y[0]) / (y[1] - y[0]) + x[0];\n      if (x.length == 3) {\n        nx[3]=x[2];\n        ny[3]=y[2];\n      }\n      x=nx;\n      y=ny;\n    }\n else     if ((x.length == 3) && (y[1] != y[2]) && ((ycycleBound >= y[1]) && (ycycleBound <= y[2]) || (ycycleBound >= y[2]) && (ycycleBound <= y[1]))) {\n      double[] nx=new double[4];\n      double[] ny=new double[4];\n      nx[0]=x[0];\n      nx[1]=x[1];\n      nx[3]=x[2];\n      ny[0]=y[0];\n      ny[1]=y[1];\n      ny[3]=y[2];\n      ny[2]=ycycleBound;\n      nx[2]=(x[2] - x[1]) * (ycycleBound - y[1]) / (y[2] - y[1]) + x[1];\n      x=nx;\n      y=ny;\n    }\n  }\n  if (x.length == 2) {\n    super.drawItem(g2,state,dataArea,info,plot,domainAxis,rangeAxis,dataset,series,item,crosshairState,pass);\n    return;\n  }\n  OverwriteDataSet newset=new OverwriteDataSet(x,y,dataset);\n  if (cnax != null) {\n    if (xcycleBound == x[0]) {\n      cnax.setBoundMappedToLastCycle(x[1] <= xcycleBound);\n    }\n    if (xcycleBound == x[1]) {\n      cnax.setBoundMappedToLastCycle(x[0] <= xcycleBound);\n    }\n  }\n  if (cnay != null) {\n    if (ycycleBound == y[0]) {\n      cnay.setBoundMappedToLastCycle(y[1] <= ycycleBound);\n    }\n    if (ycycleBound == y[1]) {\n      cnay.setBoundMappedToLastCycle(y[0] <= ycycleBound);\n    }\n  }\n  super.drawItem(g2,state,dataArea,info,plot,domainAxis,rangeAxis,newset,series,1,crosshairState,pass);\n  if (cnax != null) {\n    if (xcycleBound == x[1]) {\n      cnax.setBoundMappedToLastCycle(x[2] <= xcycleBound);\n    }\n    if (xcycleBound == x[2]) {\n      cnax.setBoundMappedToLastCycle(x[1] <= xcycleBound);\n    }\n  }\n  if (cnay != null) {\n    if (ycycleBound == y[1]) {\n      cnay.setBoundMappedToLastCycle(y[2] <= ycycleBound);\n    }\n    if (ycycleBound == y[2]) {\n      cnay.setBoundMappedToLastCycle(y[1] <= ycycleBound);\n    }\n  }\n  super.drawItem(g2,state,dataArea,info,plot,domainAxis,rangeAxis,newset,series,2,crosshairState,pass);\n  if (x.length == 4) {\n    if (cnax != null) {\n      if (xcycleBound == x[2]) {\n        cnax.setBoundMappedToLastCycle(x[3] <= xcycleBound);\n      }\n      if (xcycleBound == x[3]) {\n        cnax.setBoundMappedToLastCycle(x[2] <= xcycleBound);\n      }\n    }\n    if (cnay != null) {\n      if (ycycleBound == y[2]) {\n        cnay.setBoundMappedToLastCycle(y[3] <= ycycleBound);\n      }\n      if (ycycleBound == y[3]) {\n        cnay.setBoundMappedToLastCycle(y[2] <= ycycleBound);\n      }\n    }\n    super.drawItem(g2,state,dataArea,info,plot,domainAxis,rangeAxis,newset,series,3,crosshairState,pass);\n  }\n  if (cnax != null) {\n    cnax.setBoundMappedToLastCycle(xBoundMapping);\n  }\n  if (cnay != null) {\n    cnay.setBoundMappedToLastCycle(yBoundMapping);\n  }\n}\n", "docstring": "draws the visual representation of a single data item . when using cyclic axis , do not draw a line from right to left when cycling as would a standard xy item renderer , but instead draw a line from the previous point to the cycle bound in the last cycle , and a line from the cycle bound to current point in the current cycle .", "partition": "test"}
{"idx": "4795", "code": "public void writeField(final String name,final double value) throws java.io.IOException {\n  writeField(name,Double.toString(value));\n}\n", "docstring": "writes an double field value .", "partition": "test"}
{"idx": "4796", "code": "public Creature calculateNextCreature(final int questLevel){\n  final List<Creature> possibleCreaturesToSpawn=new ArrayList<Creature>();\n  int lastLevel=0;\n  for (  final Creature creature : sortedCreatures) {\n    if (creature.getLevel() > questLevel) {\n      break;\n    }\n    if (creature.getLevel() > lastLevel) {\n      possibleCreaturesToSpawn.clear();\n      lastLevel=creature.getLevel();\n    }\n    possibleCreaturesToSpawn.add(creature);\n  }\n  Creature creatureToSpawn=null;\n  if (possibleCreaturesToSpawn.size() == 0) {\n    creatureToSpawn=sortedCreatures.get(sortedCreatures.size() - 1);\n  }\n else {\n    Collections.shuffle(possibleCreaturesToSpawn);\n    creatureToSpawn=possibleCreaturesToSpawn.get(0);\n  }\n  return creatureToSpawn;\n}\n", "docstring": "calculates which type of creature should be spawned next .", "partition": "test"}
{"idx": "4797", "code": "@Override public void before(PropertyInfoRestRep oldProps,PropertyInfoRestRep newProps){\n  String newIntervalStr=newProps.getProperty(BackupConstants.SCHEDULE_INTERVAL);\n  String newStartTimeStr=newProps.getProperty(BackupConstants.SCHEDULE_TIME);\n  if ((newIntervalStr == null || newIntervalStr.isEmpty()) && (newStartTimeStr == null || newStartTimeStr.isEmpty())) {\n    _log.info(\"No changes in backup interval and start time\");\n    return;\n  }\n  String intervalStr=(newIntervalStr == null || newIntervalStr.isEmpty()) ? oldProps.getProperty(BackupConstants.SCHEDULE_INTERVAL) : newIntervalStr;\n  String startTimeStr=(newStartTimeStr == null || newStartTimeStr.isEmpty()) ? oldProps.getProperty(BackupConstants.SCHEDULE_TIME) : newStartTimeStr;\n  _log.info(\"intervalStr={}, startTimeStr={}\",intervalStr,startTimeStr);\n  validateBackupIntervalAndStartTime(intervalStr,startTimeStr);\n}\n", "docstring": "check if backup related configurations conformed to rules , if not fail the property update .", "partition": "test"}
{"idx": "4798", "code": "@Override public void deleteTrait(String guid,String traitNameToBeDeleted) throws AtlasException {\n  guid=ParamChecker.notEmpty(guid,\"entity id\");\n  traitNameToBeDeleted=ParamChecker.notEmpty(traitNameToBeDeleted,\"trait name\");\n  if (!typeSystem.isRegistered(traitNameToBeDeleted)) {\n    final String msg=String.format(\"trait=%s should be defined in type system before it can be deleted\",traitNameToBeDeleted);\n    LOG.error(msg);\n    throw new TypeNotFoundException(msg);\n  }\n  repository.deleteTrait(guid,traitNameToBeDeleted);\n  onTraitDeletedFromEntity(repository.getEntityDefinition(guid),traitNameToBeDeleted);\n}\n", "docstring": "deletes a given trait from an existing entity represented by a guid .", "partition": "test"}
{"idx": "4799", "code": "public void addTables(Collection<Table> tables){\n  for (Iterator<Table> it=tables.iterator(); it.hasNext(); ) {\n    addTable((Table)it.next());\n  }\n}\n", "docstring": "adds the given tables .", "partition": "test"}
{"idx": "4800", "code": "protected void writeFile(String template,Writer writer){\n  if (template == null) {\n    throw new IllegalArgumentException(\"template content can not be null.\");\n  }\n  BufferedWriter bufferedWriter=new BufferedWriter(writer);\n  String output=replace(template,null);\n  try {\n    bufferedWriter.append(output);\n  }\n catch (  IOException e) {\n    logger.log(Diagnostic.Kind.ERROR,\"write file failed\");\n    e.printStackTrace();\n  }\n finally {\n    try {\n      bufferedWriter.close();\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "docstring": "replace placeholder in template", "partition": "test"}
{"idx": "4801", "code": "public int indexOf(final RoundedToolItem item){\n  checkWidget();\n  return items.indexOf(item);\n}\n", "docstring": "searches the receiver \"'\" s list starting at the first item ( index 0 ) until an item is found that is equal to the argument , and returns the index of that item . if no item is found , returns - 1 .", "partition": "test"}
{"idx": "4802", "code": "public void addAttribute(String alias,String typeUri,boolean required,int count) throws MessageException {\n  if (alias.indexOf(\',\') > -1 || alias.indexOf(\'.\') > -1 || alias.indexOf(\':\') > -1 || alias.indexOf(\'\\n\') > -1)   throw new MessageException(\"Characters [.,:\\\\n] are not allowed in attribute aliases: \" + alias);\n  _parameters.set(new Parameter(\"type.\" + alias,typeUri));\n  String level=required ? \"required\" : \"if_available\";\n  Parameter levelParam=_parameters.getParameter(level);\n  Parameter newParam;\n  if (levelParam == null) {\n    newParam=new Parameter(level,alias);\n  }\n else {\n    newParam=new Parameter(level,levelParam.getValue() + \",\" + alias);\n    _parameters.removeParameters(level);\n  }\n  _parameters.set(newParam);\n  setCount(alias,count);\n  if (DEBUG)   _log.debug(\"Added new attribute to fetch request; type: \" + typeUri + \" alias: \"+ alias+ \" count: \"+ count+ \" required: \"+ required);\n}\n", "docstring": "adds an attribute to the fetch request .", "partition": "test"}
{"idx": "4803", "code": "public Void call() throws Exception {\n  final List<Future<Void>> tasks=new LinkedList<Future<Void>>();\n  try {\n    for (    IV<?,?> termId : graphs) {\n      final FutureTask<Void> ft=new FutureTask<Void>(new DrainIteratorTask(termId));\n      tasks.add(ft);\n      executor.execute(ft);\n    }\n    for (    Future<Void> f : tasks) {\n      f.get();\n    }\n  }\n catch (  Throwable ex) {\n    for (    Future<Void> f : tasks)     f.cancel(true);\n    throw new RuntimeException(ex);\n  }\n finally {\n    buffer.close();\n  }\n  return null;\n}\n", "docstring": "outer callable submits tasks for execution .", "partition": "test"}
{"idx": "4804", "code": "protected void runFullImport(String dataConfig,Map<String,String> extraParams) throws Exception {\n  HashMap<String,String> params=new HashMap<>();\n  params.put(\"command\",\"full-import\");\n  params.put(\"debug\",\"on\");\n  params.put(\"dataConfig\",dataConfig);\n  params.put(\"clean\",\"true\");\n  params.put(\"commit\",\"true\");\n  params.putAll(extraParams);\n  NamedList l=new NamedList();\n  for (  Map.Entry<String,String> e : params.entrySet()) {\n    l.add(e.getKey(),e.getValue());\n  }\n  LocalSolrQueryRequest request=new LocalSolrQueryRequest(h.getCore(),l);\n  h.query(\"/dataimport\",request);\n}\n", "docstring": "runs a full - import using the given dataconfig and the provided request parameters . by default , debug = on , clean = true and commit = true are passed which can be overridden .", "partition": "test"}
{"idx": "4805", "code": "public String userIdFromRange(Object ominId,Object omaxId){\n  int minId=FunctionHandler.getInt(ominId);\n  int maxId=FunctionHandler.getInt(omaxId);\n  Stack<Integer> stack=getStack(minId,maxId);\n  if (stack.size() > 0) {\n    return Integer.toString(stack.pop());\n  }\n  throw new IllegalArgumentException(\"Exhausted random User Ids. Range not large enough for the number of calls.\");\n}\n", "docstring": "generate a random user id in the range provided", "partition": "test"}
{"idx": "4806", "code": "public void start(){\n  if (isStarted) {\n    log.info(\"Coordinator stream consumer already started\");\n    return;\n  }\n  log.info(\"Starting coordinator stream system consumer.\");\n  systemConsumer.start();\n  isStarted=true;\n}\n", "docstring": "starts the underlying systemconsumer .", "partition": "test"}
{"idx": "4807", "code": "public static void generateBinaryOperationFlags(final ITranslationEnvironment environment,final long nextOffset,final String result,final OperandSize resultSize,final List<ReilInstruction> instructions) throws IllegalArgumentException {\n  Preconditions.checkNotNull(environment,\"Error: Argument environment can\'t be null\");\n  Preconditions.checkNotNull(result,\"Error: Argument result can\'t be null\");\n  Preconditions.checkNotNull(resultSize,\"Error: Argument resultSize can\'t be null\");\n  Preconditions.checkNotNull(instructions,\"Error: Argument instructions can\'t be null\");\n  final long baseOffset=nextOffset - instructions.size();\n  long offset=nextOffset;\n  generateSignFlagCode(environment,offset,result,resultSize,instructions);\n  offset=(baseOffset + instructions.size()) - 1;\n  instructions.add(ReilHelpers.createBisz(offset + 1,resultSize,result,OperandSize.BYTE,Helpers.ZERO_FLAG));\n  instructions.add(ReilHelpers.createStr(offset + 2,OperandSize.BYTE,\"0\",OperandSize.BYTE,Helpers.CARRY_FLAG));\n  instructions.add(ReilHelpers.createStr(offset + 3,OperandSize.BYTE,\"0\",OperandSize.BYTE,Helpers.OVERFLOW_FLAG));\n}\n", "docstring": "sets the flags according to the result of a binary and / or / xor operation .", "partition": "test"}
{"idx": "4808", "code": "public boolean isLabelMovable(){\n  mxGraph graph=graphComponent.getGraph();\n  String label=graph.getLabel(state.getCell());\n  return graph.isLabelMovable(state.getCell()) && label != null && label.length() > 0;\n}\n", "docstring": "returns true if the label is movable .", "partition": "test"}
{"idx": "4809", "code": "public int writeTypeList(TypeList typeList){\n  int off=data.position();\n  short[] types=typeList.types;\n  writeInt(types.length);\n  for (  short type : types) {\n    writeShort(type);\n  }\n  return off;\n}\n", "docstring": "write typelist item into current section .", "partition": "test"}
{"idx": "4810", "code": "public static void loadConfigResource(String resourceName) throws IOException {\n  config.clear();\n  config.putAll(loadPropertiesFromResource(resourceName));\n}\n", "docstring": "load configuration from resource in current class loader .", "partition": "test"}
{"idx": "4811", "code": "public static void safeCloseStream(InputStream in){\n  if (in != null) {\n    try {\n      in.close();\n    }\n catch (    Exception e) {\n      log.error(e.getMessage(),e);\n    }\n  }\n}\n", "docstring": "close streams without pain", "partition": "test"}
{"idx": "4812", "code": "private Transaction createTransaction() throws LeaseDeniedException, RemoteException, TransactionException {\n  ITransactionManagerProvider transactionManagerProvider=getTransactionManagerProvider();\n  return (TransactionFactory.create(transactionManagerProvider.getTransactionManager(),_config.getTransactionTimeout())).transaction;\n}\n", "docstring": "create new transaction using the local transaction manager", "partition": "test"}
{"idx": "4813", "code": "public void skipWhile(String skip) throws IOException {\n  char ch;\n  do {\n    ch=read();\n  }\n while (skip.indexOf(ch) > -1);\n  unreadCharacter(ch);\n}\n", "docstring": "skips char any contiguous characters in skip . will also skip comments .", "partition": "test"}
{"idx": "4814", "code": "@Override public boolean containsKey(Object key){\n  if (key == null) {\n    return entryForNullKey != null;\n  }\n  int hash=key.hashCode();\n  hash^=(hash >>> 20) ^ (hash >>> 12);\n  hash^=(hash >>> 7) ^ (hash >>> 4);\n  HashMapEntry<K,V>[] tab=table;\n  for (HashMapEntry<K,V> e=tab[hash & (tab.length - 1)]; e != null; e=e.next) {\n    K eKey=e.key;\n    if (eKey == key || (e.hash == hash && key.equals(eKey))) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns whether this map contains the specified key .", "partition": "test"}
{"idx": "4815", "code": "public void savePoisFromAssets(){\n  List<Poi> pois=poiAssetLoader.loadPoisFromAssets();\n  Timber.d(\"Loaded %s poi, trying to insert them\",pois.size());\n  for (  Poi poi : pois) {\n    Timber.d(\"saving poi %s\",poi);\n    savePoi(poi);\n    Timber.d(\"poi saved\");\n  }\n}\n", "docstring": "load pois from assets and save them in the database .", "partition": "test"}
{"idx": "4816", "code": "private void createElement(Document doc,Element parentElement,String elementName,Color value){\n  Element element=doc.createElement(elementName);\n  element.appendChild(doc.createTextNode(ColourUtils.fromColour(value)));\n  parentElement.appendChild(element);\n}\n", "docstring": "creates the xml element for a colour value .", "partition": "test"}
{"idx": "4817", "code": "public static boolean beenDone(@Scope int scope,String tag,CountChecker numberOfTimes){\n  List<Long> tagSeenDates=tagLastSeenMap.get(tag);\n  if (tagSeenDates.isEmpty()) {\n    return false;\n  }\n  if (scope == THIS_APP_INSTALL) {\n    return numberOfTimes.check(tagSeenDates.size());\n  }\n else   if (scope == THIS_APP_SESSION) {\n    int counter=0;\n    for (    String tagFromList : sessionList) {\n      if (tagFromList.equals(tag)) {\n        counter++;\n      }\n    }\n    return numberOfTimes.check(counter);\n  }\n else {\n    int counter=0;\n    for (    Long seenDate : tagSeenDates) {\n      if (seenDate > lastAppUpdatedTime) {\n        counter++;\n      }\n    }\n    return numberOfTimes.check(counter);\n  }\n}\n", "docstring": "checks if a tag has been marked done within a given scope a specific number of times .", "partition": "test"}
{"idx": "4818", "code": "void variableOperatorChanged(int row,String oper){\n  ConditionalVariable variable=_variableList.get(row);\n  int oldOper=variable.getOpern();\n  if (row > 0) {\n    if (oper.equals(Bundle.getMessage(\"LogicOR\"))) {\n      variable.setOpern(Conditional.OPERATOR_OR);\n    }\n else {\n      variable.setOpern(Conditional.OPERATOR_AND);\n    }\n  }\n else {\n    variable.setOpern(Conditional.OPERATOR_NONE);\n  }\n  if (variable.getOpern() != oldOper) {\n    makeAntecedent();\n  }\n}\n", "docstring": "responds to the operator column in the edit conditional window", "partition": "test"}
{"idx": "4819", "code": "public void addHeader(String name,String val){\n  mMsgHeader=mMsgHeader + name + \": \"+ val+ mLineDelimiter;\n  addInternalHeaderFields(name,val);\n}\n", "docstring": "add a header with the name and value given . it will be appended to the header string .", "partition": "test"}
{"idx": "4820", "code": "public static void checkDuplicateRequest(RedisClient redisClient,String uri,Buffer buffer,String ttl,Handler<Boolean> callback){\n  Integer timeToLive=parseTimeToLive(ttl);\n  String redisKey=getRedisKey(uri,HashCodeGenerator.createHashCode(uri,buffer.toString()));\n  handleStorage(redisClient,redisKey,timeToLive,callback);\n}\n", "docstring": "this method checks if an entry for the provided information ( uri and buffer ) is stored in the redis database . when no entry was found in the database , a new entry will be saved to the database using a key which is created from the given parameters ( uri and buffer ) . the new entry expires after ttl has expired .", "partition": "test"}
{"idx": "4821", "code": "boolean isHidden(View view){\n  return mHiddenViews.contains(view);\n}\n", "docstring": "returns whether a view is visible to layoutmanager or not .", "partition": "test"}
{"idx": "4822", "code": "public static void deleteRecursive(@NonNull File fileOrDirectory){\n  deleteRecursive(fileOrDirectory,Collections.EMPTY_LIST);\n}\n", "docstring": "deletes a file or directory and all its content recursively .", "partition": "test"}
{"idx": "4823", "code": "static boolean doesMenuBarBorderToolBar(JMenuBar c){\n  JToolBar tb=(JToolBar)MetalToolBarUI.findRegisteredComponentOfType(c,JToolBar.class);\n  if (tb != null && tb.getOrientation() == JToolBar.HORIZONTAL) {\n    JRootPane rp=SwingUtilities.getRootPane(c);\n    Point point=new Point(0,0);\n    point=SwingUtilities.convertPoint(c,point,rp);\n    int menuX=point.x;\n    int menuY=point.y;\n    point.x=point.y=0;\n    point=SwingUtilities.convertPoint(tb,point,rp);\n    return (point.x == menuX && menuY + c.getHeight() == point.y && c.getWidth() == tb.getWidth());\n  }\n  return false;\n}\n", "docstring": "returns true if the passed in jmenubar is above a horizontal jtoolbar .", "partition": "test"}
{"idx": "4824", "code": "private PriorityQueue<USField> createQueue(String fieldName,Map<String,Flt> words) throws IOException {\n  int numDocs=ir.numDocs();\n  FreqQ res=new FreqQ(words.size());\n  for (  String word : words.keySet()) {\n    float tf=words.get(word).x;\n    if (minTermFreq > 0 && tf < minTermFreq) {\n      continue;\n    }\n    int docFreq=ir.docFreq(new Term(fieldName,word));\n    if (minDocFreq > 0 && docFreq < minDocFreq) {\n      continue;\n    }\n    if (docFreq == 0 || docFreq > maxDocFreq) {\n      continue;\n    }\n    float idf=similarity.idf(docFreq,numDocs);\n    float score=0;\n    if (isLogTf()) {\n      score=(float)(Math.log(tf + 1) * idf);\n    }\n else {\n      score=tf * idf;\n    }\n    USField mltField;\n    if (isPayloadField(fieldName)) {\n      mltField=new USField(word,fieldName,score,tf,idf,docFreq,1.01f);\n    }\n else {\n      mltField=new USField(word,fieldName,score,tf,idf,docFreq);\n    }\n    res.insertWithOverflow(mltField);\n  }\n  return res;\n}\n", "docstring": "create a priorityqueue from a word - > tf map .", "partition": "test"}
{"idx": "4825", "code": "public static void eachObject(ObjectInputStream ois,Closure closure) throws IOException, ClassNotFoundException {\n  try {\n    while (true) {\n      try {\n        Object obj=ois.readObject();\n        closure.call(obj);\n      }\n catch (      EOFException e) {\n        break;\n      }\n    }\n    InputStream temp=ois;\n    ois=null;\n    temp.close();\n  }\n  finally {\n    closeWithWarning(ois);\n  }\n}\n", "docstring": "iterates through the given object stream object by object . the objectinputstream is closed afterwards .", "partition": "test"}
{"idx": "4826", "code": "private static int exitWithStatus(int status){\n  if (ToolIO.getMode() == ToolIO.SYSTEM) {\n    System.exit(status);\n  }\n  return status;\n}\n", "docstring": "if run in the system mode , exits the program , in tool mode returns the status", "partition": "test"}
{"idx": "4827", "code": "public static double distanceInMeters(final double latP1,final double latP2,final double lonP1,final double lonP2){\n  double distRad=Math.acos(Math.sin(toRadians(latP1)) * Math.sin(toRadians(latP2)) + Math.cos(toRadians(latP1)) * Math.cos(toRadians(latP2)) * Math.cos(toRadians(lonP1 - lonP2)));\n  final double distAsDegree=toDegrees(distRad);\n  return distAsDegree * 60 * 1.1515* 1609.344;\n}\n", "docstring": "computes the distance between two coordinates in meters .", "partition": "test"}
{"idx": "4828", "code": "public void processChallenge(final String challenge) throws MalformedChallengeException {\n  String s=AuthChallengeParser.extractScheme(challenge);\n  if (!s.equalsIgnoreCase(getSchemeName())) {\n    throw new MalformedChallengeException(\"Invalid NTLM challenge: \" + challenge);\n  }\n  int i=challenge.indexOf(\' \');\n  if (i != -1) {\n    s=challenge.substring(i,challenge.length());\n    this.ntlmchallenge=s.trim();\n    this.state=TYPE2_MSG_RECEIVED;\n  }\n else {\n    this.ntlmchallenge=\"\";\n    if (this.state == UNINITIATED) {\n      this.state=INITIATED;\n    }\n else {\n      this.state=FAILED;\n    }\n  }\n}\n", "docstring": "processes the ntlm challenge .", "partition": "test"}
{"idx": "4829", "code": "public static BigInteger calculateA(BigInteger p,BigInteger q,BigInteger gA,BigInteger x2s){\n  return gA.modPow(x2s,p);\n}\n", "docstring": "calculate a as done in round 2 .", "partition": "test"}
{"idx": "4830", "code": "public static MCostQueue add(MProduct product,int M_AttributeSetInstance_ID,MAcctSchema as,int AD_Org_ID,int M_CostElement_ID,BigDecimal amt,BigDecimal qty,int precision,MCostDetail cd,String trxName){\n  if (CLogMgt.isLevelFine())   s_log.fine(\"Entering: org=\" + AD_Org_ID + \", product=\"+ product.get_ID()+ \", asi=\"+ M_AttributeSetInstance_ID+ \", amt=\"+ amt+ \", qty=\"+ qty+ \", precision=\"+ precision);\n  MCostQueue cq=new MCostQueue(product,M_AttributeSetInstance_ID,as,AD_Org_ID,M_CostElement_ID,trxName);\n  cq.setCosts(amt,qty,precision);\n  cq.setDateAcct(cd.getDateAcct());\n  cq.saveEx();\n  if (CLogMgt.isLevelFine())   s_log.fine(\"Leaving: \" + cq);\n  return cq;\n}\n", "docstring": "push to queue record . costinglevel is not validated", "partition": "test"}
{"idx": "4831", "code": "public void addUndoEvent(UndoInterface event){\n  if (shouldProcessUndoRedoAction()) {\n    boolean atEndOfList=(currentIndex >= undoList.size());\n    if (!atEndOfList) {\n      while (undoList.size() > currentIndex) {\n        int lastIndex=undoList.size() - 1;\n        undoList.remove(lastIndex);\n      }\n    }\n    undoList.add(event);\n    currentIndex=undoList.size();\n    updateMenuItems();\n    logger.debug(event.getStringRepresentation());\n  }\n}\n", "docstring": "adds the undo event .", "partition": "test"}
{"idx": "4832", "code": "public static Exception establishCacheIfNeeded(PrintStream... progress){\n  if (m_offline) {\n    return null;\n  }\n  if (REP_MIRROR == null) {\n    establishMirror();\n  }\n  Exception problem=null;\n  if (INITIAL_CACHE_BUILD_NEEDED) {\n    for (    PrintStream p : progress) {\n      p.println(\"Caching repository meta data, please wait...\");\n    }\n    problem=refreshCache(progress);\n    INITIAL_CACHE_BUILD_NEEDED=false;\n  }\n  return problem;\n}\n", "docstring": "establish the local copy of the package meta data if needed", "partition": "test"}
{"idx": "4833", "code": "public List<Snapshot> currentSnapshots(String repositoryName){\n  List<Snapshot> snapshotList=new ArrayList<>();\n  List<SnapshotsInProgress.Entry> entries=currentSnapshots(repositoryName,null);\n  for (  SnapshotsInProgress.Entry entry : entries) {\n    snapshotList.add(inProgressSnapshot(entry));\n  }\n  CollectionUtil.timSort(snapshotList);\n  return Collections.unmodifiableList(snapshotList);\n}\n", "docstring": "returns a list of currently running snapshots from repository sorted by snapshot creation date", "partition": "test"}
{"idx": "4834", "code": "private void cleanStatic(MethodNode method){\n}\n", "docstring": "finds the begining of the zkm blurb , the end , then removed everything in between !", "partition": "test"}
{"idx": "4835", "code": "@Override protected void paintTabBackground(Graphics g,int tabPlacement,int tabIndex,int x,int y,int w,int h,boolean isSelected){\n  if (isSelected) {\n    if (tabPlacement == TOP) {\n      g.setColor(Color.white);\n      g.fillRoundRect(x,y,w,h + R + R,R,R);\n    }\n  }\n else {\n  }\n}\n", "docstring": "give selected tab blue color with a gradient ! ! . fixme : with plastic l & f the unselected background is too dark", "partition": "test"}
{"idx": "4836", "code": "private Automaton buildAutomaton(BytesRefHash termBytesHash){\n  final TreeSet<BytesRef> terms=new TreeSet<BytesRef>();\n  for (int i=0; i < termBytesHash.size(); i++) {\n    BytesRef ref=new BytesRef();\n    termBytesHash.get(i,ref);\n    terms.add(ref);\n  }\n  final Automaton a=DaciukMihovAutomatonBuilder.build(terms);\n  return a;\n}\n", "docstring": "build an automaton to represent the frontier query", "partition": "test"}
{"idx": "4837", "code": "protected Range findRangeBounds(CategoryDataset dataset,boolean includeInterval){\n  if (dataset == null) {\n    return null;\n  }\n  if (getDataBoundsIncludesVisibleSeriesOnly()) {\n    List visibleSeriesKeys=new ArrayList();\n    int seriesCount=dataset.getRowCount();\n    for (int s=0; s < seriesCount; s++) {\n      if (isSeriesVisible(s)) {\n        visibleSeriesKeys.add(dataset.getRowKey(s));\n      }\n    }\n    return DatasetUtilities.findRangeBounds(dataset,visibleSeriesKeys,includeInterval);\n  }\n else {\n    return DatasetUtilities.findRangeBounds(dataset,includeInterval);\n  }\n}\n", "docstring": "returns the range of values the renderer requires to display all the items from the specified dataset .", "partition": "test"}
{"idx": "4838", "code": "protected String adminShutdown(){\n  server.shutdown();\n  return \"admin.jsp\";\n}\n", "docstring": "stop the application and the server .", "partition": "test"}
{"idx": "4839", "code": "public void assignRole(AMRole role) throws AMException, SSOException {\n  assignRole(role.getDN());\n}\n", "docstring": "assigns a role to the user .", "partition": "test"}
{"idx": "4840", "code": "protected void writeInitialStyles() throws IOException {\n  out.flushBits();\n  fillBits=OutStream.determineUnsignedBitSize(fillStyles.size());\n  lineBits=OutStream.determineUnsignedBitSize(lineStyles.size());\n  if (!hasStyle) {\n    fillBits=1;\n  }\n else {\n    writeStyles(fillStyles);\n    writeStyles(lineStyles);\n    out.flushBits();\n  }\n  out.writeUBits(4,fillBits);\n  out.writeUBits(4,lineBits);\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "4841", "code": "public static <T extends Map.Entry<String,String>>String formEncode(Collection<T> parameters) throws IOException {\n  ByteArrayOutputStream b=new ByteArrayOutputStream();\n  formEncode(parameters,b);\n  return new String(b.toByteArray());\n}\n", "docstring": "construct a x - www - form - urlencoded document containing the given sequence of name / value pairs . use oauth percent encoding ( not exactly the encoding mandated by x - www - form - urlencoded ) .", "partition": "test"}
{"idx": "4842", "code": "public void test_singleResourceLocking_serialized_lowConcurrency2() throws Exception {\n  Properties properties=new Properties();\n  properties.setProperty(TestOptions.NTHREADS,\"2\");\n  properties.setProperty(TestOptions.NTASKS,\"1000\");\n  properties.setProperty(TestOptions.NRESOURCES,\"1\");\n  properties.setProperty(TestOptions.MIN_LOCKS,\"1\");\n  properties.setProperty(TestOptions.MAX_LOCKS,\"1\");\n  properties.setProperty(TestOptions.PREDECLARE_LOCKS,\"false\");\n  properties.setProperty(TestOptions.SORT_LOCK_REQUESTS,\"false\");\n  doComparisonTest(properties);\n}\n", "docstring": "test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized .", "partition": "test"}
{"idx": "4843", "code": "public void runNextPendingCommand(){\n  Runnable runnable=deltaQueue.pop();\n  runnable.run();\n}\n", "docstring": "runs the next command scheduled to be executed immediately .", "partition": "test"}
{"idx": "4844", "code": "private static Document loadDocument(Resource xmlFile) throws SAXException, IOException {\n  DOMParser parser=new DOMParser();\n  InputStream is=null;\n  try {\n    is=IOUtil.toBufferedInputStream(xmlFile.getInputStream());\n    InputSource source=new InputSource(is);\n    parser.parse(source);\n  }\n  finally {\n    IOUtil.closeEL(is);\n  }\n  return parser.getDocument();\n}\n", "docstring": "load xml document from xml file", "partition": "test"}
{"idx": "4845", "code": "public static void prepareUnicode(final StringBuilder buffer,final ByteSequence sequence,final boolean trim,final boolean foldCase){\n  Reject.ifNull(buffer,sequence);\n  final int length=sequence.length();\n  for (int i=0; i < length; i++) {\n    final byte b=sequence.byteAt(i);\n    if ((b & 0x7F) != b) {\n      MappingTable.map(buffer,sequence.subSequence(i,length),trim,foldCase);\n      String normalizedForm=Normalizer.normalize(buffer,Form.NFKD);\n      buffer.setLength(0);\n      buffer.append(normalizedForm);\n      break;\n    }\nswitch (b) {\ncase ' ':\n      if (canMapToSpace(buffer,trim)) {\n        buffer.append(' ');\n      }\n    break;\ndefault :\n  if (b >= '\\u0009' && b < '\\u000E') {\n    if (canMapToSpace(buffer,trim)) {\n      buffer.append(SPACE_CHAR);\n    }\n  }\n else   if ((b >= '\\u0000' && b <= '\\u0008') || (b >= '\\u000E' && b <= '\\u001F') || b == '\\u007F') {\n    break;\n  }\n else   if (foldCase && b >= 'A' && b <= 'Z') {\n    buffer.append((char)(b + 32));\n  }\n else {\n    buffer.append((char)b);\n  }\nbreak;\n}\n}\nif (trim) {\nfor (int i=buffer.length() - 1; i > 0; i--) {\nif (buffer.charAt(i) == SPACE_CHAR) {\nbuffer.delete(i,i + 1);\n}\n else {\nbreak;\n}\n}\n}\n}\n", "docstring": "prepares an attribute or assertion value as per stringprep algorithm defined in rfc 4518 .", "partition": "test"}
{"idx": "4846", "code": "public void testCase18(){\n  byte aBytes[]={0};\n  byte bBytes[]={0};\n  byte rBytes[]={0};\n  int aSign=1;\n  int bSign=1;\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.add(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",0,result.signum());\n}\n", "docstring": "add zero to zero", "partition": "test"}
{"idx": "4847", "code": "@Nonnull public BugInstance addClass(ClassNode classNode){\n  String dottedClassName=ClassName.toDottedClassName(classNode.name);\n  ClassAnnotation classAnnotation=new ClassAnnotation(dottedClassName);\n  add(classAnnotation);\n  return this;\n}\n", "docstring": "add a class annotation for the classnode .", "partition": "test"}
{"idx": "4848", "code": "public static void tryFormatSatisfiability(String format) throws IllegalFormatException {\n  MessageFormat.format(format,(Object[])null);\n}\n", "docstring": "throws an exception if the format is not syntactically valid .", "partition": "test"}
{"idx": "4849", "code": "public static int parseUpperMap(String s) throws NumberFormatException {\n  int upperCase=MAP_UNDEFINED;\n  int length=s.length();\n  if (length >= 4 && length <= 6) {\n    upperCase=Integer.parseInt(s,16);\n  }\n else   if (s.length() != 0) {\n    throw new NumberFormatException();\n  }\n  return upperCase;\n}\n", "docstring": "parse the uppercase mapping attribute for a unicode character . if there is a uppercase mapping attribute and the parse succeeds , then the hasuppermap field is set to true , the uppermap field of this unicodespec object is updated , and false is returned . if the uppercase mapping attribute is an empty string , the parse succeeds but the hasuppermap field is set to false . ( and false is returned ) . the uppercase mapping attribute should be a four to six digit hexadecimal integer .", "partition": "test"}
{"idx": "4850", "code": "@Override public void run(){\n  while (!isInterrupted()) {\n    try {\n      Reference ref=_queue.remove();\n      _entryInfos.remove(ref);\n    }\n catch (    InterruptedException e) {\n      interrupt();\n      break;\n    }\n  }\n}\n", "docstring": "block on the queue until an entry is been cleaned by the gc", "partition": "test"}
{"idx": "4851", "code": "private boolean isValidPlaylistName(String newName){\n  Playlist blankPlaylist=new Playlist(newName,false);\n  return !newName.isEmpty() && !musicLibrary.containsPlaylist(blankPlaylist);\n}\n", "docstring": "ensures that a string for a playlist is valid , checking if it is empty , or another playlist has the same name .", "partition": "test"}
{"idx": "4852", "code": "public String importXML(String fileName,Properties ctx,String trxName) throws Exception {\n  log.info(\"importXML:\" + fileName);\n  File in=new File(fileName);\n  if (!in.exists()) {\n    String msg=\"File does not exist: \" + fileName;\n    log.info(\"importXML:\" + msg);\n    return msg;\n  }\n  try {\n    log.info(\"starting\");\n    System.setProperty(\"javax.xml.parsers.SAXParserFactory\",\"org.apache.xerces.jaxp.SAXParserFactoryImpl\");\n    PackInHandler handler=new PackInHandler();\n    handler.set_TrxName(trxName);\n    handler.setCtx(ctx);\n    handler.setProcess(this);\n    SAXParserFactory factory=SAXParserFactory.newInstance();\n    SAXParser parser=factory.newSAXParser();\n    String msg=\"Start Parser\";\n    log.info(msg);\n    parser.parse(in,handler);\n    msg=\"End Parser\";\n    log.info(msg);\n    return \"OK.\";\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,\"importXML:\",e);\n    throw e;\n  }\n}\n", "docstring": "uses packinhandler to update ad .", "partition": "test"}
{"idx": "4853", "code": "public synchronized void logAddOrRemoveRow(Session session,int tableId,Row row,boolean add){\n  if (logMode != LOG_MODE_OFF) {\n    if (!recoveryRunning) {\n      log.logAddOrRemoveRow(session,tableId,row,add);\n    }\n  }\n}\n", "docstring": "a record is added to a table , or removed from a table .", "partition": "test"}
{"idx": "4854", "code": "public org.smpte_ra.schemas.st2067_2_2016.DigestMethodType buildDefaultDigestMethodType(){\n  org.smpte_ra.schemas.st2067_2_2016.DigestMethodType digestMethodType=new org.smpte_ra.schemas.st2067_2_2016.DigestMethodType();\n  digestMethodType.setAlgorithm(CompositionPlaylistBuilder_2016.defaultHashAlgorithm);\n  return digestMethodType;\n}\n", "docstring": "a method to construct a default digest method type with a default hashalgorithm", "partition": "test"}
{"idx": "4855", "code": "public static <V extends SampledVertex>Set<V> createSampledPartition(Collection<V> vertices){\n  Set<V> partition=new HashSet<V>();\n  for (  V vertex : vertices) {\n    if (vertex.isSampled())     partition.add(vertex);\n  }\n  return partition;\n}\n", "docstring": "creates a subset of sampled vertices .", "partition": "test"}
{"idx": "4856", "code": "public GremlinTransactionManager(GremlinGraphFactory graphFactory){\n  super();\n  this.graphFactory=graphFactory;\n}\n", "docstring": "instantiates a new gremlintransactionmanager with the given gremlingraphfactory .", "partition": "test"}
{"idx": "4857", "code": "public void shiftBeans(BeanInstance toShiftTo,boolean save){\n  if (save) {\n    m_originalCoords=new Vector<Point>();\n  }\n  int targetX=toShiftTo.getX();\n  int targetY=toShiftTo.getY();\n  for (int i=0; i < m_subFlow.size(); i++) {\n    BeanInstance temp=(BeanInstance)m_subFlow.elementAt(i);\n    if (save) {\n      Point p=new Point(temp.getX() - targetX,temp.getY() - targetY);\n      m_originalCoords.add(p);\n    }\n    temp.setX(targetX);\n    temp.setY(targetY);\n  }\n}\n", "docstring": "move coords of all inputs and outputs of this meta bean to the coords of the supplied beaninstance . typically the supplied beaninstance is the beaninstance that encapsulates this meta bean ; the result in this case is that all inputs and outputs are shifted so that their coords coincide with the meta bean and all connections to them appear ( visually ) to go to / from the meta bean .", "partition": "test"}
{"idx": "4858", "code": "@Override protected final List<LatLong> doInBackground(final Object... args){\n  List<LatLong> points=new ArrayList<>();\n  DataHelper dbHelper=new DataHelper(mContext);\n  final ArrayList<PositionRecord> positions=dbHelper.loadPositions((Integer)args[SESSION_ID],(Double)args[MIN_LAT_COL],(Double)args[MAX_LAT_COL],(Double)args[MIN_LON_COL],(Double)args[MAX_LON_COL]);\n  for (  PositionRecord position : positions) {\n    points.add(new LatLong(position.getLatitude(),position.getLongitude()));\n  }\n  return points;\n}\n", "docstring": "queries reference database for all wifis in specified range around map centre .", "partition": "test"}
{"idx": "4859", "code": "public void make() throws Exception {\n  for (int i=0; i < _makeList.size(); i++) {\n    Make make=_makeList.get(i);\n    make.make();\n  }\n}\n", "docstring": "returns true if the underlying dependencies have changed .", "partition": "test"}
{"idx": "4860", "code": "@Override void deletedText(CharacterDataImpl node,int offset,int count){\n  if (ranges != null) {\n    notifyRangesDeletedText(node,offset,count);\n  }\n}\n", "docstring": "a method to be called when some text was deleted from a text node , so that live objects can be notified .", "partition": "test"}
{"idx": "4861", "code": "private ApplicationEnvironment(){\n  try {\n    if (System.getProperty(BootstrapProperties.IS_UBERJAR) != null) {\n      this.mode=Mode.UBERJAR;\n      if (!loadWildFlySwarmApplicationManifestFromClasspath()) {\n        loadWildFlySwarmApplicationManifestFromTCCL();\n      }\n    }\n else {\n      this.mode=Mode.CLASSPATH;\n      loadFractionManifestsFromClasspath();\n    }\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "do not construct directly .", "partition": "test"}
{"idx": "4862", "code": "public ProducerWorker(String topic,String message){\n  this._topic=topic;\n  this._message=message;\n}\n", "docstring": "creates a new producer object .", "partition": "test"}
{"idx": "4863", "code": "private static boolean functionsAreAllowed(boolean isAddAllFunction,boolean isPutAllFunction,Class<?> classD,Class<?> classS){\n  if (isAddAllFunction)   return collectionIsAssignableFrom(classD) && collectionIsAssignableFrom(classS);\n  if (isPutAllFunction)   return mapIsAssignableFrom(classD) && mapIsAssignableFrom(classS);\n  return isAssignableFrom(classD,classS);\n}\n", "docstring": "returns true if the function to check is allowed .", "partition": "test"}
{"idx": "4864", "code": "private void loadOrgAccessUser(ArrayList<OrgAccess> list){\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  String sql=\"SELECT * FROM AD_User_OrgAccess \" + \"WHERE AD_User_ID=? AND IsActive=\'Y\'\";\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getAD_User_ID());\n    rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MUserOrgAccess oa=new MUserOrgAccess(getCtx(),rs,get_TrxName());\n      loadOrgAccessAdd(list,new OrgAccess(oa.getAD_Client_ID(),oa.getAD_Org_ID(),oa.isReadOnly()));\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n finally {\n    DB.close(rs,pstmt);\n  }\n}\n", "docstring": "load org access user", "partition": "test"}
{"idx": "4865", "code": "@Override public void close() throws IOException {\n  SocketChannel s=_channel;\n  _channel=null;\n  SSLSocket sslSocket=_sslSocket;\n  _sslSocket=null;\n  if (sslSocket != null) {\n    try {\n      sslSocket.close();\n    }\n catch (    Exception e) {\n    }\n  }\n  if (s != null) {\n    try {\n      s.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "docstring": "closes the underlying socket .", "partition": "test"}
{"idx": "4866", "code": "public static Vector3D max(Vector3D a,Vector3D b){\n  return new Vector3D(FastMath.max(a.getX(),b.getX()),FastMath.max(a.getY(),b.getY()),FastMath.max(a.getZ(),b.getZ()));\n}\n", "docstring": "calculates maximum of each coordinate .", "partition": "test"}
{"idx": "4867", "code": "public static void waitForProcessOutput(Process self,OutputStream output,OutputStream error){\n  Thread tout=consumeProcessOutputStream(self,output);\n  Thread terr=consumeProcessErrorStream(self,error);\n  try {\n    tout.join();\n  }\n catch (  InterruptedException ignore) {\n  }\n  try {\n    terr.join();\n  }\n catch (  InterruptedException ignore) {\n  }\n  try {\n    self.waitFor();\n  }\n catch (  InterruptedException ignore) {\n  }\n  closeStreams(self);\n}\n", "docstring": "gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer . the processed stream data is appended to the supplied outputstream . for this , two threads are started , but join ( ) ed , so we wait . as implied by the waitfor . . . name , we also wait until we finish as well . finally , the input , output and error streams are closed .", "partition": "test"}
{"idx": "4868", "code": "@Override final Node<V> find(int h,long k){\n  for (Node<V> e=first; e != null; ) {\n    int s;\n    if (((s=lockState) & (WAITER | WRITER)) != 0) {\n      if ((e.key == k)) {\n        return e;\n      }\n      e=e.next;\n    }\n else     if (U.compareAndSwapInt(this,LOCKSTATE,s,s + READER)) {\n      TreeNode<V> r;\n      TreeNode<V> p;\n      try {\n        p=((r=root) == null ? null : r.findTreeNode(h,k));\n      }\n  finally {\n        Thread w;\n        if (getAndAddInt(this,LOCKSTATE,-READER) == (READER | WAITER) && (w=waiter) != null) {\n          LockSupport.unpark(w);\n        }\n      }\n      return p;\n    }\n  }\n  return null;\n}\n", "docstring": "returns matching node or null if none . tries to search using tree comparisons from root , but continues linear search when lock not available .", "partition": "test"}
{"idx": "4869", "code": "@Override public AxisState draw(Graphics2D g2,double cursor,Rectangle2D plotArea,Rectangle2D dataArea,RectangleEdge edge,PlotRenderingInfo plotState){\n  AxisState axisState=new AxisState(cursor);\n  if (isAxisLineVisible()) {\n    drawAxisLine(g2,cursor,dataArea,edge);\n  }\n  if (isTickMarksVisible()) {\n    drawTickMarks(g2,axisState,dataArea,edge);\n  }\n  if (isTickLabelsVisible()) {\n    for (int band=0; band < this.labelInfo.length; band++) {\n      axisState=drawTickLabels(band,g2,axisState,dataArea,edge);\n    }\n  }\n  if (getAttributedLabel() != null) {\n    axisState=drawAttributedLabel(getAttributedLabel(),g2,plotArea,dataArea,edge,axisState);\n  }\n else {\n    axisState=drawLabel(getLabel(),g2,plotArea,dataArea,edge,axisState);\n  }\n  return axisState;\n}\n", "docstring": "draws the axis on a java 2d graphics device ( such as the screen or a printer ) .", "partition": "test"}
{"idx": "4870", "code": "private ArrayList<URLCrawlDatum> readContents(Path fetchlist) throws IOException {\n  SequenceFile.Reader reader=new SequenceFile.Reader(fs,fetchlist,conf);\n  ArrayList<URLCrawlDatum> l=new ArrayList<URLCrawlDatum>();\n  READ:   do {\n    Text key=new Text();\n    CrawlDatum value=new CrawlDatum();\n    if (!reader.next(key,value)) {\n      break READ;\n    }\n    l.add(new URLCrawlDatum(key,value));\n  }\n while (true);\n  reader.close();\n  return l;\n}\n", "docstring": "read contents of fetchlist .", "partition": "test"}
{"idx": "4871", "code": "public static Color createRandomColour(){\n  float r=rand.nextFloat();\n  float g=rand.nextFloat();\n  float b=rand.nextFloat();\n  Color randomColor=new Color(r,g,b);\n  return randomColor;\n}\n", "docstring": "creates a random colour .", "partition": "test"}
{"idx": "4872", "code": "private static Pair<DiagnosticKind,Boolean> parseCategoryString(String category){\n  final String fixable=\"fixable-\";\n  final boolean isFixable=category.startsWith(fixable);\n  if (isFixable) {\n    category=category.substring(fixable.length());\n  }\n  DiagnosticKind categoryEnum=DiagnosticKind.fromParseString(category);\n  return Pair.of(categoryEnum,isFixable);\n}\n", "docstring": "given a category string that may be prepended with \" fixable - \" , return the category enum that corresponds with the category and whether or not it is a isfixable error", "partition": "test"}
{"idx": "4873", "code": "public void legacyProcess(Class clazz,Method m,MethodAppearanceDecision decision){\n  if (m.getDeclaringClass() != Object.class && m.getReturnType() != void.class && m.getParameterTypes().length == 0) {\n    String mName=m.getName();\n    if (!looksLikePropertyReadMethod(mName)) {\n      decision.setExposeMethodAs(null);\n      try {\n        decision.setExposeAsProperty(new PropertyDescriptor(mName,clazz,mName,null));\n      }\n catch (      IntrospectionException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}\n", "docstring": "this only exists as the tests need to call this through the deprecated method too .", "partition": "test"}
{"idx": "4874", "code": "public SPTKPitchReaderWriter(String lf0SPTKFile,float windowSizeInSeconds,float skipSizeInSeconds,int samplingRate){\n  contour=null;\n  header=new PitchFileHeader();\n  header.windowSizeInSeconds=windowSizeInSeconds;\n  header.skipSizeInSeconds=skipSizeInSeconds;\n  header.fs=samplingRate;\n  try {\n    contour=readSPTKF0Data(lf0SPTKFile);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "read a sptk lf0 file with external settings", "partition": "test"}
{"idx": "4875", "code": "public void abort(){\n  cleanUp();\n  if (mFuture != null) {\n    mFuture.cancel(true);\n    mFuture=null;\n  }\n  if (mExecutorService != null) {\n    mExecutorService.shutdownNow();\n    mExecutorService=null;\n  }\n  mListener=null;\n}\n", "docstring": "aborts the call . this method will cleanup the resources and removes the listener , if one was registered ,", "partition": "test"}
{"idx": "4876", "code": "public void addCSPStateListener(CSPStateListener listener){\n  listeners.add(listener);\n}\n", "docstring": "adds a csp state listener to the solution strategy .", "partition": "test"}
{"idx": "4877", "code": "public static void printWrappedText(final PrintStream stream,final String message){\n  if (stream != null && message != null && !message.isEmpty()) {\n    stream.println(wrapText(message,MAX_LINE_WIDTH));\n  }\n}\n", "docstring": "prints the provided string on the provided stream .", "partition": "test"}
{"idx": "4878", "code": "private synchronized Rect[] computeBoundingBoxes(){\n  if (!boundingBoxes.isPresent()) {\n    Rect[] bb=new Rect[(int)contours.size()];\n    for (int i=0; i < contours.size(); i++) {\n      bb[i]=boundingRect(contours.get(i));\n    }\n    boundingBoxes=Optional.of(bb);\n  }\n  return boundingBoxes.get();\n}\n", "docstring": "compute the bounding boxes of all contours ( if they haven \"'\" t already been computed ) . bounding boxes are used to compute several different properties , so it \"'\" s probably not a good idea to compute them over and over again .", "partition": "test"}
{"idx": "4879", "code": "public void addTimeline(final JSONObject timeline){\n  TimelineChannel.notifyTimeline(timeline);\n  timelines.addFirst(timeline);\n  final int maxCnt=Symphonys.getInt(\"timelineCnt\");\n  if (timelines.size() > maxCnt) {\n    timelines.remove(maxCnt);\n  }\n}\n", "docstring": "adds the specified timeline .", "partition": "test"}
{"idx": "4880", "code": "private boolean loadLOBData(){\n  if (isStoreAttachmentsOnFileSystem) {\n    return loadLOBDataFromFileSystem();\n  }\n  return loadLOBDataFromDB();\n}\n", "docstring": "load data into local m_data", "partition": "test"}
{"idx": "4881", "code": "public static <T>List<T> copyToArrayListWithExtraCapacity(T[] elements,int extraCapacity){\n  List<T> asList;\n  if (elements != null) {\n    asList=new ArrayList<T>(elements.length + extraCapacity);\n    asList.addAll(Arrays.asList(elements));\n  }\n else {\n    asList=new ArrayList<T>(extraCapacity);\n  }\n  return asList;\n}\n", "docstring": "produces an arraylist for an array of elements where the list is pre - sized with extra capacity . the extra capacity does not change the size of the list , but does change the initial capacity of the list , thus making adds more efficient if the ultimate size can be estimated .", "partition": "test"}
{"idx": "4882", "code": "private boolean sendEventToListeners(ClusterEvent event){\n  boolean success=true;\n  for (  String listenerId : Collections.unmodifiableSet(listeners.keySet())) {\n    logger.debug(\"Notifying listener {} of event {} for instance {}\",listenerId,event.getType(),instanceId);\n    ClusterEventListener listener=listeners.get(listenerId);\n    if (listener != null && !listener.handleEvent(event)) {\n      success=false;\n    }\n  }\n  return success;\n}\n", "docstring": "sends a clusterevent to all registered listeners", "partition": "test"}
{"idx": "4883", "code": "@RequestMapping(method=RequestMethod.PUT,value=\"/{region}/{keys}\",consumes={MediaType.APPLICATION_JSON_VALUE},produces={MediaType.APPLICATION_JSON_VALUE}) @ApiOperation(value=\"update data for key\",notes=\"Update or insert (put) data for key in region.\" + \"op=REPLACE, update (replace) data with key if and only if the key exists in region\" + \"op=CAS update (compare-and-set) value having key with a new value if and only if the \\\"@old\\\" value sent matches the current value for the key in region\",response=void.class) @ApiResponses({@ApiResponse(code=200,message=\"OK.\"),@ApiResponse(code=400,message=\"Bad Request.\"),@ApiResponse(code=401,message=\"Invalid Username or Password.\"),@ApiResponse(code=403,message=\"Insufficient privileges for operation.\"),@ApiResponse(code=404,message=\"Region does not exist or if key is not mapped to some value for REPLACE or CAS.\"),@ApiResponse(code=409,message=\"For CAS, @old value does not match to the current value in region\"),@ApiResponse(code=500,message=\"GemFire throws an error or exception.\")}) @PreAuthorize(\"@securityService.authorize(\'WRITE\', #region, #keys)\") public ResponseEntity<?> update(@PathVariable(\"region\") String region,@PathVariable(\"keys\") final String[] keys,@RequestParam(value=\"op\",defaultValue=\"PUT\") final String opValue,@RequestBody final String json){\n  logger.debug(\"updating key(s) for region ({}) \",region);\n  region=decode(region);\n  if (keys.length > 1) {\n    return updateMultipleKeys(region,keys,json);\n  }\n else {\n    return updateSingleKey(region,keys[0],json,opValue);\n  }\n}\n", "docstring": "update data for a key or set of keys", "partition": "test"}
{"idx": "4884", "code": "public void load(X509Extension extensions){\n  Set<String> critExts=extensions.getCriticalExtensionOIDs();\n  Set<String> nonCritExts=extensions.getNonCriticalExtensionOIDs();\n  List<X509Ext> sortedExts=new ArrayList<X509Ext>();\n  for (Iterator<String> itr=critExts.iterator(); itr.hasNext(); ) {\n    String extOid=itr.next();\n    byte[] value=extensions.getExtensionValue(extOid);\n    X509Ext ext=new X509Ext(new ASN1ObjectIdentifier(extOid),value,true);\n    sortedExts.add(ext);\n  }\n  for (Iterator<String> itr=nonCritExts.iterator(); itr.hasNext(); ) {\n    String extOid=itr.next();\n    byte[] value=extensions.getExtensionValue(extOid);\n    X509Ext ext=new X509Ext(new ASN1ObjectIdentifier(extOid),value,false);\n    sortedExts.add(ext);\n  }\n  Collections.sort(sortedExts,new ExtensionNameComparator());\n  data=new Object[sortedExts.size()][3];\n  int i=0;\n  for (Iterator<X509Ext> itrSortedExts=sortedExts.iterator(); itrSortedExts.hasNext(); ) {\n    X509Ext ext=itrSortedExts.next();\n    loadRow(ext,i);\n    i++;\n  }\n  fireTableDataChanged();\n}\n", "docstring": "load the extensionstablemodel with x . 509 extensions .", "partition": "test"}
{"idx": "4885", "code": "public Builder deleteAddresses(){\n  deleteFields.add(\"addresses\");\n  return this;\n}\n", "docstring": "deletes all existing addresses of the a existing user", "partition": "test"}
{"idx": "4886", "code": "public Query limit(int limit){\n  return limit(limit < 0 ? NO_LIMIT : Field.<Integer>field(Integer.toString(limit)));\n}\n", "docstring": "set the limit of this statement . using a negative value removes the limit .", "partition": "test"}
{"idx": "4887", "code": "public static boolean fileExists(String fName){\n  boolean result=false;\n  File file=new File(fName);\n  if (file != null) {\n    result=file.exists() && file.isFile();\n  }\n  return result;\n}\n", "docstring": "test if a file exists or not", "partition": "test"}
{"idx": "4888", "code": "private static void _init(){\n  addMethod(\"iConomy\",new com.earth2me.essentials.register.payment.methods.iCo6());\n  addMethod(\"iConomy\",new com.earth2me.essentials.register.payment.methods.iCo5());\n  addMethod(\"BOSEconomy\",new com.earth2me.essentials.register.payment.methods.BOSE7());\n  addMethod(\"Currency\",new com.earth2me.essentials.register.payment.methods.MCUR());\n  Dependencies.add(\"MultiCurrency\");\n  addMethod(\"Vault\",new com.earth2me.essentials.register.payment.methods.VaultEco());\n}\n", "docstring": "implement all methods along with their respective name & class .", "partition": "test"}
{"idx": "4889", "code": "public static String convertFileName(String name,int maxBytes){\n  try {\n    return convertFileName(name,maxBytes,Charset.defaultCharset());\n  }\n catch (  CharacterCodingException cce) {\n    try {\n      return convertFileName(name,maxBytes,Charset.forName(\"UTF-8\"));\n    }\n catch (    CharacterCodingException e) {\n      throw new RuntimeException(\"UTF-8 should have encoded: \" + name,e);\n    }\n  }\n}\n", "docstring": "cleans up the filename from illegal characters and truncates it to the length of bytes specified .", "partition": "test"}
{"idx": "4890", "code": "public static void copy(URL url,File file) throws IOException {\n  InputStream is=url.openStream();\n  try {\n    OutputStream os=new FileOutputStream(file);\n    try {\n      byte[] buffer=new byte[8192];\n      int read;\n      while ((read=is.read(buffer)) > 0) {\n        os.write(buffer,0,read);\n      }\n    }\n  finally {\n      os.close();\n    }\n  }\n  finally {\n    is.close();\n  }\n}\n", "docstring": "copy a url to a file .", "partition": "test"}
{"idx": "4891", "code": "public void createAuthConfiguration(String name) throws AMConsoleException {\n  if ((name == null) || (name.length() == 0)) {\n    throw new AMConsoleException(getLocalizedString(\"authentication.config.missing.name\"));\n  }\n  String[] params={currentRealm,name};\n  logEvent(\"ATTEMPT_CREATE_AUTH_CONFIG\",params);\n  String errorMsg=null;\n  try {\n    AMAuthConfigUtils.createNamedConfig(name,0,new HashMap(),currentRealm,getUserSSOToken());\n    logEvent(\"SUCCEED_CREATE_AUTH_CONFIG\",params);\n  }\n catch (  SMSException e) {\n    errorMsg=getErrorString(e);\n    String[] paramsEx={currentRealm,name,errorMsg};\n    logEvent(\"SMS_EXCEPTION_CREATE_AUTH_CONFIG\",paramsEx);\n    debug.warning(\"problem creating auth instance\",e);\n  }\ncatch (  SSOException e) {\n    errorMsg=getErrorString(e);\n    String[] paramsEx={currentRealm,name,errorMsg};\n    logEvent(\"SSO_EXCEPTION_CREATE_AUTH_CONFIG\",paramsEx);\n    debug.warning(\"problem creating auth instance\",e);\n  }\ncatch (  AMConfigurationException e) {\n    errorMsg=getErrorString(e);\n    String[] paramsEx={currentRealm,name,errorMsg};\n    logEvent(\"AUTH_CONFIGURATION_EXCEPTION_CREATE_AUTH_CONFIG\",paramsEx);\n    debug.warning(\"problem creating auth instance\",e);\n  }\n  if (errorMsg != null) {\n    throw new AMConsoleException(errorMsg);\n  }\n}\n", "docstring": "creates a new named authentication configuration object . this object will be used by the various objects for authentication .", "partition": "test"}
{"idx": "4892", "code": "public String classifierTipText(){\n  return \"The base classifier to be used.\";\n}\n", "docstring": "returns the tip text for this property", "partition": "test"}
{"idx": "4893", "code": "public WritableRaster createWritableChild(int x,int y,int width,int height,int x0,int y0,int[] bandList){\n  if (x < this.minX) {\n    throw new RasterFormatException(\"x lies outside the raster\");\n  }\n  if (y < this.minY) {\n    throw new RasterFormatException(\"y lies outside the raster\");\n  }\n  if ((x + width < x) || (x + width > this.minX + this.width)) {\n    throw new RasterFormatException(\"(x + width) is outside of Raster\");\n  }\n  if ((y + height < y) || (y + height > this.minY + this.height)) {\n    throw new RasterFormatException(\"(y + height) is outside of Raster\");\n  }\n  SampleModel sm;\n  if (bandList != null) {\n    sm=sampleModel.createSubsetSampleModel(bandList);\n  }\n else {\n    sm=sampleModel;\n  }\n  int deltaX=x0 - x;\n  int deltaY=y0 - y;\n  return new BytePackedRaster(sm,dataBuffer,new Rectangle(x0,y0,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),this);\n}\n", "docstring": "creates a writable subraster given a region of the raster . the x and y coordinates specify the horizontal and vertical offsets from the upper - left corner of this raster to the upper - left corner of the subraster . the bandlist is ignored . a translation to the subraster may also be specified . note that the subraster will reference the same databuffer as the parent raster , but using different offsets .", "partition": "test"}
{"idx": "4894", "code": "private void sendBuffer() throws IOException {\n  buf.flip();\n  send(buf,buf.remaining());\n  buf=null;\n}\n", "docstring": "send all local - buffered data to server .", "partition": "test"}
{"idx": "4895", "code": "public void callEvent(Event event){\n  if (event.isAsynchronous()) {\n    if (Thread.holdsLock(this)) {\n      throw new IllegalStateException(event.getEventName() + \" cannot be triggered asynchronously from inside synchronized code.\");\n    }\n    if (server.isPrimaryThread()) {\n      throw new IllegalStateException(event.getEventName() + \" cannot be triggered asynchronously from primary server thread.\");\n    }\n    fireEvent(event);\n  }\n else {\nsynchronized (this) {\n      fireEvent(event);\n    }\n  }\n}\n", "docstring": "calls an event with the given details . < p > this method only synchronizes when the event is not asynchronous .", "partition": "test"}
{"idx": "4896", "code": "@Nullable private static PsiFile findFileToOpen(@NotNull List<PsiFile> files){\n  PsiFile bestFile=null;\n  FolderConfiguration bestConfig=null;\n  for (  PsiFile file : files) {\n    PsiDirectory qualifiedDirectory=file.getParent();\n    assert qualifiedDirectory != null : \"Resource file\'s parent directory cannot be null\";\n    FolderConfiguration config=FolderConfiguration.getConfigForFolder(qualifiedDirectory.getName());\n    if (bestConfig == null || config == null || config.compareTo(bestConfig) < 0) {\n      bestConfig=config;\n      bestFile=file;\n    }\n  }\n  return bestFile;\n}\n", "docstring": "returns the best configuration of a particular resource given a set of multiple configurations of the same resource .", "partition": "test"}
{"idx": "4897", "code": "protected boolean areEqual(String string1,String string2,boolean caseMatters){\n  return (caseMatters && string1.equals(string2)) || (!caseMatters && string1.equalsIgnoreCase(string2));\n}\n", "docstring": "compares the two strings .", "partition": "test"}
{"idx": "4898", "code": "protected void populateBlob(int id,byte[] baseContent,int requiredSize) throws SQLException {\n  Connection con=getConnectionViaDriverManager();\n  CallableStatement cstmt=null;\n  try {\n    cstmt=con.prepareCall(EXECUTE_FILL_BINARY_BLOB);\n    cstmt.setInt(1,id);\n    cstmt.setBytes(2,baseContent);\n    cstmt.setInt(3,requiredSize);\n    cstmt.execute();\n  }\n  finally {\n    closeQuietly(cstmt);\n    closeQuietly(con);\n  }\n}\n", "docstring": "populates a ( segmented ) blob using the fill_binary_blob stored procedure", "partition": "test"}
{"idx": "4899", "code": "public void makeImmutable(){\n  if (mutable) {\n    if (results != null) {\n      int length=results.size();\n      for (int i=0; i < length; i++) {\n        Result result=(Result)results.get(i);\n        result.makeImmutable();\n      }\n      results=Collections.unmodifiableList(results);\n    }\n    mutable=false;\n  }\n}\n", "docstring": "makes the object immutable", "partition": "test"}
{"idx": "4900", "code": "public Statement isNull(){\n  statement.append(\" IS NULL\");\n  return this;\n}\n", "docstring": "appending the is null operator clause .", "partition": "test"}
{"idx": "4901", "code": "public void clear(){\n  processQueue();\n  hash.clear();\n}\n", "docstring": "remove all mappings from this cache .", "partition": "test"}
{"idx": "4902", "code": "private void updateFavoriteStation(){\n  String showString=null;\n  if (FmRadioStation.isFavoriteStation(mContext,mCurrentStation)) {\n    String stationName=FmRadioStation.getStationName(mContext,mCurrentStation,FmRadioStation.STATION_TYPE_FAVORITE);\n    FmRadioStation.updateStationToDb(mContext,stationName,FmRadioStation.STATION_TYPE_SEARCHED,mCurrentStation);\n    mButtonAddToFavorite.setImageResource(R.drawable.btn_fm_favorite_off_selector);\n    mTextStationName.setText(\"\");\n    showString=mProjectStringExt.getProjectString(mContext,R.string.toast_channel_deleted,R.string.toast_channel_deleted1);\n  }\n else {\n    String stationName=FmRadioStation.getStationName(mContext,mCurrentStation,FmRadioStation.STATION_TYPE_SEARCHED);\n    if (FmRadioStation.isStationExist(mContext,mCurrentStation,FmRadioStation.STATION_TYPE_SEARCHED)) {\n      FmRadioStation.updateStationToDb(mContext,stationName,FmRadioStation.STATION_TYPE_FAVORITE,mCurrentStation);\n    }\n else {\n      FmRadioStation.insertStationToDb(mContext,stationName,mCurrentStation,FmRadioStation.STATION_TYPE_FAVORITE);\n    }\n    mButtonAddToFavorite.setImageResource(R.drawable.btn_fm_favorite_on_selector);\n    mTextStationName.setText(stationName);\n    showString=mProjectStringExt.getProjectString(mContext,R.string.toast_channel_added,R.string.toast_channel_added1);\n  }\n  showToast(showString);\n}\n", "docstring": "update the favorite ui state", "partition": "test"}
{"idx": "4903", "code": "public int addAllAbsent(Collection<? extends E> c){\n  Object[] cs=c.toArray();\n  if (cs.length == 0)   return 0;\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    Object[] elements=getArray();\n    int len=elements.length;\n    int added=0;\n    for (int i=0; i < cs.length; ++i) {\n      Object e=cs[i];\n      if (indexOf(e,elements,0,len) < 0 && indexOf(e,cs,0,added) < 0)       cs[added++]=e;\n    }\n    if (added > 0) {\n      Object[] newElements=Arrays.copyOf(elements,len + added);\n      System.arraycopy(cs,0,newElements,len,added);\n      setArray(newElements);\n    }\n    return added;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "appends all of the elements in the specified collection that are not already contained in this list , to the end of this list , in the order that they are returned by the specified collection \"'\" s iterator .", "partition": "test"}
{"idx": "4904", "code": "public Iterator<Capability> dependencies(){\n  return m_Dependencies.iterator();\n}\n", "docstring": "returns an iterator over the stored dependencies", "partition": "test"}
{"idx": "4905", "code": "public static void notifyTicket(Context c,@NonNull Ticket t,boolean keepNotification){\n  String text;\n  String ticker;\n  int smallIcon;\n  int largeIcon;\n  int status;\nswitch (TicketsAdapter.getValidityStatus(t.getStatus(),t.getValidTo())) {\ncase TicketProvider.Tickets.STATUS_VALID:\ncase TicketProvider.Tickets.STATUS_VALID_EXPIRING:\n    text=c.getString(R.string.notif_valid_text,FormatUtil.formatDateTimeDifference(t.getValidTo()));\n  ticker=c.getString(R.string.notif_valid_ticker);\nsmallIcon=R.drawable.notification_small_ready;\nlargeIcon=R.drawable.notification_big_ready;\nstatus=TicketProvider.Tickets.STATUS_VALID_EXPIRING;\nbreak;\ncase TicketProvider.Tickets.STATUS_EXPIRING:\ncase TicketProvider.Tickets.STATUS_EXPIRING_EXPIRED:\ntext=c.getString(R.string.notif_expiring_text,FormatUtil.formatTime(t.getValidTo()));\nticker=c.getString(R.string.notif_expiring_ticker);\nsmallIcon=R.drawable.notification_small_warning;\nlargeIcon=R.drawable.notification_big_warning;\nstatus=TicketProvider.Tickets.STATUS_EXPIRING_EXPIRED;\nbreak;\ncase TicketProvider.Tickets.STATUS_EXPIRED:\ntext=c.getString(R.string.notif_expired_text,FormatUtil.formatTime(t.getValidTo()));\nticker=c.getString(R.string.notif_expired_ticker);\nsmallIcon=R.drawable.notification_small_expired;\nlargeIcon=R.drawable.notification_big_expired;\nstatus=TicketProvider.Tickets.STATUS_EXPIRED;\nbreak;\ndefault :\nreturn;\n}\nIntent intent=new Intent(c,WearableService.class);\nintent.setAction(\"sent_notification_to_wear\");\nintent.putExtra(\"ticket\",t);\nintent.putExtra(\"status\",status);\nc.startService(intent);\nIntent i=new Intent(c,MainActivity.class);\ni.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\ni.putExtra(MainActivity.EXTRA_TICKET_ID,t.getId());\nPendingIntent openIntent=PendingIntent.getActivity(c,t.getNotificationId(),i,PendingIntent.FLAG_CANCEL_CURRENT);\nIntent i2=new Intent(c,MainActivity.class);\ni2.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);\ni2.putExtra(MainActivity.EXTRA_TICKET_ID,t.getId());\ni2.putExtra(MainActivity.EXTRA_SHOW_SMS,true);\nPendingIntent showSmsIntent=PendingIntent.getActivity(c,t.getNotificationId() + 1000,i2,PendingIntent.FLAG_CANCEL_CURRENT);\nList<Action> actions=new ArrayList<Action>();\nactions.add(new Action(R.drawable.notification_show_sms,R.string.notif_show_sms,showSmsIntent));\nList<String> rows=new ArrayList<String>();\nrows.add(text);\nrows.add(c.getString(R.string.tickets_valid_from) + \": \" + FormatUtil.formatDateTime(t.getValidFrom()));\nrows.add(c.getString(R.string.tickets_code) + \": \" + t.getHash());\nfireNotification(c,t.getNotificationId(),openIntent,c.getString(R.string.application_name),text,rows,t.getCity(),ticker,smallIcon,largeIcon,actions,keepNotification);\n}\n", "docstring": "posts notification about new sms ticket .", "partition": "test"}
{"idx": "4906", "code": "public final static int parseInt(String str){\n  char c=str.charAt(0);\n  int length=str.length();\n  boolean negative=(c == '-');\n  int offset=1;\n  if (negative) {\n    if (length == 1 || length > 10) {\n      return Integer.parseInt(str);\n    }\n    c=str.charAt(offset++);\n  }\n else {\n    if (length > 9) {\n      return Integer.parseInt(str);\n    }\n  }\n  if (c > '9' || c < '0') {\n    return Integer.parseInt(str);\n  }\n  int num=c - '0';\n  if (offset < length) {\n    c=str.charAt(offset++);\n    if (c > '9' || c < '0') {\n      return Integer.parseInt(str);\n    }\n    num=(num * 10) + (c - '0');\n    if (offset < length) {\n      c=str.charAt(offset++);\n      if (c > '9' || c < '0') {\n        return Integer.parseInt(str);\n      }\n      num=(num * 10) + (c - '0');\n      if (offset < length) {\n        do {\n          c=str.charAt(offset++);\n          if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n          }\n          num=(num * 10) + (c - '0');\n        }\n while (offset < length);\n      }\n    }\n  }\n  return negative ? -num : num;\n}\n", "docstring": "helper method to ( more ) efficiently parse integer numbers from string values .", "partition": "test"}
{"idx": "4907", "code": "@Deprecated public static <T>T executeWithBackOff(AbstractGoogleClientRequest<T> client,String error,Object... errorArgs) throws IOException, InterruptedException {\n  return executeWithBackOff(client,String.format(error,errorArgs));\n}\n", "docstring": "execute a bq request with exponential backoff and return the result .", "partition": "test"}
{"idx": "4908", "code": "private void checkServerResponseCode(HttpURLConnection urlConnection) throws RequestFailureException {\n  try {\n    if (urlConnection.getResponseCode() != 200) {\n      throw new RequestFailureException(\"Received \" + urlConnection.getResponseCode() + \" code instead of 200 (OK) from the server.  Aborting.\");\n    }\n  }\n catch (  IOException e) {\n    throw new RequestFailureException(\"Failed to read response code from server: \",e);\n  }\n}\n", "docstring": "confirms that the omaha server sent back an \" ok \" code .", "partition": "test"}
{"idx": "4909", "code": "public static void addResourceSource(ResourceSource source){\n  ALL_RESOURCE_SOURCES.add(source);\n}\n", "docstring": "adds a new resource source . might be used by plugins etc .", "partition": "test"}
{"idx": "4910", "code": "private void commitChanges(){\n  hopfieldPropsPanel.commitChanges();\n  inputPanel.commitChanges();\n}\n", "docstring": "commit all changes made in the dialog to the model .", "partition": "test"}
{"idx": "4911", "code": "private boolean connect_to_target(PlaPointInt p_from_point){\n  if (nearest_target_item != null && target_set != null && !target_set.contains(nearest_target_item)) {\n    nearest_target_item=null;\n  }\n  if (nearest_target_item == null || !nearest_target_item.shares_net_no(net_nos)) {\n    return false;\n  }\n  boolean route_completed=false;\n  PlaPointInt connection_point=null;\n  if (nearest_target_item instanceof BrdAbit) {\n    BrdAbit target=(BrdAbit)nearest_target_item;\n    connection_point=target.center_get();\n  }\n else   if (nearest_target_item instanceof BrdTracep) {\n    return r_board.connect_to_trace(p_from_point,(BrdTracep)nearest_target_item,pen_half_width_arr[layer_active_no],clearance_class);\n  }\n else   if (nearest_target_item instanceof BrdAreaConduction) {\n    connection_point=p_from_point;\n  }\n  if (connection_point != null) {\n    route_completed=itera_connect(p_from_point,connection_point);\n  }\n  return route_completed;\n}\n", "docstring": "if p_from_point is already on a target item , a connection to the target is made and true returned .", "partition": "test"}
{"idx": "4912", "code": "public boolean onGenericMotionEvent(MotionEvent ev){\n  if ((ev.getSource() & InputDevice.SOURCE_CLASS_POINTER) == InputDevice.SOURCE_CLASS_POINTER) {\n    int action=ev.getAction();\nswitch (action & MotionEvent.ACTION_MASK) {\ncase MotionEvent.ACTION_SCROLL:\n      float vScroll=ev.getAxisValue(MotionEvent.AXIS_VSCROLL);\n    if (vScroll > 0) {\n      if (mDeckView.ensureFocusedTask()) {\n        mDeckView.focusNextTask(true,false);\n      }\n    }\n else {\n      if (mDeckView.ensureFocusedTask()) {\n        mDeckView.focusNextTask(false,false);\n      }\n    }\n  return true;\n}\n}\nreturn false;\n}\n", "docstring": "handles generic motion events", "partition": "test"}
{"idx": "4913", "code": "public boolean addClass(OwlClass targetClass){\n  targetClass.addQCRestriction(this);\n  return qcClasses.add(targetClass);\n}\n", "docstring": "add \" onclass c \" information , and tell c to point back here .", "partition": "test"}
{"idx": "4914", "code": "public void editElement(final Object element,final String columnPropertyName){\n  final int columnIndex=TableViewerUtils.columnPropertyNameToColumnIndex(columnPropertyName,true,viewer);\n  viewer.editElement(element,columnIndex);\n}\n", "docstring": "initiates cell editing on the specified element . the column that is edited is specified by property name .", "partition": "test"}
{"idx": "4915", "code": "@Override public boolean useBufferPerWindow(){\n  return !Win32GraphicsEnvironment.isDWMCompositionEnabled();\n}\n", "docstring": "there are two reasons why we don \"'\" t use buffer per window when vista \"'\" s dwm ( aka aero ) is enabled : - since with dwm all windows are already double - buffered , the application doesn \"'\" t get expose events so we don \"'\" t get to use our true back - buffer , wasting memory and performance ( this is valid for both d3d and gdi pipelines ) - in some cases with buffer per window enabled it is possible for the paint manager to redirect rendering to the screen for some operations ( like copyarea ) , and since bpw uses its own bufferstrategy the d3d onscreen rendering support is disabled and rendering goes through gdi . this doesn \"'\" t work well with vista \"'\" s dwm since one can not perform gdi and d3d operations on the same surface ( see 6630702 for more info ) note : even though dwm composition state can change during the lifetime of the application it is a rare event , and it is more often that it is temporarily disabled ( because of some app ) than it is getting permanently enabled so we can live with this approach without the complexity of dwm state listeners and such . this can be revisited if proved otherwise .", "partition": "test"}
{"idx": "4916", "code": "private void serializable(final IsolationLevels level) throws Exception {\n  clear(store);\n  final ValueFactory vf=store.getValueFactory();\n  final IRI subj=vf.createIRI(\"http://test#s\");\n  final IRI pred=vf.createIRI(\"http://test#p\");\n  RepositoryConnection prep=store.getConnection();\n  try {\n    prep.begin(level);\n    prep.add(subj,pred,vf.createLiteral(1));\n    prep.commit();\n  }\n  finally {\n    prep.close();\n  }\n  final CountDownLatch start=new CountDownLatch(2);\n  final CountDownLatch observed=new CountDownLatch(2);\n  Thread t1=incrementBy(start,observed,level,vf,subj,pred,3);\n  Thread t2=incrementBy(start,observed,level,vf,subj,pred,5);\n  t2.start();\n  t1.start();\n  t2.join();\n  t1.join();\n  assertNotFailed();\n  RepositoryConnection check=store.getConnection();\n  try {\n    check.begin(level);\n    Literal lit=readLiteral(check,subj,pred);\n    int val=lit.intValue();\n    if (val != 4 && val != 6) {\n      assertEquals(9,val);\n    }\n    check.commit();\n  }\n  finally {\n    check.close();\n  }\n}\n", "docstring": "two transactions read a value and replace it", "partition": "test"}
{"idx": "4917", "code": "public static Array listToArrayRemoveEmpty(String list,char delimiter){\n  int len=list.length();\n  ArrayImpl array=new ArrayImpl();\n  if (len == 0)   return array;\n  int last=0;\n  for (int i=0; i < len; i++) {\n    if (list.charAt(i) == delimiter) {\n      if (last < i)       array._append(list.substring(last,i));\n      last=i + 1;\n    }\n  }\n  if (last < len)   array._append(list.substring(last));\n  return array;\n}\n", "docstring": "casts a list to array object remove empty elements", "partition": "test"}
{"idx": "4918", "code": "public static <T extends Object & java.lang.Comparable<? super T>>T min(Collection<? extends T> collection){\n  Iterator<? extends T> it=collection.iterator();\n  T min=it.next();\n  while (it.hasNext()) {\n    T next=it.next();\n    if (min.compareTo(next) > 0) {\n      min=next;\n    }\n  }\n  return min;\n}\n", "docstring": "searches the specified collection for the minimum element .", "partition": "test"}
{"idx": "4919", "code": "@Override public ServerHeartbeat server(String address,int port,boolean isSSL,String clusterId,String displayName,boolean isDynamic){\n  Objects.requireNonNull(address);\n  Objects.requireNonNull(clusterId);\n  if (address.isEmpty()) {\n    address=\"127.0.0.1\";\n  }\n  ClusterHeartbeat cluster=createCluster(clusterId);\n  ServerHeartbeat server;\n  if (isDynamic) {\n    server=cluster.createDynamicServer(address,port,isSSL);\n  }\n else {\n    server=cluster.createServer(address,port,isSSL);\n  }\n  if (displayName != null) {\n    server.setDisplayName(displayName);\n  }\n  if (!isDynamic) {\n    cluster.addSeedServer(server);\n  }\n  return server;\n}\n", "docstring": "create an external / configured server", "partition": "test"}
{"idx": "4920", "code": "public void testToString(){\n  LinkedBlockingQueue q=populatedQueue(SIZE);\n  String s=q.toString();\n  for (int i=0; i < SIZE; ++i) {\n    assertTrue(s.indexOf(String.valueOf(i)) >= 0);\n  }\n}\n", "docstring": "tostring contains tostrings of elements", "partition": "test"}
{"idx": "4921", "code": "private void findClub(){\n  if (ce() == null) {\n    return;\n  }\n  String title=Messages.getString(\"FiringDisplay.FindClubDialog.title\");\n  String body=Messages.getString(\"FiringDisplay.FindClubDialog.message\");\n  if (!clientgui.doYesNoDialog(title,body)) {\n    return;\n  }\n  attacks.removeAllElements();\n  attacks.addElement(new FindClubAction(cen));\n  ready();\n}\n", "docstring": "the entity spends the rest of its turn finding a club", "partition": "test"}
{"idx": "4922", "code": "public void test_allocationContexts() throws IOException {\n  final Journal store=(Journal)getStore();\n  try {\n    final RWStrategy bs=(RWStrategy)store.getBufferStrategy();\n    final RWStore rw=bs.getStore();\n    final IAllocationContext allocContext1=rw.newAllocationContext(true);\n    final IAllocationContext allocContext2=rw.newAllocationContext(true);\n    final int sze=650;\n    final byte[] buf=new byte[sze + 4];\n    r.nextBytes(buf);\n    final long addr1a=bs.write(ByteBuffer.wrap(buf),allocContext1);\n    final long addr1b=bs.write(ByteBuffer.wrap(buf),allocContext1);\n    rw.detachContext(allocContext1);\n    final long addr2a=bs.write(ByteBuffer.wrap(buf),allocContext2);\n    final long addr2b=bs.write(ByteBuffer.wrap(buf),allocContext2);\n    rw.detachContext(allocContext2);\n    try {\n      bs.write(ByteBuffer.wrap(buf),allocContext1);\n      fail(\"Should have failed to re-use detached context\");\n    }\n catch (    IllegalStateException ise) {\n    }\n    final IAllocationContext allocContext3=rw.newAllocationContext(true);\n    final long addr1c=bs.write(ByteBuffer.wrap(buf),allocContext3);\n    assertTrue(\"allocator re-use\",bs.getPhysicalAddress(addr1c) > bs.getPhysicalAddress(addr2b));\n    bs.delete(addr1c,allocContext3);\n    final long addr1d=bs.write(ByteBuffer.wrap(buf),allocContext3);\n    assertTrue(\"re-allocation\",addr1c == addr1d);\n    rw.detachContext(allocContext3);\n    store.commit();\n    bs.delete(addr1d);\n    final long addr1e=bs.write(ByteBuffer.wrap(buf));\n    assertTrue(\"deferred-delete\",addr1e != addr1d);\n    store.commit();\n  }\n  finally {\n    store.destroy();\n  }\n}\n", "docstring": "from a rwstore , creates multiple allocationcontexts to isolate updates , re - allocate storage and protect against by concurrent contexts . this is the core functionality required to support transactions . if an allocation is made for an allocationcontext then this will result in a contextallocation object being created in the rwstore within which \" shadow \" allocations can be made . if such a shadow allocation is deleted , within the allocationcontext , then this can be removed immediately .", "partition": "test"}
{"idx": "4923", "code": "public PDFXref(byte[] line){\n  if (line == null) {\n    id=-1;\n    generation=-1;\n  }\n else {\n    id=Integer.parseInt(new String(line,0,10));\n    generation=Integer.parseInt(new String(line,11,5));\n  }\n  compressed=false;\n}\n", "docstring": "create a new pdfxref , given a sequence of bytes representing the fixed - width cross reference table line", "partition": "test"}
{"idx": "4924", "code": "public static String[] makeStrings(Collection<InetAddress> addrs){\n  String[] result=new String[addrs.size()];\n  int i=0;\n  for (  InetAddress addr : addrs) {\n    result[i++]=addr.getHostAddress();\n  }\n  return result;\n}\n", "docstring": "create a string array of host addresses from a collection of inetaddresses", "partition": "test"}
{"idx": "4925", "code": "public static void showProfile(Activity activity,String pilotId,@Nullable HashMap<String,String> extras){\n  if ((pilotId == null || pilotId.isEmpty()) && AirMap.hasValidAuthenticatedUser()) {\n    pilotId=AirMap.getUserId();\n  }\n  Intent intent=new Intent(activity,ProfileActivity.class);\n  intent.putExtra(ProfileActivity.ARG_PILOT_ID,pilotId);\n  if (extras != null) {\n    intent.putExtra(CreateFlightActivity.KEY_VALUE_EXTRAS,extras);\n  }\n  activity.startActivity(intent);\n}\n", "docstring": "display the authenticated pilot \"'\" s profile", "partition": "test"}
{"idx": "4926", "code": "public SmoothMoves(){\n  cycleStart=System.nanoTime() / 1000000;\n  startTimer(currentResolution);\n}\n", "docstring": "creates a new instance of smoothanimation", "partition": "test"}
{"idx": "4927", "code": "public static void updatePriceLists(Properties ctx,ProductBean productBean,String trxName) throws OperationException {\n  ArrayList<ProductBean> list=productBean.getProductBeanList();\n  if (list != null) {\n    int productId=productBean.getProductId();\n    Iterator<ProductBean> iter=list.iterator();\n    while (iter.hasNext()) {\n      ProductBean bean=iter.next();\n      int priceListId=bean.getPriceListId();\n      BigDecimal stdPrice=bean.getStdPrice();\n      BigDecimal listPrice=bean.getListPrice();\n      BigDecimal limitPrice=bean.getLimitPrice();\n      MPriceList priceList=MPriceList.get(ctx,priceListId,trxName);\n      if (priceList.isTaxIncluded()) {\n        stdPrice=bean.getStdPriceIncl();\n        listPrice=bean.getListPriceIncl();\n        limitPrice=bean.getLimitPriceIncl();\n      }\n      updatePriceLists(ctx,productId,priceListId,stdPrice,listPrice,limitPrice,trxName);\n    }\n  }\n}\n", "docstring": "updates product price . the product and price list are obtained from the product bean . the latest price list version is used .", "partition": "test"}
{"idx": "4928", "code": "private String checkDependencies(ModuleDescriptor md,HashMap<String,ModuleDescriptor> modlist){\n  logger.debug(\"Checking dependencies of \" + md.getId());\n  ModuleInterface[] requires=md.getRequires();\n  if (requires != null) {\n    for (    ModuleInterface req : requires) {\n      String res=checkOneDependency(md,req,modlist);\n      if (!res.isEmpty()) {\n        return res;\n      }\n    }\n  }\n  return \"\";\n}\n", "docstring": "check that the dependencies are satisfied .", "partition": "test"}
{"idx": "4929", "code": "public void deserializeFunnel(List<Object> serializedFunnel){\n  Set<Object> funnelStepAccumulator=new HashSet<>();\n  for (  Object e : serializedFunnel) {\n    if (e != null) {\n      funnelStepAccumulator.add(e);\n    }\n else {\n      funnelSteps.add(new HashSet<>(funnelStepAccumulator));\n      funnelStepAccumulator.clear();\n    }\n  }\n}\n", "docstring": "deserialize funnel steps . have to deserialize the null separated list .", "partition": "test"}
{"idx": "4930", "code": "public static String appendParameter(CtClass type,String descriptor){\n  int i=descriptor.indexOf(')');\n  if (i < 0)   return descriptor;\n else {\n    StringBuffer newdesc=new StringBuffer();\n    newdesc.append(descriptor.substring(0,i));\n    toDescriptor(newdesc,type);\n    newdesc.append(descriptor.substring(i));\n    return newdesc.toString();\n  }\n}\n", "docstring": "appends a parameter type to the parameter list represented by the given descriptor . the appended parameter becomes the last parameter .", "partition": "test"}
{"idx": "4931", "code": "public void addCatchClause(CatchClause clause){\n  assertNotNull(clause);\n  if (catchClauses == null) {\n    catchClauses=new ArrayList<CatchClause>();\n  }\n  catchClauses.add(clause);\n  clause.setParent(this);\n}\n", "docstring": "add a catch - clause to the end of the list , and sets its parent to this node .", "partition": "test"}
{"idx": "4932", "code": "public static void streamContentToBrowser(HttpServletResponse response,byte[] bytes,String contentType,String fileName) throws IOException {\n  setResponseBrowserProxyNoCache(response);\n  response.setContentLength(bytes.length);\n  if (contentType != null) {\n    response.setContentType(contentType);\n  }\n  if (fileName != null) {\n    response.setHeader(\"Content-Disposition\",\"attachment;filename=\\\"\" + fileName + \"\\\"\");\n  }\n  OutputStream out=response.getOutputStream();\n  InputStream in=new ByteArrayInputStream(bytes);\n  try {\n    streamContent(out,in,bytes.length);\n  }\n catch (  IOException e) {\n    in.close();\n    out.close();\n    throw e;\n  }\n  in.close();\n  out.flush();\n  out.close();\n}\n", "docstring": "stream an array of bytes to the browser this method will close the servletoutputstream when finished", "partition": "test"}
{"idx": "4933", "code": "public void unlock(Object key){\n  String uid=String.valueOf(key);\n  Transaction tr=lockedUIDHashMap.get(uid);\n  if (tr == null) {\n    return;\n  }\n  try {\n    tr.commit();\n  }\n catch (  Exception e) {\n    logger.warn(\"Failed to commit transaction and unlocking the object, ignoring\",e);\n  }\n finally {\n    lockedUIDHashMap.remove(uid);\n  }\n}\n", "docstring": "unlocks the given lock on the key", "partition": "test"}
{"idx": "4934", "code": "public List<Order> fetchOrders(int startIndex,int num){\n  int endIndex=startIndex + num > orders.size() ? orders.size() : startIndex + num;\n  return orders.subList(startIndex,endIndex);\n}\n", "docstring": "returns a slice of orders", "partition": "test"}
{"idx": "4935", "code": "public boolean ensureSchemaAgreement(){\n  long start=System.currentTimeMillis();\n  Map<String,List<String>> schemas=null;\n  while (System.currentTimeMillis() - start < DbClientContext.MAX_SCHEMA_WAIT_MS) {\n    try {\n      log.info(\"sleep for {} seconds before checking schema versions.\",DbClientContext.SCHEMA_RETRY_SLEEP_MILLIS / 1000);\n      Thread.sleep(DbClientContext.SCHEMA_RETRY_SLEEP_MILLIS);\n    }\n catch (    InterruptedException ex) {\n      log.warn(\"Interrupted during sleep\");\n    }\n    schemas=getSchemaVersions();\n    if (schemas.size() > 2) {\n      continue;\n    }\n    if (schemas.size() == 1) {\n      if (!schemas.containsKey(StorageProxy.UNREACHABLE)) {\n        return false;\n      }\n else {\n        continue;\n      }\n    }\n    if (schemas.containsKey(StorageProxy.UNREACHABLE)) {\n      return true;\n    }\n  }\n  log.error(\"Unable to converge schema versions {}\",schemas);\n  throw new IllegalStateException(\"Unable to converge schema versions\");\n}\n", "docstring": "try to reach a schema agreement among all the reachable nodes", "partition": "test"}
{"idx": "4936", "code": "void clear(){\n  stack.clear();\n}\n", "docstring": "removes all of the elements from enclosed list .", "partition": "test"}
{"idx": "4937", "code": "private TileStore(final SpriteStore store){\n  this.store=store;\n  tiles=new ArrayList<Sprite>();\n  tiles.add(store.getEmptySprite());\n}\n", "docstring": "create a tile store with a specific sprite store .", "partition": "test"}
{"idx": "4938", "code": "public static String comparableQualifier(String qualifier){\n  int i=_QUALIFIERS.indexOf(qualifier);\n  return i == -1 ? _QUALIFIERS.size() + \"-\" + qualifier : String.valueOf(i);\n}\n", "docstring": "returns a comparable value for a qualifier . < p / > this method both takes into account the ordering of known qualifiers as well as lexical ordering for unknown qualifiers . < p / > just returning an integer with the index here is faster , but requires a lot of if / then / else to check for - 1 or qualifiers . size and then resort to lexical ordering . most comparisons are decided by the first character , so this is still fast . if more characters are needed then it requires a lexical sort anyway .", "partition": "test"}
{"idx": "4939", "code": "public static Object evaluate(Object context,Object self,String expr,List<String> engineConfigs) throws CWLExpressionException {\n  String trimmedExpr=StringUtils.trim(expr);\n  if (trimmedExpr.startsWith(\"$\")) {\n    trimmedExpr=trimmedExpr.substring(1);\n  }\n  String function=trimmedExpr;\n  if (trimmedExpr.startsWith(\"{\")) {\n    function=\"(function()%expr)()\";\n    function=function.replace(\"%expr\",trimmedExpr);\n  }\n  Context cx=Context.enter();\n  cx.setOptimizationLevel(OPTIMIZATION_LEVEL);\n  cx.setMaximumInterpreterStackDepth(MAX_STACK_DEPTH);\n  cx.setClassShutter(new CWLExpressionDenyAllClassShutter());\n  try {\n    Scriptable globalScope=cx.initStandardObjects();\n    if (engineConfigs != null) {\n      for (int i=0; i < engineConfigs.size(); i++) {\n        Reader engineConfigReader=new StringReader(engineConfigs.get(i));\n        cx.evaluateReader(globalScope,engineConfigReader,\"engineConfig_\" + i + \".js\",1,null);\n      }\n    }\n    putToScope(EXPR_CONTEXT_NAME,context,cx,globalScope);\n    putToScope(EXPR_SELF_NAME,self,cx,globalScope);\n    Scriptable resultScope=cx.newObject(globalScope);\n    resultScope.setPrototype(globalScope);\n    resultScope.setParentScope(globalScope);\n    Object result=cx.evaluateString(resultScope,function,\"script\",1,null);\n    if (result == null || result instanceof Undefined) {\n      return null;\n    }\n    Object wrappedResult=Context.javaToJS(result,globalScope);\n    putToScope(\"$result\",wrappedResult,cx,globalScope);\n    ScriptableObject.putProperty(globalScope,\"$result\",wrappedResult);\n    String finalFunction=\"(function() { \" + \"           var result = $result;\" + \"           var type = result instanceof Array? \\\"array\\\" : typeof result;\"+ \"           return JSON.stringify({ \\\"result\\\" : result, \\\"type\\\" : type }); \"+ \"     })()\";\n    Scriptable wrapScope=cx.newObject(globalScope);\n    wrapScope.setPrototype(globalScope);\n    wrapScope.setParentScope(globalScope);\n    result=cx.evaluateString(wrapScope,finalFunction,\"script\",1,null);\n    return castResult(result);\n  }\n catch (  Exception e) {\n    String msg=String.format(\"Failed evaluating expression %s.\",expr);\n    throw new CWLExpressionException(msg,e);\n  }\n finally {\n    Context.exit();\n  }\n}\n", "docstring": "evaluate js script ( function or statement )", "partition": "test"}
{"idx": "4940", "code": "private void token(char c) throws ConfigurationException, IOException {\n  int t=st.nextToken();\n  if (t != c) {\n    if (c == \'\"\') {\n      syntax(\"a String\");\n    }\n else {\n      syntax(new String(new char[]{\'\\\'\',c,+\'\\\'\'}));\n    }\n  }\n}\n", "docstring": "parses the next token from the stream , and generates a syntax error if the token does not equal the specified character . expands references to system properties if the token is a string .", "partition": "test"}
{"idx": "4941", "code": "public static boolean isJarURL(URL url){\n  String protocol=url.getProtocol();\n  return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol)|| URL_PROTOCOL_WSJAR.equals(protocol));\n}\n", "docstring": "determine whether the given url points to a resource in a jar file , that is , has protocol \" jar \" , \" zip \" , \" vfszip \" or \" wsjar \" .", "partition": "test"}
{"idx": "4942", "code": "public boolean equals(Object o){\n  if (o instanceof LDAPUsers) {\n    LDAPUsers g=(LDAPUsers)o;\n    if ((selectedUserDNs != null) && (g.selectedUserDNs != null) && (selectedUserDNs.equals(g.selectedUserDNs))) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "indicates whether some other object is \" equal to \" this one .", "partition": "test"}
{"idx": "4943", "code": "protected void applySetTimestamp(Long timestamp) throws SQLException {\n  if (timestamp != null && conn.supportsControlTimestamp()) {\n    if (timestamp.longValue() != currentTimestamp) {\n      currentTimestamp=timestamp.longValue();\n      statement.addBatch(conn.getControlTimestampQuery(timestamp));\n    }\n  }\n}\n", "docstring": "applysettimestamp adds to the batch the query used to change the server timestamp , if needed and if possible ( if the database support such a feature )", "partition": "test"}
{"idx": "4944", "code": "public Accessor(String className,ClassLoader classLoader,Class[] constructorTypes,Object[] constructorArgs){\n  try {\n    fClass=Class.forName(className,true,classLoader);\n  }\n catch (  ClassNotFoundException e) {\n    fail();\n  }\ncatch (  ExceptionInInitializerError e) {\n    fail();\n  }\n  Constructor constructor=null;\n  try {\n    constructor=fClass.getDeclaredConstructor(constructorTypes);\n  }\n catch (  SecurityException e2) {\n    fail();\n  }\ncatch (  NoSuchMethodException e2) {\n    fail();\n  }\n  Assert.isNotNull(constructor);\n  constructor.setAccessible(true);\n  try {\n    fInstance=constructor.newInstance(constructorArgs);\n  }\n catch (  IllegalArgumentException e) {\n    fail();\n  }\ncatch (  InvocationTargetException e) {\n    fail();\n  }\ncatch (  InstantiationException e) {\n    fail();\n  }\ncatch (  IllegalAccessException e) {\n    fail();\n  }\n}\n", "docstring": "creates an accessor for the given class .", "partition": "test"}
{"idx": "4945", "code": "public static List<LoggedMqttMessage> parseMessageLog(final List<String> messages,final ProgressUpdater progress,final long current,final long max) throws SpyException {\n  try {\n    final long startTime=TimeUtils.getMonotonicTime();\n    final int items=messages.size();\n    final long chunkSize=items / 10;\n    final MqttMessageLogParser parser=new MqttMessageLogParser();\n    final List<LoggedMqttMessage> list=new ArrayList<LoggedMqttMessage>();\n    long item=0;\n    long reportAt=1;\n    for (int i=0; i < items; i++) {\n      final String message=messages.get(i);\n      if (progress != null) {\n        if (progress.isCancelled()) {\n          logger.info(\"Task cancelled!\");\n          return null;\n        }\n        item++;\n        if (item % 1000 == 0) {\n          progress.update(current + item,max);\n        }\n      }\n      if ((i > 0) && (i == (chunkSize * reportAt))) {\n        final long currentTime=TimeUtils.getMonotonicTime();\n        final long timeTaken=currentTime - startTime;\n        final long totalTimeExpected=timeTaken * items / i;\n        if (timeTaken > 1000) {\n          logger.info(\"Processed {}%, estimated time left = {}s\",reportAt * 10,(totalTimeExpected - timeTaken) / 1000);\n        }\n        reportAt++;\n      }\n      try {\n        list.add(parser.parse(message));\n      }\n catch (      XMLException e) {\n        logger.error(\"Can\'t process message \" + message,e);\n      }\n    }\n    logger.info(\"Message audit log - parsed {} XML messages\",list.size());\n    return list;\n  }\n catch (  XMLException e) {\n    throw new SpyException(\"Can\'t parse the message audit log file\",e);\n  }\n}\n", "docstring": "parses the given list of xml messages into a list of mqtt message objects .", "partition": "test"}
{"idx": "4946", "code": "public void stop(){\n  duration+=System.currentTimeMillis() - start;\n}\n", "docstring": "ends the bandwidth measurement .", "partition": "test"}
{"idx": "4947", "code": "public void addRow(Object[] row) throws CarbonSortKeyAndGroupByException {\n  int currentSize=entryCount;\n  if (sortBufferSize == currentSize) {\n    LOGGER.debug(\"************ Writing to temp file ********** \");\n    File[] fileList;\n    if (procFiles.size() >= numberOfIntermediateFileToBeMerged) {\nsynchronized (lockObject) {\n        fileList=procFiles.toArray(new File[procFiles.size()]);\n        this.procFiles=new ArrayList<File>(1);\n      }\n      LOGGER.debug(\"Sumitting request for intermediate merging no of files: \" + fileList.length);\n      startIntermediateMerging(fileList);\n    }\n    Object[][] recordHolderListLocal=recordHolderList;\n    try {\n      semaphore.acquire();\n      dataSorterAndWriterExecutorService.submit(new DataSorterAndWriter(recordHolderListLocal));\n    }\n catch (    InterruptedException e) {\n      LOGGER.error(\"exception occurred while trying to acquire a semaphore lock: \" + e.getMessage());\n      throw new CarbonSortKeyAndGroupByException(e.getMessage());\n    }\n    this.recordHolderList=new Object[this.sortBufferSize][];\n    this.entryCount=0;\n  }\n  recordHolderList[entryCount++]=row;\n}\n", "docstring": "this method will be used to add new row", "partition": "test"}
{"idx": "4948", "code": "@Uninterruptible public static Address unwindNativeStackFrame(Address currfp){\n  if (VM.BuildForIA32) {\n    return currfp;\n  }\n  Address callee_fp;\n  Address fp=Magic.getCallerFramePointer(currfp);\n  Address ip;\n  do {\n    callee_fp=fp;\n    ip=Magic.getReturnAddressUnchecked(fp);\n    fp=Magic.getCallerFramePointer(fp);\n  }\n while (!MemoryManager.addressInVM(ip) && fp.NE(StackFrameLayout.getStackFrameSentinelFP()));\n  if (VM.BuildForPowerPC) {\n    return fp;\n  }\n else {\n    return callee_fp;\n  }\n}\n", "docstring": "skip over all frames below currfp with saved code pointers outside of heap ( c frames ) , stopping at the native frame immediately preceding the glue frame which contains the method id of the native method ( this is necessary to allow retrieving the return address of the glue frame ) .", "partition": "test"}
{"idx": "4949", "code": "@Override public PathImpl schemeWalk(String userPath,Map<String,Object> attributes,String filePath,int offset){\n  String canonicalPath;\n  if (offset < filePath.length() && (filePath.charAt(offset) == \'/\' || filePath.charAt(offset) == _separatorChar))   canonicalPath=normalizePath(\"/\",filePath,offset,_separatorChar);\n else   canonicalPath=normalizePath(_pathname,filePath,offset,_separatorChar);\n  return fsWalk(userPath,attributes,canonicalPath);\n}\n", "docstring": "schemewalk is called by path for a scheme lookup like file : / tmp / foo", "partition": "test"}
{"idx": "4950", "code": "public static boolean isMimeTypeImage(String mimeType){\n  return mimeType != null && mimeType.startsWith(\"image/\");\n}\n", "docstring": "checks whether the mime type represents an image media item .", "partition": "test"}
{"idx": "4951", "code": "public FXMessageDialog(final Stage parent,final Parent group){\n  this(parent);\n  content.setCenter(group);\n}\n", "docstring": "messagedialog with custom center node", "partition": "test"}
{"idx": "4952", "code": "public Matrix abs(){\n  Matrix result=new Matrix(m,n);\n  for (int i=0; i < result.A.length; i++) {\n    for (int j=0; j < result.A[i].length; j++)     result.A[i][j]=Math.abs(A[i][j]);\n  }\n  return result;\n}\n", "docstring": "returns a new matrix object , where each value is set to the absolute value", "partition": "test"}
{"idx": "4953", "code": "public void removeAttribute(String attrName) throws SMSException {\n  Set attribute=(Set)attrSet.get(attrName);\n  if (attribute == null) {\n    throw (new SMSException(LdapException.newLdapException(ResultCode.ATTRIBUTE_OR_VALUE_EXISTS,getBundleString(IUMSConstants.SMS_ATTR_OR_VAL_EXISTS)),\"sms-ATTR_OR_VAL_EXISTS\"));\n  }\n  attrSet.remove(attrName);\n  if (modSet == null) {\n    modSet=new HashSet();\n  }\n  BasicAttribute ba=new BasicAttribute(attrName,attribute);\n  for (Iterator items=attribute.iterator(); items.hasNext(); )   ba.add(items.next());\n  modSet.add(new ModificationItem(DirContext.REMOVE_ATTRIBUTE,ba));\n}\n", "docstring": "remove the attribute from the entry .", "partition": "test"}
{"idx": "4954", "code": "@TargetApi(Build.VERSION_CODES.HONEYCOMB) public void snapshot(int cameraId){\n  final int encWidth=768;\n  final int encHeight=432;\n  if (enable.containsKey(cameraId) && !enable.get(cameraId)) {\n    return;\n  }\n  Camera camera=null;\nsynchronized (cameraLock) {\n    try {\n      camera=prepareCamera(cameraId,encWidth,encHeight);\n      if (camera == null) {\n        return;\n      }\n      if (Cfg.DEBUG) {\n        Check.log(TAG + \" (snapshot), cameraId: \" + cameraId);\n      }\n      if (this.surface == null) {\n        int[] surfaceparams=new int[1];\n        GLES20.glGenTextures(1,surfaceparams,0);\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,surfaceparams[0]);\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE);\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE);\n        this.surface=new SurfaceTexture(surfaceparams[0]);\n      }\n      camera.setPreviewTexture(surface);\n      camera.startPreview();\n      camera.setOneShotPreviewCallback(previewCallback);\n      cameraLock.wait();\n    }\n catch (    Exception e) {\n      if (Cfg.DEBUG) {\n        Check.log(TAG + \" (snapshot) ERROR: \" + e);\n      }\n    }\n  }\n}\n", "docstring": "wraps encodecameratompeg ( ) . this is necessary because surfacetexture will try to use the looper in the current thread if one exists , and the cts tests create one on the test thread . < p / > the wrapper propagates exceptions thrown by the worker thread back to the caller . < p / > / tests encoding of avc video from camera input . the output is saved as an mp4 file .", "partition": "test"}
{"idx": "4955", "code": "private static DebuggerException parseExceptionOption(Node node){\n  return new DebuggerException(parseStringOption(node,\"exceptionName\"),parseLongOption(node,\"exceptionCode\"),DebuggerExceptionHandlingAction.convertToHandlingAction(parseIntOption(node,\"handlingAction\")));\n}\n", "docstring": "parses an exception debugger option .", "partition": "test"}
{"idx": "4956", "code": "public Image rotate180Degrees(Image image,boolean maintainOpacity){\n  int[] rgb=image.getRGB();\n  int[] newRGB=new int[rgb.length];\n  int width=image.getWidth();\n  int height=image.getHeight();\n  for (int y=0; y < height; y++) {\n    for (int x=0; x < width; x++) {\n      int destX=width - x - 1;\n      newRGB[destX + (height - y - 1) * width]=rgb[x + y * width];\n    }\n  }\n  return EncodedImage.createFromRGB(newRGB,width,height,!maintainOpacity);\n}\n", "docstring": "rotates the given image by 180 degrees", "partition": "test"}
{"idx": "4957", "code": "public static void updateFinantare(SetGetModel m,String changedColumnName){\n  BigDecimal valCofinantare=SetGetUtil.get_AttrValueAsBigDecimal(m,COLUMNNAME_A_Valoare_Cofinantare);\n  BigDecimal assetCost=SetGetUtil.get_AttrValueAsBigDecimal(m,COLUMNNAME_A_Asset_Cost);\n  BigDecimal valTert=SetGetUtil.get_AttrValueAsBigDecimal(m,COLUMNNAME_A_Valoare_Tert);\n  if (valCofinantare.signum() == 0 && valTert.signum() == 0) {\n    valCofinantare=assetCost;\n    valTert=Env.ZERO;\n  }\n else   if (COLUMNNAME_A_Asset_Cost.equals(changedColumnName)) {\n    valCofinantare=assetCost.subtract(valTert);\n  }\n else   if (COLUMNNAME_A_Valoare_Cofinantare.equals(changedColumnName)) {\n    valTert=assetCost.subtract(valCofinantare);\n  }\n else   if (COLUMNNAME_A_Valoare_Tert.equals(changedColumnName)) {\n    valCofinantare=assetCost.subtract(valTert);\n  }\n else {\n    valTert=assetCost.subtract(valCofinantare);\n  }\n  String tipFinantare=A_TIP_FINANTARE_Cofinantare;\n  if (valTert.signum() == 0) {\n    tipFinantare=A_TIP_FINANTARE_Proprie;\n  }\n else   if (valCofinantare.signum() == 0) {\n    tipFinantare=A_TIP_FINANTARE_Terti;\n  }\n  m.set_AttrValue(COLUMNNAME_A_Tip_Finantare,tipFinantare);\n  m.set_AttrValue(COLUMNNAME_A_Valoare_Cofinantare,valCofinantare);\n  m.set_AttrValue(COLUMNNAME_A_Valoare_Tert,valTert);\n  if (A_TIP_FINANTARE_Proprie.equals(tipFinantare) && SetGetUtil.isPersistent(m)) {\n    m.set_AttrValue(COLUMNNAME_A_FundingMode_ID,null);\n  }\n}\n", "docstring": "update founding mode related fields", "partition": "test"}
{"idx": "4958", "code": "private void displayCalendar(){\n  ListItem listItem=fieldResource.getSelectedItem();\n  if (listItem == null)   return;\n  KeyNamePair pp=new KeyNamePair((Integer)listItem.getValue(),listItem.getLabel());\n  int S_Resource_ID=pp.getKey();\n  m_mAssignment.setS_Resource_ID(S_Resource_ID);\n  Date date=fieldDate.getValue();\n  if (date == null)   date=new Timestamp(System.currentTimeMillis());\n  m_loading=true;\n  schedulePane.recreate(S_Resource_ID,date);\n  m_loading=false;\n  invalidate();\n}\n", "docstring": "display calendar for selected resource , time ( day / week / month ) and date", "partition": "test"}
{"idx": "4959", "code": "public LineString createLineString(CoordinateSequence coordinates){\n  return new LineString(coordinates,this);\n}\n", "docstring": "creates a linestring using the given coordinatesequence . a null or empty coordinatesequence creates an empty linestring .", "partition": "test"}
{"idx": "4960", "code": "public void close(){\n  if (closed.compareAndSet(false,true)) {\n    doClose();\n  }\n}\n", "docstring": "closes this strategy and releases any zookeeper resources ; but keeps the zookeeper instance open", "partition": "test"}
{"idx": "4961", "code": "@Override public boolean connectionAllowed(String eventName){\n  if (!eventName.equals(\"instance\")) {\n    return false;\n  }\n  if (m_listenee != null) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "returns true if , at this time , the object will accept a connection via the named event", "partition": "test"}
{"idx": "4962", "code": "void subtractFlakes(int quantity){\n  for (int i=0; i < quantity; ++i) {\n    int index=numFlakes - i - 1;\n    flakes.remove(index);\n  }\n  setNumFlakes(numFlakes - quantity);\n}\n", "docstring": "subtract the specified number of droidflakes . we just take them off the end of the list , leaving the others unchanged .", "partition": "test"}
{"idx": "4963", "code": "public boolean requiredResourceName(Policy policy,String realmName,String name){\n  getSvcTypeNameToActionsMap(policy,realmName);\n  return requiredResourceNameService.contains(name);\n}\n", "docstring": "returns true if service type requires resource name .", "partition": "test"}
{"idx": "4964", "code": "public static void main(String args[]){\n  boolean ok=parseOptions(args);\n  if (!ok || !stripFiles(infiles,outfiles)) {\n    System.exit(1);\n  }\n}\n", "docstring": "strip the properties filenames supplied , replacing their contents .", "partition": "test"}
{"idx": "4965", "code": "protected String a(String s,int v,String u) throws Exception {\n  char sign=v >= 0 ? '+' : '-';\n  Date dt=DateMathParser.parseMath(null,s + 'Z' + sign+ Math.abs(v)+ u);\n  return fmt.format(dt.toInstant());\n}\n", "docstring": "macro : add : parses s , adds v u , fmts", "partition": "test"}
{"idx": "4966", "code": "JarFile open(final File jarFile) throws IOException {\n  isTrue(jarFile.exists(),\"The JAR file must exists.\");\n  return new JarFile(jarFile);\n}\n", "docstring": "opens the specified jar file and returns a valid handle .", "partition": "test"}
{"idx": "4967", "code": "public void removeAllEmails(){\n  emails.clear();\n}\n", "docstring": "removes all email \"'\" s from this user", "partition": "test"}
{"idx": "4968", "code": "public PWResetAdminLog(SSOToken token){\n  this.token=token;\n  if (logStatus) {\n    logger=(com.sun.identity.log.Logger)Logger.getLogger(logFile);\n  }\n  String lstr=SystemProperties.get(Constants.AM_LOCALE);\n  init(lstr);\n}\n", "docstring": "constructs a logger object", "partition": "test"}
{"idx": "4969", "code": "public static boolean isLetter(Character self){\n  return Character.isLetter(self);\n}\n", "docstring": "determines if a character is a letter . synonym for \"'\" character . isletter ( this ) \"'\" .", "partition": "test"}
{"idx": "4970", "code": "public static String createLink(String uri,String label){\n  return \"<a href=\'\" + uri + \"\'>\"+ label+ \"</a>\";\n}\n", "docstring": "creates a link with the given uri and label text .", "partition": "test"}
{"idx": "4971", "code": "public static boolean isExpression(String token,boolean isXml){\n  String openExpr;\n  String closeExpr;\n  if (isXml) {\n    openExpr=OPEN_EXPR_XML;\n    closeExpr=CLOSE_EXPR_XML;\n  }\n else {\n    openExpr=OPEN_EXPR;\n    closeExpr=CLOSE_EXPR;\n  }\n  if (token.startsWith(openExpr) && token.endsWith(closeExpr)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "checks if the token is a runtime expression . in standard jsp syntax , a runtime expression starts with \"'\" < % \"'\" and ends with \"'\" % > \"'\" . when the jsp document is in xml syntax , a runtime expression starts with \"'\" % = \"'\" and ends with \"'\" % \"'\" .", "partition": "test"}
{"idx": "4972", "code": "public void destroy(){\n  this.isInitialized=false;\n  this.isFinished=false;\n  this.firstNode=null;\n  this.tailLength=0;\n  this.firstNodeHeight=-1;\n}\n", "docstring": "destroys a treehash instance after the top node was taken for authentication path .", "partition": "test"}
{"idx": "4973", "code": "public static Uri fromFile(File file){\n  if (file == null) {\n    throw new NullPointerException(\"file\");\n  }\n  PathPart path=PathPart.fromDecoded(file.getAbsolutePath());\n  return new HierarchicalUri(\"file\",Part.EMPTY,path,Part.NULL,Part.NULL);\n}\n", "docstring": "creates a uri from a file . the uri has the form \" file : / / < absolute path > \" . encodes path characters with the exception of \"'\" / \"'\" . < p > example : \" file : / / / tmp / android . txt \"", "partition": "test"}
{"idx": "4974", "code": "protected Object readFixedType(BinaryReaderExImpl reader) throws BinaryObjectException {\n  Object val=null;\nswitch (mode) {\ncase BYTE:\n    val=reader.readByteNullable(id);\n  break;\ncase SHORT:\nval=reader.readShortNullable(id);\nbreak;\ncase INT:\nval=reader.readIntNullable(id);\nbreak;\ncase LONG:\nval=reader.readLongNullable(id);\nbreak;\ncase FLOAT:\nval=reader.readFloatNullable(id);\nbreak;\ncase DOUBLE:\nval=reader.readDoubleNullable(id);\nbreak;\ncase CHAR:\nval=reader.readCharNullable(id);\nbreak;\ncase BOOLEAN:\nval=reader.readBooleanNullable(id);\nbreak;\ncase DECIMAL:\nval=reader.readDecimal(id);\nbreak;\ncase STRING:\nval=reader.readString(id);\nbreak;\ncase UUID:\nval=reader.readUuid(id);\nbreak;\ncase DATE:\nval=reader.readDate(id);\nbreak;\ncase TIMESTAMP:\nval=reader.readTimestamp(id);\nbreak;\ncase BYTE_ARR:\nval=reader.readByteArray(id);\nbreak;\ncase SHORT_ARR:\nval=reader.readShortArray(id);\nbreak;\ncase INT_ARR:\nval=reader.readIntArray(id);\nbreak;\ncase LONG_ARR:\nval=reader.readLongArray(id);\nbreak;\ncase FLOAT_ARR:\nval=reader.readFloatArray(id);\nbreak;\ncase DOUBLE_ARR:\nval=reader.readDoubleArray(id);\nbreak;\ncase CHAR_ARR:\nval=reader.readCharArray(id);\nbreak;\ncase BOOLEAN_ARR:\nval=reader.readBooleanArray(id);\nbreak;\ncase DECIMAL_ARR:\nval=reader.readDecimalArray(id);\nbreak;\ncase STRING_ARR:\nval=reader.readStringArray(id);\nbreak;\ncase UUID_ARR:\nval=reader.readUuidArray(id);\nbreak;\ncase DATE_ARR:\nval=reader.readDateArray(id);\nbreak;\ncase TIMESTAMP_ARR:\nval=reader.readTimestampArray(id);\nbreak;\ncase OBJECT_ARR:\nval=reader.readObjectArray(id);\nbreak;\ncase COL:\nval=reader.readCollection(id,null);\nbreak;\ncase MAP:\nval=reader.readMap(id,null);\nbreak;\ncase BINARY_OBJ:\nval=reader.readBinaryObject(id);\nbreak;\ncase ENUM:\nval=reader.readEnum(id,field.getType());\nbreak;\ncase ENUM_ARR:\nval=reader.readEnumArray(id,field.getType().getComponentType());\nbreak;\ncase BINARY:\ncase OBJECT:\nval=reader.readObject(id);\nbreak;\ncase CLASS:\nval=reader.readClass(id);\nbreak;\ndefault :\nassert false : \"Invalid mode: \" + mode;\n}\nreturn val;\n}\n", "docstring": "reads fixed type from the given reader with flags validation .", "partition": "test"}
{"idx": "4975", "code": "@Override public Vector whatCanGoHere(int[] state){\n  Vector ret=new Vector();\n  for (int i=0; i < fNumElements; i++) {\n    if (state[i + 1] == STATE_START)     ret.addElement(fAllElements[i]);\n  }\n  return ret;\n}\n", "docstring": "check which elements are valid to appear at this point . this method also works if the state is in error , in which case it returns what should have been seen .", "partition": "test"}
{"idx": "4976", "code": "public void remove(RegionEntry entry,Object value){\n  Object object=map.get(entry);\n  if (object == null)   return;\n  if (object instanceof Collection) {\n    Collection coll=(Collection)object;\n    boolean removed=false;\n    if (useList) {\nsynchronized (coll) {\n        removed=coll.remove(value);\n      }\n    }\n else {\n      removed=coll.remove(value);\n    }\n    if (removed) {\n      if (coll.size() == 0) {\n        map.remove(entry);\n      }\n      atomicUpdater.decrementAndGet(this);\n    }\n  }\n else {\n    if (object.equals(value)) {\n      map.remove(entry);\n    }\n    atomicUpdater.decrementAndGet(this);\n  }\n}\n", "docstring": "we do not use any locks here as every remove is for a regionentry which is locked before coming here . no two threads can be entering in this method together for a regionentry .", "partition": "test"}
{"idx": "4977", "code": "private HashDataCache(DataCache<Pair<String,T>> cache,String algorithm){\n  this.cache=cache;\n  this.algorithm=algorithm;\n  try {\n    MessageDigest.getInstance(algorithm);\n  }\n catch (  NoSuchAlgorithmException e) {\n    String msg=\"Unable to get hash generator with algorithm: \" + algorithm;\n    LOG.warn(msg,e);\n    throw new SystemConfigException(e);\n  }\n}\n", "docstring": "creates cache hashing with provided algorithm .", "partition": "test"}
{"idx": "4978", "code": "private void marshallEnum(Object value,EnumType enumType) throws IOException {\n  LOG.debug(\"Enum value: {} of type: {}\",value,enumType);\n  jsonGenerator.writeString(value.toString());\n}\n", "docstring": "marshall an enum value .", "partition": "test"}
{"idx": "4979", "code": "private void initEvents(){\n  setSelectionSounds(play,hScore,credits,quit,quitY,quitN);\n  play.setOnAction(null);\n  hScore.setOnAction(null);\n  credits.setOnAction(null);\n  quit.setOnAction(null);\n  quitY.setOnAction(null);\n  quitN.setOnAction(null);\n  scene.setOnKeyPressed(null);\n  scene.setOnKeyReleased(null);\n}\n", "docstring": "initializes key and action event of game . < br > also defines player controls .", "partition": "test"}
{"idx": "4980", "code": "private String mapCollectionName(String collectionName,boolean dest){\n  if ((collectionRules.size() == 0) && (StringUtils.isBlank(defaultCollectionAppend))) {\n    return collectionName;\n  }\n  for (  String[] rule : collectionRules) {\n    String match=(dest) ? rule[0] : rule[1];\n    String replace=(dest) ? rule[1] : rule[0];\n    if (collectionName.contains(match)) {\n      return collectionName.replace(match,replace);\n    }\n  }\n  if (dest) {\n    return collectionName + defaultCollectionAppend;\n  }\n else {\n    return collectionName.replace(defaultCollectionAppend,\"\");\n  }\n}\n", "docstring": "given a collection name and a flag ( reverse of forward mapping ) , return the new collection name based on the mapping", "partition": "test"}
{"idx": "4981", "code": "static public void fillRandomIntegerUniform(IDoubleVector vec,Random rand,int min,int max){\n  final int delta=max - min;\n  for (int i=0; i < vec.getLength(); ++i) {\n    vec.set(i,min + rand.nextInt(delta));\n  }\n}\n", "docstring": "fills vector with random integer values in the range [ min , max )", "partition": "test"}
{"idx": "4982", "code": "private static void stoppingAnimation(Thread me){\n  final FetcherInfo info=FetcherInfo.getFetcherInfo();\nsynchronized (info.waitList) {\n    int index=-1;\n    for (int i=0; i < info.fetchers.length; i++) {\n      if (info.fetchers[i] == me) {\n        return;\n      }\n      if (info.fetchers[i] == null) {\n        index=i;\n      }\n    }\n    if (index >= 0) {\n      info.fetchers[index]=me;\n      info.numFetchers++;\n      me.setName(\"Image Fetcher \" + index);\n      return;\n    }\n  }\n}\n", "docstring": "returns this image animator thread back to service as an imagefetcher if possible . puts it back into the array of imagefetchers and sets the thread name back to \" image fetcher \" . if there are already the maximum number of imagefetchers , this method simply returns , and fetchloop ( ) will drop out when it sees that this thread isn \"'\" t one of the imagefetchers , and this thread will die .", "partition": "test"}
{"idx": "4983", "code": "public boolean name_is_equal(String p_name){\n  if (p_name == null)   return false;\n  return p_name.equalsIgnoreCase(pkg_name);\n}\n", "docstring": "compare the given name with the package name in case indipendent way", "partition": "test"}
{"idx": "4984", "code": "protected void drawRangeMarkers(Graphics2D g2,Rectangle2D dataArea,int index,Layer layer){\n  XYItemRenderer r=getRenderer(index);\n  if (r == null) {\n    return;\n  }\n  if (index >= getDatasetCount()) {\n    return;\n  }\n  Collection markers=getRangeMarkers(index,layer);\n  ValueAxis axis=getRangeAxisForDataset(index);\n  if (markers != null && axis != null) {\n    Iterator iterator=markers.iterator();\n    while (iterator.hasNext()) {\n      Marker marker=(Marker)iterator.next();\n      r.drawRangeMarker(g2,this,axis,marker,dataArea);\n    }\n  }\n}\n", "docstring": "draws the range markers ( if any ) for a renderer and layer . this method is typically called from within the draw ( ) method .", "partition": "test"}
{"idx": "4985", "code": "public VPFLayer(){\n  setProjectionChangePolicy(new com.bbn.openmap.layer.policy.ListResetPCPolicy(this));\n  setMouseModeIDsForEvents(new String[]{\"Gestures\"});\n}\n", "docstring": "construct a vpf layer .", "partition": "test"}
{"idx": "4986", "code": "protected boolean shouldClose(PooledConnection con,int action){\n  if (con.getConnectionVersion() < getPoolVersion())   return true;\n  if (con.isDiscarded())   return true;\n  if (isClosed())   return true;\n  if (!con.validate(action))   return true;\n  if (!terminateTransaction(con))   return true;\n  if (con.isMaxAgeExpired())   return true;\n else   return false;\n}\n", "docstring": "determines if a connection should be closed upon return to the pool .", "partition": "test"}
{"idx": "4987", "code": "public Vector3D hsl(){\n  float r=redf();\n  float g=greenf();\n  float b=bluef();\n  float min=Math.min(Math.min(r,g),b);\n  float max=Math.max(Math.max(r,g),b);\n  float l=lighting(min,max);\n  float s=saturation(min,max,l);\n  float h=hue(r,g,b,min,max);\n  return new Vector3D(h,s,l);\n}\n", "docstring": "getter for hsl components .", "partition": "test"}
{"idx": "4988", "code": "public Future<Boolean> shutdownAwaiting(long timeoutForEach){\n  ExecutorService executor=Executors.newScheduledThreadPool(0);\n  return executor.submit(createShutdown(timeoutForEach));\n}\n", "docstring": "shutdown all attached resources synchronously", "partition": "test"}
{"idx": "4989", "code": "public void changeDirectory(String path) throws IllegalStateException, IOException, FTPIllegalReplyException, FTPException {\nsynchronized (lock) {\n    if (!connected) {\n      throw new IllegalStateException(\"Client not connected\");\n    }\n    if (!authenticated) {\n      throw new IllegalStateException(\"Client not authenticated\");\n    }\n    communication.sendFTPCommand(\"CWD \" + path);\n    FTPReply r=communication.readFTPReply();\n    touchAutoNoopTimer();\n    if (!r.isSuccessCode()) {\n      throw new FTPException(r);\n    }\n  }\n}\n", "docstring": "this method changes the current working directory .", "partition": "test"}
{"idx": "4990", "code": "private String removeQuote(String column){\n  return column != null ? column.replaceAll(statementBuilder.getColumnQuote(),StringUtils.EMPTY) : null;\n}\n", "docstring": "remove quotes from the given column name .", "partition": "test"}
{"idx": "4991", "code": "private boolean scrolledUpTimeout(){\n  if (fixedChat || pauseKeyPressed) {\n    return false;\n  }\n  if (!styles.autoScroll()) {\n    return false;\n  }\n  long timePassed=System.currentTimeMillis() - lastChanged;\n  if (timePassed > 1000 * styles.autoScrollTimeout()) {\n    LOGGER.info(\"ScrolledUp Timeout (\" + timePassed + \")\");\n    return true;\n  }\n  return false;\n}\n", "docstring": "if enabled , checks whether the time that has passed since the scroll position was last changed is greater than the defined timeout .", "partition": "test"}
{"idx": "4992", "code": "public List<Document> search(Query query,boolean prefixWildCard){\n  List<Document> documents=new ArrayList<Document>();\n  try {\n    IndexSearcher searcher=getSearcher();\n    TopDocs search=searcher.search(query,10000);\n    for (    ScoreDoc scoreDoc : search.scoreDocs) {\n      Document doc=searcher.doc(scoreDoc.doc);\n      documents.add(doc);\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    throw new RuntimeException(e);\n  }\n  return documents;\n}\n", "docstring": "searches through the index for the specified query and returns the list of documents that finds a match for the query .", "partition": "test"}
{"idx": "4993", "code": "public String numArcsTipText(){\n  return \"The number of arcs in the bayesian net, at most: n * (n - 1) / 2 and at least: (n - 1); with n = numAttributes\";\n}\n", "docstring": "returns the tip text for this property", "partition": "test"}
{"idx": "4994", "code": "@RequestMapping(value=\"\",method={RequestMethod.GET}) @ResponseBody public List<JobInstance> list(JobListRequest jobRequest){\n  List<JobInstance> jobInstanceList=Collections.emptyList();\n  List<JobStatusEnum> statusList=new ArrayList<JobStatusEnum>();\n  if (null != jobRequest.getStatus()) {\n    for (    int status : jobRequest.getStatus()) {\n      statusList.add(JobStatusEnum.getByCode(status));\n    }\n  }\n  JobTimeFilterEnum timeFilter=JobTimeFilterEnum.getByCode(jobRequest.getTimeFilter());\n  try {\n    jobInstanceList=jobService.listAllJobs(jobRequest.getCubeName(),jobRequest.getProjectName(),statusList,jobRequest.getLimit(),jobRequest.getOffset(),timeFilter);\n  }\n catch (  Exception e) {\n    logger.error(e.getLocalizedMessage(),e);\n    throw new InternalErrorException(e);\n  }\n  return jobInstanceList;\n}\n", "docstring": "get all cube jobs", "partition": "test"}
{"idx": "4995", "code": "public byte[] toBinary(int q){\n  return ArrayEncoder.encodeModQ(coeffs,q);\n}\n", "docstring": "encodes a polynomial whose coefficients are between 0 and q , to binary . q must be a power of 2 .", "partition": "test"}
{"idx": "4996", "code": "public final void openFallbackInputStream() throws DataFallbackException {\n  if (inputBuf == null) {\n    if (LOG.isDebugEnabled())     LOG.debug(\"openFallbackInputStream() : Opening the reader for the \" + dataFile.getName() + \"file\");\n    try {\n      setInput(new BufferedReader(new FileReader(dataFile)));\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n  }\n}\n", "docstring": "it opens a file input stream", "partition": "test"}
{"idx": "4997", "code": "public void addCaretListener(final ICaretListener listener){\n  Preconditions.checkNotNull(listener,\"Error: Listener can\'t be null\");\n  if (!m_listeners.contains(listener)) {\n    m_listeners.add(listener);\n  }\n}\n", "docstring": "adds a new status change listener to the list of listeners .", "partition": "test"}
{"idx": "4998", "code": "@Deprecated static public SerialSensorManager instance(){\n  return null;\n}\n", "docstring": "static function returning the serialsensormanager instance to use .", "partition": "test"}
{"idx": "4999", "code": "protected void pushBidirectionalVipRoutes(IOFSwitch sw,OFPacketIn pi,FloodlightContext cntx,IPClient client,LBMember member){\n  IDevice srcDevice=null;\n  IDevice dstDevice=null;\n  Collection<? extends IDevice> allDevices=deviceManager.getAllDevices();\n  for (  IDevice d : allDevices) {\n    for (int j=0; j < d.getIPv4Addresses().length; j++) {\n      if (srcDevice == null && client.ipAddress == d.getIPv4Addresses()[j])       srcDevice=d;\n      if (dstDevice == null && member.address == d.getIPv4Addresses()[j]) {\n        dstDevice=d;\n        member.macString=dstDevice.getMACAddressString();\n      }\n      if (srcDevice != null && dstDevice != null)       break;\n    }\n  }\n  if (srcDevice == null || dstDevice == null)   return;\n  Long srcIsland=topology.getL2DomainId(sw.getId());\n  if (srcIsland == null) {\n    log.debug(\"No openflow island found for source {}/{}\",sw.getStringId(),pi.getInPort());\n    return;\n  }\n  boolean on_same_island=false;\n  boolean on_same_if=false;\n  for (  SwitchPort dstDap : dstDevice.getAttachmentPoints()) {\n    long dstSwDpid=dstDap.getSwitchDPID();\n    Long dstIsland=topology.getL2DomainId(dstSwDpid);\n    if ((dstIsland != null) && dstIsland.equals(srcIsland)) {\n      on_same_island=true;\n      if ((sw.getId() == dstSwDpid) && (pi.getInPort() == dstDap.getPort())) {\n        on_same_if=true;\n      }\n      break;\n    }\n  }\n  if (!on_same_island) {\n    if (log.isTraceEnabled()) {\n      log.trace(\"No first hop island found for destination \" + \"device {}, Action = flooding\",dstDevice);\n    }\n    return;\n  }\n  if (on_same_if) {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Both source and destination are on the same \" + \"switch/port {}/{}, Action = NOP\",sw.toString(),pi.getInPort());\n    }\n    return;\n  }\n  SwitchPort[] srcDaps=srcDevice.getAttachmentPoints();\n  Arrays.sort(srcDaps,clusterIdComparator);\n  SwitchPort[] dstDaps=dstDevice.getAttachmentPoints();\n  Arrays.sort(dstDaps,clusterIdComparator);\n  int iSrcDaps=0, iDstDaps=0;\n  while ((iSrcDaps < srcDaps.length) && (iDstDaps < dstDaps.length)) {\n    SwitchPort srcDap=srcDaps[iSrcDaps];\n    SwitchPort dstDap=dstDaps[iDstDaps];\n    Long srcCluster=topology.getL2DomainId(srcDap.getSwitchDPID());\n    Long dstCluster=topology.getL2DomainId(dstDap.getSwitchDPID());\n    int srcVsDest=srcCluster.compareTo(dstCluster);\n    if (srcVsDest == 0) {\n      if (!srcDap.equals(dstDap) && (srcCluster != null) && (dstCluster != null)) {\n        Route routeIn=routingEngine.getRoute(srcDap.getSwitchDPID(),(short)srcDap.getPort(),dstDap.getSwitchDPID(),(short)dstDap.getPort(),0);\n        Route routeOut=routingEngine.getRoute(dstDap.getSwitchDPID(),(short)dstDap.getPort(),srcDap.getSwitchDPID(),(short)srcDap.getPort(),0);\n        if (routeIn != null) {\n          pushStaticVipRoute(true,routeIn,client,member,sw.getId());\n        }\n        if (routeOut != null) {\n          pushStaticVipRoute(false,routeOut,client,member,sw.getId());\n        }\n      }\n      iSrcDaps++;\n      iDstDaps++;\n    }\n else     if (srcVsDest < 0) {\n      iSrcDaps++;\n    }\n else {\n      iDstDaps++;\n    }\n  }\n  return;\n}\n", "docstring": "used to find and push in - bound and out - bound routes using staticflowentrypusher", "partition": "test"}
{"idx": "5000", "code": "public static String parseIdFromSameDocumentURI(String uri){\n  if (uri.length() == 0) {\n    return null;\n  }\n  String id=uri.substring(1);\n  if (id != null && id.startsWith(\"xpointer(id(\")) {\n    int i1=id.indexOf(\'\\\'\');\n    int i2=id.indexOf(\'\\\'\',i1 + 1);\n    id=id.substring(i1 + 1,i2);\n  }\n  return id;\n}\n", "docstring": "returns the id from a same - document uri ( ex : \" # id \" )", "partition": "test"}
{"idx": "5001", "code": "public void markUsed(long pos,int length){\n  int start=getBlock(pos);\n  int blocks=getBlockCount(length);\n  set.set(start,start + blocks);\n}\n", "docstring": "mark the space as in use .", "partition": "test"}
{"idx": "5002", "code": "public CholMatrix(Matrix Arg){\n  final double[][] A=Arg.toDoubleArray();\n  n=(int)Arg.getRowCount();\n  L=new double[n][n];\n  isspd=(Arg.getColumnCount() == n);\n  double[] Lrowj=null;\n  double[] Lrowk=null;\n  double[] Aj=null;\n  for (int j=0; j < n; j++) {\n    Lrowj=L[j];\n    Aj=A[j];\n    double d=0.0;\n    for (int k=0; k < j; k++) {\n      Lrowk=L[k];\n      double s=0.0;\n      for (int i=0; i < k; i++) {\n        s+=Lrowk[i] * Lrowj[i];\n      }\n      Lrowj[k]=s=(Aj[k] - s) / Lrowk[k];\n      d=d + s * s;\n      isspd=isspd & (A[k][j] == Aj[k]);\n    }\n    d=Aj[j] - d;\n    isspd=isspd & (d > 0.0);\n    Lrowj[j]=Math.sqrt(Math.max(d,0.0));\n    for (int k=j + 1; k < n; k++) {\n      Lrowj[k]=0.0;\n    }\n  }\n}\n", "docstring": "cholesky algorithm for symmetric and positive definite matrix .", "partition": "test"}
{"idx": "5003", "code": "public static String readStringNZ(Memory mem,int address,int n){\n  address&=Memory.addressMask;\n  if (address + n > MemoryMap.END_RAM) {\n    n=MemoryMap.END_RAM - address + 1;\n    if (n < 0) {\n      n=0;\n    }\n  }\n  byte[] bytes=new byte[Math.min(n,10000)];\n  int length=0;\n  IMemoryReader memoryReader=MemoryReader.getMemoryReader(address,n,1);\n  for (; n > 0; n--) {\n    int b=memoryReader.readNext();\n    if (b == 0) {\n      break;\n    }\n    if (length >= bytes.length) {\n      byte[] newBytes=new byte[bytes.length + 10000];\n      System.arraycopy(bytes,0,newBytes,0,bytes.length);\n      bytes=newBytes;\n    }\n    bytes[length]=(byte)b;\n    length++;\n  }\n  return new String(bytes,0,length,Constants.charset);\n}\n", "docstring": "read a string from memory . the string ends when the maximal length is reached or a \"'\" \\ 0 \"'\" byte is found . the memory bytes are interpreted as utf - 8 bytes to form the string .", "partition": "test"}
{"idx": "5004", "code": "@Override public void agg(Object newVal){\n  valueSet.add(newVal instanceof Long ? (Long)newVal : Long.valueOf(newVal.toString()));\n  firstTime=false;\n}\n", "docstring": "distinct aggregate function which update the distinct set", "partition": "test"}
{"idx": "5005", "code": "private boolean removeLegionMember(String charName,boolean kick,String playerName){\n  LegionMemberEx legionMember=getLegionMemberEx(charName);\n  if (legionMember == null) {\n    log.error(\"Char name does not exist in legion member table: \" + charName);\n    return false;\n  }\n  deleteLegionMemberFromDB(legionMember);\n  Player player=world.findPlayer(charName);\n  if (player != null) {\n    PacketSendUtility.broadcastPacket(player,new SM_LEGION_UPDATE_TITLE(player.getObjectId(),0,\"\",2),true);\n  }\n  if (kick) {\n    PacketSendUtility.broadcastPacketToLegion(legionMember.getLegion(),new SM_LEGION_LEAVE_MEMBER(1300247,legionMember.getObjectId(),playerName,legionMember.getName()));\n  }\n else {\n    PacketSendUtility.broadcastPacketToLegion(legionMember.getLegion(),new SM_LEGION_LEAVE_MEMBER(900699,legionMember.getObjectId(),charName));\n  }\n  return true;\n}\n", "docstring": "this method will remove a legion member", "partition": "test"}
{"idx": "5006", "code": "synchronized void printBuffer() throws IOException {\n  int len=sb.length();\n  if (len > 0) {\n    char[] chars=new char[len];\n    sb.getChars(0,len,chars,0);\n    sb.setLength(0);\n    super.write(chars,0,chars.length);\n  }\n}\n", "docstring": "prints the characters from the buffer and resets it todo : make sure that printbuffer ( ) is called at the end of the stream in case we have some characters there ! ( flush ( ) ? )", "partition": "test"}
{"idx": "5007", "code": "public boolean containsBafBody(){\n  Iterator<SootMethod> methodIt=methodIterator();\n  while (methodIt.hasNext()) {\n    SootMethod m=methodIt.next();\n    if (m.hasActiveBody() && m.getActiveBody() instanceof soot.baf.BafBody) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true if some method in this class has an active baf body .", "partition": "test"}
{"idx": "5008", "code": "public static String retainAllChars(String str,String retainChars){\n  int pos=indexOfChars(str,retainChars);\n  if (pos == -1) {\n    return \"\";\n  }\n  StringBuilder buf=new StringBuilder();\n  do {\n    buf.append(str.charAt(pos));\n    pos=indexOfChars(str,retainChars,pos + 1);\n  }\n while (pos != -1);\n  return buf.toString();\n}\n", "docstring": "removes all characters from \"'\" str \"'\" that are not in \"'\" retainchars \"'\" . example : retainallchars ( \" hello , world ! \" , \" lo \" ) returns \" llool \"", "partition": "test"}
{"idx": "5009", "code": "public synchronized void deleteLeastUsedConnection(){\n  final HttpConnection connection=(HttpConnection)freeConnections.removeFirst();\n  if (connection != null) {\n    deleteConnection(connection);\n  }\n else   if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Attempted to reclaim an unused connection but there were none.\");\n  }\n}\n", "docstring": "close and delete an old , unused connection to make room for a new one .", "partition": "test"}
{"idx": "5010", "code": "private TransitSchedule cleanUpSchedule(TransitSchedule newTransitSchedule){\n  newTransitSchedule=TransitScheduleCleaner.removeRoutesWithoutDepartures(newTransitSchedule);\n  newTransitSchedule=TransitScheduleCleaner.removeEmptyLines(newTransitSchedule);\n  newTransitSchedule=TransitScheduleCleaner.removeStopsNotUsed(newTransitSchedule);\n  return newTransitSchedule;\n}\n", "docstring": "removes all routes without any departure from the schedule . removes all lines without any route from the schedule . removes all stops not referenced by any line from the schedule .", "partition": "test"}
{"idx": "5011", "code": "private boolean step1(){\n  if (CT == null)   return false;\n  if (suffix(CT,\"uciones\") && suffix(R2,\"uciones\")) {\n    CT=replaceSuffix(CT,\"uciones\",\"u\");\n    return true;\n  }\n  if (CT.length() >= 6) {\n    if (suffix(CT,\"imentos\") && suffix(R2,\"imentos\")) {\n      CT=removeSuffix(CT,\"imentos\");\n      return true;\n    }\n    if (suffix(CT,\"amentos\") && suffix(R2,\"amentos\")) {\n      CT=removeSuffix(CT,\"amentos\");\n      return true;\n    }\n    if (suffix(CT,\"adores\") && suffix(R2,\"adores\")) {\n      CT=removeSuffix(CT,\"adores\");\n      return true;\n    }\n    if (suffix(CT,\"adoras\") && suffix(R2,\"adoras\")) {\n      CT=removeSuffix(CT,\"adoras\");\n      return true;\n    }\n    if (suffix(CT,\"logias\") && suffix(R2,\"logias\")) {\n      replaceSuffix(CT,\"logias\",\"log\");\n      return true;\n    }\n    if (suffix(CT,\"encias\") && suffix(R2,\"encias\")) {\n      CT=replaceSuffix(CT,\"encias\",\"ente\");\n      return true;\n    }\n    if (suffix(CT,\"amente\") && suffix(R1,\"amente\")) {\n      CT=removeSuffix(CT,\"amente\");\n      return true;\n    }\n    if (suffix(CT,\"idades\") && suffix(R2,\"idades\")) {\n      CT=removeSuffix(CT,\"idades\");\n      return true;\n    }\n  }\n  if (CT.length() >= 5) {\n    if (suffix(CT,\"acoes\") && suffix(R2,\"acoes\")) {\n      CT=removeSuffix(CT,\"acoes\");\n      return true;\n    }\n    if (suffix(CT,\"imento\") && suffix(R2,\"imento\")) {\n      CT=removeSuffix(CT,\"imento\");\n      return true;\n    }\n    if (suffix(CT,\"amento\") && suffix(R2,\"amento\")) {\n      CT=removeSuffix(CT,\"amento\");\n      return true;\n    }\n    if (suffix(CT,\"adora\") && suffix(R2,\"adora\")) {\n      CT=removeSuffix(CT,\"adora\");\n      return true;\n    }\n    if (suffix(CT,\"ismos\") && suffix(R2,\"ismos\")) {\n      CT=removeSuffix(CT,\"ismos\");\n      return true;\n    }\n    if (suffix(CT,\"istas\") && suffix(R2,\"istas\")) {\n      CT=removeSuffix(CT,\"istas\");\n      return true;\n    }\n    if (suffix(CT,\"logia\") && suffix(R2,\"logia\")) {\n      CT=replaceSuffix(CT,\"logia\",\"log\");\n      return true;\n    }\n    if (suffix(CT,\"ucion\") && suffix(R2,\"ucion\")) {\n      CT=replaceSuffix(CT,\"ucion\",\"u\");\n      return true;\n    }\n    if (suffix(CT,\"encia\") && suffix(R2,\"encia\")) {\n      CT=replaceSuffix(CT,\"encia\",\"ente\");\n      return true;\n    }\n    if (suffix(CT,\"mente\") && suffix(R2,\"mente\")) {\n      CT=removeSuffix(CT,\"mente\");\n      return true;\n    }\n    if (suffix(CT,\"idade\") && suffix(R2,\"idade\")) {\n      CT=removeSuffix(CT,\"idade\");\n      return true;\n    }\n  }\n  if (CT.length() >= 4) {\n    if (suffix(CT,\"acao\") && suffix(R2,\"acao\")) {\n      CT=removeSuffix(CT,\"acao\");\n      return true;\n    }\n    if (suffix(CT,\"ezas\") && suffix(R2,\"ezas\")) {\n      CT=removeSuffix(CT,\"ezas\");\n      return true;\n    }\n    if (suffix(CT,\"icos\") && suffix(R2,\"icos\")) {\n      CT=removeSuffix(CT,\"icos\");\n      return true;\n    }\n    if (suffix(CT,\"icas\") && suffix(R2,\"icas\")) {\n      CT=removeSuffix(CT,\"icas\");\n      return true;\n    }\n    if (suffix(CT,\"ismo\") && suffix(R2,\"ismo\")) {\n      CT=removeSuffix(CT,\"ismo\");\n      return true;\n    }\n    if (suffix(CT,\"avel\") && suffix(R2,\"avel\")) {\n      CT=removeSuffix(CT,\"avel\");\n      return true;\n    }\n    if (suffix(CT,\"ivel\") && suffix(R2,\"ivel\")) {\n      CT=removeSuffix(CT,\"ivel\");\n      return true;\n    }\n    if (suffix(CT,\"ista\") && suffix(R2,\"ista\")) {\n      CT=removeSuffix(CT,\"ista\");\n      return true;\n    }\n    if (suffix(CT,\"osos\") && suffix(R2,\"osos\")) {\n      CT=removeSuffix(CT,\"osos\");\n      return true;\n    }\n    if (suffix(CT,\"osas\") && suffix(R2,\"osas\")) {\n      CT=removeSuffix(CT,\"osas\");\n      return true;\n    }\n    if (suffix(CT,\"ador\") && suffix(R2,\"ador\")) {\n      CT=removeSuffix(CT,\"ador\");\n      return true;\n    }\n    if (suffix(CT,\"ivas\") && suffix(R2,\"ivas\")) {\n      CT=removeSuffix(CT,\"ivas\");\n      return true;\n    }\n    if (suffix(CT,\"ivos\") && suffix(R2,\"ivos\")) {\n      CT=removeSuffix(CT,\"ivos\");\n      return true;\n    }\n    if (suffix(CT,\"iras\") && suffix(RV,\"iras\") && suffixPreceded(CT,\"iras\",\"e\")) {\n      CT=replaceSuffix(CT,\"iras\",\"ir\");\n      return true;\n    }\n  }\n  if (CT.length() >= 3) {\n    if (suffix(CT,\"eza\") && suffix(R2,\"eza\")) {\n      CT=removeSuffix(CT,\"eza\");\n      return true;\n    }\n    if (suffix(CT,\"ico\") && suffix(R2,\"ico\")) {\n      CT=removeSuffix(CT,\"ico\");\n      return true;\n    }\n    if (suffix(CT,\"ica\") && suffix(R2,\"ica\")) {\n      CT=removeSuffix(CT,\"ica\");\n      return true;\n    }\n    if (suffix(CT,\"oso\") && suffix(R2,\"oso\")) {\n      CT=removeSuffix(CT,\"oso\");\n      return true;\n    }\n    if (suffix(CT,\"osa\") && suffix(R2,\"osa\")) {\n      CT=removeSuffix(CT,\"osa\");\n      return true;\n    }\n    if (suffix(CT,\"iva\") && suffix(R2,\"iva\")) {\n      CT=removeSuffix(CT,\"iva\");\n      return true;\n    }\n    if (suffix(CT,\"ivo\") && suffix(R2,\"ivo\")) {\n      CT=removeSuffix(CT,\"ivo\");\n      return true;\n    }\n    if (suffix(CT,\"ira\") && suffix(RV,\"ira\") && suffixPreceded(CT,\"ira\",\"e\")) {\n      CT=replaceSuffix(CT,\"ira\",\"ir\");\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "standard suffix removal . search for the longest among the following suffixes , and perform the following actions :", "partition": "test"}
{"idx": "5012", "code": "void close(int contextPrec,int ownPrec) throws IOException {\n  if (ownPrec < contextPrec)   out.write(\")\");\n}\n", "docstring": "leave precedence level . emit a ` ( \"'\" if inner precedence level is less than precedence level we revert to .", "partition": "test"}
{"idx": "5013", "code": "public void finishPainting(boolean useCache){\n  DataBufferInt dataBuffer=new DataBufferInt(w0 * h0);\n  int transparency=nativeFinishPainting(SunWritableRaster.stealData(dataBuffer,0),w0,h0);\n  SunWritableRaster.markDirty(dataBuffer);\n  int[] bands=BAND_OFFSETS[transparency - 1];\n  WritableRaster raster=Raster.createPackedRaster(dataBuffer,w0,h0,w0,bands,null);\n  ColorModel cm=COLOR_MODELS[transparency - 1];\n  Image img=new BufferedImage(cm,raster,false,null);\n  if (useCache) {\n    cache.setImage(getClass(),null,w0,h0,cacheArgs,img);\n  }\n  graphics.drawImage(img,x0,y0,null);\n}\n", "docstring": "called to indicate that painting is finished . we create a new bufferedimage from the offscreen buffer , ( optionally ) cache it , and paint it .", "partition": "test"}
{"idx": "5014", "code": "public boolean deletePanel(){\n  if (!super.deletePanel()) {\n    return false;\n  }\n  turnoutList.clear();\n  trackList.clear();\n  pointList.clear();\n  xingList.clear();\n  slipList.clear();\n  turntableList.clear();\n  return true;\n}\n", "docstring": "invoked by deletepanel menu item validate user intent before deleting", "partition": "test"}
{"idx": "5015", "code": "@Override default CompletableFuture<OptionalDouble> averageDouble(final ToDoubleFunction<? super T> fn){\n  return CompletableFuture.supplyAsync(null,getExec());\n}\n", "docstring": "perform an asynchronous average operation", "partition": "test"}
{"idx": "5016", "code": "public String next(){\n  return next(ANY_PATTERN);\n}\n", "docstring": "returns the next token . the token will be both prefixed and suffixed by the delimiter that is currently being used ( or a string that matches the delimiter pattern ) . this method will block if input is being read .", "partition": "test"}
{"idx": "5017", "code": "public Macro(File file) throws EOFException, FileNotFoundException, IOException {\n  DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();\n  DocumentBuilder db=null;\n  Document doc=null;\n  try {\n    db=dbf.newDocumentBuilder();\n    InputSource is=new InputSource(new UnicodeReader(new FileInputStream(file),FILE_ENCODING));\n    is.setEncoding(FILE_ENCODING);\n    doc=db.parse(is);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    String desc=e.getMessage();\n    if (desc == null) {\n      desc=e.toString();\n    }\n    throw new IOException(\"Error parsing XML: \" + desc);\n  }\n  macroRecords=new ArrayList();\n  boolean parsedOK=initializeFromXMLFile(doc.getDocumentElement());\n  if (parsedOK == false) {\n    name=null;\n    macroRecords.clear();\n    macroRecords=null;\n    throw new IOException(\"Error parsing XML!\");\n  }\n}\n", "docstring": "loads a macro from a file on disk .", "partition": "test"}
{"idx": "5018", "code": "public static void deleteESInput(){\n  String esPIRIndex=SystemConfiguration.getProperty(DistributedTestDriver.ES_INPUT_NODES_PROPERTY) + \":\" + SystemConfiguration.getProperty(DistributedTestDriver.ES_INPUT_PORT_PROPERTY)+ \"/\"+ SystemConfiguration.getProperty(DistributedTestDriver.ES_INPUT_INDEX_PROPERTY);\n  logger.info(\"ES input being deleted at \" + esPIRIndex);\n  ProcessBuilder pDeletePIR=new ProcessBuilder(\"curl\",\"-XDELETE\",esPIRIndex);\n  try {\n    TestUtils.executeCommand(pDeletePIR);\n    logger.info(\"ES input deleted!\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "delete the elasticsearch indices that was used for functional testing", "partition": "test"}
{"idx": "5019", "code": "private boolean add(int part){\n  if (!parts.contains(part)) {\n    parts.add(part);\n    return true;\n  }\n  return false;\n}\n", "docstring": "adds partition to partition set .", "partition": "test"}
{"idx": "5020", "code": "private Location findFarthestLocation(Location location,Direction direction){\n  Location farthest;\n  do {\n    farthest=location;\n    location=farthest.offset(direction);\n  }\n while (gridOperator.isValidLocation(location) && gameGrid.get(location) == null);\n  return farthest;\n}\n", "docstring": "searchs for the farthest empty location where the current tile could go", "partition": "test"}
{"idx": "5021", "code": "private JSplitPane createMainSplitPane(){\n  final JSplitPane mainSplitPane=new JSplitPane();\n  mainSplitPane.setOneTouchExpandable(true);\n  mainSplitPane.setDividerLocation(250);\n  mainSplitPane.setResizeWeight(0.33);\n  mainSplitPane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);\n  m_componentPanel.setBackground(Color.WHITE);\n  mainSplitPane.setLeftComponent(createProjectTreePanel());\n  mainSplitPane.setRightComponent(m_componentPanel);\n  mainSplitPane.setBorder(new LineBorder(Color.GRAY));\n  return mainSplitPane;\n}\n", "docstring": "creates the main split pane . the main split pane divides the main window into project tree on the left side of the main window and the state - specific views on the right side of the main window .", "partition": "test"}
{"idx": "5022", "code": "private DigicoreChain cleanChain(DigicoreChain chain){\n  return chain;\n}\n", "docstring": "todo currently returns exactly the same chain . no cleaning or merging of activities that are close to one another .", "partition": "test"}
{"idx": "5023", "code": "private boolean checkSetup(){\n  this.txmgr=TransactionManagerImp.getTransactionManager();\n  if (this.txmgr == null) {\n    try {\n      Hashtable<String,String> env=new Hashtable<String,String>();\n      env.put(Context.INITIAL_CONTEXT_FACTORY,this.initialContextFactory);\n      env.put(Context.PROVIDER_URL,this.providerUrl);\n      Context ctx=new InitialContext(env);\n      this.txmgrServer=(UserTransactionServer)PortableRemoteObject.narrow(ctx.lookup(this.userTransactionServerLookupName),UserTransactionServer.class);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(getNotFoundMessage());\n    }\n    if (this.txmgrServer == null)     throw new RuntimeException(getNotFoundMessage());\n  }\n  return this.txmgr != null;\n}\n", "docstring": "referenceable mechanism requires later setup of txmgr_ , otherwise binding into jndi already requires that tm is running .", "partition": "test"}
{"idx": "5024", "code": "public static final boolean givesCheck(Position pos,Move m){\n  boolean wtm=pos.whiteMove;\n  int oKingSq=pos.getKingSq(!wtm);\n  int oKing=wtm ? Piece.BKING : Piece.WKING;\n  int p=Piece.makeWhite(m.promoteTo == Piece.EMPTY ? pos.getPiece(m.from) : m.promoteTo);\n  int d1=BitBoard.getDirection(m.to,oKingSq);\nswitch (d1) {\ncase 8:\ncase -8:\ncase 1:\ncase -1:\n    if ((p == Piece.WQUEEN) || (p == Piece.WROOK))     if ((d1 != 0) && (MoveGen.nextPiece(pos,m.to,d1) == oKing))     return true;\n  break;\ncase 9:\ncase 7:\ncase -9:\ncase -7:\nif ((p == Piece.WQUEEN) || (p == Piece.WBISHOP)) {\n  if ((d1 != 0) && (MoveGen.nextPiece(pos,m.to,d1) == oKing))   return true;\n}\n else if (p == Piece.WPAWN) {\n  if (((d1 > 0) == wtm) && (pos.getPiece(m.to + d1) == oKing))   return true;\n}\nbreak;\ndefault :\nif (d1 != 0) {\nif (p == Piece.WKNIGHT) return true;\n}\n}\nint d2=BitBoard.getDirection(m.from,oKingSq);\nif ((d2 != 0) && (d2 != d1) && (MoveGen.nextPiece(pos,m.from,d2) == oKing)) {\nint p2=MoveGen.nextPieceSafe(pos,m.from,-d2);\nswitch (d2) {\ncase 8:\ncase -8:\ncase 1:\ncase -1:\nif ((p2 == (wtm ? Piece.WQUEEN : Piece.BQUEEN)) || (p2 == (wtm ? Piece.WROOK : Piece.BROOK))) return true;\nbreak;\ncase 9:\ncase 7:\ncase -9:\ncase -7:\nif ((p2 == (wtm ? Piece.WQUEEN : Piece.BQUEEN)) || (p2 == (wtm ? Piece.WBISHOP : Piece.BBISHOP))) return true;\nbreak;\n}\n}\nif ((m.promoteTo != Piece.EMPTY) && (d1 != 0) && (d1 == d2)) {\nswitch (d1) {\ncase 8:\ncase -8:\ncase 1:\ncase -1:\nif ((p == Piece.WQUEEN) || (p == Piece.WROOK)) if ((d1 != 0) && (MoveGen.nextPiece(pos,m.from,d1) == oKing)) return true;\nbreak;\ncase 9:\ncase 7:\ncase -9:\ncase -7:\nif ((p == Piece.WQUEEN) || (p == Piece.WBISHOP)) {\nif ((d1 != 0) && (MoveGen.nextPiece(pos,m.from,d1) == oKing)) return true;\n}\nbreak;\n}\n}\nif (p == Piece.WKING) {\nif (m.to - m.from == 2) {\nif (MoveGen.nextPieceSafe(pos,m.from,-1) == oKing) return true;\nif (MoveGen.nextPieceSafe(pos,m.from + 1,wtm ? 8 : -8) == oKing) return true;\n}\n else if (m.to - m.from == -2) {\nif (MoveGen.nextPieceSafe(pos,m.from,1) == oKing) return true;\nif (MoveGen.nextPieceSafe(pos,m.from - 1,wtm ? 8 : -8) == oKing) return true;\n}\n}\n else if (p == Piece.WPAWN) {\nif (pos.getPiece(m.to) == Piece.EMPTY) {\nint dx=Position.getX(m.to) - Position.getX(m.from);\nif (dx != 0) {\nint epSq=m.from + dx;\nint d3=BitBoard.getDirection(epSq,oKingSq);\nswitch (d3) {\ncase 9:\ncase 7:\ncase -9:\ncase -7:\nif (MoveGen.nextPiece(pos,epSq,d3) == oKing) {\nint p2=MoveGen.nextPieceSafe(pos,epSq,-d3);\nif ((p2 == (wtm ? Piece.WQUEEN : Piece.BQUEEN)) || (p2 == (wtm ? Piece.WBISHOP : Piece.BBISHOP))) return true;\n}\nbreak;\ncase 1:\nif (MoveGen.nextPiece(pos,Math.max(epSq,m.from),d3) == oKing) {\nint p2=MoveGen.nextPieceSafe(pos,Math.min(epSq,m.from),-d3);\nif ((p2 == (wtm ? Piece.WQUEEN : Piece.BQUEEN)) || (p2 == (wtm ? Piece.WROOK : Piece.BROOK))) return true;\n}\nbreak;\ncase -1:\nif (MoveGen.nextPiece(pos,Math.min(epSq,m.from),d3) == oKing) {\nint p2=MoveGen.nextPieceSafe(pos,Math.max(epSq,m.from),-d3);\nif ((p2 == (wtm ? Piece.WQUEEN : Piece.BQUEEN)) || (p2 == (wtm ? Piece.WROOK : Piece.BROOK))) return true;\n}\nbreak;\n}\n}\n}\n}\nreturn false;\n}\n", "docstring": "return true if making a move delivers check to the opponent", "partition": "test"}
{"idx": "5025", "code": "public static FSDirectory newFSDirectory(Class<? extends FSDirectory> clazz,Path path) throws ReflectiveOperationException {\n  return newFSDirectory(clazz,path,FSLockFactory.getDefault());\n}\n", "docstring": "creates a new specific fsdirectory instance", "partition": "test"}
{"idx": "5026", "code": "private static Element addElement(Document doc,Node parent,String tagName,String attr1,String val1,String attr2,String val2){\n  Element elem=doc.createElement(tagName);\n  if (attr1 != null)   elem.setAttribute(attr1,val1);\n  if (attr2 != null)   elem.setAttribute(attr2,val2);\n  parent.appendChild(elem);\n  return elem;\n}\n", "docstring": "add element to xml document .", "partition": "test"}
{"idx": "5027", "code": "public static String stream2String(InputStream is,int maxLength) throws IOException {\n  byte[] buffer=new byte[4096];\n  StringWriter sw=new StringWriter();\n  int totalRead=0;\n  int read=0;\n  do {\n    sw.write(new String(buffer,0,read));\n    totalRead+=read;\n    read=is.read(buffer,0,buffer.length);\n  }\n while (((-1 == maxLength) || (totalRead < maxLength)) && (read != -1));\n  return sw.toString();\n}\n", "docstring": "read a string of up to maxlength bytes from an inputstream", "partition": "test"}
{"idx": "5028", "code": "private static Couple<String> splitNameOfRemoteBranch(String branchName){\n  int firstSlash=branchName.indexOf('/');\n  String remoteName=firstSlash > -1 ? branchName.substring(0,firstSlash) : branchName;\n  String remoteBranchName=branchName.substring(firstSlash + 1);\n  return Couple.of(remoteName,remoteBranchName);\n}\n", "docstring": "returns the remote and the \" local \" name of a remote branch . expects branch in format \" origin / master \" , i . e . remote / branch", "partition": "test"}
{"idx": "5029", "code": "public static OutputStream encrypt(OutputStream unencryptedOutputStream,char[] password) throws EncryptionException, IOException {\n  OutputStream encryptedOutputStream=null;\n  PBEKeySpec pbeKeySpec=new PBEKeySpec(password);\n  PBEParameterSpec pbeParameterSpec=new PBEParameterSpec(SALT,ITERATION_COUNT);\n  try {\n    SecretKeyFactory secretKeyFactory=SecretKeyFactory.getInstance(ENCRYPTION_ALGORITHM,CRYPTOPROVIDER);\n    SecretKey pbeKey=secretKeyFactory.generateSecret(pbeKeySpec);\n    Cipher cipher=Cipher.getInstance(ENCRYPTION_ALGORITHM,CRYPTOPROVIDER);\n    cipher.init(Cipher.ENCRYPT_MODE,pbeKey,pbeParameterSpec);\n    encryptedOutputStream=new CipherOutputStream(unencryptedOutputStream,cipher);\n  }\n catch (  GeneralSecurityException e) {\n    throw new EncryptionException(\"There was a problem during the encryption process. See the stacktrace for details.\",e);\n  }\n  return encryptedOutputStream;\n}\n", "docstring": "encrypts data received from the given outputstream using the aes algorithm .", "partition": "test"}
{"idx": "5030", "code": "public static String rightPad(String original,int length,char padChar){\n  if (original.length() >= length) {\n    return original;\n  }\n  return original + stringOfChar(padChar,length - original.length());\n}\n", "docstring": "pads the string with the given character until it has the given length . if original is longer than the given length , returns original .", "partition": "test"}
{"idx": "5031", "code": "protected void reloadSwipeStateInView(View frontView,int position){\n  if (!opened.get(position)) {\n    ViewCompat.setTranslationX(frontView,0.0f);\n  }\n else {\n    if (openedRight.get(position)) {\n      ViewCompat.setTranslationX(frontView,swipeListView.getWidth());\n    }\n else {\n      ViewCompat.setTranslationX(frontView,-swipeListView.getWidth());\n    }\n  }\n}\n", "docstring": "reset the state of front view when the it \"'\" s recycled by listview", "partition": "test"}
{"idx": "5032", "code": "void reset(){\n  System.arraycopy(iv,0,k,0,blockSize);\n}\n", "docstring": "resets the iv to its original value . this is used when dofinal is called in the cipher class , so that the cipher can be reused ( with its original iv ) .", "partition": "test"}
{"idx": "5033", "code": "public Matrix3 multiplyByVerticalFlip(){\n  double[] m=this.m;\n  m[2]+=m[1];\n  m[5]+=m[4];\n  m[8]+=m[7];\n  m[1]=-m[1];\n  m[4]=-m[4];\n  m[7]=-m[7];\n  return this;\n}\n", "docstring": "multiplies this matrix by a matrix that flips and shifts the y - axis . the vertical flip matrix maps y = 0 to y = 1 and y = 1 to y = 0 . this matrix is usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate origin . < p / > this is typically necessary to align the coordinate system of images ( top - left origin ) with that of opengl ( bottom - left origin ) .", "partition": "test"}
{"idx": "5034", "code": "public void shutdown() throws DataSourceException {\n  if (createdSessionFactory) {\n    if (sessionFactory != null && !sessionFactory.isClosed()) {\n      try {\n        sessionFactory.close();\n      }\n  finally {\n        sessionFactory=null;\n      }\n    }\n  }\n}\n", "docstring": "shuts down the data source . if the session factory was created by this data source , will close it .", "partition": "test"}
{"idx": "5035", "code": "public COpenFunctionAction(final CGraphWindow parent,final IViewContainer container,final INaviFunction function){\n  super(String.format(\"Open function %s\",function.getName()));\n  Preconditions.checkNotNull(parent,\"IE02163: Parent argument can not be null\");\n  Preconditions.checkNotNull(container,\"IE02164: Container argument can not be null\");\n  m_parent=parent;\n  m_container=container;\n  m_function=function;\n}\n", "docstring": "creates a new action object .", "partition": "test"}
{"idx": "5036", "code": "public void writeString(final String s){\n  final byte[] bytes=s.getBytes();\n  final int len=bytes.length;\n  writeInt(len);\n  System.arraycopy(bytes,0,buffer,offset,len);\n  offset+=len;\n  pad();\n}\n", "docstring": "puts a string into the buffer by first writing the size of the string as an int , followed by the bytes of the string , padded if necessary to a multiple of 4 .", "partition": "test"}
{"idx": "5037", "code": "private static PermissionCollection createAllPermissions(){\n  Permissions permissions=new Permissions();\n  permissions.add(new AllPermission());\n  return permissions;\n}\n", "docstring": "create permission for our trusted code . no restrictions are applied", "partition": "test"}
{"idx": "5038", "code": "private void mergeNetworks(Network tzone,Network sZone){\n  List<String> addedEndPoints=new ArrayList<String>(sZone.retrieveEndpoints());\n  StringSet newEndPoints=sZone.retrieveEndpoints();\n  for (  String endpoint : tzone.retrieveEndpoints()) {\n    if (newEndPoints.contains(endpoint)) {\n      addedEndPoints.remove(endpoint);\n    }\n  }\n  if (!addedEndPoints.isEmpty()) {\n    tzone.addEndpoints(addedEndPoints,true);\n  }\n  tzone.setNativeGuid(sZone.getNativeGuid());\n}\n", "docstring": "update one network with information from another", "partition": "test"}
{"idx": "5039", "code": "static public void println(String msg){\n  println(msg,CLLogLevel.normal);\n}\n", "docstring": "temporary utility method to keep current println behavior .", "partition": "test"}
{"idx": "5040", "code": "private List<FacetResult> sumAssociations() throws IOException {\n  DirectoryReader indexReader=DirectoryReader.open(indexDir);\n  IndexSearcher searcher=new IndexSearcher(indexReader);\n  TaxonomyReader taxoReader=new DirectoryTaxonomyReader(taxoDir);\n  FacetsCollector fc=new FacetsCollector();\n  FacetsCollector.search(searcher,new MatchAllDocsQuery(),10,fc);\n  Facets tags=new TaxonomyFacetSumIntAssociations(\"$tags\",taxoReader,config,fc);\n  Facets genre=new TaxonomyFacetSumFloatAssociations(\"$genre\",taxoReader,config,fc);\n  List<FacetResult> results=new ArrayList<>();\n  results.add(tags.getTopChildren(10,\"tags\"));\n  results.add(genre.getTopChildren(10,\"genre\"));\n  indexReader.close();\n  taxoReader.close();\n  return results;\n}\n", "docstring": "user runs a query and aggregates facets by summing their association values .", "partition": "test"}
{"idx": "5041", "code": "public ReverseGeoCode(InputStream placenames,boolean majorOnly) throws IOException {\n  createKdTree(placenames,majorOnly);\n}\n", "docstring": "parse the raw text geonames file .", "partition": "test"}
{"idx": "5042", "code": "public static String fromTag(ListTag<Tag> tag){\n  StringBuilder builder=new StringBuilder();\n  builder.append(ARRAY_START);\n  boolean start=true;\n  for (  Tag value : tag.getValue()) {\n    if (start) {\n      start=false;\n    }\n else {\n      builder.append(ELEMENT_SEPERATOR);\n    }\n    builder.append(fromGenericTag(value));\n  }\n  builder.append(ARRAY_END);\n  return builder.toString();\n}\n", "docstring": "creates a mojangson string from the given list tag .", "partition": "test"}
{"idx": "5043", "code": "private XMLElement2 createAnotherElement(){\n  return new XMLElement2(this.entities,this.ignoreWhitespace,false,this.ignoreCase);\n}\n", "docstring": "creates a new similar xml element . < p > you should override this method when subclassing xmlelement .", "partition": "test"}
{"idx": "5044", "code": "public synchronized void reset(){\n  labels.clear();\n  labels.put(SensisionConstants.SENSISION_LABEL_TOPIC,this.topic);\n  labels.put(SensisionConstants.SENSISION_LABEL_GROUPID,this.groupid);\n  for (int i=0; i < this.counters.length; i++) {\n    if (null == this.counters[i]) {\n      continue;\n    }\n    labels.put(SensisionConstants.SENSISION_LABEL_PARTITION,Integer.toString(i));\n    Sensision.clear(SensisionConstants.SENSISION_CLASS_WARP_KAFKA_CONSUMER_OFFSET,labels);\n    this.counters[i]=null;\n  }\n}\n", "docstring": "remove per partition counters and associated sensision metrics", "partition": "test"}
{"idx": "5045", "code": "public Vector rotateInRadian(double radians){\n  final double length=length();\n  double angle=angleInRadian();\n  angle+=radians;\n  final Vector result=new Vector(Math.cos(angle),Math.sin(angle));\n  return result.multiply(length);\n}\n", "docstring": "return a new instance of vector rotated from the given number of radians .", "partition": "test"}
{"idx": "5046", "code": "public void connectionLost(java.lang.Throwable cause){\n  int rc=-1;\n  led.setAmber();\n  led.setFlash();\n  setTitleText(\"Connection Lost!....Reconnecting\");\nsynchronized (this) {\n    writeLogln(\"MQTT Connection Lost!....Reconnecting to \" + mqtt.getServerURI());\n  }\n  try {\n    while ((rc == -1) && connected) {\n      try {\nsynchronized (connLostWait) {\n          connLostWait.wait(10000);\n        }\n      }\n catch (      InterruptedException iex) {\n      }\nsynchronized (this) {\n        if (connected) {\n          writeLog(\"MQTT reconnecting......\");\n          try {\n            connect(mqtt.getServerURI(),optionsComp.isPersistenceSelected());\n            rc=0;\n          }\n catch (          MqttException mqte) {\n            rc=-1;\n          }\n          if (rc == -1) {\n            writeLogln(\"failed\");\n          }\n else {\n            writeLogln(\"success !\");\n          }\n        }\n      }\n    }\n    setTitleText(\"\");\n  }\n catch (  Exception ex) {\n    setTitleText(\"MQTT connection broken !\");\n    ex.printStackTrace();\n    disconnect();\n  }\n finally {\n    if (led.isFlashing()) {\n      led.setFlash();\n    }\n  }\n  if (connected) {\n    led.setGreen();\n    setConnected(true);\n  }\n else {\n    led.setRed();\n    setConnected(false);\n  }\n}\n", "docstring": "the method is part of the mqttsimplecallback interface < br > in the event of the mqtt connection being broken the led is set to colour amber and made to flash . the code then keeps trying to reconnect until either a successful reconnect occurs or the disconnect button is pressed . finally the led is stopped flashing and set to green or red depending upon whether the connect was successful or not .", "partition": "test"}
{"idx": "5047", "code": "public String headerOut(String name){\n  ArrayList<String> keys=_headerKeysOut;\n  int headerSize=keys.size();\n  for (int i=0; i < headerSize; i++) {\n    String oldKey=keys.get(i);\n    if (oldKey.equalsIgnoreCase(name)) {\n      return (String)_headerValuesOut.get(i);\n    }\n  }\n  if (name.equalsIgnoreCase(\"content-length\")) {\n    return _contentLengthOut >= 0 ? String.valueOf(_contentLengthOut) : null;\n  }\n  if (name.equalsIgnoreCase(\"content-type\")) {\n    return _contentTypeOut;\n  }\n  return null;\n}\n", "docstring": "returns the value of an already set output header .", "partition": "test"}
{"idx": "5048", "code": "private static Map<String,Set<String>> parseSparseFields(MultivaluedMap<String,String> queryParams){\n  Map<String,Set<String>> result=new HashMap<>();\n  for (  Map.Entry<String,List<String>> kv : queryParams.entrySet()) {\n    String key=kv.getKey();\n    if (key.startsWith(\"fields[\") && key.endsWith(\"]\")) {\n      String type=key.substring(7,key.length() - 1);\n      LinkedHashSet<String> filters=new LinkedHashSet<>();\n      for (      String filterParams : kv.getValue()) {\n        Collections.addAll(filters,filterParams.split(\",\"));\n      }\n      if (!filters.isEmpty()) {\n        result.put(type,filters);\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "parses queryparams and produces sparsefields map .", "partition": "test"}
{"idx": "5049", "code": "public Element signWithWSSSAMLTokenProfile(Document doc,java.security.cert.Certificate cert,String assertionID,String algorithm,List ids) throws XMLSignatureException {\n  return signWithWSSSAMLTokenProfile(doc,cert,assertionID,algorithm,ids,SOAPBindingConstants.WSF_10_VERSION);\n}\n", "docstring": "sign part of the xml document referered by the supplied a list of id attributes of nodes", "partition": "test"}
{"idx": "5050", "code": "@Override public void addURL(URL url,boolean isScanned){\n  if (containsURL(url)) {\n    return;\n  }\n  super.addURL(url,isScanned);\n  if (isScanned)   _pendingScanRoots.add(new ScanRoot(url,null));\n}\n", "docstring": "adds the url to the urlclassloader .", "partition": "test"}
{"idx": "5051", "code": "public void add(final int start,final int end,final byte status){\n  final int s=start - mStart;\n  if (s < mInterval.length && end > mStart) {\n    Arrays.fill(mInterval,Math.max(s,0),Math.min(end - mStart,mInterval.length),status);\n  }\n}\n", "docstring": "add points to the interval . regions outside the overall interval are ignored .", "partition": "test"}
{"idx": "5052", "code": "public void reset(){\n  alpha=initAlpha;\n  neighborhoodSize=initNeighborhoodSize;\n}\n", "docstring": "resets som network to initial values .", "partition": "test"}
{"idx": "5053", "code": "private void reload(){\n  Document doc=textPane.getDocument();\n  doc.putProperty(Document.StreamDescriptionProperty,null);\n  reference=currentReference;\n  loadPage(currentPage);\n}\n", "docstring": "reloads the current page and jumps to the same position . this is only used for testing purposes , because usually the pages shouldn \"'\" t change while the program is running .", "partition": "test"}
{"idx": "5054", "code": "protected void drawHexagon(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow,String direction){\n  Polygon hexagon=new Polygon();\n  if (direction.equals(mxConstants.DIRECTION_NORTH) || direction.equals(mxConstants.DIRECTION_SOUTH)) {\n    hexagon.addPoint(x + (int)(0.5 * w),y);\n    hexagon.addPoint(x + w,y + (int)(0.25 * h));\n    hexagon.addPoint(x + w,y + (int)(0.75 * h));\n    hexagon.addPoint(x + (int)(0.5 * w),y + h);\n    hexagon.addPoint(x,y + (int)(0.75 * h));\n    hexagon.addPoint(x,y + (int)(0.25 * h));\n  }\n else {\n    hexagon.addPoint(x + (int)(0.25 * w),y);\n    hexagon.addPoint(x + (int)(0.75 * w),y);\n    hexagon.addPoint(x + w,y + (int)(0.5 * h));\n    hexagon.addPoint(x + (int)(0.75 * w),y + h);\n    hexagon.addPoint(x + (int)(0.25 * w),y + h);\n    hexagon.addPoint(x,y + (int)(0.5 * h));\n  }\n  drawPolygon(hexagon,fillColor,fillPaint,penColor,shadow);\n}\n", "docstring": "draws a hexagon shape for the given parameters .", "partition": "test"}
{"idx": "5055", "code": "private boolean isStatic(Field field){\n  int modifier=field.getModifiers();\n  if (Modifier.isStatic(modifier)) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "this is used to determine if a field is static . if a field is static it should not be considered as a default field . this ensures the default annotation does not pick up static finals .", "partition": "test"}
{"idx": "5056", "code": "public int outstandingRequests(){\n  return outstanding.get();\n}\n", "docstring": "get the current number of outstanding ( batch ) requests to google pub / sub .", "partition": "test"}
{"idx": "5057", "code": "final public static String toString(final byte[] key,final int off,final int len){\n  if (key == null)   return NULL;\n  final StringBuilder sb=new StringBuilder(len * 4 + 2);\n  sb.append(\"[\");\n  for (int i=off; i < off + len; i++) {\n    if (i > 0)     sb.append(\",\");\n    sb.append(Integer.toString(key[i] & 0xff));\n  }\n  sb.append(\"]\");\n  return sb.toString();\n}\n", "docstring": "formats a key as a series of comma delimited unsigned bytes .", "partition": "test"}
{"idx": "5058", "code": "public void init(String componentName) throws LogException {\n  accessLogger=Logger.getLogger(componentName + \".access\");\n  errorLogger=Logger.getLogger(componentName + \".error\");\n}\n", "docstring": "initializes the logging for the component .", "partition": "test"}
{"idx": "5059", "code": "private View fillLeft(int pos,int nextRight){\n  if (DEBUG)   Log.i(TAG,\"fillLeft() pos: \" + pos + \" nextRight: \"+ nextRight+ M_FIRST_POSITION+ mFirstPosition);\n  View selectedView=null;\n  final int end=mListPadding.left;\n  while (nextRight > end && pos >= 0) {\n    View temp=makeColumn(pos,nextRight,false);\n    if (temp != null) {\n      selectedView=temp;\n    }\n    nextRight=mReferenceView.getLeft() - mHorizontalSpacing;\n    mFirstPosition=pos;\n    pos-=mNumRows;\n  }\n  if (mStackFromBottom) {\n    mFirstPosition=Math.max(0,pos + 1);\n  }\n  return selectedView;\n}\n", "docstring": "fills the list from pos to the left of the list view .", "partition": "test"}
{"idx": "5060", "code": "public void removeDefaultValue(String value) throws SMSException, SSOException {\n  Set defaultValues=getDefaultValues();\n  if (defaultValues != Collections.EMPTY_SET) {\n    defaultValues.remove(value);\n    updateDefaultValues(defaultValues);\n  }\n}\n", "docstring": "removes the given value from the set of default values .", "partition": "test"}
{"idx": "5061", "code": "public static int keyBindingDescriptionToKeyCode(String keyBindingDescription){\n  if (StringUtils.isBlank(keyBindingDescription)) {\n    return 0;\n  }\n else   if (keyBindingDescription.equals(\"ESC\")) {\n    return SWT.ESC;\n  }\n else   if (keyBindingDescription.equals(\"F1\")) {\n    return SWT.F1;\n  }\n else   if (keyBindingDescription.equals(\"F2\")) {\n    return SWT.F2;\n  }\n else   if (keyBindingDescription.equals(\"F3\")) {\n    return SWT.F3;\n  }\n else   if (keyBindingDescription.equals(\"F4\")) {\n    return SWT.F4;\n  }\n else   if (keyBindingDescription.equals(\"F5\")) {\n    return SWT.F5;\n  }\n else   if (keyBindingDescription.equals(\"F6\")) {\n    return SWT.F6;\n  }\n else   if (keyBindingDescription.equals(\"F7\")) {\n    return SWT.F7;\n  }\n else   if (keyBindingDescription.equals(\"F8\")) {\n    return SWT.F8;\n  }\n else   if (keyBindingDescription.equals(\"F9\")) {\n    return SWT.F9;\n  }\n else   if (keyBindingDescription.equals(\"F10\")) {\n    return SWT.F10;\n  }\n else   if (keyBindingDescription.equals(\"F11\")) {\n    return SWT.F11;\n  }\n else   if (keyBindingDescription.equals(\"F12\")) {\n    return SWT.F12;\n  }\n else   if (keyBindingDescription.equals(\"SCRLOCK\")) {\n    return SWT.SCROLL_LOCK;\n  }\n else   if (VALID_ACTION_KEY_CODES.indexOf(keyBindingDescription.charAt(keyBindingDescription.length() - 1)) != -1) {\n    return keyBindingDescription.charAt(keyBindingDescription.length() - 1);\n  }\n else {\n    return 0;\n  }\n}\n", "docstring": "returns the key code for the specified key binding description .", "partition": "test"}
{"idx": "5062", "code": "public void testPutCauseEviction(){\n  List<String> log=new ArrayList<String>();\n  LruCache<String,String> cache=newRemovalLogCache(log);\n  cache.put(\"a\",\"A\");\n  cache.put(\"b\",\"B\");\n  cache.put(\"c\",\"C\");\n  cache.put(\"b\",\"B2\");\n  assertEquals(Arrays.asList(\"b=B>B2\"),log);\n  assertSnapshot(cache,\"a\",\"A\",\"c\",\"C\",\"b\",\"B2\");\n}\n", "docstring": "replacing the value for a key doesn \"'\" t cause an eviction but it does bring the replaced entry to the front of the queue .", "partition": "test"}
{"idx": "5063", "code": "protected Signature mergeSignatures(Signature first,Signature second,int numBins){\n  int d2=-1;\n  for (int i=0; i < second.spec.length; i+=2) {\n    if (second.spec[i] >= 0) {\n      assert (d2 == -1) : \"Merging with non-1-signature?!?\";\n      d2=i;\n    }\n  }\n  assert (d2 >= 0) : \"Merging with empty signature?\";\n  if (first.spec[d2] >= 0) {\n    return null;\n  }\n  final ModifiableDBIDs intersection=DBIDUtil.intersection(first.ids,second.ids);\n  final int support=intersection.size();\n  double width=(second.spec[d2 + 1] - second.spec[d2] + 1.) / (double)numBins;\n  double expect=first.ids.size() * width;\n  if (support <= expect || support < minClusterSize) {\n    return null;\n  }\n  final double test=PoissonDistribution.rawProbability(support,expect);\n  if ((poissonThreshold) <= test) {\n    return null;\n  }\n  int[] spec=first.spec.clone();\n  spec[d2]=second.spec[d2];\n  spec[d2 + 1]=second.spec[d2];\n  final Signature newsig=new Signature(spec,intersection);\n  if (LOG.isDebugging()) {\n    LOG.debug(newsig.toString());\n  }\n  return newsig;\n}\n", "docstring": "generates a merged signature of this and another one , where the other signature must be a 1 - signature .", "partition": "test"}
{"idx": "5064", "code": "public IgniteDeploymentException(Throwable cause){\n  this(cause.getMessage(),cause);\n}\n", "docstring": "creates new exception with given throwable as a nested cause and source of error message .", "partition": "test"}
{"idx": "5065", "code": "public synchronized boolean enter(CnATreeElement obj) throws TransactionAbortedException {\n  if (aborted) {\n    throw new TransactionAbortedException();\n  }\n  visited.add(obj);\n  if (this.initiator != null) {\n    return false;\n  }\n  this.initiator=obj;\n  aborted=false;\n  return true;\n}\n", "docstring": "the given objects enters the transaction .", "partition": "test"}
{"idx": "5066", "code": "public Options addOption(Option opt){\n  String key=opt.getKey();\n  if (opt.hasLongOpt()) {\n    longOpts.put(opt.getLongOpt(),opt);\n  }\n  if (opt.isRequired()) {\n    if (requiredOpts.contains(key)) {\n      requiredOpts.remove(requiredOpts.indexOf(key));\n    }\n    requiredOpts.add(key);\n  }\n  shortOpts.put(key,opt);\n  return this;\n}\n", "docstring": "adds an option instance", "partition": "test"}
{"idx": "5067", "code": "private void pauseForClientToJoin(){\n  Wait.pause(2000);\n}\n", "docstring": "the joined event fires when the first client handshake is processed . this pauses long enough to allow the rest of the client sockets to complete handshaking before making the client leave . without doing this subsequent socket handshakes that are processed could fire join events after departure events and then a departure event again . if you see failures in testclientmembershipeventsinserver , try increasing this timeout .", "partition": "test"}
{"idx": "5068", "code": "public void propertyChange(PropertyChangeEvent pce){\n  if (pce.getPropertyName() == MapBean.BackgroundProperty && backgroundSlave) {\n    map.setBckgrnd((Paint)pce.getNewValue());\n  }\n}\n", "docstring": "propertychangelistener method , to listen for the source map \"'\" s background changes . act on if necessary .", "partition": "test"}
{"idx": "5069", "code": "public TransitionBuilder addFrame(int imageResource){\n  mFrames.add(imageResource);\n  return this;\n}\n", "docstring": "add a frame to the transition animation .", "partition": "test"}
{"idx": "5070", "code": "public Class<?>[] scanForClasses(String location,Class<?> implementedInterface) throws Exception {\n  LOG.debug(\"Scanning for classes at \'\" + location + \"\' (Implementing: \'\"+ implementedInterface.getName()+ \"\')\");\n  List<Class<?>> classes=new ArrayList<Class<?>>();\n  Set<String> resourceNames=findResourceNames(location,\"\",\".class\");\n  for (  String resourceName : resourceNames) {\n    String className=toClassName(resourceName);\n    Class<?> clazz=classLoader.loadClass(className);\n    if (Modifier.isAbstract(clazz.getModifiers()) || clazz.isEnum() || clazz.isAnonymousClass()) {\n      LOG.debug(\"Skipping non-instantiable class: \" + className);\n      continue;\n    }\n    if (!implementedInterface.isAssignableFrom(clazz)) {\n      continue;\n    }\n    try {\n      ClassUtils.instantiate(className,classLoader);\n    }\n catch (    Exception e) {\n      throw new CassandraMigrationException(\"Unable to instantiate class: \" + className,e);\n    }\n    classes.add(clazz);\n    LOG.debug(\"Found class: \" + className);\n  }\n  return classes.toArray(new Class<?>[classes.size()]);\n}\n", "docstring": "scans the classpath for concrete classes under the specified package implementing this interface . non - instantiable abstract classes are filtered out .", "partition": "test"}
{"idx": "5071", "code": "private static boolean needsSkylightUpdate(FastCubeBlockAccess access,MutableBlockPos pos){\n  if (access.getBlockLightOpacity(pos) >= 15) {\n    return false;\n  }\n  int computedLight=access.computeLightValue(pos);\n  for (  EnumFacing facing : EnumFacing.values()) {\n    pos.move(facing);\n    int currentLight=access.getLightFor(EnumSkyBlock.SKY,pos);\n    int currentOpacity=Math.max(1,access.getBlockLightOpacity(pos));\n    pos.move(facing.getOpposite());\n    if (computedLight == currentLight - currentOpacity) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "determines if the block at the given position requires a skylight update .", "partition": "test"}
{"idx": "5072", "code": "@Override public String toString(){\n  StringBuffer buffer=new StringBuffer(\"CellConstraints\");\n  buffer.append(\"[x=\");\n  buffer.append(gridX);\n  buffer.append(\"; y=\");\n  buffer.append(gridY);\n  buffer.append(\"; w=\");\n  buffer.append(gridWidth);\n  buffer.append(\"; h=\");\n  buffer.append(gridHeight);\n  buffer.append(\"; hAlign=\");\n  buffer.append(hAlign);\n  buffer.append(\"; vAlign=\");\n  buffer.append(vAlign);\n  if (!EMPTY_INSETS.equals(insets)) {\n    buffer.append(\"; insets=\");\n    buffer.append(insets);\n  }\n  buffer.append(\"; honorsVisibility=\");\n  buffer.append(honorsVisibility);\n  buffer.append(\']\');\n  return buffer.toString();\n}\n", "docstring": "constructs and returns a string representation of this constraints object .", "partition": "test"}
{"idx": "5073", "code": "private ArrayList<PROCLUSCluster> assignPoints(ArrayDBIDs m_current,long[][] dimensions,Relation<V> database){\n  ModifiableDBIDs[] clusterIDs=new ModifiableDBIDs[dimensions.length];\n  for (int i=0; i < m_current.size(); i++) {\n    clusterIDs[i]=DBIDUtil.newHashSet();\n  }\n  DBIDArrayIter m_i=m_current.iter();\n  for (DBIDIter it=database.iterDBIDs(); it.valid(); it.advance()) {\n    V p=database.get(it);\n    double minDist=Double.NaN;\n    int best=-1, i=0;\n    for (m_i.seek(0); m_i.valid(); m_i.advance(), i++) {\n      V m=database.get(m_i);\n      double currentDist=manhattanSegmentalDistance(p,m,dimensions[i]);\n      if (!(minDist <= currentDist)) {\n        minDist=currentDist;\n        best=i;\n      }\n    }\n    assert best >= 0;\n    ModifiableDBIDs ids=clusterIDs[best];\n    ids.add(it);\n  }\n  ArrayList<PROCLUSCluster> clusters=new ArrayList<>(m_current.size());\n  for (int i=0; i < dimensions.length; i++) {\n    ModifiableDBIDs objectIDs=clusterIDs[i];\n    if (!objectIDs.isEmpty()) {\n      long[] clusterDimensions=dimensions[i];\n      double[] centroid=Centroid.make(database,objectIDs).getArrayRef();\n      clusters.add(new PROCLUSCluster(objectIDs,clusterDimensions,centroid));\n    }\n else {\n      clusters.add(null);\n    }\n  }\n  if (LOG.isDebugging()) {\n    StringBuilder msg=new StringBuilder();\n    msg.append(\'\\n\');\n    msg.append(\"clusters \").append(clusters).append(\'\\n\');\n    LOG.debugFine(msg.toString());\n  }\n  return clusters;\n}\n", "docstring": "assigns the objects to the clusters .", "partition": "test"}
{"idx": "5074", "code": "public double slideSubtree(MutableTree tree){\n  double logHastingsRatio;\n  NodeRef i, newParent, newChild;\n  do {\n    i=tree.getNode(MathUtils.nextInt(tree.getNodeCount()));\n  }\n while (tree.getRoot() == i);\n  NodeRef iP=tree.getParent(i);\n  NodeRef CiP=getOtherChild(tree,iP,i);\n  NodeRef PiP=tree.getParent(iP);\n  double delta=getDelta();\n  double oldHeight=tree.getNodeHeight(iP);\n  double newHeight=oldHeight + delta;\n  if (delta > 0) {\n    if (PiP != null && tree.getNodeHeight(PiP) < newHeight) {\n      newParent=PiP;\n      newChild=iP;\n      while (tree.getNodeHeight(newParent) < newHeight) {\n        newChild=newParent;\n        newParent=tree.getParent(newParent);\n        if (newParent == null)         break;\n      }\n      tree.beginTreeEdit();\n      if (tree.isRoot(newChild)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.setRoot(iP);\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      int possibleSources=intersectingEdges(tree,newChild,oldHeight,null);\n      logHastingsRatio=Math.log(1.0 / (double)possibleSources);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logHastingsRatio=0.0;\n    }\n  }\n else {\n    if (tree.getNodeHeight(i) > newHeight) {\n      return Double.NEGATIVE_INFINITY;\n    }\n    if (tree.getNodeHeight(CiP) > newHeight) {\n      ArrayList newChildren=new ArrayList();\n      int possibleDestinations=intersectingEdges(tree,CiP,newHeight,newChildren);\n      if (newChildren.size() == 0) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      int childIndex=MathUtils.nextInt(newChildren.size());\n      newChild=(NodeRef)newChildren.get(childIndex);\n      newParent=tree.getParent(newChild);\n      tree.beginTreeEdit();\n      if (tree.isRoot(iP)) {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(newParent,iP);\n        tree.setRoot(CiP);\n      }\n else {\n        tree.removeChild(iP,CiP);\n        tree.removeChild(PiP,iP);\n        tree.removeChild(newParent,newChild);\n        tree.addChild(iP,newChild);\n        tree.addChild(PiP,CiP);\n        tree.addChild(newParent,iP);\n      }\n      tree.setNodeHeight(iP,newHeight);\n      tree.endTreeEdit();\n      logHastingsRatio=Math.log((double)possibleDestinations);\n    }\n else {\n      tree.setNodeHeight(iP,newHeight);\n      logHastingsRatio=0.0;\n    }\n  }\n  return logHastingsRatio;\n}\n", "docstring": "do a probablistic subtree slide move .", "partition": "test"}
{"idx": "5075", "code": "public boolean isInitialized(){\n  return _initialized;\n}\n", "docstring": "indicates if the bean was initialized at least once . for optimization where one does not want to call loadkeys ( ) if a key is already loaded .", "partition": "test"}
{"idx": "5076", "code": "public String toString(){\n  return Double.toString(get());\n}\n", "docstring": "returns the string representation of the current value .", "partition": "test"}
{"idx": "5077", "code": "boolean checkCameraSize(CameraOptions cameraId){\n  boolean sizeAvailable=false;\n  Camera camera=null;\n  Method method=getCameraOpenMethod();\n  if (method != null) {\n    try {\n      camera=(Camera)method.invoke(camera,new Object[]{cameraId.getValue()});\n    }\n catch (    Exception e) {\n      camera=Camera.open();\n    }\n  }\n else {\n    camera=Camera.open();\n  }\n  if (camera == null) {\n    return false;\n  }\n  Parameters param=camera.getParameters();\n  List<Camera.Size> sizes=param.getSupportedPreviewSizes();\n  for (  Camera.Size size : sizes) {\n    if ((size.width == H264Config.QVGA_WIDTH && size.height == H264Config.QVGA_HEIGHT) || (size.width == H264Config.CIF_WIDTH && size.height == H264Config.CIF_HEIGHT) || (size.width == H264Config.VGA_WIDTH && size.height == H264Config.VGA_HEIGHT)) {\n      sizeAvailable=true;\n      break;\n    }\n  }\n  camera.release();\n  return sizeAvailable;\n}\n", "docstring": "check if good camera sizes are available for encoder . must be used only before open camera .", "partition": "test"}
{"idx": "5078", "code": "public void append(final String s){\n  if (first) {\n    first=false;\n  }\n else {\n    builder.append(space);\n  }\n  builder.append(s);\n}\n", "docstring": "append string separated by space .", "partition": "test"}
{"idx": "5079", "code": "public static ByteArrayOutputStream encode(String plaintext) throws IOException, MessagingException {\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  byte[] in=plaintext.getBytes();\n  ByteArrayOutputStream inStream=new ByteArrayOutputStream();\n  inStream.write(in,0,in.length);\n  if ((in.length % 3) == 1) {\n    inStream.write(0);\n    inStream.write(0);\n  }\n else   if ((in.length % 3) == 2) {\n    inStream.write(0);\n  }\n  inStream.writeTo(MimeUtility.encode(out,\"base64\"));\n  return out;\n}\n", "docstring": "encode string to base64", "partition": "test"}
{"idx": "5080", "code": "public LookupListTable lookupList(){\n  if (lookupListTable.get() == null) {\n    lookupListTable.compareAndSet(null,gsub.createLookupList());\n  }\n  return lookupListTable.get();\n}\n", "docstring": "return information about the lookup tables in this gsub table .", "partition": "test"}
{"idx": "5081", "code": "public long sum(){\n  return deltaSum.get();\n}\n", "docstring": "get aggregate summation of time - deltas , in nanoseconds .", "partition": "test"}
{"idx": "5082", "code": "private static boolean isWordBoundary(CharSequence singleChar,String wordSeparators){\n  return TextUtils.isEmpty(singleChar) || wordSeparators.contains(singleChar);\n}\n", "docstring": "takes a character sequence with a single character and checks if the character occurs in a list of word separators or is empty .", "partition": "test"}
{"idx": "5083", "code": "public void executeBlocking(String desc,BlockingConsumer<MongoClient> operation) throws InterruptedException {\n  while (true) {\n    MongoClient primary=primaryConnectionSupplier.get();\n    try {\n      operation.accept(primary);\n      return;\n    }\n catch (    Throwable t) {\n      errorHandler.accept(desc,t);\n    }\n  }\n}\n", "docstring": "execute the supplied operation using the primary , blocking until a primary is available . whenever the operation stops ( e . g . , if the primary is no longer primary ) , then restart the operation using the current primary .", "partition": "test"}
{"idx": "5084", "code": "public void write(char[] cbuf) throws java.io.IOException {\n  write(cbuf,0,cbuf.length);\n}\n", "docstring": "write an array of characters .", "partition": "test"}
{"idx": "5085", "code": "protected TableViewer createTable(Composite parent,int span){\n  Table table=new Table(parent,SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER| SWT.SINGLE| SWT.FULL_SELECTION);\n  GridData data=new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL);\n  data.horizontalSpan=span;\n  table.setLayoutData(data);\n  TableLayout layout=new TableLayout();\n  layout.addColumnData(new ColumnWeightData(100,true));\n  table.setLayout(layout);\n  TableColumn col=new TableColumn(table,SWT.NONE);\n  col.setResizable(true);\n  return new TableViewer(table);\n}\n", "docstring": "creates the table for the repositories", "partition": "test"}
{"idx": "5086", "code": "public String typeAsString(){\n  String typeStr=\"?\";\n  String subtypeStr=\"?\";\nswitch (this.type) {\ncase ETYPE_CONTROL:\n    typeStr=\" control/\";\nswitch (this.subtype) {\ncase ESTYPE_HEADER:\n    subtypeStr=\"header\";\n  break;\ncase ESTYPE_FOOTER:\nsubtypeStr=\"footer\";\nbreak;\n}\nbreak;\ncase ETYPE_TRANSACTIONS:\ntypeStr=\" transaction/\";\nswitch (this.subtype) {\ncase ESTYPE_TRAN_START:\nsubtypeStr=\"start\";\nbreak;\ncase ESTYPE_TRAN_COMMIT:\nsubtypeStr=\"commit\";\nbreak;\ncase ESTYPE_TRAN_ROLLBACK:\nsubtypeStr=\"rollback\";\nbreak;\ncase ESTYPE_TRAN_ROLLBACK_TO_SAVEPOINT:\nsubtypeStr=\"rollback_to_savepoint\";\nbreak;\ncase ESTYPE_TRAN_AUDIT:\nsubtypeStr=\"audit\";\nbreak;\n}\nbreak;\ncase ETYPE_LCR_DATA:\ntypeStr=\" LCR data/\";\nswitch (this.subtype) {\ncase ESTYPE_LCR_INSERT:\nsubtypeStr=\"insert\";\nbreak;\ncase ESTYPE_LCR_DELETE:\nsubtypeStr=\"delete\";\nbreak;\ncase ESTYPE_LCR_UPDATE:\nsubtypeStr=\"update\";\nbreak;\ncase ESTYPE_LCR_LOB_WRITE:\nsubtypeStr=\"LOB write\";\nbreak;\ncase ESTYPE_LCR_LOB_TRIM:\nsubtypeStr=\"LOB trim\";\nbreak;\ncase ESTYPE_LCR_LOB_ERASE:\nsubtypeStr=\"LOB erase\";\nbreak;\ncase ESTYPE_LCR_DDL:\nsubtypeStr=\"DDL\";\nbreak;\n}\nbreak;\ncase ETYPE_LCR_PLOG:\ntypeStr=\" LCR plog/\";\nswitch (this.subtype) {\ncase ESTYPE_LCR_PLOG_IFILE:\nsubtypeStr=\"include plog file\";\nbreak;\ncase ESTYPE_LCR_PLOG_IFILE_STATS:\nsubtypeStr=\"include plog file - rowcount\";\nbreak;\n}\nbreak;\ndefault :\ntypeStr=\" ?\" + this.type + \"/\";\nsubtypeStr=\"?\" + this.subtype;\n}\nreturn typeStr + subtypeStr;\n}\n", "docstring": "human readable text description of type and subtype", "partition": "test"}
{"idx": "5087", "code": "protected boolean[] canHandleMissing(boolean nominalPredictor,boolean numericPredictor,boolean stringPredictor,boolean datePredictor,boolean relationalPredictor,boolean multiInstance,int classType,boolean predictorMissing,boolean classMissing,int missingLevel){\n  if (missingLevel == 100) {\n    print(\"100% \");\n  }\n  print(\"missing\");\n  if (predictorMissing) {\n    print(\" predictor\");\n    if (classMissing) {\n      print(\" and\");\n    }\n  }\n  if (classMissing) {\n    print(\" class\");\n  }\n  print(\" values\");\n  printAttributeSummary(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType);\n  print(\"...\");\n  ArrayList<String> accepts=new ArrayList<String>();\n  accepts.add(\"missing\");\n  accepts.add(\"value\");\n  accepts.add(\"train\");\n  int numTrain=getNumInstances(), numTest=getNumInstances(), numClasses=2;\n  return runBasicTest(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType,missingLevel,predictorMissing,classMissing,numTrain,numTest,numClasses,accepts);\n}\n", "docstring": "checks basic missing value handling of the scheme . if the missing values cause an exception to be thrown by the scheme , this will be recorded .", "partition": "test"}
{"idx": "5088", "code": "private void disableButtons(){\n  for (  DeployCommand cmd : DeployCommand.values()) {\n    setButtonEnabled(cmd,false);\n  }\n  butDone.setEnabled(false);\n  setLoadEnabled(false);\n  setUnloadEnabled(false);\n  setAssaultDropEnabled(false);\n}\n", "docstring": "disables all buttons in the interface", "partition": "test"}
{"idx": "5089", "code": "public Artifact load(File path) throws IOException {\n  return load(new ArtifactName(path.getName()),path);\n}\n", "docstring": "load artifact at path , using path name as artifactid", "partition": "test"}
{"idx": "5090", "code": "private static final boolean isHeaderEnd(StringBuilder sb){\n  int len=sb.length();\n  if (len > 2) {\n    if (LF2.equals(sb.substring(len - 2))) {\n      return true;\n    }\n  }\n  if (len > 4) {\n    if (CRLF2.equals(sb.substring(len - 4))) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "check if the current stringbuilder trailing characters is an http header end ( empty crlf ) .", "partition": "test"}
{"idx": "5091", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.addElement(new Option(\"\\tSQL query to execute.\",\"Q\",1,\"-Q <query>\"));\n  result.addElement(new Option(\"\\tReturn sparse rather than normal instances.\",\"S\",0,\"-S\"));\n  result.addElement(new Option(\"\\tThe username to use for connecting.\",\"U\",1,\"-U <username>\"));\n  result.addElement(new Option(\"\\tThe password to use for connecting.\",\"P\",1,\"-P <password>\"));\n  result.add(new Option(\"\\tThe custom properties file to use instead of default ones,\\n\" + \"\\tcontaining the database parameters.\\n\" + \"\\t(default: none)\",\"custom-props\",1,\"-custom-props <file>\"));\n  result.addElement(new Option(\"\\tEnables debug output.\",\"D\",0,\"-D\"));\n  return result.elements();\n}\n", "docstring": "returns an enumeration describing the available options < p >", "partition": "test"}
{"idx": "5092", "code": "public TSActionDelay(TransitSectionAction tsa,int delay){\n  _tsa=tsa;\n  _delay=delay;\n}\n", "docstring": "a runnable that implements delayed execution of a transitsectionaction", "partition": "test"}
{"idx": "5093", "code": "public DAddExtensions(JDialog parent,X509ExtensionSet extensions,PublicKey authorityPublicKey,X500Name authorityCertName,BigInteger authorityCertSerialNumber,PublicKey subjectPublicKey){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  setTitle(res.getString(\"DAddExtensions.Title\"));\n  this.extensions=(X509ExtensionSet)extensions.clone();\n  this.authorityPublicKey=authorityPublicKey;\n  this.authorityCertName=authorityCertName;\n  this.authorityCertSerialNumber=authorityCertSerialNumber;\n  this.subjectPublicKey=subjectPublicKey;\n  initComponents();\n}\n", "docstring": "creates new daddextensions dialog .", "partition": "test"}
{"idx": "5094", "code": "public void add(IMultiPoint pt){\n  if (inProgress) {\n    throw new ConcurrentModificationException(\"Can\'t add point while iterator in progress\");\n  }\n  points.add(pt);\n}\n", "docstring": "add point to the result set .", "partition": "test"}
{"idx": "5095", "code": "private DiscoveryInformation verifyDiscovered(AuthSuccess authResp,DiscoveryInformation discovered) throws DiscoveryException {\n  if (authResp == null || authResp.getIdentity() == null) {\n    _log.info(\"Assertion is not about an identifier\");\n    return null;\n  }\n  if (authResp.isVersion2())   return verifyDiscovered2(authResp,discovered);\n else   return verifyDiscovered1(authResp,discovered);\n}\n", "docstring": "verifies the dicovery information matches the data received in a authentication response from an openid provider .", "partition": "test"}
{"idx": "5096", "code": "public boolean generate(ReportDescription description,Date date){\n  try {\n    Integer targetDateInt=Integer.parseInt(format.format(date));\n    AnalysisResultSet logAggregation=makeLogAnal(description,targetDateInt);\n    Report report=new Report();\n    report.setSendTime(new Date());\n    report.setTargetDate(date);\n    report.setLogReport(logAggregation);\n    report.setTargets(description.getTargets());\n    logger.debug(\"generated > \" + report);\n    reportRepository.save(report);\n    return true;\n  }\n catch (  Exception e) {\n    logger.error(e.getMessage(),e);\n    return false;\n  }\n}\n", "docstring": "generate report using description and target date", "partition": "test"}
{"idx": "5097", "code": "@Override public void updateTextViews(Recharge recharge){\n  unitTypeTextView.setText(recharge.getUnits());\n  unitValueTextView.setText(String.valueOf(recharge.getCurrentAmount()));\n  costTextView.setText(Currency.localize(recharge.getCurrentCost(),true));\n  rechargeName.setText(recharge.getTitle());\n  confirmationTextView.setText(\"Add \" + recharge.getCurrentAmount() + \" extra \"+ recharge.getUnits()+ \" for the month?\");\n  if (recharge.getCurrentAmount() == recharge.getInitialAmount()) {\n    downArrow.setVisibility(View.INVISIBLE);\n  }\n else {\n    downArrow.setVisibility(View.VISIBLE);\n  }\n}\n", "docstring": "update the text views based on the recharge data being passed in .", "partition": "test"}
{"idx": "5098", "code": "private ConcurrentMap<GridCacheVersion,IgniteInternalTx> transactionMap(IgniteInternalTx tx){\n  return (tx.near() && !tx.local()) ? nearIdMap : idMap;\n}\n", "docstring": "gets transaction id map depending on transaction type .", "partition": "test"}
{"idx": "5099", "code": "public static byte[] decode(byte[] data,String pri_key){\n  try {\n    Cipher cipher=Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    java.security.Key k=getPrivateKey(pri_key);\n    cipher.init(Cipher.DECRYPT_MODE,k);\n    byte[] deBytes=cipher.doFinal(data);\n    return deBytes;\n  }\n catch (  Exception e) {\n    log.error(pri_key,e);\n  }\n  return null;\n}\n", "docstring": "decode data with private key .", "partition": "test"}
{"idx": "5100", "code": "public static int deriveARGB(Color color1,Color color2,float midPoint){\n  int r=color1.getRed() + (int)((color2.getRed() - color1.getRed()) * midPoint + 0.5f);\n  int g=color1.getGreen() + (int)((color2.getGreen() - color1.getGreen()) * midPoint + 0.5f);\n  int b=color1.getBlue() + (int)((color2.getBlue() - color1.getBlue()) * midPoint + 0.5f);\n  int a=color1.getAlpha() + (int)((color2.getAlpha() - color1.getAlpha()) * midPoint + 0.5f);\n  return ((a & 0xFF) << 24) | ((r & 0xFF) << 16) | ((g & 0xFF) << 8)| (b & 0xFF);\n}\n", "docstring": "derives the argb value for a color based on an offset between two other colors .", "partition": "test"}
{"idx": "5101", "code": "public void addLandingPad(int x,int z){\n  BlockPosition pos=new BlockPosition(x,0,z);\n  if (!spawnLocations.contains(pos)) {\n    spawnLocations.add(pos);\n    occupiedLandingPads.put(pos,false);\n  }\n}\n", "docstring": "adds a landing pad to the station", "partition": "test"}
{"idx": "5102", "code": "static AttackStrategy create(String params){\n  String[] arg=params.split(\",\",-1);\n  if (arg.length != 3) {\n    throw new IllegalArgumentException(\"Invalid compound description: \'\" + params + \"\'\");\n  }\n  Pair<String,String> desc=parseStrategy(arg[1]);\n  TargetSelectionStrategy targeter=TargetSelectionStrategyFactory.get(desc.first(),desc.second());\n  desc=parseStrategy(arg[2]);\n  PositioningStrategy positioner=PositioningStrategyFactory.get(desc.first(),desc.second());\n  return new CompoundAttackStrategy(getSubStrategy(arg[0]),targeter,positioner);\n}\n", "docstring": "create a new strategy .", "partition": "test"}
{"idx": "5103", "code": "final public void writeChunk(L locator,KVO<O>[] chunk) throws MockStaleLocatorException {\nsynchronized (this) {\n    if (staleLocators.contains(locator.getPartitionId())) {\n      throw new MockStaleLocatorException(locator);\n    }\n    if (!knownLocators.contains(locator.getPartitionId())) {\n      throw new RuntimeException(\"Locator not registered on DS: \" + locator);\n    }\n  }\n  acceptWrite(locator,chunk);\n}\n", "docstring": "write a chunk onto the data service .", "partition": "test"}
{"idx": "5104", "code": "public Event event(int id){\n  if (!host) {\n    return (Event)events.get(new Integer(id));\n  }\n  return null;\n}\n", "docstring": "disabled for hosted mode .", "partition": "test"}
{"idx": "5105", "code": "private void initValues(){\n  IPreferenceStore store=doGetPreferenceStore();\n  final String storedItems=store.getString(CheckerPreferences.PREF_CHECKER_CUSTOM_CLASSES);\n  if (!storedItems.equals(\"\")) {\n    customCheckers.setItems(storedItems.split(\",\"));\n  }\n}\n", "docstring": "initialize the values in the table to the preference values", "partition": "test"}
{"idx": "5106", "code": "void sync(int sourceRepoIndex,int destRepoIndex,AuthenticationInfo subject) throws IOException {\n  LOG.info(\"Sync started\");\n  NotebookAuthorization auth=NotebookAuthorization.getInstance();\n  NotebookRepo srcRepo=getRepo(sourceRepoIndex);\n  NotebookRepo dstRepo=getRepo(destRepoIndex);\n  List<NoteInfo> allSrcNotes=srcRepo.list(subject);\n  List<NoteInfo> srcNotes=auth.filterByUser(allSrcNotes,subject);\n  List<NoteInfo> dstNotes=dstRepo.list(subject);\n  Map<String,List<String>> noteIds=notesCheckDiff(srcNotes,srcRepo,dstNotes,dstRepo,subject);\n  List<String> pushNoteIds=noteIds.get(pushKey);\n  List<String> pullNoteIds=noteIds.get(pullKey);\n  List<String> delDstNoteIds=noteIds.get(delDstKey);\n  if (!pushNoteIds.isEmpty()) {\n    LOG.info(\"Notes with the following IDs will be pushed\");\n    for (    String id : pushNoteIds) {\n      LOG.info(\"ID : \" + id);\n    }\n    pushNotes(subject,pushNoteIds,srcRepo,dstRepo,false);\n  }\n else {\n    LOG.info(\"Nothing to push\");\n  }\n  if (!pullNoteIds.isEmpty()) {\n    LOG.info(\"Notes with the following IDs will be pulled\");\n    for (    String id : pullNoteIds) {\n      LOG.info(\"ID : \" + id);\n    }\n    pushNotes(subject,pullNoteIds,dstRepo,srcRepo,true);\n  }\n else {\n    LOG.info(\"Nothing to pull\");\n  }\n  if (!delDstNoteIds.isEmpty()) {\n    LOG.info(\"Notes with the following IDs will be deleted from dest\");\n    for (    String id : delDstNoteIds) {\n      LOG.info(\"ID : \" + id);\n    }\n    deleteNotes(subject,delDstNoteIds,dstRepo);\n  }\n else {\n    LOG.info(\"Nothing to delete from dest\");\n  }\n  LOG.info(\"Sync ended\");\n}\n", "docstring": "copies new / updated notes from source to destination storage", "partition": "test"}
{"idx": "5107", "code": "public void list(PrintStream out){\n  out.println(\"-- listing properties --\");\n  Hashtable<String,Object> h=new Hashtable<>();\n  enumerate(h);\n  for (Enumeration<String> e=h.keys(); e.hasMoreElements(); ) {\n    String key=e.nextElement();\n    String val=(String)h.get(key);\n    if (val.length() > 40) {\n      val=val.substring(0,37) + \"...\";\n    }\n    out.println(key + \"=\" + val);\n  }\n}\n", "docstring": "prints this property list out to the specified output stream . this method is useful for debugging .", "partition": "test"}
{"idx": "5108", "code": "@Nullable public static String md5(@Nullable File file,@Nullable IgniteLogger log){\n  if (file != null)   return file.isFile() ? fileMd5(file,log) : directoryMd5(file,log);\n  return null;\n}\n", "docstring": "calculates md5 checksum for the given file o directory . for directories tries to walk all nested files accumulating the result .", "partition": "test"}
{"idx": "5109", "code": "@Override public boolean hasNext(){\n  if (allRowsResult.size() == 0) {\n    return false;\n  }\n  totalRecordCounter++;\n  listRecordCounter++;\n  if (listRecordCounter == 0 || (listRecordCounter >= currentRowPointer.size() && currentListCounter < allRowsResult.size())) {\n    listRecordCounter=0;\n    currentRowPointer=allRowsResult.get(currentListCounter);\n    currentListCounter++;\n  }\n  return totalRecordCounter < totalNumberOfRecords;\n}\n", "docstring": "method to check more result is present or not", "partition": "test"}
{"idx": "5110", "code": "public void trimToSize(){\n  delegate.trimToSize();\n}\n", "docstring": "trims the capacity of this list to be the list \"'\" s current size .", "partition": "test"}
{"idx": "5111", "code": "public final void clear(){\n  caches.clear();\n  sections.clear();\n}\n", "docstring": "clears the caches and sections data set", "partition": "test"}
{"idx": "5112", "code": "static Set<Node> toNodeSet(Iterator<Node> i){\n  Set<Node> nodeSet=new HashSet<Node>();\n  while (i.hasNext()) {\n    Node n=i.next();\n    nodeSet.add(n);\n    if (n.getNodeType() == Node.ELEMENT_NODE) {\n      NamedNodeMap nnm=n.getAttributes();\n      for (int j=0, length=nnm.getLength(); j < length; j++) {\n        nodeSet.add(nnm.item(j));\n      }\n    }\n  }\n  return nodeSet;\n}\n", "docstring": "converts an iterator to a set of nodes , according to the xpath data model .", "partition": "test"}
{"idx": "5113", "code": "public static void runConcurrently(final Callable<Void> task,final int times) throws Exception {\n  final ExecutorService service=Executors.newFixedThreadPool(5);\n  final List<Future<?>> futures=new ArrayList<Future<?>>();\n  for (int i=0; i < times; i++) {\n    futures.add(service.submit(task));\n  }\n  for (  final Future<?> future : futures) {\n    future.get();\n  }\n}\n", "docstring": "runs a task concurrently . allows to test thread - safe behavior .", "partition": "test"}
{"idx": "5114", "code": "private static ArrayList<ContainerVm> createVmList(int brokerId,int containerVmsNumber){\n  ArrayList<ContainerVm> containerVms=new ArrayList<ContainerVm>();\n  for (int i=0; i < containerVmsNumber; ++i) {\n    ArrayList<ContainerPe> peList=new ArrayList<ContainerPe>();\n    int vmType=i / (int)Math.ceil((double)containerVmsNumber / 4.0D);\n    for (int j=0; j < ConstantsExamples.VM_PES[vmType]; ++j) {\n      peList.add(new ContainerPe(j,new CotainerPeProvisionerSimple((double)ConstantsExamples.VM_MIPS[vmType])));\n    }\n    containerVms.add(new PowerContainerVm(IDs.pollId(ContainerVm.class),brokerId,(double)ConstantsExamples.VM_MIPS[vmType],(float)ConstantsExamples.VM_RAM[vmType],ConstantsExamples.VM_BW,ConstantsExamples.VM_SIZE,\"Xen\",new ContainerSchedulerTimeSharedOverSubscription(peList),new ContainerRamProvisionerSimple(ConstantsExamples.VM_RAM[vmType]),new ContainerBwProvisionerSimple(ConstantsExamples.VM_BW),peList,ConstantsExamples.SCHEDULING_INTERVAL));\n  }\n  return containerVms;\n}\n", "docstring": "create the virtual machines and add them to the list", "partition": "test"}
{"idx": "5115", "code": "public static void addPortUse(Map<StoragePort,Integer> portUseCounts,StoragePort port){\n  if (!portUseCounts.containsKey(port)) {\n    portUseCounts.put(port,1);\n  }\n else {\n    Integer newCount=portUseCounts.get(port) + 1;\n    portUseCounts.put(port,newCount);\n  }\n}\n", "docstring": "adds a use count to a port , which indicates one initiator is using the port this is public static because the storageportsassignertest uses it .", "partition": "test"}
{"idx": "5116", "code": "@Override public synchronized CacheObject<V> put(K key,CacheObject<V> value){\n  if (cache.size() >= maxSize) {\n    if (removeExpired() <= 0) {\n      if (cacheFullRemoveType instanceof RemoveTypeNotRemove) {\n        return null;\n      }\n      if (fullRemoveOne() == null) {\n        return null;\n      }\n    }\n  }\n  value.setEnterTime(System.currentTimeMillis());\n  cache.put(key,value);\n  return value;\n}\n", "docstring": "put element , key and value both not allowed to be null", "partition": "test"}
{"idx": "5117", "code": "public void removeModelChange(String tableName,ModelValidator listener){\n  if (tableName == null || listener == null)   return;\n  String propertyName=m_globalValidators.contains(listener) ? tableName + \"*\" : tableName + listener.getAD_Client_ID();\n  ArrayList<ModelValidator> list=m_modelChangeListeners.get(propertyName);\n  if (list == null)   return;\n  list.remove(listener);\n  if (list.size() == 0)   m_modelChangeListeners.remove(propertyName);\n}\n", "docstring": "remove model change listener", "partition": "test"}
{"idx": "5118", "code": "private String createConnectionName(){\n  StringBuilder nameBuffer=new StringBuilder();\n  nameBuffer.append(getConnectionType());\n  nameBuffer.append(\"-\");\n  nameBuffer.append(_host);\n  nameBuffer.append(\"-\");\n  nameBuffer.append(_port);\n  return nameBuffer.toString();\n}\n", "docstring": "constructs a name for the connection using the connection type , host , and port .", "partition": "test"}
{"idx": "5119", "code": "public Query execute(PageContext pc,SQL sql,int maxrows,int fetchsize,TimeSpan timeout) throws PageException {\n  Stopwatch stopwatch=new Stopwatch(Stopwatch.UNIT_NANO);\n  stopwatch.start();\n  String prettySQL=null;\n  Selects selects=null;\n  try {\n    SelectParser parser=new SelectParser();\n    selects=parser.parse(sql.getSQLString());\n    Query q=qoq.execute(pc,sql,selects,maxrows);\n    q.setExecutionTime(stopwatch.time());\n    return q;\n  }\n catch (  SQLParserException spe) {\n    prettySQL=SQLPrettyfier.prettyfie(sql.getSQLString());\n    try {\n      Query query=executer.execute(pc,sql,prettySQL,maxrows);\n      query.setExecutionTime(stopwatch.time());\n      return query;\n    }\n catch (    PageException ex) {\n    }\n  }\ncatch (  PageException e) {\n  }\n  try {\n    boolean isUnion=false;\n    Set<String> tables=null;\n    if (selects != null) {\n      HSQLUtil2 hsql2=new HSQLUtil2(selects);\n      isUnion=hsql2.isUnion();\n      tables=hsql2.getInvokedTables();\n    }\n else {\n      if (prettySQL == null)       prettySQL=SQLPrettyfier.prettyfie(sql.getSQLString());\n      HSQLUtil hsql=new HSQLUtil(prettySQL);\n      tables=hsql.getInvokedTables();\n      isUnion=hsql.isUnion();\n    }\n    String strSQL=StringUtil.replace(sql.getSQLString(),\"[\",\"\",false);\n    strSQL=StringUtil.replace(strSQL,\"]\",\"\",false);\n    sql.setSQLString(strSQL);\n    return _execute(pc,sql,maxrows,fetchsize,timeout,stopwatch,tables,isUnion);\n  }\n catch (  ParseException e) {\n    throw new DatabaseException(e.getMessage(),null,sql,null);\n  }\n}\n", "docstring": "executes a query on the queries inside the cld fusion enviroment", "partition": "test"}
{"idx": "5120", "code": "@POST @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Path(\"/{id}/discover\") @CheckPermission(roles={Role.TENANT_ADMIN}) public TaskResourceRep discoverHost(@PathParam(\"id\") URI id){\n  ArgValidator.checkFieldUriType(id,Host.class,\"id\");\n  Host host=queryObject(Host.class,id,true);\n  return doDiscoverHost(host);\n}\n", "docstring": "discovers ( refreshes ) a host . this is an asynchronous call .", "partition": "test"}
{"idx": "5121", "code": "public static final void readFully(InputStream i,byte b[],int off,int len) throws IOException {\n  if (len < 0) {\n    throw new IndexOutOfBoundsException();\n  }\n  int n=0;\n  while (n < len) {\n    int count=i.read(b,off + n,len - n);\n    if (count < 0) {\n      throw new EOFException();\n    }\n    n+=count;\n  }\n}\n", "docstring": "the read fully method from data input stream is very useful for all types of streams . . .", "partition": "test"}
{"idx": "5122", "code": "private void drawLines(Canvas canvas){\n  for (int i=0; i < connectionOrder.size() - 1; i++) {\n    drawLine(canvas,circles[connectionOrder.get(i)],circles[connectionOrder.get(i + 1)]);\n  }\n}\n", "docstring": "draw lines between the connectors", "partition": "test"}
{"idx": "5123", "code": "public static File toFile(JavaFileObject javaFileObject){\n  return new File(javaFileObject.getName());\n}\n", "docstring": "gets the file from a java file object .", "partition": "test"}
{"idx": "5124", "code": "public WritableRaster createCompatibleWritableRaster(int w,int h){\n  int[] bOffs={2,1,0};\n  return Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,w,h,w * 3,3,bOffs,null);\n}\n", "docstring": "creates a writableraster with the specified width and height , that has a data layout ( samplemodel ) compatible with this colormodel .", "partition": "test"}
{"idx": "5125", "code": "public static MultiSegmentPowerLawBipartiteGraph buildRandomMultiSegmentBipartiteGraph(int maxNumSegments,int maxNumEdgesPerSegment,int leftSize,int rightSize,double edgeProbability,Random random){\n  MultiSegmentPowerLawBipartiteGraph multiSegmentPowerLawBipartiteGraph=new MultiSegmentPowerLawBipartiteGraph(maxNumSegments,maxNumEdgesPerSegment,leftSize / 2,(int)(rightSize * edgeProbability / 2),2.0,rightSize / 2,(int)(leftSize * edgeProbability / 2),2.0,new IdentityEdgeTypeMask(),new NullStatsReceiver());\n  for (int i=0; i < leftSize; i++) {\n    for (int j=0; j < rightSize; j++) {\n      if (random.nextDouble() < edgeProbability) {\n        multiSegmentPowerLawBipartiteGraph.addEdge(i,j,(byte)0);\n      }\n    }\n  }\n  return multiSegmentPowerLawBipartiteGraph;\n}\n", "docstring": "build a random left - regular bipartite graph of given left and right sizes .", "partition": "test"}
{"idx": "5126", "code": "public static String execute(String command){\n  return SubprocessUttility.execute(command);\n}\n", "docstring": "execute a command in the environment", "partition": "test"}
{"idx": "5127", "code": "public synchronized void updateProgress(final int value){\n  final Thread t=Thread.currentThread();\n  final MyInteger v=mIndividualThreadProgress.get(t);\n  if (v == null) {\n    mIndividualThreadProgress.put(t,new MyInteger(value));\n  }\n else {\n    v.setValue(value);\n  }\n  if (value > mLastReportedProgress) {\n    int min=Integer.MAX_VALUE;\n    for (    final MyInteger m : mIndividualThreadProgress.values()) {\n      if (m.getValue() < min) {\n        min=m.getValue();\n      }\n    }\n    if (min > mLastReportedProgress) {\n      mLastReportedProgress=min;\n      Diagnostic.progress(\"Processed \" + min + \"% of \"+ mName);\n    }\n  }\n}\n", "docstring": "update progress , safe to use for multithreading .", "partition": "test"}
{"idx": "5128", "code": "private ContextHandler createContextHandler(String directory,boolean isInJar,File installRootDirectory,int expiresInSeconds){\n  final ContextHandler contextHandler=new ContextHandler();\n  final ResourceHandler resourceHandler=new ExpiresResourceHandler(expiresInSeconds);\n  final String directoryWithSlash=\"/\" + directory;\n  contextHandler.setContextPath(directoryWithSlash);\n  Resource directoryResource=getDirectoryResource(directory,isInJar,installRootDirectory);\n  directoryResource=new JsMinifyingResource(directoryResource);\n  if (isInJar) {\n    directoryResource=new CachingResource(directoryResource,directoryWithSlash);\n  }\n  resourceHandler.setBaseResource(directoryResource);\n  if (!isInJar) {\n    resourceHandler.setMinMemoryMappedContentLength(0);\n  }\n  contextHandler.setHandler(resourceHandler);\n  return contextHandler;\n}\n", "docstring": "creates a context handler for the directory .", "partition": "test"}
{"idx": "5129", "code": "public boolean startsWith(java.lang.CharSequence prefix){\n  return startsWith(prefix,0);\n}\n", "docstring": "indicates if this text starts with the specified prefix .", "partition": "test"}
{"idx": "5130", "code": "private List<ContainerInitializer> jspInitializers(){\n  JettyJasperInitializer sci=new JettyJasperInitializer();\n  ContainerInitializer initializer=new ContainerInitializer(sci,null);\n  List<ContainerInitializer> initializers=new ArrayList<ContainerInitializer>();\n  initializers.add(initializer);\n  return initializers;\n}\n", "docstring": "ensure the jsp engine is initialized correctly", "partition": "test"}
{"idx": "5131", "code": "public static TempPath createDirectory() throws IOException {\n  return wrap(Files.createTempDirectory(PREFIX));\n}\n", "docstring": "creates a new temporary directory in the default temporary file location .", "partition": "test"}
{"idx": "5132", "code": "public static String toString(int partition[][]){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"{\");\n  for (int i=0; i < partition.length; i++) {\n    sb.append(\" \" + Arrays.toString(partition[i]));\n  }\n  sb.append(\" }\");\n  return sb.toString();\n}\n", "docstring": "tostring - a string representation for the super - class partition \"'\" partition \"'\" .", "partition": "test"}
{"idx": "5133", "code": "public static boolean isCategoryChildOf(ServletRequest request,String parentProductCategoryId,String productCategoryId){\n  return isCategoryChildOf((Delegator)request.getAttribute(\"delegator\"),(LocalDispatcher)request.getAttribute(\"dispatcher\"),parentProductCategoryId,productCategoryId);\n}\n", "docstring": "scipio : returns true only if the category id is child of the given parent category id . < p > note : is caching", "partition": "test"}
{"idx": "5134", "code": "@Override public boolean input(Instance instance){\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  if (m_NewBatch) {\n    resetQueue();\n    m_NewBatch=false;\n  }\n  push((Instance)instance.copy());\n  return true;\n}\n", "docstring": "input an instance for filtering . ordinarily the instance is processed and made available for output immediately . some filters require all instances be read before producing output .", "partition": "test"}
{"idx": "5135", "code": "public Collection<String> listColumns(String table) throws DatabaseException {\n  Collection<String> result=new ArrayList<String>();\n  ResultSet rs=null;\n  try {\n    DatabaseMetaData dbm=connection.getMetaData();\n    rs=dbm.getColumns(null,null,table,null);\n    while (rs.next()) {\n      result.add(rs.getString(\"COLUMN_NAME\"));\n    }\n  }\n catch (  SQLException e) {\n    throw new DatabaseException(e);\n  }\n finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n  }\n  return result;\n}\n", "docstring": "get a list of all of the columns on a table .", "partition": "test"}
{"idx": "5136", "code": "public void addCreatedResource(Location location,Resource resource){\n  resourceList.add(resource);\n  locationToResourceMap.put(location,resource);\n}\n", "docstring": "add a resource created within the analyzed method .", "partition": "test"}
{"idx": "5137", "code": "public void signalEvent(){\n  Collection<Semaphore> semaphores=_semaphores.values();\n  for (  Semaphore semaphore : semaphores) {\n    semaphore.release();\n    semaphores.remove(semaphore);\n  }\n}\n", "docstring": "signals the semaphore when the event arrives .", "partition": "test"}
{"idx": "5138", "code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof KeyedObjects)) {\n    return false;\n  }\n  KeyedObjects that=(KeyedObjects)obj;\n  int count=getItemCount();\n  if (count != that.getItemCount()) {\n    return false;\n  }\n  for (int i=0; i < count; i++) {\n    Comparable k1=getKey(i);\n    Comparable k2=that.getKey(i);\n    if (!k1.equals(k2)) {\n      return false;\n    }\n    Object o1=getObject(i);\n    Object o2=that.getObject(i);\n    if (o1 == null) {\n      if (o2 != null) {\n        return false;\n      }\n    }\n else {\n      if (!o1.equals(o2)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "tests this object for equality with an arbitrary object .", "partition": "test"}
{"idx": "5139", "code": "protected boolean isQuorumMaintained(){\n  if (nodeCount == 1) {\n    log.info(\"There\'s no way to maintain quorum on single node deployments. Proceed anyway.\");\n    return true;\n  }\n  int quorumNodeCnt=nodeCount / 2 + 1;\n  CoordinatorClient coordinatorClient=coordinator.getCoordinatorClient();\n  List<Service> allActiveDbsvcs=coordinatorClient.locateAllSvcsAllVers(Constants.DBSVC_NAME);\n  List<String> otherActiveDbsvcIds=new ArrayList<>();\n  String mySvcId=coordinator.getMySvcId();\n  String localDbSvcId=\"db\" + mySvcId.substring(mySvcId.lastIndexOf(\"-\"));\n  for (  Service activeDbsvc : allActiveDbsvcs) {\n    if (!localDbSvcId.equals(activeDbsvc.getId())) {\n      otherActiveDbsvcIds.add(activeDbsvc.getId());\n    }\n  }\n  log.info(\"List of active dbsvc instances on other nodes: {}, expect {} instances to maintain quorum\",otherActiveDbsvcIds,quorumNodeCnt);\n  boolean isMaintained=otherActiveDbsvcIds.size() >= quorumNodeCnt;\n  if (!isMaintained) {\n    log.info(\"quorum would lost if reboot the current node. Retrying...\");\n  }\n  return isMaintained;\n}\n", "docstring": "check if node_count / 2 + 1 dbsvc instances are active on other nodes in the cluster so that if the current node is powered off , a quorum will still be maintained .", "partition": "test"}
{"idx": "5140", "code": "public static void scheduleNextAlarm(Context context){\n  scheduleNextAlarm(context,AlertUtils.createAlarmManager(context),REMINDER_QUERY_BATCH_SIZE,System.currentTimeMillis());\n}\n", "docstring": "schedules the nearest upcoming alarm , to refresh notifications . this is historically done in the provider but we dupe this here so the unbundled app will work on devices that have modified this portion of the provider . this has the limitation of querying events within some interval from now ( ie . looks at reminders for all events occurring in the next week ) . this means for example , a 2 week notification will not fire on time .", "partition": "test"}
{"idx": "5141", "code": "public void requestStop(){\n  stopRequested.set(true);\n}\n", "docstring": "allows scheduling a request to stop the workload .", "partition": "test"}
{"idx": "5142", "code": "@SafeVarargs public static <T>T[] join(IntFunction<T[]> arrayFunction,T[]... arrays){\n  if (arrays.length == 0) {\n    return arrayFunction.apply(0);\n  }\n  if (arrays.length == 1) {\n    return arrays[0];\n  }\n  if (arrays.length == 2) {\n    return join(arrayFunction,arrays[0],arrays[1]);\n  }\n  T[] notNull=null;\n  int finalSize=0;\n  int nullArrays=0;\n  List<T> list=new ArrayList<>(arrays.length * 10);\n  for (  T[] array : arrays) {\n    if ((array == null) || (array.length == 0)) {\n      nullArrays++;\n    }\n else {\n      notNull=array;\n      finalSize+=array.length;\n      Collections.addAll(list,array);\n    }\n  }\n  if (nullArrays == arrays.length) {\n    return arrayFunction.apply(0);\n  }\n  if (nullArrays == (arrays.length - 1)) {\n    return notNull;\n  }\n  return list.toArray(arrayFunction.apply(list.size()));\n}\n", "docstring": "joins arrays together , if only one array contains elements it will be returned without coping anything . < br > if given array or arrays is empty , new empty array will be returned .", "partition": "test"}
{"idx": "5143", "code": "private static Set<String> splitPath(RelaxedURL url){\n  Set<String> results=new HashSet<String>();\n  Set<String> queries=normalizeQuery(url.getQuery());\n  results.add(\"/\");\n  for (  String q : queries) {\n    results.add(\"/?\" + q);\n  }\n  Set<String> paths=splitPath(url.getPath());\n  results.addAll(paths);\n  for (  String p : paths) {\n    for (    String q : queries) {\n      results.add(p + \"?\" + q);\n    }\n  }\n  return results;\n}\n", "docstring": "returns a list of sub parts of path of a resource name .", "partition": "test"}
{"idx": "5144", "code": "public ActionForward initBestSellingReport(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws ApplicationException, OperationException {\n  ActionForward fwd=init(mapping,form,request,response);\n  if (fwd != null)   return fwd;\n  SellingItemForm reportForm=(SellingItemForm)form;\n  String timePeriod=ReportDateManager.TODAY;\n  String dateRange=Constants.FIXED_DATE_RANGE;\n  reportForm.setTimePeriod(timePeriod);\n  reportForm.setDateRange(dateRange);\n  reportForm.setFromDate(\"\");\n  reportForm.setToDate(\"\");\n  reportForm.validate(mapping,request);\n  return mapping.findForward(INIT_BEST_SELLING_REPORT);\n}\n", "docstring": "initialise best selling items report", "partition": "test"}
{"idx": "5145", "code": "@Override public void transactionBegin(){\n  for (  BigdataGraphListener listener : listeners) {\n    listener.transactionBegin();\n  }\n}\n", "docstring": "notification of transaction beginning .", "partition": "test"}
{"idx": "5146", "code": "public synchronized void add(Job job){\n  boolean canRunImmediately=dagManager.addJob(job);\n  if (canRunImmediately) {\n    LOG.debug(\"Job \" + job + \" is ready to run.\");\n    jobsToRun.add(job);\n  }\n  incrementSubmittedJobCount();\n}\n", "docstring": "add the given job to run . it will attempt to acquire the locks needed by the job , but if not possible , it will wait until the jobs that hold the required locks give them up . with this requirement in mind , jobs will be executed in the order that they are added .", "partition": "test"}
{"idx": "5147", "code": "public void addConstant(ConstantPoolEntry entry){\n  if (entry instanceof Utf8Constant) {\n    Utf8Constant utf8=(Utf8Constant)entry;\n    _utf8Map.put(utf8.getValue(),utf8);\n  }\n  _entries.add(entry);\n}\n", "docstring": "adds a new constant .", "partition": "test"}
{"idx": "5148", "code": "static void writeRule(ZoneOffsetTransitionRule rule,DataOutput out) throws IOException {\n  int month=rule.month;\n  byte dom=rule.dom;\n  int dow=rule.dow;\n  LocalTime time=rule.time;\n  boolean timeEndOfDay=rule.timeEndOfDay;\n  TimeDefinition timeDefinition=rule.timeDefinition;\n  ZoneOffset standardOffset=rule.standardOffset;\n  ZoneOffset offsetBefore=rule.offsetBefore;\n  ZoneOffset offsetAfter=rule.offsetAfter;\n  int timeSecs=(timeEndOfDay ? 86400 : time.toSecondOfDay());\n  int stdOffset=standardOffset.getTotalSeconds();\n  int beforeDiff=offsetBefore.getTotalSeconds() - stdOffset;\n  int afterDiff=offsetAfter.getTotalSeconds() - stdOffset;\n  int timeByte=(timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);\n  int stdOffsetByte=(stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);\n  int beforeByte=(beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);\n  int afterByte=(afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);\n  int dowByte=(dow == -1 ? 0 : dow);\n  int b=(month << 28) + ((dom + 32) << 22) + (dowByte << 19)+ (timeByte << 14)+ (timeDefinition.ordinal() << 12)+ (stdOffsetByte << 4)+ (beforeByte << 2)+ afterByte;\n  out.writeInt(b);\n  if (timeByte == 31) {\n    out.writeInt(timeSecs);\n  }\n  if (stdOffsetByte == 255) {\n    out.writeInt(stdOffset);\n  }\n  if (beforeByte == 3) {\n    out.writeInt(offsetBefore.getTotalSeconds());\n  }\n  if (afterByte == 3) {\n    out.writeInt(offsetAfter.getTotalSeconds());\n  }\n}\n", "docstring": "writes the state of the transition rule to the stream .", "partition": "test"}
{"idx": "5149", "code": "@SuppressWarnings(\"unchecked typecast\") public static <T>TypeSerializer<T> deserialize(byte[] bytes) throws IOException {\n  ByteArrayInputStream bis=new ByteArrayInputStream(bytes);\n  ObjectInput in=null;\n  try {\n    in=new ObjectInputStream(bis);\n    return (TypeSerializer<T>)in.readObject();\n  }\n catch (  ClassNotFoundException e) {\n    throw new IOException(\"Could not deserialize class\");\n  }\n finally {\n    try {\n      bis.close();\n    }\n catch (    IOException ex) {\n    }\n    try {\n      if (in != null) {\n        in.close();\n      }\n    }\n catch (    IOException ex) {\n    }\n  }\n}\n", "docstring": "deserializes a serialized typeserializer", "partition": "test"}
{"idx": "5150", "code": "public void testRemainderKnuthMultiDigitsByOneDigit(){\n  byte aBytes[]={113,-83,123,-5,18,-34,67,39,-29};\n  byte bBytes[]={2,-3,-4,-50};\n  int aSign=1;\n  int bSign=-1;\n  byte rBytes[]={2,-37,-60,59};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.remainder(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "docstring": "divide the number of multi digits by the number of one digit", "partition": "test"}
{"idx": "5151", "code": "public void showSelectedNeuronProperties(){\n  NeuronDialog dialog=NeuronDialog.createNeuronDialog(getSelectedNeurons());\n  dialog.setModalityType(Dialog.ModalityType.MODELESS);\n  dialog.pack();\n  dialog.setLocationRelativeTo(null);\n  dialog.setVisible(true);\n}\n", "docstring": "creates and displays the neuron properties dialog .", "partition": "test"}
{"idx": "5152", "code": "public void encrypt(byte[] in,int length){\n  int pos=0;\n  while (pos < in.length && pos < length) {\n    encryptBlock(in,pos,length);\n    pos+=blockSize;\n  }\n}\n", "docstring": "perform pseudo \" in - place \" encryption", "partition": "test"}
{"idx": "5153", "code": "private static boolean hasChangesOfChildren(long last,PageContext pc,Class clazz){\n  java.lang.reflect.Method[] methods=clazz.getMethods();\n  java.lang.reflect.Method method;\n  Class[] params;\n  for (int i=0; i < methods.length; i++) {\n    method=methods[i];\n    if (method.getDeclaringClass() == clazz) {\n      if (_hasChangesOfChildren(pc,last,method.getReturnType()))       return true;\n      params=method.getParameterTypes();\n      for (int y=0; y < params.length; y++) {\n        if (_hasChangesOfChildren(pc,last,params[y]))         return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "check if one of the children is changed", "partition": "test"}
{"idx": "5154", "code": "private WindowStuffHelper(){\n}\n", "docstring": "prevent initializing this class .", "partition": "test"}
{"idx": "5155", "code": "public static String removeSpecialChar(String tempStr){\n  if (tempStr != null) {\n    tempStr=replace(tempStr,\",\",\"\",true,true);\n    tempStr=replace(tempStr,\".\",\"\",true,true);\n    tempStr=replace(tempStr,\"!\",\"\",true,true);\n    tempStr=replace(tempStr,\"?\",\"\",true,true);\n    tempStr=replace(tempStr,\"\'\",\"\",true,true);\n    tempStr=replace(tempStr,\":\",\"\",true,true);\n    tempStr=replace(tempStr,\"(\",\"\",true,true);\n    tempStr=replace(tempStr,\")\",\"\",true,true);\n    tempStr=replace(tempStr,\"+\",\"\",true,true);\n    tempStr=replace(tempStr,\"-\",\"\",true,true);\n    tempStr=replace(tempStr,\">\",\"\",true,true);\n    tempStr=replace(tempStr,\"<\",\"\",true,true);\n    tempStr=replace(tempStr,\"/\",\"\",true,true);\n    while (tempStr.indexOf(\"  \") > 0) {\n      tempStr=replace(tempStr,\"  \",\" \",true,true);\n    }\n    tempStr=replace(tempStr,\"\t\",\" \",true,true);\n  }\n  return tempStr;\n}\n", "docstring": "for some save scnearios and analysis we should remove special characters , i . e . html", "partition": "test"}
{"idx": "5156", "code": "public RunScriptAction(NetworkPanel networkPanel){\n  super(\"Run Script...\");\n  putValue(SMALL_ICON,ResourceManager.getImageIcon(\"Script.png\"));\n  putValue(SHORT_DESCRIPTION,\"Open and apply a network .bsh script to this network\");\n  this.networkPanel=networkPanel;\n}\n", "docstring": "create a new script action for the workspace .", "partition": "test"}
{"idx": "5157", "code": "public T webImage(String url){\n  return webImage(url,true,false,0xFF000000);\n}\n", "docstring": "load the webview with an image with a url . zoom is enabled without zoom control . default background color is solid black ( 0xff000000 ) .", "partition": "test"}
{"idx": "5158", "code": "private Map<Installment,List<Receipt>> consolidateTuplesInstallmentWise(final List<InstallmentReceiptTuple> tuples){\n  final Map<Installment,List<Receipt>> consolidated=new HashMap<Installment,List<Receipt>>();\n  for (  final InstallmentReceiptTuple t : tuples) {\n    List<Receipt> receiptsForInstallment=consolidated.get(t.installment);\n    if (receiptsForInstallment == null) {\n      receiptsForInstallment=new ArrayList<Receipt>();\n      consolidated.put(t.installment,receiptsForInstallment);\n    }\n    if (!receiptsForInstallment.contains(t.receipt))     receiptsForInstallment.add(t.receipt);\n  }\n  LOGGER.info(\"consolidateTuplesInstallmentWise() returned: \" + consolidated);\n  return consolidated;\n}\n", "docstring": "constructs a list of receipts for each installment .", "partition": "test"}
{"idx": "5159", "code": "public static boolean isValidEmail(String email){\n  final String emailPattern=\"^[_A-Za-z0-9-]+(\\\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(\\\\.[A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$\";\n  Matcher matcher;\n  Pattern pattern=Pattern.compile(emailPattern);\n  matcher=pattern.matcher(email);\n  if (matcher != null)   return matcher.matches();\n else   return false;\n}\n", "docstring": "checks if the input parameter is a valid email .", "partition": "test"}
{"idx": "5160", "code": "public void add(LineMergeDirectedEdge directedEdge){\n  directedEdges.add(directedEdge);\n}\n", "docstring": "adds a directed edge which is known to form part of this line .", "partition": "test"}
{"idx": "5161", "code": "public static ApplicationXml parseApplicationXmlFromFile(File file,EntityResolver entityResolver) throws IOException, JDOMException {\n  InputStream in=null;\n  try {\n    in=new FileInputStream(file);\n    return parseApplicationXml(in,entityResolver);\n  }\n  finally {\n    if (in != null) {\n      try {\n        in.close();\n      }\n catch (      IOException ioe) {\n      }\n    }\n  }\n}\n", "docstring": "parses a deployment descriptor stored in a regular file .", "partition": "test"}
{"idx": "5162", "code": "public ChannelEntry newConnection(ReadSelectorThread readHandler,SelectionKey key){\n  SocketChannel channel=(SocketChannel)key.channel();\n  WriteSelectorThread writeHandler=_selectorManager.getWriteHandler(key.channel());\n  Socket socket=channel.socket();\n  InetSocketAddress socketAddress=(InetSocketAddress)(socket == null ? null : socket.getRemoteSocketAddress());\n  ChannelEntry channelEntry=new ChannelEntry(writeHandler,readHandler,key,socketAddress,this);\n  m_Channels.put(channel,channelEntry);\n  if (socketAddress != null) {\n    _clientToChannel.put(socketAddress,channelEntry);\n  }\n  if (_logger.isLoggable(Level.FINE))   _logger.log(Level.FINE,\"Connected new client from [\" + channelEntry.getClientEndPointAddress() + \"] endpoint.\");\n  return channelEntry;\n}\n", "docstring": "called by the connmgr thread when a new connection is created .", "partition": "test"}
{"idx": "5163", "code": "public String report(){\n  StringBuffer report=new StringBuffer();\n  intHashTable=new int[table.tableSize];\n  calculateSlotUsage();\n  int max=maxCollisions();\n  int[] slotUsageCount=new int[max + 1];\n  for (  int i : intHashTable) {\n    slotUsageCount[i]++;\n  }\n  report.append(\"Total number of entries: \" + numEntries + \"\\n\");\n  report.append(\"   Load factor:\" + (numEntries / (1.0f * table.tableSize) + \"\\n\\n\"));\n  float weightedAvg=0.0f;\n  int numNonEmpty=0;\n  report.append(\"Number of hits\\tNumber of slots\\n\");\n  for (int j=0; j <= max; j++) {\n    if (slotUsageCount[j] != 0) {\n      report.append(j + \"\\t\" + slotUsageCount[j]+ \"\\n\");\n      if (j != 0) {\n        weightedAvg+=slotUsageCount[j] * j;\n        numNonEmpty+=slotUsageCount[j];\n      }\n    }\n  }\n  weightedAvg/=numNonEmpty;\n  report.append(\"\\n  Slot statistics: min=\" + minCollisions() + \", max=\"+ max+ \", weightedAvg:\"+ weightedAvg);\n  return report.toString();\n}\n", "docstring": "generate and return the collision report .", "partition": "test"}
{"idx": "5164", "code": "public void addSubscriptionToStore(final String topic,final String clientId){\n  final ClientTopicCouple subscription=new ClientTopicCouple(clientId,topic);\n  if (!topics.contains(subscription)) {\n    logger.debug(\"Added subscription \" + topic + \" (\"+ clientId+ \") to store\");\n    subscriptionsStore.add(subscription);\n    topics.add(topic);\n  }\n}\n", "docstring": "adds the given topic to the subscription store - used for topic to subscription matching .", "partition": "test"}
{"idx": "5165", "code": "public boolean zip(String zipLocation,String toBeZippedName){\n  boolean ret=false;\n  if (verbose)   Debug.put(\"zip\");\n  File toBeZipped=new File(toBeZippedName);\n  if (toBeZipped.exists()) {\n    try {\n      FileUtils.saveZipFile(zipLocation,toBeZipped);\n      ret=true;\n    }\n catch (    FileNotFoundException e) {\n      e.printStackTrace();\n    }\ncatch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n  return ret;\n}\n", "docstring": "store the contents of the tobezippedname directory into a zip file with the provided name . if the zip file name doesn \"'\" t end in . zip , it will .", "partition": "test"}
{"idx": "5166", "code": "private HashMap<Integer,Boolean> generateExpandedStateMap(){\n  HashMap<Integer,Boolean> parentListItemHashMap=new HashMap<>();\n  int childCount=0;\n  Object listItem;\n  ParentWrapper parentWrapper;\n  int listItemCount=mItemList.size();\n  for (int i=0; i < listItemCount; i++) {\n    if (mItemList.get(i) != null) {\n      listItem=getListItem(i);\n      if (listItem instanceof ParentWrapper) {\n        parentWrapper=(ParentWrapper)listItem;\n        parentListItemHashMap.put(i - childCount,parentWrapper.isExpanded());\n      }\n else {\n        childCount++;\n      }\n    }\n  }\n  return parentListItemHashMap;\n}\n", "docstring": "generates a hashmap used to store expanded state for items in the list on configuration change or whenever onresume is called .", "partition": "test"}
{"idx": "5167", "code": "public void addAudioPacketListener(Listener<AudioPacket> listener){\n  mAudioPacketBroadcaster.addListener(listener);\n}\n", "docstring": "adds the listener to receive audio packets from all modules .", "partition": "test"}
{"idx": "5168", "code": "public DeltaCRLIndicatorExtension(Boolean critical,Object value) throws IOException {\n  super(PKIXExtensions.DeltaCRLIndicator_Id,critical.booleanValue(),value,NAME,LABEL);\n}\n", "docstring": "creates the extension from the passed der encoded value of the same .", "partition": "test"}
{"idx": "5169", "code": "public JavaEnvironment(File javaPath){\n  Objects.requireNonNull(javaPath);\n  this.javaPath=javaPath;\n}\n", "docstring": "creates a javaenvironment with the given \"'\" java \"'\" path .", "partition": "test"}
{"idx": "5170", "code": "void addCallback(JSObject source,String method,JSFunction callback,boolean async){\n  String key=source.toJSPointer() + \".\" + method;\n  callbacks.put(key,callback);\n  String id=JSObject.ID_KEY;\n  String self=source.toJSPointer();\n  String js=self + \".\" + method+ \"=function(){\"+ \"var len=arguments.length;var url=\'/!cn1command/\"+ self+ \".\"+ method+ \"?\'; \"+ \"for (var i=0; i<len; i++){\"+ \"var val = arguments[i]; var strval=val;\"+ \"if ( (typeof(val) == \'object\') || (typeof(val) == \'function\')){ \"+ \"var id = val.\"+ id+ \"; \"+ \"if (typeof(id)==\'undefined\' || typeof(\"+ jsLookupTable+ \"[id]) == \'undefined\' || \"+ jsLookupTable+ \"[id].\"+ id+ \"!=id){\"+ jsLookupTable+ \".push(val); id=\"+ jsLookupTable+ \".indexOf(val); Object.defineProperty(val,\\\"\"+ id+ \"\\\",{value:id, enumerable:false});\"+ \"}\"+ \"strval=\'\"+ jsLookupTable+ \"[\'+id+\']\'\"+ \"}\"+ \"url += encodeURIComponent(typeof(val))+\'=\'+encodeURIComponent(strval);\"+ \"if (i < len-1){ url += \'&\';}\"+ \"} window.location.href=url;\"+ \"}\";\n  exec(js,async);\n}\n", "docstring": "adds a jsfunction to handle calls to the specified javascript object . this essentially installed a javascript proxy method that sends a message via a navigation callback to the javascriptcontext so that it can cause java code to be executed .", "partition": "test"}
{"idx": "5171", "code": "public void removeAllBlocksFromSection(){\n  for (int i=mBlockEntries.size(); i > 0; i--) {\n    Block b=mBlockEntries.get(i - 1);\n    if (b != null) {\n      b.removePropertyChangeListener(mBlockListeners.get(i - 1));\n    }\n    mBlockListeners.remove(i - 1);\n    mBlockEntries.remove(i - 1);\n  }\n  for (int i=mForwardEntryPoints.size(); i > 0; i--) {\n    mForwardEntryPoints.remove(i - 1);\n  }\n  for (int i=mReverseEntryPoints.size(); i > 0; i--) {\n    mReverseEntryPoints.remove(i - 1);\n  }\n  initializationNeeded=false;\n}\n", "docstring": "remove all blocks , block listeners , and entry points", "partition": "test"}
{"idx": "5172", "code": "public static void writeStringToFile(Path file,String text) throws IOException {\n  byte[] buf=text.getBytes(StandardCharsets.UTF_8);\n  Files.write(file,buf);\n}\n", "docstring": "java nio replacement of commons - io", "partition": "test"}
{"idx": "5173", "code": "private static boolean isOperatorVariableAccess(final INaviOperandTreeNode node){\n  final List<INaviOperandTreeNode> children=node.getChildren();\n  if (children.size() == 2) {\n    final INaviOperandTreeNode child0=children.get(0);\n    final INaviOperandTreeNode child1=children.get(1);\n    return isVariable(child0) ^ isVariable(child1);\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "determines whether a given node is a variable access node that can be simplified .", "partition": "test"}
{"idx": "5174", "code": "@Override public void onValueSelected(int pickerIndex,int newValue,boolean autoAdvance){\n  if (pickerIndex == HOUR_INDEX) {\n    setHour(newValue,false);\n    String announcement=String.format(\"%d\",newValue);\n    if (mAllowAutoAdvance && autoAdvance) {\n      setCurrentItemShowing(MINUTE_INDEX,true,true,false);\n      announcement+=\". \" + mSelectMinutes;\n    }\n else {\n      mTimePicker.setContentDescription(mHourPickerDescription + \": \" + newValue);\n    }\n    Utils.tryAccessibilityAnnounce(mTimePicker,announcement);\n  }\n else   if (pickerIndex == MINUTE_INDEX) {\n    setMinute(newValue);\n    mTimePicker.setContentDescription(mMinutePickerDescription + \": \" + newValue);\n  }\n else   if (pickerIndex == HALF_DAY_INDEX) {\n    updateHalfDay(newValue);\n  }\n else   if (pickerIndex == ENABLE_PICKER_INDEX) {\n    if (!isTypedTimeFullyLegal()) {\n      mTypedTimes.clear();\n    }\n    finishKbMode(true);\n  }\n}\n", "docstring": "called by the picker for updating the header display .", "partition": "test"}
{"idx": "5175", "code": "public static final List<Geo> segmentNearPoly(Geo s1,Geo s2,GeoArray r,double near){\n  int rlen=r.getSize();\n  Geo pl0=r.get(rlen - 1,new Geo());\n  Geo pl1=new Geo();\n  List<Geo> list=null;\n  Geo check=new Geo();\n  for (int j=0; j < rlen; j++) {\n    r.get(j,pl1);\n    Geo ret=segmentsIntersectOrNear(s1,s2,pl0,pl1,near,check);\n    if (ret != null) {\n      if (list == null) {\n        list=new LinkedList<Geo>();\n      }\n      list.add(ret);\n      check=new Geo();\n    }\n    pl0.initialize(pl1);\n  }\n  return list;\n}\n", "docstring": "where is a segment , represented by endpoints \"'\" s1 \"'\" and \"'\" s2 \"'\" , withing a range \"'\" near \"'\" of region \"'\" r \"'\" ?", "partition": "test"}
{"idx": "5176", "code": "public void addAction(UpdateAction action){\n  actionList.add(action);\n  for (  UpdateManagerListener listener : listeners) {\n    listener.actionAdded(action);\n  }\n}\n", "docstring": "add an action to the list .", "partition": "test"}
{"idx": "5177", "code": "public void load(DataInput rafIn) throws IOException, MaryConfigurationException {\n  int numIdx=rafIn.readInt();\n  idxInterval=rafIn.readInt();\n  if (idxInterval <= 0) {\n    throw new MaryConfigurationException(\"read negative index interval -- file seems corrupt\");\n  }\n  bytePtrs=new long[numIdx];\n  timePtrs=new long[numIdx];\n  int numBytesToRead=16 * numIdx + 16;\n  byte[] data=new byte[numBytesToRead];\n  rafIn.readFully(data);\n  DataInput bufIn=new DataInputStream(new ByteArrayInputStream(data));\n  for (int i=0; i < numIdx; i++) {\n    bytePtrs[i]=bufIn.readLong();\n    timePtrs[i]=bufIn.readLong();\n    if (i > 0) {\n      if (bytePtrs[i] < bytePtrs[i - 1] || timePtrs[i] < timePtrs[i - 1]) {\n        throw new MaryConfigurationException(\"File seems corrupt: Pointer positions in index fields are not strictly monotonously rising\");\n      }\n    }\n  }\n  bufIn.readLong();\n  bufIn.readLong();\n}\n", "docstring": "method which loads an index from a data input ( random access file or data input stream ) .", "partition": "test"}
{"idx": "5178", "code": "public void signoff(String uniqueID){\n  Debug.message(\"crfp\",\"CRFPServer: Client\" + uniqueID + \" signing off!\");\n  caches.remove(uniqueID);\n  viewAttributeLists.remove(uniqueID);\n  timestamps.remove(uniqueID);\n}\n", "docstring": "the signoff function lets the server know that a client is checking out .", "partition": "test"}
{"idx": "5179", "code": "private String createNonCGSrdfPairStepsOnEmptyGroup(List<VolumeDescriptor> sourceDescriptors,List<VolumeDescriptor> targetDescriptors,RemoteDirectorGroup group,Map<URI,Volume> uriVolumeMap,String waitFor,Workflow workflow){\n  StorageSystem system=dbClient.queryObject(StorageSystem.class,group.getSourceStorageSystemUri());\n  URI vpoolChangeUri=getVirtualPoolChangeVolume(sourceDescriptors);\n  log.info(\"VPoolChange URI {}\",vpoolChangeUri);\n  List<URI> sourceURIs=VolumeDescriptor.getVolumeURIs(sourceDescriptors);\n  List<URI> targetURIs=new ArrayList<>();\n  for (  URI sourceURI : sourceURIs) {\n    Volume source=uriVolumeMap.get(sourceURI);\n    StringSet srdfTargets=source.getSrdfTargets();\n    for (    String targetStr : srdfTargets) {\n      URI targetURI=URI.create(targetStr);\n      targetURIs.add(targetURI);\n    }\n  }\n  Method createListMethod=createListReplicasMethod(system.getId(),sourceURIs,targetURIs,vpoolChangeUri,true);\n  Method rollbackMethod=rollbackSRDFLinksMethod(system.getId(),sourceURIs,targetURIs,false);\n  String stepId=workflow.createStep(CREATE_SRDF_ACTIVE_VOLUME_PAIR_STEP_GROUP,CREATE_SRDF_ACTIVE_VOLUME_PAIR_STEP_DESC,waitFor,system.getId(),system.getSystemType(),getClass(),createListMethod,rollbackMethod,null);\n  return stepId;\n}\n", "docstring": "this method creates steps to create srdf pairs in an empty srdf group .", "partition": "test"}
{"idx": "5180", "code": "public static Long downsamplerTimestamp(Long millitimestamp,long windowSize){\n  return millitimestamp - (millitimestamp % windowSize);\n}\n", "docstring": "creating timestamp for downsampling in order to be consistent with tsdb downsampling func on hour / minute level", "partition": "test"}
{"idx": "5181", "code": "@Override public String toString(){\n  if (points == null || points.length() == 0) {\n    return idx + \"\";\n  }\n  StringBuffer bf=new StringBuffer();\n  try {\n    bf.append(idx + \" p: \");\n    ListNode temp;\n    for (int i=0; i < points.size(); i++) {\n      temp=points.get(i);\n      if (i == 0) {\n        bf.append(\"\" + temp.idx);\n      }\n else {\n        bf.append(\", \" + temp.idx);\n      }\n    }\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n  return bf.toString();\n}\n", "docstring": "returns a string represention of the node .", "partition": "test"}
{"idx": "5182", "code": "public IStatus run(IProgressMonitor monitor) throws InvocationTargetException {\n  ZipFile zipFile=null;\n  FileOutputStream fos=null;\n  BufferedOutputStream dest=null;\n  BufferedInputStream is=null;\n  jobStatus=Status.OK_STATUS;\n  try {\n    zipFile=new ZipFile(archive);\n    monitor.beginTask(\"Uncompressing \" + archive.getName(),zipFile.size());\n    Enumeration<? extends ZipEntry> entries=zipFile.entries();\n    while (entries.hasMoreElements()) {\n      ZipEntry zipEntry=entries.nextElement();\n      String currentEntry=zipEntry.getName();\n      File destFile=new File(targetDir,currentEntry);\n      File destinationParent=destFile.getParentFile();\n      if (!zipEntry.isDirectory()) {\n        destinationParent.mkdirs();\n        is=new BufferedInputStream(zipFile.getInputStream(zipEntry));\n        int numBytesRead;\n        byte bytes[]=new byte[BUFSIZE];\n        fos=new FileOutputStream(destFile);\n        dest=new BufferedOutputStream(fos,BUFSIZE);\n        while ((numBytesRead=is.read(bytes,0,BUFSIZE)) != -1) {\n          dest.write(bytes,0,numBytesRead);\n        }\n        dest.flush();\n      }\n else {\n        destFile.mkdirs();\n      }\n      monitor.worked(1);\n      if (monitor.isCanceled()) {\n        jobStatus=Status.CANCEL_STATUS;\n        break;\n      }\n    }\n    if (!monitor.isCanceled()) {\n      jobStatus=Status.OK_STATUS;\n    }\n  }\n catch (  ZipException ze) {\n    String errormsg=errorMessage(\"It may be corrupted?\");\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,errormsg);\n    CorePluginLog.logError(ze,errormsg);\n  }\ncatch (  IOException ioe) {\n    String errormsg=errorMessage();\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,errormsg);\n    CorePluginLog.logError(ioe,errormsg);\n  }\n finally {\n    try {\n      if (zipFile != null) {\n        zipFile.close();\n      }\n      if (is != null) {\n        is.close();\n      }\n      if (dest != null) {\n        dest.close();\n      }\n    }\n catch (    IOException ioe) {\n      String errormsg=errorMessage();\n      jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,errormsg);\n      CorePluginLog.logError(ioe,errormsg);\n    }\n  }\n  return jobStatus;\n}\n", "docstring": "executes the unziprunnable using the provided monitor to update the user and provide cancel capabilities .", "partition": "test"}
{"idx": "5183", "code": "public int read(String table,String key,Set<String> fields,HashMap<String,ByteIterator> result){\n  long st=System.nanoTime();\n  int res=_db.read(table,key,fields,result);\n  long en=System.nanoTime();\n  _measurements.measure(\"READ\",(int)((en - st) / 1000));\n  _measurements.reportReturnCode(\"READ\",res);\n  return res;\n}\n", "docstring": "read a record from the database . each field / value pair from the result will be stored in a hashmap .", "partition": "test"}
{"idx": "5184", "code": "protected void errorMessage(String msg) throws IOException {\n  String str=msg + \", read \" + m_Tokenizer.toString();\n  if (m_Lines > 0) {\n    int line=Integer.parseInt(str.replaceAll(\".* line \",\"\"));\n    str=str.replaceAll(\" line .*\",\" line \" + (m_Lines + line - 1));\n  }\n  throw new IOException(str);\n}\n", "docstring": "throws error message with line number and last token read .", "partition": "test"}
{"idx": "5185", "code": "public static void spooky4(final BitVector bv,final long prefixLength,final long seed,final long[] state,final long[] tuple){\n  long h0, h1, h2, h3;\n  h0=seed;\n  h1=seed;\n  h2=ARBITRARY_BITS;\n  h3=ARBITRARY_BITS;\n  long pos;\n  if (prefixLength >= 2 * Long.SIZE) {\n    final int p=4 * (int)((prefixLength - 2 * Long.SIZE) / (4 * Long.SIZE));\n    h0=state[p + 0];\n    h1=state[p + 1];\n    h2=state[p + 2];\n    h3=state[p + 3];\n    pos=p * Long.SIZE + 2 * Long.SIZE;\n  }\n else   pos=0;\n  long remaining=prefixLength - pos;\n  if (remaining >= Long.SIZE * 2) {\n    h0+=bv.getLong(pos + 0 * Long.SIZE,pos + 1 * Long.SIZE);\n    h1+=bv.getLong(pos + 1 * Long.SIZE,pos + 2 * Long.SIZE);\n    remaining-=2 * Long.SIZE;\n    pos+=2 * Long.SIZE;\n  }\n  if (remaining > Long.SIZE) {\n    h2+=bv.getLong(pos + 0 * Long.SIZE,pos + 1 * Long.SIZE);\n    h3+=bv.getLong(pos + 1 * Long.SIZE,prefixLength);\n  }\n else   if (remaining > 0) {\n    h2+=bv.getLong(pos,prefixLength);\n  }\n else {\n    h2+=ARBITRARY_BITS;\n    h3+=ARBITRARY_BITS;\n  }\n  h0+=prefixLength;\n  h3^=h2;\n  h2=Long.rotateLeft(h2,15);\n  h3+=h2;\n  h0^=h3;\n  h3=Long.rotateLeft(h3,52);\n  h0+=h3;\n  h1^=h0;\n  h0=Long.rotateLeft(h0,26);\n  h1+=h0;\n  h2^=h1;\n  h1=Long.rotateLeft(h1,51);\n  h2+=h1;\n  h3^=h2;\n  h2=Long.rotateLeft(h2,28);\n  h3+=h2;\n  h0^=h3;\n  h3=Long.rotateLeft(h3,9);\n  h0+=h3;\n  h1^=h0;\n  h0=Long.rotateLeft(h0,47);\n  h1+=h0;\n  h2^=h1;\n  h1=Long.rotateLeft(h1,54);\n  h2+=h1;\n  h3^=h2;\n  h2=Long.rotateLeft(h2,32);\n  h3+=h2;\n  h0^=h3;\n  h3=Long.rotateLeft(h3,25);\n  h0+=h3;\n  h1^=h0;\n  h0=Long.rotateLeft(h0,63);\n  h1+=h0;\nswitch (tuple.length) {\ncase 4:\n    tuple[3]=h3;\ncase 3:\n  tuple[2]=h2;\ncase 2:\ntuple[1]=h1;\ncase 1:\ntuple[0]=h0;\n}\n}\n", "docstring": "constant - time spookyhash 4 - word - state hashing reusing precomputed state partially .", "partition": "test"}
{"idx": "5186", "code": "public boolean hasNext(){\n  if (deal > 32000) {\n    sc.close();\n  }\n  return (deal <= 32000);\n}\n", "docstring": "if the deal has more deals , this returns true ; false otherwise .", "partition": "test"}
{"idx": "5187", "code": "private void filterNodeMap(ConcurrentMap<String,Collection<ClusterNode>> map,final ClusterNode exclNode){\n  for (  String cacheName : registeredCaches.keySet()) {\n    String maskedName=maskNull(cacheName);\n    while (true) {\n      Collection<ClusterNode> oldNodes=map.get(maskedName);\n      if (oldNodes == null || oldNodes.isEmpty())       break;\n      Collection<ClusterNode> newNodes=new ArrayList<>(oldNodes);\n      if (!newNodes.remove(exclNode))       break;\n      if (map.replace(maskedName,oldNodes,newNodes))       break;\n    }\n  }\n}\n", "docstring": "creates a copy of nodes map without the given node .", "partition": "test"}
{"idx": "5188", "code": "private static void adjustAbs(double[] array,int lower,int upper){\n  int j, k;\n  double temp;\n  j=lower;\n  k=lower * 2;\n  while (k <= upper) {\n    if ((k < upper) && (Math.abs(array[k - 1]) < Math.abs(array[k]))) {\n      k+=1;\n    }\n    if (Math.abs(array[j - 1]) < Math.abs(array[k - 1])) {\n      temp=array[j - 1];\n      array[j - 1]=array[k - 1];\n      array[k - 1]=temp;\n    }\n    j=k;\n    k*=2;\n  }\n}\n", "docstring": "helps sort an array of doubles . assumes that array [ lower + 1 ", "partition": "test"}
{"idx": "5189", "code": "public synchronized IAudioProcessor remove(int index){\n  IAudioProcessor processor=processors.remove(index);\n  buildFinalProcessor();\n  return processor;\n}\n", "docstring": "removes the processor from the internal processor queue at the provided index .", "partition": "test"}
{"idx": "5190", "code": "LinkedList<TrieNode<T>> makeSuffixChain(TrieNode<T> root,String suffix,T value){\n  LinkedList<TrieNode<T>> result=new LinkedList<>();\n  String rootPrefix=root.getPrefix();\n  for (int i=1, suffixSize=suffix.length(); i <= suffixSize; i++) {\n    String newPrefix=rootPrefix + suffix.substring(0,i);\n    TrieNode<T> newNode=TrieNode.makeNode(newPrefix);\n    result.add(newNode);\n    root.addChild(newNode);\n    root=newNode;\n  }\n  root.setValue(value);\n  return result;\n}\n", "docstring": "inserts a chain of children into the given node .", "partition": "test"}
{"idx": "5191", "code": "private static By byFromLocator(String locator){\n  if (locator.startsWith(\"//\")) {\n    return By.xpath(locator);\n  }\n  if (locator.startsWith(\"id=\")) {\n    return By.id(locator.replaceFirst(\"id=\",\"\"));\n  }\n  if (locator.startsWith(\"css=\")) {\n    return By.cssSelector(locator.replaceFirst(\"css=\",\"\"));\n  }\n  if (locator.startsWith(\"xpath=\")) {\n    return By.xpath(locator.replaceFirst(\"xpath=\",\"\"));\n  }\n  if (locator.startsWith(\"name=\")) {\n    return By.name(locator.replaceFirst(\"name=\",\"\"));\n  }\n  if (locator.startsWith(\"link=\")) {\n    return By.linkText(locator.replaceFirst(\"link=\",\"\"));\n  }\n  if (locator.startsWith(\"linkpartial=\")) {\n    return By.partialLinkText(locator.replaceFirst(\"linkpartial=\",\"\"));\n  }\n  throw new IllegalArgumentException(\"Locator not supported: \" + locator);\n}\n", "docstring": "converts a locator string with a known prefix to a by object", "partition": "test"}
{"idx": "5192", "code": "private static void taskStarted(ProgressThread task){\n  for (  ProgressThreadStateListener l : listener.getListeners(ProgressThreadStateListener.class)) {\n    l.progressThreadStarted(task);\n  }\n}\n", "docstring": "notify listeners that a task was started .", "partition": "test"}
{"idx": "5193", "code": "public static final void isCommentWF(DOMErrorHandler errorHandler,DOMErrorImpl error,DOMLocatorImpl locator,String datavalue,boolean isXML11Version){\n  if (datavalue == null || (datavalue.length() == 0)) {\n    return;\n  }\n  char[] dataarray=datavalue.toCharArray();\n  int datalength=dataarray.length;\n  if (isXML11Version) {\n    int i=0;\n    while (i < datalength) {\n      char c=dataarray[i++];\n      if (XML11Char.isXML11Invalid(c)) {\n        if (XMLChar.isHighSurrogate(c) && i < datalength) {\n          char c2=dataarray[i++];\n          if (XMLChar.isLowSurrogate(c2) && XMLChar.isSupplemental(XMLChar.supplemental(c,c2))) {\n            continue;\n          }\n        }\n        String msg=DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,\"InvalidCharInComment\",new Object[]{Integer.toString(dataarray[i - 1],16)});\n        reportDOMError(errorHandler,error,locator,msg,DOMError.SEVERITY_ERROR,\"wf-invalid-character\");\n      }\n else       if (c == \'-\' && i < datalength && dataarray[i] == \'-\') {\n        String msg=DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,\"DashDashInComment\",null);\n        reportDOMError(errorHandler,error,locator,msg,DOMError.SEVERITY_ERROR,\"wf-invalid-character\");\n      }\n    }\n  }\n else {\n    int i=0;\n    while (i < datalength) {\n      char c=dataarray[i++];\n      if (XMLChar.isInvalid(c)) {\n        if (XMLChar.isHighSurrogate(c) && i < datalength) {\n          char c2=dataarray[i++];\n          if (XMLChar.isLowSurrogate(c2) && XMLChar.isSupplemental(XMLChar.supplemental(c,c2))) {\n            continue;\n          }\n        }\n        String msg=DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,\"InvalidCharInComment\",new Object[]{Integer.toString(dataarray[i - 1],16)});\n        reportDOMError(errorHandler,error,locator,msg,DOMError.SEVERITY_ERROR,\"wf-invalid-character\");\n      }\n else       if (c == \'-\' && i < datalength && dataarray[i] == \'-\') {\n        String msg=DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,\"DashDashInComment\",null);\n        reportDOMError(errorHandler,error,locator,msg,DOMError.SEVERITY_ERROR,\"wf-invalid-character\");\n      }\n    }\n  }\n}\n", "docstring": "non - dom : check if value of the comment is well - formed", "partition": "test"}
{"idx": "5194", "code": "private void throwExceptionIfDestroyed(String method) throws DeepstreamRecordDestroyedException {\n  if (this.isDestroyed) {\n    throw new DeepstreamRecordDestroyedException(method);\n  }\n}\n", "docstring": "throw an exception if the record has been destroyed", "partition": "test"}
{"idx": "5195", "code": "public void upload(final InputStream in,String artifact,String version,String fileName,Properties props) throws IOException {\n  props.put(FILE_NAME_PROPERTY,fileName);\n  props.put(VERSION_PROPERTY,version);\n  props.put(ARTIFACT_PROPERTY,artifact);\n  storeProperties(artifact,version,props);\n  try (OutputStream out=newOutputStream(getArtifact(artifact,version,fileName))){\n    IOUtils.copyLarge(in,out);\n  }\n  finally {\n    in.close();\n  }\n}\n", "docstring": "uploads artifact into the repository .", "partition": "test"}
{"idx": "5196", "code": "public void load() throws IOException {\n  if (magicNumber == 0) {\n    try (InputReaderLittleEndian ins=new InputReaderLittleEndian(new FileInputStreamAdapter(fileName))){\n      magicNumber=ins.readLong();\n      if (magicNumber != MAGIC_NUMBER)       throw new IOException(\"Input file is not a DAA file.\");\n      version=ins.readLong();\n      if (version > DAA_VERSION)       throw new IOException(\"DAA version requires later version of MEGAN.\");\n      diamondBuild=ins.readLong();\n      dbSeqs=ins.readLong();\n      dbSeqsUsed=ins.readLong();\n      dbLetters=ins.readLong();\n      flags=ins.readLong();\n      queryRecords=ins.readLong();\n      modeRank=ins.readInt();\n      gapOpen=ins.readInt();\n      gapExtend=ins.readInt();\n      reward=ins.readInt();\n      penalty=ins.readInt();\n      reserved1=ins.readInt();\n      reserved2=ins.readInt();\n      reserved3=ins.readInt();\n      k=ins.readDouble();\n      lambda=ins.readDouble();\n      reserved4=ins.readDouble();\n      reserved5=ins.readDouble();\n      for (int i=0; i < scoreMatrix.length; i++) {\n        scoreMatrix[i]=(byte)ins.read();\n      }\n      scoreMatrixName=Basic.toString(scoreMatrix);\n      for (int i=0; i < blockSize.length; i++)       blockSize[i]=ins.readLong();\n      if (blockSize[0] == 0)       throw new IOException(\"Invalid DAA file. DIAMOND run probably has not completed successfully.\");\n      for (int i=0; i < blockTypeRank.length; i++) {\n        blockTypeRank[i]=(byte)ins.read();\nswitch (BlockType.value(blockTypeRank[i])) {\ncase ref_names:\n          if (refNamesBlockIndex != -1)           throw new IOException(\"DAA file contains multiple ref_names blocks, not implemented.\");\n        refNamesBlockIndex=i;\n      break;\ncase ref_lengths:\n    if (refLengthsBlockIndex != -1)     throw new IOException(\"DAA file contains multiple ref_lengths blocks, not implemented.\");\n  refLengthsBlockIndex=i;\nbreak;\ncase alignments:\nif (alignmentsBlockIndex != -1) throw new IOException(\"DAA file contains multiple alignments blocks, not implemented.\");\nalignmentsBlockIndex=i;\nbreak;\n}\n}\nif (refNamesBlockIndex == -1) throw new IOException(\"DAA file contains 0 ref_names blocks, not implemented.\");\nif (refLengthsBlockIndex == -1) throw new IOException(\"DAA file contains 0 ref_lengths blocks, not implemented.\");\nif (alignmentsBlockIndex == -1) throw new IOException(\"DAA file contains 0 alignments blocks, not implemented.\");\nif (refLengthsBlockIndex < refNamesBlockIndex) throw new IOException(\"DAA file contains ref_lengths block before ref_names block, not implemented.\");\nheaderSize=ins.getPosition();\nlnK=Math.log(k);\n}\n }\n}\n", "docstring": "read the header of a daa file and all reference names", "partition": "test"}
{"idx": "5197", "code": "private final void countAll() throws IOException {\n  MultiDocValues.OrdinalMap ordinalMap;\n  if (dv instanceof MultiDocValues.MultiSortedSetDocValues) {\n    ordinalMap=((MultiSortedSetDocValues)dv).mapping;\n  }\n else {\n    ordinalMap=null;\n  }\n  IndexReader origReader=state.getOrigReader();\n  for (  LeafReaderContext context : origReader.leaves()) {\n    LeafReader reader=context.reader();\n    SortedSetDocValues segValues=reader.getSortedSetDocValues(field);\n    if (segValues == null) {\n      continue;\n    }\n    Bits liveDocs=reader.getLiveDocs();\n    if (ordinalMap != null) {\n      final LongValues ordMap=ordinalMap.getGlobalOrds(context.ord);\n      int numSegOrds=(int)segValues.getValueCount();\n      final int[] segCounts=new int[numSegOrds];\n      int docID;\n      while ((docID=segValues.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (liveDocs == null || liveDocs.get(docID)) {\n          int term=(int)segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            segCounts[term]++;\n            term=(int)segValues.nextOrd();\n          }\n        }\n      }\n      for (int ord=0; ord < numSegOrds; ord++) {\n        int count=segCounts[ord];\n        if (count != 0) {\n          counts[(int)ordMap.get(ord)]+=count;\n        }\n      }\n    }\n else {\n      int docID;\n      while ((docID=segValues.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (liveDocs == null || liveDocs.get(docID)) {\n          int term=(int)segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts[term]++;\n            term=(int)segValues.nextOrd();\n          }\n        }\n      }\n    }\n  }\n}\n", "docstring": "does all the \" real work \" of tallying up the counts .", "partition": "test"}
{"idx": "5198", "code": "public void addToParent(Element headerE) throws Exception {\n  Document doc=headerE.getOwnerDocument();\n  Element securityE=doc.createElementNS(wsseNS,WSSEConstants.TAG_WSSE + \":\" + WSSEConstants.TAG_SECURITYT);\n  securityE.setAttributeNS(SOAPBindingConstants.NS_XML,WSSEConstants.TAG_XML_WSSE,wsseNS);\n  headerE.appendChild(securityE);\n  Document binaryTokenD=XMLUtils.toDOMDocument(toString(),debug);\n  Element binaryTokenE=binaryTokenD.getDocumentElement();\n  securityE.appendChild(doc.importNode(binaryTokenE,true));\n}\n", "docstring": "adds th binary security token to the header element .", "partition": "test"}
{"idx": "5199", "code": "public void update(){\n  if (amplitude > 0) {\n    long elapsed=System.currentTimeMillis() - timestamp;\n    double delta=amplitude * Math.exp(-elapsed / timeConstant);\n    if (Math.abs(delta) > 0.5) {\n      viewpointNode.drag(lastDx * delta,lastDy * delta);\n    }\n else {\n      amplitude=0;\n      updateLookAt();\n    }\n  }\n}\n", "docstring": "update the kinetic scrolling", "partition": "test"}
{"idx": "5200", "code": "@Override public Assignment sample(){\n  if (!samples.isEmpty()) {\n    int selection=sampler.nextInt(samples.size());\n    Assignment selected=samples.get(selection);\n    return selected;\n  }\n else {\n    log.warning(\"distribution has no samples\");\n    return new Assignment();\n  }\n}\n", "docstring": "samples from the distribution . in this case , simply selects one arbitrary sample out of the set defining the distribution", "partition": "test"}
{"idx": "5201", "code": "@SneakyThrows public static X509Certificate readCertificate(InputStream is){\n  return (X509Certificate)CERT_FACTORY.generateCertificate(is);\n}\n", "docstring": "reads x509certificate object from given input stream .", "partition": "test"}
{"idx": "5202", "code": "public GuacamoleHTTPTunnelMap(){\n  executor.scheduleAtFixedRate(new TunnelTimeoutTask(TUNNEL_TIMEOUT * 1000l),TUNNEL_TIMEOUT,TUNNEL_TIMEOUT,TimeUnit.SECONDS);\n}\n", "docstring": "creates a new guacamolehttptunnelmap which automatically closes and removes http tunnels which are no longer in use .", "partition": "test"}
{"idx": "5203", "code": "default B with(String key,Class<?> value){\n  return with(key,value != null ? value.getName() : null);\n}\n", "docstring": "associate the given class name value with the specified key .", "partition": "test"}
{"idx": "5204", "code": "private void rename(Table table){\n  if (renameDefinitions != null) {\n    for (    Column col : table.getAllColumns()) {\n      String newColName=renameDefinitions.getNewColumnName(table.getSchema(),table.getName(),col.getName());\n      if (newColName != null)       col.setName(newColName);\n    }\n    String newTableName=renameDefinitions.getNewTableName(table.getSchema(),table.getName());\n    String newSchemaName=renameDefinitions.getNewSchemaName(table.getSchema(),table.getName());\n    if (newTableName != null)     table.setTable(newTableName);\n    if (newSchemaName != null)     table.setSchema(newSchemaName);\n  }\n}\n", "docstring": "if renamedefinitions object is prepared , does the lookup and renaming of schema , table and columns . nothing is done if renamedefinitions is null .", "partition": "test"}
{"idx": "5205", "code": "public synchronized boolean put(long fp){\n  int index=(int)(fp & this.mask);\n  long[] list=this.table[index];\n  if (list != null) {\n    int listlen=list.length;\n    for (int i=0; i < listlen; i++) {\n      if (list[i] == fp)       return true;\n    }\n  }\n  if (count >= threshold) {\n    rehash();\n    index=(int)(fp & this.mask);\n    list=this.table[index];\n  }\n  int len=(list == null ? 0 : list.length);\n  long[] newList=new long[len + 1];\n  if (list != null)   System.arraycopy(list,0,newList,0,len);\n  newList[len]=fp;\n  this.table[index]=newList;\n  this.count++;\n  return false;\n}\n", "docstring": "tests if the specified fingerprint is in this set . as a side effect , updates the set to contain the fingerprint .", "partition": "test"}
{"idx": "5206", "code": "public void applyLayout(){\n  layout.setInitialLocation(getPosition());\n  layout.layoutNeurons(getNeuronList());\n}\n", "docstring": "apply this group \"'\" s layout to its neurons .", "partition": "test"}
{"idx": "5207", "code": "float layerSize(int p_76490_1_){\n  if ((float)p_76490_1_ < (float)this.heightLimit * 0.3F) {\n    return -1.0F;\n  }\n else {\n    float f=(float)this.heightLimit / 2.0F;\n    float f1=f - (float)p_76490_1_;\n    float f2=MathHelper.sqrt_float(f * f - f1 * f1);\n    if (f1 == 0.0F) {\n      f2=f;\n    }\n else     if (Math.abs(f1) >= f) {\n      return 0.0F;\n    }\n    return f2 * 0.5F;\n  }\n}\n", "docstring": "gets the rough size of a layer of the tree .", "partition": "test"}
{"idx": "5208", "code": "public static Method findStaticMethod(Class<?> type,String name,Class<?>... args) throws NoSuchMethodException {\n  Method method=findMethod(type,name,args);\n  if (!Modifier.isStatic(method.getModifiers())) {\n    throw new NoSuchMethodException(\"Method \'\" + name + \"\' is not static\");\n  }\n  return method;\n}\n", "docstring": "finds public static method that is accessible from public class .", "partition": "test"}
{"idx": "5209", "code": "private void fetchSearchServiceCardsFromServer(String keyword,String categoryId){\n  final Map<String,String> params=new HashMap<String,String>(5);\n  params.put(HttpConstants.LATITUDE,SharedPreferenceHelper.getString(R.string.pref_latitude));\n  params.put(HttpConstants.LONGITUDE,SharedPreferenceHelper.getString(R.string.pref_longitude));\n  params.put(HttpConstants.TYPE,HttpConstants.SearchType.SERVICE_CARD);\n  params.put(HttpConstants.GROUP_ID,categoryId);\n  params.put(HttpConstants.PER,\"20\");\n  params.put(HttpConstants.RADIUS,\"50\");\n  params.put(HttpConstants.TITLE,keyword);\n  RetroCallback retroCallback;\n  retroCallback=new RetroCallback(this);\n  retroCallback.setRequestId(HttpConstants.ApiResponseCodes.SEARCH_SERVICES);\n  retroCallbackList.add(retroCallback);\n  params.put(HttpConstants.PAGE,\"1\");\n  mYeloApi.getServiceCards(params,retroCallback);\n  mSwipeRefreshLayout.setRefreshing(true);\n}\n", "docstring": "helper http function to get list of my service cards based on keyword and category", "partition": "test"}
{"idx": "5210", "code": "public void addPhonenumber(String aPhonenumber){\n  if (mPhoneNumbers.indexOf(aPhonenumber) < 0) {\n    mPhoneNumbers.add(aPhonenumber);\n  }\n}\n", "docstring": "add a phone number address to the list .", "partition": "test"}
{"idx": "5211", "code": "public static final String digitsAndPlusOnly(Matcher matcher){\n  StringBuilder buffer=new StringBuilder();\n  String matchingRegion=matcher.group();\n  for (int i=0, size=matchingRegion.length(); i < size; i++) {\n    char character=matchingRegion.charAt(i);\n    if (character == '+' || Character.isDigit(character)) {\n      buffer.append(character);\n    }\n  }\n  return buffer.toString();\n}\n", "docstring": "convenience method to return only the digits and plus signs in the matching string .", "partition": "test"}
{"idx": "5212", "code": "boolean compareMethods(Method a,Method b){\n  if ((a == null) != (b == null)) {\n    return false;\n  }\n  if (a != null && b != null) {\n    if (!a.equals(b)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "package private helper method for descriptor . equals methods .", "partition": "test"}
{"idx": "5213", "code": "MarkerSegment findMarkerSegment(int tag){\n  Iterator iter=markerSequence.iterator();\n  while (iter.hasNext()) {\n    MarkerSegment seg=(MarkerSegment)iter.next();\n    if (seg.tag == tag) {\n      return seg;\n    }\n  }\n  return null;\n}\n", "docstring": "returns the first markersegment object in the list with the given tag , or null if none is found .", "partition": "test"}
{"idx": "5214", "code": "private static Reader openInput(String from){\n  try {\n    return CliUtils.reader(from);\n  }\n catch (  IOException e) {\n    log.error(\"Error finding input\",e);\n    System.exit(1);\n    return null;\n  }\n}\n", "docstring": "open the input using the \" from \" parameter , exiting on failure .", "partition": "test"}
{"idx": "5215", "code": "public PublisherConcatArray<T> concatAdditionalSourceFirst(Publisher<? extends T> source){\n  int n=array.length;\n  @SuppressWarnings(\"unchecked\") Publisher<? extends T>[] newArray=new Publisher[n + 1];\n  System.arraycopy(array,0,newArray,1,n);\n  newArray[0]=source;\n  return new PublisherConcatArray<>(delayError,newArray);\n}\n", "docstring": "returns a new instance which has the additional first source to be concatenated together with the current array of sources . < p > this operation doesn \"'\" t change the current publisherconcatarray instance .", "partition": "test"}
{"idx": "5216", "code": "protected void doPublish(String tenantId,List<T> items,String subscriber,int retryCount,long delay) throws Exception {\n  String data=mapper.writeValueAsString(items);\n  TextMessage tm=session.createTextMessage(data);\n  if (tenantId != null) {\n    tm.setStringProperty(\"tenant\",tenantId);\n  }\n  if (subscriber != null) {\n    tm.setStringProperty(\"subscriber\",subscriber);\n  }\n  tm.setIntProperty(\"retryCount\",retryCount);\n  if (delay > 0) {\n    tm.setLongProperty(\"_AMQ_SCHED_DELIVERY\",System.currentTimeMillis() + delay);\n  }\n  if (log.isLoggable(Level.FINEST)) {\n    log.finest(\"Publish: \" + tm);\n  }\n  producer.send(tm);\n}\n", "docstring": "this method publishes the supplied items .", "partition": "test"}
{"idx": "5217", "code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase MappingPackage.ATTRIBUTE__NAME:\n    return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);\ncase MappingPackage.ATTRIBUTE__VALUE:\n  return VALUE_EDEFAULT == null ? value != null : !VALUE_EDEFAULT.equals(value);\n}\nreturn super.eIsSet(featureID);\n}\n", "docstring": "< ! - - begin - user - doc - - > < ! - - end - user - doc - - >", "partition": "test"}
{"idx": "5218", "code": "protected void checkValid() throws URIException {\n  if (!(equals(_scheme,DEFAULT_SCHEME) || _scheme == null)) {\n    throw new URIException(URIException.PARSING,\"wrong class use\");\n  }\n}\n", "docstring": "verify the valid class use for construction .", "partition": "test"}
{"idx": "5219", "code": "public PrivateKeyUsageExtension(Boolean critical,Object value) throws CertificateException, IOException {\n  this.extensionId=PKIXExtensions.PrivateKeyUsage_Id;\n  this.critical=critical.booleanValue();\n  this.extensionValue=(byte[])value;\n  DerInputStream str=new DerInputStream(this.extensionValue);\n  DerValue[] seq=str.getSequence(2);\n  for (int i=0; i < seq.length; i++) {\n    DerValue opt=seq[i];\n    if (opt.isContextSpecific(TAG_BEFORE) && !opt.isConstructed()) {\n      if (notBefore != null) {\n        throw new CertificateParsingException(\"Duplicate notBefore in PrivateKeyUsage.\");\n      }\n      opt.resetTag(DerValue.tag_GeneralizedTime);\n      str=new DerInputStream(opt.toByteArray());\n      notBefore=str.getGeneralizedTime();\n    }\n else     if (opt.isContextSpecific(TAG_AFTER) && !opt.isConstructed()) {\n      if (notAfter != null) {\n        throw new CertificateParsingException(\"Duplicate notAfter in PrivateKeyUsage.\");\n      }\n      opt.resetTag(DerValue.tag_GeneralizedTime);\n      str=new DerInputStream(opt.toByteArray());\n      notAfter=str.getGeneralizedTime();\n    }\n else     throw new IOException(\"Invalid encoding of \" + \"PrivateKeyUsageExtension\");\n  }\n}\n", "docstring": "create the extension from the passed der encoded value .", "partition": "test"}
{"idx": "5220", "code": "@Override public List<Period> generatePeriods(DateTimeUnit dateTimeUnit){\n  Calendar cal=getCalendar();\n  dateTimeUnit.setMonth(1);\n  dateTimeUnit.setDay(1);\n  List<Period> periods=Lists.newArrayList();\n  int year=dateTimeUnit.getYear();\n  while (dateTimeUnit.getYear() == year) {\n    periods.add(createPeriod(dateTimeUnit,cal));\n    dateTimeUnit=cal.plusMonths(dateTimeUnit,2);\n  }\n  return periods;\n}\n", "docstring": "generates bimonthly periods for the whole year in which the start date of the given period exists .", "partition": "test"}
{"idx": "5221", "code": "public static SecretKey createAESKey(){\n  try {\n    final KeyGenerator kgen=KeyGenerator.getInstance(\"AES\");\n    final int keySize=256;\n    kgen.init(keySize);\n    return kgen.generateKey();\n  }\n catch (  final NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return null;\n}\n", "docstring": "generates a random aes key for encrypting / decrypting the turnover value attention : in a real cash box this key would be generated during the init process and stored in a secure area", "partition": "test"}
{"idx": "5222", "code": "@Override public void valueChange(ValueChangeEvent e){\n  String name=e.getPropertyName();\n  Object value=e.getNewValue();\n  log.config(name + \"=\" + value);\n  if (value == null)   return;\n}\n", "docstring": "vetoable change listener . - business partner - currency - date", "partition": "test"}
{"idx": "5223", "code": "public SpyVersions loadVersions() throws XMLException {\n  setLoading(true);\n  final String urlString=propertyLoader.getProperty(BasePropertyNames.VERSION_INFO_URL) + \"?current=\" + currentRelease;\n  try {\n    final URL url=new URL(urlString);\n    final String xml=IOUtils.toString(url.openStream());\n    versions=(SpyVersions)loadFromString(xml);\n  }\n catch (  IOException|NullPointerException e) {\n    throw new XMLException(\"Cannot read version info from \" + urlString,e);\n  }\n  setLoading(false);\n  return versions;\n}\n", "docstring": "loads version information from the url .", "partition": "test"}
{"idx": "5224", "code": "@RequestMapping(value=\"/page\",method=POST,produces=APPLICATION_JSON_VALUE) public ResponseEntity<PageResponse<UserDTO>> findAll(@RequestBody PageRequestByExample<UserDTO> prbe) throws URISyntaxException {\n  PageResponse<UserDTO> pageResponse=userDTOService.findAll(prbe);\n  return new ResponseEntity<>(pageResponse,new HttpHeaders(),HttpStatus.OK);\n}\n", "docstring": "find a page of user using query by example .", "partition": "test"}
{"idx": "5225", "code": "public void addFooterView(View view){\n  mFooterViews.add(view);\n  notifyDataSetChanged();\n}\n", "docstring": "add a static view to appear at the end of the recyclerview . footers are displayed in the order they were added .", "partition": "test"}
{"idx": "5226", "code": "public boolean isReadOnly(boolean useSessionStatus) throws SQLException {\n  if (useSessionStatus && !this.isClosed && versionMeetsMinimum(5,6,5)&& !getUseLocalSessionState()&& getReadOnlyPropagatesToServer()) {\n    java.sql.Statement stmt=null;\n    java.sql.ResultSet rs=null;\n    try {\n      try {\n        stmt=getMetadataSafeStatement();\n        rs=stmt.executeQuery(\"select @@session.tx_read_only\");\n        if (rs.next()) {\n          return rs.getInt(1) != 0;\n        }\n      }\n catch (      SQLException ex1) {\n        if (ex1.getErrorCode() != MysqlErrorNumbers.ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords()) {\n          throw SQLError.createSQLException(\"Could not retrieve transation read-only status server\",SQLError.SQL_STATE_GENERAL_ERROR,ex1,getExceptionInterceptor());\n        }\n      }\n    }\n  finally {\n      if (rs != null) {\n        try {\n          rs.close();\n        }\n catch (        Exception ex) {\n        }\n        rs=null;\n      }\n      if (stmt != null) {\n        try {\n          stmt.close();\n        }\n catch (        Exception ex) {\n        }\n        stmt=null;\n      }\n    }\n  }\n  return this.readOnly;\n}\n", "docstring": "tests to see if the connection is in read only mode . note that prior to 5 . 6 , we cannot really put the database in read only mode , but we pretend we can by returning the value of the readonly flag", "partition": "test"}
{"idx": "5227", "code": "public void testConsume(){\n  AtomicInteger sum=new AtomicInteger();\n  SubmissionPublisher<Integer> p=basicPublisher();\n  CompletableFuture<Void> f=p.consume(null);\n  int n=20;\n  for (int i=1; i <= n; ++i)   p.submit(i);\n  p.close();\n  f.join();\n  assertEquals((n * (n + 1)) / 2,sum.get());\n}\n", "docstring": "consume returns a completablefuture that is done when publisher completes", "partition": "test"}
{"idx": "5228", "code": "private static DownscaleQuality addConstant(String type){\n  init();\n  if (constList.containsKey(type)) {\n    throw new RuntimeException(\"Type strings for DownscaleQuality should be unique; \" + type + \" is declared twice\");\n  }\n  DownscaleQuality q=new DownscaleQuality(type);\n  constList.put(type,q);\n  return q;\n}\n", "docstring": "create and add constant instance", "partition": "test"}
{"idx": "5229", "code": "public void bail(String message,boolean printUsageStatement){\n  Debug.output(message);\n  if (printUsageStatement)   printUsage();\n  System.exit(0);\n}\n", "docstring": "called if something is messed up . prints a message , and the usage statement , if desired .", "partition": "test"}
{"idx": "5230", "code": "private void assertTimestampsEqualWithEpsilon(long expected,long actual,int epsilon,String desc){\n  assertTrue(\"Expected a \" + desc + \" time within \"+ epsilon+ \"ms of \"+ expected+ \" but got \"+ actual,Math.abs(actual - expected) < epsilon);\n}\n", "docstring": "kinda like the junit asserts for doubles , which allows an \" epsilon \" but this is for integers , and with a specific description in the assert just for timestamps . all times are expected in milliseconds", "partition": "test"}
{"idx": "5231", "code": "public SpiderSitemapXMLParser(SpiderParam params){\n  super();\n  if (params == null) {\n    throw new IllegalArgumentException(\"Parameter params must not be null.\");\n  }\n  this.params=params;\n}\n", "docstring": "instantiates a new sitemap . xml parser .", "partition": "test"}
{"idx": "5232", "code": "public boolean flush(boolean deaccelerated);\n", "docstring": "flush all cached resources . the deaccelerated parameter indicates if the flush is happening because the associated surface is no longer being accelerated ( for instance the acceleration priority is set below the threshold needed for acceleration ) . returns a boolean that indicates if the cached object is no longer needed and should be removed from the cache .", "partition": "test"}
{"idx": "5233", "code": "public void addHop(int id){\n  if (entities == null) {\n    return;\n  }\n  hopsNumber++;\n  entities.add(Integer.valueOf(id));\n}\n", "docstring": "add an entity where the infopacket traverses . this method should be called by network entities that count as hops , for instance routers or cloudresources . it should not be called by links etc .", "partition": "test"}
{"idx": "5234", "code": "protected boolean[] datasetIntegrity(boolean nominalPredictor,boolean numericPredictor,boolean stringPredictor,boolean datePredictor,boolean relationalPredictor,boolean multiInstance,int classType,boolean predictorMissing,boolean classMissing){\n  print(\"associator doesn\'t alter original datasets\");\n  printAttributeSummary(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType);\n  print(\"...\");\n  int numTrain=getNumInstances(), numClasses=2, missingLevel=20;\n  boolean[] result=new boolean[2];\n  Instances train=null;\n  Associator associator=null;\n  try {\n    train=makeTestDataset(42,numTrain,nominalPredictor ? getNumNominal() : 0,numericPredictor ? getNumNumeric() : 0,stringPredictor ? getNumString() : 0,datePredictor ? getNumDate() : 0,relationalPredictor ? getNumRelational() : 0,numClasses,classType,multiInstance);\n    if (missingLevel > 0) {\n      addMissing(train,missingLevel,predictorMissing,classMissing);\n    }\n    associator=AbstractAssociator.makeCopies(getAssociator(),1)[0];\n  }\n catch (  Exception ex) {\n    throw new Error(\"Error setting up for tests: \" + ex.getMessage());\n  }\n  try {\n    Instances trainCopy=new Instances(train);\n    associator.buildAssociations(trainCopy);\n    compareDatasets(train,trainCopy);\n    println(\"yes\");\n    result[0]=true;\n  }\n catch (  Exception ex) {\n    println(\"no\");\n    result[0]=false;\n    if (m_Debug) {\n      println(\"\\n=== Full Report ===\");\n      print(\"Problem during building\");\n      println(\": \" + ex.getMessage() + \"\\n\");\n      println(\"Here is the dataset:\\n\");\n      println(\"=== Train Dataset ===\\n\" + train.toString() + \"\\n\");\n    }\n  }\n  return result;\n}\n", "docstring": "checks whether the scheme alters the training dataset during building . if the scheme needs to modify the data it should take a copy of the training data . currently checks for changes to header structure , number of instances , order of instances , instance weights .", "partition": "test"}
{"idx": "5235", "code": "public boolean isEmpty(){\n  return mEventQueue.isEmpty();\n}\n", "docstring": "determines if the event queue is empty .", "partition": "test"}
{"idx": "5236", "code": "public static void testPrimitiveInstantiation(){\n  testPrimitiveInstantiation(false);\n}\n", "docstring": "test that all of the graphicsprimitiveproxy objects actually resolve to something . throws a runtimeexception if anything is wrong , an has no effect if all is well .", "partition": "test"}
{"idx": "5237", "code": "public void readEntries(TableKelp table,InSegment reader,SegmentEntryCallback cb){\n  TempBuffer tBuf=TempBuffer.createLarge();\n  byte[] buffer=tBuf.buffer();\n  InStore sIn=reader.getStoreRead();\n  byte[] tableKey=new byte[TableKelp.TABLE_KEY_SIZE];\n  for (int ptr=length() - BLOCK_SIZE; ptr > 0; ptr-=BLOCK_SIZE) {\n    sIn.read(getAddress() + ptr,buffer,0,buffer.length);\n    int index=0;\n    long seq=BitsUtil.readLong(buffer,index);\n    index+=8;\n    if (seq != getSequence()) {\n      log.warning(L.l(\"Invalid sequence {0} expected {1} at 0x{2}\",seq,getSequence(),Long.toHexString(getAddress() + ptr)));\n      break;\n    }\n    System.arraycopy(buffer,index,tableKey,0,tableKey.length);\n    index+=tableKey.length;\n    if (!Arrays.equals(tableKey,_tableKey)) {\n      log.warning(L.l(\"Invalid table {0} table {1} at 0x{2}\",Hex.toShortHex(tableKey),Hex.toShortHex(_tableKey),Long.toHexString(getAddress() + ptr)));\n      break;\n    }\n    int head=index;\n    while (head < BLOCK_SIZE && buffer[head] != 0) {\n      head=readEntry(table,buffer,head,cb,getAddress());\n    }\n    boolean isCont=buffer[head + 1] != 0;\n    if (!isCont) {\n      break;\n    }\n  }\n  tBuf.free();\n}\n", "docstring": "reads index entries from the segment . the index is at the tail of the segment , written backwards in blocks . the final block has the first entries , and the next to last has the second set of entries .", "partition": "test"}
{"idx": "5238", "code": "static int numberOfHosts(Map<URI,List<Initiator>> net2InitiatorsMap){\n  Set<URI> hostSet=new HashSet<URI>();\n  for (  List<Initiator> initiators : net2InitiatorsMap.values()) {\n    for (    Initiator init : initiators) {\n      hostSet.add(init.getHost());\n    }\n  }\n  return hostSet.size();\n}\n", "docstring": "returns number of hosts in the net2initiatorsmap", "partition": "test"}
{"idx": "5239", "code": "protected void processLob(LobMetadata lob,DatabaseMapping mapping,MetadataClass referenceClass,boolean isForMapKey){\n  lob.process(mapping,this,referenceClass,isForMapKey);\n}\n", "docstring": "internal : process a lob specification . the lob must be specified to process and create a lob type mapping .", "partition": "test"}
{"idx": "5240", "code": "protected AttributesImpl startPrefixMapping(Element element,NamespaceStack namespaceStack) throws SAXException {\n  AttributesImpl namespaceAttributes=null;\n  Namespace elementNamespace=element.getNamespace();\n  if ((elementNamespace != null) && !isIgnoreableNamespace(elementNamespace,namespaceStack)) {\n    namespaceStack.push(elementNamespace);\n    contentHandler.startPrefixMapping(elementNamespace.getPrefix(),elementNamespace.getURI());\n    namespaceAttributes=addNamespaceAttribute(namespaceAttributes,elementNamespace);\n  }\n  List<Namespace> declaredNamespaces=element.declaredNamespaces();\n  for (  Namespace namespace : declaredNamespaces) {\n    if (!isIgnoreableNamespace(namespace,namespaceStack)) {\n      namespaceStack.push(namespace);\n      contentHandler.startPrefixMapping(namespace.getPrefix(),namespace.getURI());\n      namespaceAttributes=addNamespaceAttribute(namespaceAttributes,namespace);\n    }\n  }\n  return namespaceAttributes;\n}\n", "docstring": "fires a sax startprefixmapping event for all the namespacestack which have just come into scope", "partition": "test"}
{"idx": "5241", "code": "private static DataFlavor[] convertToArray(List<DataFlavor> dataFlavourList){\n  DataFlavor[] array=new DataFlavor[dataFlavourList.size()];\n  dataFlavourList.toArray(array);\n  return array;\n}\n", "docstring": "convert dataflavor list to array .", "partition": "test"}
{"idx": "5242", "code": "public void testChoiceEmptyIconErrorHandling(){\n  String xml=\"\";\n  xml+=createStartMissionXml(\"start\",\"Name\");\n  xml+=createStartChoiceMomentXml(\"start\",0.5,\"Example ChoiceMoment Description\",\"choice_2\");\n  xml+=createChoiceXml(\"fire\",\"Example Choice Description 1\",\"start\",true,false,\"test_icon\");\n  xml+=createChoiceXml(\"choice_2\",\"Example Choice Description 2\",\"start\",false,false,\"\");\n  xml+=createEndChoiceMomentXml();\n  xml+=createEndChoiceMomentXml();\n  xml+=createEndMissionXml();\n  Utils.logDebug(TAG,xml);\n  InputStream momentInputStream=new ByteArrayInputStream(xml.getBytes());\n  mMission=new Mission(mMissionData);\n  boolean didMissionParseFail=false;\n  try {\n    mMission.readMoments(momentInputStream);\n  }\n catch (  MissionParseException e) {\n    e.printStackTrace();\n    didMissionParseFail=true;\n  }\n  Assert.assertEquals(true,didMissionParseFail);\n}\n", "docstring": "test for correct error handling for a choice that has an empty icon element .", "partition": "test"}
{"idx": "5243", "code": "public static String translateAttribute(String attributes) throws IOException {\n  short[] flags=strAttrToBooleanFlags(attributes);\n  StringBuilder sb=new StringBuilder();\n  if (flags[READ_ONLY] == YES)   sb.append(\" +R\");\n else   if (flags[READ_ONLY] == NO)   sb.append(\" -R\");\n  if (flags[HIDDEN] == YES)   sb.append(\" +H\");\n else   if (flags[HIDDEN] == NO)   sb.append(\" -H\");\n  if (flags[SYSTEM] == YES)   sb.append(\" +S\");\n else   if (flags[SYSTEM] == NO)   sb.append(\" -S\");\n  if (flags[ARCHIVE] == YES)   sb.append(\" +A\");\n else   if (flags[ARCHIVE] == NO)   sb.append(\" -A\");\n  return sb.toString();\n}\n", "docstring": "sets attributes of a file on windows system", "partition": "test"}
{"idx": "5244", "code": "public static int nextIndexId(){\n  return msgIdx.getAndIncrement();\n}\n", "docstring": "gets next id for indexed message id .", "partition": "test"}
{"idx": "5245", "code": "private void fillFieldValues(){\n  if (isCreationPanel) {\n    phrase.setText(\"\" + Hearing.DEFAULT_PHRASE);\n    outputAmount.setText(\"\" + Hearing.DEFAULT_OUTPUT_AMOUNT);\n  }\n else {\n    phrase.setText(\"\" + hearingSensor.getPhrase());\n    outputAmount.setText(\"\" + hearingSensor.getOutputAmount());\n  }\n}\n", "docstring": "set the current values of all fields .", "partition": "test"}
{"idx": "5246", "code": "public static boolean checkSecurityInfos(String endpoint,Identity clientIdentity,List<SecurityInfo> securityInfos){\n  if (clientIdentity.isSecure()) {\n    if (securityInfos == null || securityInfos.isEmpty()) {\n      LOG.warn(\"Client \'{}\' without security info try to connect through the secure endpoint\",endpoint);\n      return false;\n    }\n else {\n      for (      SecurityInfo securityInfo : securityInfos) {\n        if (checkSecurityInfo(endpoint,clientIdentity,securityInfo)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n else   if (securityInfos != null && !securityInfos.isEmpty()) {\n    LOG.warn(\"Client \'{}\' must connect using DTLS\",endpoint);\n    return false;\n  }\n  return true;\n}\n", "docstring": "return true if any of the securityinfos is valid for the given endpoint and client identity .", "partition": "test"}
{"idx": "5247", "code": "public boolean retainAll(AbstractIntList other){\n  if (other.size() == 0) {\n    if (size == 0)     return false;\n    setSize(0);\n    return true;\n  }\n  int limit=other.size() - 1;\n  int j=0;\n  for (int i=0; i < size; i++) {\n    if (other.indexOfFromTo(getQuick(i),0,limit) >= 0)     setQuick(j++,getQuick(i));\n  }\n  boolean modified=(j != size);\n  setSize(j);\n  return modified;\n}\n", "docstring": "retains ( keeps ) only the elements in the receiver that are contained in the specified other list . in other words , removes from the receiver all of its elements that are not contained in the specified other list .", "partition": "test"}
{"idx": "5248", "code": "public static ArrayList<ByteString> byteArraysToStrings(ArrayList<byte[]> byteArrays){\n  if (byteArrays == null) {\n    return null;\n  }\n  ArrayList<ByteString> byteStrings=new ArrayList<ByteString>();\n  for (  byte[] bytes : byteArrays) {\n    byteStrings.add(ByteString.of(bytes));\n  }\n  return byteStrings;\n}\n", "docstring": "converts an arraylist < byte [ ", "partition": "test"}
{"idx": "5249", "code": "void addIndex(IndexType type,List<String> columnNames){\n  IndexDefinition index=new IndexDefinition();\n  index.indexName=tableName + \"_\" + indexes.size();\n  index.columnNames=New.arrayList(columnNames);\n  index.type=type;\n  indexes.add(index);\n}\n", "docstring": "defines an index with the specified column names .", "partition": "test"}
{"idx": "5250", "code": "public Builder withKeyStoreKeyPassword(String keyStoreKeyPassword){\n  properties.setProperty(NettyOptions.SSL_KEY_STORE_KEY_PASSWORD,Assert.notNull(keyStoreKeyPassword,\"trustStorePassword\"));\n  return this;\n}\n", "docstring": "sets the ssl key store key password .", "partition": "test"}
{"idx": "5251", "code": "public ZookeeperStateMachineEnsemble(CuratorFramework curatorClient,String basePath){\n  this(curatorClient,basePath,true,DEFAULT_LOGSIZE);\n}\n", "docstring": "instantiates a new zookeeper state machine ensemble .", "partition": "test"}
{"idx": "5252", "code": "public static CustomShortcutSet createShortcut(char ch){\n  Character mnemonic=Character.valueOf(ch);\n  String shortcut=SystemInfo.isMac && SystemInfo.isJavaVersionAtLeast(\"1.7\") ? \"control alt pressed \" + mnemonic : \"alt pressed \" + mnemonic;\n  return CustomShortcutSet.fromString(shortcut);\n}\n", "docstring": "creates shortcut for mnemonic replacing standard alt + letter to ctrl + alt + letter on mac with jdk version newer than 6", "partition": "test"}
{"idx": "5253", "code": "public void gc(){\n  System.gc();\n}\n", "docstring": "runs the garbage collector . calling this method suggests that the java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse . when control returns from the method call , the java virtual machine has made its best effort to recycle all discarded objects . the name gc stands for \" garbage collector \" . the java virtual machine performs this recycling process automatically as needed even if the gc method is not invoked explicitly . the method system . gc ( ) is the conventional and convenient means of invoking this method .", "partition": "test"}
{"idx": "5254", "code": "private Node deleteMin(Node x){\n  if (x.left == null)   return x.right;\n  x.left=deleteMin(x.left);\n  x.size=1 + size(x.left) + size(x.right);\n  x.height=1 + Math.max(height(x.left),height(x.right));\n  return balance(x);\n}\n", "docstring": "removes the smallest key and associated value from the given subtree .", "partition": "test"}
{"idx": "5255", "code": "public static void resetCounters(){\n  errors=0;\n  warnings=0;\n}\n", "docstring": "reset error and warning counters", "partition": "test"}
{"idx": "5256", "code": "public void write(CeylonConfig config,File source,OutputStream out) throws IOException {\n  if (source.isFile()) {\n    InputStream in=null;\n    try {\n      in=new FileInputStream(source);\n      write(config,in,out);\n    }\n  finally {\n      if (in != null) {\n        try {\n          in.close();\n        }\n catch (        IOException e) {\n        }\n      }\n    }\n  }\n else {\n    throw new FileNotFoundException(\"Couldn\'t open source configuration file\");\n  }\n}\n", "docstring": "reads config from the given source file , updating it using the given configuration and writing in to the given output .", "partition": "test"}
{"idx": "5257", "code": "protected Map<TargetClass,List<Attribute.TypeCompound>> sift(final Iterable<Attribute.TypeCompound> typeCompounds){\n  final Map<TargetClass,List<Attribute.TypeCompound>> targetClassToCompound=new EnumMap<>(TargetClass.class);\n  for (  TargetClass targetClass : TargetClass.values()) {\n    targetClassToCompound.put(targetClass,new ArrayList<TypeCompound>());\n  }\n  for (  final Attribute.TypeCompound typeCompound : typeCompounds) {\n    final TargetType typeCompoundTarget=typeCompound.position.type;\n    final List<Attribute.TypeCompound> destList;\n    if (ElementAnnotationUtil.contains(typeCompoundTarget,annotatedTargets())) {\n      destList=targetClassToCompound.get(TargetClass.TARGETED);\n    }\n else     if (ElementAnnotationUtil.contains(typeCompoundTarget,validTargets())) {\n      destList=targetClassToCompound.get(TargetClass.VALID);\n    }\n else {\n      destList=targetClassToCompound.get(TargetClass.INVALID);\n    }\n    destList.add(typeCompound);\n  }\n  return targetClassToCompound;\n}\n", "docstring": "separate the input annotations into a map of targetclass ( targeted , valid , invalid ) to the annotations that fall into each of those categories .", "partition": "test"}
{"idx": "5258", "code": "protected synchronized void updateLocation(Point newLocn){\n  prev=locn;\n  locn=newLocn;\n  if (Math.abs(locn.x - prev.x) > hysteresis || Math.abs(locn.y - prev.y) > hysteresis) {\n    if (timer.isRunning())     timer.stop();\n  }\n else {\n    if (!timer.isRunning())     timer.start();\n  }\n}\n", "docstring": "cause autoscroll to occur < p >", "partition": "test"}
{"idx": "5259", "code": "@Override public int compareTo(Value o){\n  if (o instanceof StringVal) {\n    return str.compareTo(((StringVal)o).str);\n  }\n else {\n    return 0;\n  }\n}\n", "docstring": "compares the string value to another value", "partition": "test"}
{"idx": "5260", "code": "public void bind(IntegerProperty property,int value){\n  if (isAchieved())   return;\n  bind(property.greaterThanOrEqualTo(value));\n  BooleanBinding bb=property.greaterThanOrEqualTo(value / 2);\n  progressListener=null;\n  bb.addListener(progressListener);\n}\n", "docstring": "bind achievement condition to given property .", "partition": "test"}
{"idx": "5261", "code": "public synchronized void write(String logData){\n  if (logEnabled) {\n    histData.append(logData);\n    histData.revalidate();\nsynchronized (histData) {\n      histData.notify();\n    }\n  }\n}\n", "docstring": "append text to the log , repaint the window and notify the autoscroll thread to scroll to the end of the text area .", "partition": "test"}
{"idx": "5262", "code": "public void closeConnection(){\n  try {\n    if (m_connection != null) {\n      m_connection.close();\n    }\n  }\n catch (  final SQLException exception) {\n    NaviLogger.severe(\"Error: Closing the database connection failed with exception: %s\",exception);\n  }\n  m_connection=null;\n}\n", "docstring": "closes the connection to the database .", "partition": "test"}
{"idx": "5263", "code": "public StructEmBayesSearchEditor(StructEmBayesSearchRunner semBayesEstWrapper){\n  this(semBayesEstWrapper.getEstimatedBayesIm(),semBayesEstWrapper.getDataSet());\n}\n", "docstring": "constructs a new bayes im editor from a bayes estimator wrapper .", "partition": "test"}
{"idx": "5264", "code": "public void removeActionListener(ActionListener listener){\n  forwardProjectionButton.addActionListener(listener);\n  backProjectionButton.addActionListener(listener);\n}\n", "docstring": "removes the listener for events that shift the projection stack .", "partition": "test"}
{"idx": "5265", "code": "boolean isLiteral(int index){\n  if (isValidMask() && index < string.length()) {\n    return literalMask.get(index);\n  }\n  return false;\n}\n", "docstring": "returns true if the character at index is a literal , that is not editable .", "partition": "test"}
{"idx": "5266", "code": "protected Granularity generateGranularity(String granularity,GranularityParser granularityParser) throws BadApiRequestException {\n  try {\n    return granularityParser.parseGranularity(granularity);\n  }\n catch (  GranularityParseException e) {\n    LOG.error(UNKNOWN_GRANULARITY.logFormat(granularity),granularity);\n    throw new BadApiRequestException(e.getMessage());\n  }\n}\n", "docstring": "generate a granularity instance based on a path element .", "partition": "test"}
{"idx": "5267", "code": "public WordIterator(){\n  this(Locale.getDefault());\n}\n", "docstring": "constructs a worditerator using the default locale .", "partition": "test"}
{"idx": "5268", "code": "@Override public void close(){\n  if (leaf != null) {\n    leaf.close();\n    leaf=null;\n  }\n  ccMgr.releaseIndexLocks();\n  dirsMayBeUpdated=null;\n}\n", "docstring": "closes the index by closing its open leaf page , if necessary .", "partition": "test"}
{"idx": "5269", "code": "public void pushFile(String local,String remote,ISyncProgressMonitor monitor) throws SyncException, IOException, TimeoutException {\n  File f=new File(local);\n  if (!f.exists()) {\n    throw new SyncException(SyncError.NO_LOCAL_FILE);\n  }\n  if (f.isDirectory()) {\n    throw new SyncException(SyncError.LOCAL_IS_DIRECTORY);\n  }\n  monitor.start((int)f.length());\n  doPushFile(local,remote,monitor);\n  monitor.stop();\n}\n", "docstring": "push a single file .", "partition": "test"}
{"idx": "5270", "code": "public String process(Item seg) throws ProcessException {\n  return segCodaCtype(seg,\"f\");\n}\n", "docstring": "performs some processing on the given item .", "partition": "test"}
{"idx": "5271", "code": "public void resize(int size){\n  if (buffer != null) {\n    if (size >= 0 && size < buffer.size()) {\n      int oldLastIndex=buffer.size() - 1;\n      int newLastIndex=size - 1;\n      for (int i=oldLastIndex; i > newLastIndex; i--) {\n        buffer.remove(i);\n      }\n    }\n  }\n else {\n    if (size >= 0 && size < offsets.size()) {\n      long offset=offsets.get(size);\n      byteCache.resize(key,offset);\n      ArrayList<Long> newOffsets=new ArrayList<Long>(size);\n      for (int i=0; i < size; i++) {\n        newOffsets.add(offsets.get(i));\n      }\n      offsets=newOffsets;\n    }\n  }\n}\n", "docstring": "resizes the array to contain a smaller number of elements . has no effect if the size is greater than current number of elements .", "partition": "test"}
{"idx": "5272", "code": "protected void initFromDir(String prefix,File dir){\n  File[] files;\n  files=dir.listFiles(new ClassFileFilter());\n  for (  File file : files) {\n    if (prefix == null) {\n      add(file.getName());\n    }\n else {\n      add(prefix + \".\" + file.getName());\n    }\n  }\n  files=dir.listFiles(new DirectoryFilter());\n  for (  File file : files) {\n    if (prefix == null) {\n      initFromDir(file.getName(),file);\n    }\n else {\n      initFromDir(prefix + \".\" + file.getName(),file);\n    }\n  }\n}\n", "docstring": "fills the class cache with classes in the specified directory .", "partition": "test"}
{"idx": "5273", "code": "public void removeBandwidth(String name){\n  if (name != null)   if (bandwidthList != null) {\n    for (int i=0; i < bandwidthList.size(); i++) {\n      Object o=bandwidthList.elementAt(i);\n      if (o instanceof BandwidthField) {\n        BandwidthField b=(BandwidthField)o;\n        try {\n          String type=b.getType();\n          if (type != null) {\n            if (name.equals(type)) {\n              bandwidthList.remove(b);\n            }\n          }\n        }\n catch (        SdpParseException e) {\n        }\n      }\n    }\n  }\n}\n", "docstring": "removes the specified bandwidth type .", "partition": "test"}
{"idx": "5274", "code": "public static long now(){\n  return System.currentTimeMillis();\n}\n", "docstring": "get the current time .", "partition": "test"}
{"idx": "5275", "code": "public static String collapseNewlines(String argStr){\n  char last=argStr.charAt(0);\n  StringBuffer argBuf=new StringBuffer();\n  for (int cIdx=0; cIdx < argStr.length(); cIdx++) {\n    char ch=argStr.charAt(cIdx);\n    if (ch != '\\n' || last != '\\n') {\n      argBuf.append(ch);\n      last=ch;\n    }\n  }\n  return argBuf.toString();\n}\n", "docstring": "remove / collapse multiple newline characters .", "partition": "test"}
{"idx": "5276", "code": "@Override protected String generateJavadoc(int index) throws Exception {\n  throw new Exception(\"Not used!\");\n}\n", "docstring": "generates and returns the javadoc for the specified start / end tag pair .", "partition": "test"}
{"idx": "5277", "code": "public Properties extractProperties(Iterable<Map.Entry<String,String>> propSrc){\n  Properties result=new Properties();\n  for (  Map.Entry<String,String> entry : propSrc) {\n    String name=entry.getKey();\n    if (isNamespacedProperty(name)) {\n      String val=entry.getValue();\n      result.setProperty(name,val);\n    }\n  }\n  return result;\n}\n", "docstring": "extract all properties in this namespace that can be found in the provided property source", "partition": "test"}
{"idx": "5278", "code": "public T removeLast(){\n  if (rows.size() != 0)   rows.remove(rows.size() - 1);\n  return instance();\n}\n", "docstring": "remove the last row .", "partition": "test"}
{"idx": "5279", "code": "public static void ensureVisible(String componentName){\n  if (verbose) {\n    log(\"ensureVisible(\" + componentName + \")\");\n  }\n  ensureVisible(findByName(componentName));\n}\n", "docstring": "scrolls to show the component in case it is invisible currently", "partition": "test"}
{"idx": "5280", "code": "public void endRepresentation(){\n  if (!representationProtectionsSet) {\n    if (currentRepresentationProtections != null) {\n      Collections.sort(currentRepresentationProtections,this);\n    }\n    representationProtections=currentRepresentationProtections;\n    representationProtectionsSet=true;\n  }\n else {\n    if (currentRepresentationProtections == null) {\n      Assertions.checkState(representationProtections == null);\n    }\n else {\n      Collections.sort(currentRepresentationProtections,this);\n      Assertions.checkState(currentRepresentationProtections.equals(representationProtections));\n    }\n  }\n  currentRepresentationProtections=null;\n}\n", "docstring": "should be invoked after processing each child representation element , in order to apply consistency checks .", "partition": "test"}
{"idx": "5281", "code": "public StandardPieSectionLabelGenerator(String labelFormat){\n  this(labelFormat,NumberFormat.getNumberInstance(),NumberFormat.getPercentInstance());\n}\n", "docstring": "creates a new section label generator using the specified label format string , and platform default number and percentage formatters .", "partition": "test"}
{"idx": "5282", "code": "public static CharSequence[] split(CharSequence line,int delimiter){\n  CharSequence[] tokens0=split(line,delimiter,N);\n  if (tokens0.length < N) {\n    return tokens0;\n  }\n else {\n    CharSequence[] tokens1=split(tokens0[N - 1],delimiter);\n    CharSequence[] tokens2=new CharSequence[tokens0.length + tokens1.length - 1];\n    System.arraycopy(tokens0,0,tokens2,0,tokens0.length - 1);\n    System.arraycopy(tokens1,0,tokens2,tokens0.length - 1,tokens1.length);\n    return tokens2;\n  }\n}\n", "docstring": "splits a charsequence according to the delimiter character .", "partition": "test"}
{"idx": "5283", "code": "public CCTimer(Object t,String s,float seconds){\n  target=t;\n  selector=s;\n  interval=seconds;\n  elapsed=-1;\n  try {\n    Class<?> cls=target.getClass();\n    invocation=cls.getMethod(s,Float.TYPE);\n  }\n catch (  NoSuchMethodException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "initializes a timer with a target , a selector and an interval in seconds .", "partition": "test"}
{"idx": "5284", "code": "public Tuple read() throws IOException {\n  try {\n    Map fields=jsonTupleStream.next();\n    if (fields == null) {\n      Map m=new HashMap();\n      m.put(\"EOF\",true);\n      return new Tuple(m);\n    }\n else {\n      String msg=(String)fields.get(\"EXCEPTION\");\n      if (msg != null) {\n        HandledException ioException=new HandledException(msg);\n        throw ioException;\n      }\n      if (trace) {\n        fields.put(\"_CORE_\",this.baseUrl);\n        if (slice != null) {\n          fields.put(\"_SLICE_\",slice);\n        }\n      }\n      if (fieldMappings != null) {\n        fields=mapFields(fields,fieldMappings);\n      }\n      return new Tuple(fields);\n    }\n  }\n catch (  HandledException e) {\n    throw new IOException(\"--> \" + this.baseUrl + \":\"+ e.getMessage());\n  }\ncatch (  Exception e) {\n    throw new IOException(\"--> \" + this.baseUrl + \": An exception has occurred on the server, refer to server log for details.\",e);\n  }\n}\n", "docstring": "reads a tuple from the stream . the stream is completed when tuple . eof = = true .", "partition": "test"}
{"idx": "5285", "code": "private String compute(String left,double right,boolean isInteger){\n  if (left == null && Double.isNaN(right)) {\n    return null;\n  }\n  if (isInteger && right == (int)right) {\n    return (left == null ? \"\" : left) + (int)right;\n  }\n else   if (Double.isInfinite(right)) {\n    return (left == null ? \"\" : left) + Tools.formatNumber(right);\n  }\n else {\n    return (left == null ? \"\" : left) + (Double.isNaN(right) ? \"\" : right);\n  }\n}\n", "docstring": "adds a string and a double . if the double represents an integer tries to add it without trailing \"'\" . 0 \"'\" . if both are missing , then the result is missing ; if one is missing , it is ignored . if the double is infinite , formats is using a symbol .", "partition": "test"}
{"idx": "5286", "code": "public void removePropertyChangeListener(final PropertyChangeListener listener){\n  propertyChangeSupport.removePropertyChangeListener(listener);\n}\n", "docstring": "remove the specified property change listener .", "partition": "test"}
{"idx": "5287", "code": "public void loadXML(Node stepnode,List<DatabaseMeta> databases,Map<String,Counter> counters) throws KettleXMLException {\n  try {\n    this.tabelName=XMLHandler.getTagValue(stepnode,\"TableName\");\n    this.outputRowSize=XMLHandler.getTagValue(stepnode,\"outputRowSize\");\n    this.factDimLensString=XMLHandler.getTagValue(stepnode,\"factDimLensString\");\n    this.tableName=XMLHandler.getTagValue(stepnode,\"tableName\");\n    this.databaseName=XMLHandler.getTagValue(stepnode,\"databaseName\");\n    this.dimensionCount=XMLHandler.getTagValue(stepnode,\"dimensionCount\");\n    this.noDictionaryDims=XMLHandler.getTagValue(stepnode,\"noDictionaryDims\");\n    this.noDictionaryDimsMapping=XMLHandler.getTagValue(stepnode,\"noDictionaryDimsMapping\");\n    this.complexDimensionCount=XMLHandler.getTagValue(stepnode,\"complexDimensionCount\");\n    this.measureCount=XMLHandler.getTagValue(stepnode,\"measureCount\");\n    this.updateMemberRequest=XMLHandler.getTagValue(stepnode,\"isUpdateMemberRequest\");\n    this.measureDataType=XMLHandler.getTagValue(stepnode,\"measureDataType\");\n    this.partitionID=XMLHandler.getTagValue(stepnode,\"partitionID\");\n    this.segmentId=XMLHandler.getTagValue(stepnode,\"segmentId\");\n    this.taskNo=XMLHandler.getTagValue(stepnode,\"taskNo\");\n  }\n catch (  Exception e) {\n    throw new KettleXMLException(\"Unable to read step info from XML node\",e);\n  }\n}\n", "docstring": "load the values for this step from an xml node", "partition": "test"}
{"idx": "5288", "code": "public final int[] hashSignature(final int[] signature){\n  int[] hash=new int[stages];\n  int rows=signature.length / stages;\n  for (int i=0; i < signature.length; i++) {\n    int stage=Math.min(i / rows,stages - 1);\n    hash[stage]=(int)((hash[stage] + (long)signature[i] * LARGE_PRIME) % buckets);\n  }\n  return hash;\n}\n", "docstring": "hash a signature . the signature is divided in s stages ( or bands ) . each stage is hashed to one of the b buckets .", "partition": "test"}
{"idx": "5289", "code": "public void cast(final Type from,final Type to){\n  if (from != to) {\n    if (from == Type.DOUBLE_TYPE) {\n      if (to == Type.FLOAT_TYPE) {\n        mv.visitInsn(Opcodes.D2F);\n      }\n else       if (to == Type.LONG_TYPE) {\n        mv.visitInsn(Opcodes.D2L);\n      }\n else {\n        mv.visitInsn(Opcodes.D2I);\n        cast(Type.INT_TYPE,to);\n      }\n    }\n else     if (from == Type.FLOAT_TYPE) {\n      if (to == Type.DOUBLE_TYPE) {\n        mv.visitInsn(Opcodes.F2D);\n      }\n else       if (to == Type.LONG_TYPE) {\n        mv.visitInsn(Opcodes.F2L);\n      }\n else {\n        mv.visitInsn(Opcodes.F2I);\n        cast(Type.INT_TYPE,to);\n      }\n    }\n else     if (from == Type.LONG_TYPE) {\n      if (to == Type.DOUBLE_TYPE) {\n        mv.visitInsn(Opcodes.L2D);\n      }\n else       if (to == Type.FLOAT_TYPE) {\n        mv.visitInsn(Opcodes.L2F);\n      }\n else {\n        mv.visitInsn(Opcodes.L2I);\n        cast(Type.INT_TYPE,to);\n      }\n    }\n else {\n      if (to == Type.BYTE_TYPE) {\n        mv.visitInsn(Opcodes.I2B);\n      }\n else       if (to == Type.CHAR_TYPE) {\n        mv.visitInsn(Opcodes.I2C);\n      }\n else       if (to == Type.DOUBLE_TYPE) {\n        mv.visitInsn(Opcodes.I2D);\n      }\n else       if (to == Type.FLOAT_TYPE) {\n        mv.visitInsn(Opcodes.I2F);\n      }\n else       if (to == Type.LONG_TYPE) {\n        mv.visitInsn(Opcodes.I2L);\n      }\n else       if (to == Type.SHORT_TYPE) {\n        mv.visitInsn(Opcodes.I2S);\n      }\n    }\n  }\n}\n", "docstring": "generates the instructions to cast a numerical value from one type to another .", "partition": "test"}
{"idx": "5290", "code": "private void addTriggerGroupName(String groupName) throws JobPersistenceException, ResourceException {\n  addRepoListName(groupName,TRIGGER_GROUP_NAMES_RESOURCE_PATH,\"names\");\n}\n", "docstring": "adds a trigger group name to the list of trigger group names", "partition": "test"}
{"idx": "5291", "code": "private synchronized void clearTempFiles(){\n  if ((tempFiles != null) && (tempFiles.size() > 0)) {\n    Iterator it=tempFiles.iterator();\n    File file=null;\n    while (it.hasNext()) {\n      file=(File)it.next();\n      file.delete();\n    }\n    tempFiles.clear();\n  }\n}\n", "docstring": "limpia la lista de ficheros temporales del escaneo", "partition": "test"}
{"idx": "5292", "code": "private Bitmap readAndDecompressThumbnail(File file){\n  try {\n    if (file.length() > 0) {\n      FileInputStream instream=new FileInputStream(file);\n      ReadableByteChannel bytechan=Channels.newChannel(instream);\n      ByteBuffer buff=ByteBuffer.allocateDirect((int)file.length());\n      if (buff != null) {\n        bytechan.read(buff);\n        instream.close();\n        buff.rewind();\n        PDQImage pthumb=DecompressionService.decompressThumbnailImage(buff);\n        if (pthumb != null) {\n          Bitmap bm=ConversionService.convertPDQImageToBitmap(pthumb,false);\n          pthumb.close();\n          return bm;\n        }\n      }\n    }\n  }\n catch (  IOException ex) {\n    ex.printStackTrace();\n  }\n  return null;\n}\n", "docstring": "read and extract a thumbnail - sized image from a file .", "partition": "test"}
{"idx": "5293", "code": "public void testSubmitRunnable() throws Throwable {\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    Future<?> future=e.submit(new NoOpRunnable());\n    assertNull(future.get());\n    assertTrue(future.isDone());\n    assertFalse(future.isCancelled());\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "completed submit ( runnable ) returns successfully", "partition": "test"}
{"idx": "5294", "code": "public Rectangle2D shrink(Rectangle2D area,Rectangle2D result){\n  if (result == null) {\n    result=new Rectangle2D.Double();\n  }\n  result.setRect(area.getX() + this.left,area.getY() + this.top,area.getWidth() - this.left - this.right,area.getHeight() - this.top - this.bottom);\n  return result;\n}\n", "docstring": "shrinks an area by the space attributes .", "partition": "test"}
{"idx": "5295", "code": "public static String assertJQ(SolrQueryRequest req,String... tests) throws Exception {\n  return assertJQ(req,JSONTestUtil.DEFAULT_DELTA,tests);\n}\n", "docstring": "validates a query matches some json test expressions using the default double delta tolerance .", "partition": "test"}
{"idx": "5296", "code": "protected void buildAbsoluteStats(String name,long value,long time) throws InterruptedException {\n  List<XYDataItem> stats=statsCollection.getStats(name);\n  if (stats == null) {\n    stats=statsCollection.newStats(name,maxSeries);\n  }\n else {\n    XYDataItem data=new XYDataItem(time,value);\n    statsCollection.lockForUpdate();\n    try {\n      stats.add(data);\n      houseKeepStats(stats);\n    }\n  finally {\n      statsCollection.releaseLock();\n    }\n    if (listeners != null) {\n      StatsCollectionEvent event=new StatsCollectionEvent(name,data);\n      for (      StatsCollectionListener listener : listeners) {\n        if (listener.isEnabled()) {\n          listener.statsCollected(event);\n        }\n      }\n    }\n  }\n}\n", "docstring": "builds the absolute stats .", "partition": "test"}
{"idx": "5297", "code": "@Override public void run(){\n  amIActive=true;\n  String demHeader=null;\n  String streamHeadsHeader=null;\n  String elevationModifiedHeader=null;\n  String correctedDemHeader=null;\n  List<StreamHead> streamHeadList=new ArrayList<>();\n  int counter=0;\n  float progress=0;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      demHeader=args[i];\n    }\n else     if (i == 1) {\n      streamHeadsHeader=args[i];\n    }\n else     if (i == 2) {\n      elevationModifiedHeader=args[i];\n    }\n else     if (i == 3) {\n      correctedDemHeader=args[i];\n    }\n else     if (i == 4) {\n      maxRadius=Double.parseDouble(args[i]);\n    }\n  }\n  if ((demHeader == null) || (streamHeadsHeader == null) || (elevationModifiedHeader == null)|| (correctedDemHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    dem=new WhiteboxRaster(demHeader,\"r\");\n    streamHeads=new WhiteboxRaster(streamHeadsHeader,\"r\");\n    numRows=dem.getNumberRows();\n    numCols=dem.getNumberColumns();\n    noData=dem.getNoDataValue();\n    gridRes=dem.getCellSizeX();\n    elevationModified=new WhiteboxRaster(elevationModifiedHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    elevationModified.setPreferredPalette(\"blueyellow.pal\");\n    elevationModified.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    elevationModified.setZUnits(\"dimensionless\");\n    correctedDEM=new WhiteboxRaster(correctedDemHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    correctedDEM.setPreferredPalette(\"blueyellow.pal\");\n    correctedDEM.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    correctedDEM.setZUnits(\"dimensionless\");\n    if (streamHeads.getNumberColumns() != numCols || streamHeads.getNumberRows() != numRows) {\n      showFeedback(\"Input images must have the same dimensions.\");\n      return;\n    }\n    updateProgress(\"Loop 1 of 4:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (dem.getValue(row,col) != noData) {\n          elevationModified.setValue(row,col,0);\n        }\n else {\n          elevationModified.setValue(row,col,noData);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 1 of 4:\",(int)progress);\n    }\n    updateProgress(\"Loop 2 of 4:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (streamHeads.getValue(row,col) == 1) {\n          streamHeadList.add(new StreamHead(col,row,dem.getValue(row,col)));\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 2 of 4:\",(int)progress);\n    }\n    streamHeadList=OrderStreamHeads(streamHeadList);\n    updateProgress(\"Loop 3 of 4:\",0);\n    for (    StreamHead streamHead : streamHeadList) {\n      CheckFlowPath(streamHead.GetXCoord(),streamHead.GetYCoord());\n      counter=counter + 1;\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * counter / streamHeadList.size());\n      updateProgress(\"Loop 3 of 4:\",(int)progress);\n    }\n    updateProgress(\"Loop 4 of 4:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (elevationModified.getValue(row,col) != noData) {\n          correctedDEM.setValue(row,col,dem.getValue(row,col) - elevationModified.getValue(row,col));\n        }\n else {\n          correctedDEM.setValue(row,col,noData);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 4 of 4:\",(int)progress);\n    }\n    elevationModified.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    elevationModified.addMetadataEntry(\"Created on \" + new Date());\n    correctedDEM.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    correctedDEM.addMetadataEntry(\"Created on \" + new Date());\n    dem.close();\n    streamHeads.close();\n    elevationModified.close();\n    correctedDEM.close();\n    returnData(correctedDemHeader);\n  }\n catch (  Exception e) {\n    showFeedback(e.getMessage());\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "docstring": "used to execute this plugin tool .", "partition": "test"}
{"idx": "5298", "code": "protected void serialize(String filename){\n  classifier.serializeClassifier(filename);\n}\n", "docstring": "serialize a model to file .", "partition": "test"}
{"idx": "5299", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return BEGIN_IN_BOTH;\ncase 2:\n  return NEWINT;\ncase 3:\nreturn NEWBYTE;\ncase 4:\nreturn NEWSHORT;\ncase 5:\nreturn NEWLONG;\ncase 6:\nreturn NEWDOUBLE;\ncase 7:\nreturn NEWSTRUCT;\ncase 8:\nreturn NEWLIST;\ncase 9:\nreturn NEWSET;\ncase 10:\nreturn NEWMAP;\ncase 11:\nreturn NEWSTRING;\ncase 12:\nreturn END_IN_BOTH;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "5300", "code": "protected Size2D arrangeFN(BlockContainer container,Graphics2D g2,RectangleConstraint constraint){\n  List blocks=container.getBlocks();\n  Block b=(Block)blocks.get(0);\n  Size2D s=b.arrange(g2,RectangleConstraint.NONE);\n  double width=constraint.getWidth();\n  Rectangle2D bounds=new Rectangle2D.Double((width - s.width) / 2.0,0.0,s.width,s.height);\n  b.setBounds(bounds);\n  return new Size2D((width - s.width) / 2.0,s.height);\n}\n", "docstring": "arranges the blocks in the container with a fixed width and no height constraint .", "partition": "test"}
{"idx": "5301", "code": "private Object processExecute(Statement proxy,Method method,Object[] args) throws Throwable {\n  long startTime=logSlowQuery ? System.currentTimeMillis() : 0L;\n  try {\n    if (method.getName() == \"executeQuery\")     return newProxiedResultSet(proxy,method,args);\n    return targetInvoke(method,args);\n  }\n  finally {\n    if (logSlowQuery)     logQuery(proxy,args,startTime);\n  }\n}\n", "docstring": "mainly exists to provide statement . execute . . . methods timing logging .", "partition": "test"}
{"idx": "5302", "code": "int boundedIndexOf(String string,char search,int start,int end){\n  int retValue=string.indexOf(search,start);\n  if (retValue >= end) {\n    return -1;\n  }\n  return retValue;\n}\n", "docstring": "similar to string . indexof , but allows an upper bound ( this is slower in that it will still check string starting at start .", "partition": "test"}
{"idx": "5303", "code": "public int incr(T k,int delta){\n  Integer i=counts.get(k);\n  if (i == null) {\n    i=0;\n  }\n  int next=i.intValue() + delta;\n  if (next < 0) {\n    throw new java.lang.ArithmeticException();\n  }\n  if (next == 0) {\n    counts.remove(k);\n  }\n else {\n    counts.put(k,i + delta);\n  }\n  return i;\n}\n", "docstring": "adds delta to the count for k and returns the count prior to addition .", "partition": "test"}
{"idx": "5304", "code": "public void send(final OscPacket thePacket,final TcpClient theClient){\n  theClient.send(thePacket.getBytes());\n}\n", "docstring": "send to tcp client", "partition": "test"}
{"idx": "5305", "code": "@Override @SuppressWarnings(\"unchecked\") public void keyTyped(KeyEvent evt){\n  int modifiers=evt.getModifiers();\n  char c=evt.getKeyChar();\n  if (c != KeyEvent.CHAR_UNDEFINED && (modifiers & InputEvent.ALT_MASK) == 0) {\n    if (c >= 0x20 && c != 0x7f) {\n      KeyStroke keyStroke=KeyStroke.getKeyStroke(Character.toUpperCase(c));\n      Object o=currentBindings.get(keyStroke);\n      if (o instanceof Hashtable) {\n        currentBindings=(Hashtable)o;\n        return;\n      }\n else       if (o instanceof ActionListener) {\n        currentBindings=bindings;\n        executeAction((ActionListener)o,evt.getSource(),String.valueOf(c));\n        return;\n      }\n      currentBindings=bindings;\n      if (grabAction != null) {\n        handleGrabAction(evt);\n        return;\n      }\n      if (repeat && Character.isDigit(c)) {\n        repeatCount*=10;\n        repeatCount+=(c - \'0\');\n        return;\n      }\n      executeAction(INSERT_CHAR,evt.getSource(),String.valueOf(evt.getKeyChar()));\n      repeatCount=0;\n      repeat=false;\n    }\n  }\n}\n", "docstring": "handle a key typed event . this inserts the key into the text area .", "partition": "test"}
{"idx": "5306", "code": "public static Map<String,MappedClass> fillInTheGaps(Map<String,MappedClass> mappedClasses,MappingMode mode){\n  for (  String originalName : mappedClasses.keySet()) {\n    mappedClasses=fillGap(mappedClasses.get(originalName),mappedClasses,mode);\n  }\n  return mappedClasses;\n}\n", "docstring": "given a map of already renamed classes , fill in the gaps for classes that were not reached , but have parents that can be pulled from .", "partition": "test"}
{"idx": "5307", "code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  if (name == null) {\n    if (types != null) {\n      throw new InvalidObjectException(\"cannot have types with null name\");\n    }\n  }\n else {\n    try {\n      check();\n    }\n catch (    RuntimeException e) {\n      rethrow(e);\n    }\n  }\n  if (constraints != null && constraints.isEmpty()) {\n    throw new InvalidObjectException(\"constraints cannot be empty\");\n  }\n}\n", "docstring": "verifies that the method name , parameter types , and constraints are valid .", "partition": "test"}
{"idx": "5308", "code": "public static Script createMultiSigInputScriptBytes(List<byte[]> signatures){\n  checkArgument(signatures.size() <= 16);\n  ScriptBuilder builder=new ScriptBuilder();\n  builder.smallNum(0);\n  for (  byte[] signature : signatures)   builder.data(signature);\n  return builder.build();\n}\n", "docstring": "create a program that satisfies an op_checkmultisig program , using pre - encoded signatures .", "partition": "test"}
{"idx": "5309", "code": "public static void gc2gc(double c1[],int m1,double g1,double c2[],int m2,double g2){\n  double[] gc2gc_buff=Arrays.copyOf(c1,m1 + 1);\n  c2[0]=gc2gc_buff[0];\n  for (int i=1; i <= m2; i++) {\n    double ss1=0.0;\n    double ss2=0.0;\n    int min=m1 < i ? m1 : i - 1;\n    for (int k=1; k <= min; k++) {\n      int mk=i - k;\n      double cc=gc2gc_buff[k] * c2[mk];\n      ss2+=k * cc;\n      ss1+=mk * cc;\n    }\n    if (i <= m1)     c2[i]=gc2gc_buff[i] + (g2 * ss2 - g1 * ss1) / i;\n else     c2[i]=(g2 * ss2 - g1 * ss1) / i;\n  }\n}\n", "docstring": "gc2gc : generalized cepstral transformation", "partition": "test"}
{"idx": "5310", "code": "public static boolean between(Date baseDate,Date startDate,Date endDate){\n  if (startDate.equals(endDate) || endDate.before(startDate)) {\n    return false;\n  }\n  if ((startDate.before(baseDate) || startDate.equals(baseDate)) && (endDate.after(baseDate) || endDate.equals(baseDate))) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "tests if the given base date is between the given start date and end date , including the dates themselves .", "partition": "test"}
{"idx": "5311", "code": "public void addListener(final TimeoutEventListener listener){\n  final long timeout=listener.getTimeout();\n  if (timeout > 0) {\n    listeners.add(listener);\nsynchronized (stateLock) {\n      pendingListenerMinDelay=Math.min(pendingListenerMinDelay,timeout);\n      stateLock.notifyAll();\n    }\n  }\n}\n", "docstring": "registers a timeout event listener for timeout notification .", "partition": "test"}
{"idx": "5312", "code": "public static String transformToolTipText(final String description,final boolean addHTMLTags,final int lineLength,final boolean escapeSlashes,final boolean escapeHTML){\n  String completeText=description.trim();\n  if (escapeHTML) {\n    completeText=Tools.escapeHTML(completeText);\n  }\n  if (escapeSlashes) {\n    completeText=completeText.replaceAll(\"/\",\"&#47;\");\n  }\n  StringBuffer result=new StringBuffer();\n  if (addHTMLTags) {\n    result.append(\"<html>\");\n  }\n  completeText=Tools.transformAllLineSeparators(completeText);\n  String[] lines=completeText.split(\"\\n\");\n  for (  String text : lines) {\n    boolean first=true;\n    while (text.length() > lineLength) {\n      int spaceIndex=text.indexOf(\" \",lineLength);\n      if (!first) {\n        result.append(\"<br>\");\n      }\n      first=false;\n      if (spaceIndex >= 0) {\n        result.append(text.substring(0,spaceIndex));\n        text=text.substring(spaceIndex + 1);\n      }\n else {\n        result.append(text);\n        text=\"\";\n      }\n    }\n    if (!first && text.length() > 0) {\n      result.append(\"<br>\");\n    }\n    result.append(text);\n    result.append(\"<br>\");\n  }\n  if (addHTMLTags) {\n    result.append(\"</html>\");\n  }\n  return result.toString();\n}\n", "docstring": "this method transforms the given tool tip text into html . lines are splitted at linebreaks and additional line breaks are added after ca . linelength characters .", "partition": "test"}
{"idx": "5313", "code": "@Override public void write(byte[] buffer,int offset,int length){\n  if (isClosed() || isHead()) {\n    return;\n  }\n  int byteLength=_offset;\n  while (true) {\n    int sublen=Math.min(length,SIZE - byteLength);\n    System.arraycopy(buffer,offset,_buffer,byteLength,sublen);\n    offset+=sublen;\n    length-=sublen;\n    byteLength+=sublen;\n    if (length <= 0) {\n      break;\n    }\n    _offset=byteLength;\n    flushByteBuffer();\n    byteLength=_offset;\n  }\n  _offset=byteLength;\n}\n", "docstring": "writes a chunk of bytes to the stream .", "partition": "test"}
{"idx": "5314", "code": "public ClientHttpRequest(URLConnection connection) throws IOException {\n  this.connection=connection;\n  connection.setDoOutput(true);\n  connection.setDoInput(true);\n  connection.setRequestProperty(\"Content-Type\",\"multipart/form-data; boundary=\" + boundary);\n}\n", "docstring": "creates a new multipart post http request on a freshly opened urlconnection", "partition": "test"}
{"idx": "5315", "code": "private void appendTag(String tagName,String value){\n  xml.append(\"\\n<\");\n  xml.append(tagName);\n  xml.append(\"><![CDATA[\");\n  xml.append(value);\n  xml.append(\"]]></\");\n  xml.append(tagName);\n  xml.append(\">\");\n}\n", "docstring": "helper method for printing a tag in toplevel . xml", "partition": "test"}
{"idx": "5316", "code": "@Override public CertificateTokenValidationExtraInfo extraInfo(){\n  return extraInfo;\n}\n", "docstring": "returns the object managing the validation extra info .", "partition": "test"}
{"idx": "5317", "code": "public void addTopLevelContents(Collection<ContentElement> contents){\n  topLevelContents.addAll(contents);\n}\n", "docstring": "add top level contents to the document .", "partition": "test"}
{"idx": "5318", "code": "public static void withInstance(Map<String,Object> args,Closure c) throws SQLException, ClassNotFoundException {\n  Sql sql=null;\n  try {\n    sql=newInstance(args);\n    c.call(sql);\n  }\n  finally {\n    if (sql != null)     sql.close();\n  }\n}\n", "docstring": "invokes a closure passing it a new sql instance created from the given map of arguments . the created connection will be closed if required .", "partition": "test"}
{"idx": "5319", "code": "public void write(byte[] buffer,int offset,int length,boolean isEnd) throws IOException {\n  throw new UnsupportedOperationException(String.valueOf(this));\n}\n", "docstring": "writes a buffer to the underlying stream .", "partition": "test"}
{"idx": "5320", "code": "private boolean addIndexEntry(ServiceType resourceType,String resourceName,String policyName) throws PolicyException {\n  ResourceIndex resourceIndex=(ResourceIndex)resourceIndices.get(resourceType.getName());\n  if (resourceIndex == null) {\n    resourceIndex=refreshResourceIndexFromDataStore(resourceType);\n  }\n  return resourceIndex.addIndexEntry(resourceName,policyName);\n}\n", "docstring": "adds a new index entry or updates an existing index entry", "partition": "test"}
{"idx": "5321", "code": "public void ddSolve(Set<Node> qryNodes){\n  long solve_time=0, prepare_time=0;\n  if (hasExecuted == false)   solve();\n  if (ddPrepared == false || offlineProcessor == null) {\n    offlineProcessor=new OfflineProcessor(this);\n    IFigureManager.cleanCache();\n    ddPrepared=true;\n    ps.println();\n    ps.println(\"==> Entering demand-driven mode (experimental).\");\n  }\n  int init_size=qryNodes.size();\n  if (init_size == 0) {\n    ps.println(\"Please provide at least one pointer.\");\n    return;\n  }\n  Date prepare_begin=new Date();\n  offlineProcessor.init();\n  offlineProcessor.addUserDefPts(qryNodes);\n  offlineProcessor.runOptimizations();\n  Date prepare_end=new Date();\n  prepare_time+=prepare_end.getTime() - prepare_begin.getTime();\n  Date begin=new Date();\n  prepareNextRun();\n  nodeGenerator.initFlowGraph(this);\n  solveConstraints();\n  Date end=new Date();\n  solve_time+=end.getTime() - begin.getTime();\n  ps.println();\n  ps.printf(\"[ddGeom] Preprocessing time: %.2f seconds\\n\",(double)prepare_time / 1000);\n  ps.printf(\"[ddGeom] Main propagation time: %.2f seconds\\n\",(double)solve_time / 1000);\n}\n", "docstring": "the demand - driven mode for precisely computing points - to information for given pointers . call graph will not be updated in this mode .", "partition": "test"}
{"idx": "5322", "code": "private static void deleteFrom(int deleteAt,int[] starts,int numStarts){\n  while (starts[--numStarts] > deleteAt) {\n    starts[numStarts]-=1;\n  }\n}\n", "docstring": "adjust indices in starts to reflect a deletion after deleteat . any index in starts greater than deleteat will be increased by 1 . it is the caller \"'\" s responsibility to make sure that no 0 - length runs result .", "partition": "test"}
{"idx": "5323", "code": "public static EventTypeMetadata createBeanType(String name,Class clazz,boolean isPreConfiguredStatic,boolean isPreConfigured,boolean isConfigured,TypeClass typeClass){\n  Set<String> secondaryNames=null;\n  if (name == null) {\n    name=clazz.getName();\n  }\n else {\n    if (!name.equals(clazz.getName())) {\n      secondaryNames=new LinkedHashSet<String>();\n      secondaryNames.add(clazz.getName());\n    }\n  }\n  return new EventTypeMetadata(name,secondaryNames,typeClass,isPreConfiguredStatic,isPreConfigured,isConfigured,ApplicationType.CLASS,false);\n}\n", "docstring": "factory for a bean type .", "partition": "test"}
{"idx": "5324", "code": "private boolean reverseIt(){\n  if (!isActive())   throw new IllegalStateException(\"Allocation already reversed (not active)\");\n  MPeriod.testPeriodOpen(getCtx(),getDateTrx(),MPeriodControl.DOCBASETYPE_PaymentAllocation,getAD_Org_ID());\n  setIsActive(false);\n  if (!isPosted())   setPosted(true);\n  setDocumentNo(getDocumentNo() + \"^\");\n  setDocStatus(DOCSTATUS_Reversed);\n  if (!save() || isActive())   throw new IllegalStateException(\"Cannot de-activate allocation\");\n  MFactAcct.deleteEx(MAllocationHdr.Table_ID,getC_AllocationHdr_ID(),get_TrxName());\n  getLines(true);\n  HashSet<Integer> bps=new HashSet<Integer>();\n  for (int i=0; i < m_lines.length; i++) {\n    MAllocationLine line=m_lines[i];\n    line.setIsActive(false);\n    line.saveEx();\n    bps.add(new Integer(line.processIt(true)));\n  }\n  updateBP(bps);\n  return true;\n}\n", "docstring": "reverse allocation . period needs to be open", "partition": "test"}
{"idx": "5325", "code": "public static boolean useSubjectCredsOnly(GSSCaller caller){\n  if (caller instanceof HttpCaller) {\n    return false;\n  }\n  String propValue=AccessController.doPrivileged(new GetPropertyAction(\"javax.security.auth.useSubjectCredsOnly\",\"true\"));\n  return (!propValue.equalsIgnoreCase(\"false\"));\n}\n", "docstring": "determines if the application doesn \"'\" t mind if the mechanism obtains the required credentials from outside of the current subject . our kerberos v5 mechanism would do a jaas login on behalf of the application if this were the case . the application indicates this by explicitly setting the system property javax . security . auth . usesubjectcredsonly to false .", "partition": "test"}
{"idx": "5326", "code": "public void deleteStorage(StorageData storageData) throws BusinessException, IOException {\n  StorageData local=getLocalStorageDataObject(storageData);\nsynchronized (local) {\n    if ((storageRecorder.isRecordingOn() || storageRecorder.isRecordingScheduled()) && Objects.equals(local,recorderStorageData)) {\n      throw new BusinessException(\"Delete the storage \" + local + \".\",StorageErrorCodeEnum.STORAGE_ALREADY_CLOSED);\n    }\n    if (local.isStorageOpened()) {\n      StorageWriter writer=openedStoragesMap.get(local);\n      if (writer != null) {\n        writer.cancel();\n      }\n      openedStoragesMap.remove(local);\n    }\n    deleteCompleteStorageDataFromDisk(local);\n    existingStoragesSet.remove(local);\n  }\n}\n", "docstring": "deletes a storage information and files from disk .", "partition": "test"}
{"idx": "5327", "code": "public CoapResponse advanced(Request request){\n  assignClientUriIfEmpty(request);\n  return synchronous(request);\n}\n", "docstring": "sends an advanced synchronous request that has to be configured by the developer .", "partition": "test"}
{"idx": "5328", "code": "public void visitErrorNode(ErrorNode node){\n  ProgressIndicatorProvider.checkCanceled();\n  Token badToken=node.getSymbol();\n  boolean isConjuredToken=badToken.getTokenIndex() < 0;\n  int nodeStartIndex=badToken.getStartIndex();\n  SyntaxError error=tokenToErrorMap.get(nodeStartIndex);\n  if (error != null) {\n    PsiBuilder.Marker errorMarker=builder.mark();\n    if (badToken.getStartIndex() >= 0 && badToken.getType() != Token.EOF && !isConjuredToken) {\n      builder.advanceLexer();\n    }\n    String message=String.format(\"%s%n\",error.getMessage());\n    errorMarker.error(message);\n  }\n else {\n    if (isConjuredToken) {\n      PsiBuilder.Marker errorMarker=builder.mark();\n      errorMarker.error(badToken.getText());\n    }\n else {\n      builder.advanceLexer();\n    }\n  }\n}\n", "docstring": "summary . for any syntax error thrown by the parser , there will be an errornode in the parse tree and this method will process it . all errors correspond to actual tokens in the input except for missing token errors . there are there are multiple error situations to consider : 1 . extraneous token . the parse tree will have an errornode for token . 2 . token mismatch . the parse tree will have an errornode for token . 3 . missing token . the parse tree will have an errornode but it does not correspond to any bit of the input . we underline the current token . 4 . noviablealt ( input inconsistent with any rule alt ) . the parse tree will have an errornode for token . 5 . tokens consumed to resync the parser during recovery . the parse tree will have an errornode for each token . this is complicated by errors that occur at eof but i have modified error strategy to add error nodes for eof if needed . another complication . during prediction , we might match n tokens and then fail on the n + 1 token , leading to noviablealtexception . but , it \"'\" s offending token is at n + 1 not current token where prediction started ( which we use to find syntax errors ) . so , syntaxerror objects return start not offending token in this case .", "partition": "test"}
{"idx": "5329", "code": "@Override public boolean conditionOk(Example example){\n  boolean isOk=true;\n  for (  Attribute attribute : checkedAttributes) {\n    isOk&=!Double.isNaN(example.getValue(attribute));\n  }\n  return isOk;\n}\n", "docstring": "returns true if the example does not contain missing values within regarded attributes .", "partition": "test"}
{"idx": "5330", "code": "private void loadBinary(InputStream is) throws IOException {\n  if (useNewIO && is instanceof FileInputStream) {\n    FileInputStream fis=(FileInputStream)is;\n    if (useIndexing) {\n      loadBinaryIndex(new URL(indexName));\n      mapDatabase(fis);\n    }\n else {\n      loadMappedBinary(fis);\n    }\n  }\n else {\n    DataInputStream dis=new DataInputStream(new BufferedInputStream(is));\n    loadBinary(dis);\n  }\n}\n", "docstring": "loads a binary file from the input stream . < p / > note that we currently have four ! methods of loading up the database . we were interested in the performance characteristics of the various methods of loading the database so we coded it all up .", "partition": "test"}
{"idx": "5331", "code": "public VNXeCommandJob deleteLunsFromLunGroup(String lunGroupId,List<String> luns){\n  LunGroupModifyParam param=new LunGroupModifyParam();\n  List<LunAddParam> lunDelete=new ArrayList<LunAddParam>();\n  for (  String lunId : luns) {\n    VNXeBase lun=new VNXeBase(lunId);\n    LunAddParam lunAdd=new LunAddParam();\n    lunAdd.setLun(lun);\n    lunDelete.add(lunAdd);\n  }\n  param.setLunDelete(lunDelete);\n  LunGroupRequests req=new LunGroupRequests(_khClient);\n  return req.modifyLunGroupAsync(lunGroupId,param);\n}\n", "docstring": "delete luns from lun group", "partition": "test"}
{"idx": "5332", "code": "public void removeLocators(LookupLocator[] locators){\n  testSetForNull(locators);\nsynchronized (this) {\n    if (terminated) {\n      throw new IllegalStateException(\"discovery terminated\");\n    }\n    HashMap groupsMap=new HashMap(1);\n    for (int i=0; i < locators.length; i++) {\n      LocatorReg reg=removeDiscoveredLocator(locators[i]);\n      if (reg != null) {\n        groupsMap.put(reg.proxy,reg.memberGroups);\n        continue;\n      }\n      reg=findReg(locators[i]);\n      if (reg != null) {\n        undiscoveredLocators.remove(reg);\n      }\n    }\n    if (!groupsMap.isEmpty() && !listeners.isEmpty()) {\n      addNotify((ArrayList)listeners.clone(),groupsMap,true);\n    }\n  }\n}\n", "docstring": "deletes a set of locators from the managed set of locators , and discards any already - discovered lookup service that corresponds to a deleted locator . for any lookup service that is discarded as a result of an invocation of this method , a discard notification is sent ; and that lookup service will not be eligible for re - discovery ( assuming it is not currently eligible for discovery through other means , such as group discovery ) . < p / > if the empty array is input , this method takes no action .", "partition": "test"}
{"idx": "5333", "code": "public boolean is_selected(ItemSelectionChoice p_choice){\n  return sel_array[p_choice.ordinal()];\n}\n", "docstring": "looks , if the input item type is selected .", "partition": "test"}
{"idx": "5334", "code": "private void add(final IProgressOperation operation){\n  final GridBagConstraints constraints=new GridBagConstraints();\n  constraints.fill=GridBagConstraints.HORIZONTAL;\n  constraints.gridy=counter++;\n  constraints.gridx=0;\n  constraints.weightx=1;\n  constraints.weighty=1;\n  m_progressPanel.add(operation.getProgressPanel(),constraints);\n}\n", "docstring": "updates the dialog with a new operation .", "partition": "test"}
{"idx": "5335", "code": "public KeyStoreBuilder withProvider(final String providerName){\n  Provider provider=Security.getProvider(providerName);\n  if (provider == null) {\n    throw new IllegalArgumentException(\"No such provider: \" + providerName);\n  }\n  return withProvider(provider);\n}\n", "docstring": "specifies the security provider to use for the keystore .", "partition": "test"}
{"idx": "5336", "code": "public static HttpURLConnection toHttpConnection(Request... requests){\n  return toHttpConnection(Arrays.asList(requests));\n}\n", "docstring": "serializes one or more requests but does not execute them . the resulting httpurlconnection can be executed explicitly by the caller .", "partition": "test"}
{"idx": "5337", "code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 198) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "docstring": "unpacks the compressed character translation table .", "partition": "test"}
{"idx": "5338", "code": "public CompositeRouteFinder(final GameMap map,final HashMap<Match<Territory>,Integer> matches){\n  m_map=map;\n  m_matches=matches;\n  s_logger.finer(\"Initializing CompositeRouteFinderClass...\");\n}\n", "docstring": "this class can find composite routes between two territories . example set of matches : [ friendly land , score : 1 ", "partition": "test"}
{"idx": "5339", "code": "public TCPEndpoint(String host,int port){\n  this(host,port,null,null);\n}\n", "docstring": "create an endpoint for a specified host and port . this should not be used by external classes to create endpoints for servers in this vm ; use getlocalendpoint instead .", "partition": "test"}
{"idx": "5340", "code": "public void testBug22613() throws Exception {\n  createTable(\"bug22613\",\"( s set(\'a\',\'bc\',\'def\',\'ghij\') default NULL, t enum(\'a\', \'ab\', \'cdef\'), s2 SET(\'1\',\'2\',\'3\',\'4\',\'1585\',\'ONE\',\'TWO\',\'Y\',\'N\',\'THREE\'))\");\n  checkMetadataForBug22613(this.conn);\n  if (versionMeetsMinimum(5,0)) {\n    Connection infoSchemConn=null;\n    try {\n      Properties props=new Properties();\n      props.setProperty(\"useInformationSchema\",\"true\");\n      infoSchemConn=getConnectionWithProps(props);\n      checkMetadataForBug22613(infoSchemConn);\n    }\n  finally {\n      if (infoSchemConn != null) {\n        infoSchemConn.close();\n      }\n    }\n  }\n}\n", "docstring": "tests fix for bug # 22613 - dbmd . getcolumns ( ) does not return expected column_size for the set type ( fixed to be consistent with the odbc driver )", "partition": "test"}
{"idx": "5341", "code": "public ProgramRewriter(ArrayList<HopRewriteRule> hRewrites,ArrayList<StatementBlockRewriteRule> sbRewrites){\n  _dagRuleSet=new ArrayList<HopRewriteRule>();\n  _dagRuleSet.addAll(hRewrites);\n  _sbRuleSet=new ArrayList<StatementBlockRewriteRule>();\n  _sbRuleSet.addAll(sbRewrites);\n}\n", "docstring": "construct a program rewriter for the given rewrite sets which are passed from outside .", "partition": "test"}
{"idx": "5342", "code": "private JMenu createSettingsMenu(){\n  final JMenu menu=new JMenu(\"Settings\");\n  menu.setMnemonic(\'S\');\n  menu.add(new CActionShowSettingsDialog(getParent()));\n  menu.add(new JSeparator());\n  menu.add(new CActionInitialCallgraphSettings(getParent()));\n  menu.add(new CActionInitialFlowgraphSettings(getParent()));\n  return menu;\n}\n", "docstring": "creates the settings menu .", "partition": "test"}
{"idx": "5343", "code": "public static void writeString(DataOutputStream os,String s) throws IOException {\n  if (s == null) {\n    os.writeInt(-1);\n  }\n else {\n    byte array[]=s.getBytes();\n    os.writeInt(array.length);\n    os.write(array);\n  }\n}\n", "docstring": "write string to dataoutputstream motivation : datainputstream . readutf can \"'\" t print lines larger than ushortmax", "partition": "test"}
{"idx": "5344", "code": "public static boolean isJavaValidName(String str){\n  if (str.isEmpty())   return false;\n  if (javaKeys.contains(str))   return false;\n  char first=str.charAt(0);\n  if (isValidNameStartChar(first)) {\n    for (int i=1; i < str.length(); ++i) {\n      char c=str.charAt(i);\n      if (!isValidNameChar(c))       return false;\n    }\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "check whether the given string can be a valid java name", "partition": "test"}
{"idx": "5345", "code": "private List<String> createCommands(){\n  List<String> commands=createNodeCommands(nodejsFile,tsFile);\n  List<String> args=createNodeArgs();\n  if (args != null) {\n    commands.addAll(args);\n  }\n  return commands;\n}\n", "docstring": "create process commands to start tern with node . js", "partition": "test"}
{"idx": "5346", "code": "private void parsePackages(SensorContext sensorContext){\n  for (  Directory directory : packageList) {\n    sensorContext.saveMeasure(directory,CoreMetrics.DIRECTORIES,1.0);\n    sensorContext.saveMeasure(directory,CoreMetrics.FILES,(double)filesCount.get(directory));\n  }\n}\n", "docstring": "count the metrics for packages", "partition": "test"}
{"idx": "5347", "code": "public static Thread consumeProcessErrorStream(Process self,Appendable error){\n  Thread thread=new Thread(new TextDumper(self.getErrorStream(),error));\n  thread.start();\n  return thread;\n}\n", "docstring": "gets the error stream from a process and reads it to keep the process from blocking due to a full buffer . the processed stream data is appended to the supplied appendable . a new thread is started , so this method will return immediately .", "partition": "test"}
{"idx": "5348", "code": "public StrBuilder deleteFirst(final String str){\n  final int len=(str == null ? 0 : str.length());\n  if (len > 0) {\n    final int index=indexOf(str,0);\n    if (index >= 0) {\n      deleteImpl(index,index + len,len);\n    }\n  }\n  return this;\n}\n", "docstring": "deletes the string wherever it occurs in the builder .", "partition": "test"}
{"idx": "5349", "code": "@Reference(authors=\"D. Pelleg, A. Moore\",booktitle=\"X-means: Extending K-means with Efficient Estimation on the Number of Clusters\",title=\"Proceedings of the 17th International Conference on Machine Learning (ICML 2000)\",url=\"http://www.pelleg.org/shared/hp/download/xmeans.ps\") public static <V extends NumberVector>double logLikelihood(Relation<V> relation,Clustering<? extends MeanModel> clustering,NumberVectorDistanceFunction<? super V> distanceFunction){\n  List<? extends Cluster<? extends MeanModel>> clusters=clustering.getAllClusters();\n  final int dim=RelationUtil.dimensionality(relation);\n  final int m=clusters.size();\n  int n=0;\n  int[] n_i=new int[m];\n  double d=0.;\n  double[] d_i=new double[m];\n  Iterator<? extends Cluster<? extends MeanModel>> it=clusters.iterator();\n  for (int i=0; it.hasNext(); ++i) {\n    Cluster<? extends MeanModel> cluster=it.next();\n    n+=n_i[i]=cluster.size();\n    d+=d_i[i]=varianceOfCluster(cluster,distanceFunction,relation);\n  }\n  if (n <= m) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  final double v=d / (n - m), logv=Math.log(v);\n  double logLikelihood=0.;\n  for (int i=0; i < m; i++) {\n    logLikelihood+=n_i[i] * Math.log(n_i[i]) - n_i[i] * .5 * MathUtil.LOGTWOPI - n_i[i] * dim * .5* logv - (d_i[i] - m) * .5;\n  }\n  logLikelihood-=n * Math.log(n);\n  return logLikelihood;\n}\n", "docstring": "computes log likelihood of an entire clustering . version as used in the x - means publication .", "partition": "test"}
{"idx": "5350", "code": "private static Class<?>[] classesForParams(List<String> params){\n  Class<?>[] result=new Class<?>[params.size()];\n  for (int i=0; i < params.size(); i++) {\n    result[i]=classForParam(params.get(i));\n  }\n  return result;\n}\n", "docstring": "turn an array of strings ( class names ) into an array of class objects", "partition": "test"}
{"idx": "5351", "code": "final public void trimToSize(){\n  for (  GazEntry ge : gaz.values()) {\n    ge.trimToSize();\n  }\n}\n", "docstring": "trim off excess size dead space .", "partition": "test"}
{"idx": "5352", "code": "public boolean containsSelectAccount(){\n  return prompts.contains(PROMPT_SELECT_ACCOUNT);\n}\n", "docstring": "determines if the prompt contains \"'\" select_account \"'\" .", "partition": "test"}
{"idx": "5353", "code": "protected static void quickSort(Instances insts,int[] indices,int attidx,int left,int right){\n  if (left < right) {\n    int middle=partition(insts,indices,attidx,left,right);\n    quickSort(insts,indices,attidx,left,middle);\n    quickSort(insts,indices,attidx,middle + 1,right);\n  }\n}\n", "docstring": "sorts the instances according to the given attribute / dimension . the sorting is done on the master index array and not on the actual instances object .", "partition": "test"}
{"idx": "5354", "code": "public Image flipImageHorizontally(Image image,boolean maintainOpacity){\n  int[] rgb=image.getRGB();\n  int[] newRGB=new int[rgb.length];\n  int width=image.getWidth();\n  int height=image.getHeight();\n  for (int y=0; y < height; y++) {\n    for (int x=0; x < width; x++) {\n      newRGB[(width - x - 1) + y * width]=rgb[x + y * width];\n    }\n  }\n  return EncodedImage.createFromRGB(newRGB,width,height,!maintainOpacity);\n}\n", "docstring": "flips the given image on the horizontal axis", "partition": "test"}
{"idx": "5355", "code": "public static boolean isTermsRequest(SipRequest request){\n  String contentType=request.getContentType();\n  return (contentType != null && contentType.startsWith(\"application/end-user\"));\n}\n", "docstring": "is a terms & conditions request", "partition": "test"}
{"idx": "5356", "code": "private void readSegments() throws IOException {\n  for (  SegmentExtent10 extent : _segmentExtents) {\n    try (ReadStream is=openRead(extent.address(),extent.length())){\n      is.skip(extent.length() - BLOCK_SIZE);\n      long sequence=BitsUtil.readLong(is);\n      byte[] tableKey=new byte[TABLE_KEY_SIZE];\n      is.readAll(tableKey,0,tableKey.length);\n      if (sequence > 0) {\n        Segment10 segment=new Segment10(sequence,tableKey,extent);\n        _segments.add(segment);\n      }\n    }\n   }\n}\n", "docstring": "reads the segment metadata , the sequence and table key .", "partition": "test"}
{"idx": "5357", "code": "public static double projectTimeWithin24Hours(double time){\n  double secondsInOneDay=60 * 60 * 24;\n  if (time == Double.NEGATIVE_INFINITY || time == Double.POSITIVE_INFINITY) {\n    DebugLib.stopSystemAndReportInconsistency(\"time is not allowed to be minus or plus infinity\");\n  }\n  while (time < 0) {\n    time+=secondsInOneDay;\n  }\n  if (time < secondsInOneDay) {\n    return time;\n  }\n else {\n    return ((time / secondsInOneDay) - (Math.floor(time / secondsInOneDay))) * secondsInOneDay;\n  }\n}\n", "docstring": "if time is > 60 * 60 * 24 [ seconds ", "partition": "test"}
{"idx": "5358", "code": "@SuppressWarnings(\"unchecked\") public static void checkType(Map<String,Object> map,String name){\n  Map<String,Object> tmap;\n  if (map.get(MetamodelGenerator.KEY_TYPE) instanceof Map) {\n    tmap=(Map<String,Object>)map.get(MetamodelGenerator.KEY_TYPE);\n  }\n else   if (map.get(MetamodelGenerator.KEY_TYPE) instanceof String) {\n    tmap=new HashMap<String,Object>();\n    tmap.put(MetamodelGenerator.KEY_NAME,map.get(MetamodelGenerator.KEY_TYPE));\n  }\n else {\n    tmap=map;\n  }\n  int join=name.indexOf(\'&\');\n  if (join > 0) {\n    while (join > 0 && !pointyBracketsEven(name.substring(0,join))) {\n      join=name.indexOf(\'&\',join + 1);\n    }\n    if (join > 0) {\n      Assert.assertEquals(\"not an intersection type\",\"i\",tmap.get(\"comp\"));\n      checkTypeParameters(-1,(List<Map<String,Object>>)tmap.get(MetamodelGenerator.KEY_TYPES),name.substring(0,join));\n      checkTypeParameters(-1,(List<Map<String,Object>>)tmap.get(MetamodelGenerator.KEY_TYPES),name.substring(join + 1));\n      return;\n    }\n  }\n  join=name.indexOf(\'|\');\n  if (join > 0) {\n    while (join > 0 && !pointyBracketsEven(name.substring(0,join))) {\n      join=name.indexOf(\'|\',join + 1);\n    }\n    if (join > 0) {\n      Assert.assertEquals(\"not a union type\",\"u\",tmap.get(\"comp\"));\n      checkTypeParameters(-1,(List<Map<String,Object>>)tmap.get(MetamodelGenerator.KEY_TYPES),name.substring(0,join));\n      checkTypeParameters(-1,(List<Map<String,Object>>)tmap.get(MetamodelGenerator.KEY_TYPES),name.substring(join + 1));\n      return;\n    }\n  }\n  int sep=name.indexOf(\'<\');\n  String typeParams=null;\n  if (sep > 0) {\n    typeParams=name.substring(sep + 1,name.length() - 1);\n    name=name.substring(0,sep);\n  }\n  if (tmap.containsKey(MetamodelGenerator.KEY_PACKAGE)) {\n    Assert.assertEquals(name,String.format(\"%s::%s\",packageName(tmap),tmap.get(MetamodelGenerator.KEY_NAME)));\n  }\n else {\n    Assert.assertEquals(name,tmap.get(MetamodelGenerator.KEY_NAME));\n  }\n  if (typeParams != null) {\n    List<Map<String,Object>> tparms=(List<Map<String,Object>>)tmap.get(MetamodelGenerator.KEY_TYPE_PARAMS);\n    Assert.assertFalse(\"Type parameters shouldn\'t be empty\",tparms.isEmpty());\n    checkTypeParameters(0,tparms,typeParams);\n  }\n}\n", "docstring": "check that the map either contains the specified type or is the specified type . the type name can be parameterized , i . e . sequence & lt ; string & gt ; ( but with fully qualified names ) ; when it \"'\" s parameterized , the type parameters are checked as well .", "partition": "test"}
{"idx": "5359", "code": "private Object _deserializeStruct(Element elStruct) throws ConverterException {\n  String type=elStruct.getAttribute(\"type\");\n  Struct struct=new StructImpl();\n  NodeList list=elStruct.getChildNodes();\n  int len=list.getLength();\n  for (int i=0; i < len; i++) {\n    Node node=list.item(i);\n    if (node instanceof Element) {\n      Element var=(Element)node;\n      Element value=getChildElement((Element)node);\n      if (value != null) {\n        struct.setEL(var.getAttribute(\"name\"),_deserialize(value));\n      }\n    }\n  }\n  if (struct.size() == 0 && type != null && type.length() > 0) {\n    return \"\";\n  }\n  return struct;\n}\n", "docstring": "desirialize a struct object", "partition": "test"}
{"idx": "5360", "code": "public QuerierCLI(String[] args){\n  cliOptions=createOptions();\n  try {\n    CommandLineParser parser=new GnuParser();\n    commandLine=parser.parse(cliOptions,args,true);\n    if (hasOption(\"h\")) {\n      printHelp();\n      System.exit(1);\n    }\n    if (!parseOptions()) {\n      logger.info(\"The provided options are not valid\");\n      printHelp();\n      System.exit(1);\n    }\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    System.exit(1);\n  }\n}\n", "docstring": "create and parse allowable options", "partition": "test"}
{"idx": "5361", "code": "private static byte[] concatBytes(byte[] array1,byte[] array2){\n  byte[] cBytes=new byte[array1.length + array2.length];\n  try {\n    System.arraycopy(array1,0,cBytes,0,array1.length);\n    System.arraycopy(array2,0,cBytes,array1.length,array2.length);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n  return cBytes;\n}\n", "docstring": "this method concatenates two byte arrays", "partition": "test"}
{"idx": "5362", "code": "void writeValueProperties(String fullId,long dbId,String localId,JsonValue value,Connection connection) throws SQLException {\n  if (cfg.hasPossibleSearchableProperties()) {\n    Integer batchingCount=0;\n    PreparedStatement propCreateStatement=getPreparedStatement(connection,QueryDefinition.PROPCREATEQUERYSTR);\n    try {\n      batchingCount=writeValueProperties(fullId,dbId,localId,value,connection,propCreateStatement,batchingCount);\n      if (enableBatching && batchingCount > 0) {\n        int[] numUpdates=propCreateStatement.executeBatch();\n        logger.debug(\"Batch update of objectproperties updated: {}\",numUpdates);\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Writing batch of objectproperties, updated: {}\",Arrays.asList(numUpdates));\n        }\n        propCreateStatement.clearBatch();\n      }\n    }\n  finally {\n      CleanupHelper.loggedClose(propCreateStatement);\n    }\n  }\n}\n", "docstring": "writes all properties of a given resource to the properties table and links them to the main table record .", "partition": "test"}
{"idx": "5363", "code": "protected double computeMaxYAxisValueLogScale(double maxValue){\n  double v=0;\n  int mantisse=0;\n  int exponent=0;\n  while (v < maxValue) {\n    if (mantisse < 9)     mantisse++;\n else {\n      mantisse=1;\n      exponent++;\n    }\n    v=mantisse * Math.pow(10,exponent);\n  }\n  return Math.log10(v);\n}\n", "docstring": "compute the maximum value on a log scale", "partition": "test"}
{"idx": "5364", "code": "public void addFocusClearedListener(FocusClearedListener focusClearedListener){\n  mFocusClearedListeners.add(focusClearedListener);\n}\n", "docstring": "register a listener to be notified when focus is cleared", "partition": "test"}
{"idx": "5365", "code": "public void addItemListener(ItemListener aListener){\n  listenerList.add(ItemListener.class,aListener);\n}\n", "docstring": "add a listener for mode changes", "partition": "test"}
{"idx": "5366", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result;\n  result=new Vector<Option>();\n  result.addElement(new Option(\"\\tThe range of attributes to print in addition to the classification.\\n\" + \"\\t(default: none)\",\"p\",1,\"-p <range>\"));\n  result.addElement(new Option(\"\\tWhether to turn on the output of the class distribution.\\n\" + \"\\tOnly for nominal class attributes.\\n\" + \"\\t(default: off)\",\"distribution\",0,\"-distribution\"));\n  result.addElement(new Option(\"\\tThe number of digits after the decimal point.\\n\" + \"\\t(default: \" + getDefaultNumDecimals() + \")\",\"decimals\",1,\"-decimals <num>\"));\n  result.addElement(new Option(\"\\tThe file to store the output in, instead of outputting it on stdout.\\n\" + \"\\tGets ignored if the supplied path is a directory.\\n\" + \"\\t(default: .)\",\"file\",1,\"-file <path>\"));\n  result.addElement(new Option(\"\\tIn case the data gets stored in a file, then this flag can be used\\n\" + \"\\tto suppress the regular output.\\n\" + \"\\t(default: not suppressed)\",\"suppress\",0,\"-suppress\"));\n  return result.elements();\n}\n", "docstring": "returns an enumeration of all the available options . .", "partition": "test"}
{"idx": "5367", "code": "public static MosaicLevy createMosaicLevy(final MosaicId mosaicId){\n  return new MosaicLevy(MosaicTransferFeeType.Absolute,generateRandomAccount(),mosaicId,Quantity.fromValue(123));\n}\n", "docstring": "creates a xem mosaic levy .", "partition": "test"}
{"idx": "5368", "code": "public int rankOf(double value){\n  int ret=0;\n  if (!hasCapacity()) {\n    ret=Arrays.binarySearch(data,value);\n    if (ret < 0) {\n      return -ret - 1;\n    }\n else {\n      return ret;\n    }\n  }\n else {\n    for (int i=0; i < next; i++) {\n      if (data[i] < value) {\n        ret++;\n      }\n    }\n    return ret;\n  }\n}\n", "docstring": "returns the ordinal rank of value among the sampled values in this buffer .", "partition": "test"}
{"idx": "5369", "code": "public static <T>Predicate<T> not(Predicate<T> predicate){\n  return predicate.negate();\n}\n", "docstring": "negate the given predicate .", "partition": "test"}
{"idx": "5370", "code": "private static void addMarginTopToContentChild(View mContentChild,int statusBarHeight){\n  if (mContentChild == null) {\n    return;\n  }\n  if (!TAG_MARGIN_ADDED.equals(mContentChild.getTag())) {\n    FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mContentChild.getLayoutParams();\n    lp.topMargin+=statusBarHeight;\n    mContentChild.setLayoutParams(lp);\n    mContentChild.setTag(TAG_MARGIN_ADDED);\n  }\n}\n", "docstring": "add margintop to simulate set fitssystemwindow true", "partition": "test"}
{"idx": "5371", "code": "static byte[] hexStringToByteArray(String hexString){\n  String s=hexString;\n  int len=s.length();\n  if (len % 2 == 1) {\n    s=\"0\" + s;\n    len++;\n  }\n  byte[] data=new byte[len / 2];\n  for (int i=0; i < len; i+=2) {\n    data[i / 2]=(byte)((Character.digit(s.charAt(i),16) << 4) + Character.digit(s.charAt(i + 1),16));\n  }\n  return data;\n}\n", "docstring": "converts a hexadecimal string into an byte array", "partition": "test"}
{"idx": "5372", "code": "private void fetchSchema() throws ExecutionException, RpcException, TimeoutException {\n  Message schema=Rpc.get(myClient.getSchema(),FETCH_SCHEMA_TIMEOUT_MS,TimeUnit.MILLISECONDS);\n  LOG.info(\"Schema with \" + schema.entities.length + \" classes, \"+ schema.constants.length+ \" constant sets\");\n  int atoms=0;\n  for (  Entity type : schema.entities) {\n    if (AtomMetadata.find(type) != null) {\n      atoms++;\n    }\n    Dynamic.register(type);\n  }\n  LOG.info(\"Schema with \" + atoms + \" atoms\");\n  for (  ConstantSet set : schema.constants) {\n    ConstantSet.register(set);\n  }\n}\n", "docstring": "requests and blocks for the schema from the server .", "partition": "test"}
{"idx": "5373", "code": "private void append(StringBuilder buffer,double[] data,String prefix,String separator,String suffix){\n  buffer.append(prefix);\n  for (int i=0; i < data.length; ++i) {\n    if (i > 0) {\n      buffer.append(separator);\n    }\n    buffer.append(data[i]);\n  }\n  buffer.append(suffix);\n}\n", "docstring": "append a text representation of an array to a buffer .", "partition": "test"}
{"idx": "5374", "code": "public T toRealArray(){\n  return _outputArrayType.cast(ArrayMultidimensionalizer.multidimensionalize(_real,_dimensions));\n}\n", "docstring": "returns an array that holds the real values from the matlab array . each call returns a new copy which may be used in any manner ; modifications to it will have no effect on this instance .", "partition": "test"}
{"idx": "5375", "code": "private ArrayList<WritableComparable> readPartitions(FileSystem fs,Path p,JobConf job) throws IOException {\n  SequenceFile.Reader reader=new SequenceFile.Reader(fs,p,job);\n  ArrayList<WritableComparable> parts=new ArrayList<WritableComparable>();\n  try {\n    DoubleWritable key=new DoubleWritable();\n    NullWritable value=NullWritable.get();\n    while (reader.next(key,value)) {\n      parts.add(key);\n      key=new DoubleWritable();\n    }\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    IOUtilFunctions.closeSilently(reader);\n  }\n  reader.close();\n  return parts;\n}\n", "docstring": "read the cut points from the given sequence file .", "partition": "test"}
{"idx": "5376", "code": "public boolean pollSeqno(long seqno){\n  return seqno <= diskLog.getMaxSeqno();\n}\n", "docstring": "returns true if the indicated sequence number is available .", "partition": "test"}
{"idx": "5377", "code": "public String process(Item item) throws ProcessException {\n  int count=0;\n  Item inPhrase=SUB_PHRASE_PATH.findItem(item);\n  for (Item p=inPhrase; p != null; p=p.getPrevious()) {\n    count++;\n  }\n  return Integer.toString(rail(count));\n}\n", "docstring": "performs some processing on the given item .", "partition": "test"}
{"idx": "5378", "code": "public E push(E value){\n  elements.add(value);\n  return value;\n}\n", "docstring": "push to the top of the stack", "partition": "test"}
{"idx": "5379", "code": "public long cardinality(final int tailIndex){\n  return rangeCount(tailIndex);\n}\n", "docstring": "return the cardinality of a particular tail , which is the range count if not optional and infinite if optional .", "partition": "test"}
{"idx": "5380", "code": "public static void createResponse(HttpServletRequest request,HttpServletResponse response,HttpServlet servlet,Properties cookieProperties,WebDoc doc,boolean debug) throws IOException {\n  response.setHeader(\"Cache-Control\",\"no-cache\");\n  response.setContentType(\"text/html; charset=UTF-8\");\n  if (cookieProperties != null) {\n    Cookie cookie=new Cookie(WebEnv.COOKIE_INFO,propertiesEncode(cookieProperties));\n    cookie.setComment(\"(c) adempiere, Inc - Jorg Janke\");\n    cookie.setSecure(false);\n    cookie.setPath(\"/\");\n    if (cookieProperties.size() == 0)     cookie.setMaxAge(0);\n else     cookie.setMaxAge(2592000);\n    response.addCookie(cookie);\n  }\n  if (debug && WebEnv.DEBUG) {\n    WebEnv.addFooter(request,response,servlet,doc.getBody());\n  }\n  PrintWriter out=response.getWriter();\n  doc.output(out);\n  out.flush();\n  if (out.checkError())   log.log(Level.SEVERE,\"error writing\");\n  out.close();\n}\n", "docstring": "create standard response header with optional cookie and print document . d : \\ j2sdk1 . 4 . 0 \\ docs \\ guide \\ intl \\ encoding . doc . html", "partition": "test"}
{"idx": "5381", "code": "public static Long toLong(Object o) throws PageException {\n  if (o instanceof Long)   return (Long)o;\n  return Long.valueOf(toLongValue(o));\n}\n", "docstring": "cast a object to a long object ( reference type )", "partition": "test"}
{"idx": "5382", "code": "protected void finishGridRow(){\n  GridBagConstraints constraints=new GridBagConstraints();\n  constraints.gridwidth=GridBagConstraints.REMAINDER;\n  constraints.weightx=0;\n  final JLabel icon;\n  if (param.isOptional()) {\n    if (param.isDefined() && param.tookDefaultValue() && !(param instanceof Flag)) {\n      icon=new JLabel(StockIcon.getStockIcon(StockIcon.DIALOG_INFORMATION));\n      icon.setToolTipText(\"Default value: \" + param.getDefaultValueAsString());\n    }\n else {\n      icon=new JLabel();\n      icon.setMinimumSize(new Dimension(16,16));\n    }\n  }\n else {\n    if (!param.isDefined()) {\n      icon=new JLabel(StockIcon.getStockIcon(StockIcon.DIALOG_ERROR));\n      icon.setToolTipText(\"Missing value.\");\n    }\n else {\n      icon=new JLabel();\n      icon.setMinimumSize(new Dimension(16,16));\n    }\n  }\n  parent.add(icon,constraints);\n}\n", "docstring": "complete the current grid row , adding the icon at the end", "partition": "test"}
{"idx": "5383", "code": "@Override public void shutdown(){\n  if (!shouldKeepAdbAlive) {\n    AndroidDebugBridge.disconnectBridge();\n    AndroidDebugBridge.terminate();\n  }\n  logger.info(\"stopping Device Manager\");\n}\n", "docstring": "shutdown the androiddebugbridge and clean up all connected devices .", "partition": "test"}
{"idx": "5384", "code": "public void pingReceived(Ping pong){\n  long now=System.currentTimeMillis();\n  long previousReceived=(int)(lastPingSent.get() & 0xffffffff);\n  log.debug(\"Pong from client id {} at {} with value {}, previous received at {}\",new Object[]{getId(),now,pong.getValue2(),previousReceived});\n  if (pong.getValue2() == previousReceived) {\n    lastPingTime.set((int)(now & 0xffffffff) - pong.getValue2());\n  }\n  lastPongReceived.set(now);\n}\n", "docstring": "marks that ping back was received .", "partition": "test"}
{"idx": "5385", "code": "public static int findObjectLiteral(Object literal){\nsynchronized (objectLiterals) {\n    Integer result=objectLiterals.get(literal);\n    return result == null ? 0 : result.intValue();\n  }\n}\n", "docstring": "find a slot in the jtoc with this object literal in else return 0", "partition": "test"}
{"idx": "5386", "code": "@Override public void resetViewableArea(){\n  throw new RuntimeException(\"resetViewableArea called in PdfDecoderFx\");\n}\n", "docstring": "not part of api turns off the viewable area , scaling the page back to original scaling", "partition": "test"}
{"idx": "5387", "code": "public static Lexicon buildWumpusLex(){\n  Lexicon l=new Lexicon();\n  ArrayList<LexWord> list=new ArrayList<LexWord>();\n  list.add(new LexWord(\"stench\",(float)0.05));\n  list.add(new LexWord(\"breeze\",(float)0.10));\n  list.add(new LexWord(\"wumpus\",(float)0.15));\n  list.add(new LexWord(\"pits\",(float)0.05));\n  list.add(new LexWord(\"friend\",(float)0.10));\n  list.add(new LexWord(\"enemy\",(float)0.10));\n  list.add(new LexWord(\"dog\",(float)0.10));\n  list.add(new LexWord(\"superhero\",(float)0.20));\n  list.add(new LexWord(\"virus\",(float)0.15));\n  l.put(\"NOUN\",list);\n  ArrayList<LexWord> verbList=new ArrayList<LexWord>();\n  verbList.add(new LexWord(\"is\",(float)0.10));\n  verbList.add(new LexWord(\"feel\",(float)0.10));\n  verbList.add(new LexWord(\"smells\",(float)0.10));\n  verbList.add(new LexWord(\"stinks\",(float)0.05));\n  verbList.add(new LexWord(\"wants\",(float)0.20));\n  verbList.add(new LexWord(\"flies\",(float)0.10));\n  verbList.add(new LexWord(\"keeps\",(float)0.05));\n  verbList.add(new LexWord(\"leaves\",(float)0.10));\n  verbList.add(new LexWord(\"throws\",(float)0.20));\n  l.put(\"VERB\",verbList);\n  ArrayList<LexWord> adjList=new ArrayList<LexWord>();\n  adjList.add(new LexWord(\"right\",(float)0.10));\n  adjList.add(new LexWord(\"dead\",(float)0.05));\n  adjList.add(new LexWord(\"smelly\",(float)0.02));\n  adjList.add(new LexWord(\"breezy\",(float)0.02));\n  adjList.add(new LexWord(\"foul\",(float)0.10));\n  adjList.add(new LexWord(\"black\",(float)0.05));\n  adjList.add(new LexWord(\"white\",(float)0.05));\n  adjList.add(new LexWord(\"callous\",(float)0.10));\n  adjList.add(new LexWord(\"proud\",(float)0.10));\n  adjList.add(new LexWord(\"right\",(float)0.10));\n  adjList.add(new LexWord(\"gold\",(float)0.06));\n  adjList.add(new LexWord(\"normal\",(float)0.25));\n  l.put(\"ADJS\",adjList);\n  l.addLexWords(\"ADVERB\",\"here\",\"0.05\",\"ahead\",\"0.05\",\"nearby\",\"0.02\",\"quickly\",\"0.05\",\"badly\",\"0.05\",\"slowly\",\"0.08\",\"sadly\",\"0.10\",\"silently\",\"0.10\",\"easily\",\"0.10\",\"seldom\",\"0.10\",\"sometimes\",\"0.10\",\"loudly\",\"0.10\",\"cordially\",\"0.05\",\"frequently\",\"0.05\");\n  l.addLexWords(\"PRONOUN\",\"me\",\"0.10\",\"you\",\"0.03\",\"i\",\"0.10\",\"it\",\"0.10\",\"us\",\"0.07\",\"they\",\"0.20\",\"he\",\"0.20\",\"she\",\"0.20\");\n  l.addLexWords(\"RELPRO\",\"that\",\"0.40\",\"which\",\"0.15\",\"who\",\"0.20\",\"whom\",\"0.02\",\"whose\",\"0.08\",\"whabt\",\"0.15\");\n  l.addLexWords(buildNameLexicon());\n  l.addLexWords(\"ARTICLE\",\"the\",\"0.40\",\"a\",\"0.30\",\"an\",\"0.10\",\"every\",\"0.05\",\"some\",\"0.15\");\n  l.addLexWords(\"PREP\",\"to\",\"0.20\",\"in\",\"0.10\",\"on\",\"0.05\",\"near\",\"0.10\",\"after\",\"0.10\",\"among\",\"0.05\",\"around\",\"0.20\",\"against\",\"0.10\",\"across\",\"0.10\");\n  l.addLexWords(\"CONJ\",\"and\",\"0.50\",\"or\",\"0.10\",\"but\",\"0.20\",\"yet\",\"0.02\",\"since\",\"0.08\",\"unless\",\"0.10\");\n  l.addLexWords(\"DIGIT\",\"0\",\"0.20\",\"1\",\"0.20\",\"2\",\"0.20\",\"3\",\"0.20\",\"4\",\"0.20\");\n  return l;\n}\n", "docstring": "builds an expanded version of the \"'\" wumpus lexicon \"'\" found on page 891 of aima v3", "partition": "test"}
{"idx": "5388", "code": "private void testTransferRate(){\n  Assert.assertNotNull(mExpectedTransferRateOps);\n  Assert.assertNotNull(mExpectedTransferRateBps);\n  Assert.assertTrue(mExpectedTransferRateBps.intValue() > 0);\n  Assert.assertTrue(mExpectedTransferRateOps.intValue() > 0);\n}\n", "docstring": "compare transfer rate calculated to expected value .", "partition": "test"}
{"idx": "5389", "code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Node nameNode;\n  CharacterData child;\n  String childData;\n  doc=(Document)load(\"staff\",true);\n  elementList=doc.getElementsByTagName(\"address\");\n  nameNode=elementList.item(0);\n  child=(CharacterData)nameNode.getFirstChild();\n  child.replaceData(5,5,\"South\");\n  childData=child.getData();\n  assertEquals(\"characterdataReplaceDataMiddleAssert\",\"1230 South Ave. Dallas, Texas 98551\",childData);\n}\n", "docstring": "runs the test case .", "partition": "test"}
{"idx": "5390", "code": "public void add(X509TrustManager mgr){\n  if (mgr instanceof X509Extensions) {\n    managers.add((X509Extensions)mgr);\n  }\n else {\n    managers.add(new X509ExtensionsWrapper(mgr));\n  }\n}\n", "docstring": "add an x509trustmanager to the ones being governed by this composite . ideally , this implements x509extensions . if not , it will be wrapped in an x509extensionswrapper , to try to call additional methods via reflection .", "partition": "test"}
{"idx": "5391", "code": "public Iterator<TreeNode> findChildren(){\n  List<TreeNode> nodes;\n  if (children == null)   nodes=Collections.emptyList();\n else   nodes=children;\n  return nodes.iterator();\n}\n", "docstring": "return an iterator of all children of this node . if there are no children , an empty iterator is returned .", "partition": "test"}
{"idx": "5392", "code": "public static double I(double P[][],int j,int k){\n  double I=0.0;\n  double p_x=P[j][j];\n  double p_y=P[k][k];\n  double p_xy=P[j][k];\n  I+=p_xy * Math.log(p_xy / (p_x * p_y));\n  I+=(1. - p_xy) * Math.log((1. - p_xy) / ((1. - p_x) * (1. - p_y)));\n  return I;\n}\n", "docstring": "i - mutual information . < br > note binary only", "partition": "test"}
{"idx": "5393", "code": "public Result doComparisonTest(Properties properties) throws Exception {\n  final long timeout=Long.parseLong(properties.getProperty(TestOptions.TIMEOUT));\n  final int nclients=Integer.parseInt(properties.getProperty(TestOptions.NCLIENTS));\n  final int ntrials=Integer.parseInt(properties.getProperty(TestOptions.NTRIALS));\n  final int keyLen=Integer.parseInt(properties.getProperty(TestOptions.KEYLEN));\n  final int nops=Integer.parseInt(properties.getProperty(TestOptions.NOPS));\n  final double insertRate=Integer.parseInt(properties.getProperty(TestOptions.INSERT_RATE));\n  final int nindices=Integer.parseInt(properties.getProperty(TestOptions.NINDICES));\n  final boolean testCorrectness=Boolean.parseBoolean(properties.getProperty(TestOptions.TEST_CORRECTNESS));\n  Result result=doConcurrentClientTest(client,nclients,timeout,ntrials,keyLen,nops,insertRate,nindices,testCorrectness);\n  return result;\n}\n", "docstring": "setup and run a test .", "partition": "test"}
{"idx": "5394", "code": "static String valueToString(Object value,int indentFactor,int indent){\n  if (value == null || value.equals(null)) {\n    return \"null\";\n  }\n  try {\n    if (value instanceof String) {\n      return quote((String)value);\n    }\n  }\n catch (  Exception e) {\n  }\n  if (value instanceof Float || value instanceof Double || value instanceof Byte|| value instanceof Short|| value instanceof Integer|| value instanceof Long) {\n    return numberToString(value);\n  }\n  if (value instanceof Boolean) {\n    return value.toString();\n  }\n  if (value instanceof Map) {\n    return print((Map)value,indentFactor,indent);\n  }\n  if (value instanceof List) {\n    return print((List)value,indentFactor,indent);\n  }\n  return quote(value.toString());\n}\n", "docstring": "make a prettyprinted json text of an object value . < p > warning : this method assumes that the data structure is acyclical .", "partition": "test"}
{"idx": "5395", "code": "public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType){\n  Retention retention=annotationType.getAnnotation(Retention.class);\n  return retention != null && retention.value() == RetentionPolicy.RUNTIME;\n}\n", "docstring": "returns true if the given annotation is retained at runtime .", "partition": "test"}
{"idx": "5396", "code": "public void testProcessMsg5(){\n  byte[] pdu=createPDU(2);\n  int headerLen=pdu.length - (mGsmHeader.length + mUserDataHeader.length + mMessageBody.length);\n  int pduType=6;\n  int tranId=0;\n  String originalPackageName=mPackageName;\n  String originalClassName=mClassName;\n  try {\n    mClassName=\"com.android.smspush.unitTests.ReceiverActivity\";\n    IWapPushManager iwapman=getInterface();\n    iwapman.addPackage(Integer.toString(mAppIdValue),Integer.toString(mContentTypeValue),mPackageName,mClassName,WapPushManagerParams.APP_TYPE_ACTIVITY,false,false);\n    assertTrue((iwapman.processMessage(Integer.toString(mAppIdValue),Integer.toString(mContentTypeValue),createIntent(pduType,tranId)) & WapPushManagerParams.MESSAGE_HANDLED) == WapPushManagerParams.MESSAGE_HANDLED);\n    iwapman.deletePackage(Integer.toString(mAppIdValue),Integer.toString(mContentTypeValue),mPackageName,mClassName);\n  }\n catch (  RemoteException e) {\n    assertTrue(false);\n  }\n  mPackageName=originalPackageName;\n  mClassName=originalClassName;\n}\n", "docstring": "message processing test , send invalid sms data", "partition": "test"}
{"idx": "5397", "code": "public void addClassPath(String classpath){\n  char sep=CauchoUtil.getPathSeparatorChar();\n  int head=0;\n  int tail=0;\n  while (head < classpath.length()) {\n    tail=classpath.indexOf(sep,head);\n    String segment=null;\n    if (tail < 0) {\n      segment=classpath.substring(head);\n      head=classpath.length();\n    }\n else {\n      segment=classpath.substring(head,tail);\n      head=tail + 1;\n    }\n    if (segment.equals(\"\"))     continue;\n else     if (segment.endsWith(\".jar\") || segment.endsWith(\".zip\"))     addMergePath(JarPath.create(VfsOld.lookup(segment)));\n else     addMergePath(VfsOld.lookup(segment));\n  }\n}\n", "docstring": "adds the classpath for the loader as paths in the mergepath .", "partition": "test"}
{"idx": "5398", "code": "@Singleton public static synchronized void loadDirectories(String firstOption) throws InvalidConfigException {\n  if (userIdDirectories == null) {\n    userIdDirectories=new TreeMap<String,String>();\n    userIdDirectories.put(\"\",(firstOption == null) ? \"-\" : firstOption);\n    Properties properties=directoriesProperties();\n    for (    Map.Entry<Object,Object> entry : properties.entrySet()) {\n      String key=StringUtils.trim((String)entry.getKey());\n      String value=StringUtils.trim((String)entry.getValue());\n      if (key != null && value != null) {\n        userIdDirectories.put(key,value);\n      }\n else {\n        String error=DIRECTORIES_PROPFILE_PATH + \" has been been configured wrong.\";\n        LOG.error(error);\n        throw new InvalidConfigException(InvalidConfigException.TYPE.INVALID_PROPERTIES_FILE,error);\n      }\n    }\n    if ((userIdDirectories.size() - 1) == 0) {\n      String error=\"No licenses could be loaded from \" + DIRECTORIES_PROPFILE_PATH + \". Please check configuration.\";\n      LOG.error(error);\n      throw new InvalidConfigException(InvalidConfigException.TYPE.INVALID_PROPERTIES_FILE,error);\n    }\n  }\n}\n", "docstring": "load directories map used to populate select on basic metadata page", "partition": "test"}
{"idx": "5399", "code": "public static Individuum nullIndividuum(int dim){\n  short[] gene=new short[dim];\n  Arrays.fill(gene,DONT_CARE);\n  return new Individuum(0.0,gene);\n}\n", "docstring": "create a \" null \" individuum ( full space ) .", "partition": "test"}
{"idx": "5400", "code": "public List<Class<?>> findAllClasses(String uri) throws IOException, ClassNotFoundException {\n  List<Class<?>> classes=new ArrayList<>();\n  List<String> strings=findAllStrings(uri);\n  for (  String className : strings) {\n    Class<?> clazz=_classLoader.loadClass(className);\n    classes.add(clazz);\n  }\n  return classes;\n}\n", "docstring": "executes findallstrings assuming the strings are the names of a classes that should be loaded and returned . < p / > any url or class that cannot be loaded will cause an exception to be thrown .", "partition": "test"}
{"idx": "5401", "code": "public void shuffleInventory(@Nonnull IInventory inv,@Nonnull Random random){\n  final List<ItemStack> list=getInventoryList(inv);\n  Collections.shuffle(list,random);\n  for (int i=0; i < inv.getSizeInventory(); ++i) {\n    inv.setInventorySlotContents(i,list.get(i));\n  }\n}\n", "docstring": "shuffles all items in the inventory", "partition": "test"}
{"idx": "5402", "code": "@Override public String format(double value,int formatNumber){\n  if (formatNumber % 2 == 0) {\n    return format.format(value);\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "returns the formatted value . returns null if the value does not start with 1 .", "partition": "test"}
{"idx": "5403", "code": "public void runAsserts(List<Step> list,int size,Boolean needAssignee){\n  assertEquals(size,list.size());\n  for (int i=0; i < size; i++) {\n    runAsserts(list.get(i),i,needAssignee);\n  }\n}\n", "docstring": "assert a step - list with getalistofsamplesteps ( size )", "partition": "test"}
{"idx": "5404", "code": "public static boolean registerTransform(final String transformURI){\n  final boolean added=transforms.add(transformURI);\n  return added;\n}\n", "docstring": "this method allows to register a transformation .", "partition": "test"}
{"idx": "5405", "code": "public ANDCondition(Condition... conditions){\n  Reject.ifNull(conditions);\n  this.conditions=Arrays.asList(conditions);\n}\n", "docstring": "creates a new logical and condition with the provided sub - conditions .", "partition": "test"}
{"idx": "5406", "code": "private void updateControls(){\n  Spinner difficulty=(Spinner)findViewById(R.id.spinner_difficultyLevel);\n  difficulty.setSelection(GameActivity.getDifficultyIndex());\n  Button resume=(Button)findViewById(R.id.button_resumeGame);\n  resume.setEnabled(GameActivity.canResumeFromSave());\n  CheckBox neverLoseBall=(CheckBox)findViewById(R.id.checkbox_neverLoseBall);\n  neverLoseBall.setChecked(GameActivity.getNeverLoseBall());\n  CheckBox soundEffectsEnabled=(CheckBox)findViewById(R.id.checkbox_soundEffectsEnabled);\n  soundEffectsEnabled.setChecked(GameActivity.getSoundEffectsEnabled());\n  TextView highScore=(TextView)findViewById(R.id.text_highScore);\n  highScore.setText(String.valueOf(mHighScore));\n}\n", "docstring": "sets the state of the ui controls to match our internal state .", "partition": "test"}
{"idx": "5407", "code": "public static void write(OutputStream out,int c){\n  if (out == null) {\n    throw new IllegalArgumentException(\"output stream null.\");\n  }\n  try {\n    out.write(c);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e.getMessage(),e);\n  }\n}\n", "docstring": "write a ascii code to the output stream", "partition": "test"}
{"idx": "5408", "code": "public void message(LocoNetMessage m){\n  if (m.getNumDataElements() != 6) {\n    return;\n  }\n  int b1=m.getElement(0) & 0xFF;\n  int b2=m.getElement(1) & 0xFF;\n  int b3=m.getElement(2) & 0xFF;\n  int b4=m.getElement(3) & 0x07;\n  if ((b1 == 0xD7) && ((b2 == 0x12) || (b2 == 0x17) || (b2 == 0x1F)) && (b3 == 0x00)) {\n    idBox.setSelectedIndex(b4 + 1);\n  }\n}\n", "docstring": "process the incoming message , see if it is a panel response , and if so parse the loconet id . use that value to set the id box . this is the callback called by the lntrafficcontroller", "partition": "test"}
{"idx": "5409", "code": "public Void call() throws Exception {\n  byte[][] keys=new byte[nops][];\n  byte[][] vals=new byte[nops][];\n  if (r.nextDouble() <= insertRate) {\n    for (int i=0; i < nops; i++) {\n      keys[i]=nextKey();\n      vals[i]=new byte[5];\n      r.nextBytes(vals[i]);\n    }\n    lock.lock();\n    try {\n      ndx.submit(0,nops,keys,vals,BatchInsertConstructor.RETURN_NO_VALUES,null);\n      if (groundTruth != null) {\n        groundTruth.submit(0,nops,keys,vals,BatchInsertConstructor.RETURN_NO_VALUES,null);\n      }\n    }\n  finally {\n      lock.unlock();\n    }\n  }\n else {\n    for (int i=0; i < nops; i++) {\n      keys[i]=nextKey();\n    }\n    lock.lock();\n    try {\n      ndx.submit(0,nops,keys,null,BatchRemoveConstructor.RETURN_MUTATION_COUNT,null);\n      if (groundTruth != null) {\n        groundTruth.submit(0,nops,keys,null,BatchRemoveConstructor.RETURN_MUTATION_COUNT,null);\n      }\n    }\n  finally {\n      lock.unlock();\n    }\n  }\n  return null;\n}\n", "docstring": "executes a random batch operation with keys presented in sorted order . < p > note : batch operations with sorted keys have twice the performance of the corresponding operation with unsorted keys due to improved locality of the lookups performed on the index .", "partition": "test"}
{"idx": "5410", "code": "public boolean allowMultipleAdditions(String systemName){\n  return true;\n}\n", "docstring": "a method that determines if it is possible to add a range of lights in numerical order eg 11 thru 18 , primarily used to show / not show the add range box in the add light window", "partition": "test"}
{"idx": "5411", "code": "public void writeField(final String name,final int value) throws java.io.IOException {\n  writeField(name,Integer.toString(value));\n}\n", "docstring": "writes an int field value .", "partition": "test"}
{"idx": "5412", "code": "public static double lnFactorial(int x){\n  if (x < 0)   throw new IllegalArgumentException(\"Invalid input to factorial: \" + x);\n else   if (x > 32)   return lnGamma(x + 1);\n else {\n    int l=factorialsBuffer.size();\n    for (int i=l; i <= x; i++) {\n      factorialsBuffer.add(log(i) + factorialsBuffer.get(i - 1));\n    }\n    return factorialsBuffer.get(x);\n  }\n}\n", "docstring": "get the log of the factorial of a number . upto 32 , the factorial is exact . after that , the gamma function is used because the numbers can \"'\" t be represented anyway .", "partition": "test"}
{"idx": "5413", "code": "public void sync() throws IOException {\n  try {\n    latch.await();\n  }\n catch (  InterruptedException e) {\n    Thread.interrupted();\n    throw IOExceptionSupport.create(e);\n  }\n  failOnError();\n}\n", "docstring": "waits for a response to some pending operation .", "partition": "test"}
{"idx": "5414", "code": "public static void closeSilently(Closeable closeable){\n  if (closeable == null) {\n    return;\n  }\n  try {\n    closeable.close();\n  }\n catch (  RuntimeException rethrown) {\n    throw rethrown;\n  }\ncatch (  Exception ignored) {\n  }\n}\n", "docstring": "closes a specified closeable , suppressing any checked exceptions . this has no effect if the closeable is null .", "partition": "test"}
{"idx": "5415", "code": "public synchronized boolean append(final byte[] data){\n  if (data == null) {\n    if (Cfg.DEBUG) {\n      Check.log(TAG + \" (append) null data\");\n    }\n    return true;\n  }\n  FileOutputStream fout=null;\n  OutputStream out=null;\n  try {\n    fout=new FileOutputStream(file,true);\n    out=new BufferedOutputStream(fout,data.length);\n    out.write(data);\n    out.flush();\n  }\n catch (  final Exception ex) {\n    return false;\n  }\n finally {\n    if (fout != null) {\n      try {\n        fout.close();\n      }\n catch (      final IOException e) {\n        if (Cfg.EXCEPTION) {\n          Check.log(e);\n        }\n        if (Cfg.DEBUG) {\n          Check.log(TAG + \" Error: \" + e.toString());\n        }\n      }\n    }\n    if (out != null) {\n      try {\n        out.close();\n      }\n catch (      final IOException e) {\n        if (Cfg.EXCEPTION) {\n          Check.log(e);\n        }\n        if (Cfg.DEBUG) {\n          Check.log(TAG + \" Error: \" + e.toString());\n        }\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "append some data to the file .", "partition": "test"}
{"idx": "5416", "code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) private void notifyListListeners(){\n  if (!listListeners.isEmpty()) {\n    List temp=new ArrayList(sensorDataObjects.values());\n    temp.addAll(objectStorages.values());\n    for (    ListListener<?> listListener : listListeners) {\n      listListener.contentChanged(temp);\n    }\n  }\n}\n", "docstring": "notify all registered listeners that a change occurred in the lists .", "partition": "test"}
{"idx": "5417", "code": "public static InetAddress intToInetAddress(int hostAddress){\n  if (hostAddress == 0)   return null;\n  byte[] addressBytes={(byte)(0xff & hostAddress),(byte)(0xff & (hostAddress >> 8)),(byte)(0xff & (hostAddress >> 16)),(byte)(0xff & (hostAddress >> 24))};\n  try {\n    return InetAddress.getByAddress(addressBytes);\n  }\n catch (  UnknownHostException e) {\n    throw new AssertionError();\n  }\n}\n", "docstring": "convert a ipv4 address from an integer to an inetaddress .", "partition": "test"}
{"idx": "5418", "code": "private AFTPClient actionOpen() throws IOException, PageException {\n  required(\"server\",server);\n  required(\"username\",username);\n  required(\"password\",password);\n  AFTPClient client=getClient();\n  writeCfftp(client);\n  return client;\n}\n", "docstring": "opens a ftp connection", "partition": "test"}
{"idx": "5419", "code": "public V putIfAbsent(final K k,final V v){\n  final WeakReference<V> ref=newWeakRef(k,v,referenceQueue);\n  final WeakReference<V> oldRef=map.putIfAbsent(k,ref);\n  final V oldVal=oldRef == null ? null : oldRef.get();\n  if (oldRef != null && oldVal == null) {\n    if (map.replace(k,oldRef,ref)) {\n      if (queue.add(v) && DEBUG) {\n        log.debug(\"put: key=\" + k + \", val=\"+ v);\n      }\n      didUpdate(k,ref,oldRef);\n      return null;\n    }\n  }\n  if (oldVal == null) {\n    if (queue.add(v) && DEBUG) {\n      log.debug(\"put: key=\" + k + \", val=\"+ v);\n    }\n    didUpdate(k,ref,null);\n    return null;\n  }\n  return oldVal;\n}\n", "docstring": "adds the key - value mapping to the cache iff there is no entry for that key . note that a cleared reference under a key is treated in exactly the same manner as if there were no entry under the key ( the entry under the key is replaced atomically ) .", "partition": "test"}
{"idx": "5420", "code": "public void close(){\n  if (elementLayers != null) {\n    elementLayers.clear();\n    elementLayers=null;\n  }\n  inputSource=null;\n  curListener=null;\n}\n", "docstring": "closes parser and frees all resources .", "partition": "test"}
{"idx": "5421", "code": "public void start(){\n  if (monitorThread != null) {\n    if (!monitorThread.isAlive()) {\n      startMonitorThread();\n    }\n else {\n      LOG.error(\"The monitor thread is already running\");\n    }\n  }\n else {\n    startMonitorThread();\n  }\n}\n", "docstring": "starts the publishing monitor once and only once .", "partition": "test"}
{"idx": "5422", "code": "@HLEUnimplemented @HLEFunction(nid=0x41E73E95,version=271) public int sceUsbCamPollReadVideoFrameEnd(){\n  if (jpegBuffer == null || jpegBuffer.isNull()) {\n    return SceKernelErrors.ERROR_USBCAM_NO_READ_ON_VIDEO_FRAME;\n  }\n  if (currentVideoFrameCount <= lastVideoFrameCount) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceUsbCamPollReadVideoFrameEnd not frame end (%d - %d)\",currentVideoFrameCount,lastVideoFrameCount));\n    }\n    return SceKernelErrors.ERROR_USBCAM_NO_VIDEO_FRAME_AVAILABLE;\n  }\n  return writeCurrentVideoImage(jpegBuffer,jpegBufferSize);\n}\n", "docstring": "polls the status of video frame read completion .", "partition": "test"}
{"idx": "5423", "code": "public void scale(int factor){\n  if (m_icon != null) {\n    removeAll();\n    Image pic=m_icon.getImage();\n    int width=m_icon.getIconWidth();\n    int height=m_icon.getIconHeight();\n    int reduction=width / factor;\n    width-=reduction;\n    height-=reduction;\n    pic=pic.getScaledInstance(width,height,Image.SCALE_SMOOTH);\n    m_icon=new ImageIcon(pic);\n    m_visualLabel=new JLabel(m_icon);\n    add(m_visualLabel,BorderLayout.CENTER);\n    Dimension d=m_visualLabel.getPreferredSize();\n    Dimension d2=new Dimension((int)d.getWidth() + 10,(int)d.getHeight() + 10);\n    setMinimumSize(d2);\n    setPreferredSize(d2);\n    setMaximumSize(d2);\n  }\n}\n", "docstring": "reduce this beanvisual \"'\" s icon size by the given factor", "partition": "test"}
{"idx": "5424", "code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n  in.defaultReadObject();\n  try {\n    initFromName(getName());\n  }\n catch (  RuntimeException e) {\n    if (e instanceof NullPointerException || e instanceof IllegalArgumentException) {\n      InvalidObjectException ee=new InvalidObjectException(e.getMessage());\n      ee.initCause(e);\n      throw ee;\n    }\n    throw e;\n  }\n}\n", "docstring": "reconstitutes contained permissions based on the information in the target name .", "partition": "test"}
{"idx": "5425", "code": "public String toLowerCamel(){\n  return toCamel(CaseFormat.LOWER_CAMEL);\n}\n", "docstring": "returns the identifier in lower - camel format .", "partition": "test"}
{"idx": "5426", "code": "protected List<BlockObject> sortFullCopySourceList(List<BlockObject> fcSourceObjects){\n  List<BlockObject> sortedSourceObjects=new ArrayList<BlockObject>();\n  Map<String,BlockObject> fcSourcObjectsMap=new HashMap<String,BlockObject>();\n  for (  BlockObject fcSourceObject : fcSourceObjects) {\n    fcSourcObjectsMap.put(fcSourceObject.getLabel(),fcSourceObject);\n  }\n  List<String> fcSourceLabels=new ArrayList<String>(fcSourcObjectsMap.keySet());\n  Collections.sort(fcSourceLabels);\n  for (  String fcSourceLabel : fcSourceLabels) {\n    sortedSourceObjects.add(fcSourcObjectsMap.get(fcSourceLabel));\n  }\n  return sortedSourceObjects;\n}\n", "docstring": "sorts the passed list of full copy source objects based on the natural sort order of their labels . used to align the labels for the full copies with their sources . for example say you have a cg with two volumes foo - 1 and foo - 2 , and you then create a full copy of one of these volumes . because they are in a cg , a full copy is created for each volume in the cg . when we create the full copies with a name of bar , then we want the full copy for foo - 1 to be bar - 1 , and the full copy for foo - 2 to be bar - 2 . however , when you get the volumes in the cg , there is no guarantee of order . now there is no restriction that volumes in a cg are named like this , but often they are because often one would create multiple volumes in a cg in a single request . so , in this simple case , then the full copy names should align . we can always create a more sophisticated comparator for the sort routine if something more elaborate is desired .", "partition": "test"}
{"idx": "5427", "code": "public MovieSetAddAction(boolean withTitle){\n  if (withTitle) {\n    putValue(NAME,BUNDLE.getString(\"movieset.add.desc\"));\n  }\n  putValue(LARGE_ICON_KEY,IconManager.LIST_ADD);\n  putValue(SMALL_ICON,IconManager.LIST_ADD);\n  putValue(SHORT_DESCRIPTION,BUNDLE.getString(\"movieset.add.desc\"));\n}\n", "docstring": "instantiates a new adds the movie set action .", "partition": "test"}
{"idx": "5428", "code": "protected void createRegistry(int port){\n  if (rmiRegistry == null) {\n    try {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Starting RMI registry on registryPort: \" + port);\n      }\n      rmiRegistry=LocateRegistry.createRegistry(port);\n    }\n catch (    Throwable e) {\n      throw new ServerRuntimeException(\"Unable to start rmi registry on registryPort: \" + port,e);\n    }\n  }\n}\n", "docstring": "starts the rmi registry .", "partition": "test"}
{"idx": "5429", "code": "public void poll(final UdpSocketStatisticsHandler handler){\n  this.statisticsHandler=handler;\n  try {\n    fileLoader.load();\n    final ByteBuffer buffer=fileLoader.getBuffer();\n    lineParser.reset();\n    lineParser.handleToken(buffer,buffer.position(),buffer.limit());\n  }\n  finally {\n    this.statisticsHandler=null;\n  }\n  monitoredSockets.purgeEntriesOlderThan(updateCount);\n  updateCount++;\n}\n", "docstring": "read from monitored file , report any changed values for monitored socket statistics . not thread - safe , only call from a single thread .", "partition": "test"}
{"idx": "5430", "code": "void fixWhiteSpace(){\n  final int index=mOutputBuilder.length() - 1;\n  if (index >= 0) {\n    final char lastCharacter=mOutputBuilder.charAt(index);\n    if (!Character.isWhitespace(lastCharacter)) {\n      mOutputBuilder.append(\" \");\n    }\n  }\n}\n", "docstring": "ensure the output string has a character of whitespace before adding another word .", "partition": "test"}
{"idx": "5431", "code": "public void handleTblRequestHandlerListHrefDupActionRequest(RequestInvocationEvent event) throws ModelControlException {\n  try {\n    Map values=getValues();\n    onBeforeSaveProfile(values);\n    setPageSessionAttribute(PROPERTY_ATTRIBUTE,(HashMap)values);\n    SCSOAPBindingRequestHandlerListDupViewBean vb=(SCSOAPBindingRequestHandlerListDupViewBean)getViewBean(SCSOAPBindingRequestHandlerListDupViewBean.class);\n    unlockPageTrail();\n    passPgSessionMap(vb);\n    int idx=Integer.parseInt((String)getDisplayFieldValue(TBL_REQUEST_HANDLER_LIST_HREF_DUP_ACTION));\n    vb.setDupIndex(idx);\n    vb.forwardTo(getRequestContext());\n  }\n catch (  AMConsoleException e) {\n    setInlineAlertMessage(CCAlert.TYPE_ERROR,\"message.error\",e.getMessage());\n  }\n}\n", "docstring": "handles duplicate request handler request .", "partition": "test"}
{"idx": "5432", "code": "public boolean expired(long expire){\n  long mod=time.getTime();\n  long now=System.currentTimeMillis();\n  long diff=now - mod;\n  if (diff > expire && getSource() != NETWORK) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "test if the response is expired against current time , given the expire duration in milliseconds . if the ajax source is network , it \"'\" s never considered expired .", "partition": "test"}
{"idx": "5433", "code": "private void handleDoneQuery(final UUID queryId,final Future<Void> doneQueryFuture){\n  try {\n    doneQueryFuture.get();\n    throw new InterruptedException();\n  }\n catch (  InterruptedException e) {\n    throw new RuntimeException(e);\n  }\ncatch (  ExecutionException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "handle a recently halted query by throwing an appropriate exception .", "partition": "test"}
{"idx": "5434", "code": "synchronized public static List<String> formerIdentities(){\n  if (instance == null) {\n    instance=new NodeIdentity();\n    log.info(\"Using {} as the JMRI Node identity\",instance.getIdentity());\n  }\n  return instance.getFormerIdentities();\n}\n", "docstring": "if network hardware on a node was replaced , the identity will change .", "partition": "test"}
{"idx": "5435", "code": "public final double doOperation(){\n  final int dim=parameter.getDimension();\n  double sum=0.0;\n  if (usesPriorOnSum) {\n    for (int i=0; i < dim; i++) {\n      sum+=Math.abs(parameter.getParameterValue(i));\n    }\n  }\n  final int pos=MathUtils.nextInt(dim);\n  final int value=(int)parameter.getParameterValue(pos);\n  double logq=0.0;\n  if (value == 0) {\n    logq=bitFlipHelper.flipZero(pos,dim,sum);\n  }\n else   if (value == 1) {\n    logq=bitFlipHelper.flipOne(pos,dim,sum);\n  }\n else   if (value == -1) {\n    logq=bitFlipHelper.flipNegOne(pos,dim,sum);\n  }\n else {\n    throw new RuntimeException(\"expected 1 or 0 or -1\");\n  }\n  if (!usesPriorOnSum) {\n    logq=0;\n  }\n  return logq;\n}\n", "docstring": "change the parameter and return the hastings ratio . flip ( switch a 0 to 1 or 1 to 0 ) for a random bit in a bit vector . return the hastings ratio which makes all subsets of vectors with the same number of 1 bits equiprobable , unless usesprioronsum = false then all configurations are equiprobable", "partition": "test"}
{"idx": "5436", "code": "@Override public void chartProgress(ChartProgressEvent event){\n}\n", "docstring": "receives notification of a chart progress event .", "partition": "test"}
{"idx": "5437", "code": "@Override public JapaneseDate dateEpochDay(long epochDay){\n  return new JapaneseDate(LocalDate.ofEpochDay(epochDay));\n}\n", "docstring": "obtains a local date in the japanese calendar system from the epoch - day .", "partition": "test"}
{"idx": "5438", "code": "public long convertTransverseMercatorToGeodetic(double Easting,double Northing){\n  double c;\n  double de;\n  double dlam;\n  double eta;\n  double eta2;\n  double eta3;\n  double eta4;\n  double ftphi;\n  int i;\n  double sn;\n  double sr;\n  double t;\n  double tan2;\n  double tan4;\n  double t10;\n  double t11;\n  double t12;\n  double t13;\n  double t14;\n  double t15;\n  double t16;\n  double t17;\n  double tmd;\n  double tmdo;\n  long Error_Code=TRANMERC_NO_ERROR;\n  if ((Easting < (TranMerc_False_Easting - TranMerc_Delta_Easting)) || (Easting > (TranMerc_False_Easting + TranMerc_Delta_Easting))) {\n    Error_Code|=TRANMERC_EASTING_ERROR;\n  }\n  if ((Northing < (TranMerc_False_Northing - TranMerc_Delta_Northing)) || (Northing > (TranMerc_False_Northing + TranMerc_Delta_Northing))) {\n    Error_Code|=TRANMERC_NORTHING_ERROR;\n  }\n  if (Error_Code == TRANMERC_NO_ERROR) {\n    tmdo=TranMerc_ap * TranMerc_Origin_Lat - TranMerc_bp * Math.sin(2.0 * TranMerc_Origin_Lat) + TranMerc_cp * Math.sin(4.0 * TranMerc_Origin_Lat) - TranMerc_dp * Math.sin(6.0 * TranMerc_Origin_Lat) + TranMerc_ep * Math.sin(8.0 * TranMerc_Origin_Lat);\n    tmd=tmdo + (Northing - TranMerc_False_Northing) / TranMerc_Scale_Factor;\n    sr=TranMerc_a * (1.e0 - TranMerc_es) / Math.pow(Math.sqrt(1.e0 - TranMerc_es * Math.pow(Math.sin(0.e0),2)),3);\n    ftphi=tmd / sr;\n    for (i=0; i < 5; i++) {\n      t10=TranMerc_ap * ftphi - TranMerc_bp * Math.sin(2.0 * ftphi) + TranMerc_cp * Math.sin(4.0 * ftphi) - TranMerc_dp * Math.sin(6.0 * ftphi) + TranMerc_ep * Math.sin(8.0 * ftphi);\n      sr=TranMerc_a * (1.e0 - TranMerc_es) / Math.pow(Math.sqrt(1.e0 - TranMerc_es * Math.pow(Math.sin(ftphi),2)),3);\n      ftphi=ftphi + (tmd - t10) / sr;\n    }\n    sr=TranMerc_a * (1.e0 - TranMerc_es) / Math.pow(Math.sqrt(1.e0 - TranMerc_es * Math.pow(Math.sin(ftphi),2)),3);\n    sn=TranMerc_a / Math.sqrt(1.e0 - TranMerc_es * Math.pow(Math.sin(ftphi),2));\n    c=Math.cos(ftphi);\n    t=Math.tan(ftphi);\n    tan2=t * t;\n    tan4=tan2 * tan2;\n    eta=TranMerc_ebs * Math.pow(c,2);\n    eta2=eta * eta;\n    eta3=eta2 * eta;\n    eta4=eta3 * eta;\n    de=Easting - TranMerc_False_Easting;\n    if (Math.abs(de) < 0.0001)     de=0.0;\n    t10=t / (2.e0 * sr * sn* Math.pow(TranMerc_Scale_Factor,2));\n    t11=t * (5.e0 + 3.e0 * tan2 + eta - 4.e0 * Math.pow(eta,2) - 9.e0 * tan2 * eta) / (24.e0 * sr * Math.pow(sn,3)* Math.pow(TranMerc_Scale_Factor,4));\n    t12=t * (61.e0 + 90.e0 * tan2 + 46.e0 * eta + 45.E0 * tan4 - 252.e0 * tan2 * eta - 3.e0 * eta2 + 100.e0 * eta3 - 66.e0 * tan2 * eta2 - 90.e0 * tan4 * eta + 88.e0 * eta4 + 225.e0 * tan4 * eta2 + 84.e0 * tan2 * eta3 - 192.e0 * tan2 * eta4) / (720.e0 * sr * Math.pow(sn,5)* Math.pow(TranMerc_Scale_Factor,6));\n    t13=t * (1385.e0 + 3633.e0 * tan2 + 4095.e0 * tan4 + 1575.e0 * Math.pow(t,6)) / (40320.e0 * sr * Math.pow(sn,7)* Math.pow(TranMerc_Scale_Factor,8));\n    Latitude=ftphi - Math.pow(de,2) * t10 + Math.pow(de,4) * t11 - Math.pow(de,6) * t12 + Math.pow(de,8) * t13;\n    t14=1.e0 / (sn * c * TranMerc_Scale_Factor);\n    t15=(1.e0 + 2.e0 * tan2 + eta) / (6.e0 * Math.pow(sn,3) * c* Math.pow(TranMerc_Scale_Factor,3));\n    t16=(5.e0 + 6.e0 * eta + 28.e0 * tan2 - 3.e0 * eta2 + 8.e0 * tan2 * eta + 24.e0 * tan4 - 4.e0 * eta3 + 4.e0 * tan2 * eta2 + 24.e0 * tan2 * eta3) / (120.e0 * Math.pow(sn,5) * c* Math.pow(TranMerc_Scale_Factor,5));\n    t17=(61.e0 + 662.e0 * tan2 + 1320.e0 * tan4 + 720.e0 * Math.pow(t,6)) / (5040.e0 * Math.pow(sn,7) * c* Math.pow(TranMerc_Scale_Factor,7));\n    dlam=de * t14 - Math.pow(de,3) * t15 + Math.pow(de,5) * t16 - Math.pow(de,7) * t17;\n    Longitude=TranMerc_Origin_Long + dlam;\n    if (Math.abs(Latitude) > (90.0 * PI / 180.0))     Error_Code|=TRANMERC_NORTHING_ERROR;\n    if ((Longitude) > (PI)) {\n      Longitude-=(2 * PI);\n      if (Math.abs(Longitude) > PI)       Error_Code|=TRANMERC_EASTING_ERROR;\n    }\n    if (Math.abs(dlam) > (9.0 * PI / 180) * Math.cos(Latitude)) {\n      Error_Code|=TRANMERC_LON_WARNING;\n    }\n    if (Latitude > 1.0e10)     Error_Code|=TRANMERC_LON_WARNING;\n  }\n  return (Error_Code);\n}\n", "docstring": "the function convert_transverse_mercator_to_geodetic converts transverse mercator projection ( easting and northing ) coordinates to geodetic ( latitude and longitude ) coordinates , according to the current ellipsoid and transverse mercator projection parameters . if any errors occur , the error code ( s ) are returned by the function , otherwise tranmerc_no_error is returned .", "partition": "test"}
{"idx": "5439", "code": "private void checkEmpty(){\n  for (int i=0; i < gridCount(); i++) {\n    IgniteCache<Integer,String> cache=jcache(i);\n    assertEquals(0,cache.localSize());\n    assertEquals(0,cache.size());\n    for (    CachePeekMode peekMode : CachePeekMode.values()) {\n      assertEquals(0,cache.localSize(peekMode));\n      assertEquals(0,cache.size(peekMode));\n    }\n  }\n  checkPrimarySize(0);\n}\n", "docstring": "checks size is zero .", "partition": "test"}
{"idx": "5440", "code": "Node<K,V> find(int h,Object k){\n  Node<K,V> e=this;\n  if (k != null) {\n    do {\n      K ek;\n      if (e.hash == h && ((ek=e.key) == k || ek != null && myHashingStrategy.equals((K)k,ek))) {\n        return e;\n      }\n    }\n while ((e=e.next) != null);\n  }\n  return null;\n}\n", "docstring": "virtualized support for map . get ( ) ; overridden in subclasses .", "partition": "test"}
{"idx": "5441", "code": "@LoopProcessorAnnotations(loopProcessorAnnotations={@LoopProcessorAnnotation(processPath={IModelingElementDefinitions.CLASSES_PROCESSOR,IModelingElementDefinitions.OPERATIONS_PROCESSOR}),@LoopProcessorAnnotation(processPath={IModelingElementDefinitions.INTERFACES_PROCESSOR,IModelingElementDefinitions.OPERATIONS_PROCESSOR})},aspect=LoopAspectConstants.AFTER) public static void operationsProcessor(@GenerationRegistry GenerationPolicyRegistry generationValueGetter,@GenerationBaseElement Object element,@GenerationLoopElement Object modelPackage,@GenerationLoopElement(id={IModelingElementDefinitions.CLASSES_PROCESSOR,IModelingElementDefinitions.INTERFACES_PROCESSOR}) Object parent){\n  List<Object> userAddedDependTypes=generationValueGetter.getValues(DEPEND_TYPES_TRACKER,parent);\n  List<Object> parametersArgument=generationValueGetter.getValues(IModelingDecisions.OPERATION_PARAMETER_ARGUMENT,element,parent);\n  for (  Object item : parametersArgument) {\n    if (item instanceof SimpleEntry == false) {\n      continue;\n    }\n    SimpleEntry<?,?> simpleEntry=(SimpleEntry<?,?>)item;\n    Object type=simpleEntry.getKey();\n    if (!userAddedDependTypes.contains(type)) {\n      List<Object> types=generationValueGetter.getValues(IModelingConstants.TYPES_TRACKER,modelPackage,type);\n      if (types.isEmpty()) {\n        continue;\n      }\n      addDepend(generationValueGetter,parent,type);\n    }\n  }\n}\n", "docstring": "this is an important usability feature to have in our cpp transformation . asking the user to add \" depend \" statement for their code in each used parameter is some extra work . however , it is not that much , but the issue that in a language when the user forgets about adding the required depend , they can find a massive number of errors in the generated code due to that missing depends , and finding out that the missing depends is the reason can take sometime . in a language such as java , this is not a problem to realize that missing depend , but in cpp it can be even a nightmare in many cases .", "partition": "test"}
{"idx": "5442", "code": "public static void addLanguage(Language language){\n  if (language == null)   return;\n  ArrayList<Language> list=new ArrayList<Language>(Arrays.asList(s_languages));\n  list.add(language);\n  s_languages=new Language[list.size()];\n  list.toArray(s_languages);\n}\n", "docstring": "add language to supported languages", "partition": "test"}
{"idx": "5443", "code": "protected void doAddUser(User user) throws UsersRepositoryException {\n  Connection conn=null;\n  PreparedStatement addUserStatement=null;\n  try {\n    conn=openConnection();\n    addUserStatement=conn.prepareStatement(m_insertUserSql);\n    setUserForInsertStatement(user,addUserStatement);\n    addUserStatement.execute();\n  }\n catch (  SQLException sqlExc) {\n    sqlExc.printStackTrace();\n    throw new UsersRepositoryException(\"Error accessing database\",sqlExc);\n  }\n finally {\n    theJDBCUtil.closeJDBCStatement(addUserStatement);\n    theJDBCUtil.closeJDBCConnection(conn);\n  }\n}\n", "docstring": "adds a user to the underlying repository . the user name must not clash with an existing user .", "partition": "test"}
{"idx": "5444", "code": "void blockMix128(long k1,long k2){\n  h1^=mixK1(k1);\n  h1=Long.rotateLeft(h1,27);\n  h1+=h2;\n  h1=(h1 * 5) + 0x52dce729;\n  h2^=mixK2(k2);\n  h2=Long.rotateLeft(h2,31);\n  h2+=h1;\n  h2=(h2 * 5) + 0x38495ab5;\n}\n", "docstring": "block mix ( 128 - bit block ) of input key to internal hash state .", "partition": "test"}
{"idx": "5445", "code": "private void registerHost(SimEvent ev){\n  NetworkHost hs=(NetworkHost)ev.getData();\n  hostlist.put(hs.getId(),hs);\n}\n", "docstring": "register a host that is connected to the switch .", "partition": "test"}
{"idx": "5446", "code": "void createJar(FileOutputStream outStream,Map<String,byte[]> all) throws IOException {\n  JarOutputStream jar=new JarOutputStream(outStream);\n  for (  Entry<String,byte[]> entry : all.entrySet()) {\n    String name=entry.getKey();\n    JarEntry jar_entry=new JarEntry(name);\n    jar.putNextEntry(jar_entry);\n    jar.write(entry.getValue());\n    jar.closeEntry();\n  }\n  jar.flush();\n  jar.close();\n}\n", "docstring": "writes the jar file .", "partition": "test"}
{"idx": "5447", "code": "public void appendCell(int value){\n  appendCell(String.valueOf(value));\n}\n", "docstring": "appends a new cell to the current row containing the provided integer value .", "partition": "test"}
{"idx": "5448", "code": "public void expectServerProxyFailed(){\n  expectedApiCalls.add(new ApiCall(SERVER_PROXY_FAILED));\n}\n", "docstring": "expect a server proxy failure .", "partition": "test"}
{"idx": "5449", "code": "public Object remove(final Object key){\n  return parameters.remove(key);\n}\n", "docstring": "remove a key from the parameter set .", "partition": "test"}
{"idx": "5450", "code": "@Override public void recalculateAttributeStatistics(Attribute attribute){\n  List<Attribute> allAttributes=new ArrayList<Attribute>();\n  allAttributes.add(attribute);\n  recalculateAttributeStatistics(allAttributes);\n}\n", "docstring": "recalculate the attribute statistics of the given attribute .", "partition": "test"}
{"idx": "5451", "code": "public boolean isEmpty(){\n  return children.isEmpty();\n}\n", "docstring": "returns whether this group has any child layers .", "partition": "test"}
{"idx": "5452", "code": "public void insertColumn(int columnIndex,ColumnSpec columnSpec){\n  if (columnIndex < 1 || columnIndex > getColumnCount()) {\n    throw new IndexOutOfBoundsException(\"The column index \" + columnIndex + \"must be in the range [1, \"+ getColumnCount()+ \"].\");\n  }\n  colSpecs.add(columnIndex - 1,columnSpec);\n  shiftComponentsHorizontally(columnIndex,false);\n  adjustGroupIndices(colGroupIndices,columnIndex,false);\n}\n", "docstring": "inserts the specified column at the specified position . shifts components that intersect the new column to the right hand side and readjusts column groups . < p > the component shift works as follows : components that were located on the right hand side of the inserted column are shifted one column to the right ; component column span is increased by one if it intersects the new column . < p > column group indices that are greater or equal than the given column index will be increased by one .", "partition": "test"}
{"idx": "5453", "code": "private int calcRhsSize(Production production){\n  int result=production.getRHSSizeWithoutEpsilon();\n  if (production.getLHS() instanceof AuxiliaryLHS4SemanticShiftAction) {\n    final AuxiliaryLHS4SemanticShiftAction auxAction=(AuxiliaryLHS4SemanticShiftAction)production.getLHS();\n    result+=auxAction.numPrecedingSymbolsNotEpsilon;\n  }\n  return result;\n}\n", "docstring": "todo relevant for ll - parser ? ? ?", "partition": "test"}
{"idx": "5454", "code": "private BshMethod loadScriptedCommand(InputStream in,String name,Class[] argTypes,String resourcePath,Interpreter interpreter) throws UtilEvalError {\n  try {\n    interpreter.eval(new InputStreamReader(in),this,resourcePath);\n  }\n catch (  EvalError e) {\n    Interpreter.debug(e.toString());\n    throw new UtilEvalError(\"Error loading script: \" + e.getMessage());\n  }\n  BshMethod meth=getMethod(name,argTypes);\n  return meth;\n}\n", "docstring": "load a command script from the input stream and find the bshmethod in the target namespace .", "partition": "test"}
{"idx": "5455", "code": "public static Object invokeCompiledCommand(Class commandClass,Object[] args,Interpreter interpreter,CallStack callstack) throws UtilEvalError {\n  Object[] invokeArgs=new Object[args.length + 2];\n  invokeArgs[0]=interpreter;\n  invokeArgs[1]=callstack;\n  System.arraycopy(args,0,invokeArgs,2,args.length);\n  BshClassManager bcm=interpreter.getClassManager();\n  try {\n    return Reflect.invokeStaticMethod(bcm,commandClass,\"invoke\",invokeArgs);\n  }\n catch (  InvocationTargetException e) {\n    throw new UtilEvalError(\"Error in compiled command: \" + e.getTargetException());\n  }\ncatch (  ReflectError e) {\n    throw new UtilEvalError(\"Error invoking compiled command: \" + e);\n  }\n}\n", "docstring": "a command may be implemented as a compiled java class containing one or more static invoke ( ) methods of the correct signature . the invoke ( ) methods must accept two additional leading arguments of the interpreter and callstack , respectively . e . g . invoke ( interpreter , callstack , . . . ) this method adds the arguments and invokes the static method , returning the result .", "partition": "test"}
{"idx": "5456", "code": "private static void computeProbabilitiesMultinomialLogistic(double[] responses){\n  double[] r=responses.clone();\n  for (int j=0; j < r.length; j++) {\n    double sum=0;\n    boolean overflow=false;\n    for (int k=0; k < r.length; k++) {\n      if (r[k] - r[j] > 700) {\n        overflow=true;\n        break;\n      }\n      sum+=Math.exp(r[k] - r[j]);\n    }\n    if (overflow) {\n      responses[j]=0.0;\n    }\n else {\n      responses[j]=1.0 / sum;\n    }\n  }\n}\n", "docstring": "computes probabilities for the multinomial logistic model type .", "partition": "test"}
{"idx": "5457", "code": "public int addClientExternal(SSOToken token,Map props) throws AMClientCapException {\nsynchronized (externalClientData) {\n    extCapInstance.addClient(token,props);\n    String ct=getClientType(props);\n    Map eMap=mergeWithParent(props);\n    externalClientData.put(ct,eMap);\n    addToIndexes(ct,eMap);\n  }\n  return 0;\n}\n", "docstring": "wrapper methods for add / modify / remove apis in amclientcapdata . we have it here , so we dont have to wait for an event notification to arrive when this is called by the plugin .", "partition": "test"}
{"idx": "5458", "code": "public static void delete(File resourceToDelete) throws IOException {\n  if (resourceToDelete.exists()) {\n    delete(resourceToDelete.toPath());\n  }\n}\n", "docstring": "deletes a single file or recursively a folder with its content .", "partition": "test"}
{"idx": "5459", "code": "private void addExportRemoveVolumeSteps(Workflow workflow,ProtectionSystem rpSystem,URI exportGroupID,List<URI> boIDs) throws InternalException {\n  ExportGroup exportGroup=_dbClient.queryObject(ExportGroup.class,exportGroupID);\n  String exportStep=workflow.createStepId();\n  initTaskStatus(exportGroup,exportStep,Operation.Status.pending,\"export remove volumes (that contain RP snapshots)\");\n  Map<URI,List<URI>> deviceToBlockObjects=new HashMap<URI,List<URI>>();\n  for (  URI snapshotID : boIDs) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,snapshotID);\n    List<BlockObject> objectsToRemove=getExportObjectsForBookmark(snapshot);\n    for (    BlockObject blockObject : objectsToRemove) {\n      List<URI> blockObjects=deviceToBlockObjects.get(blockObject.getStorageController());\n      if (blockObjects == null) {\n        blockObjects=new ArrayList<URI>();\n        deviceToBlockObjects.put(blockObject.getStorageController(),blockObjects);\n      }\n      blockObjects.add(blockObject.getId());\n    }\n  }\n  for (  Map.Entry<URI,List<URI>> deviceEntry : deviceToBlockObjects.entrySet()) {\n    _log.info(String.format(\"Adding workflow step to remove RP bookmarks and associated target volumes from export.  ExportGroup: %s, Storage System: %s, BlockObjects: %s\",exportGroup.getId(),deviceEntry.getKey(),deviceEntry.getValue()));\n    _exportWfUtils.generateExportGroupRemoveVolumes(workflow,STEP_EXPORT_REMOVE_SNAPSHOT,STEP_EXPORT_GROUP_DISABLE,deviceEntry.getKey(),exportGroupID,deviceEntry.getValue());\n  }\n  _log.info(String.format(\"Created export group remove snapshot steps in workflow: %s\",exportGroup.getId()));\n}\n", "docstring": "add the export remove volume step to the workflow", "partition": "test"}
{"idx": "5460", "code": "public static void remove(String dbgToken){\n  dbgTable.remove(dbgToken);\n}\n", "docstring": "rremoves a debug token", "partition": "test"}
{"idx": "5461", "code": "protected boolean isRecompilationNeeded(int[] loadedChecksums){\n  this.checksums[0]=calculateChecksum();\n  if (this.checksums[0] != loadedChecksums[0]) {\n    if (Trace.swcChecksum) {\n      Trace.trace(\"isRecompilationNeeded: calculated checksum differs from last checksum, recompile\");\n    }\n    return true;\n  }\n  if (!isSwcChecksumEnabled) {\n    if (Trace.swcChecksum) {\n      Trace.trace(\"isRecompilationNeeded: checksums equal, swc-checksum disabled, incremental compile\");\n    }\n    return false;\n  }\n  Map<QName,Long> signatureChecksums=swcDefSignatureChecksums;\n  if (signatureChecksums == null) {\n    if (Trace.swcChecksum) {\n      Trace.trace(\"isRecompilationNeeded: checksums equal, signatureChecksums is null, incremental compile\");\n    }\n  }\n else {\n    for (    Map.Entry<QName,Long> entry : signatureChecksums.entrySet()) {\n      QName qName=(QName)entry.getKey();\n      Long dataSignatureChecksum=(Long)entry.getValue();\n      Long swcSignatureChecksum=swcContext.getChecksum(qName);\n      if (swcSignatureChecksum == null && qName != null) {\n        Source source=swcContext.getSource(qName.getNamespace(),qName.getLocalPart());\n        if (source != null) {\n          swcSignatureChecksum=new Long(source.getLastModified());\n        }\n      }\n      if (Trace.swcChecksum) {\n        if (dataSignatureChecksum == null) {\n          throw new IllegalStateException(\"dataSignatureChecksum should never be null\");\n        }\n      }\n      if (dataSignatureChecksum != null && swcSignatureChecksum == null) {\n        if (Trace.swcChecksum) {\n          Trace.trace(\"isRecompilationNeeded: signature checksums not equal, recompile\");\n          Trace.trace(\"compare \" + entry.getKey());\n          Trace.trace(\"data =  \" + dataSignatureChecksum);\n          Trace.trace(\"swc  =  \" + swcSignatureChecksum);\n        }\n        return true;\n      }\n      if (dataSignatureChecksum != null) {\n        if (dataSignatureChecksum.longValue() != swcSignatureChecksum.longValue()) {\n          if (Trace.swcChecksum) {\n            Trace.trace(\"isRecompilationNeeded: signature checksums not equal, recompile\");\n            Trace.trace(\"compare \" + entry.getKey());\n            Trace.trace(\"data =  \" + dataSignatureChecksum);\n            Trace.trace(\"swc  =  \" + swcSignatureChecksum);\n          }\n          return true;\n        }\n      }\n else {\n        return true;\n      }\n    }\n  }\n  boolean result=!areSwcFileChecksumsEqual();\n  if (Trace.swcChecksum) {\n    Trace.trace(\"isRecompilationNeeded: \" + (result ? \"recompile\" : \"incremental compile\"));\n  }\n  return result;\n}\n", "docstring": "loop thru the saved signature and file checksums in the persisted data and compare them with the signature and file checksums in the swc context .", "partition": "test"}
{"idx": "5462", "code": "private void adjustMinPrefForSpanningComps(DimConstraint[] specs,Float[] defPush,FlowSizeSpec fss,ArrayList<LinkedDimGroup>[] groupsLists){\n  for (int r=groupsLists.length - 1; r >= 0; r--) {\n    ArrayList<LinkedDimGroup> groups=groupsLists[r];\n    for (    LinkedDimGroup group : groups) {\n      if (group.span == 1) {\n        continue;\n      }\n      int[] sizes=group.getMinPrefMax();\n      for (int s=LayoutUtil.MIN; s <= LayoutUtil.PREF; s++) {\n        int cSize=sizes[s];\n        if (cSize == LayoutUtil.NOT_SET) {\n          continue;\n        }\n        int rowSize=0;\n        int sIx=(r << 1) + 1;\n        int len=Math.min((group.span << 1),fss.sizes.length - sIx) - 1;\n        for (int j=sIx; j < sIx + len; j++) {\n          int sz=fss.sizes[j][s];\n          if (sz != LayoutUtil.NOT_SET) {\n            rowSize+=sz;\n          }\n        }\n        if (rowSize < cSize && len > 0) {\n          for (int eagerness=0, newRowSize=0; eagerness < 4 && newRowSize < cSize; eagerness++) {\n            newRowSize=fss.expandSizes(specs,defPush,cSize,sIx,len,s,eagerness);\n          }\n        }\n      }\n    }\n  }\n}\n", "docstring": "adjust min / pref size for columns ( or rows ) that has components that spans multiple columns ( or rows ) .", "partition": "test"}
{"idx": "5463", "code": "public static String dumpAsHex(byte[] byteBuffer,int length){\n  StringBuilder outputBuilder=new StringBuilder(length * 4);\n  int p=0;\n  int rows=length / 8;\n  for (int i=0; (i < rows) && (p < length); i++) {\n    int ptemp=p;\n    for (int j=0; j < 8; j++) {\n      String hexVal=Integer.toHexString(byteBuffer[ptemp] & 0xff);\n      if (hexVal.length() == 1) {\n        hexVal=\"0\" + hexVal;\n      }\n      outputBuilder.append(hexVal + \" \");\n      ptemp++;\n    }\n    outputBuilder.append(\"    \");\n    for (int j=0; j < 8; j++) {\n      int b=0xff & byteBuffer[p];\n      if (b > 32 && b < 127) {\n        outputBuilder.append((char)b + \" \");\n      }\n else {\n        outputBuilder.append(\". \");\n      }\n      p++;\n    }\n    outputBuilder.append(\"\\n\");\n  }\n  int n=0;\n  for (int i=p; i < length; i++) {\n    String hexVal=Integer.toHexString(byteBuffer[i] & 0xff);\n    if (hexVal.length() == 1) {\n      hexVal=\"0\" + hexVal;\n    }\n    outputBuilder.append(hexVal + \" \");\n    n++;\n  }\n  for (int i=n; i < 8; i++) {\n    outputBuilder.append(\"   \");\n  }\n  outputBuilder.append(\"    \");\n  for (int i=p; i < length; i++) {\n    int b=0xff & byteBuffer[i];\n    if (b > 32 && b < 127) {\n      outputBuilder.append((char)b + \" \");\n    }\n else {\n      outputBuilder.append(\". \");\n    }\n  }\n  outputBuilder.append(\"\\n\");\n  return outputBuilder.toString();\n}\n", "docstring": "dumps the given bytes to stdout as a hex dump ( up to length bytes ) .", "partition": "test"}
{"idx": "5464", "code": "public void parseFile(ChatEventParseListener listener){\nsynchronized (this) {\n    @SuppressWarnings(\"unused\") long startTime=System.currentTimeMillis();\n    BufferedReader reader=null;\n    try {\n      reader=new BufferedReader(new FileReader(pathToFile));\n      String currentLine=reader.readLine();\n      while (currentLine != null) {\n        try {\n          ChatEvent event=ChatEventUtils.deserializeChatEvent(currentLine);\n          if (!listener.onNewEventParsed(event)) {\n            break;\n          }\n        }\n catch (        Throwable t) {\n          LOG.warn(\"Error reading chat event line \" + currentLine + \" skipping ChatEvent\",t);\n        }\n        currentLine=reader.readLine();\n      }\n      listener.onParseCompleted();\n    }\n catch (    IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        }\n catch (        Throwable t) {\n        }\n      }\n    }\n  }\n}\n", "docstring": "parses the chatlogger and invokes the listener on each chat event encountered .", "partition": "test"}
{"idx": "5465", "code": "private CoderResult escapeSequenceOther(short newByte){\n  if (newByte >= 0x20 && newByte <= 0x2F) {\n    state=ESCAPE_SEQUENCE_OTHER;\n    versionSequenceAllowed=false;\n    queue.write(newByte);\n  }\n else   if (newByte >= 0x30 && newByte <= 0x7E) {\n    state=NORMAL_BYTES;\n    versionSequenceAllowed=false;\n    queue.reset();\n  }\n else {\n    return malformedInput(ERR_ESCBYTE);\n  }\n  return CoderResult.UNDERFLOW;\n}\n", "docstring": "test for unknown , but valid , escape sequences .", "partition": "test"}
{"idx": "5466", "code": "@Nullable public static NetworkParameters fromID(String id){\n  if (id.equals(ID_MAINNET)) {\n    return MainNetParams.get();\n  }\n else   if (id.equals(ID_TESTNET)) {\n    return TestNet3Params.get();\n  }\n else   if (id.equals(ID_UNITTESTNET)) {\n    return UnitTestParams.get();\n  }\n else   if (id.equals(ID_REGTEST)) {\n    return RegTestParams.get();\n  }\n else   if (id.equals(ID_ALPHANET)) {\n    return AlphaNetParams.get();\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "returns the network parameters for the given string id or null if not recognized .", "partition": "test"}
{"idx": "5467", "code": "public void addCertificatesAndCRLs(CertStore certStore) throws CertStoreException, CMSException {\n  certs.addAll(CMSUtils.getCertificatesFromStore(certStore));\n  crls.addAll(CMSUtils.getCRLsFromStore(certStore));\n}\n", "docstring": "add the certificates and crls contained in the given certstore to the pool that will be included in the encoded signature block . < p > note : this assumes the certstore will support null in the get methods .", "partition": "test"}
{"idx": "5468", "code": "protected abstract void storeBody(DataOutputStream dos) throws IOException ;\n", "docstring": "writes the body of this attribute in an attribute - type dependent way ; see jvms7 4 . 7 . 2 and following .", "partition": "test"}
{"idx": "5469", "code": "private double findAngle(Point originPoint,Point targetPoint){\n  int x1=originPoint.x;\n  int y1=originPoint.y;\n  int x2=targetPoint.x;\n  int y2=targetPoint.y;\n  double angle=0.0;\n  double offset=0.0;\n  double sideA=x2 - x1;\n  double sideB=0.0;\n  if (y1 >= y2) {\n    sideB=y1 - y2;\n    offset=Math.toRadians(-90);\n  }\n else {\n    sideB=-(y2 - y1);\n    offset=Math.toRadians(90);\n  }\n  if (sideB == 0) {\n    return angle;\n  }\n  angle=Math.atan(sideA / sideB);\n  return angle + offset;\n}\n", "docstring": "uses trig to find angle of the arrow", "partition": "test"}
{"idx": "5470", "code": "void clearResourceIndex(String resourceTypeName){\n  Set resourceTypes=new HashSet();\n  resourceTypes.addAll(resourceIndices.keySet());\n  Iterator iter=resourceTypes.iterator();\n  while (iter.hasNext()) {\n    String resourceType=(String)iter.next();\n    if (resourceType.equalsIgnoreCase(resourceTypeName)) {\n      resourceIndices.remove(resourceType);\n      break;\n    }\n  }\n}\n", "docstring": "clears resourceindex of the given resource type name from the local cache . if an attempt is made to use this resource index subsequently , it would be refreshed from the datastore .", "partition": "test"}
{"idx": "5471", "code": "@Override public byte[] bitcoinSerialize(){\n  if (headerBytesValid && transactionBytesValid) {\n    Preconditions.checkNotNull(payload,\"Bytes should never be null if headerBytesValid && transactionBytesValid\");\n    if (length == payload.length) {\n      return payload;\n    }\n else {\n      byte[] buf=new byte[length];\n      System.arraycopy(payload,offset,buf,0,length);\n      return buf;\n    }\n  }\n  ByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? HEADER_SIZE + guessTransactionsLength() : length);\n  try {\n    writeHeader(stream);\n    writeTransactions(stream);\n  }\n catch (  IOException e) {\n  }\n  return stream.toByteArray();\n}\n", "docstring": "special handling to check if we have a valid byte array for both header and transactions", "partition": "test"}
{"idx": "5472", "code": "@Override public List<Period> generateRollingPeriods(DateTimeUnit dateTimeUnit){\n  Calendar calendar=getCalendar();\n  List<Period> periods=Lists.newArrayList();\n  dateTimeUnit=calendar.minusDays(dateTimeUnit,calendar.weekday(dateTimeUnit) - 1);\n  dateTimeUnit=calendar.minusDays(dateTimeUnit,357);\n  for (int i=0; i < 52; i++) {\n    periods.add(createPeriod(dateTimeUnit,calendar));\n    dateTimeUnit=calendar.plusWeeks(dateTimeUnit,1);\n  }\n  return periods;\n}\n", "docstring": "generates the last 52 weeks where the last one is the week which the given date is inside .", "partition": "test"}
{"idx": "5473", "code": "@Override public Set<String> vertexMatchPatternLabels(){\n  return Collections.emptySet();\n}\n", "docstring": "gets the set of labels required at the time of matching the vertex in a cypher match pattern . this implementation returns no labels .", "partition": "test"}
{"idx": "5474", "code": "public boolean resetUnreadCounts(int aSection){\n  boolean retCode=false;\n  ArrayList<RoomSummary> summariesList=mSummaryListByGroupPosition.get(aSection);\n  if (null != summariesList) {\n    for (int summaryIdx=0; summaryIdx < summariesList.size(); summaryIdx++) {\n      retCode|=resetUnreadCount(aSection,summaryIdx);\n    }\n  }\n else {\n    Log.w(DBG_CLASS_NAME,\"## resetUnreadCounts(): section \" + aSection + \" was not found in the sections summary list\");\n  }\n  return retCode;\n}\n", "docstring": "reset the count of the unread messages of the section whose index is given in asection", "partition": "test"}
{"idx": "5475", "code": "public static void addCategory(LexiconCategory category){\n  categories.add(category);\n}\n", "docstring": "adds a category to the list of registered categories to appear in the lexicon .", "partition": "test"}
{"idx": "5476", "code": "private static int CallNonvirtualObjectMethodV(JNIEnvironment env,int objJREF,int classJREF,int methodID,Address argAddress) throws Exception {\n  if (traceJNI)   VM.sysWrite(\"JNI called: CallNonvirtualObjectMethodV  \\n\");\n  RuntimeEntrypoints.checkJNICountDownToGC();\n  try {\n    Object obj=env.getJNIRef(objJREF);\n    Object returnObj=JNIHelpers.invokeWithVarArg(obj,methodID,argAddress,null,true);\n    return env.pushJNIRef(returnObj);\n  }\n catch (  Throwable unexpected) {\n    if (traceJNI)     unexpected.printStackTrace(System.err);\n    env.recordException(unexpected);\n    return 0;\n  }\n}\n", "docstring": "callnonvirtualobjectmethodv : invoke a virtual method that returns an object", "partition": "test"}
{"idx": "5477", "code": "private Tuple<Message,Connection> tryOtherMessages(){\n  List<Tuple<Message,Connection>> messages=new ArrayList<Tuple<Message,Connection>>();\n  Collection<Message> msgCollection=getMessageCollection();\n  for (  Connection con : getConnections()) {\n    DTNHost other=con.getOtherNode(getHost());\n    ProphetV2Router othRouter=(ProphetV2Router)other.getRouter();\n    if (othRouter.isTransferring()) {\n      continue;\n    }\n    for (    Message m : msgCollection) {\n      if (othRouter.hasMessage(m.getId())) {\n        continue;\n      }\n      if ((othRouter.getPredFor(m.getTo()) >= getPredFor(m.getTo()))) {\n        messages.add(new Tuple<Message,Connection>(m,con));\n      }\n    }\n  }\n  if (messages.size() == 0) {\n    return null;\n  }\n  Collections.sort(messages,new TupleComparator());\n  return tryMessagesForConnected(messages);\n}\n", "docstring": "tries to send all other messages to all connected hosts ordered by their delivery probability", "partition": "test"}
{"idx": "5478", "code": "private void testStreamsFromValues(){\n  Stream<String> movieNames=Stream.of(\"Gods Must Be Crazy\",\"Fiddler On The Roof\",\"Ben-Hur\");\n  movieNames.forEach(null);\n  String[] movieNames2={\"Gods Must Be Crazy\",\"Fiddler On The Roof\"};\n  Stream<String> mNames2=Stream.of(movieNames2);\n  mNames2.forEach(null);\n  List<String> moviesList=new ArrayList<>();\n  moviesList.add(\"The Sound of Music\");\n  moviesList.add(\"Gone with the Wind\");\n  Stream<List<String>> fromList=Stream.of(moviesList);\n  fromList.forEach(null);\n}\n", "docstring": "creating a stream from a set of seed values", "partition": "test"}
{"idx": "5479", "code": "public static void cacheClientUserId(ConsumerBean consumerBean,Long internalId,String clientId){\n  cacheClientUserId(consumerBean.getShort_name(),internalId,clientId);\n}\n", "docstring": "cache a user \"'\" s client item id keyed by internal user id", "partition": "test"}
{"idx": "5480", "code": "protected void processEntity(IXMLReader reader,IXMLEntityResolver entityResolver) throws Exception {\n  if (!XMLUtil.checkLiteral(reader,\"NTITY\")) {\n    XMLUtil.skipTag(reader);\n    return;\n  }\n  XMLUtil.skipWhitespace(reader,null);\n  char ch=XMLUtil.readChar(reader,\'\\0\');\n  if (ch == \'%\') {\n    XMLUtil.skipWhitespace(reader,null);\n    entityResolver=this.parameterEntityResolver;\n  }\n else {\n    reader.unread(ch);\n  }\n  String key=XMLUtil.scanIdentifier(reader);\n  XMLUtil.skipWhitespace(reader,null);\n  ch=XMLUtil.readChar(reader,\'%\');\n  String systemID=null;\n  String publicID=null;\nswitch (ch) {\ncase \'P\':\n    if (!XMLUtil.checkLiteral(reader,\"UBLIC\")) {\n      XMLUtil.skipTag(reader);\n      return;\n    }\n  XMLUtil.skipWhitespace(reader,null);\npublicID=XMLUtil.scanString(reader,\'%\',this.parameterEntityResolver);\nXMLUtil.skipWhitespace(reader,null);\nsystemID=XMLUtil.scanString(reader,\'%\',this.parameterEntityResolver);\nXMLUtil.skipWhitespace(reader,null);\nXMLUtil.readChar(reader,\'%\');\nbreak;\ncase \'S\':\nif (!XMLUtil.checkLiteral(reader,\"YSTEM\")) {\nXMLUtil.skipTag(reader);\nreturn;\n}\nXMLUtil.skipWhitespace(reader,null);\nsystemID=XMLUtil.scanString(reader,\'%\',this.parameterEntityResolver);\nXMLUtil.skipWhitespace(reader,null);\nXMLUtil.readChar(reader,\'%\');\nbreak;\ncase \'\"\':\ncase \'\\\'\':\nreader.unread(ch);\nString value=XMLUtil.scanString(reader,\'%\',this.parameterEntityResolver);\nentityResolver.addInternalEntity(key,value);\nXMLUtil.skipWhitespace(reader,null);\nXMLUtil.readChar(reader,\'%\');\nbreak;\ndefault :\nXMLUtil.skipTag(reader);\n}\nif (systemID != null) {\nentityResolver.addExternalEntity(key,publicID,systemID);\n}\n}\n", "docstring": "processes an entity element .", "partition": "test"}
{"idx": "5481", "code": "@Override final Node<V> find(int h,int k){\n  for (Node<V> e=first; e != null; ) {\n    int s;\n    if (((s=lockState) & (WAITER | WRITER)) != 0) {\n      if ((e.key == k)) {\n        return e;\n      }\n      e=e.next;\n    }\n else     if (U.compareAndSwapInt(this,LOCKSTATE,s,s + READER)) {\n      TreeNode<V> r;\n      TreeNode<V> p;\n      try {\n        p=((r=root) == null ? null : r.findTreeNode(h,k));\n      }\n  finally {\n        Thread w;\n        if (getAndAddInt(this,LOCKSTATE,-READER) == (READER | WAITER) && (w=waiter) != null) {\n          LockSupport.unpark(w);\n        }\n      }\n      return p;\n    }\n  }\n  return null;\n}\n", "docstring": "returns matching node or null if none . tries to search using tree comparisons from root , but continues linear search when lock not available .", "partition": "test"}
{"idx": "5482", "code": "public boolean isPublic(){\n  return Modifier.isPublic(flags);\n}\n", "docstring": "utility method to query the modifier flags of this member .", "partition": "test"}
{"idx": "5483", "code": "@Override public boolean receiveImage(ImageToProcess img,TaskImageContainer task,boolean blockUntilImageRelease,boolean closeOnImageRelease,Optional<Runnable> runnableWhenDone) throws InterruptedException {\n  Set<TaskImageContainer> passTasks=new HashSet<TaskImageContainer>(1);\n  passTasks.add(task);\n  return receiveImage(img,passTasks,blockUntilImageRelease,closeOnImageRelease,runnableWhenDone);\n}\n", "docstring": "implements that top - level image single task submission that is defined by the imageconsumer interface .", "partition": "test"}
{"idx": "5484", "code": "protected String doIt() throws Exception {\n  log.info(\"Selection=\" + p_Selection + \", DateInvoiced=\"+ p_DateInvoiced+ \", AD_Org_ID=\"+ p_AD_Org_ID+ \", C_BPartner_ID=\"+ p_C_BPartner_ID+ \", M_InOut_ID=\"+ p_M_InOut_ID+ \", DocAction=\"+ p_docAction+ \", Consolidate=\"+ p_ConsolidateDocument);\n  String sql=null;\n  if (p_Selection) {\n    sql=\"SELECT M_InOut.* FROM M_InOut, T_Selection \" + \"WHERE M_InOut.DocStatus=\'CO\' AND M_InOut.IsSOTrx=\'Y\' \" + \" AND M_InOut.M_InOut_ID = T_Selection.T_Selection_ID \"+ \" AND T_Selection.AD_PInstance_ID=? \"+ \"ORDER BY M_InOut.M_InOut_ID\";\n  }\n else {\n    sql=\"SELECT * FROM M_InOut o \" + \"WHERE DocStatus IN(\'CO\',\'CL\') AND IsSOTrx=\'Y\'\";\n    if (p_AD_Org_ID != 0)     sql+=\" AND AD_Org_ID=?\";\n    if (p_C_BPartner_ID != 0)     sql+=\" AND C_BPartner_ID=?\";\n    if (p_M_InOut_ID != 0)     sql+=\" AND M_InOut_ID=?\";\n    sql+=\" AND EXISTS (SELECT * FROM M_InOutLine ol \" + \"WHERE o.M_InOut_ID=ol.M_InOut_ID AND ol.IsInvoiced=\'N\') \" + \"ORDER BY M_InOut_ID\";\n  }\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    int index=1;\n    if (p_Selection) {\n      pstmt.setInt(index,getAD_PInstance_ID());\n    }\n else {\n      if (p_AD_Org_ID != 0)       pstmt.setInt(index++,p_AD_Org_ID);\n      if (p_C_BPartner_ID != 0)       pstmt.setInt(index++,p_C_BPartner_ID);\n      if (p_M_InOut_ID != 0)       pstmt.setInt(index++,p_M_InOut_ID);\n    }\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  return generate(pstmt);\n}\n", "docstring": "generate invoices from shipments", "partition": "test"}
{"idx": "5485", "code": "public static S2CellId fromFaceIJ(int face,int i,int j){\n  long n[]={0,face << (POS_BITS - 33)};\n  int bits=(face & SWAP_MASK);\n  for (int k=7; k >= 0; --k) {\n    bits=getBits(n,i,j,k,bits);\n  }\n  S2CellId s=new S2CellId((((n[1] << 32) + n[0]) << 1) + 1);\n  return s;\n}\n", "docstring": "return a leaf cell given its cube face ( range 0 . . 5 ) and i - and j - coordinates ( see s2 . h ) .", "partition": "test"}
{"idx": "5486", "code": "private void updateActions(final INaviProject project){\n  m_loadProjectAction.setEnabled(!project.isLoaded());\n  if (m_addAddressSpaceAction != null) {\n    m_addAddressSpaceAction.setEnabled(project.isLoaded());\n  }\n  m_searchViewAction.setEnabled(project.isLoaded());\n  m_forwardAction.setEnabled(project.isLoaded());\n}\n", "docstring": "updates the actions that depend on the state of a single project .", "partition": "test"}
{"idx": "5487", "code": "void close() throws IOException {\n  stream.close();\n}\n", "docstring": "closes the file item .", "partition": "test"}
{"idx": "5488", "code": "public boolean truncateTooLongNumber(PhoneNumber number){\n  if (isValidNumber(number)) {\n    return true;\n  }\n  PhoneNumber numberCopy=new PhoneNumber();\n  numberCopy.mergeFrom(number);\n  long nationalNumber=number.getNationalNumber();\n  do {\n    nationalNumber/=10;\n    numberCopy.setNationalNumber(nationalNumber);\n    if (isPossibleNumberWithReason(numberCopy) == ValidationResult.TOO_SHORT || nationalNumber == 0) {\n      return false;\n    }\n  }\n while (!isValidNumber(numberCopy));\n  number.setNationalNumber(nationalNumber);\n  return true;\n}\n", "docstring": "attempts to extract a valid number from a phone number that is too long to be valid , and resets the phonenumber object passed in to that valid version . if no valid number could be extracted , the phonenumber object passed in will not be modified .", "partition": "test"}
{"idx": "5489", "code": "public static boolean isWithinTimeComparisonEpsilon(long timeMicros){\n  long now=Utils.getSystemNowMicrosUtc();\n  return Math.abs(timeMicros - now) < timeComparisonEpsilon;\n}\n", "docstring": "compares a time value with current time . both time values are in micros since epoch . since we can not assume the time came from the same node , we use the concept of a time epsilon : any two time values within epsilon are considered too close to globally order in respect to each other and this method will return true .", "partition": "test"}
{"idx": "5490", "code": "public Optional<Histogram> histogram(){\n  return Optional.empty();\n}\n", "docstring": "histogram getter , returns the histogram value contained in this metricvalue .", "partition": "test"}
{"idx": "5491", "code": "private JLabel createWeekday(String title){\n  JLabel label=new JLabel(title);\n  label.setHorizontalAlignment(SwingConstants.CENTER);\n  label.setHorizontalTextPosition(SwingConstants.CENTER);\n  label.setRequestFocusEnabled(false);\n  label.setBackground(AdempierePLAF.getPrimary1());\n  label.setForeground(Color.white);\n  label.setOpaque(true);\n  return label;\n}\n", "docstring": "create week day label", "partition": "test"}
{"idx": "5492", "code": "default Path append(String relPath){\n  return append(Path.parse(relPath));\n}\n", "docstring": "create a new path consisting of this path with one or more additional segments given by the relative path .", "partition": "test"}
{"idx": "5493", "code": "public static int indexOf(String value,String substring){\n  return value != null && substring != null ? value.indexOf(substring) : -1;\n}\n", "docstring": "returns the index within a string of the first occurrence of a specified substring .", "partition": "test"}
{"idx": "5494", "code": "public void testSubmitNullCallable(){\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    try {\n      @SuppressWarnings(\"unused\") Future<String> future=e.submit((Callable<String>)null);\n      shouldThrow();\n    }\n catch (    NullPointerException success) {\n    }\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "submit ( null callable ) throws nullpointerexception", "partition": "test"}
{"idx": "5495", "code": "public int readSI32() throws IOException {\n  synchBits();\n  int b0=in.read();\n  if (b0 < 0) {\n    throw new IOException(\"Unexpected end of input\");\n  }\n  int b1=in.read();\n  if (b1 < 0) {\n    throw new IOException(\"Unexpected end of input\");\n  }\n  int b2=in.read();\n  if (b2 < 0) {\n    throw new IOException(\"Unexpected end of input\");\n  }\n  byte[] aByte=new byte[1];\n  int count=in.read(aByte);\n  if (count < 1) {\n    throw new IOException(\"Unexpected end of input\");\n  }\n  bytesRead+=4;\n  return (int)((aByte[0] * 256 * 256* 256) + (b2 * 256 * 256) + (b1 * 256)+ b0);\n}\n", "docstring": "read a 32 bit signed number", "partition": "test"}
{"idx": "5496", "code": "public void format(long inDate,StringBuilder buffer){\n  buffer.append(format(inDate));\n}\n", "docstring": "format to string buffer .", "partition": "test"}
{"idx": "5497", "code": "public Profiler clearResults(){\n  lapped.clear();\n  return this;\n}\n", "docstring": "clears saved results for average computations .", "partition": "test"}
{"idx": "5498", "code": "@Override public GraphQuery has(final String key,final Object value){\n  criteria.add(new Has(key,value));\n  return this;\n}\n", "docstring": "filter out elements that do not have a property value equal to provided value . ? s < key > < value > .", "partition": "test"}
{"idx": "5499", "code": "public void addAttributeValue(Principal principal,Guid guid,String name,String value) throws UMSException {\n  modifyAttributeValue(ModificationType.ADD,principal,guid,name,value);\n}\n", "docstring": "adds value for an attribute and saves the change in the database .", "partition": "test"}
{"idx": "5500", "code": "public static void copyStream(InputStream inputStream,OutputStream outputStream){\n  if (inputStream != null && outputStream != null) {\n    try {\n      int length=-1;\n      byte[] buffer=new byte[Constant.Capacity.BYTES_PER_MB];\n      while ((length=inputStream.read(buffer,0,buffer.length)) != -1) {\n        outputStream.write(buffer,0,length);\n        outputStream.flush();\n      }\n    }\n catch (    Exception e) {\n      throw new FileUtilException(e);\n    }\n  }\n}\n", "docstring": "copy stream , from input to output , it don \"'\" t close", "partition": "test"}
{"idx": "5501", "code": "private void printTypeMembers(List<? extends Element> members,List<TypeElement> innerClass){\n  for (  Element element : members) {\n    if (isPublicOrProtected(element)) {\n      printMember(element,innerClass);\n    }\n  }\n}\n", "docstring": "helper method that outputs the public or protected inner members of a class .", "partition": "test"}
{"idx": "5502", "code": "private void initializeBasicVariables(final int startColumn){\n  basicVariables=new int[getWidth() - 1];\n  basicRows=new int[getHeight()];\n  Arrays.fill(basicVariables,-1);\n  for (int i=startColumn; i < getWidth() - 1; i++) {\n    Integer row=findBasicRow(i);\n    if (row != null) {\n      basicVariables[i]=row;\n      basicRows[row]=i;\n    }\n  }\n}\n", "docstring": "initializes the basic variable / row mapping .", "partition": "test"}
{"idx": "5503", "code": "public void mouseReleased(MouseEvent e){\n}\n", "docstring": "if the mouse is dragging a rectangle , pick the vertices contained in that rectangle clean up settings from mousepressed", "partition": "test"}
{"idx": "5504", "code": "private void attachHeader(SIPHeader h){\n  if (h == null)   throw new IllegalArgumentException(\"null header!\");\n  try {\n    if (h instanceof SIPHeaderList) {\n      SIPHeaderList<?> hl=(SIPHeaderList<?>)h;\n      if (hl.isEmpty()) {\n        return;\n      }\n    }\n    attachHeader(h,false,false);\n  }\n catch (  SIPDuplicateHeaderException ex) {\n  }\n}\n", "docstring": "attach a header and die if you get a duplicate header exception .", "partition": "test"}
{"idx": "5505", "code": "public String phonemise(String text,String pos,StringBuilder g2pMethod){\n  String result=userdictLookup(text,pos);\n  if (result != null) {\n    g2pMethod.append(\"userdict\");\n    return result;\n  }\n  result=lexiconLookup(text,pos);\n  if (result != null) {\n    g2pMethod.append(\"lexicon\");\n    return result;\n  }\n  String normalised=MaryUtils.normaliseUnicodeLetters(text,getLocale());\n  if (!normalised.equals(text)) {\n    result=userdictLookup(normalised,pos);\n    if (result != null) {\n      g2pMethod.append(\"userdict\");\n      return result;\n    }\n    result=lexiconLookup(normalised,pos);\n    if (result != null) {\n      g2pMethod.append(\"lexicon\");\n      return result;\n    }\n  }\n  String phones=lts.predictPronunciation(text);\n  result=lts.syllabify(phones);\n  if (result != null) {\n    g2pMethod.append(\"rules\");\n    return result;\n  }\n  return null;\n}\n", "docstring": "phonemise the word text . this starts with a simple lexicon lookup , followed by some heuristics , and finally applies letter - to - sound rules if nothing else was successful .", "partition": "test"}
{"idx": "5506", "code": "public static void stop(int exit_code){\n  System.exit(exit_code);\n}\n", "docstring": "allows to exit program .", "partition": "test"}
{"idx": "5507", "code": "private FieldODEStateAndDerivative<Decimal64> state(double t){\n  return new FieldODEStateAndDerivative<>(zero.add(t),new Decimal64[0],new Decimal64[0]);\n}\n", "docstring": "create a state at a time .", "partition": "test"}
{"idx": "5508", "code": "public static final void writeStringArrayXml(String[] val,String name,XmlSerializer out) throws XmlPullParserException, java.io.IOException {\n  if (val == null) {\n    out.startTag(null,\"null\");\n    out.endTag(null,\"null\");\n    return;\n  }\n  out.startTag(null,\"string-array\");\n  if (name != null) {\n    out.attribute(null,\"name\",name);\n  }\n  final int n=val.length;\n  out.attribute(null,\"num\",Integer.toString(n));\n  for (int i=0; i < n; i++) {\n    if (val[i] == null) {\n      out.startTag(null,\"null\");\n      out.endTag(null,\"null\");\n    }\n else {\n      out.startTag(null,\"item\");\n      out.attribute(null,\"value\",val[i]);\n      out.endTag(null,\"item\");\n    }\n  }\n  out.endTag(null,\"string-array\");\n}\n", "docstring": "flatten a string [ ", "partition": "test"}
{"idx": "5509", "code": "private Spannable highlightHashtags(Spannable text){\n  if (text == null) {\n    return null;\n  }\n  final Matcher matcher=PATTERN_HASHTAGS.matcher(text);\n  while (matcher.find()) {\n    final int start=matcher.start(1);\n    final int end=matcher.end(1);\n    text.setSpan(new ForegroundColorSpan(mHighlightColor),start,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    text.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),start,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n  }\n  return text;\n}\n", "docstring": "highlights all the hashtag in the passed text .", "partition": "test"}
{"idx": "5510", "code": "private static void checkForNullElement(Object[] arg,String argName){\n  if ((arg == null) || (arg.length == 0)) {\n    throw new IllegalArgumentException(\"Argument \" + argName + \"[] cannot be null or empty.\");\n  }\n  for (int i=0; i < arg.length; i++) {\n    if (arg[i] == null) {\n      throw new IllegalArgumentException(\"Argument\'s element \" + argName + \"[\"+ i+ \"] cannot be null.\");\n    }\n  }\n}\n", "docstring": "checks that object [ ", "partition": "test"}
{"idx": "5511", "code": "public InputStream executeDownload(String url,String cookie) throws IOException {\n  String[][] headerParams=new String[][]{{\"Cookie\",cookie},{\"User-Agent\",\"AndroidDownloadManager/6.0.1 (Linux; U; Android 6.0.1; Nexus 6P Build/MTC19T)\"}};\n  HttpEntity httpEntity=executeGet(url,null,headerParams);\n  return httpEntity.getContent();\n}\n", "docstring": "fetches url content by executing get request with provided cookie string .", "partition": "test"}
{"idx": "5512", "code": "public Image flipImageVertically(Image image,boolean maintainOpacity){\n  int[] rgb=image.getRGB();\n  int[] newRGB=new int[rgb.length];\n  int width=image.getWidth();\n  int height=image.getHeight();\n  for (int y=0; y < height; y++) {\n    for (int x=0; x < width; x++) {\n      newRGB[x + (height - y - 1) * width]=rgb[x + y * width];\n    }\n  }\n  return EncodedImage.createFromRGB(newRGB,width,height,!maintainOpacity);\n}\n", "docstring": "flips the given image on the vertical axis", "partition": "test"}
{"idx": "5513", "code": "public MorfologikFilterFactory(Map<String,String> args){\n  super(args);\n  final String DICTIONARY_RESOURCE_ATTRIBUTE=\"dictionary-resource\";\n  String dictionaryResource=get(args,DICTIONARY_RESOURCE_ATTRIBUTE);\n  if (dictionaryResource != null && !dictionaryResource.isEmpty()) {\n    throw new IllegalArgumentException(\"The \" + DICTIONARY_RESOURCE_ATTRIBUTE + \" attribute is no \"+ \"longer supported. Use the \'\"+ DICTIONARY_ATTRIBUTE+ \"\' attribute instead (see LUCENE-6833).\");\n  }\n  resourceName=get(args,DICTIONARY_ATTRIBUTE);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "docstring": "creates a new morfologikfilterfactory", "partition": "test"}
{"idx": "5514", "code": "public static <T>T wrapThrow(Callable<T> callable,Code _finally){\n  try {\n    return callable.call();\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    wrapThrow(_finally);\n  }\n}\n", "docstring": "execute the callable wrapping checked exceptions inside a runtimeexception .", "partition": "test"}
{"idx": "5515", "code": "public static String padLeft(String str,int totalChars){\n  if (str == null)   str=\"null\";\n  StringBuffer sb=new StringBuffer();\n  for (int i=0; i < totalChars - str.length(); i++) {\n    sb.append(\" \");\n  }\n  sb.append(str);\n  return sb.toString();\n}\n", "docstring": "pads the given string to the left with spaces to ensure that it \"'\" s at least totalchars long .", "partition": "test"}
{"idx": "5516", "code": "protected void decodeImageData(){\n  int NullCode=-1;\n  int npix=iw * ih;\n  int available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, count, i, datum, data_size, first, top, bi, pi;\n  if ((pixels == null) || (pixels.length < npix)) {\n    pixels=new byte[npix];\n  }\n  if (prefix == null)   prefix=new short[MaxStackSize];\n  if (suffix == null)   suffix=new byte[MaxStackSize];\n  if (pixelStack == null)   pixelStack=new byte[MaxStackSize + 1];\n  data_size=read();\n  clear=1 << data_size;\n  end_of_information=clear + 1;\n  available=clear + 2;\n  old_code=NullCode;\n  code_size=data_size + 1;\n  code_mask=(1 << code_size) - 1;\n  for (code=0; code < clear; code++) {\n    prefix[code]=0;\n    suffix[code]=(byte)code;\n  }\n  datum=bits=count=first=top=pi=bi=0;\n  for (i=0; i < npix; ) {\n    if (top == 0) {\n      if (bits < code_size) {\n        if (count == 0) {\n          count=readBlock();\n          if (count <= 0)           break;\n          bi=0;\n        }\n        datum+=(((int)block[bi]) & 0xff) << bits;\n        bits+=8;\n        bi++;\n        count--;\n        continue;\n      }\n      code=datum & code_mask;\n      datum>>=code_size;\n      bits-=code_size;\n      if ((code > available) || (code == end_of_information))       break;\n      if (code == clear) {\n        code_size=data_size + 1;\n        code_mask=(1 << code_size) - 1;\n        available=clear + 2;\n        old_code=NullCode;\n        continue;\n      }\n      if (old_code == NullCode) {\n        pixelStack[top++]=suffix[code];\n        old_code=code;\n        first=code;\n        continue;\n      }\n      in_code=code;\n      if (code == available) {\n        pixelStack[top++]=(byte)first;\n        code=old_code;\n      }\n      while (code > clear) {\n        pixelStack[top++]=suffix[code];\n        code=prefix[code];\n      }\n      first=((int)suffix[code]) & 0xff;\n      if (available >= MaxStackSize)       break;\n      pixelStack[top++]=(byte)first;\n      prefix[available]=(short)old_code;\n      suffix[available]=(byte)first;\n      available++;\n      if (((available & code_mask) == 0) && (available < MaxStackSize)) {\n        code_size++;\n        code_mask+=available;\n      }\n      old_code=in_code;\n    }\n    top--;\n    pixels[pi++]=pixelStack[top];\n    i++;\n  }\n  for (i=pi; i < npix; i++) {\n    pixels[i]=0;\n  }\n}\n", "docstring": "decodes lzw image data into pixel array . adapted from john cristy \"'\" s imagemagick .", "partition": "test"}
{"idx": "5517", "code": "public int hashCode(){\n  int myhash=37 + policyIdentifier.hashCode();\n  myhash=37 * myhash + policyQualifiers.hashCode();\n  return myhash;\n}\n", "docstring": "returns the hash code for this policyinformation .", "partition": "test"}
{"idx": "5518", "code": "public UnixTerminal() throws IOException {\n  this(System.in,System.out,Charset.defaultCharset());\n}\n", "docstring": "creates a unixterminal with default settings , using system . in and system . out for input / output , using the default character set on the system as the encoding and trap ctrl + c signal instead of killing the application .", "partition": "test"}
{"idx": "5519", "code": "@Override public boolean isCellEditable(int rowIndex,int columnIndex){\n  ProcessFunctionParameterValue value=valueList.get(rowIndex);\nswitch (columnIndex) {\ncase COL_OPTIONAL:\n    return value.optional;\ncase COL_VALUE:\n  if (value.optional) {\n    return value.included;\n  }\n else {\n    return true;\n  }\ncase COL_PARAMETER:\ncase COL_TYPE:\ndefault :\nreturn false;\n}\n}\n", "docstring": "checks if is cell editable .", "partition": "test"}
{"idx": "5520", "code": "private void checkStreams(){\n  if ((System.currentTimeMillis() - lastChecked) / 1000 < CHECK_DELAY) {\n    return;\n  }\n  lastChecked=System.currentTimeMillis();\n  Set<StreamInfo> remove=new HashSet<>();\n  for (  StreamInfo info : data) {\n    if (!info.isValid() || !info.getOnline()) {\n      remove.add(info);\n    }\n  }\n  for (  StreamInfo info : remove) {\n    data.remove(info);\n    itemRemoved(info);\n  }\n  if (remove.isEmpty()) {\n    listDataChanged();\n  }\n}\n", "docstring": "checks all added streams and removes invalid ones .", "partition": "test"}
{"idx": "5521", "code": "public void addPriorityPackage(String pkg){\n  if (_priorityPackages == null)   _priorityPackages=new String[0];\n  int oldLength=_priorityPackages.length;\n  String[] newPkgs=new String[oldLength + 1];\n  System.arraycopy(_priorityPackages,0,newPkgs,0,oldLength);\n  if (!pkg.endsWith(\".\"))   pkg=pkg + \'.\';\n  newPkgs[oldLength]=pkg;\n  _priorityPackages=newPkgs;\n}\n", "docstring": "add to the list of packages that take priority over the parent", "partition": "test"}
{"idx": "5522", "code": "@Override public void actionPerformed(ActionEvent ev){\n  final megan.remote.RemoteServiceBrowser remoteServiceBrowser=(megan.remote.RemoteServiceBrowser)getViewer();\n  if (remoteServiceBrowser != null) {\n    String url=remoteServiceBrowser.getURL();\n    String user=remoteServiceBrowser.getUser();\n    String password=remoteServiceBrowser.getPasswd();\n    String command=\"openServer url=\'\" + url + \"\'\";\n    if (user.length() > 0)     command+=\" user=\'\" + user + \"\'\";\n    if (password.length() > 0) {\nsynchronized (syncObject) {\n        OpenRemoteServerCommand.hiddenPassword=password;\n      }\n      command+=\" password=\'\" + HIDDEN_PASSWORD + \"\'\";\n    }\n    command+=\";\";\n    if (url.length() > 0) {\n      execute(command);\n    }\n  }\n}\n", "docstring": "action to be performed", "partition": "test"}
{"idx": "5523", "code": "public static String verifyCertificate(X509Certificate cert,Collection<CRL> crls,Calendar calendar){\n  if (SignUtils.hasUnsupportedCriticalExtension(cert))   return \"Has unsupported critical extension\";\n  try {\n    cert.checkValidity(calendar.getTime());\n  }\n catch (  Exception e) {\n    return e.getMessage();\n  }\n  if (crls != null) {\n    for (    CRL crl : crls) {\n      if (crl.isRevoked(cert))       return \"Certificate revoked\";\n    }\n  }\n  return null;\n}\n", "docstring": "verifies a single certificate .", "partition": "test"}
{"idx": "5524", "code": "public static void expand(){\n  String[] st=new String[L];\n  int i;\n  for (i=0; i < R; i++)   st[i]=\"\" + (char)i;\n  st[i++]=\"\";\n  int codeword=BinaryStdIn.readInt(W);\n  if (codeword == R)   return;\n  String val=st[codeword];\n  while (true) {\n    BinaryStdOut.write(val);\n    codeword=BinaryStdIn.readInt(W);\n    if (codeword == R)     break;\n    String s=st[codeword];\n    if (i == codeword)     s=val + val.charAt(0);\n    if (i < L)     st[i++]=val + s.charAt(0);\n    val=s;\n  }\n  BinaryStdOut.close();\n}\n", "docstring": "reads a sequence of bit encoded using lzw compression with 12 - bit codewords from standard input ; expands them ; and writes the results to standard output .", "partition": "test"}
{"idx": "5525", "code": "@Override public boolean isRotateEdgeLabels(){\n  return graphCreator.isRotatingEdgeLabels();\n}\n", "docstring": "let the graph model decide .", "partition": "test"}
{"idx": "5526", "code": "public static ResponseCode createExtension(String name){\n  StringBuffer buffer=new StringBuffer(name.length() + 2);\n  if (!name.startsWith(\"X\")) {\n    buffer.append(\'X\');\n  }\n  buffer.append(name);\n  return new ResponseCode(buffer.toString());\n}\n", "docstring": "creates an extension response code . names that do not begin with \"'\" x \"'\" will have \"'\" x \"'\" prepended", "partition": "test"}
{"idx": "5527", "code": "@Override public double[] makeInverseCumulativeTestValues(){\n  double[] points=makeCumulativeTestPoints();\n  double[] points2=new double[points.length - 2];\n  System.arraycopy(points,1,points2,0,points2.length);\n  return points2;\n}\n", "docstring": "creates the default inverse cumulative probability density test expected values .", "partition": "test"}
{"idx": "5528", "code": "public java.lang.StringBuilder append(boolean b){\n  if (b) {\n    return append(\"true\");\n  }\n  return append(\"false\");\n}\n", "docstring": "appends the string representation of the boolean argument to the string buffer . the argument is converted to a string as if by the method string . valueof , and the characters of that string are then appended to this string buffer .", "partition": "test"}
{"idx": "5529", "code": "public void deleteServers(Set servers) throws AMConsoleException {\n  if (servers.contains(SystemProperties.getServerInstanceName())) {\n    throw new AMConsoleException(getLocalizedString(\"exception.cannot.delete.this.server.instance\"));\n  }\n  String serverName=null;\n  try {\n    if ((servers != null) && !servers.isEmpty()) {\n      SSOToken token=getUserSSOToken();\n      for (Iterator i=servers.iterator(); i.hasNext(); ) {\n        serverName=(String)i.next();\n        String[] param={serverName};\n        logEvent(\"ATTEMPT_DELETE_SERVER\",param);\n        ServerConfiguration.deleteServerInstance(token,serverName);\n        logEvent(\"SUCCEED_DELETE_SERVER\",param);\n      }\n    }\n  }\n catch (  SMSException e) {\n    String[] params={serverName,e.getMessage()};\n    logEvent(\"SMS_EXCEPTION_DELETE_SERVER\",params);\n    throw new AMConsoleException(getErrorString(e));\n  }\ncatch (  SSOException e) {\n    String[] params={serverName,e.getMessage()};\n    logEvent(\"SSO_EXCEPTION_DELETE_SERVER\",params);\n    throw new AMConsoleException(getErrorString(e));\n  }\n}\n", "docstring": "deletes a set of servers .", "partition": "test"}
{"idx": "5530", "code": "public boolean add(terminal sym) throws internal_error {\n  boolean result;\n  not_null(sym);\n  result=_elements.get(sym.index());\n  if (!result)   _elements.set(sym.index());\n  return result;\n}\n", "docstring": "add a single terminal to the set .", "partition": "test"}
{"idx": "5531", "code": "private void createRecursivly(String path) throws KeeperException, InterruptedException {\n  try {\n    if (zk.exists(path,true) == null && path.length() > 0) {\n      String temp=path.substring(0,path.lastIndexOf(File.separator));\n      createRecursivly(temp);\n      zk.create(path,null,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n    }\n else {\n      return;\n    }\n  }\n catch (  KeeperException e) {\n    throw e;\n  }\ncatch (  InterruptedException e) {\n    throw e;\n  }\n}\n", "docstring": "create zookeepr node if not exist", "partition": "test"}
{"idx": "5532", "code": "public void stopRecording(){\n  mHandler.sendMessage(mHandler.obtainMessage(MSG_STOP_RECORDING));\n  mHandler.sendMessage(mHandler.obtainMessage(MSG_QUIT));\n}\n", "docstring": "tells the video recorder to stop recording . ( call from non - encoder thread . ) < p > returns immediately ; the encoder / muxer may not yet be finished creating the movie . < p > todo : have the encoder thread invoke a callback on the ui thread just before it shuts down so we can provide reasonable status ui ( and let the caller know that movie encoding has completed ) .", "partition": "test"}
{"idx": "5533", "code": "private void writeTag(String name,Tag tag) throws IOException {\n  TagType type=tag.getType();\n  byte[] nameBytes=name.getBytes(StandardCharsets.UTF_8);\n  if (type == TagType.END) {\n    throw new IOException(\"Named TAG_End not permitted.\");\n  }\n  os.writeByte(type.getId());\n  os.writeShort(nameBytes.length);\n  os.write(nameBytes);\n  writeTagPayload(tag);\n}\n", "docstring": "write a tag with a name .", "partition": "test"}
{"idx": "5534", "code": "public int hashCode(){\n  if (myhash == -1) {\n    if (timestamp == null) {\n      myhash=signerCertPath.hashCode();\n    }\n else {\n      myhash=signerCertPath.hashCode() + timestamp.hashCode();\n    }\n  }\n  return myhash;\n}\n", "docstring": "returns the hash code value for this code signer . the hash code is generated using the signer \"'\" s certificate path and the timestamp , if present .", "partition": "test"}
{"idx": "5535", "code": "public TypeVariableBV typeVariable(){\n  int id=typeVariableList.size();\n  typeVariableList.add(null);\n  TypeVariableBV result=new TypeVariableBV(id,this);\n  typeVariableList.set(id,result);\n  return result;\n}\n", "docstring": "get new type variable", "partition": "test"}
{"idx": "5536", "code": "public int process(Callback[] callbacks,int state) throws AuthLoginException {\n  initAuthConfig();\n  X509Certificate[] allCerts=null;\n  try {\n    HttpServletRequest servletRequest=getHttpServletRequest();\n    if (servletRequest != null) {\n      allCerts=(X509Certificate[])servletRequest.getAttribute(\"javax.servlet.request.X509Certificate\");\n      if (allCerts == null || allCerts.length == 0) {\n        debug.message(\"Certificate: checking for cert passed in the URL.\");\n        if (!portal_gw_cert_auth_enabled) {\n          debug.error(\"Certificate: cert passed \" + \"in URL not enabled for this client\");\n          throw new AuthLoginException(amAuthCert,\"noURLCertAuth\",null);\n        }\n        thecert=getPortalStyleCert(servletRequest);\n        allCerts=new X509Certificate[]{thecert};\n      }\n else {\n        if (portal_gw_cert_auth_enabled && portal_gw_cert_preferred) {\n          thecert=getPortalStyleCert(servletRequest);\n          allCerts=new X509Certificate[]{thecert};\n        }\n else {\n          if (debug.messageEnabled()) {\n            debug.message(\"Certificate: got all certs from \" + \"HttpServletRequest = {}\",allCerts.length);\n          }\n          thecert=allCerts[0];\n        }\n      }\n    }\n else {\n      thecert=sendCallback();\n    }\n    if (thecert == null) {\n      debug.message(\"Certificate: no cert passed in.\");\n      throw new AuthLoginException(amAuthCert,\"noCert\",null);\n    }\n    getTokenFromCert(thecert);\n    storeUsernamePasswd(userTokenId,null);\n    if (debug.messageEnabled()) {\n      debug.message(\"in Certificate. userTokenId=\" + userTokenId + \" from getTokenFromCert\");\n    }\n  }\n catch (  AuthLoginException e) {\n    setFailureID(userTokenId);\n    debug.error(\"Certificate:  exiting validate with exception\",e);\n    throw new AuthLoginException(amAuthCert,\"noCert\",null);\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"Got client cert =\\n\" + thecert.toString());\n  }\n  if (amAuthCert_chkCertInLDAP.equalsIgnoreCase(\"false\") && amAuthCert_chkCRL.equalsIgnoreCase(\"false\") && !ocspEnabled) {\n    return ISAuthConstants.LOGIN_SUCCEED;\n  }\n  if (ldapParam == null) {\n    setLdapStoreParam();\n  }\n  if (amAuthCert_chkCertInLDAP.equalsIgnoreCase(\"true\")) {\n    X509Certificate ldapcert=AMCertStore.getRegisteredCertificate(ldapParam,thecert,amAuthCert_chkAttrCertInLDAP);\n    if (ldapcert == null) {\n      debug.error(\"X509Certificate: getRegCertificate is null\");\n      setFailureID(userTokenId);\n      throw new AuthLoginException(amAuthCert,\"CertNoReg\",null);\n    }\n  }\n  int ret=doJCERevocationValidation(allCerts);\n  if (ret != ISAuthConstants.LOGIN_SUCCEED) {\n    debug.error(\"X509Certificate:CRL / OCSP verify failed.\");\n    setFailureID(userTokenId);\n    throw new AuthLoginException(amAuthCert,\"CertVerifyFailed\",null);\n  }\n  return ISAuthConstants.LOGIN_SUCCEED;\n}\n", "docstring": "process certificate based auth request", "partition": "test"}
{"idx": "5537", "code": "public static void downto(Number self,Number to,@ClosureParams(FirstParam.class) Closure closure){\n  int self1=self.intValue();\n  int to1=to.intValue();\n  if (self1 >= to1) {\n    for (int i=self1; i >= to1; i--) {\n      closure.call(i);\n    }\n  }\n else   throw new GroovyRuntimeException(\"The argument (\" + to + \") to downto() cannot be greater than the value (\"+ self+ \") it\'s called on.\");\n}\n", "docstring": "iterates from this number down to the given number , inclusive , decrementing by one each time .", "partition": "test"}
{"idx": "5538", "code": "public void add(SelectClauseElementRaw element){\n  selectClauseElements.add(element);\n}\n", "docstring": "adds an select expression within the select clause .", "partition": "test"}
{"idx": "5539", "code": "public synchronized void removePvChangeListener(PvChangeListener l){\n  log.debug(\"-PvListener:\" + String.valueOf(this) + \"->\"+ String.valueOf(l));\n  PvChangeListeners.remove(l);\n}\n", "docstring": "remove listener for pv changes", "partition": "test"}
{"idx": "5540", "code": "public static boolean isNormal(GeoTimeSerie gts,int buckets,double pcterror,boolean bessel){\n  if (0 == gts.values) {\n    return true;\n  }\n  if (TYPE.DOUBLE != gts.type && TYPE.LONG != gts.type) {\n    return false;\n  }\n  double[] musigma=musigma(gts,bessel);\n  double mu=musigma[0];\n  double sigma=musigma[1];\n  if (0.0D == sigma) {\n    return false;\n  }\n  double[] bounds=SAXUtils.getBounds(buckets);\n  int[] counts=new int[bounds.length + 1];\n  for (int i=0; i < gts.values; i++) {\n    double v=((double)GTSHelper.valueAtIndex(gts,i) - mu) / sigma;\n    int insertion=Arrays.binarySearch(bounds,v);\n    if (insertion >= 0) {\n      counts[insertion]++;\n    }\n else {\n      counts[-(1 + insertion)]++;\n    }\n  }\n  double mean=gts.values / counts.length;\n  for (int i=0; i < counts.length; i++) {\n    if (Math.abs(1.0D - (counts[i] / mean)) > pcterror) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "determine if a gts \"'\" values are normally distributed . works for numerical gts only", "partition": "test"}
{"idx": "5541", "code": "public void loadFromProperties(Properties properties){\n  projected=StringUtil.getBooleanValue(properties,\"ProjectionInfo.Projected\",false,true);\n  tiePoint=StringUtil.getDoubleArray(properties,\"ProjectionInfo.TiePoint\",null,true);\n  scale=StringUtil.getDoubleArray(properties,\"ProjectionInfo.Scale\",null,true);\n  globe=StringUtil.getStringValue(properties,\"ProjectionInfo.Globe\",null,true);\n  rasterWidth=StringUtil.getIntegerValue(properties,\"ProjectionInfo.RasterWidth\",true,0,true);\n  rasterLength=StringUtil.getIntegerValue(properties,\"ProjectionInfo.RasterLength\",true,0,true);\n  datumCode=StringUtil.getIntegerValue(properties,\"ProjectionInfo.DatumCode\",true,0,false);\n  ellipsoidCode=StringUtil.getIntegerValue(properties,\"ProjectionInfo.DatumCode\",true,0,false);\n  semiMajorAxis=StringUtil.getDoubleValue(properties,\"ProjectionInfo.SemiMajorAxis\",true,Double.NaN,false);\n  semiMinorAxis=StringUtil.getDoubleValue(properties,\"ProjectionInfo.SemiMinorAxis\",true,Double.NaN,false);\n  inverseFlattening=StringUtil.getDoubleValue(properties,\"ProjectionInfo.InverseFlattening\",false,Double.NaN,false);\n  gcsPrimeMeridianLon=StringUtil.getDoubleValue(properties,\"ProjectionInfo.GCSPrimeMeridianLon\",false,Double.NaN,false);\n  projCode=StringUtil.getIntegerValue(properties,\"ProjectionInfo.ProjectionCode\",true,0,false);\n  pcsCode=StringUtil.getIntegerValue(properties,\"ProjectionInfo.ProjectionCoordinateSystemCode\",true,0,false);\n  coordTransformCode=StringUtil.getIntegerValue(properties,\"ProjectionInfo.CoordTransformCode\",true,0,false);\n  stdParallel1=StringUtil.getDoubleValue(properties,\"ProjectionInfo.StdParallel1\",false,Double.NaN,false);\n  poleLat=(int)(Math.signum(stdParallel1) * 90);\n  stdParallel2=StringUtil.getDoubleValue(properties,\"ProjectionInfo.StdParallel1\",false,Double.NaN,false);\n  naturalOriginLon=StringUtil.getDoubleValue(properties,\"ProjectionInfo.NaturalOriginLon\",false,Double.NaN,false);\n  naturalOriginLat=StringUtil.getDoubleValue(properties,\"ProjectionInfo.NaturalOriginLat\",false,Double.NaN,false);\n  falseOriginLon=StringUtil.getDoubleValue(properties,\"ProjectionInfo.FalseOriginLon\",false,Double.NaN,false);\n  falseOriginLat=StringUtil.getDoubleValue(properties,\"ProjectionInfo.FalseOriginLat\",false,Double.NaN,false);\n  falseEasting=StringUtil.getDoubleValue(properties,\"ProjectionInfo.FalseEasting\",false,Double.NaN,false);\n  falseNorthing=StringUtil.getDoubleValue(properties,\"ProjectionInfo.FalseNorthing\",false,Double.NaN,false);\n  centerEasting=StringUtil.getDoubleValue(properties,\"ProjectionInfo.CenterEasting\",false,Double.NaN,false);\n  centerNorthing=StringUtil.getDoubleValue(properties,\"ProjectionInfo.CenterNorthing\",false,Double.NaN,false);\n  centerLon=StringUtil.getDoubleValue(properties,\"ProjectionInfo.CenterLon\",false,Double.NaN,false);\n  centerLat=StringUtil.getDoubleValue(properties,\"ProjectionInfo.CenterLat\",false,Double.NaN,false);\n  scaleAtNaturalOrigin=StringUtil.getDoubleValue(properties,\"ProjectionInfo.ScaleAtNaturalOrigin\",false,Double.NaN,false);\n  scaleAtCenter=StringUtil.getDoubleValue(properties,\"ProjectionInfo.ScaleAtCenter\",false,Double.NaN,false);\n  azimuth=StringUtil.getDoubleValue(properties,\"ProjectionInfo.Azimuth\",false,Double.NaN,false);\n  straightVertPoleLon=StringUtil.getDoubleValue(properties,\"ProjectionInfo.StraightVertPoleLon\",false,Double.NaN,false);\n  gcsCitation=StringUtil.getStringValue(properties,\"ProjectionInfo.GCSCitation\",null,false);\n  pcsCitation=StringUtil.getStringValue(properties,\"ProjectionInfo.PCSCitation\",null,false);\n  projLinearUnits=StringUtil.getStringValue(properties,\"ProjectionInfo.ProjLinearUnits\",\"meter\",false);\n  if (coordTransformCode == GeoKey.Code_Undefined) {\n    String citation=(pcsCitation == null ? \"\" : pcsCitation.toLowerCase());\n    if (citation.contains(\"mercator\") && (citation.contains(\"web\") || citation.contains(\"pseudo\") || citation.contains(\"global\"))) {\n      coordTransformCode=GeoKey.Code_CT_Mercator;\n      if (Double.isNaN(naturalOriginLon))       naturalOriginLon=0;\n      if (Double.isNaN(falseEasting))       falseEasting=0;\n      if (Double.isNaN(falseNorthing))       falseNorthing=0;\n      if (citation.contains(\"auxiliary\") && citation.contains(\"sphere\")) {\n        if (!Double.isNaN(semiMajorAxis))         semiMinorAxis=semiMajorAxis;\n else {\n          semiMajorAxis=SEMI_MAJOR_AXIS[0];\n          semiMinorAxis=SEMI_MINOR_AXIS[0];\n        }\n      }\n    }\n  }\n}\n", "docstring": "load contents from a properties object", "partition": "test"}
{"idx": "5542", "code": "public static double gamma(double x){\n  double P[]={1.60119522476751861407E-4,1.19135147006586384913E-3,1.04213797561761569935E-2,4.76367800457137231464E-2,2.07448227648435975150E-1,4.94214826801497100753E-1,9.99999999999999996796E-1};\n  double Q[]={-2.31581873324120129819E-5,5.39605580493303397842E-4,-4.45641913851797240494E-3,1.18139785222060435552E-2,3.58236398605498653373E-2,-2.34591795718243348568E-1,7.14304917030273074085E-2,1.00000000000000000320E0};\n  double p, z;\n  double q=Math.abs(x);\n  if (q > 33.0) {\n    if (x < 0.0) {\n      p=Math.floor(q);\n      if (p == q) {\n        throw new ArithmeticException(\"gamma: overflow\");\n      }\n      z=q - p;\n      if (z > 0.5) {\n        p+=1.0;\n        z=q - p;\n      }\n      z=q * Math.sin(Math.PI * z);\n      if (z == 0.0) {\n        throw new ArithmeticException(\"gamma: overflow\");\n      }\n      z=Math.abs(z);\n      z=Math.PI / (z * stirlingFormula(q));\n      return -z;\n    }\n else {\n      return stirlingFormula(x);\n    }\n  }\n  z=1.0;\n  while (x >= 3.0) {\n    x-=1.0;\n    z*=x;\n  }\n  while (x < 0.0) {\n    if (x == 0.0) {\n      throw new ArithmeticException(\"gamma: singular\");\n    }\n else     if (x > -1.E-9) {\n      return (z / ((1.0 + 0.5772156649015329 * x) * x));\n    }\n    z/=x;\n    x+=1.0;\n  }\n  while (x < 2.0) {\n    if (x == 0.0) {\n      throw new ArithmeticException(\"gamma: singular\");\n    }\n else     if (x < 1.e-9) {\n      return (z / ((1.0 + 0.5772156649015329 * x) * x));\n    }\n    z/=x;\n    x+=1.0;\n  }\n  if ((x == 2.0) || (x == 3.0)) {\n    return z;\n  }\n  x-=2.0;\n  p=polevl(x,P,6);\n  q=polevl(x,Q,7);\n  return z * p / q;\n}\n", "docstring": "returns the gamma function of the argument .", "partition": "test"}
{"idx": "5543", "code": "public ShowProgress(){\n  start=last=System.currentTimeMillis();\n}\n", "docstring": "create a new instance of this class , and start the timer .", "partition": "test"}
{"idx": "5544", "code": "public static RepositoryExpression parseRepositoryExpression(String toParse) throws ParseError {\n  StreamTokenizer t=Parser.tokenize(toParse);\n  Term creator=Parser.parseTerm(t);\n  List<Operation> operations=Parser.parseOperationList(t);\n  RepositoryExpression ex=new RepositoryExpression(creator);\n  if (!operations.isEmpty()) {\n    throw new ParseError(\"Expression must represent a simple repository, e.g. \'internal(revision=3)\'.\");\n  }\n  return ex;\n}\n", "docstring": "parse a string under the expectation that it is a repositoryexpression , i . e . repository name plus options , e . g . \" internal ( revision = 1234 ) \" or \" file ( path = / tmp , projectspace = internal ) \" .", "partition": "test"}
{"idx": "5545", "code": "@Override public synchronized void close() throws IOException {\n  buffer=null;\n  notifyAll();\n}\n", "docstring": "closes this stream . this implementation releases the buffer used for the pipe and notifies all threads waiting to read or write .", "partition": "test"}
{"idx": "5546", "code": "public void addSection(SourceSection section){\n  sections.add(section);\n}\n", "docstring": "add a section to the document .", "partition": "test"}
{"idx": "5547", "code": "public static GenomeRelationships load(BufferedReader reader) throws IOException {\n  final GenomeRelationships ped=new GenomeRelationships();\n  String line;\n  while ((line=reader.readLine()) != null) {\n    line=line.trim();\n    if (line.startsWith(\"#\") || line.matches(\"^\\\\s*$\")) {\n      continue;\n    }\n    if (line.matches(\"^genome\\\\s+[-a-zA-Z0-9_]+(\\\\s+[-a-zA-Z0-9_]+?=[^\\\\s]*)*$\")) {\n      parseGenomeLine(ped,line);\n      continue;\n    }\n    if (line.matches(\"^[a-z]+-[a-z]+\\\\s+[-a-zA-Z0-9_]+\\\\s+[-a-zA-Z0-9_]+(\\\\s+[-a-zA-Z0-9_]+?=[^\\\\s]*)*$\")) {\n      parseRelationshipLine(ped,line);\n      continue;\n    }\n    throw new NoTalkbackSlimException(\"unrecognized line in relationships: \'\" + line + \"\'\");\n  }\n  return ped;\n}\n", "docstring": "load a genome relationships file", "partition": "test"}
{"idx": "5548", "code": "private int[] versionParts(String version){\n  String[] parts=version.split(\"\\\\.\");\n  int[] p=new int[3];\n  for (int i=0; i < 3; i++) {\n    int pi;\n    if (i < parts.length) {\n      p[i]=Integer.parseInt(parts[i]);\n    }\n else {\n      p[i]=-1;\n    }\n  }\n  return p;\n}\n", "docstring": "return the version parts", "partition": "test"}
{"idx": "5549", "code": "public static boolean approxEquals(final double a,final double b,final double tolerance){\n  if (Double.isNaN(a) || Double.isNaN(b)) {\n    return false;\n  }\n  if (a == b) {\n    return true;\n  }\n  if (Double.isInfinite(a) || Double.isInfinite(b)) {\n    return false;\n  }\n  if (a >= (b - tolerance) && a <= (b + tolerance)) {\n    return true;\n  }\n  return false;\n}\n", "docstring": "check if two doubles are equal to within specified tolerance .", "partition": "test"}
{"idx": "5550", "code": "public static Map<String,Object> loadJsonModel(File jsFile){\n  try {\n    Map<String,Object> model=JavaScriptResolver.readJsonModel(jsFile);\n    if (model == null) {\n      throw new CompilerErrorException(\"Can\'t find metamodel definition in \" + jsFile.getAbsolutePath());\n    }\n    if (!model.containsKey(\"$mod-bin\")) {\n      throw new CeylonRunJsException(\"The JavaScript module \" + jsFile + \" is not compatible with the current version of ceylon-js\");\n    }\n    return model;\n  }\n catch (  IOException ex) {\n    throw new CompilerErrorException(\"Error loading model from \" + jsFile);\n  }\n}\n", "docstring": "read the metamodel declaration from a js file , check it \"'\" s the right version and return the model as a map .", "partition": "test"}
{"idx": "5551", "code": "static String[] splitLine(final String line){\n  final int ix0=line.indexOf(\'#\');\n  final int ix=ix0 == -1 ? line.length() : ix0;\n  final String lessComment=line.substring(0,ix);\n  if (lessComment.matches(\"^\\\\s*$\")) {\n    return null;\n  }\n  return lessComment.split(\"\\\\s+\");\n}\n", "docstring": "check for comments , trim white space . return null if nothing left after that . otherwise split on tabs and return the array .", "partition": "test"}
{"idx": "5552", "code": "private List<Volume> createVolumeData(String name,int numVolumes){\n  List<Volume> volumes=new ArrayList<Volume>();\n  URI cgUri=createBlockConsistencyGroup(name + \"-cg\");\n  for (int i=1; i <= numVolumes; i++) {\n    Volume volume=new Volume();\n    URI volumeURI=URIUtil.createId(Volume.class);\n    testVolumeURIs.add(volumeURI);\n    volume.setId(volumeURI);\n    volume.setLabel(name + i);\n    volume.setConsistencyGroup(cgUri);\n    _dbClient.createObject(volume);\n  }\n  return volumes;\n}\n", "docstring": "creates the blockobject volume data .", "partition": "test"}
{"idx": "5553", "code": "private static <T>T hashMapToObject(LinkedHashMap map,Class<T> type){\n  try {\n    return stringToObject(mapper.writeValueAsString(map),type);\n  }\n catch (  IOException e) {\n    log.warn(\"Could not create a object of the class \" + type.getName() + \" out of the map \"+ map.toString()+ \" :\"+ e.getMessage());\n    return null;\n  }\n}\n", "docstring": "takes a hashmap and creates an object . the hashmap should be created through jackson , so that jackson can deserialize it and instantiate an object .", "partition": "test"}
{"idx": "5554", "code": "private void deleteSMS(String cmd,String search){\n  int nbDeleted=-2;\n  if (cmd.equals(\"all\")) {\n    nbDeleted=mSmsManager.deleteAllSms();\n  }\n else   if (cmd.equals(\"sent\")) {\n    nbDeleted=mSmsManager.deleteSentSms();\n  }\n else   if (cmd.startsWith(\"last\")) {\n    Integer number=Tools.parseInt(search);\n    if (number == null) {\n      number=1;\n    }\n    if (cmd.equals(\"last\")) {\n      nbDeleted=mSmsManager.deleteLastSms(number);\n    }\n else     if (cmd.equals(\"lastin\")) {\n      nbDeleted=mSmsManager.deleteLastInSms(number);\n    }\n else     if (cmd.equals(\"lastout\")) {\n      nbDeleted=mSmsManager.deleteLastOutSms(number);\n    }\n else {\n      send(R.string.chat_del_sms_error);\n    }\n  }\n else   if (cmd.equals(\"contact\") && search != null) {\n    ArrayList<Contact> contacts=ContactsManager.getMatchingContacts(sContext,search);\n    if (contacts.size() > 1) {\n      StringBuilder sb=new StringBuilder(getString(R.string.chat_specify_details));\n      sb.append(Tools.LineSep);\n      for (      Contact contact : contacts) {\n        sb.append(contact.name);\n        sb.append(Tools.LineSep);\n      }\n      send(sb.toString());\n    }\n else     if (contacts.size() == 1) {\n      Contact contact=contacts.get(0);\n      send(R.string.chat_del_sms_from,contact.name);\n      nbDeleted=mSmsManager.deleteSmsByContact(contact.rawIds);\n    }\n else {\n      send(R.string.chat_no_match_for,search);\n    }\n  }\n else   if (cmd.equals(\"number\") && search != null) {\n    send(R.string.chat_del_sms_from,search);\n    nbDeleted=mSmsManager.deleteSmsByNumber(search);\n    if (nbDeleted <= 0) {\n      send(R.string.chat_no_match_for,search);\n    }\n  }\n else {\n    send(R.string.chat_del_sms_syntax);\n  }\n  if (nbDeleted >= 0) {\n    send(R.string.chat_del_sms_nb,nbDeleted);\n  }\n else   if (nbDeleted == -1) {\n    send(R.string.chat_del_sms_error);\n  }\n}\n", "docstring": "\" delsms \" cmd deletes sms , either - all sms - all sent sms - sms from specified contact - # last messages - # last incoming / outgoing messages", "partition": "test"}
{"idx": "5555", "code": "private static BlocksRemoveInfo isStartBlock(BlockNode remBlock,BlockNode startBlock){\n  List<InsnNode> remInsns=remBlock.getInstructions();\n  List<InsnNode> startInsns=startBlock.getInstructions();\n  if (remInsns.size() < startInsns.size()) {\n    return null;\n  }\n  int startPos=remInsns.size() - startInsns.size();\n  int endPos=0;\n  if (!checkInsns(remInsns,startInsns,startPos,null)) {\n    if (checkInsns(remInsns,startInsns,0,null)) {\n      startPos=0;\n      endPos=startInsns.size();\n    }\n else {\n      boolean found=false;\n      for (int i=1; i < startPos; i++) {\n        if (checkInsns(remInsns,startInsns,i,null)) {\n          startPos=i;\n          endPos=startInsns.size() + i;\n          found=true;\n          break;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n  }\n  BlocksPair startPair=new BlocksPair(remBlock,startBlock);\n  BlocksRemoveInfo removeInfo=new BlocksRemoveInfo(startPair);\n  removeInfo.setStartSplitIndex(startPos);\n  removeInfo.setEndSplitIndex(endPos);\n  if (endPos != 0) {\n    removeInfo.setEnd(startPair);\n  }\n  if (!checkInsns(remInsns,startInsns,startPos,removeInfo)) {\n    return null;\n  }\n  return removeInfo;\n}\n", "docstring": "\"'\" finally \"'\" instructions can start in the middle of the first block .", "partition": "test"}
{"idx": "5556", "code": "public boolean checkError(){\n  return pw.checkError();\n}\n", "docstring": "checks to see if the there has been an error in the printstream .", "partition": "test"}
{"idx": "5557", "code": "public List<PdfDocument> splitBySize(long size){\n  List<PageRange> splitRanges=new ArrayList<>();\n  int currentPage=1;\n  int numOfPages=pdfDocument.getNumberOfPages();\n  while (currentPage <= numOfPages) {\n    PageRange nextRange=getNextRange(currentPage,numOfPages,size);\n    splitRanges.add(nextRange);\n    List<Integer> allPages=nextRange.getAllPages();\n    currentPage=(int)allPages.get(allPages.size() - 1) + 1;\n  }\n  return extractPageRanges(splitRanges);\n}\n", "docstring": "splits the document basing on the given size .", "partition": "test"}
{"idx": "5558", "code": "private boolean validateAuthSchemes(Set authSchemeSet) throws PolicyException {\n  if (authSchemeSet.isEmpty()) {\n    String args[]={AUTH_SCHEME};\n    throw new PolicyException(ResBundleUtils.rbName,\"property_does_not_allow_empty_values\",args,null);\n  }\n  Iterator authSchemeSetIter=authSchemeSet.iterator();\n  authSchemes.clear();\n  while (authSchemeSetIter.hasNext()) {\n    try {\n      String authScheme=(String)authSchemeSetIter.next();\n      authSchemes.add(authScheme);\n    }\n catch (    ClassCastException e) {\n      String args[]={AUTH_SCHEME};\n      throw new PolicyException(ResBundleUtils.rbName,\"property_is_not_a_String\",args,null);\n    }\n  }\n  return true;\n}\n", "docstring": "validates the module instance names provided to the setproperties ( ) call for the auth_scheme key . checks for null and throws exception if null or not a string .", "partition": "test"}
{"idx": "5559", "code": "public static UUID fromUUIDAsURNStringToUUID(String UUIDasURN){\n  if (!UUIDasURN.startsWith(UUIDHelper.UUID_as_a_URN_PREFIX)) {\n    IMFErrorLogger imfErrorLogger=new IMFErrorLoggerImpl();\n    imfErrorLogger.addError(IMFErrorLogger.IMFErrors.ErrorCodes.UUID_ERROR,IMFErrorLogger.IMFErrors.ErrorLevels.FATAL,String.format(\"Input UUID %s \" + \"does not start with %s\",UUIDasURN,UUIDHelper.UUID_as_a_URN_PREFIX));\n    throw new IMFException(String.format(\"Input UUID %s does not start with %s\",UUIDasURN,UUIDHelper.UUID_as_a_URN_PREFIX),imfErrorLogger);\n  }\n  return UUID.fromString(UUIDasURN.split(UUIDHelper.UUID_as_a_URN_PREFIX)[1]);\n}\n", "docstring": "a helper method to return the uuid without the \" urn : uuid : \" prefix", "partition": "test"}
{"idx": "5560", "code": "public String readLine(){\n  String line;\n  try {\n    line=scanner.nextLine();\n  }\n catch (  NoSuchElementException e) {\n    line=null;\n  }\n  return line;\n}\n", "docstring": "reads and returns the next line in this input stream .", "partition": "test"}
{"idx": "5561", "code": "public static byte[] decode(final String s){\n  return Base64.decode(s,Base64.NO_OPTIONS);\n}\n", "docstring": "decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .", "partition": "test"}
{"idx": "5562", "code": "public static GradientPaint makeRedPaint(final double width,final double height){\n  return new GradientPaint(0f,0f,new Color(200,50,50),(float)width / 2,(float)height / 2,new Color(255,100,100),true);\n}\n", "docstring": "creates a red gradient paint .", "partition": "test"}
{"idx": "5563", "code": "public static List<String> matchNumbers(String text){\n  String pattern=\"\\\\d+[0-9]+\";\n  Pattern pat=Pattern.compile(pattern);\n  Matcher m=pat.matcher(text);\n  List<String> matches=new ArrayList<String>();\n  while (m.find()) {\n    matches.add(m.group());\n  }\n  return matches;\n}\n", "docstring": "returns a list of all numbers found in a given string .", "partition": "test"}
{"idx": "5564", "code": "private boolean deleteStorage(TrackerServer trackerServer,String groupName,String storageIpAddr) throws IOException {\n  byte[] header;\n  byte[] bGroupName;\n  byte[] bs;\n  int len;\n  Socket trackerSocket;\n  trackerSocket=trackerServer.getSocket();\n  OutputStream out=trackerSocket.getOutputStream();\n  bs=groupName.getBytes(ClientGlobal.g_charset);\n  bGroupName=new byte[ProtoCommon.FDFS_GROUP_NAME_MAX_LEN];\n  if (bs.length <= ProtoCommon.FDFS_GROUP_NAME_MAX_LEN) {\n    len=bs.length;\n  }\n else {\n    len=ProtoCommon.FDFS_GROUP_NAME_MAX_LEN;\n  }\n  Arrays.fill(bGroupName,(byte)0);\n  System.arraycopy(bs,0,bGroupName,0,len);\n  int ipAddrLen;\n  byte[] bIpAddr=storageIpAddr.getBytes(ClientGlobal.g_charset);\n  if (bIpAddr.length < ProtoCommon.FDFS_IPADDR_SIZE) {\n    ipAddrLen=bIpAddr.length;\n  }\n else {\n    ipAddrLen=ProtoCommon.FDFS_IPADDR_SIZE - 1;\n  }\n  header=ProtoCommon.packHeader(ProtoCommon.TRACKER_PROTO_CMD_SERVER_DELETE_STORAGE,ProtoCommon.FDFS_GROUP_NAME_MAX_LEN + ipAddrLen,(byte)0);\n  byte[] wholePkg=new byte[header.length + bGroupName.length + ipAddrLen];\n  System.arraycopy(header,0,wholePkg,0,header.length);\n  System.arraycopy(bGroupName,0,wholePkg,header.length,bGroupName.length);\n  System.arraycopy(bIpAddr,0,wholePkg,header.length + bGroupName.length,ipAddrLen);\n  out.write(wholePkg);\n  ProtoCommon.RecvPackageInfo pkgInfo=ProtoCommon.recvPackage(trackerSocket.getInputStream(),ProtoCommon.TRACKER_PROTO_CMD_RESP,0);\n  this.errno=pkgInfo.errno;\n  return pkgInfo.errno == 0;\n}\n", "docstring": "delete a storage server from the tracker server", "partition": "test"}
{"idx": "5565", "code": "@Override public UUID createEntryNode(UUID parentNode){\n  UUID uuid=UUID.randomUUID();\n  graphServer.addVertex(uuid);\n  graphServer.addEdge(uuid,parentNode);\n  return uuid;\n}\n", "docstring": "creates a node that accepts input into the routing network can only connect to one other node", "partition": "test"}
{"idx": "5566", "code": "protected void assertDeliveryStates(final Collection<CustomerOrderDelivery> deliveries,final Map<String,String> expectedState){\n  for (  CustomerOrderDelivery delivery : deliveries) {\n    assertEquals(\"Delivery \" + delivery.getDeliveryGroup() + \", no \"+ delivery.getDeliveryNum(),expectedState.get(delivery.getDeliveryGroup()),delivery.getDeliveryStatus());\n  }\n}\n", "docstring": "assert delivery state by delivery group .", "partition": "test"}
{"idx": "5567", "code": "@Nullable private CompileScope createFacetsCompileScope(@NotNull final CompilerManager compilerManager,@NotNull final VirtualFile[] files){\n  final Set<Module> modules=New.set();\n  boolean facetsFound=false;\n  for (  final VirtualFile file : files) {\n    final Module module=ModuleUtilCore.findModuleForFile(file,project);\n    if (module != null) {\n      modules.add(module);\n      if (!facetsFound) {\n        facetsFound=hasFacets(module);\n      }\n    }\n  }\n  if (facetsFound) {\n    return compilerManager.createModulesCompileScope(modules.toArray(Module.EMPTY_ARRAY),true,true);\n  }\n  return null;\n}\n", "docstring": "it seems that createfilescompilescope does not work in all environments , at least with android , see https : / / intellij - support . jetbrains . com / hc / en - us / community / posts / 207521525 - compilermanager - make - does - not - all - tasks - in - case - of - a - android - module - project < p > we choose a very defensive solution and use createmodulescompilescope when we detect a facet .", "partition": "test"}
{"idx": "5568", "code": "@Nullable @WorkerThread static File writeBitmapToFile(@NonNull Bitmap bitmap,@NonNull File file){\n  FileOutputStream fileStream=null;\n  try {\n    ByteArrayOutputStream byteStream=new ByteArrayOutputStream();\n    bitmap.compress(Bitmap.CompressFormat.PNG,0,byteStream);\n    fileStream=new FileOutputStream(file);\n    fileStream.write(byteStream.toByteArray());\n    return file;\n  }\n catch (  IOException e) {\n    Log.e(TAG,e.getMessage(),e);\n  }\n finally {\n    if (fileStream != null) {\n      try {\n        fileStream.close();\n      }\n catch (      IOException e) {\n        Log.e(TAG,e.getMessage(),e);\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "writes the bitmap to disk and returns the new file .", "partition": "test"}
{"idx": "5569", "code": "public static Sentence parse(final String text,final ConversationContext ctx){\n  String txt;\n  if (text == null) {\n    txt=\"\";\n  }\n else {\n    if ((ctx != null) && ctx.isForMatching()) {\n      final ExpressionMatcher matcher=new ExpressionMatcher();\n      txt=matcher.readMatchingFlags(text);\n      if (matcher.isAnyFlagSet()) {\n        return matcher.parseSentence(txt,ctx);\n      }\n    }\n else {\n      txt=text;\n    }\n  }\n  txt=txt.trim();\n  final SentenceImplementation sentence=new SentenceImplementation(ctx,txt);\n  try {\n    final ConversationParser parser=new ConversationParser(sentence);\n    sentence.parse(parser);\n    sentence.classifyWords(parser);\n    if ((ctx != null) && ctx.getMergeExpressions()) {\n      sentence.evaluateSentenceType();\n      sentence.mergeWords();\n      if (!ctx.isForMatching()) {\n        sentence.standardizeSentenceType();\n        sentence.performaAliasing();\n      }\n    }\n    sentence.setError(parser.getErrorString());\n  }\n catch (  final Exception e) {\n    LOGGER.error(\"ConversationParser.parse(): caught Exception while parsing \'\" + text + \'\\\'\');\n    sentence.setError(e.getMessage());\n    e.printStackTrace();\n  }\n  return sentence;\n}\n", "docstring": "parse the given text sentence .", "partition": "test"}
{"idx": "5570", "code": "protected int hash(Object key1,Object key2,Object key3){\n  int h=0;\n  if (key1 != null) {\n    h^=key1.hashCode();\n  }\n  if (key2 != null) {\n    h^=key2.hashCode();\n  }\n  if (key3 != null) {\n    h^=key3.hashCode();\n  }\n  h+=~(h << 9);\n  h^=(h >>> 14);\n  h+=(h << 4);\n  h^=(h >>> 10);\n  return h;\n}\n", "docstring": "gets the hash code for the specified multi - key .", "partition": "test"}
{"idx": "5571", "code": "public void flush() throws IOException {\n  flushBuffer();\n  _outputStream.flush();\n}\n", "docstring": "flushes the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .", "partition": "test"}
{"idx": "5572", "code": "private void addEntryToInfoList(Entry entry,List<EntryInfo> entryInfoList){\n  if (entryInfoList != null) {\n    String typeToAdd=entry.getType();\n    if (typeToAdd.equals(DbLogic.Constants.quotation)) {\n      typeToAdd=DbLogic.Constants.note;\n    }\n    entryInfoList.add(new EntryInfo(entry.getId(),entry.getNoteOrTitle(\"\"),entry.getQuotation(\"\"),entry.getIsPublic(),entry.hasFirstChildId(),entry.hasParentId(),typeToAdd));\n  }\n}\n", "docstring": "adds the entry to the entry list .", "partition": "test"}
{"idx": "5573", "code": "private void updateSliding(float newPositionNormalized){\n  currentSlide=newPositionNormalized;\n  state=currentSlide == 1 ? EXPANDED : currentSlide == 0 ? COLLAPSED : SLIDING;\n  float slideY=Math.abs((currentSlide * maxSlide) - maxSlide);\n  slidableView.setY(slideY);\n  invalidate();\n  notifyListeners(currentSlide);\n}\n", "docstring": "always use this method to update the position of the sliding view .", "partition": "test"}
{"idx": "5574", "code": "void flush(VcfWriter writer) throws IOException {\n  if (mPrevRecord != null) {\n    if (!mPrevDense) {\n      writeCount(writer,mPrevRecord);\n    }\n else {\n      mVcfFilterStatistics.increment(Stat.DENSITY_WINDOW_COUNT);\n    }\n  }\n  mPrevRecord=null;\n  mPrevDense=false;\n}\n", "docstring": "writes any remaining snp lines", "partition": "test"}
{"idx": "5575", "code": "public boolean equals(String str){\n  if (str == null)   return false;\n  if (_length != str.length())   return false;\n  for (int i=_length, j=_offset + _length; --i >= 0; ) {\n    if (_array[--j] != str.charAt(i))     return false;\n  }\n  return true;\n}\n", "docstring": "compares this character array against the specified string . in case of equality , the chararray keeps a reference to the string for future comparisons .", "partition": "test"}
{"idx": "5576", "code": "protected void flush(){\n  stream.flush();\n}\n", "docstring": "flushes any buffered output .", "partition": "test"}
{"idx": "5577", "code": "private ServerStarter startServers() throws Exception {\n  ServerStarter srvStarter=new ServerStarter();\n  Thread t=new Thread(srvStarter);\n  t.setDaemon(true);\n  t.setName(\"Server Starter\");\n  t.start();\n  srvStarter.waitForServerStart();\n  return srvStarter;\n}\n", "docstring": "starts background thread that launches servers . this method will block until at least one server is running .", "partition": "test"}
{"idx": "5578", "code": "public Pagination evaluate(final Class entityClass){\n  Paginate paginate=entityClass != null ? (Paginate)entityClass.getAnnotation(Paginate.class) : null;\n  int defaultLimit=paginate != null ? paginate.defaultLimit() : DEFAULT_PAGE_LIMIT;\n  int maxLimit=paginate != null ? paginate.maxLimit() : MAX_PAGE_LIMIT;\n  evaluate(defaultLimit,maxLimit);\n  generateTotals=generateTotals && (paginate == null || paginate.countable());\n  return this;\n}\n", "docstring": "evaluates the pagination variables . uses the paginate annotation if it has been set for the entity to be queried .", "partition": "test"}
{"idx": "5579", "code": "public boolean deregisterServiceProvider(Object provider){\n  Object oprovider=map.get(provider.getClass());\n  if (provider == oprovider) {\n    map.remove(provider.getClass());\n    poset.remove(provider);\n    if (provider instanceof RegisterableService) {\n      RegisterableService rs=(RegisterableService)provider;\n      rs.onDeregistration(registry,category);\n    }\n    return true;\n  }\n  return false;\n}\n", "docstring": "if the provider was not previously registered , do nothing .", "partition": "test"}
{"idx": "5580", "code": "public NewestFirstComparator(Date now){\n  Preconditions.checkNotNull(now);\n  mNow=new Date(now.getTime() + MILLIS_IN_DAY);\n}\n", "docstring": "construct a comparator that sorts items by newest first . we ignore future creation dates using the supplied current date as a baseline .", "partition": "test"}
{"idx": "5581", "code": "protected void update(Comparable x,Object y){\n  int index=indexOf(x);\n  if (index < 0) {\n    throw new SeriesException(\"No observation for x = \" + x);\n  }\n else {\n    ComparableObjectItem item=getDataItem(index);\n    item.setObject(y);\n    fireSeriesChanged();\n  }\n}\n", "docstring": "updates an item in the series .", "partition": "test"}
{"idx": "5582", "code": "public void writeField(String name,float value) throws java.io.IOException {\n  writeField(name,Float.toString(value));\n}\n", "docstring": "writes an float field value .", "partition": "test"}
{"idx": "5583", "code": "public byte[] decodeData(byte[] data,int numErrorCorrectionBytes) throws ReedSolomonException, DataTooLargeException {\n  if (data == null || data.length == 0) {\n    return null;\n  }\n  if (data.length > 256) {\n    throw new DataTooLargeException(\"Data exceeds 256 bytes! Too large\");\n  }\n  int[] dataInts=new int[data.length];\n  for (int i=0; i < data.length; i++) {\n    dataInts[i]=data[i] & 0xFF;\n  }\n  int totalBytes=data.length - numErrorCorrectionBytes;\n  decoder.decode(dataInts,numErrorCorrectionBytes);\n  ByteArrayOutputStream bos=new ByteArrayOutputStream();\n  for (int i=0; i < totalBytes && i < dataInts.length; i++) {\n    bos.write(dataInts[i]);\n  }\n  return bos.toByteArray();\n}\n", "docstring": "repairs and decodes the supplied byte array , removing the error correction codes and returning the original data", "partition": "test"}
{"idx": "5584", "code": "void removeAllViewsFromAdapter(ViewPager pager){\n  mViews.clear();\n  pager.removeAllViews();\n  mIsViewPagerInIntentionallyInconsistentState=true;\n}\n", "docstring": "remove all the views from the adapter and de - parents them from the viewpager after calling this , it is expected that notifydatasetchanged should be called soon afterwards .", "partition": "test"}
{"idx": "5585", "code": "public static boolean isValidMobile(@NonNull String mobile){\n  if (!TextUtils.isEmpty(mobile) && mobile.length() == 10) {\n    if (mobile.startsWith(\"9\") || mobile.startsWith(\"8\") || mobile.startsWith(\"7\")) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "method to check valid malaysia mobile number", "partition": "test"}
{"idx": "5586", "code": "public String convertError(String filename,int line,int column,String message){\n  String srcFilename=null;\n  int destLine=0;\n  int srcLine=0;\n  for (int i=0; i < _lines.size(); i++) {\n    Line map=_lines.get(i);\n    if (filename != null && !filename.endsWith(_dstFilename)) {\n    }\n else     if (map._dstLine <= line && line <= map.getLastDestinationLine()) {\n      srcFilename=map._srcFilename;\n      srcLine=map.getSourceLine(line);\n    }\n  }\n  if (srcFilename != null)   return srcFilename + \":\" + srcLine+ \": \"+ message;\n else   return filename + \":\" + line+ \": \"+ message;\n}\n", "docstring": "converts an error in the generated file to a compileerror based on the source .", "partition": "test"}
{"idx": "5587", "code": "public void addNotification(@NotNull Notification notification){\n  NotificationItem item=new NotificationItem(resources,notification,delegate,panel);\n  notificationWidget.add(notification);\n}\n", "docstring": "show notification in container .", "partition": "test"}
{"idx": "5588", "code": "protected boolean isAttributesModified(){\n  if (attributes != null) {\n    return (attributes.isEmpty()) ? false : true;\n  }\n  return false;\n}\n", "docstring": "have the attributes of this service schema been modified", "partition": "test"}
{"idx": "5589", "code": "@Nullable public static IgnoreDescriptor forMethod(Class cls,Method mthd){\n  if (mthd.isAnnotationPresent(IgniteIgnore.class)) {\n    IgniteIgnore ignore=mthd.getAnnotation(IgniteIgnore.class);\n    String reason=ignore.value();\n    if (F.isEmpty(reason))     throw new IllegalArgumentException(\"Reason is not set for ignored test [class=\" + cls.getName() + \", method=\"+ mthd.getName()+ \']\');\n    return new IgnoreDescriptor(reason,ignore.forceFailure());\n  }\n else   return null;\n}\n", "docstring": "get descriptor for method ( if any ) .", "partition": "test"}
{"idx": "5590", "code": "public static ModifiableDBIDs randomSample(DBIDs source,int k,Random random){\n  if (k < 0 || k > source.size()) {\n    throw new IllegalArgumentException(\"Illegal value for size of random sample: \" + k + \" > \"+ source.size()+ \" or < 0\");\n  }\n  if (random == null) {\n    random=new FastNonThreadsafeRandom();\n  }\n  if (k < source.size() >> 1) {\n    ArrayDBIDs aids=DBIDUtil.ensureArray(source);\n    DBIDArrayIter iter=aids.iter();\n    HashSetModifiableDBIDs sample=DBIDUtil.newHashSet(k);\n    while (sample.size() < k) {\n      iter.seek(random.nextInt(aids.size()));\n      sample.add(iter);\n    }\n    return sample;\n  }\n else {\n    ArrayModifiableDBIDs sample=DBIDUtil.newArray(source);\n    randomShuffle(sample,random,k);\n    for (int i=sample.size() - 1; i >= k; i--) {\n      sample.remove(i);\n    }\n    return sample;\n  }\n}\n", "docstring": "produce a random sample of the given dbids .", "partition": "test"}
{"idx": "5591", "code": "protected int drawMessageSize(){\n  int sizeDiff=sizeRange[0] == sizeRange[1] ? 0 : rng.nextInt(sizeRange[1] - sizeRange[0]);\n  return sizeRange[0] + sizeDiff;\n}\n", "docstring": "generates a ( random ) message size", "partition": "test"}
{"idx": "5592", "code": "public static String[] grabArgs(String signature){\n  Matcher matcher=sigRE.matcher(signature);\n  boolean b=matcher.matches();\n  if (!b && matcher.groupCount() != 4)   logger.error(\"Bad method signature: {}\",signature);\n  String args=matcher.group(4);\n  if (args.isEmpty())   return new String[0];\n  return args.split(\",\");\n}\n", "docstring": "grab the args string from the method signature", "partition": "test"}
{"idx": "5593", "code": "public void processDispatch(UniformPair<EventBean[]> events){\n  if (!forClauseDelivery) {\n    dispatchInternal(events);\n    return;\n  }\n  if ((groupDeliveryExpressions == null) || (groupDeliveryExpressions.length == 0)) {\n    UniformPair<EventBean[]> todeliver=new UniformPair<EventBean[]>(null,null);\n    if (events != null) {\n      if (events.getFirst() != null) {\n        for (        EventBean theEvent : events.getFirst()) {\n          todeliver.setFirst(new EventBean[]{theEvent});\n          dispatchInternal(todeliver);\n        }\n        todeliver.setFirst(null);\n      }\n      if (events.getSecond() != null) {\n        for (        EventBean theEvent : events.getSecond()) {\n          todeliver.setSecond(new EventBean[]{theEvent});\n          dispatchInternal(todeliver);\n        }\n        todeliver.setSecond(null);\n      }\n    }\n    return;\n  }\n  Map<Object,UniformPair<EventBean[]>> groups;\n  try {\n    groups=getGroupedResults(events);\n  }\n catch (  RuntimeException ex) {\n    log.error(\"Unexpected exception evaluating grouped-delivery expressions: \" + ex.getMessage() + \", delivering ungrouped\",ex);\n    dispatchInternal(events);\n    return;\n  }\n  for (  Map.Entry<Object,UniformPair<EventBean[]>> group : groups.entrySet()) {\n    dispatchInternal(group.getValue());\n  }\n}\n", "docstring": "indicate an outbound result .", "partition": "test"}
{"idx": "5594", "code": "public V put(K key,V value){\n  final int hash;\n  int index;\n  if (key == null) {\n    hash=0;\n    index=indexOfNull();\n  }\n else {\n    hash=key.hashCode();\n    index=indexOf(key,hash);\n  }\n  if (index >= 0) {\n    index=(index << 1) + 1;\n    final V old=(V)mArray[index];\n    mArray[index]=value;\n    return old;\n  }\n  index=~index;\n  if (mSize >= mHashes.length) {\n    final int n=mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);\n    final int[] ohashes=mHashes;\n    final Object[] oarray=mArray;\n    allocArrays(n);\n    if (mHashes.length > 0) {\n      System.arraycopy(ohashes,0,mHashes,0,ohashes.length);\n      System.arraycopy(oarray,0,mArray,0,oarray.length);\n    }\n    freeArrays(ohashes,oarray,mSize);\n  }\n  if (index < mSize) {\n    System.arraycopy(mHashes,index,mHashes,index + 1,mSize - index);\n    System.arraycopy(mArray,index << 1,mArray,(index + 1) << 1,(mSize - index) << 1);\n  }\n  mHashes[index]=hash;\n  mArray[index << 1]=key;\n  mArray[(index << 1) + 1]=value;\n  mSize++;\n  return null;\n}\n", "docstring": "add a new value to the array map .", "partition": "test"}
{"idx": "5595", "code": "public void putLong(long pos,long val){\n  unsafe.putLong(pos + addr,val);\n}\n", "docstring": "writes a long to the specified position .", "partition": "test"}
{"idx": "5596", "code": "public boolean deleteRSetStep(URI rpSystemId,List<URI> volumeIds,String token) throws InternalException {\n  List<String> replicationSetNames=new ArrayList<String>();\n  try {\n    List<RecoverPointVolumeProtectionInfo> volumeProtectionInfoList=new ArrayList<RecoverPointVolumeProtectionInfo>();\n    ProtectionSystem rpSystem=_dbClient.queryObject(ProtectionSystem.class,rpSystemId);\n    RecoverPointClient rp=RPHelper.getRecoverPointClient(rpSystem);\n    for (    URI volumeId : volumeIds) {\n      Volume volume=_dbClient.queryObject(Volume.class,volumeId);\n      RecoverPointVolumeProtectionInfo volumeProtectionInfo=rp.getProtectionInfoForVolume(RPHelper.getRPWWn(volume.getId(),_dbClient));\n      Volume sourceVolume=RPHelper.getRPSourceVolume(_dbClient,volume);\n      VirtualPool virtualPool=_dbClient.queryObject(VirtualPool.class,sourceVolume.getVirtualPool());\n      volumeProtectionInfo.setMetroPoint(VirtualPool.vPoolSpecifiesMetroPoint(virtualPool));\n      volumeProtectionInfoList.add(volumeProtectionInfo);\n      replicationSetNames.add(volume.getRSetName());\n    }\n    if (!volumeProtectionInfoList.isEmpty()) {\n      rp.deleteReplicationSets(volumeProtectionInfoList);\n    }\n    WorkflowStepCompleter.stepSucceded(token);\n  }\n catch (  Exception e) {\n    _log.error(String.format(\"deleteRSetStep Failed - Replication Sets: %s\",replicationSetNames.toString()));\n    return stepFailed(token,e,\"deleteRSetStep\");\n  }\n  return true;\n}\n", "docstring": "delete the replication set", "partition": "test"}
{"idx": "5597", "code": "private void moveToNext(){\n  checkMainThread();\n  scheduled.set(false);\n  Bitmap next=pending.poll();\n  if (next != null) {\n    if (current != null && !finished.offer(current))     throw new RuntimeException(\"Could not add image to finished queue\");\n    current=next;\n    invalidateSelf();\n    ensureScheduled();\n    frameAvailableSubject.onNext(null);\n    fpsCounter.update();\n  }\n}\n", "docstring": "called to move to the next frame . this method will be called on the ui thread and must not block ! .", "partition": "test"}
{"idx": "5598", "code": "public String rma(Properties ctx,int WindowNo,GridTab mTab,GridField mField,Object value){\n  Integer M_RMA_ID=(Integer)value;\n  if (M_RMA_ID == null || M_RMA_ID.intValue() == 0)   return \"\";\n  if (isCalloutActive())   return \"\";\n  MRMA rma=new MRMA(ctx,M_RMA_ID.intValue(),null);\n  MInOut originalReceipt=rma.getShipment();\n  if (rma.get_ID() != 0) {\n    mTab.setValue(\"DateOrdered\",originalReceipt.getDateOrdered());\n    mTab.setValue(\"POReference\",originalReceipt.getPOReference());\n    mTab.setValue(\"AD_Org_ID\",new Integer(originalReceipt.getAD_Org_ID()));\n    mTab.setValue(\"AD_OrgTrx_ID\",new Integer(originalReceipt.getAD_OrgTrx_ID()));\n    mTab.setValue(\"C_Activity_ID\",new Integer(originalReceipt.getC_Activity_ID()));\n    mTab.setValue(\"C_Campaign_ID\",new Integer(originalReceipt.getC_Campaign_ID()));\n    mTab.setValue(\"C_Project_ID\",new Integer(originalReceipt.getC_Project_ID()));\n    mTab.setValue(\"User1_ID\",new Integer(originalReceipt.getUser1_ID()));\n    mTab.setValue(\"User2_ID\",new Integer(originalReceipt.getUser2_ID()));\n    mTab.setValue(\"M_Warehouse_ID\",new Integer(originalReceipt.getM_Warehouse_ID()));\n    mTab.setValue(\"DeliveryRule\",originalReceipt.getDeliveryRule());\n    mTab.setValue(\"DeliveryViaRule\",originalReceipt.getDeliveryViaRule());\n    mTab.setValue(\"M_Shipper_ID\",new Integer(originalReceipt.getM_Shipper_ID()));\n    mTab.setValue(\"FreightCostRule\",originalReceipt.getFreightCostRule());\n    mTab.setValue(\"FreightAmt\",originalReceipt.getFreightAmt());\n    mTab.setValue(\"C_BPartner_ID\",new Integer(originalReceipt.getC_BPartner_ID()));\n    mTab.setValue(\"C_BPartner_Location_ID\",new Integer(originalReceipt.getC_BPartner_Location_ID()));\n    if (originalReceipt.getAD_User_ID() > 0)     mTab.setValue(\"AD_User_ID\",new Integer(originalReceipt.getAD_User_ID()));\n else     mTab.setValue(\"AD_User_ID\",null);\n  }\n  return \"\";\n}\n", "docstring": "m_rma - rma defaults .", "partition": "test"}
{"idx": "5599", "code": "public final long readLong() throws java.io.IOException {\n  readFully(scratch,0,8);\n  int h=((scratch[0] & 0xff) << 24) | ((scratch[1] & 0xff) << 16) | ((scratch[2] & 0xff) << 8)| ((scratch[3] & 0xff) << 0);\n  int l=((scratch[4] & 0xff) << 24) | ((scratch[5] & 0xff) << 16) | ((scratch[6] & 0xff) << 8)| ((scratch[7] & 0xff) << 0);\n  return (((long)h) << 32L) | ((long)l) & 0xffffffffL;\n}\n", "docstring": "see the general contract of the readlong method of datainput . bytes for this operation are read from the contained input stream .", "partition": "test"}
{"idx": "5600", "code": "public void testGetColumnsMetaData() throws Exception {\n  DatabaseMetaData dmd=con.getMetaData();\n  ResultSet rs=dmd.getColumns(null,null,\"Table doesn\'t exist\",null);\n  assertNotNull(rs);\n  ResultSetMetaData rsmd=rs.getMetaData();\n  assertNotNull(rsmd.getCatalogName(1));\n  assertNotNull(rsmd.getColumnClassName(1));\n  rsmd.getColumnCount();\n  assertTrue(0 != rsmd.getColumnDisplaySize(1));\n  assertNotNull(rsmd.getColumnLabel(1));\n  assertNotNull(rsmd.getColumnName(1));\n  rsmd.getColumnType(1);\n  assertNotNull(rsmd.getColumnTypeName(1));\n  rsmd.getPrecision(1);\n  rsmd.getScale(1);\n  assertNotNull(rsmd.getSchemaName(1));\n  assertNotNull(rsmd.getTableName(1));\n  rsmd.isAutoIncrement(1);\n  rsmd.isCaseSensitive(1);\n  rsmd.isCurrency(1);\n  rsmd.isDefinitelyWritable(1);\n  rsmd.isNullable(1);\n  rsmd.isReadOnly(1);\n  rsmd.isSearchable(1);\n  rsmd.isSigned(1);\n  rsmd.isWritable(1);\n  rs.close();\n}\n", "docstring": "test for bug [ 1120168 ", "partition": "test"}
{"idx": "5601", "code": "public String toString(){\n  return super.toString() + \"{recordCount=\" + recordMap.size()+ \",firstOffset=\"+ firstOffset+ \",releaseBuffer=\"+ releaseBuffer+ \",prefixWrites=\"+ prefixWrites+ \",useChecksum=\"+ useChecksum+ \",bytesWritten=\"+ bytesWritten()+ \",bytesRemaining=\"+ remaining()+ \",bytesRemoved=\"+ m_removed+ \"}\";\n}\n", "docstring": "adds some debugging information .", "partition": "test"}
{"idx": "5602", "code": "private void handleJsonCreateAccount(RequestAndResponse requestAndResponse) throws IOException, ServletException {\n  requestAndResponse.setResponseContentTypeJson();\n  String userName, password, password2, email;\n  boolean mayContact=false;\n  String csrft;\n  try {\n    final JsonNodeHelper json=getJsonNode(requestAndResponse);\n    userName=json.getString(\"username\");\n    password=json.getString(\"password\");\n    password2=json.getString(\"password2\");\n    email=json.getString(\"email\");\n    mayContact=json.getBoolean(\"mayContact\");\n    csrft=json.getString(\"csrft\");\n  }\n catch (  final IOException e) {\n    returnJson400(requestAndResponse,servletText.errorJson());\n    return;\n  }\n  if (userName != null) {\n    userName=userName.toLowerCase();\n  }\n  if (isTheCsrftWrong(requestAndResponse,csrft)) {\n    returnJson400(requestAndResponse,servletText.errorWrongCsrft());\n    return;\n  }\n  if (!allowSelfSignUp) {\n    returnJson400(requestAndResponse,servletText.errorSelfSignUpNotAllowed());\n    return;\n  }\n  if (userName == null || userName.isEmpty()) {\n    returnJson400(requestAndResponse,servletText.errorUsernameMustNotBeBlank());\n    return;\n  }\n  if (password == null || password.isEmpty()) {\n    returnJson400(requestAndResponse,servletText.errorFirstPasswordMustBeSet(true,null));\n    return;\n  }\n  if (password == null || password2.isEmpty()) {\n    returnJson400(requestAndResponse,servletText.errorSecondPasswordMustBeSet(true,null));\n    return;\n  }\n  if (!password2.equals(password)) {\n    returnJson400(requestAndResponse,servletText.errorPasswordsMustMatch());\n    return;\n  }\n  if (!AccountAttributeValidator.isUserNameValid(userName)) {\n    returnJson400(requestAndResponse,servletText.errorUserNameIsNotValid());\n    return;\n  }\n  if (!AccountAttributeValidator.isPasswordValid(password)) {\n    returnJson400(requestAndResponse,servletText.errorPasswordIsNotValid());\n    return;\n  }\n  if (email != null && email.isEmpty()) {\n    email=null;\n  }\n  if (email != null && !AccountAttributeValidator.isEmailValid(email)) {\n    returnJson400(requestAndResponse,servletText.errorEmailIsNotValid());\n    return;\n  }\n  try {\n    User user=dbLogic.getUserByUserName(userName);\n    if (user != null) {\n      returnJson400(requestAndResponse,servletText.errorUserNameIsAlreadyTaken());\n      return;\n    }\n    user=dbLogic.createUser(userName);\n    if (user == null) {\n      returnJson400(requestAndResponse,servletText.errorCouldNotCreateAccount());\n      return;\n    }\n    user.setPassword(DigestUtils.sha1Hex(password));\n    user.setEmail(email);\n    user.setMayContact(mayContact);\n    mapSessionToUser(requestAndResponse,user.getId());\n    dbLogic.commit();\n    returnJson200(requestAndResponse);\n  }\n catch (  final PersistenceException e) {\n    logger.log(Level.INFO,\"Exception\",e);\n    returnJson500(requestAndResponse,servletText.errorInternalDatabase());\n  }\n}\n", "docstring": "part of the json api . handles sign in requests .", "partition": "test"}
{"idx": "5603", "code": "private Object[] resolveParameters(Executable executable,Optional<Object> target,Object outerInstance,ExtensionContext extensionContext,ExtensionRegistry extensionRegistry){\n  Preconditions.notNull(target,\"target must not be null\");\n  Parameter[] parameters=executable.getParameters();\n  Object[] values=new Object[parameters.length];\n  int start=0;\n  if (outerInstance != null) {\n    values[0]=outerInstance;\n    start=1;\n  }\n  for (int i=start; i < parameters.length; i++) {\n    ParameterContext parameterContext=new DefaultParameterContext(parameters[i],i,target);\n    values[i]=resolveParameter(parameterContext,executable,extensionContext,extensionRegistry);\n  }\n  return values;\n}\n", "docstring": "resolve the array of parameters for the supplied executable , target , and outer instance .", "partition": "test"}
{"idx": "5604", "code": "public static boolean isValidNameChar(char c){\n  return isValidNameStartChar(c) || (c >= '0' && c <= '9');\n}\n", "docstring": "check whether the given char can be one of a name", "partition": "test"}
{"idx": "5605", "code": "protected static boolean id_start_char(int ch){\n  return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_');\n}\n", "docstring": "determine if a character is ok to start an id .", "partition": "test"}
{"idx": "5606", "code": "public int hashCode(){\n  int fhash=(family != null) ? family.hashCode() : 0;\n  return fhash ^ style ^ size;\n}\n", "docstring": "returns a hashcode for this font .", "partition": "test"}
{"idx": "5607", "code": "private CommandHandlerEnum(final Command command1){\n  this.command=command1;\n}\n", "docstring": "enum contructor to set command .", "partition": "test"}
{"idx": "5608", "code": "public static boolean isFloat(String desc){\n  return desc.endsWith(\"F\");\n}\n", "docstring": "tells whether a given type is a float", "partition": "test"}
{"idx": "5609", "code": "public void componentResized(ComponentEvent e){\n  JScrollBar bar=getVerticalScrollBar();\n  int incr=(int)(getSize().getHeight() - (bar.getUnitIncrement(1) * 3));\n  getVerticalScrollBar().setBlockIncrement(incr);\n}\n", "docstring": "invoked when the component \"'\" s size changes . reset scrollable increment , because page - down / up is relative to current view size .", "partition": "test"}
{"idx": "5610", "code": "public Arg(String aName,String desc,int expectedNumberOfArguments,boolean expectDashedArguments){\n  name=aName;\n  description=desc;\n  numExpectedValues=expectedNumberOfArguments;\n  c=name.charAt(0);\n  dashedArguments=expectDashedArguments;\n}\n", "docstring": "create an arg with a name and help line description , along with a number of expected arguments to follow this option . has an argument to not check for arguments that may start with dashes , in case one of the arguments may be a negative number .", "partition": "test"}
{"idx": "5611", "code": "private boolean remove(Object o,Object[] snapshot,int index){\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    Object[] current=getArray();\n    int len=current.length;\n    if (snapshot != current)     findIndex: {\n      int prefix=Math.min(index,len);\n      for (int i=0; i < prefix; i++) {\n        if (current[i] != snapshot[i] && eq(o,current[i])) {\n          index=i;\n          break findIndex;\n        }\n      }\n      if (index >= len)       return false;\n      if (current[index] == o)       break findIndex;\n      index=indexOf(o,current,index,len);\n      if (index < 0)       return false;\n    }\n    Object[] newElements=new Object[len - 1];\n    System.arraycopy(current,0,newElements,0,index);\n    System.arraycopy(current,index + 1,newElements,index,len - index - 1);\n    setArray(newElements);\n    return true;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "a version of remove ( object ) using the strong hint that given recent snapshot contains o at the given index .", "partition": "test"}
{"idx": "5612", "code": "public void removeModel(Model model){\n  models.remove(model);\n}\n", "docstring": "removes the given model from the container .", "partition": "test"}
{"idx": "5613", "code": "public void readMap(int map_Number){\n  InputStream map_file;\n  try {\n    map_file=new FileInputStream(\"src/Asset/stage0\" + map_Number + \".stg\");\n    try {\n      byte[] data=new byte[map_file.available()];\n      map_file.read(data);\n      map_file.close();\n      String load_data=new String(data,\"EUC-KR\");\n      makeMap(load_data);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n catch (  FileNotFoundException e1) {\n    e1.printStackTrace();\n  }\n}\n", "docstring": "read map information from stage0x . stg", "partition": "test"}
{"idx": "5614", "code": "public static double hoeffdingLn(double trials,double observed,double prob){\n  return -2 * Math.pow(trials * prob - observed,2) / trials;\n}\n", "docstring": "get hoeffding probability number , in ln space", "partition": "test"}
{"idx": "5615", "code": "public void testLocalInstances_deterministic(){\n  MatsimRandom.reset();\n  Random local1a=MatsimRandom.getLocalInstance();\n  Random local1b=MatsimRandom.getLocalInstance();\n  MatsimRandom.reset();\n  Random local2a=MatsimRandom.getLocalInstance();\n  Random local2b=MatsimRandom.getLocalInstance();\n  assertEqualRandomNumberGenerators(local1a,local2a);\n  assertEqualRandomNumberGenerators(local1b,local2b);\n}\n", "docstring": "tests that local instances can be recreated ( = are deterministic ) if the same random seed is used to generate them .", "partition": "test"}
{"idx": "5616", "code": "public void add(Match match,AppliedRegion appliedRegion){\n  add(match,appliedRegion,false);\n}\n", "docstring": "adds a new applied region to the match without a priority .", "partition": "test"}
{"idx": "5617", "code": "public void reset(){\n  techTree.checkSubTree(techTree.getPathForRow(0),true);\n}\n", "docstring": "resets the selection the panel by selecting all technologies .", "partition": "test"}
{"idx": "5618", "code": "@SuppressWarnings(\"unchecked\") private static <T>void assertThrows(final Consumer<Void> consumer,final Class<T> exceptionClass,final Consumer<T> assertExceptionProperties,final String message){\n  final String normalizedMessage=null == message ? \"\" : String.format(\"[%s]: \",message);\n  try {\n    consumer.accept(null);\n  }\n catch (  final Exception ex) {\n    if (exceptionClass.isAssignableFrom(ex.getClass())) {\n      assertExceptionProperties.accept((T)ex);\n      return;\n    }\n    Assert.fail(String.format(\"%sunexpected exception of type %s was thrown: \'%s\'\",normalizedMessage,ex.getClass(),ex.getMessage()));\n  }\n  Assert.fail(String.format(\"%sexpected exception of type %s was not thrown\",normalizedMessage,exceptionClass));\n}\n", "docstring": "asserts that the execution of consumer throws an exception of the specific class .", "partition": "test"}
{"idx": "5619", "code": "public boolean isEmpty(){\n  return nodes.isEmpty() && ways.isEmpty() && relations.isEmpty();\n}\n", "docstring": "return true if this storage is empty", "partition": "test"}
{"idx": "5620", "code": "public static void assertBool(boolean b){\n  if (verbose) {\n    log(\"assertBool(\" + b + \")\");\n  }\n  if (!b) {\n    throw new RuntimeException();\n  }\n}\n", "docstring": "assertions allow for simpler test code", "partition": "test"}
{"idx": "5621", "code": "public TagKeyValueMapConverter(boolean nullIfEmpty,String idKey){\n  Objects.requireNonNull(idKey);\n  this.nullIfEmpty=nullIfEmpty;\n  this.addId=true;\n  this.idKey=idKey;\n}\n", "docstring": "store feature ids using idkey . id value may be null if not present .", "partition": "test"}
{"idx": "5622", "code": "private static void postInit(){\n  debugAll=dbgTable.containsKey(debugAllToken);\n}\n", "docstring": "common inits , regardless of applet or application .", "partition": "test"}
{"idx": "5623", "code": "public static List<File> sortInBatch(File file,Comparator<String> cmp) throws IOException {\n  return sortInBatch(file,cmp,DEFAULTMAXTEMPFILES);\n}\n", "docstring": "this will simply load the file by blocks of x rows , then sort them in - memory , and write the result to temporary files that have to be merged later .", "partition": "test"}
{"idx": "5624", "code": "public void addDirectorySet(Context context,String path){\n  TinyDB tinydb=new TinyDB(context);\n  ArrayList<String> file=tinydb.getListString(\"directories\");\n  file.add(path);\n  tinydb.putListString(\"directories\",file);\n}\n", "docstring": "add directory to scan for saves avatars", "partition": "test"}
{"idx": "5625", "code": "private FastConcurrentSkipListMap.Node<K,V> hiNode(){\n  if (hi == null)   return m.findLast();\n else   if (hiInclusive)   return m.findNear(hi,m.LT | m.EQ);\n else   return m.findNear(hi,m.LT);\n}\n", "docstring": "returns highest node . this node might not be in range , so most usages need to check bounds", "partition": "test"}
{"idx": "5626", "code": "protected void processEventProperties(Properties eventProps){\n  int status;\n  Node node;\n  Line line;\n  String cmd=eventProps.getProperty(COMMAND_FIELD);\n  int index=PropUtils.intFromProperties(eventProps,INDEX_FIELD,ERROR_VALUE_INT);\n  if (cmd.equals(NODE_OBJECT)) {\n    int shape=PropUtils.intFromProperties(eventProps,SHAPE_FIELD,ERROR_VALUE_INT);\n    if (index == ERROR_VALUE_INT) {\n      Debug.error(\"NMGL: error parsing object index for node.\");\n      return;\n    }\n    node=nodeList.get(index);\n    if (shape == 11) {\n      String icon=eventProps.getProperty(ICON_FIELD);\n      if (DEBUG)       Debug.output(\"NetMapReader: jimage  \" + icon);\n    }\n    if (shape == NODE_DELETE) {\n      if (node != null) {\n        lineList.del(node);\n        nodeList.del(node);\n      }\n    }\n else     if (shape == NODE_MOVE && node != null) {\n      setNodePositionFromEventProps(node,eventProps);\n      lineList.move(node);\n      node.setTime(Double.parseDouble(eventProps.getProperty(TIME_FIELD,\"0\")));\n    }\n else {\n      status=PropUtils.intFromProperties(eventProps,STATUS_FIELD,0);\n      int menu=PropUtils.intFromProperties(eventProps,MENU_FIELD,0);\n      String label=eventProps.getProperty(LABEL_FIELD);\n      if (label == null) {\n        label=eventProps.getProperty(INDEX_FIELD);\n      }\n      String ip=eventProps.getProperty(IP_FIELD);\n      boolean isLocalhost=false;\n      if (ip != null && localhostIP != null) {\n        isLocalhost=localhostIP.equals(ip);\n        if (DEBUG) {\n          Debug.output(\"NetMapGraphicLoader displaying a node running on the localhost: \" + localhostIP);\n        }\n      }\n      if (DEBUG) {\n        Debug.output(\"Creating node (\" + label + \")\");\n      }\n      try {\n        if (shape != ERROR_VALUE_INT) {\n          node=nodeList.add(label,index,shape,menu,status);\n          node.setLocalhost(isLocalhost);\n        }\n      }\n catch (      Exception e) {\n        Debug.error(\"NMGL: error creating node\");\n      }\n      setNodePositionFromEventProps(node,eventProps);\n    }\n  }\n else   if (cmd.equals(NODE_OBJECT_STATUS)) {\n    if (index == ERROR_VALUE_INT) {\n      Debug.error(\"NMGL: error parsing object index for status update.\");\n      return;\n    }\n    node=nodeList.get(index);\n    if (node != null) {\n      status=PropUtils.intFromProperties(eventProps,STATUS_FIELD,ERROR_VALUE_INT);\n      if (status != ERROR_VALUE_INT) {\n        node.setStatus(status);\n      }\n    }\n  }\n else   if (cmd.equals(LINK_OBJECT_STATUS)) {\n    if (index == ERROR_VALUE_INT) {\n      Debug.error(\"NMGL: error parsing line index for status update.\");\n      return;\n    }\n    line=lineList.get(index);\n    if (line != null) {\n      status=PropUtils.intFromProperties(eventProps,STATUS_FIELD,ERROR_VALUE_INT);\n      if (status != ERROR_VALUE_INT) {\n        line.setStatus(status);\n      }\n    }\n  }\n else   if (cmd.equals(LINK_OBJECT)) {\n    if (index == ERROR_VALUE_INT) {\n      Debug.error(\"NMGL: error parsing line index for link.\");\n      return;\n    }\n    line=lineList.get(index);\n    int shape=PropUtils.intFromProperties(eventProps,SHAPE_FIELD,ERROR_VALUE_INT);\n    if (shape == NODE_DELETE) {\n      lineList.del(index);\n    }\n else {\n      status=PropUtils.intFromProperties(eventProps,STATUS_FIELD,0);\n      int node1=PropUtils.intFromProperties(eventProps,LINK_NODE1_FIELD,ERROR_VALUE_INT);\n      int node2=PropUtils.intFromProperties(eventProps,LINK_NODE2_FIELD,ERROR_VALUE_INT);\n      if (node1 == ERROR_VALUE_INT || node2 == ERROR_VALUE_INT) {\n        Debug.error(\"NMGL: error parsing node indexes for link\");\n        return;\n      }\n      Node n1=nodeList.get(node1);\n      Node n2=nodeList.get(node2);\n      if (n1 != null && n2 != null) {\n        lineList.add(String.valueOf(index),index,shape,status,n1,n2);\n      }\n else {\n        if (DEBUG) {\n          Debug.output(\"NetMapGraphicLoader: can\'t create lobj, nodes are undefined\");\n        }\n      }\n    }\n  }\n else   if (cmd.equals(REFRESH) || cmd.equals(UPDATE)) {\n  }\n else   if (cmd.equals(CLEAR)) {\n    if (nodeList != null) {\n      nodeList.flush();\n    }\n    if (lineList != null) {\n      lineList.flush();\n    }\n  }\n else {\n    if (DEBUG) {\n      Debug.output(\"NMGL: received unused event: \" + eventProps.toString());\n    }\n  }\n  manageGraphics();\n}\n", "docstring": "process a netmapevent properties object , which means that a properties object , representing an event from the netmap server , is evaluated and used to modify the nodecache and linecache accordingly .", "partition": "test"}
{"idx": "5627", "code": "protected static void addIdRepoAMSDKPlugin(SSOToken token,String orgName) throws SMSException, SSOException {\n  ServiceConfigManager scm=new ServiceConfigManager(ServiceManager.REALM_SERVICE,token);\n  ServiceConfig sc=scm.getOrganizationConfig(orgName,null);\n  Map attributes=new HashMap();\n  Set values=new HashSet();\n  values.add(\"com.iplanet.am.sdk.AMSDKRepo\");\n  attributes.put(\"sunIdRepoClass\",values);\n  values=new HashSet();\n  values.add(DNMapper.realmNameToAMSDKName(DNMapper.orgNameToDN(orgName)));\n  attributes.put(\"amSDKOrgName\",values);\n  sc.addSubConfig(\"amsdk1\",\"amSDK\",0,attributes);\n}\n", "docstring": "adds idrepo amsdk plugin to the given organization name", "partition": "test"}
{"idx": "5628", "code": "public static String onKeyPress(String key){\n  pin=pin.concat(key);\n  return pin;\n}\n", "docstring": "getting the value of key pressed and appending it to current pin", "partition": "test"}
{"idx": "5629", "code": "public boolean isHierachic(String string){\n  int index=string.indexOf(m_Seperator);\n  if ((index == (string.length() - 1)) || (index == -1)) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "whether the given string has a hierachy structure with the seperators", "partition": "test"}
{"idx": "5630", "code": "public Shape paintLayer(Graphics g,int offs0,int offs1,Shape bounds,JTextComponent c,View view){\n  Color base=getColor();\n  Color color=base != null ? new Color(base.getRed(),base.getGreen(),base.getBlue(),255) : null;\n  if (color == null) {\n    g.setColor(c.getSelectionColor());\n  }\n else {\n    g.setColor(color);\n  }\n  if (offs0 == view.getStartOffset() && offs1 == view.getEndOffset()) {\n    Rectangle alloc;\n    if (bounds instanceof Rectangle) {\n      alloc=(Rectangle)bounds;\n    }\n else {\n      alloc=bounds.getBounds();\n    }\n    g.fillRect(alloc.x,alloc.y,c.getWidth() - alloc.x,alloc.height);\n  }\n else {\n    try {\n      Shape shape=view.modelToView(offs0,Position.Bias.Forward,offs1,Position.Bias.Backward,bounds);\n      Rectangle r=(shape instanceof Rectangle) ? (Rectangle)shape : shape.getBounds();\n      g.fillRect(0,r.y,c.getWidth(),r.height);\n      return r;\n    }\n catch (    BadLocationException e) {\n    }\n  }\n  return null;\n}\n", "docstring": "paints a portion of a highlight .", "partition": "test"}
{"idx": "5631", "code": "synchronized void receive(char oneChar) throws IOException {\n  if (buffer == null) {\n    throw new IOException(\"Pipe is closed\");\n  }\n  if (lastReader != null && !lastReader.isAlive()) {\n    throw new IOException(\"Pipe broken\");\n  }\n  lastWriter=Thread.currentThread();\n  try {\n    while (buffer != null && out == in) {\n      notifyAll();\n      wait(1000);\n      if (lastReader != null && !lastReader.isAlive()) {\n        throw new IOException(\"Pipe broken\");\n      }\n    }\n  }\n catch (  InterruptedException e) {\n    throw new InterruptedIOException();\n  }\n  if (buffer == null) {\n    throw new IOException(\"Pipe is closed\");\n  }\n  if (in == -1) {\n    in=0;\n  }\n  buffer[in++]=oneChar;\n  if (in == buffer.length) {\n    in=0;\n  }\n}\n", "docstring": "receives a char and stores it into the pipedreader . this called by pipedwriter . write ( ) when writes occur . < p > if the buffer is full and the thread sending # receive is interrupted , the interruptedioexception will be thrown .", "partition": "test"}
{"idx": "5632", "code": "public static final ByteBuffer bufferToByteBuffer(final byte[] buffer,final ByteOrder order){\n  final ByteBuffer retBuff=ByteBuffer.wrap(buffer);\n  retBuff.order(order);\n  return retBuff;\n}\n", "docstring": "converts a buffer to a bytebuffer .", "partition": "test"}
{"idx": "5633", "code": "private URI processLocalFiles(URI uri){\n  String uriStr=uri.toString();\n  if (uriStr.startsWith(\"file:\")) {\n    uriStr=\"file:\" + System.getProperty(\"user.dir\") + \"/\"+ uriStr.substring(5);\n    URL url;\n    try {\n      url=new URL(uriStr);\n      return url.toURI();\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n  }\n  return uri;\n}\n", "docstring": "convert local paths into absolute paths for links based on the local file system .", "partition": "test"}
{"idx": "5634", "code": "public void reset(){\n  count=0;\n  startTime=System.currentTimeMillis();\n}\n", "docstring": "resets the rate sampling .", "partition": "test"}
{"idx": "5635", "code": "public int readInt() throws IOException {\n  length+=4;\n  int k1=in.read();\n  if (k1 < 0)   return 0;\n  int k2=in.read() << 8;\n  int k3=in.read() << 16;\n  return k1 + k2 + k3+ (in.read() << 24);\n}\n", "docstring": "read the next int from the inputstream .", "partition": "test"}
{"idx": "5636", "code": "public void addTransformation(TagTransformation tagTransformation){\n  if (tagTransformation != null) {\n    mappings.put(tagTransformation.getSourceTag(),tagTransformation);\n  }\n}\n", "docstring": "adds specified tag transformation to the collection .", "partition": "test"}
{"idx": "5637", "code": "public String nextString(){\n  nextClean(\'\"\');\n  StringBuilder sb=new StringBuilder();\n  for (; ; ) {\n    char c=next();\nswitch (c) {\ncase 0:\ncase \'\\n\':\ncase \'\\r\':\n      throw syntaxError(\"Unterminated string\");\ncase \'\\\\\':\n    c=next();\nswitch (c) {\ncase \'b\':\n    sb.append(\'\\b\');\n  break;\ncase \'t\':\nsb.append(\'\\t\');\nbreak;\ncase \'n\':\nsb.append(\'\\n\');\nbreak;\ncase \'f\':\nsb.append(\'\\f\');\nbreak;\ncase \'r\':\nsb.append(\'\\r\');\nbreak;\ncase \'u\':\nsb.append((char)Integer.parseInt(next(4),16));\nbreak;\ndefault :\nsb.append(c);\n}\nbreak;\ncase \'\"\':\nreturn sb.toString();\ndefault :\nif (c < \' \') {\nthrow syntaxError(\"Unescaped control character (ascii \" + ((int)c) + \") in string\");\n}\nsb.append(c);\nbreak;\n}\n}\n}\n", "docstring": "return the characters up to the next close quote character . backslash processing is done . the formal json format does not allow strings in single quotes , but an implementation is allowed to accept them .", "partition": "test"}
{"idx": "5638", "code": "private void readLyrics3Tag(File file,RandomAccessFile newFile,int loadOptions) throws IOException {\n}\n", "docstring": "read lyrics3 tag todo : not working", "partition": "test"}
{"idx": "5639", "code": "public double evaluate(VectorInstance x,VectorInstance y) throws Exception {\n  double dotProd=x.dotProduct(y);\n  return Math.pow(m_gamma * dotProd + m_coef0,m_degree);\n}\n", "docstring": "compute the result of the kernel evaluation on the supplied vectors", "partition": "test"}
{"idx": "5640", "code": "private boolean isDbConfigurationPresent(){\n  return StringUtils.isNotBlank(selectColumn) && StringUtils.isNotBlank(tableName);\n}\n", "docstring": "returns whether the database configuration is present or not ( i . e . the select column and the tablename have both been specified ) .", "partition": "test"}
{"idx": "5641", "code": "public boolean isIncompleteNumericalRun(String pin){\n  final int len=pin.length();\n  int consecutive=0;\n  char last=pin.charAt(0);\n  for (int i=1; i < len; i++) {\n    final char c=pin.charAt(i);\n    if (last == c) {\n      consecutive++;\n    }\n else {\n      consecutive=0;\n    }\n    last=c;\n    if (consecutive >= 2) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "tests the string to see if it contains a partial numeric run . eg . 3000 , 5553", "partition": "test"}
{"idx": "5642", "code": "private static void generateJavaScriptLogAlertCloseWindow(Writer writer,String message) throws IOException {\n  writer.write(\"<script language=\\\"javascript\\\">alert(\\\"\" + message + \"\\\");\");\n  writer.write(\"window.close();\");\n  writer.write(\"</script>\");\n}\n", "docstring": "metodo que genera un alert con el mensaje de error y ademas cierra la ventana que se intenta abrir", "partition": "test"}
{"idx": "5643", "code": "public Tree<String> extractBestMaxRuleParse1(int start,int end,int state,List<String> sentence){\n  int cState=maxcChild[start][end][state];\n  if (cState == -1) {\n    return extractBestMaxRuleParse2(start,end,state,sentence);\n  }\n else {\n    List<Tree<String>> child=new ArrayList<Tree<String>>();\n    child.add(extractBestMaxRuleParse2(start,end,cState,sentence));\n    String stateStr=(String)tagNumberer.object(state);\n    if (stateStr.endsWith(\"^g\"))     stateStr=stateStr.substring(0,stateStr.length() - 2);\n    int intermediateNode=grammar.getUnaryIntermediate((short)state,(short)cState);\n    if (intermediateNode == 0) {\n    }\n    if (intermediateNode > 0) {\n      List<Tree<String>> restoredChild=new ArrayList<Tree<String>>();\n      String stateStr2=(String)tagNumberer.object(intermediateNode);\n      if (stateStr2.endsWith(\"^g\"))       stateStr2=stateStr2.substring(0,stateStr2.length() - 2);\n      restoredChild.add(new Tree<String>(stateStr2,child));\n      return new Tree<String>(stateStr,restoredChild);\n    }\n    return new Tree<String>(stateStr,child);\n  }\n}\n", "docstring": "returns the best parse for state \" state \" , potentially starting with a unary rule", "partition": "test"}
{"idx": "5644", "code": "protected void drawCenterText(Canvas c){\n  SpannableString centerText=mChart.getCenterText();\n  if (mChart.isDrawCenterTextEnabled() && centerText != null) {\n    PointF center=mChart.getCenterCircleBox();\n    float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();\n    RectF holeRect=mRectBuffer[0];\n    holeRect.left=center.x - innerRadius;\n    holeRect.top=center.y - innerRadius;\n    holeRect.right=center.x + innerRadius;\n    holeRect.bottom=center.y + innerRadius;\n    RectF boundingRect=mRectBuffer[1];\n    boundingRect.set(holeRect);\n    float radiusPercent=mChart.getCenterTextRadiusPercent();\n    if (radiusPercent > 0.0) {\n      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);\n    }\n    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {\n      mCenterTextLastBounds.set(boundingRect);\n      mCenterTextLastValue=centerText;\n      float width=mCenterTextLastBounds.width();\n      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);\n    }\n    float layoutHeight=mCenterTextLayout.getHeight();\n    c.save();\n    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);\n    mCenterTextLayout.draw(c);\n    c.restore();\n  }\n}\n", "docstring": "draws the description text in the center of the pie chart makes most sense when center - hole is enabled", "partition": "test"}
{"idx": "5645", "code": "public void start(int conditions) throws IOException {\n  print(\"conditions\",new String[]{Integer.toBinaryString(conditions)});\n  printer.flush();\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "5646", "code": "private static ResultCode registerErrorResultCode(final int intValue,final LocalizableMessage name,final Enum resultCodeEnum){\n  final ResultCode t=new ResultCode(intValue,name,true,resultCodeEnum);\n  ELEMENTS.put(intValue,t);\n  return t;\n}\n", "docstring": "creates and registers a new error result code with the application .", "partition": "test"}
{"idx": "5647", "code": "public void addAll(ExceptionSet other){\n  exceptionSet.or(other.exceptionSet);\n  explicitSet.or(other.explicitSet);\n  size=countBits(exceptionSet);\n  commonSupertype=null;\n}\n", "docstring": "add all exceptions in the given set .", "partition": "test"}
{"idx": "5648", "code": "@HLEUnimplemented @HLEFunction(nid=0x574A8C3F,version=271) public int sceUsbCamStartVideo(){\n  if (!setupVideo()) {\n    log.warn(String.format(\"Cannot find webcam\"));\n  }\n  return 0;\n}\n", "docstring": "starts video input from the camera .", "partition": "test"}
{"idx": "5649", "code": "protected ResourceLoaderLicenseLocator(final Charset charset,final String... licenseFiles){\n  if (licenseFiles == null || licenseFiles.length == 0) {\n    throw new IllegalArgumentException(\"No license files specified\");\n  }\n  if (charset == null) {\n    throw new NullPointerException(\"Charset is null\");\n  }\n  this.licenseFiles=new ArrayList<String>(Arrays.asList(licenseFiles));\n  this.charset=charset;\n}\n", "docstring": "constructs the license locator with the given license file names . each file name given must exist on the system classpath .", "partition": "test"}
{"idx": "5650", "code": "@Inject public ProjectTypeRegistry(Set<ProjectTypeDef> types){\n  projectTypes=new HashMap<>();\n  validatedData=new HashMap<>();\n  validate(types);\n  for (  ProjectTypeDef type : validatedData.values()) {\n    try {\n      init(type);\n    }\n catch (    ProjectTypeConstraintException e) {\n      LOG.error(e.getMessage());\n    }\n  }\n}\n", "docstring": "initialises set of project type definitions", "partition": "test"}
{"idx": "5651", "code": "static public void addNotificationListener(JMXConnector jmxConnector,Class<?> mbeanInterface,String mbeanName,NotificationListener notificationListener,boolean ignored) throws InstanceNotFoundException, Exception {\n  MBeanServerConnection mbsc=jmxConnector.getMBeanServerConnection();\n  ObjectName objectName=generateMBeanObjectName(mbeanInterface.getName(),mbeanName);\n  mbsc.addNotificationListener(objectName,notificationListener,null,null);\n}\n", "docstring": "attach notificationlistener that can be used to listen notifications emitted by mbean server .", "partition": "test"}
{"idx": "5652", "code": "private void consume(){\n  consumer.subscribe(topics);\n  while (running.get()) {\n    try {\n      ConsumerRecords records=consumer.poll(pollIntervalMs);\n      if (records == null) {\n        continue;\n      }\n      Iterator<ConsumerRecord<String,String>> iterator=records.iterator();\n      while (iterator.hasNext()) {\n        sendMessage(iterator.next());\n      }\n    }\n catch (    Exception ex) {\n      String error=\"Error consuming messages from kafka\";\n      logger.error(error,ex);\n      bus.send(ConfigConstants.CONSUMER_ERROR_TOPIC,getErrorString(error,ex.getMessage()));\n    }\n  }\n}\n", "docstring": "handles looping and consuming", "partition": "test"}
{"idx": "5653", "code": "private byte[] readRawBytesSlowPath(final int size) throws IOException {\n  if (size <= 0) {\n    if (size == 0) {\n      return Internal.EMPTY_BYTE_ARRAY;\n    }\n else {\n      throw InvalidProtocolBufferException.negativeSize();\n    }\n  }\n  if (totalBytesRetired + bufferPos + size > currentLimit) {\n    skipRawBytes(currentLimit - totalBytesRetired - bufferPos);\n    throw InvalidProtocolBufferException.truncatedMessage();\n  }\n  if (size < BUFFER_SIZE) {\n    final byte[] bytes=new byte[size];\n    int pos=bufferSize - bufferPos;\n    System.arraycopy(buffer,bufferPos,bytes,0,pos);\n    bufferPos=bufferSize;\n    ensureAvailable(size - pos);\n    System.arraycopy(buffer,0,bytes,pos,size - pos);\n    bufferPos=size - pos;\n    return bytes;\n  }\n else {\n    final int originalBufferPos=bufferPos;\n    final int originalBufferSize=bufferSize;\n    totalBytesRetired+=bufferSize;\n    bufferPos=0;\n    bufferSize=0;\n    int sizeLeft=size - (originalBufferSize - originalBufferPos);\n    final List<byte[]> chunks=new ArrayList<byte[]>();\n    while (sizeLeft > 0) {\n      final byte[] chunk=new byte[Math.min(sizeLeft,BUFFER_SIZE)];\n      int pos=0;\n      while (pos < chunk.length) {\n        final int n=(input == null) ? -1 : input.read(chunk,pos,chunk.length - pos);\n        if (n == -1) {\n          throw InvalidProtocolBufferException.truncatedMessage();\n        }\n        totalBytesRetired+=n;\n        pos+=n;\n      }\n      sizeLeft-=chunk.length;\n      chunks.add(chunk);\n    }\n    final byte[] bytes=new byte[size];\n    int pos=originalBufferSize - originalBufferPos;\n    System.arraycopy(buffer,originalBufferPos,bytes,0,pos);\n    for (    final byte[] chunk : chunks) {\n      System.arraycopy(chunk,0,bytes,pos,chunk.length);\n      pos+=chunk.length;\n    }\n    return bytes;\n  }\n}\n", "docstring": "exactly like readrawbytes , but caller must have already checked the fast path : ( size < = ( buffersize - pos ) & & size > 0 )", "partition": "test"}
{"idx": "5654", "code": "private void deleteAttrs(SvcReg reg,EntryRep entry,boolean checkDups){\n  EntryClass eclass=entry.eclass;\n  deleteInstance(eclass);\n  Object[] fields=entry.fields;\n  if (fields.length == 0) {\n    ArrayList regs=serviceByEmptyAttr.get(eclass);\n    if (regs == null || (checkDups && hasEmptyAttr(reg,eclass)))     return;\n    int idx=regs.indexOf(reg);\n    if (idx >= 0) {\n      regs.remove(idx);\n      if (regs.isEmpty())       serviceByEmptyAttr.remove(eclass);\n    }\n    return;\n  }\n  for (int fldidx=fields.length; --fldidx >= 0; ) {\n    eclass=getDefiningClass(eclass,fldidx);\n    HashMap[] attrMaps=serviceByAttr.get(eclass);\n    if (attrMaps == null || attrMaps[fldidx] == null || (checkDups && hasAttr(reg,eclass,fldidx,fields[fldidx])))     continue;\n    HashMap map=attrMaps[fldidx];\n    Object value=fields[fldidx];\n    ArrayList regs=(ArrayList)map.get(value);\n    if (regs == null)     continue;\n    int idx=regs.indexOf(reg);\n    if (idx < 0)     continue;\n    regs.remove(idx);\n    if (!regs.isEmpty())     continue;\n    map.remove(value);\n    if (!map.isEmpty())     continue;\n    attrMaps[fldidx]=null;\n    if (allNull(attrMaps))     serviceByAttr.remove(eclass);\n  }\n}\n", "docstring": "if checkdups is false , delete the service ( if present ) from servicebyattr under all attribute values of the given entry or from servicebyemptyattr if the entry has no attributes . if checkdups is true , only delete for a given attribute value if the service has no other entries of similar type that still have the same value . either way , delete an instance of the entryclass , and update entryclasses as necessary .", "partition": "test"}
{"idx": "5655", "code": "public static boolean isClassLiteralPossible(ClassNode classNode){\n  return Modifier.isPublic(classNode.getModifiers());\n}\n", "docstring": "tells if a class node is candidate for class literal bytecode optimization . if so , bytecode may use ldc instructions instead of static constant class fields to retrieve class literals .", "partition": "test"}
{"idx": "5656", "code": "private Properties loadLogFile(License license,boolean create){\n  Properties log=new Properties();\n  File logFile=getLogFile(license);\n  try {\n    if (create && logFile.createNewFile()) {\n      logger.fine(\"Created license log file: \" + logFile.getAbsolutePath());\n    }\n    final InputStream in=new FileInputStream(logFile);\n    try {\n      log.load(in);\n    }\n  finally {\n      in.close();\n    }\n  }\n catch (  FileNotFoundException ex) {\n    if (create) {\n      logger.log(Level.SEVERE,\"Unable to create license log file: \" + logFile.getAbsolutePath(),ex);\n    }\n else {\n      logger.fine(\"Log file does not yet exist\");\n    }\n  }\ncatch (  IOException ex) {\n    logger.log(Level.WARNING,\"Unable to access license log file: \" + logFile.getAbsolutePath(),ex);\n  }\n  return log;\n}\n", "docstring": "loads the log file for the given license and returns it .", "partition": "test"}
{"idx": "5657", "code": "public HTMLStripCharFilterFactory(Map<String,String> args){\n  super(args);\n  escapedTags=getSet(args,\"escapedTags\");\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "docstring": "creates a new htmlstripcharfilterfactory", "partition": "test"}
{"idx": "5658", "code": "public static int update(long id,V v){\n  String passwd=(String)v.value(\"password\");\n  if (!X.isEmpty(passwd)) {\n    passwd=encrypt(passwd);\n    v.set(\"password\",passwd,true);\n  }\n else {\n    v.remove(\"password\");\n  }\n  return Helper.update(id,v.set(\"updated\",System.currentTimeMillis()),User.class);\n}\n", "docstring": "update the user by the values , < br > if the values contains \" password \" field , it will auto encrypt the password field .", "partition": "test"}
{"idx": "5659", "code": "@Override public String toString(){\n  StringBuffer text=new StringBuffer();\n  text.append(\"attributes \" + attributesToString() + \"\\n\");\n  text.append(\"number of instances \" + getInstNums());\n  return text.toString();\n}\n", "docstring": "make a string from the cluster features .", "partition": "test"}
{"idx": "5660", "code": "public boolean isSafeMode(){\n  return this.safeMode;\n}\n", "docstring": "check if task will be in safe mode . < br > this works only for sync to object tasks . < br > safe sync task will automatically unregister when sync object will be invalid , like after player logout or chunk unload . < br >", "partition": "test"}
{"idx": "5661", "code": "public void test_getPutByteArrayWithOffsetAndLength(){\n  final int size=200;\n  final IDataRecord buf=new FixedByteArrayBuffer(size);\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(size - 1));\n  final int pos=1;\n  for (int i=0; i < LIMIT; i++) {\n    final byte[] expected=new byte[r.nextInt(size - 2)];\n    final int off=(expected.length / 2 == 0 ? 0 : r.nextInt(expected.length / 2));\n    final int len=(expected.length == 0 ? 0 : r.nextInt(expected.length - off));\n    r.nextBytes(expected);\n    buf.put(pos,expected,off,len);\n    assertEquals(0,BytesUtil.compareBytesWithLenAndOffset(off,len,expected,pos,len,buf.array()));\n    final int dstoff=r.nextInt(10);\n    final byte[] actual=new byte[expected.length + dstoff];\n    buf.get(pos,actual,dstoff,expected.length);\n    assertEquals(0,BytesUtil.compareBytesWithLenAndOffset(off,len,expected,dstoff,len,actual));\n  }\n  assertEquals((byte)0,buf.getByte(0));\n  assertEquals((byte)0,buf.getByte(pos + size - 2));\n}\n", "docstring": "test of the bulk get / put byte [ ", "partition": "test"}
{"idx": "5662", "code": "public void addLastItem(M model){\n  addItem(mDatas.size(),model);\n}\n", "docstring": "insert data to footer", "partition": "test"}
{"idx": "5663", "code": "static boolean hasLocalizedMessages(){\n  return GUIMediator.isEnglishLocale() || !FIRST_MESSAGE.equals(I18n.tr(FIRST_MESSAGE));\n}\n", "docstring": "determines whether or not the current locale language is english . note that the user setting may be empty , defaulting to the running system locale which may be other than english . here we check the effective locale seen in the messagesbundle .", "partition": "test"}
{"idx": "5664", "code": "public static DockerImage fromImageName(String imageName){\n  imageName=prepare(imageName);\n  String[] parts=imageName.split(SECTION_SEPARATOR);\nswitch (parts.length) {\ncase 1:\n    return fromParts(null,null,parts[0]);\ncase 2:\n  if (isValidNamespace(parts[0])) {\n    return fromParts(null,parts[0],parts[1]);\n  }\n else {\n    return fromParts(parts[0],null,parts[1]);\n  }\ncase 3:\nreturn fromParts(parts[0],parts[1],parts[2]);\ndefault :\nthrow new IllegalArgumentException(\"Invalid image format: \" + imageName);\n}\n}\n", "docstring": "parse a full image name ( myhost : 300 / namespace / repo : tag ) into its components", "partition": "test"}
{"idx": "5665", "code": "public synchronized void listen(final Set<NotificationChannel> channelNames){\n  m_channels.addAll(channelNames);\n}\n", "docstring": "adds the set of channel names to the set of listened channels .", "partition": "test"}
{"idx": "5666", "code": "private void displayNonVerbose(ConsoleApplication app,String categoryName,String typeName,Tag tag,Set<String> propertyNames){\n  if (!app.isScriptFriendly()) {\n    displayPropertyOptionKey(app);\n    app.println();\n    app.println();\n  }\n  TableBuilder builder=new TableBuilder();\n  builder.appendHeading(INFO_DSCFG_HEADING_COMPONENT_NAME.get());\n  builder.appendHeading(INFO_DSCFG_HEADING_COMPONENT_TYPE.get());\n  builder.appendHeading(INFO_DSCFG_HEADING_PROPERTY_NAME.get());\n  builder.appendHeading(INFO_DSCFG_HEADING_PROPERTY_OPTIONS.get());\n  builder.appendHeading(INFO_DSCFG_HEADING_PROPERTY_SYNTAX.get());\n  builder.addSortKey(0);\n  builder.addSortKey(1);\n  builder.addSortKey(2);\n  for (  String category : categoryMap.keySet()) {\n    if (categoryName != null && !categoryName.equals(category)) {\n      continue;\n    }\n    Map<String,AbstractManagedObjectDefinition<?,?>> subTypes=categoryMap.get(category);\n    for (    String type : subTypes.keySet()) {\n      if (typeName != null && !typeName.equals(type)) {\n        continue;\n      }\n      AbstractManagedObjectDefinition<?,?> mod=subTypes.get(type);\n      if (cannotDisplay(app,mod,tag)) {\n        continue;\n      }\n      Set<PropertyDefinition<?>> pds=getPropertyDefinitions(mod);\n      for (      PropertyDefinition<?> pd : pds) {\n        if (cannotDisplay(app,pd,propertyNames)) {\n          continue;\n        }\n        builder.startRow();\n        builder.appendCell(category);\n        builder.appendCell(type);\n        builder.appendCell(pd.getName());\n        builder.appendCell(getPropertyOptionSummary(pd));\n        PropertyDefinitionUsageBuilder v=new PropertyDefinitionUsageBuilder(false);\n        builder.appendCell(v.getUsage(pd));\n      }\n    }\n  }\n  TablePrinter printer;\n  if (app.isScriptFriendly()) {\n    printer=createScriptFriendlyTablePrinter(app.getOutputStream());\n  }\n else {\n    printer=new TextTablePrinter(app.getOutputStream());\n  }\n  builder.print(printer);\n}\n", "docstring": "output property summary table .", "partition": "test"}
{"idx": "5667", "code": "@Override default CompletableFuture<Integer> sumInt(final ToIntFunction<? super T> fn){\n  return CompletableFuture.supplyAsync(null,getExec());\n}\n", "docstring": "perform an asynchronous sum operation", "partition": "test"}
{"idx": "5668", "code": "public void testWrite3() throws Exception {\n  byte[] data=new byte[]{-127,-100,-50,-10,-1,0,1,10,50,127};\n  TestOutputStream tos=new TestOutputStream();\n  CipherOutputStream cos=new CipherOutputStream(tos,new NullCipher());\n  for (int i=0; i < data.length; i++) {\n    cos.write(data,i,1);\n  }\n  cos.flush();\n  byte[] result=tos.toByteArray();\n  if (!Arrays.equals(result,data)) {\n    fail(\"CipherOutputStream wrote incorrect data.\");\n  }\n}\n", "docstring": "write ( byte [ ", "partition": "test"}
{"idx": "5669", "code": "private Document parse(final String data){\n  if (docBuilder == null || data == null) {\n    return null;\n  }\n  Document document=null;\n  try {\n    String buf=BEGINPART + data + ENDPART;\n    InputSource inputSource=new InputSource(new StringReader(buf));\n    document=docBuilder.parse(inputSource);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n  return document;\n}\n", "docstring": "converts the loggingevent data in xml string format into an actual xml document class instance .", "partition": "test"}
{"idx": "5670", "code": "public boolean isProductionJournal(Set<String> productionCopies,Volume volume){\n  for (  String productionCopy : productionCopies) {\n    if (productionCopy.equalsIgnoreCase(volume.getRpCopyName())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks to see if the volume is a production journal . we check to see if the volume \"'\" s rp copy name lines up with any of the given production copies .", "partition": "test"}
{"idx": "5671", "code": "private void testPoundSymbolInColumnName() throws SQLException {\n  deleteDb(\"oracle\");\n  Connection conn=getConnection(\"oracle;MODE=Oracle\");\n  Statement stat=conn.createStatement();\n  stat.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, U##NAME VARCHAR(255))\");\n  stat.execute(\"INSERT INTO TEST VALUES(1, \'Hello\'), (2, \'HelloWorld\'), (3, \'HelloWorldWorld\')\");\n  assertResult(\"1\",stat,\"SELECT ID FROM TEST where U##NAME =\'Hello\'\");\n  conn.close();\n}\n", "docstring": "test the # in a column name for oracle compatibility", "partition": "test"}
{"idx": "5672", "code": "public static String decode(final String escaped) throws URIException {\n  try {\n    final byte[] rawdata=URLCodec.decodeUrl(EncodingUtil.getAsciiBytes(escaped));\n    return EncodingUtil.getString(rawdata,URI.getDefaultProtocolCharset());\n  }\n catch (  final DecoderException e) {\n    throw new URIException(e.getMessage());\n  }\n}\n", "docstring": "unescape and decode a given string regarded as an escaped string with the default protocol charset .", "partition": "test"}
{"idx": "5673", "code": "void waitBeforeNextPoll(int pollingInterval) throws InterruptedException {\nsynchronized (this) {\n    wait(pollingInterval);\n  }\n  if (!pollOutstanding) {\n    return;\n  }\n  log.debug(\"--- extra wait\");\n  for (int i=0; i < 20; i++) {\nsynchronized (this) {\n      wait(pollingInterval / 4);\n    }\n    log.debug(\"-------------extra wait\");\n    if (!pollOutstanding) {\n      return;\n    }\n  }\n}\n", "docstring": "wait before sending next poll . < p > waits specified time , and then checks to see if response has been returned . if not , it waits again ( twice ) by 1 / 2 the interval , then finally polls anyway .", "partition": "test"}
{"idx": "5674", "code": "private void shiftMappingVectorTokensLeft(int lineNum,int startCol,int shift){\n  boolean lastWasBeginTLAToken=false;\n  int lastBeginTLATokCol=-777;\n  Vector line=(Vector)mappingVector.elementAt(lineNum);\n  for (int i=0; i < line.size(); i++) {\n    MappingObject obj=(MappingObject)line.elementAt(i);\n    if (obj.getType() == MappingObject.BEGIN_TLATOKEN) {\n      MappingObject.BeginTLAToken tobj=(MappingObject.BeginTLAToken)obj;\n      int col=tobj.getColumn();\n      if (col >= startCol) {\n        tobj.setColumn(col - shift);\n      }\n      lastWasBeginTLAToken=true;\n      lastBeginTLATokCol=tobj.getColumn();\n    }\n else {\n      if (obj.getType() == MappingObject.END_TLATOKEN) {\n        MappingObject.EndTLAToken tobj=(MappingObject.EndTLAToken)obj;\n        int col=tobj.getColumn();\n        if (col >= startCol) {\n          tobj.setColumn(col - shift);\n        }\n        if (lastWasBeginTLAToken && tobj.getColumn() <= lastBeginTLATokCol) {\n          PcalDebug.ReportBug(\"PcalTLAGen.shiftMappingVectorTokensLeft created a null TLA Token\");\n        }\n      }\n else       if (obj.getType() == MappingObject.SOURCE_TOKEN) {\n        MappingObject.SourceToken tobj=(MappingObject.SourceToken)obj;\n        int col=tobj.getBeginColumn();\n        if (col >= startCol) {\n          tobj.setBeginColumn(col - shift);\n        }\n        col=tobj.getEndColumn();\n        if (col >= startCol) {\n          tobj.setEndColumn(col - shift);\n        }\n        lastWasBeginTLAToken=false;\n      }\n    }\n  }\n}\n", "docstring": "adjusts the objects in line linenum of mappingvector so all column numbers starting with startcol are decreased by ` shift \"'\" . if any begin / endtlatoken pairs are changed to have a non - positive width , a bug is reported . note : it is assumed that there is no aliasing of mappingtokens in mappingvector . that is , other than in transient local variables , the only pointer to a mappingtoken in mappingvector is the single one in its line of mappingvector . i can \"'\" t see how any aliasing of mappingtokens could arise . this method is called only by genlabeledstmts .", "partition": "test"}
{"idx": "5675", "code": "protected Dimension computeLengths(String annoText){\n  String[] lines=Util.splitLines(annoText);\n  int lineLength=0;\n  for (  String line : lines) {\n    if (line.length() > lineLength)     lineLength=line.length();\n  }\n  return new Dimension(lineLength + 5,lines.length + 1);\n}\n", "docstring": "determine the number of lines in the annotation text and the length of the longest line .", "partition": "test"}
{"idx": "5676", "code": "ImportNoteBuilder addMessage(ImportNoteMessage.Type type,String message){\n  if (!Strings.isNullOrEmpty(message)) {\n    messages.add(new ImportNoteMessage(type,message));\n  }\n  return this;\n}\n", "docstring": "adds a message ( if not null ) to the builder .", "partition": "test"}
{"idx": "5677", "code": "public static List<String> asStringList(Collection<? extends Object> objects){\n  List<String> list=new ArrayList<>();\n  for (  Object object : objects) {\n    list.add(String.valueOf(object));\n  }\n  return list;\n}\n", "docstring": "returns a list of strings , where the strings are the result of calling string . valueof ( object ) of each object in the given collection .", "partition": "test"}
{"idx": "5678", "code": "public <E extends T>E min(Iterable<E> iterable){\n  Iterator<E> iterator=iterable.iterator();\n  E minSoFar=iterator.next();\n  while (iterator.hasNext()) {\n    minSoFar=min(minSoFar,iterator.next());\n  }\n  return minSoFar;\n}\n", "docstring": "returns the smallest of the specified values according to this ordering . if there are multiple smallest values , the first of those is returned .", "partition": "test"}
{"idx": "5679", "code": "public synchronized int read(byte b[],int off,int len) throws IOException {\n  if (len <= 0)   return 0;\n  int moreSpace;\nsynchronized (lock) {\n    if (pos >= present)     pos=present=0;\n else     if (pos >= waterMark) {\n      System.arraycopy(buffer,pos,buffer,0,present - pos);\n      present-=pos;\n      pos=0;\n    }\n    int freeSpace=buffer.length - present;\n    moreSpace=Math.max(freeSpace - requested,0);\n  }\n  if (moreSpace > 0)   manager.sendRequest(info,moreSpace);\nsynchronized (lock) {\n    requested+=moreSpace;\n    while ((pos >= present) && !disconnected) {\n      try {\n        lock.wait();\n      }\n catch (      InterruptedException e) {\n      }\n    }\n    if (disconnected && pos >= present)     return -1;\n    int available=present - pos;\n    if (len < available) {\n      System.arraycopy(buffer,pos,b,off,len);\n      pos+=len;\n      return len;\n    }\n else {\n      System.arraycopy(buffer,pos,b,off,available);\n      pos=present=0;\n      return available;\n    }\n  }\n}\n", "docstring": "read a subarray of bytes from connection . this method blocks for at least one byte , and it returns the number of bytes actually read , or - 1 if the end of the stream was detected .", "partition": "test"}
{"idx": "5680", "code": "public static List<ItemStack> consolidateItemStacks(List<ItemStack> inputStacks){\n  List<ItemStack> outputStacks=new ArrayList<ItemStack>();\n  for (  ItemStack sourceIS : inputStacks) {\n    boolean bFound=false;\n    for (    ItemStack destIS : outputStacks) {\n      if (destIS != null && sourceIS != null && itemStackIngredientsMatch(destIS,sourceIS)) {\n        bFound=true;\n        destIS.stackSize+=sourceIS.stackSize;\n      }\n    }\n    if (!bFound)     outputStacks.add(sourceIS.copy());\n  }\n  return outputStacks;\n}\n", "docstring": "take a list of itemstacks and amalgamate where possible . < br >", "partition": "test"}
{"idx": "5681", "code": "public static int howManyDaysOld(long time){\n  return (int)((System.currentTimeMillis() - time) / DateUtils.DAY_IN_MILLIS);\n}\n", "docstring": "determines how many days ago time was ( rounded down ) .", "partition": "test"}
{"idx": "5682", "code": "protected Character isWFXMLChar(String chardata){\n  Character refInvalidChar;\n  if (chardata == null || (chardata.length() == 0)) {\n    return null;\n  }\n  char[] dataarray=chardata.toCharArray();\n  int datalength=dataarray.length;\n  if (fIsXMLVersion11) {\n    int i=0;\n    while (i < datalength) {\n      if (XML11Char.isXML11Invalid(dataarray[i++])) {\n        char ch=dataarray[i - 1];\n        if (XMLChar.isHighSurrogate(ch) && i < datalength) {\n          char ch2=dataarray[i++];\n          if (XMLChar.isLowSurrogate(ch2) && XMLChar.isSupplemental(XMLChar.supplemental(ch,ch2))) {\n            continue;\n          }\n        }\n        refInvalidChar=new Character(ch);\n        return refInvalidChar;\n      }\n    }\n  }\n else {\n    int i=0;\n    while (i < datalength) {\n      if (XMLChar.isInvalid(dataarray[i++])) {\n        char ch=dataarray[i - 1];\n        if (XMLChar.isHighSurrogate(ch) && i < datalength) {\n          char ch2=dataarray[i++];\n          if (XMLChar.isLowSurrogate(ch2) && XMLChar.isSupplemental(XMLChar.supplemental(ch,ch2))) {\n            continue;\n          }\n        }\n        refInvalidChar=new Character(ch);\n        return refInvalidChar;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "checks if a xml character is well - formed . if there is a problem with the character a non - null character is returned else null is returned .", "partition": "test"}
{"idx": "5683", "code": "public void testZeroZero(){\n  String numA=\"0\";\n  String numB=\"0\";\n  String res=\"0\";\n  BigInteger aNumber=new BigInteger(numA);\n  BigInteger bNumber=new BigInteger(numB);\n  BigInteger result=aNumber.xor(bNumber);\n  assertTrue(res.equals(result.toString()));\n}\n", "docstring": "xor for zero and zero", "partition": "test"}
{"idx": "5684", "code": "public final ParallelFlux<T> doOnNext(Consumer<? super T> onNext){\n  Objects.requireNonNull(onNext,\"onNext\");\n  return doOnSignal(this,onNext,null,null,null,null,null,null,null);\n}\n", "docstring": "call the specified consumer with the current element passing through any \"'\" rail \"'\" .", "partition": "test"}
{"idx": "5685", "code": "protected void addMissing(Instances data,int level,boolean predictorMissing,boolean classMissing){\n  int classIndex=data.classIndex();\n  Random random=new Random(1);\n  for (int i=0; i < data.numInstances(); i++) {\n    Instance current=data.instance(i);\n    for (int j=0; j < data.numAttributes(); j++) {\n      if (((j == classIndex) && classMissing) || ((j != classIndex) && predictorMissing)) {\n        if (Math.abs(random.nextInt()) % 100 < level)         current.setMissing(j);\n      }\n    }\n  }\n}\n", "docstring": "add missing values to a dataset .", "partition": "test"}
{"idx": "5686", "code": "public <T extends DataObject>void insertInBatches(List<T> records,int partitionSize,DbClient dbClient,String type){\n  List<List<T>> volume_partitions=Lists.partition(records,partitionSize);\n  for (  List<T> partition : volume_partitions) {\n    try {\n      dbClient.createObject(partition);\n      _log.info(\"{} {} Records inserted to DB\",partition.size(),type);\n    }\n catch (    DatabaseException e) {\n      _log.error(\"Error inserting {} records into the database:\",type,e);\n    }\n  }\n}\n", "docstring": "insert discovered objects in batches", "partition": "test"}
{"idx": "5687", "code": "public void modify(SSOToken token,String objName,ModificationItem[] mods) throws SMSException, SSOException {\n  if ((objName == null) || (objName.length() == 0) || (mods == null)|| (mods.length == 0)) {\n    throw new IllegalArgumentException(\"SMSEnhancedFlatFileObject.modify: \" + \"One or more arguments is null or empty\");\n  }\n  mRWLock.readRequest();\n  try {\n    if (!root.isExists(mRootDir,objName)) {\n      String errmsg=\"SMSEnhancedFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n  }\n  finally {\n    mRWLock.readDone();\n  }\n  mRWLock.writeRequest();\n  try {\n    SMSFlatFileTreeNode node=root.getChild(objName);\n    if (node == null) {\n      String errmsg=\"SMSEnhancedFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    String filepath=node.getAttributeFilename(mRootDir);\n    if (filepath == null) {\n      String errmsg=\"SMSEnhancedFlatFileObject.modify: object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    File filehandle=new File(filepath);\n    if (!filehandle.isFile()) {\n      String errmsg=\"SMSEnhancedFlatFileObject.modify: Attributes file for \" + \"object \" + objName + \" not found.\";\n      mDebug.error(errmsg);\n      throw new ServiceNotFoundException(errmsg);\n    }\n    Properties props=loadProperties(filehandle,objName);\n    boolean hasSunXmlKeyValue=props.getProperty(SMSEntry.ATTR_XML_KEYVAL) != null;\n    for (int i=0; i < mods.length; i++) {\n      modifyValues(objName,mods[i],props);\n    }\n    saveProperties(props,filehandle,objName);\n    String newSunXMLKeyValue=props.getProperty(SMSEntry.ATTR_XML_KEYVAL);\n    if (newSunXMLKeyValue != null) {\n      Set xmlKeyVals=toValSet(SMSEntry.ATTR_XML_KEYVAL,newSunXMLKeyValue);\n      if (!hasSunXmlKeyValue) {\n        deleteSunXmlKeyValFiles(node);\n      }\n      createSunXmlKeyValFiles(node,xmlKeyVals);\n      saveDirectoryTree();\n    }\n  }\n  finally {\n    mRWLock.writeDone();\n  }\n}\n", "docstring": "modifies the attributes for the given configuration object .", "partition": "test"}
{"idx": "5688", "code": "public void removeOnTabSelectedListener(OnTabSelectedListener listener){\n  if (listener != null) {\n    mListeners.remove(listener);\n  }\n}\n", "docstring": "removes the given tab listener from this layout", "partition": "test"}
{"idx": "5689", "code": "public ConnectUriManager(List<String> connectUri) throws THLException {\n  this.uriList=connectUri;\n  if (connectUri.size() == 0) {\n    throw new THLException(\"Connect URI value is empty; must be a list of one or more THL URIs\");\n  }\n}\n", "docstring": "creates a new instance with a list of uris .", "partition": "test"}
{"idx": "5690", "code": "private void addVolumesToParkingStorageGroup(StorageSystem storage,String policyName,Set<String> volumeDeviceIds) throws Exception {\n  String[] tokens=policyName.split(Constants.SMIS_PLUS_REGEX);\n  CIMObjectPath groupPath=_helper.getVolumeGroupBasedOnSLO(storage,storage,tokens[0],tokens[1],tokens[2]);\n  if (groupPath == null) {\n    groupPath=_helper.createVolumeGroupBasedOnSLO(storage,storage,tokens[0],tokens[1],tokens[2]);\n  }\n  CIMArgument[] inArgs=_helper.getAddVolumesToMaskingGroupInputArguments(storage,groupPath,volumeDeviceIds);\n  CIMArgument[] outArgs=new CIMArgument[5];\n  SmisJob addVolumesToSGJob=new SmisSynchSubTaskJob(null,storage.getId(),SmisConstants.ADD_MEMBERS);\n  _helper.invokeMethodSynchronously(storage,_cimPath.getControllerConfigSvcPath(storage),\"AddMembers\",inArgs,outArgs,addVolumesToSGJob);\n}\n", "docstring": "this method is used for vmax3 to add volumes to parking storage group once volumes are unexported .", "partition": "test"}
{"idx": "5691", "code": "public boolean exportPkcs8(){\n  return jrbPkcs8.isSelected();\n}\n", "docstring": "has the user chosen to export to pkcs # 8 ?", "partition": "test"}
{"idx": "5692", "code": "public NumberTick(Number number,String label,TextAnchor textAnchor,TextAnchor rotationAnchor,double angle){\n  super(number.doubleValue(),label,textAnchor,rotationAnchor,angle);\n  this.number=number;\n}\n", "docstring": "creates a new tick .", "partition": "test"}
{"idx": "5693", "code": "private boolean isStoppable(){\n  return (isRunning() && getCache() != null);\n}\n", "docstring": "determines whether the server can be stopped in - process , such as when a server is embedded in an application and the serverlauncher api is being used .", "partition": "test"}
{"idx": "5694", "code": "private void log(String message,String level,String levelColor,PrintStream ps){\n  StringBuilder builder=new StringBuilder();\n  if (!level.equals(\"raw\"))   builder.append(getPrefix(level,levelColor));\n  builder.append(message);\n  String ts=builder.toString();\n  ps.println(ts);\n  for (  LogHandler hand : handlers)   hand.onLog(level,message,ts,this);\n}\n", "docstring": "log a new message on the selected printstream with the given method and level . this is where all other \"'\" log \"'\" type methods in this class delegate to .", "partition": "test"}
{"idx": "5695", "code": "public static boolean isPublic(int mod){\n  return Modifier.isPublic(mod);\n}\n", "docstring": "returns if modifier is public . note that in our case modifier can be mix ( public and private for example ) .", "partition": "test"}
{"idx": "5696", "code": "public JSONBuffer appendString(Object cont){\n  if (stack.empty() || stack.peek() != Operand.ARRAY) {\n    throw new JSONException(\"Appending string outside of array context.\");\n  }\n  addQuotedString(cont);\n  addSeparator();\n  return this;\n}\n", "docstring": "append a string in quotes", "partition": "test"}
{"idx": "5697", "code": "public static void deleteUserFromAuthenticationInfo(AuthenticationInfo authenticationInfo) throws ServerRuntimeException {\n  String username=authenticationInfo.getUsername();\n  String passwordFileLocation=authenticationInfo.getPasswordFileLocation();\n  try {\n    PropertiesConfiguration props=new PropertiesConfiguration(passwordFileLocation);\n    String usernameInFile=props.getString(username);\n    if (usernameInFile == null) {\n      throw new ServerRuntimeException(MessageFormat.format(\"Username does not exist: {0}\",username));\n    }\n    props.clearProperty(username);\n    props.save();\n  }\n catch (  org.apache.commons.configuration.ConfigurationException ce) {\n    logger.error(\"Error while saving properties for file:\" + authenticationInfo.getPasswordFileLocation(),ce);\n    throw new ServerRuntimeException(\"Error while saving Credentials: \" + ce.getMessage());\n  }\n}\n", "docstring": "delete a user and password from a file", "partition": "test"}
{"idx": "5698", "code": "public void error(Level level,String messageId,String data[],Object session) throws LogException {\n  error(level,messageId,data,session,null);\n}\n", "docstring": "logs error messages to the error logs .", "partition": "test"}
{"idx": "5699", "code": "public synchronized void remove(IAudioProcessor processor){\n  processors.remove(processor);\n  buildFinalProcessor();\n}\n", "docstring": "removes the provided processor from the internal processor queue .", "partition": "test"}
{"idx": "5700", "code": "private int endRecoverAnimation(ViewHolder viewHolder,boolean override){\n  final int recoverAnimSize=mRecoverAnimations.size();\n  for (int i=recoverAnimSize - 1; i >= 0; i--) {\n    final RecoverAnimation anim=mRecoverAnimations.get(i);\n    if (anim.mViewHolder == viewHolder) {\n      anim.mOverridden|=override;\n      if (!anim.mEnded) {\n        anim.cancel();\n      }\n      mRecoverAnimations.remove(i);\n      return anim.mAnimationType;\n    }\n  }\n  return 0;\n}\n", "docstring": "returns the animation type or 0 if cannot be found .", "partition": "test"}
{"idx": "5701", "code": "private boolean isMethodContained(Method m,List<Method> wrapperMethods){\n  String name=m.getName();\n  Class<?>[] paramTypes=m.getParameterTypes();\n  Class<?> returnType=m.getReturnType();\n  for (  Method wm : wrapperMethods) {\n    if (name.equals(wm.getName()) && Arrays.equals(paramTypes,wm.getParameterTypes()) && returnType == wm.getReturnType()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "returns true it the passed method is contained in the also passed list of methods by also comparing matching parameters .", "partition": "test"}
{"idx": "5702", "code": "void updatePressed(ActionEvent e,boolean newRoute){\n  String uName=_userName.getText();\n  Route g=checkNamesOK();\n  if (g == null) {\n    return;\n  }\n  g.setUserName(uName);\n  g.clearOutputTurnouts();\n  g.clearOutputSensors();\n  g.clearRouteSensors();\n  initializeIncludedList();\n  setTurnoutInformation(g);\n  setSensorInformation(g);\n  g.setOutputScriptName(scriptFile.getText());\n  g.setOutputSoundName(soundFile.getText());\n  setControlInformation(g);\n  curRoute=g;\n  finishUpdate();\n  status1.setText((newRoute ? Bundle.getMessage(\"RouteAddStatusCreated\") : Bundle.getMessage(\"RouteAddStatusUpdated\")) + \": \\\"\" + uName+ \"\\\" (\"+ _includedTurnoutList.size()+ \" \"+ Bundle.getMessage(\"Turnouts\")+ \", \"+ _includedSensorList.size()+ \" \"+ Bundle.getMessage(\"Sensors\")+ \")\");\n}\n", "docstring": "responds to the update button - update to route table", "partition": "test"}
{"idx": "5703", "code": "public String toString(){\n  return m_Attributes.toString();\n}\n", "docstring": "returns a string representation of this object", "partition": "test"}
{"idx": "5704", "code": "private static void checkForXStream(){\n  try {\n    Class.forName(\"com.thoughtworks.xstream.XStream\");\n    m_Present=true;\n  }\n catch (  Exception e) {\n    m_Present=false;\n  }\n}\n", "docstring": "checks whether the xstream is present in the class path", "partition": "test"}
{"idx": "5705", "code": "@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1) private Response<BitmapDrawable> doParse(NetworkResponse response){\n  byte[] data=response.data;\n  BitmapFactory.Options decodeOptions=new BitmapFactory.Options();\n  decodeOptions.inInputShareable=true;\n  decodeOptions.inPurgeable=true;\n  decodeOptions.inPreferredConfig=mDecodeConfig;\n  Bitmap bitmap;\n  if (mMaxWidth == 0 && mMaxHeight == 0) {\n    bitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n  }\n else {\n    decodeOptions.inJustDecodeBounds=true;\n    BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n    int actualWidth=decodeOptions.outWidth;\n    int actualHeight=decodeOptions.outHeight;\n    int desiredWidth=getResizedDimension(mMaxWidth,mMaxHeight,actualWidth,actualHeight);\n    int desiredHeight=getResizedDimension(mMaxHeight,mMaxWidth,actualHeight,actualWidth);\n    decodeOptions.inJustDecodeBounds=false;\n    if (Utils.hasGingerbreadMR1()) {\n      decodeOptions.inPreferQualityOverSpeed=PREFER_QUALITY_OVER_SPEED;\n    }\n    decodeOptions.inSampleSize=ImageUtils.findBestSampleSize(actualWidth,actualHeight,desiredWidth,desiredHeight);\n    Bitmap tempBitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);\n    if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() > desiredHeight)) {\n      bitmap=Bitmap.createScaledBitmap(tempBitmap,desiredWidth,desiredHeight,true);\n      tempBitmap.recycle();\n    }\n else {\n      bitmap=tempBitmap;\n    }\n  }\n  if (bitmap == null) {\n    return Response.error(new ParseError(response));\n  }\n else {\n    BitmapDrawable drawable;\n    if (Utils.hasHoneycomb()) {\n      drawable=new BitmapDrawable(mResources,bitmap);\n    }\n else {\n      drawable=new RecyclingBitmapDrawable(mResources,bitmap);\n    }\n    return Response.success(drawable,HttpHeaderParser.parseCacheHeaders(response));\n  }\n}\n", "docstring": "the real guts of parsenetworkresponse . broken out for readability .", "partition": "test"}
{"idx": "5706", "code": "public double evaluate(VectorInstance x,double[] y) throws Exception {\n  VectorInstance diff=x.subtract(y);\n  double result=-m_gamma * diff.dotProduct(diff);\n  return Math.exp(result);\n}\n", "docstring": "compute the result of the kernel evaluation on the supplied vectors", "partition": "test"}
{"idx": "5707", "code": "@Override public int batchSize(){\n  return batchSize;\n}\n", "docstring": "get local batch size for this sequences .", "partition": "test"}
{"idx": "5708", "code": "public void clear(){\n  mAttachedScrap.clear();\n  recycleAndClearCachedViews();\n}\n", "docstring": "clear scrap views out of this recycler . detached views contained within a recycled view pool will remain .", "partition": "test"}
{"idx": "5709", "code": "public FPSTextureView addChildAt(int location,@NonNull DisplayBase displayBase){\n  displayBase.setUp(mFps);\n  mDisplayList.add(location,displayBase);\n  return this;\n}\n", "docstring": "adds a child to the display list at the specified index , bumping children at equal or greater indexes up one , and setting its parent to this container", "partition": "test"}
{"idx": "5710", "code": "private double[] pruneEM(Tree tree,NodeRef node,ColourChangeMatrix mm,MetaPopulation mp){\n  double[] p=new double[colourCount];\n  if (tree.isExternal(node)) {\n    p[getColour(node)]=1.0;\n  }\n else {\n    NodeRef leftChild=tree.getChild(node,0);\n    NodeRef rightChild=tree.getChild(node,1);\n    double[] left=pruneEM(tree,leftChild,mm,mp);\n    double[] right=pruneEM(tree,rightChild,mm,mp);\n    double[] leftBranchPartials=pruneBranchEM(mm,left,node,leftChild,tree,mp);\n    double[] rightBranchPartials=pruneBranchEM(mm,right,node,rightChild,tree,mp);\n    double maxp=0.0;\n    for (int i=0; i < colourCount; i++) {\n      p[i]=leftBranchPartials[i] * rightBranchPartials[i];\n      if (useNodeBias) {\n        p[i]*=mm.getEquilibrium(i) / mp.getDemographic(tree.getNodeHeight(node) - tinyTime,i);\n      }\n      if (p[i] > maxp) {\n        maxp=p[i];\n      }\n    }\n    if (maxp < 1.0e-100) {\n      for (int i=0; i < colourCount; i++) {\n        p[i]*=1.0e+100;\n      }\n      logNodePartialsRescaling-=Math.log(1.0e+100);\n    }\n  }\n  nodePartials[node.getNumber()]=p;\n  if (debugNodePartials) {\n    prettyPrint(\"Node \" + node.getNumber() + \" pruneEM=\",p);\n  }\n  return p;\n}\n", "docstring": "calculate probability of data at descendants from node , given a color at the node ( \"'\" partials \"'\" ) , by a felsenstein - like pruning algorithm . ( first step in the color sampling algorithm ) side effect : updates nodepartials [ ", "partition": "test"}
{"idx": "5711", "code": "public static int minPathSum(int[][] grid){\n  if (grid == null || grid.length == 0)   return 0;\n  int m=grid.length;\n  int n=grid[0].length;\n  int[] rowSum=new int[n];\n  rowSum[0]=grid[0][0];\n  for (int col=1; col < n; col++)   rowSum[col]=rowSum[col - 1] + grid[0][col];\n  for (int row=1; row < m; row++) {\n    rowSum[0]+=grid[row][0];\n    for (int col=1; col < n; col++) {\n      rowSum[col]=Math.min(rowSum[col - 1],rowSum[col]) + grid[row][col];\n    }\n  }\n  return rowSum[n - 1];\n}\n", "docstring": "dp . bottom - up row by row , use an array to store values", "partition": "test"}
{"idx": "5712", "code": "public Time(Date time){\n  SimpleTimeZone tz=new SimpleTimeZone(0,\"Z\");\n  SimpleDateFormat dateF=new SimpleDateFormat(\"yyyyMMddHHmmss\");\n  dateF.setTimeZone(tz);\n  String d=dateF.format(time) + \"Z\";\n  int year=Integer.parseInt(d.substring(0,4));\n  if (year < 1950 || year > 2049) {\n    this.time=new DERGeneralizedTime(d);\n  }\n else {\n    this.time=new DERUTCTime(d.substring(2));\n  }\n}\n", "docstring": "creates a time object from a given date - if the date is between 1950 and 2049 a utctime object is generated , otherwise a generalizedtime is used .", "partition": "test"}
{"idx": "5713", "code": "public DCheckUpdate(JFrame parent){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  initComponents();\n}\n", "docstring": "creates a new dcheckupdate dialog .", "partition": "test"}
{"idx": "5714", "code": "public static Automaton minimizeSimple(Automaton a){\n  Set<Integer> initialSet=new HashSet<Integer>();\n  a=determinizeSimple(Operations.reverse(a,initialSet),initialSet);\n  initialSet.clear();\n  a=determinizeSimple(Operations.reverse(a,initialSet),initialSet);\n  return a;\n}\n", "docstring": "simple , original brics implementation of brzozowski minimize ( )", "partition": "test"}
{"idx": "5715", "code": "@Override public boolean equals(Object o){\n  if (this == o)   return true;\n  if (o == null || getClass() != o.getClass())   return false;\n  AbstractItem<?,?> that=(AbstractItem<?,?>)o;\n  return mIdentifier == that.mIdentifier;\n}\n", "docstring": "if this item equals to the given object", "partition": "test"}
{"idx": "5716", "code": "public void addColumn(Column column){\n  if (column != null) {\n    columns.add(column);\n  }\n}\n", "docstring": "adds the given column .", "partition": "test"}
{"idx": "5717", "code": "private boolean checkForNaNs(NumberVector vec){\n  for (int i=0, d=vec.getDimensionality(); i < d; i++) {\n    double v=vec.doubleValue(i);\n    if (v != v) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "check for nan values .", "partition": "test"}
{"idx": "5718", "code": "public static void fill(StringBuilder strb,int offset){\n  while (strb.length() < offset)   strb.append(' ');\n}\n", "docstring": "fills a string buffer with spaces until it has at least the given length . not very efficient , basically used for debug output .", "partition": "test"}
{"idx": "5719", "code": "public void openForWrite() throws EventException {\n  File f=new File(ConfigUtils.getInitialPropertyExpanded(m_address.getPathname()));\n  try {\n    if (!f.exists()) {\n      f.createNewFile();\n    }\n else {\n      LOGGER.info(\"appending to file=\" + m_address.getPathname());\n    }\n  }\n catch (  IOException ioe) {\n    throw new EventException(\"failed to create file=\" + m_address.getPathname() + \", e=\"+ ioe);\n  }\n  try {\n    m_fos=new FileOutputStream(f,true);\n  }\n catch (  FileNotFoundException fnfe) {\n    throw new EventException(\"failed to open file=\" + m_address.getPathname() + \", e=\"+ fnfe);\n  }\n}\n", "docstring": "open the file with appending mode . if the file exists already , a warning log is issued . if failed to create or open the file , a error log is issued .", "partition": "test"}
{"idx": "5720", "code": "@Override public double calculate_K(int[] x_index,double[] x_att,int[] y_index,double[] y_att){\n  return (Math.exp(gamma * norm2(x_index,x_att,y_index,y_att)));\n}\n", "docstring": "calculates kernel value of vectors x and y .", "partition": "test"}
{"idx": "5721", "code": "@Override public void close() throws IOException {\n  Throwable thrown=null;\n  try {\n    flush();\n  }\n catch (  Throwable e) {\n    thrown=e;\n  }\n  try {\n    out.close();\n  }\n catch (  Throwable e) {\n    if (thrown == null) {\n      thrown=e;\n    }\n  }\n}\n", "docstring": "closes this stream . this implementation closes the target stream .", "partition": "test"}
{"idx": "5722", "code": "public final double cos(){\n  return Math.cos(this.radians);\n}\n", "docstring": "obtains the cosine of this angle .", "partition": "test"}
{"idx": "5723", "code": "public static double ssError(double[] predictedValues,double[] targetAttribute){\n  double ret=0;\n  for (int i=0; i < predictedValues.length; i++) {\n    ret+=Math.pow(targetAttribute[i] - predictedValues[i],2);\n  }\n  return ret;\n}\n", "docstring": "how much of the variance is not explained by the regression", "partition": "test"}
{"idx": "5724", "code": "public int size(){\n  return prefixes.size();\n}\n", "docstring": "this returns the number of available namespaces .", "partition": "test"}
{"idx": "5725", "code": "public static String timestamp(DateTime ts){\n  return Long.toString(ts.getMillis() / 1000);\n}\n", "docstring": "convert a timestamp to the string representation that wavefront will accept .", "partition": "test"}
{"idx": "5726", "code": "public String consume(String name,boolean required) throws ParseException {\n  if (name == null) {\n    if (content == null && required) {\n      throw new ParseException(CoreErrorDomain.ERR.missingRequiredContent);\n    }\n    contentConsumed=true;\n    return content;\n  }\n  String value=attrs.get(name);\n  if (value == null) {\n    if (required) {\n      ParseException pe=new ParseException(CoreErrorDomain.ERR.missingAttribute);\n      pe.setInternalReason(\"Missing attribute: \'\" + name + \"\'\");\n      throw pe;\n    }\n    return null;\n  }\n  attrs.remove(name);\n  return value;\n}\n", "docstring": "gets the value of an attribute and remove it from the list .", "partition": "test"}
{"idx": "5727", "code": "public int copy(byte[] bytes,int at){\n  System.arraycopy(this.bytes,0,bytes,at,this.length);\n  return at + this.length;\n}\n", "docstring": "copy the contents of this kim to a byte array .", "partition": "test"}
{"idx": "5728", "code": "public void importKey(ECKey key){\n  lock.lock();\n  try {\n    checkKeyEncryptionStateMatches(key);\n    if (hasKey(key))     return;\n    importKeyLocked(key);\n    queueOnKeysAdded(ImmutableList.of(key));\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "imports a key to the key chain . if key is present in the key chain , ignore it .", "partition": "test"}
{"idx": "5729", "code": "public ConnectionGroupTree(UserContext userContext,ConnectionGroup root,List<ObjectPermission.Type> permissions) throws GuacamoleException {\n  this.rootAPIGroup=new APIConnectionGroup(root);\n  retrievedGroups.put(root.getIdentifier(),this.rootAPIGroup);\n  User self=userContext.self();\n  this.connectionPermissions=self.getConnectionPermissions();\n  this.sharingProfilePermissions=self.getSharingProfilePermissions();\n  this.connectionDirectory=userContext.getConnectionDirectory();\n  this.connectionGroupDirectory=userContext.getConnectionGroupDirectory();\n  this.sharingProfileDirectory=userContext.getSharingProfileDirectory();\n  addConnectionGroupDescendants(Collections.singleton(root),permissions);\n}\n", "docstring": "creates a new connection group tree using the given connection group as the tree root .", "partition": "test"}
{"idx": "5730", "code": "private boolean containsSingleMetric(BufferedReader reader) throws FormatParseException {\n  try {\n    reader.mark(1);\n    char firstChar=(char)reader.read();\n    reader.reset();\n    return firstChar == \'{\';\n  }\n catch (  IOException e) {\n    throw new FormatParseException(\"IOException while determining if single or multiple metrics \",e);\n  }\n}\n", "docstring": "determines if the given reader contains a single or multiple metrics .", "partition": "test"}
{"idx": "5731", "code": "private void readServiceConfig() throws SSOException, SMSException {\n  if (debug.messageEnabled()) {\n    debug.message(\"G11Settings::ReadServiceConfig\");\n  }\n  SSOToken internalToken=(SSOToken)AccessController.doPrivileged(AdminTokenAction.getInstance());\n  serviceSchemaManager=new ServiceSchemaManager(G11N_SETTINGS_SERVICE_NAME,internalToken);\n  ServiceSchema gsc=serviceSchemaManager.getGlobalSchema();\n  rawServiceData=gsc.getAttributeDefaults();\n}\n", "docstring": "read g11nsettings service config data from sms", "partition": "test"}
{"idx": "5732", "code": "public void refreshPreferences(Context context){\n  if (mEnabledResId != 0) {\n    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n    if (!prefs.getBoolean(context.getString(mEnabledResId),mEnabledDefault)) {\n      setTriggerKeys(Collections.<Long>emptySet());\n      return;\n    }\n  }\n  setTriggerKeys(KeyComboPreference.getKeyCodesForPreference(context,mAssignedKeysResId));\n}\n", "docstring": "read key mapping from default preferences for context", "partition": "test"}
{"idx": "5733", "code": "void addInheritedTypes(TypeMirror typeMirror,Types typesUtils){\n  if (!CompilerUtils.typeMirrorInCollection(inheritedTypes,typeMirror,typesUtils)) {\n    inheritedTypes.add(typeMirror);\n  }\n}\n", "docstring": "add the types that are inherited by this class .", "partition": "test"}
{"idx": "5734", "code": "public static Histogram multiply(Histogram x,double y){\n  return x.modifyEventCounters(null);\n}\n", "docstring": "multiply histogram by scalar .", "partition": "test"}
{"idx": "5735", "code": "public void paint(Graphics g){\n  if (m_from == null || m_to == null)   return;\n  Polygon arrow=new Polygon();\n  Point from=null;\n  Point to=null;\n  if (isRightTop()) {\n    from=addPoint(arrow,m_from,SwingConstants.RIGHT,true);\n    to=addPoint(arrow,m_to,SwingConstants.TOP,false);\n  }\n else   if (isBottomTop()) {\n    from=addPoint(arrow,m_from,SwingConstants.BOTTOM,true);\n    to=addPoint(arrow,m_to,SwingConstants.TOP,false);\n  }\n else   if (isTopBottom()) {\n    from=addPoint(arrow,m_from,SwingConstants.TOP,true);\n    to=addPoint(arrow,m_to,SwingConstants.BOTTOM,false);\n  }\n else   if (isLeftRight()) {\n    from=addPoint(arrow,m_from,SwingConstants.LEFT,true);\n    to=addPoint(arrow,m_to,SwingConstants.RIGHT,false);\n  }\n else {\n    from=addPoint(arrow,m_from,SwingConstants.RIGHT,true);\n    to=addPoint(arrow,m_to,SwingConstants.LEFT,false);\n  }\n  if (!m_next.isUnconditional()) {\n    g.setColor(Color.red);\n    g.fillPolygon(arrow);\n  }\n  if (m_visited)   g.setColor(Color.green);\n else   g.setColor(Color.black);\n  g.drawPolygon(arrow);\n  if (m_next.isFromSplitAnd()) {\n    g.setColor(Color.magenta);\n    g.fillOval(from.x - 3,from.y - 3,6,6);\n  }\n  if (m_next.isToJoinAnd()) {\n    g.setColor(Color.magenta);\n    g.fillOval(to.x - 3,to.y - 3,6,6);\n  }\n  if (m_description != null) {\n    Graphics2D g2D=(Graphics2D)g;\n    Font font=new Font(\"Dialog\",Font.PLAIN,9);\n    if (m_next.isUnconditional())     g2D.setColor(Color.black);\n else     g2D.setColor(Color.red);\n    TextLayout layout=new TextLayout(m_description,font,g2D.getFontRenderContext());\n    int x=0;\n    if (from.x < to.x)     x=from.x + ((to.x - from.x) / 2);\n else     x=to.x + ((from.x - to.x) / 2);\n    int y=0;\n    if (from.y < to.y)     y=from.y + ((to.y - from.y) / 2);\n else     y=to.y + ((from.y - to.y) / 2);\n    y-=(layout.getAscent() - 3);\n    x-=(layout.getAdvance() / 2);\n    if (x < 2)     x=2;\n    layout.draw(g2D,x,y);\n  }\n}\n", "docstring": "paint it . coordinates based on wfcontentpanel .", "partition": "test"}
{"idx": "5736", "code": "public void addCacheParticipants(Map<UUID,IgniteUuid> allParticipants,Map<UUID,IgniteUuid> addedParticipants){\n  verStore.addParticipants(allParticipants,addedParticipants);\n}\n", "docstring": "adds participants to all shared deployments .", "partition": "test"}
{"idx": "5737", "code": "private void savepostMni(String mnipostLocation,String mnipostRespLocation,List manageNameIdList,com.sun.identity.saml2.jaxb.metadata.ObjectFactory objFact) throws JAXBException {\n  if (mnipostLocation != null && mnipostLocation.length() > 0) {\n    ManageNameIDServiceElement slsElemPost=objFact.createManageNameIDServiceElement();\n    slsElemPost.setBinding(httpPostBinding);\n    slsElemPost.setLocation(mnipostLocation);\n    slsElemPost.setResponseLocation(mnipostRespLocation);\n    manageNameIdList.add(slsElemPost);\n  }\n}\n", "docstring": "saves the post managenameid service .", "partition": "test"}
{"idx": "5738", "code": "public static boolean goToUpdatePage(Context context){\n  final Uri playStoreUri=Uri.parse(\"market://details?id=\" + context.getPackageName());\n  FreshAirLog.i(\"Attempting to open Play Store update page at URI: \" + playStoreUri.toString());\n  final Intent playStoreIntent=new Intent(Intent.ACTION_VIEW,playStoreUri);\n  final PackageManager packageManager=context.getPackageManager();\n  for (  ResolveInfo resolveInfo : packageManager.queryIntentActivities(playStoreIntent,0)) {\n    final ActivityInfo resolveActivity=resolveInfo.activityInfo;\n    final String resolvePackageName=resolveActivity.packageName;\n    if (resolvePackageName.equals(\"com.android.vending\")) {\n      FreshAirLog.i(\"Opening Play Store update page...\");\n      playStoreIntent.setComponent(new ComponentName(resolvePackageName,resolveActivity.name));\n      context.startActivity(playStoreIntent);\n      return true;\n    }\n  }\n  FreshAirLog.e(\"Failed to find the Play Store as a candidate for the resolution of update URI: \" + playStoreUri.toString());\n  return false;\n}\n", "docstring": "attempts to start the play store activity for the update page of this app , and returns success or failure .", "partition": "test"}
{"idx": "5739", "code": "public static List<String> toRelativeFiles(@NotNull VirtualFile root,@NotNull final Collection<VirtualFile> files){\n  ArrayList<String> rc=new ArrayList<String>(files.size());\n  for (  VirtualFile file : files) {\n    rc.add(relativePath(root,file));\n  }\n  return rc;\n}\n", "docstring": "covert list of files to relative paths", "partition": "test"}
{"idx": "5740", "code": "synchronized static void ensureSecurityManager(){\n  if (System.getSecurityManager() == null) {\n    System.setSecurityManager(new RMISecurityManager());\n  }\n}\n", "docstring": "utility routine that sets a security manager if one isn \"'\" t already present .", "partition": "test"}
{"idx": "5741", "code": "public static BigDecimal rate(int p_C_CurrencyFrom_ID,int p_C_CurrencyTo_ID,Timestamp p_ConversionDate,int p_C_ConversionType_ID,int p_AD_Client_ID,int p_AD_Org_ID) throws SQLException {\n  if (p_C_CurrencyFrom_ID == p_C_CurrencyTo_ID)   return Adempiere.ONE;\n  Timestamp ConversionDate=p_ConversionDate;\n  if (ConversionDate == null)   ConversionDate=new Timestamp(System.currentTimeMillis());\n  ConversionDate=Adempiere.trunc(ConversionDate);\n  int C_ConversionType_ID=p_C_ConversionType_ID;\n  if (C_ConversionType_ID == 0) {\n    String sql=\"SELECT C_ConversionType_ID \" + \"FROM C_ConversionType \" + \"WHERE IsDefault=\'Y\'\"+ \" AND AD_Client_ID IN (0,?) \"+ \"ORDER BY AD_Client_ID DESC\";\n    C_ConversionType_ID=Adempiere.getSQLValue(sql,p_AD_Client_ID);\n  }\n  BigDecimal rate=null;\n  String sql=\"SELECT MultiplyRate \" + \"FROM C_Conversion_Rate \" + \"WHERE C_Currency_ID=? AND C_Currency_ID_To=?\"+ \" AND C_ConversionType_ID=?\"+ \" AND TRUNC(ValidFrom, \'DD\') <= ?\"+ \" AND TRUNC(ValidTo, \'DD\') >= ?\"+ \" AND AD_Client_ID IN (0,?) AND AD_Org_ID IN (0,?) \"+ \"ORDER BY AD_Client_ID DESC, AD_Org_ID DESC, ValidFrom DESC\";\n  PreparedStatement pstmt=Adempiere.prepareStatement(sql);\n  pstmt.setInt(1,p_C_CurrencyFrom_ID);\n  pstmt.setInt(2,p_C_CurrencyTo_ID);\n  pstmt.setInt(3,C_ConversionType_ID);\n  pstmt.setTimestamp(4,ConversionDate);\n  pstmt.setTimestamp(5,ConversionDate);\n  pstmt.setInt(6,p_AD_Client_ID);\n  pstmt.setInt(7,p_AD_Org_ID);\n  ResultSet rs=pstmt.executeQuery();\n  if (rs.next()) {\n    rate=rs.getBigDecimal(1);\n  }\n  rs.close();\n  pstmt.close();\n  if (rate == null)   return null;\n  return rate;\n}\n", "docstring": "get conversion rate . previously : c_currency_rate - now : currencyrate", "partition": "test"}
{"idx": "5742", "code": "public static SnmpEngineId createEngineId(int port) throws UnknownHostException {\n  int suniana=42;\n  InetAddress address=null;\n  address=InetAddress.getLocalHost();\n  return createEngineId(address,port,suniana);\n}\n", "docstring": "generates a unique engine id . the engine id unicity is based on the host ip address and port . the ip address used is the localhost one . the creation algorithm uses the sun microsystems iana number ( 42 ) .", "partition": "test"}
{"idx": "5743", "code": "public static List<Rule> parseReferential(String path){\n  Ruleset ruleset=DelphiRulesUtils.buildRuleSetFromXml(DelphiRulesUtils.getConfigurationFromFile(path));\n  List<Rule> rulesRepository=new ArrayList<Rule>();\n  for (  DelphiRule fRule : ruleset.getRules()) {\n    rulesRepository.add(createRepositoryRule(fRule));\n  }\n  return rulesRepository;\n}\n", "docstring": "parses rules xml file", "partition": "test"}
{"idx": "5744", "code": "public org.w3c.dom.Document encryptAndReplaceWSSElements(org.w3c.dom.Document doc,java.util.Map elmMap,java.lang.String encDataEncAlg,int encDataEncAlgStrength,String certAlias,int kekStrength,java.lang.String tokenType,java.lang.String providerID) throws EncryptionException {\n  return null;\n}\n", "docstring": "encrypts the given wss xml element in a given xml context document .", "partition": "test"}
{"idx": "5745", "code": "public void insertChild(Node node,int index){\n  node.detachFromParent();\n  node.parentNode=this;\n  try {\n    initChildNodes(node);\n    childNodes.add(index,node);\n  }\n catch (  IndexOutOfBoundsException ignore) {\n    throw new LagartoDOMException(\"Invalid node index: \" + index);\n  }\n  reindexChildren();\n}\n", "docstring": "inserts node at given index .", "partition": "test"}
{"idx": "5746", "code": "private static byte[] ntlmHash(final String password) throws AuthenticationException {\n  try {\n    final byte[] unicodePassword=password.getBytes(\"UnicodeLittleUnmarked\");\n    final MD4 md4=new MD4();\n    md4.update(unicodePassword);\n    return md4.getOutput();\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new AuthenticationException(\"Unicode not supported: \" + e.getMessage(),e);\n  }\n}\n", "docstring": "creates the ntlm hash of the user \"'\" s password .", "partition": "test"}
{"idx": "5747", "code": "private boolean betweenZeroAndOne(final String paramName,final double val){\n  if ((val < 0) || (val > 1)) {\n    JOptionPane.showMessageDialog(null,paramName + \"should be between 0 and 1\",\"Warning!\",JOptionPane.WARNING_MESSAGE);\n    return false;\n  }\n  return true;\n}\n", "docstring": "helper method to check that a value is between 0 and 1 and display a warning if not .", "partition": "test"}
{"idx": "5748", "code": "public abstract String substituteMacros(String parameterValue,MacroHandler mh) throws UndefinedParameterError ;\n", "docstring": "this method operates on the internal string representation of parameter values and replaces macro expressions of the form % { macroname } .", "partition": "test"}
{"idx": "5749", "code": "public void powEquals(double exp){\n  for (int i=0; i < A.length; i++)   for (int j=0; j < A[i].length; j++)   A[i][j]=Math.pow(A[i][j],exp);\n}\n", "docstring": "x . powequals ( ) calculates the power of each element of the matrix . the result is stored in this matrix object again .", "partition": "test"}
{"idx": "5750", "code": "private static List<String> splitCamelCase(String className){\n  String remaining=className;\n  List<String> result=new ArrayList<String>();\n  while (!remaining.isEmpty()) {\n    boolean found=false;\n    for (int i=1; i < remaining.length(); i++) {\n      if (Character.isUpperCase(remaining.charAt(i))) {\n        result.add(remaining.substring(0,i));\n        remaining=remaining.substring(i);\n        found=true;\n        break;\n      }\n    }\n    if (!found) {\n      result.add(remaining);\n      remaining=\"\";\n    }\n  }\n  return result;\n}\n", "docstring": "converts a name like \" outputbyteinputtablecodingloop \" to a list of words : { \" output \" , \" byte \" , \" input \" , \" table \" , \" coding \" , \" loop \" }", "partition": "test"}
{"idx": "5751", "code": "public static NodeList selectNodeList(Node doc,String str,NamespaceContext nsctx) throws XPathException {\n  XPathFactory xpf=xpathFactoryCache.getInstanceForCurrentThread();\n  XPath xpath=xpf.newXPath();\n  xpath.setNamespaceContext(nsctx);\n  XPathExpression expr=xpath.compile(str);\n  return (NodeList)expr.evaluate(doc,XPathConstants.NODESET);\n}\n", "docstring": "use an xpath string to select a nodelist namespace prefix is resolved using the the specified context .", "partition": "test"}
{"idx": "5752", "code": "private void generateDiscovery() throws SAXException {\n  handler.startElement(\"\",LOCATORS,LOCATORS,EMPTY);\n  generateLocators();\n  handler.endElement(\"\",LOCATORS,LOCATORS);\n}\n", "docstring": "generates xml for locators in the distributed system", "partition": "test"}
{"idx": "5753", "code": "protected BasicType(Class<T> type,int sqlType){\n  super(type,sqlType);\n  checkNull=!type.isPrimitive();\n}\n", "docstring": "instantiates a new type instance .", "partition": "test"}
{"idx": "5754", "code": "@Override public void actionPerformed(ActionEvent e){\n}\n", "docstring": "close window ( or reload page if in debug mode )", "partition": "test"}
{"idx": "5755", "code": "public void applyProperties(){\n  for (  ParameterType type : allParameterTypes) {\n    String value=allParameterValues.getProperty(type.getKey());\n    ParameterService.setParameterValue(type,value);\n  }\n}\n", "docstring": "applies the properties without saving them .", "partition": "test"}
{"idx": "5756", "code": "public void add(ClusterNode newNode){\n  if (node != null) {\n    nodes=new ArrayList<>(2);\n    nodes.add(node);\n    node=null;\n  }\n  nodes.add(newNode);\n}\n", "docstring": "add node to the group .", "partition": "test"}
{"idx": "5757", "code": "public boolean checkIfBackupSetExists(String setName){\n  validateNotNullOrEmpty(setName);\n  try {\n    File file=new File(getBackupRoot(),setName);\n    if (file.exists()) {\n      return true;\n    }\n  }\n catch (  Exception e) {\n    log.error(\"Exception during backup set directory exists check\");\n  }\n  return false;\n}\n", "docstring": "check to see if the given backup set already exists in the backup store .", "partition": "test"}
{"idx": "5758", "code": "public static String[] toQuotedAndCommaSeparatedArray(String str) throws IOException {\n  LinkedList<String> values=new LinkedList<String>();\n  StreamTokenizer tt=new StreamTokenizer(new StringReader(str));\n  tt.wordChars(\'a\',\'z\');\n  tt.wordChars(\'A\',\'Z\');\n  tt.wordChars(128 + 32,255);\n  tt.whitespaceChars(0,\' \');\n  tt.quoteChar(\'\"\');\n  tt.quoteChar(\'\\\'\');\n  while (tt.nextToken() != StreamTokenizer.TT_EOF) {\nswitch (tt.ttype) {\ncase StreamTokenizer.TT_WORD:\ncase \'\"\':\ncase \'\\\'\':\n      values.add(tt.sval);\n    break;\n}\n}\nreturn values.toArray(new String[values.size()]);\n}\n", "docstring": "returns a value as a string array . the values are separated by commas with optional quotes and white space .", "partition": "test"}
{"idx": "5759", "code": "public void writeStringNoCompression(String str) throws IOException {\n  if (str == null) {\n    writeInt(0);\n  }\n else {\n    writeInt(str.length());\n    for (int i=0; i < str.length(); i++)     io.write((byte)str.charAt(i));\n  }\n}\n", "docstring": "write a string without compression", "partition": "test"}
{"idx": "5760", "code": "public SmartThresholds parse(final Resource thresholdFileResource) throws IOException {\n  final SmartThresholds holder=new SmartThresholds();\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new InputStreamReader(thresholdFileResource.getInputStream()));\n    String line;\n    while ((line=reader.readLine()) != null) {\n      if (line.startsWith(\"SM\")) {\n        String[] lineInput=line.split(\"\\\\s+\");\n        holder.addThreshold(new SmartThreshold(lineInput));\n      }\n    }\n  }\n  finally {\n    if (reader != null) {\n      reader.close();\n    }\n  }\n  return holder;\n}\n", "docstring": "returns a map of model accession to a threshold record .", "partition": "test"}
{"idx": "5761", "code": "public void shutdown(){\n  ExecutorService executor=Executors.newScheduledThreadPool(0);\n  executor.submit(createShutdown(0));\n}\n", "docstring": "shutdown all attached resources without waiting on the thread", "partition": "test"}
{"idx": "5762", "code": "@Override public Point drawingToView(Point2D.Double p){\n  return new Point((int)(p.x * scaleFactor) - translation.x,(int)(p.y * scaleFactor) - translation.y);\n}\n", "docstring": "converts drawing coordinates to view coordinates .", "partition": "test"}
{"idx": "5763", "code": "protected void onConnect(){\n}\n", "docstring": "this method is called once the pircbot has successfully connected to the irc server . < p > the implementation of this method in the pircbot abstract class performs no actions and may be overridden as required .", "partition": "test"}
{"idx": "5764", "code": "public void addDescriptor(final SetupDescriptor desc){\n  descriptors.add(desc);\n}\n", "docstring": "add a setup descriptor .", "partition": "test"}
{"idx": "5765", "code": "public static String compileProgressSuccessAction(String progressSuccessAction) throws TemplateModelException {\n  Environment env=CommonFtlUtil.getCurrentEnvironment();\n  return compileProgressSuccessAction(progressSuccessAction,ContextFtlUtil.getRequest(env),ContextFtlUtil.getResponse(env));\n}\n", "docstring": "compiles a progress success action . < p > context - dependent ; uses thread environment .", "partition": "test"}
{"idx": "5766", "code": "public static String join(String separator,float... elements){\n  if (elements == null || elements.length == 0) {\n    return \"\";\n  }\n  List<Number> list=new ArrayList<Number>(elements.length);\n  for (  Float elem : elements) {\n    list.add(elem);\n  }\n  return join(separator,list);\n}\n", "docstring": "returns a string with all float values concatenated by a specified separator .", "partition": "test"}
{"idx": "5767", "code": "public static void putUnsignedByte(ByteBuffer bb,short v){\n  bb.put((byte)(v & 0xff));\n}\n", "docstring": "put an unsigned byte into the specified bytebuffer at the current position", "partition": "test"}
{"idx": "5768", "code": "@Override public Trie optimize(Trie orig){\n  List<CharSequence> cmds=orig.cmds;\n  List<Row> rows=new ArrayList<>();\n  List<Row> orows=orig.rows;\n  int remap[]=new int[orows.size()];\n  for (int j=orows.size() - 1; j >= 0; j--) {\n    Row now=new Remap(orows.get(j),remap);\n    boolean merged=false;\n    for (int i=0; i < rows.size(); i++) {\n      Row q=merge(now,rows.get(i));\n      if (q != null) {\n        rows.set(i,q);\n        merged=true;\n        remap[j]=i;\n        break;\n      }\n    }\n    if (merged == false) {\n      remap[j]=rows.size();\n      rows.add(now);\n    }\n  }\n  int root=remap[orig.root];\n  Arrays.fill(remap,-1);\n  rows=removeGaps(root,rows,new ArrayList<Row>(),remap);\n  return new Trie(orig.forward,remap[root],cmds,rows);\n}\n", "docstring": "optimize ( remove empty rows ) from the given trie and return the resulting trie .", "partition": "test"}
{"idx": "5769", "code": "public boolean isAllDenied(){\n  int count=0;\n  for (int i=0; i < mPerms.size(); i++) {\n    if (mPerms.get(mUserPermission.get(i)) == PackageManager.PERMISSION_DENIED)     count++;\n  }\n  return count == mPerms.size();\n}\n", "docstring": "is all denied boolean .", "partition": "test"}
{"idx": "5770", "code": "public String toStringKey(){\n  String result;\n  int i;\n  result=\"<table border=\\\"1\\\" cellpadding=\\\"3\\\" cellspacing=\\\"0\\\">\\n\" + \"   <tr><td colspan=\\\"2\\\"><b>Key</b></td></tr>\\n\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    result+=\"   <tr>\" + \"<td><b>(\" + (i + 1) + \")</b></td>\"+ \"<td>\"+ removeFilterName(m_ColNames[i])+ \"</td>\"+ \"</tr>\\n\";\n  }\n  result+=\"</table>\\n\";\n  return result;\n}\n", "docstring": "returns returns a key for all the col names , for better readability if the names got cut off .", "partition": "test"}
{"idx": "5771", "code": "private DateTimeFormatter toFormatter(Locale locale,ResolverStyle resolverStyle,Chronology chrono){\n  Objects.requireNonNull(locale,\"locale\");\n  while (active.parent != null) {\n    optionalEnd();\n  }\n  CompositePrinterParser pp=new CompositePrinterParser(printerParsers,false);\n  return new DateTimeFormatter(pp,locale,DecimalStyle.STANDARD,resolverStyle,null,chrono,null);\n}\n", "docstring": "completes this builder by creating the formatter .", "partition": "test"}
{"idx": "5772", "code": "protected void waitForExternalStoreMount() throws Exception {\n  String extStorageState=Environment.getExternalStorageState();\n  int currentWaitTime=0;\n  while (!extStorageState.equals(Environment.MEDIA_MOUNTED)) {\n    Log.i(LOG_TAG,\"Waiting for SD card...\");\n    currentWaitTime=timeoutWait(currentWaitTime,DEFAULT_WAIT_POLL_TIME,DEFAULT_MAX_WAIT_TIME,\"Timed out waiting for SD Card to be ready!\");\n    extStorageState=Environment.getExternalStorageState();\n  }\n}\n", "docstring": "synchronously waits for external store to be mounted ( eg : sd card ) .", "partition": "test"}
{"idx": "5773", "code": "public boolean uploadAndInstallApk(@NotNull IDevice device,@NotNull String packageName,@NotNull File localFile,@NotNull LaunchStatus launchStatus){\n  if (!needsInstall(device,localFile,packageName)) {\n    return true;\n  }\n  String remotePath=\"/data/local/tmp/\" + packageName;\n  myPrinter.stdout(\"$ adb push \" + localFile + \" \"+ remotePath);\n  try {\n    device.pushFile(localFile.getPath(),remotePath);\n    boolean installed=installApp(device,remotePath,packageName,launchStatus);\n    if (installed) {\n      myInstalledApkCache.setInstalled(device,localFile,packageName);\n    }\n    return installed;\n  }\n catch (  Exception e) {\n    myPrinter.stderr(e.toString());\n    return false;\n  }\n}\n", "docstring": "installs the given apk on the device .", "partition": "test"}
{"idx": "5774", "code": "public void open(final long[] list,final int position){\n  launchPlayerActivity=true;\nsynchronized (this) {\n    if (mShuffleMode == SHUFFLE_AUTO) {\n      mShuffleMode=SHUFFLE_NORMAL;\n    }\n    final long oldId=getAudioId();\n    final int listlength=list.length;\n    boolean newlist=true;\n    if (mPlayListLen == listlength) {\n      newlist=false;\n      for (int i=0; i < listlength; i++) {\n        if (list[i] != mPlayList[i]) {\n          newlist=true;\n          break;\n        }\n      }\n    }\n    if (newlist) {\n      addToPlayList(list,-1);\n      notifyChange(QUEUE_CHANGED);\n    }\n    if (position >= 0) {\n      mPlayPos=position;\n    }\n else {\n      mPlayPos=mShuffler.nextInt(mPlayListLen);\n    }\n    mHistory.clear();\n    openCurrentAndNext();\n    if (oldId != getAudioId()) {\n      notifyChange(META_CHANGED);\n    }\n  }\n}\n", "docstring": "opens a list for playback", "partition": "test"}
{"idx": "5775", "code": "public void testNegativeReverseStepByOneWithClosure(){\n  final List callLog=new ArrayList();\n  final Closure closure=new RecordingClosure(callLog);\n  final Range range=createRange(5,1);\n  range.step(-1,closure);\n  assertEquals(\"wrong number of calls to closure\",5,callLog.size());\n  final Iterator iter=callLog.iterator();\n  for (int i=1; i <= 5; i++) {\n    assertEquals(\"wrong argument passed to closure\",createValue(i),iter.next());\n  }\n}\n", "docstring": "tests stepping backwards through a reversed range with a closure .", "partition": "test"}
{"idx": "5776", "code": "public static BigDecimal normalizeDecimalValue(BigDecimal bigDecimal,int allowedPrecision){\n  if (bigDecimal.precision() > allowedPrecision) {\n    return null;\n  }\n  return bigDecimal;\n}\n", "docstring": "this method will check the digits before dot with the max precision allowed", "partition": "test"}
{"idx": "5777", "code": "protected static Node deserializeString(String doc){\n  try {\n    StringReader reader=new StringReader(doc);\n    StreamSource source=new StreamSource(reader);\n    DOMResult result=new DOMResult();\n    TransformerFactory tf=TransformerFactory.newInstance();\n    Transformer transformer=tf.newTransformer();\n    transformer.setOutputProperty(OutputKeys.ENCODING,DEFAULT_ENCODING);\n    transformer.setOutputProperty(OutputKeys.INDENT,DEFAULT_INDENT);\n    transformer.transform(source,result);\n    return result.getNode();\n  }\n catch (  Throwable e) {\n    log.log(Level.SEVERE,\"Failed to serialize node\",e);\n  }\n  return null;\n}\n", "docstring": "this method deserializes the supplied document .", "partition": "test"}
{"idx": "5778", "code": "public void sendEventToAgent(final String event){\nsynchronized (eventSocket) {\n    eventWriter.print(event);\n    eventWriter.flush();\n  }\n}\n", "docstring": "sends a message to the testrunneragent", "partition": "test"}
{"idx": "5779", "code": "private void applyJMSObjects(HashMap<String,String> filters){\n  StringWriter writer=new StringWriter();\n  PrintWriter printWriter=new PrintWriter(writer);\n  printWriter.println();\n  for (  String str : getQueueList()) {\n    printWriter.println(\"      <queue name=\\\"\" + str + \"\\\"/>\");\n  }\n  for (  String str : getTopicList()) {\n    printWriter.println(\"      <topic name=\\\"\" + str + \"\\\"/>\");\n  }\n  filters.put(\"${jms-list.settings}\",writer.toString());\n}\n", "docstring": "it will create the jms configurations", "partition": "test"}
{"idx": "5780", "code": "@Override public Revision next(){\n  try {\n    int revCount, articleID;\n    revCount=result.getInt(3);\n    articleID=result.getInt(5);\n    if (articleID != this.currentArticleID) {\n      this.currentRevCounter=0;\n      this.currentArticleID=articleID;\n    }\n    if (revCount - 1 != this.currentRevCounter) {\n      logger.error(\"\\nInvalid RevCounter -\" + \" [ArticleId \" + articleID + \", RevisionId \"+ result.getInt(4)+ \", RevisionCounter \"+ result.getInt(3)+ \"] - Expected: \"+ (this.currentRevCounter + 1));\n      this.currentRevCounter=revCount;\n      this.previousRevision=null;\n      return null;\n    }\n    this.currentRevCounter=revCount;\n    this.primaryKey=result.getInt(1);\n    Revision revision=new Revision(revCount);\n    revision.setPrimaryKey(this.primaryKey);\n    if (!shouldLoadRevisionText) {\n      String currentRevision;\n      Diff diff;\n      RevisionDecoder decoder=new RevisionDecoder(config.getCharacterSet());\n      if (binaryData) {\n        decoder.setInput(result.getBinaryStream(2),true);\n      }\n else {\n        decoder.setInput(result.getString(2));\n      }\n      diff=decoder.decode();\n      try {\n        currentRevision=diff.buildRevision(previousRevision);\n      }\n catch (      Exception e) {\n        this.previousRevision=null;\n        logger.error(\"Reconstruction failed -\" + \" [ArticleId \" + result.getInt(5) + \", RevisionId \"+ result.getInt(4)+ \", RevisionCounter \"+ result.getInt(3)+ \"]\");\n        return null;\n      }\n      previousRevision=currentRevision;\n      revision.setRevisionText(currentRevision);\n    }\n else {\n      if (revApi == null) {\n        revApi=new RevisionApi(config);\n      }\n      revision.setRevisionApi(revApi);\n    }\n    revision.setRevisionID(result.getInt(4));\n    revision.setArticleID(articleID);\n    revision.setTimeStamp(new Timestamp(result.getLong(6)));\n    revision.setFullRevisionID(result.getInt(7));\n    revision.setContributorName(result.getString(8));\n    revision.setContributorId(result.getInt(9));\n    revision.setComment(result.getString(10));\n    revision.setMinor(result.getBoolean(11));\n    revision.setContributorIsRegistered(result.getBoolean(12));\n    return revision;\n  }\n catch (  DecodingException e) {\n    throw new RuntimeException(e);\n  }\ncatch (  SQLException e) {\n    throw new RuntimeException(e);\n  }\ncatch (  IOException e) {\n    throw new RuntimeException(e);\n  }\ncatch (  WikiApiException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "returns the next revision .", "partition": "test"}
{"idx": "5781", "code": "public void addSelectionColumn(GridField mField){\n  log.config(mField.getHeader());\n  int displayLength=mField.getDisplayLength();\n  if (displayLength <= 0 || displayLength > FIELDLENGTH)   mField.setDisplayLength(FIELDLENGTH);\n else   displayLength=0;\n  WEditor editor=null;\n  Label label=null;\n  Row panel=new Row();\n  contentSimpleRows.appendChild(panel);\n  if (mField.isRange()) {\n    Hbox box=new Hbox();\n    editor=WebEditorFactory.getEditor(mField,false);\n    label=editor.getLabel();\n    editor.setMandatory(false);\n    editor.setReadWrite(true);\n    editor.dynamicDisplay();\n    Component fieldLabel=editor.getComponent();\n    box.appendChild(editor.getComponent());\n    rangeFirstEditor.add(mField.getColumnName());\n    WEditor toRangeEditor=WebEditorFactory.getEditor(mField,false);\n    toRangeEditor.setMandatory(false);\n    toRangeEditor.setReadWrite(true);\n    toRangeEditor.dynamicDisplay();\n    m_sEditors2.add(toRangeEditor);\n    Label separator=new Label(\" - \");\n    box.appendChild(separator);\n    Component fieldLabel1=toRangeEditor.getComponent();\n    box.appendChild(toRangeEditor.getComponent());\n    if (displayLength > 0)     mField.setDisplayLength(displayLength);\n    if (isTwoColumns) {\n      if (!isPair)       panel=new Row();\n    }\n else     panel=new Row();\n    panel.appendChild(LayoutUtils.makeRightAlign(label));\n    panel.appendChild(box);\n    fieldLabel.addEventListener(Events.ON_OK,this);\n    fieldLabel1.addEventListener(Events.ON_OK,this);\n  }\n else {\n    editor=WebEditorFactory.getEditor(mField,false);\n    label=editor.getLabel();\n    editor.setMandatory(false);\n    editor.setReadWrite(true);\n    editor.dynamicDisplay();\n    Component fieldLabel=editor.getComponent();\n    if (displayLength > 0)     mField.setDisplayLength(displayLength);\n    panel.appendChild(LayoutUtils.makeRightAlign(label));\n    panel.appendChild(fieldLabel);\n    fieldLabel.addEventListener(Events.ON_OK,this);\n    m_sEditors2.add(null);\n  }\n  m_sEditors.add(editor);\n}\n", "docstring": "add selection column to first tab", "partition": "test"}
{"idx": "5782", "code": "public final static void closeEL(final OutputStream os){\n  try {\n    if (os != null)     os.close();\n  }\n catch (  final Throwable e) {\n  }\n}\n", "docstring": "close outputstream without a exception", "partition": "test"}
{"idx": "5783", "code": "public void addSearchListener(SearchListener l){\n  m_SearchListeners.add(l);\n}\n", "docstring": "adds the specified listener to the internal list of listeners .", "partition": "test"}
{"idx": "5784", "code": "public boolean isSingleAttributeContainer(){\n  return false;\n}\n", "docstring": "returns false for the idpplegalidentity container .", "partition": "test"}
{"idx": "5785", "code": "public void open(File file) throws IOException {\n  checkAWTPermission();\n  checkExec();\n  checkActionSupport(Action.OPEN);\n  checkFileValidation(file);\n  peer.open(file);\n}\n", "docstring": "launches the associated application to open the file . < p > if the specified file is a directory , the file manager of the current platform is launched to open it .", "partition": "test"}
{"idx": "5786", "code": "public static String convertISO8601DurationToNormalTime(String isoTime){\n  String formattedTime=new String();\n  if (isoTime.contains(\"H\") && isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'H\'));\n    String minutes=isoTime.substring(isoTime.indexOf(\'H\') + 1,isoTime.indexOf(\'M\'));\n    String seconds=isoTime.substring(isoTime.indexOf(\'M\') + 1,isoTime.indexOf(\'S\'));\n    formattedTime=hours + \":\" + formatTo2Digits(minutes)+ \":\"+ formatTo2Digits(seconds);\n  }\n else   if (!isoTime.contains(\"H\") && isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String minutes=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'M\'));\n    String seconds=isoTime.substring(isoTime.indexOf(\'M\') + 1,isoTime.indexOf(\'S\'));\n    formattedTime=minutes + \":\" + formatTo2Digits(seconds);\n  }\n else   if (isoTime.contains(\"H\") && !isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'H\'));\n    String seconds=isoTime.substring(isoTime.indexOf(\'H\') + 1,isoTime.indexOf(\'S\'));\n    formattedTime=hours + \":00:\" + formatTo2Digits(seconds);\n  }\n else   if (isoTime.contains(\"H\") && isoTime.contains(\"M\") && !isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'H\'));\n    String minutes=isoTime.substring(isoTime.indexOf(\'H\') + 1,isoTime.indexOf(\'M\'));\n    formattedTime=hours + \":\" + formatTo2Digits(minutes)+ \":00\";\n  }\n else   if (!isoTime.contains(\"H\") && !isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String seconds=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'S\'));\n    formattedTime=\"0:\" + formatTo2Digits(seconds);\n  }\n else   if (!isoTime.contains(\"H\") && isoTime.contains(\"M\") && !isoTime.contains(\"S\")) {\n    String minutes=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'M\'));\n    formattedTime=minutes + \":00\";\n  }\n else   if (isoTime.contains(\"H\") && !isoTime.contains(\"M\") && !isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf(\'T\') + 1,isoTime.indexOf(\'H\'));\n    formattedTime=hours + \":00:00\";\n  }\n  return formattedTime;\n}\n", "docstring": "converting iso8601 formatted duration to normal readable time", "partition": "test"}
{"idx": "5787", "code": "@Override public void toggleSelection(T photo){\n  if (selectedPhotos.contains(photo)) {\n    selectedPhotos.remove(photo);\n  }\n else {\n    selectedPhotos.add(photo);\n  }\n}\n", "docstring": "toggle the selection status of the item at a given position", "partition": "test"}
{"idx": "5788", "code": "protected void preTick(){\n}\n", "docstring": "fired when the scheduler begins to tick , before any tasks are processed .", "partition": "test"}
{"idx": "5789", "code": "public byte map(byte src){\n  char c=map((char)src);\n  if (c < Byte.MIN_VALUE || c > Byte.MAX_VALUE) {\n    return 0;\n  }\n  return (byte)c;\n}\n", "docstring": "cannot map from a byte", "partition": "test"}
{"idx": "5790", "code": "public String wrapIfKeywordOrBuiltIn(String name){\n  if (KEYWORD_BUILT_IN_SET.contains(name)) {\n    return name + \"_\";\n  }\n  return name;\n}\n", "docstring": "return a non - conflicting safe name if name is a ruby built - in .", "partition": "test"}
{"idx": "5791", "code": "public IssueMatcher add(){\n  IssueMatcher issueMatcher=new IssueMatcher();\n  issueMatchers.add(issueMatcher);\n  return issueMatcher;\n}\n", "docstring": "creates a new issue matcher and adds it to this matcher .", "partition": "test"}
{"idx": "5792", "code": "private <T>InjectScope<T> findScope(AnnotatedElement annElement){\n  for (  Annotation ann : annElement.getAnnotations()) {\n    Class<? extends Annotation> annType=ann.annotationType();\n    if (annType.isAnnotationPresent(Scope.class)) {\n      Supplier<InjectScope<T>> scopeGen=(Supplier)_scopeMap.get(annType);\n      if (scopeGen != null) {\n        return scopeGen.get();\n      }\n else {\n        log.fine(L.l(\"@{0} is an unknown scope\",annType.getSimpleName()));\n      }\n    }\n  }\n  return new InjectScopeFactory<>();\n}\n", "docstring": "finds the scope for a bean producing declaration , either a method or a type .", "partition": "test"}
{"idx": "5793", "code": "private static native int[] RegOpenKey(int hKey,byte[] subKey,int securityMask);\n", "docstring": "java wrapper for windows registry api regopenkey ( )", "partition": "test"}
{"idx": "5794", "code": "public void removePropertyChangeListener(IPropertyChangeListener listener){\n  listeners.remove(listener);\n}\n", "docstring": "remove the provided listener from the receiver .", "partition": "test"}
{"idx": "5795", "code": "@Override public int previous(){\n  CharacterIterator text=getText();\n  if (current() == text.getBeginIndex()) {\n    return BreakIterator.DONE;\n  }\n  int start=current();\n  int lastResult=cachedLastKnownBreak;\n  if (lastResult >= start || lastResult <= BreakIterator.DONE) {\n    getPrevious();\n    lastResult=handlePrevious();\n  }\n else {\n    text.setIndex(lastResult);\n  }\n  int result=lastResult;\n  while (result != BreakIterator.DONE && result < start) {\n    lastResult=result;\n    result=handleNext();\n  }\n  text.setIndex(lastResult);\n  cachedLastKnownBreak=lastResult;\n  return lastResult;\n}\n", "docstring": "advances the iterator backwards , to the last boundary preceding this one .", "partition": "test"}
{"idx": "5796", "code": "public DeferredImageReplacedElement(ImageResource imageResource,RepaintListener repaintListener,int w,int h){\n  this._imageResource=imageResource;\n  _loaded=false;\n  this.repaintListener=repaintListener;\n  if (w == -1 && h == -1) {\n    _doScaleImage=false;\n    _targetHeight=1;\n    _targetWidth=1;\n  }\n else {\n    _doScaleImage=true;\n    _targetHeight=Math.max(1,h);\n    _targetWidth=Math.max(1,w);\n  }\n  _image=ImageUtil.createCompatibleBufferedImage(_targetWidth,_targetHeight);\n}\n", "docstring": "creates a new imagereplacedelement and scales it to the size specified if either width or height has a valid value ( values are > - 1 ) , otherwise original size is preserved . the idea is that the image was loaded at a certain size ( that \"'\" s the image instance here ) and that at the time we create the imagereplacedelement we have a target w / h we want to use .", "partition": "test"}
{"idx": "5797", "code": "public boolean startsWith(Name n){\n  if (n instanceof CompoundName) {\n    return (impl.startsWith(n.size(),n.getAll()));\n  }\n else {\n    return false;\n  }\n}\n", "docstring": "determines whether a compound name is a prefix of this compound name . a compound name \"'\" n \"'\" is a prefix if it is equal to getprefix ( n . size ( ) ) - - in other words , this compound name starts with \"'\" n \"'\" . if n is null or not a compound name , false is returned . < p > implementation note : currently the syntax properties of n are not used when doing the comparison . they might be in the future .", "partition": "test"}
{"idx": "5798", "code": "public ParameterizedGenericMethodBinding(MethodBinding originalMethod,TypeBinding[] typeArguments,LookupEnvironment environment){\n  this.environment=environment;\n  this.modifiers=originalMethod.modifiers;\n  this.selector=originalMethod.selector;\n  this.declaringClass=originalMethod.declaringClass;\n  this.typeVariables=Binding.NO_TYPE_VARIABLES;\n  this.typeArguments=typeArguments;\n  this.isRaw=false;\n  this.tagBits=originalMethod.tagBits;\n  this.originalMethod=originalMethod;\n  this.parameters=Scope.substitute(this,originalMethod.parameters);\n  this.returnType=Scope.substitute(this,originalMethod.returnType);\n  this.thrownExceptions=Scope.substitute(this,originalMethod.thrownExceptions);\n  if (this.thrownExceptions == null)   this.thrownExceptions=Binding.NO_EXCEPTIONS;\n  checkMissingType: {\n    if ((this.tagBits & TagBits.HasMissingType) != 0)     break checkMissingType;\n    if ((this.returnType.tagBits & TagBits.HasMissingType) != 0) {\n      this.tagBits|=TagBits.HasMissingType;\n      break checkMissingType;\n    }\n    for (int i=0, max=this.parameters.length; i < max; i++) {\n      if ((this.parameters[i].tagBits & TagBits.HasMissingType) != 0) {\n        this.tagBits|=TagBits.HasMissingType;\n        break checkMissingType;\n      }\n    }\n    for (int i=0, max=this.thrownExceptions.length; i < max; i++) {\n      if ((this.thrownExceptions[i].tagBits & TagBits.HasMissingType) != 0) {\n        this.tagBits|=TagBits.HasMissingType;\n        break checkMissingType;\n      }\n    }\n  }\n  this.wasInferred=true;\n}\n", "docstring": "create method of parameterized type , substituting original parameters with type arguments .", "partition": "test"}
{"idx": "5799", "code": "public void testInvokeAll5() throws Throwable {\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    List<Callable<String>> l=new ArrayList<Callable<String>>();\n    l.add(new StringTask());\n    l.add(new StringTask());\n    List<Future<String>> futures=e.invokeAll(l);\n    assertEquals(2,futures.size());\n    for (    Future<String> future : futures)     assertSame(TEST_STRING,future.get());\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "docstring": "invokeall ( c ) returns results of all completed tasks in c", "partition": "test"}
{"idx": "5800", "code": "public InternalListener(final ConfigManager configFile){\n  this.configFile=configFile;\n}\n", "docstring": "creates a new listener object .", "partition": "test"}
{"idx": "5801", "code": "public byte[] sign(byte[] hash){\n  ECDSASigner signer=new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));\n  signer.init(true,new ECPrivateKeyParameters(priv,domain));\n  BigInteger[] signature=signer.generateSignature(hash);\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n  try {\n    DERSequenceGenerator seq=new DERSequenceGenerator(baos);\n    seq.addObject(new ASN1Integer(signature[0]));\n    seq.addObject(new ASN1Integer(toCanonicalS(signature[1])));\n    seq.close();\n    return baos.toByteArray();\n  }\n catch (  IOException e) {\n  }\n  return null;\n}\n", "docstring": "sign a digest with this key .", "partition": "test"}
{"idx": "5802", "code": "public TimePeriod(Date startTime,Date endTime){\n  if (startTime != null && endTime != null && !endTime.after(startTime)) {\n    throw new IllegalArgumentException(\"EndTime: \" + endTime + \" is not after startTime: \"+ startTime);\n  }\n  this.startTime=startTime;\n  this.endTime=endTime;\n}\n", "docstring": "creates time interval [ starttime , endtime ) if times are not null . creates time interval ( - inf , endtime ) if start time is null . creates time interval [ starttime , + inf ) if end time is null . creates time interval ( - inf , + inf ) if both times are null .", "partition": "test"}
{"idx": "5803", "code": "JMenu createEditMenu(){\n  JMenu editMenu=new JMenu(\"Edit\");\n  editMenu.add(actionManager.getCutAction());\n  editMenu.add(actionManager.getCopyAction());\n  editMenu.add(actionManager.getPasteAction());\n  editMenu.add(actionManager.getDeleteAction());\n  editMenu.addSeparator();\n  editMenu.add(actionManager.getClearSourceNeuronsAction());\n  editMenu.add(actionManager.getSetSourceNeuronsAction());\n  editMenu.add(actionManager.getConnectionMenu());\n  editMenu.add(actionManager.getAddSynapseGroupAction());\n  editMenu.addSeparator();\n  editMenu.add(actionManager.getRandomizeObjectsAction());\n  editMenu.add(actionManager.getShowAdjustSynapsesDialog());\n  editMenu.addSeparator();\n  editMenu.add(actionManager.getLayoutMenu());\n  editMenu.add(actionManager.getGroupMenu());\n  editMenu.addSeparator();\n  editMenu.add(createAlignMenu());\n  editMenu.add(createSpacingMenu());\n  editMenu.addSeparator();\n  editMenu.add(actionManager.getSetNeuronPropertiesAction());\n  editMenu.add(actionManager.getSetSynapsePropertiesAction());\n  editMenu.addSeparator();\n  editMenu.add(createSelectionMenu());\n  return editMenu;\n}\n", "docstring": "create and return a new edit menu for this network panel .", "partition": "test"}
{"idx": "5804", "code": "public void currentState(long state,Model currentModel){\n  currentState=state;\n  if (loggers != null) {\n    for (    Logger logger : loggers) {\n      logger.log(state);\n    }\n  }\n}\n", "docstring": "called to update the current model keepevery states .", "partition": "test"}
{"idx": "5805", "code": "public boolean isBOM(){\n  return m_isBOM;\n}\n", "docstring": "is it a bom", "partition": "test"}
{"idx": "5806", "code": "public boolean isSigned(){\n  return signed;\n}\n", "docstring": "returns whether the object is signed or not .", "partition": "test"}
{"idx": "5807", "code": "public Object parseText(String text){\n  if (text == null || text.length() == 0) {\n    throw new IllegalArgumentException(\"The JSON input text should neither be null nor empty.\");\n  }\n  return parse(new LineColumnReader(new StringReader(text)));\n}\n", "docstring": "parse a text representation of a json data structure", "partition": "test"}
{"idx": "5808", "code": "protected <T>Database makeSimpleDatabase(String filename,int expectedSize,ListParameterization params,Class<?>[] filters){\n  try (InputStream is=open(filename)){\n    List<ObjectFilter> filterlist=new ArrayList<>();\n    filterlist.add(new FixedDBIDsFilter(1));\n    if (filters != null) {\n      for (      Class<?> filtercls : filters) {\n        ObjectFilter filter=ClassGenericsUtil.parameterizeOrAbort(filtercls,params);\n        filterlist.add(filter);\n      }\n    }\n    NumberVectorLabelParser<DoubleVector> parser=new NumberVectorLabelParser<>(DoubleVector.FACTORY);\n    InputStreamDatabaseConnection dbc=new InputStreamDatabaseConnection(is,filterlist,parser);\n    params.addParameter(AbstractDatabase.Parameterizer.DATABASE_CONNECTION_ID,dbc);\n    Database db=ClassGenericsUtil.parameterizeOrAbort(StaticArrayDatabase.class,params);\n    testParameterizationOk(params);\n    db.initialize();\n    Relation<?> rel=db.getRelation(TypeUtil.ANY);\n    assertEquals(\"Database size does not match.\",expectedSize,rel.size());\n    return db;\n  }\n catch (  IOException e) {\n    fail(\"Test data \" + filename + \" not found.\");\n    return null;\n  }\n}\n", "docstring": "generate a simple doublevector database from a file .", "partition": "test"}
{"idx": "5809", "code": "protected void addChooserFilters(JFileChooser chooser){\n  javax.swing.filechooser.FileNameExtensionFilter filter;\n  chooser.addChoosableFileFilter(filter=new javax.swing.filechooser.FileNameExtensionFilter(\"Intel Hex Format Firmware (*.hex)\",\"hex\"));\n  chooser.setFileFilter(filter);\n}\n", "docstring": "add filter ( s ) for possible types to the input file chooser .", "partition": "test"}
{"idx": "5810", "code": "public void onStop(){\n  if (null != mService) {\n    if (null != mContext) {\n      mContext.unbindService(mServiceConnection);\n    }\n    mServiceConnection=null;\n    mService=null;\n  }\n}\n", "docstring": "unbinds the in - app billing service .", "partition": "test"}
{"idx": "5811", "code": "public String peek(){\n  String result=null;\n  if (isEmpty()) {\n    return null;\n  }\n else {\n    int cachedCurrentIndex=currentIndex;\n    if (isEatingBlocksOfDelimiters) {\n      trimStartingDelimiters();\n    }\n    int nearestDelimeter=-1;\n    for (int i=0; i < delimiters.length(); i++) {\n      int delimiter=source.indexOf(delimiters.charAt(i),currentIndex);\n      if (nearestDelimeter == -1 || delimiter != -1 && delimiter < nearestDelimeter) {\n        nearestDelimeter=delimiter;\n      }\n    }\n    if (nearestDelimeter == -1) {\n      result=source.substring(currentIndex);\n    }\n else {\n      result=source.substring(currentIndex,nearestDelimeter);\n    }\n    currentIndex=cachedCurrentIndex;\n  }\n  return result;\n}\n", "docstring": "returns null if there is nothing left .", "partition": "test"}
{"idx": "5812", "code": "private void eliminarUsuariosOrgano(GestionOrganizacionBI organizacionBI,OrganizacionVO organizacionVO){\n  organizacionBI.eliminarUsuariosOrgano(organizacionVO.getId());\n}\n", "docstring": "metodo encargado de borrar todos los usuarios asociados a un determinado organo , siempre y cuando este organo se encuentre en estado vigente .", "partition": "test"}
{"idx": "5813", "code": "private static void addPreviousLayer(List<List<Neuron>> layers,List<Neuron> sourceLayer,List<Neuron> layerToCheck){\n  final int MAXLAYERS=100;\n  Set<Neuron> newLayerTemp=new HashSet<Neuron>();\n  boolean theNextLayerIsTheSourceLayer=false;\n  for (  Neuron neuron : layerToCheck) {\n    for (    Synapse synapse : neuron.getFanIn()) {\n      Neuron sourceNeuron=synapse.getSource();\n      if (sourceLayer.contains(sourceNeuron)) {\n        theNextLayerIsTheSourceLayer=true;\n      }\n      if (sourceNeuron == neuron) {\n        continue;\n      }\n      newLayerTemp.add(synapse.getSource());\n    }\n  }\n  if ((theNextLayerIsTheSourceLayer) || (newLayerTemp.size() == 0) || (layers.size() > MAXLAYERS)) {\n    layers.add(sourceLayer);\n  }\n else {\n    List<Neuron> newLayer=new ArrayList<Neuron>(newLayerTemp);\n    Collections.sort(newLayer,OrientationComparator.X_ORDER);\n    layers.add(newLayer);\n    addPreviousLayer(layers,sourceLayer,newLayer);\n  }\n}\n", "docstring": "helper method for getintermedatelayers . add the \" next layer down \" in the hierarchy .", "partition": "test"}
{"idx": "5814", "code": "public static void ignorm(double c1[],double c2[],int m,double ng){\n  if (ng != 0.0) {\n    double k=Math.pow(c1[0],ng);\n    for (int i=m; i >= 1; i--)     c2[i]=k * c1[i];\n    c2[0]=(k - 1.0) / ng;\n  }\n else {\n    System.arraycopy(c1,1,c2,1,m - 1);\n    c2[0]=Math.log(c1[0]);\n  }\n}\n", "docstring": "ignorm : inverse gain normalization", "partition": "test"}
{"idx": "5815", "code": "public static int findNonwhitespaceCharacter(String s,int index){\n  int sLength=s.length();\n  while (index < sLength && Character.isWhitespace(s.charAt(index))) {\n    index++;\n  }\n  return index;\n}\n", "docstring": "finds the first non - whitespace character starting at index .", "partition": "test"}
{"idx": "5816", "code": "public Primitive(Object value){\n  this.value=value;\n  type=(value != null) ? Utilities.getPrimitiveType(value.getClass()) : null;\n  if (type == null) {\n    throw new IllegalArgumentException(\"value is not a primitive: \" + value);\n  }\n}\n", "docstring": "creates an object that represents a primitive value of the type associated with the specified primitive wrapper object .", "partition": "test"}
{"idx": "5817", "code": "public void createCashBasedJournalEntriesAndReversalsForSavingsTax(final Office office,final String currencyCode,final CASH_ACCOUNTS_FOR_SAVINGS accountTypeToBeDebited,final CASH_ACCOUNTS_FOR_SAVINGS accountTypeToBeCredited,final Long savingsProductId,final Long paymentTypeId,final Long savingsId,final String transactionId,final Date transactionDate,final BigDecimal amount,final Boolean isReversal,final List<TaxPaymentDTO> taxDetails){\n  for (  TaxPaymentDTO taxPaymentDTO : taxDetails) {\n    if (taxPaymentDTO.getAmount() != null) {\n      if (taxPaymentDTO.getCreditAccountId() == null) {\n        createCashBasedCreditJournalEntriesAndReversalsForSavings(office,currencyCode,accountTypeToBeCredited.getValue(),savingsProductId,paymentTypeId,savingsId,transactionId,transactionDate,taxPaymentDTO.getAmount(),isReversal);\n      }\n else {\n        createCashBasedCreditJournalEntriesAndReversalsForSavings(office,currencyCode,taxPaymentDTO.getCreditAccountId(),savingsId,transactionId,transactionDate,taxPaymentDTO.getAmount(),isReversal);\n      }\n    }\n  }\n  createCashBasedDebitJournalEntriesAndReversalsForSavings(office,currencyCode,accountTypeToBeDebited.getValue(),savingsProductId,paymentTypeId,savingsId,transactionId,transactionDate,amount,isReversal);\n}\n", "docstring": "convenience method that creates a pair of related debits and credits for cash based accounting . the target accounts for debits and credits are switched in case of a reversal", "partition": "test"}
{"idx": "5818", "code": "public int read(ByteBuf dst,int dstStart,int dstLength) throws IOException {\n  final int remaining=(int)Math.min(this.length - this.position,Integer.MAX_VALUE);\n  final int read=Math.min(remaining,dstLength);\n  final int bufferPosition=checkOffset(position,read);\n  final long srcAddress=PlatformDependent.directBufferAddress(lastMapped) + bufferPosition;\n  if (dst.hasMemoryAddress()) {\n    final long dstAddress=dst.memoryAddress() + dstStart;\n    PlatformDependent.copyMemory(srcAddress,dstAddress,read);\n  }\n else   if (dst.hasArray()) {\n    final byte[] dstArray=dst.array();\n    PlatformDependent.copyMemory(srcAddress,dstArray,dstStart,read);\n  }\n else {\n    throw new IllegalArgumentException(\"unsupported byte buffer\");\n  }\n  position+=read;\n  return read;\n}\n", "docstring": "reads a sequence of bytes from this file into the given buffer . < p > < p > bytes are read starting at this file \"'\" s current position , and then the position is updated with the number of bytes actually read .", "partition": "test"}
{"idx": "5819", "code": "public static Calendar clearTime(final Calendar self){\n  clearTimeCommon(self);\n  return self;\n}\n", "docstring": "clears the time portion of this calendar instance ; useful utility where it makes sense to compare month / day / year only portions of a calendar .", "partition": "test"}
{"idx": "5820", "code": "public double pdf(int k){\n  return Math.exp(k * Math.log(this.mean) - Arithmetic.logFactorial(k) - this.mean);\n}\n", "docstring": "returns the probability distribution function .", "partition": "test"}
{"idx": "5821", "code": "public static void appendUnpaddedInteger(StringBuffer buf,long value){\n  int intValue=(int)value;\n  if (intValue == value) {\n    appendUnpaddedInteger(buf,intValue);\n  }\n else {\n    buf.append(Long.toString(value));\n  }\n}\n", "docstring": "converts an integer to a string , and appends it to the given buffer . < p > this method is optimized for converting small values to strings .", "partition": "test"}
{"idx": "5822", "code": "private void drawTextElements(Canvas canvas,float textSize,Typeface typeface,ColorStateList textColor,String[] texts,float[] textX,float[] textY,Paint paint,int alpha,boolean showActivated,int activatedDegrees,boolean activatedOnly){\n  paint.setTextSize(textSize);\n  paint.setTypeface(typeface);\n  final float activatedIndex=activatedDegrees / (360.0f / NUM_POSITIONS);\n  final int activatedFloor=(int)activatedIndex;\n  final int activatedCeil=((int)Math.ceil(activatedIndex)) % NUM_POSITIONS;\n  for (int i=0; i < 12; i++) {\n    final boolean activated=(activatedFloor == i || activatedCeil == i);\n    if (activatedOnly && !activated) {\n      continue;\n    }\n    final int[] stateMask=new int[]{android.R.attr.state_enabled,(showActivated && activated ? android.R.attr.state_selected : 0)};\n    final int color=textColor.getColorForState(stateMask,0);\n    paint.setColor(color);\n    paint.setAlpha(getMultipliedAlpha(color,alpha));\n    canvas.drawText(texts[i],textX[i],textY[i],paint);\n  }\n}\n", "docstring": "draw the 12 text values at the positions specified by the textgrid parameters .", "partition": "test"}
{"idx": "5823", "code": "public void testFindSpringActiveDirectoryWithLimit(){\n  LdapProxy proxy=getLdapAD();\n  List result=null;\n  int limit=1;\n  try {\n    result=proxy.find(getLdapSearchVO(\"\",limit,\"cn\",\"nacho\",null,LdapScopeConstants.SCOPE_SUBTREE));\n  }\n catch (  Exception e) {\n  }\n  assertNotNull(result);\n  if (result != null) {\n    assertEquals(limit,result.size());\n  }\n}\n", "docstring": "test de busqueda active directory con limite", "partition": "test"}
{"idx": "5824", "code": "@Override public void handleKey(int virtualKeyCode,int transitionState,char keyChar){\n  switchControlKeys(virtualKeyCode,transitionState);\n  inputBuffer.add(new GlobalKeyEvent(this,virtualKeyCode,transitionState,keyChar,menuPressed,shiftPressed,controlPressed,extendedKey));\n}\n", "docstring": "handle the input virtualkeycode and transitionstate , create event and add it to the inputbuffer", "partition": "test"}
{"idx": "5825", "code": "public int hashCode(){\n  return alignment ^ leader ^ Math.round(position);\n}\n", "docstring": "returns the hashcode for the object . this must be defined here to ensure 100 % pure .", "partition": "test"}
{"idx": "5826", "code": "public static String stripLeadingPeriod(String s){\n  if (null != s && s.startsWith(\".\"))   return s.substring(Math.min(1,s.length()),s.length());\n  return s;\n}\n", "docstring": "strips leading period from a string ( example : input - > \" . ext \" , output - > \" ext \" )", "partition": "test"}
{"idx": "5827", "code": "private void cleanUpLabels(){\n  int id=0;\n  for (Iterator<Label> i=labels.iterator(); i.hasNext(); ) {\n    Label label=i.next();\n    if (label.isEmpty()) {\n      i.remove();\n    }\n else {\n      label.compact();\n      label.id=id++;\n    }\n  }\n}\n", "docstring": "removes empty labels and assigns ids to non - empty labels .", "partition": "test"}
{"idx": "5828", "code": "public static long nanosFromDate(long ms){\n  Calendar cal=getCalendar();\n  cal.setTimeInMillis(ms);\n  return nanosFromCalendar(cal);\n}\n", "docstring": "convert a time in milliseconds in utc to the nanoseconds since midnight ( in the default timezone ) .", "partition": "test"}
{"idx": "5829", "code": "@Override default CompletableFuture<OptionalLong> maxLong(final ToLongFunction<? super T> fn){\n  return CompletableFuture.supplyAsync(null,getExec());\n}\n", "docstring": "perform an asynchronous max operation", "partition": "test"}
{"idx": "5830", "code": "protected BalancedWebResource createHttpsClient(final String username,final String password,List<String> hosts) throws NoSuchAlgorithmException {\n  return createHttpsClient(username,password,hosts,true);\n}\n", "docstring": "create the httpsclient , returns a balancedwebresource that can be used the same way a webresource is .", "partition": "test"}
{"idx": "5831", "code": "public static char[] createArraySignature(char[] typeSignature,int arrayCount){\n  if (arrayCount == 0)   return typeSignature;\n  int sigLength=typeSignature.length;\n  char[] result=new char[arrayCount + sigLength];\n  for (int i=0; i < arrayCount; i++) {\n    result[i]=C_ARRAY;\n  }\n  System.arraycopy(typeSignature,0,result,arrayCount,sigLength);\n  return result;\n}\n", "docstring": "creates a new type signature with the given amount of array nesting added to the given type signature .", "partition": "test"}
{"idx": "5832", "code": "public void println() throws IOException {\n  writer.write(format.getLineSeparator());\n}\n", "docstring": "writes the new line text to the underlying writer", "partition": "test"}
{"idx": "5833", "code": "protected void increaseBufferSize(int minSize){\n  int newLength=buf.length;\n  while (newLength < minSize)   newLength*=2;\n  double[] newBuf=new double[newLength];\n  int avail=currentlyInBuffer();\n  System.arraycopy(buf,readPos,newBuf,0,avail);\n  buf=newBuf;\n  readPos=0;\n  writePos=avail;\n}\n", "docstring": "increase the underlying buffer array in size , so that the new size is at least minsize", "partition": "test"}
{"idx": "5834", "code": "private void handleEnumeratedAttribute(Instances trainInstances) throws Exception {\n  Instance instance;\n  m_distribution=new Distribution(m_complexityIndex,trainInstances.numClasses());\n  Enumeration<Instance> enu=trainInstances.enumerateInstances();\n  while (enu.hasMoreElements()) {\n    instance=enu.nextElement();\n    if (!instance.isMissing(m_attIndex)) {\n      m_distribution.add((int)instance.value(m_attIndex),instance);\n    }\n  }\n  if (m_distribution.check(m_minNoObj)) {\n    m_numSubsets=m_complexityIndex;\n    m_infoGain=infoGainCrit.splitCritValue(m_distribution,m_sumOfWeights);\n    m_gainRatio=gainRatioCrit.splitCritValue(m_distribution,m_sumOfWeights,m_infoGain);\n  }\n}\n", "docstring": "creates split on enumerated attribute .", "partition": "test"}
{"idx": "5835", "code": "@Override protected Node removeFromFrontier(){\n  Node result=frontier.remove();\n  frontierNodeLookup.remove(result.getState());\n  explored.add(result.getState());\n  updateMetrics(frontier.size());\n  return result;\n}\n", "docstring": "removes the node at the head of the frontier , adds the corresponding state to the explored set , and returns the node .", "partition": "test"}
{"idx": "5836", "code": "public static String encode(byte[] data){\n  int start=0;\n  int len=data.length;\n  StringBuffer buf=new StringBuffer(data.length * 3 / 2);\n  int end=len - 3;\n  int i=start;\n  int n=0;\n  while (i <= end) {\n    int d=((((int)data[i]) & 0x0ff) << 16) | ((((int)data[i + 1]) & 0x0ff) << 8) | (((int)data[i + 2]) & 0x0ff);\n    buf.append(legalChars[(d >> 18) & 63]);\n    buf.append(legalChars[(d >> 12) & 63]);\n    buf.append(legalChars[(d >> 6) & 63]);\n    buf.append(legalChars[d & 63]);\n    i+=3;\n    if (n++ >= 14) {\n      n=0;\n    }\n  }\n  if (i == start + len - 2) {\n    int d=((((int)data[i]) & 0x0ff) << 16) | ((((int)data[i + 1]) & 255) << 8);\n    buf.append(legalChars[(d >> 18) & 63]);\n    buf.append(legalChars[(d >> 12) & 63]);\n    buf.append(legalChars[(d >> 6) & 63]);\n    buf.append(\"=\");\n  }\n else   if (i == start + len - 1) {\n    int d=(((int)data[i]) & 0x0ff) << 16;\n    buf.append(legalChars[(d >> 18) & 63]);\n    buf.append(legalChars[(d >> 12) & 63]);\n    buf.append(\"==\");\n  }\n  return buf.toString();\n}\n", "docstring": "base64 encode the given data .", "partition": "test"}
{"idx": "5837", "code": "public static Font createBitmapFont(String name,Image bitmap,int[] cutOffsets,int[] charWidth,String charsets){\n  Font f=createBitmapFont(bitmap,cutOffsets,charWidth,charsets);\n  bitmapCache.put(name,f);\n  return f;\n}\n", "docstring": "creates a bitmap font with the given arguments and places said font in the cache", "partition": "test"}
{"idx": "5838", "code": "static boolean isTenured(MemoryPoolMXBean memoryPoolMXBean){\n  if (memoryPoolMXBean.getType() != MemoryType.HEAP) {\n    return false;\n  }\n  String name=memoryPoolMXBean.getName();\n  return name.equals(\"CMS Old Gen\") || name.equals(\"PS Old Gen\") || name.equals(\"G1 Old Gen\")|| name.equals(\"Old Space\")|| name.equals(\"Tenured Gen\")|| name.equals(\"Java heap\")|| name.equals(\"GenPauseless Old Gen\")|| (HEAP_POOL != null && name.equals(HEAP_POOL));\n}\n", "docstring": "determines if the name of the memory pool mxbean provided matches a list of known tenured pool names . package private for testing .", "partition": "test"}
{"idx": "5839", "code": "public String toSimpleString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(\"DataSet, label: \" + (mLabel == null ? \"\" : mLabel) + \", entries: \"+ mYVals.size()+ \"\\n\");\n  return buffer.toString();\n}\n", "docstring": "returns a simple string representation of the dataset with the type and the number of entries .", "partition": "test"}
{"idx": "5840", "code": "public static <T>T interpreterOnly(Callable<T> callable) throws Exception {\n  return callable.call();\n}\n", "docstring": "directive for the compiler that the given callable should only be executed in the interpreter .", "partition": "test"}
{"idx": "5841", "code": "private void addSelectorForProtocol(Properties settings,String protocol,ProtocolDispatchSelector ps){\n  String proxy=settings.getProperty(protocol);\n  if (proxy != null) {\n    FixedProxySelector protocolSelector=ProxyUtil.parseProxySettings(proxy);\n    ps.setSelector(protocol,protocolSelector);\n  }\n}\n", "docstring": "creates a selector for a given protocol . the proxy will be taken from the settings and installed on the dispatch selector .", "partition": "test"}
{"idx": "5842", "code": "public static void readSkel(BufferedReader reader) throws IOException {\n  List<String> lines=new ArrayList<String>();\n  StringBuilder section=new StringBuilder();\n  String ln;\n  while ((ln=reader.readLine()) != null) {\n    if (ln.startsWith(\"---\")) {\n      lines.add(section.toString());\n      section.setLength(0);\n    }\n else {\n      section.append(ln);\n      section.append(NL);\n    }\n  }\n  if (section.length() > 0)   lines.add(section.toString());\n  if (lines.size() != size) {\n    Out.error(ErrorMessages.WRONG_SKELETON);\n    throw new GeneratorException();\n  }\n  line=new String[size];\n  for (int i=0; i < size; i++)   line[i]=lines.get(i);\n}\n", "docstring": "reads an external skeleton file from a bufferedreader .", "partition": "test"}
{"idx": "5843", "code": "public static Set<String> nonMonogamousSamples(Collection<Family> families){\n  final LinkedHashSet<String> ret=new LinkedHashSet<>();\n  final HashSet<String> parents=new HashSet<>();\n  for (  Family f : families) {\n    if (!parents.add(f.getFather())) {\n      ret.add(f.getFather());\n    }\n    if (!parents.add(f.getMother())) {\n      ret.add(f.getMother());\n    }\n  }\n  return ret;\n}\n", "docstring": "detects the presence of genetic non - monogamy within an set of families", "partition": "test"}
{"idx": "5844", "code": "public boolean contains(File file,String fileContent){\n  if (exists(file)) {\n    String content=readFileContent(file);\n    return content != null && content.equals(fileContent);\n  }\n  return false;\n}\n", "docstring": "returns boolean indicating whether this file contains the content value .", "partition": "test"}
{"idx": "5845", "code": "public static boolean[][] loadImage(File file,char offChar) throws FileNotFoundException, RuntimeException {\n  ArrayList<String> rows=loadImagePad(file,offChar);\n  String s=rows.get(0);\n  boolean[][] img=new boolean[rows.size()][s.length()];\n  for (int i=0; i < rows.size(); i++) {\n    s=rows.get(i);\n    for (int j=0; j < s.length(); j++) {\n      char c=s.charAt(j);\n      if (c == offChar) {\n        img[i][j]=false;\n      }\n else {\n        img[i][j]=true;\n      }\n    }\n  }\n  return img;\n}\n", "docstring": "load up an image from the given file , where only the off character is known . pads short lines with offchar .", "partition": "test"}
{"idx": "5846", "code": "protected void updateReceiptStatusWhenCancelled(final String receiptNumber){\n  final List<EgdmCollectedReceipt> egdmCollectedReceipts=demandGenericDAO.getAllEgdmCollectedReceipts(receiptNumber);\n  if (egdmCollectedReceipts != null && !egdmCollectedReceipts.isEmpty())   for (  final EgdmCollectedReceipt egDmCollectedReceipt : egdmCollectedReceipts) {\n    egDmCollectedReceipt.setStatus(DemandConstants.CANCELLED_RECEIPT);\n    egDmCollectedReceipt.setUpdatedTime(new Date());\n    egdmCollectedReceiptDAO.update(egDmCollectedReceipt);\n  }\n}\n", "docstring": "when receipt is cancelled the status of the receipt in egdmcollectedreceipts is updated as cancelled .", "partition": "test"}
{"idx": "5847", "code": "public void addAnimation(int id,Animation... animations){\n  if (mAnimations.get(id) == null) {\n    mAnimations.put(id,new ArrayList<Animation>(animations.length));\n    if (id != Animation.FULL_PAGE) {\n      mAnimatedViews.add(id);\n    }\n  }\n  ArrayList<Animation> anims=mAnimations.get(id);\n  Collections.addAll(anims,animations);\n}\n", "docstring": "add animations to the target view . the view \"'\" s id is used as key .", "partition": "test"}
{"idx": "5848", "code": "@Override protected void initialize(){\n  List<String> words;\n  super.initialize();\n  m_Words=new HashSet<String>();\n  words=read();\n  for (  String word : words) {\n    if (!word.startsWith(\"#\"))     m_Words.add(word);\n  }\n}\n", "docstring": "performs intialization of the scheme .", "partition": "test"}
{"idx": "5849", "code": "protected boolean existsInRange(String x,int minLength,int maxLength){\n  x=StringUtils.trimToNull(x);\n  return x != null && x.length() >= minLength && x.length() <= maxLength;\n}\n", "docstring": "checks if string has a length in a certain range .", "partition": "test"}
{"idx": "5850", "code": "public synchronized void unwatch(String pathName) throws IOException {\n  unregisterAll(Paths.get(pathName));\n}\n", "docstring": "recursively listen for file system events in the specified path name .", "partition": "test"}
{"idx": "5851", "code": "public Criteria addProperty(String name,String value,Operator operator){\n  properties.add(new PropertyCriteria(name,value,operator));\n  return this;\n}\n", "docstring": "this method adds a new property criteria .", "partition": "test"}
{"idx": "5852", "code": "public void removeColumn(final String columnName){\n  if (columnName == null) {\n    return;\n  }\n  final List<String> cols=Arrays.asList(getInfo().headers);\n  final int colIndex=cols.indexOf(columnName);\n  removeColumn(colIndex);\n}\n", "docstring": "remove the column represented by its name", "partition": "test"}
{"idx": "5853", "code": "public static UnManagedProtectionSet checkUnManagedProtectionSetExistsInDB(DbClient dbClient,String nativeGuid) throws IOException {\n  List<UnManagedProtectionSet> cgs=CustomQueryUtility.getUnManagedProtectionSetByNativeGuid(dbClient,nativeGuid);\n  Iterator<UnManagedProtectionSet> cgsItr=cgs.iterator();\n  if (cgsItr.hasNext()) {\n    return cgsItr.next();\n  }\n  return null;\n}\n", "docstring": "check unmanaged protection set exists in db", "partition": "test"}
{"idx": "5854", "code": "private void checkQuery(String expRes,String qry) throws Exception {\n  assertEquals(0,executeHiveQuery(\"drop table if exists result\"));\n  assertEquals(0,executeHiveQuery(\"create table result \" + \"row format delimited fields terminated by \' \' \" + \"stored as textfile \"+ \"location \'/result\' as \"+ qry));\n  IgfsInputStream in=igfs.open(new IgfsPath(\"/result/000000_0\"));\n  byte[] buf=new byte[(int)in.length()];\n  in.read(buf);\n  assertEquals(expRes,new String(buf));\n}\n", "docstring": "runs query check result .", "partition": "test"}
{"idx": "5855", "code": "public final V updateAndGet(UnaryOperator<V> updateFunction){\n  V prev, next;\n  do {\n    prev=get();\n    next=updateFunction.apply(prev);\n  }\n while (!compareAndSet(prev,next));\n  return next;\n}\n", "docstring": "atomically updates the current value with the results of applying the given function , returning the updated value . the function should be side - effect - free , since it may be re - applied when attempted updates fail due to contention among threads .", "partition": "test"}
{"idx": "5856", "code": "public void close(){\n  stopTimers();\n  closed=true;\n  window.dispose();\n  if (listener != null) {\n    listener.notificationRemoved(this);\n  }\n  if (activityListener != null) {\n    ActivityTracker.removeActivityListener(activityListener);\n  }\n}\n", "docstring": "close the window immediately and cleanup .", "partition": "test"}
{"idx": "5857", "code": "protected boolean shouldMove(final ILoadBalancerService loadBalancerService){\n  if (loadBalancerService == null)   throw new IllegalArgumentException();\n  final boolean highlyUtilizedService;\n  try {\n    final UUID serviceUUID=resourceManager.getDataServiceUUID();\n    highlyUtilizedService=loadBalancerService.isHighlyUtilizedDataService(serviceUUID);\n  }\n catch (  Exception ex) {\n    log.warn(\"Could not determine if this data service is highly utilized\");\n    return false;\n  }\n  if (!highlyUtilizedService) {\n    if (log.isInfoEnabled())     log.info(\"Service is not highly utilized.\");\n    return false;\n  }\n  final ResourceScores resourceScores=resourceManager.getResourceScores();\n  final boolean shouldMove=(resourceScores.percentCPUTime >= resourceManager.movePercentCpuTimeThreshold) || (resourceScores.majorPageFaultsPerSec > 20) || (resourceScores.dataDirBytesFree < Bytes.gigabyte * 5)|| (resourceScores.dataDirBytesFree < Bytes.gigabyte * .5);\n  return shouldMove;\n}\n", "docstring": "figure out if this data service is considered to be highly utilized , in which case the ds should shed some index partitions . < p > note : we consult the load balancer service on this since it is able to put the load of this service into perspective by also considering the load on the other services in the federation .", "partition": "test"}
{"idx": "5858", "code": "private static Object[] convertThrowableMessages(final Object[] args){\n  if (args != null) {\n    for (int i=0; i < args.length; i++) {\n      if (args[i] instanceof Throwable) {\n        Throwable t=(Throwable)args[i];\n        if (t.getMessage() != null) {\n          args[i]=t.getMessage();\n        }\n      }\n    }\n  }\n  return args;\n}\n", "docstring": "converts all throwable arguments to its message if the message is not null", "partition": "test"}
{"idx": "5859", "code": "protected void wrapContent(){\n  if (!DO_WRAP) {\n    return;\n  }\n  if (mText == null) {\n    return;\n  }\n  Canvas c=new Canvas();\n  c.setFont(mFont);\n  FontMetrics fm=c.getFontMetrics(mFont);\n  String string=getText();\n  if (mToUpperCase) {\n    string=string.toUpperCase();\n  }\n  int tw=fm.stringWidth(string) + 2 * (mHorizontalPadding + mHorizontalMargin);\n  int th=fm.getMaxAscent() + 2 * fm.getMaxDescent() + 2 * (mVerticalPadding + mVerticalMargin);\n  mWidget.setWrapWidth(tw);\n  mWidget.setWrapHeight(th);\n  if (tw > mWidget.getMinWidth()) {\n    mWidget.setMinWidth(tw);\n  }\n  if (th > mWidget.getMinHeight()) {\n    mWidget.setMinHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setWidth(tw);\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {\n    mWidget.setHeight(th);\n  }\n  if (mWidget.getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getWidth() <= mWidget.getMinWidth()) {\n      mWidget.setHorizontalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  if (mWidget.getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.FIXED) {\n    if (mWidget.getHeight() <= mWidget.getMinHeight()) {\n      mWidget.setVerticalDimensionBehaviour(ConstraintWidget.DimensionBehaviour.WRAP_CONTENT);\n    }\n  }\n  int baseline=fm.getAscent() + fm.getMaxDescent() + mVerticalPadding+ mVerticalMargin;\n  mWidget.setBaselineDistance(baseline);\n}\n", "docstring": "utility method computing the size of the widget if dimensions are set to wrap_content , using the default font", "partition": "test"}
{"idx": "5860", "code": "public RAFDirectory(Path path,LockFactory lockFactory) throws IOException {\n  super(path,lockFactory);\n  path.toFile();\n}\n", "docstring": "create a new rafdirectory for the named location . the directory is created at the named location if it does not yet exist .", "partition": "test"}
{"idx": "5861", "code": "public static void addMinutesToList(Context context,ArrayList<Integer> values,ArrayList<String> labels,int minutes){\n  int index=values.indexOf(minutes);\n  if (index != -1) {\n    return;\n  }\n  String label=constructReminderLabel(context,minutes,false);\n  int len=values.size();\n  for (int i=0; i < len; i++) {\n    if (minutes < values.get(i)) {\n      values.add(i,minutes);\n      labels.add(i,label);\n      return;\n    }\n  }\n  values.add(minutes);\n  labels.add(len,label);\n}\n", "docstring": "if \" minutes \" is not currently present in \" values \" , we add an appropriate new entry to values and labels .", "partition": "test"}
{"idx": "5862", "code": "public void propertyChange(PropertyChangeEvent e){\n  String propertyName=e.getPropertyName();\n  if (propertyName == \"visible\") {\n    if (e.getOldValue() == Boolean.FALSE && e.getNewValue() == Boolean.TRUE) {\n      handlePopupIsVisibleEvent(true);\n    }\n else     if (e.getOldValue() == Boolean.TRUE && e.getNewValue() == Boolean.FALSE) {\n      handlePopupIsVisibleEvent(false);\n    }\n  }\n}\n", "docstring": "this method gets called when a bound property is changed .", "partition": "test"}
{"idx": "5863", "code": "private static int[] maybeSort(int[] values){\n  if (!isSorted(values,0,false)) {\n    values=values.clone();\n    Arrays.sort(values);\n  }\n  return values;\n}\n", "docstring": "clone and sort the array , if not already sorted .", "partition": "test"}
{"idx": "5864", "code": "private void doTextNormal(final PDFPage cmds,final String text){\n  final PointF zero=new PointF();\n  final Matrix scale=new Matrix();\n  Utils.setMatValues(scale,fsize,0,0,fsize * th,0,tr);\n  final Matrix at=new Matrix();\n  final List<PDFGlyph> l=(List<PDFGlyph>)font.getGlyphs(text);\n  for (  final PDFGlyph glyph : l) {\n    at.set(cur);\n    at.preConcat(scale);\n    final PointF advance=glyph.addCommands(cmds,at,tm);\n    float advanceX=(advance.x * fsize) + tc;\n    if (glyph.getChar() == ' ') {\n      advanceX+=tw;\n    }\n    advanceX*=th;\n    cur.preTranslate(advanceX,advance.y);\n  }\n  final float[] src={zero.x,zero.y};\n  final float[] dst=new float[src.length];\n  cur.mapPoints(dst,src);\n  prevEnd.set(dst[0],dst[1]);\n}\n", "docstring": "add some text to the page .", "partition": "test"}
{"idx": "5865", "code": "public synchronized static void initialize(Connection conn) throws SQLException {\n  if (logHadoopIdPatterns != null && logLineagePatterns != null) {\n    return;\n  }\n  loadLineagePatterns(conn);\n  loadHadoopIdPatterns(conn);\n}\n", "docstring": "initialize , download the regex info into cache", "partition": "test"}
{"idx": "5866", "code": "public void addIndices(Collection<IIndex> indices){\n  for (Iterator<IIndex> it=indices.iterator(); it.hasNext(); ) {\n    addIndex((IIndex)it.next());\n  }\n}\n", "docstring": "adds the given indices .", "partition": "test"}
{"idx": "5867", "code": "public static boolean isCookieSecure(){\n  return secureCookie;\n}\n", "docstring": "gets property value of \" com . iplanet . am . cookie . secure \"", "partition": "test"}
{"idx": "5868", "code": "public static List<ObjectModel> loadJsonStream(InputStream input){\n  List<ObjectModel> models=new ArrayList<>();\n  Reader reader=new InputStreamReader(input);\n  ObjectModel[] objectModels=GSON.fromJson(reader,ObjectModel[].class);\n  for (  ObjectModel objectModel : objectModels) {\n    models.add(objectModel);\n  }\n  return models;\n}\n", "docstring": "load object definitions from json stream .", "partition": "test"}
{"idx": "5869", "code": "private int addWordlenWeights(Channel chan,int weightIdx){\n  int[] weigthsTab=atrac3p_wl_weights[chan.chNum * 3 + weightIdx - 1];\n  for (int i=0; i < ctx.numQuantUnits; i++) {\n    chan.quWordlen[i]+=weigthsTab[i];\n    if (chan.quWordlen[i] < 0 || chan.quWordlen[i] > 7) {\n      log.error(String.format(\"WL index out of range pos=%d, val=%d\",i,chan.quWordlen[i]));\n      return AT3P_ERROR;\n    }\n  }\n  return 0;\n}\n", "docstring": "add weighting coefficients to the decoded word - length information .", "partition": "test"}
{"idx": "5870", "code": "final void pruneExceptionalOut(IR ir){\n  int n=getNumberOfExceptionalOut();\n  if (n > 0) {\n    ComputedBBEnum handlers=new ComputedBBEnum(n);\n    Enumeration<Instruction> e=forwardRealInstrEnumerator();\n    while (e.hasMoreElements()) {\n      Instruction x=e.nextElement();\n      Enumeration<BasicBlock> bbs=getApplicableExceptionalOut(x);\n      while (bbs.hasMoreElements()) {\n        BasicBlock bb=bbs.nextElement();\n        handlers.addPossiblyDuplicateElement(bb);\n      }\n    }\n    deleteExceptionalOut();\n    for (int i=0; handlers.hasMoreElements(); i++) {\n      ExceptionHandlerBasicBlock b=(ExceptionHandlerBasicBlock)handlers.nextElement();\n      insertOut(b);\n    }\n  }\n  recomputeNormalOut(ir);\n}\n", "docstring": "prune away exceptional out edges that are not reachable given this block \"'\" s instructions .", "partition": "test"}
{"idx": "5871", "code": "private Pair<DBIDVar,Double> singleIteration(Relation<V> relationx,Relation<? extends NumberVector> relationy){\n  final int dim=RelationUtil.dimensionality(relationx);\n  final int dimy=RelationUtil.dimensionality(relationy);\n  assert (dim == 2);\n  KNNQuery<V> knnQuery=QueryUtil.getKNNQuery(relationx,getDistanceFunction(),k + 1);\n  ArrayModifiableDBIDs ids=DBIDUtil.newArray(relationx.getDBIDs());\n  ids.sort();\n  double[][] X=new double[ids.size()][6];\n  double[][] F=new double[ids.size()][ids.size()];\n  double[][] Y=new double[ids.size()][dimy];\n{\n    int i=0;\n    for (DBIDIter id=ids.iter(); id.valid(); id.advance(), i++) {\n{\n        V vec=relationx.get(id);\n        double la=vec.doubleValue(0);\n        double lo=vec.doubleValue(1);\n        X[i][0]=1.0;\n        X[i][1]=la;\n        X[i][2]=lo;\n        X[i][3]=la * lo;\n        X[i][4]=la * la;\n        X[i][5]=lo * lo;\n      }\n{\n        final NumberVector vecy=relationy.get(id);\n        for (int d=0; d < dimy; d++) {\n          double idy=vecy.doubleValue(d);\n          Y[i][d]=idy;\n        }\n      }\n{\n        KNNList neighbors=knnQuery.getKNNForDBID(id,k + 1);\n        ModifiableDBIDs neighborhood=DBIDUtil.newArray(neighbors.size());\n        for (DBIDIter neighbor=neighbors.iter(); neighbor.valid(); neighbor.advance()) {\n          if (DBIDUtil.equal(id,neighbor)) {\n            continue;\n          }\n          neighborhood.add(neighbor);\n        }\n        F[i][i]=1.0;\n        final int nweight=-1 / neighborhood.size();\n        for (DBIDIter iter=neighborhood.iter(); iter.valid(); iter.advance()) {\n          int pos=ids.binarySearch(iter);\n          assert (pos >= 0);\n          F[pos][i]=nweight;\n        }\n      }\n    }\n  }\n  double[][] common=times(transposeTimesTranspose(X,F),F);\n  double[][] b=times(inverse(times(common,X)),times(common,Y));\n  double[][] sigmaMat=times(F,minusEquals(times(X,b),times(F,Y)));\n  final double sigma_sum_square=normF(sigmaMat) / (relationx.size() - 6 - 1);\n  final double norm=1 / Math.sqrt(sigma_sum_square);\n  double[][] E=timesEquals(times(F,minus(Y,times(X,b))),norm);\n  DBIDVar worstid=DBIDUtil.newVar();\n  double worstscore=Double.NEGATIVE_INFINITY;\n  int i=0;\n  for (DBIDIter id=ids.iter(); id.valid(); id.advance(), i++) {\n    double err=squareSum(getRow(E,i));\n    if (err > worstscore) {\n      worstscore=err;\n      worstid.set(id);\n    }\n  }\n  return new Pair<>(worstid,Math.sqrt(worstscore));\n}\n", "docstring": "run a single iteration of the gls - sod modeling step", "partition": "test"}
{"idx": "5872", "code": "public String toSpacedString(){\n  final String original=toString();\n  final StringBuilder builder=new StringBuilder();\n  for (int i=0; i < original.length(); i++) {\n    if (i > 0 && (i % 4) == 0)     builder.append(' ');\n    builder.append(original.charAt(i));\n  }\n  return builder.toString();\n}\n", "docstring": "return a spaced fingerprint representation of this hexdigest . ex : 1e0f 5874 2268 e82f c600 d81d 9064 07c5 7cc2 c3a7", "partition": "test"}
{"idx": "5873", "code": "private int parseContentType(final byte[] b,final int off) throws ParseException {\n  contentTypeVal_=PrimitivesParser.parseByte(b,off);\n  if (ContentType.deserialize(contentTypeVal_) == null) {\n    throw new BadCiphertextException(\"Invalid content type in ciphertext.\");\n  }\n  return 1;\n}\n", "docstring": "parse the content type in the provided bytes . it looks for a single byte in the provided bytes starting at the specified off . < p > if successful , it returns 1 indicating that a byte was parsed . on failure , it throws a parse exception .", "partition": "test"}
{"idx": "5874", "code": "@Benchmark public void nonCaching(){\n  run();\n}\n", "docstring": "no cache for deserialized strings , each string is an own instance .", "partition": "test"}
{"idx": "5875", "code": "private void rLineTo(float dx,float dy){\n  if (isEmpty()) {\n    mPath.moveTo(mLastX=0,mLastY=0);\n  }\n  dx+=mLastX;\n  dy+=mLastY;\n  mPath.lineTo(mLastX=dx,mLastY=dy);\n}\n", "docstring": "same as lineto , but the coordinates are considered relative to the last point on this contour . if there is no previous point , then a moveto ( 0 , 0 ) is inserted automatically .", "partition": "test"}
{"idx": "5876", "code": "@Override public ConflictResults parseOutput(final String stdout,final String stderr){\n  final List<String> contentConflicts=new ArrayList<String>();\n  final List<String> renameConflicts=new ArrayList<String>();\n  final List<String> bothConflicts=new ArrayList<String>();\n  final String[] lines=getLines(stderr);\n  for (  final String line : lines) {\n    final int index=line.lastIndexOf(\":\");\n    if (index != -1) {\n      if (StringUtils.endsWith(line,BOTH_CONFLICTS_SUFFIX)) {\n        bothConflicts.add(line.substring(0,index));\n      }\n else       if (StringUtils.endsWith(line,RENAME_CONFLICT_SUFFIX)) {\n        renameConflicts.add(line.substring(0,index));\n      }\n else {\n        contentConflicts.add(line.substring(0,index));\n      }\n    }\n  }\n  return new ConflictResults(contentConflicts,renameConflicts,bothConflicts);\n}\n", "docstring": "outputs the conflicts found in the workspace in the following format : < p / > tfstest_01 / addfold / testhere2 : the item content has changed tfstest_01 / testadd . txt : the item content has changed", "partition": "test"}
{"idx": "5877", "code": "protected void sendStart(final OutputStream out) throws IOException {\n  LOG.trace(\"enter sendStart(OutputStream out)\");\n  out.write(EXTRA_BYTES);\n  out.write(getPartBoundary());\n  out.write(CRLF_BYTES);\n}\n", "docstring": "write the start to the specified output stream", "partition": "test"}
{"idx": "5878", "code": "public void addActualQty(BigDecimal add){\n  m_actualQty=m_actualQty.add(add);\n}\n", "docstring": "add to actual qty", "partition": "test"}
{"idx": "5879", "code": "protected static boolean isVowel(final char c){\n  final char l=Character.toLowerCase(c);\n  return ((l == 'a') || (l == 'e') || (l == 'i')|| (l == 'o')|| (l == 'u'));\n}\n", "docstring": "is the character a vowel ?", "partition": "test"}
{"idx": "5880", "code": "public static void printStackTrace(SQLException e,PrintWriter pw){\n  SQLException next=e;\n  while (next != null) {\n    next.printStackTrace(pw);\n    next=next.getNextException();\n    if (next != null) {\n      pw.println(\"Next SQLException:\");\n    }\n  }\n}\n", "docstring": "print the stack trace for a sqlexception to a specified printwriter .", "partition": "test"}
{"idx": "5881", "code": "protected void initializeWorld(){\n  Body ground=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(100.0,1.0);\n    BodyFixture bf=new BodyFixture(c);\n    ground.addFixture(bf);\n  }\n  ground.translate(new Vector2(0.6875,-8.75));\n  ground.setMass(MassType.INFINITE);\n  world.addBody(ground);\n  Body head=new SimulationBody();\n{\n    Convex c=Geometry.createCircle(0.25);\n    BodyFixture bf=new BodyFixture(c);\n    head.addFixture(bf);\n  }\n  head.setMass(MassType.NORMAL);\n  world.addBody(head);\n  Body torso=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.5,1.0);\n    BodyFixture bf=new BodyFixture(c);\n    torso.addFixture(bf);\n  }\n{\n    Convex c=Geometry.createRectangle(1.0,0.25);\n    c.translate(new Vector2(0.00390625,0.375));\n    BodyFixture bf=new BodyFixture(c);\n    torso.addFixture(bf);\n  }\n  torso.translate(new Vector2(0.0234375,-0.8125));\n  torso.setMass(MassType.NORMAL);\n  world.addBody(torso);\n  Body rightHumerus=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.5);\n    BodyFixture bf=new BodyFixture(c);\n    rightHumerus.addFixture(bf);\n  }\n  rightHumerus.translate(new Vector2(0.4375,-0.609375));\n  rightHumerus.setMass(MassType.NORMAL);\n  world.addBody(rightHumerus);\n  Body rightUlna=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.4);\n    BodyFixture bf=new BodyFixture(c);\n    rightUlna.addFixture(bf);\n  }\n  rightUlna.translate(new Vector2(0.44140625,-0.98828125));\n  rightUlna.setMass(MassType.NORMAL);\n  world.addBody(rightUlna);\n  Body neck=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.15,0.2);\n    BodyFixture bf=new BodyFixture(c);\n    neck.addFixture(bf);\n  }\n  neck.translate(new Vector2(0.015625,-0.2734375));\n  neck.setMass(MassType.NORMAL);\n  world.addBody(neck);\n  Body leftHumerus=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.5);\n    BodyFixture bf=new BodyFixture(c);\n    leftHumerus.addFixture(bf);\n  }\n  leftHumerus.translate(new Vector2(-0.3828125,-0.609375));\n  leftHumerus.setMass(MassType.NORMAL);\n  world.addBody(leftHumerus);\n  Body leftUlna=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.4);\n    BodyFixture bf=new BodyFixture(c);\n    leftUlna.addFixture(bf);\n  }\n  leftUlna.translate(new Vector2(-0.3828125,-0.9765625));\n  leftUlna.setMass(MassType.NORMAL);\n  world.addBody(leftUlna);\n  Body rightFemur=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.75);\n    BodyFixture bf=new BodyFixture(c);\n    rightFemur.addFixture(bf);\n  }\n  rightFemur.translate(new Vector2(0.1796875,-1.5703125));\n  rightFemur.setMass(MassType.NORMAL);\n  world.addBody(rightFemur);\n  Body leftFemur=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.75);\n    BodyFixture bf=new BodyFixture(c);\n    leftFemur.addFixture(bf);\n  }\n  leftFemur.translate(new Vector2(-0.1328125,-1.5703125));\n  leftFemur.setMass(MassType.NORMAL);\n  world.addBody(leftFemur);\n  Body rightTibia=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.5);\n    BodyFixture bf=new BodyFixture(c);\n    rightTibia.addFixture(bf);\n  }\n  rightTibia.translate(new Vector2(0.18359375,-2.11328125));\n  rightTibia.setMass(MassType.NORMAL);\n  world.addBody(rightTibia);\n  Body leftTibia=new SimulationBody();\n{\n    Convex c=Geometry.createRectangle(0.25,0.5);\n    BodyFixture bf=new BodyFixture(c);\n    leftTibia.addFixture(bf);\n  }\n  leftTibia.translate(new Vector2(-0.1328125,-2.1171875));\n  leftTibia.setMass(MassType.NORMAL);\n  world.addBody(leftTibia);\n  RevoluteJoint headToNeck=new RevoluteJoint(head,neck,new Vector2(0.01,-0.2));\n  headToNeck.setLimitEnabled(false);\n  headToNeck.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  headToNeck.setReferenceAngle(Math.toRadians(0.0));\n  headToNeck.setMotorEnabled(false);\n  headToNeck.setMotorSpeed(Math.toRadians(0.0));\n  headToNeck.setMaximumMotorTorque(0.0);\n  headToNeck.setCollisionAllowed(false);\n  world.addJoint(headToNeck);\n  RevoluteJoint neckToTorso=new RevoluteJoint(neck,torso,new Vector2(0.01,-0.35));\n  neckToTorso.setLimitEnabled(false);\n  neckToTorso.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  neckToTorso.setReferenceAngle(Math.toRadians(0.0));\n  neckToTorso.setMotorEnabled(false);\n  neckToTorso.setMotorSpeed(Math.toRadians(0.0));\n  neckToTorso.setMaximumMotorTorque(0.0);\n  neckToTorso.setCollisionAllowed(false);\n  world.addJoint(neckToTorso);\n  RevoluteJoint torsoToLeftHumerus=new RevoluteJoint(torso,leftHumerus,new Vector2(-0.4,-0.4));\n  torsoToLeftHumerus.setLimitEnabled(false);\n  torsoToLeftHumerus.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  torsoToLeftHumerus.setReferenceAngle(Math.toRadians(0.0));\n  torsoToLeftHumerus.setMotorEnabled(false);\n  torsoToLeftHumerus.setMotorSpeed(Math.toRadians(0.0));\n  torsoToLeftHumerus.setMaximumMotorTorque(0.0);\n  torsoToLeftHumerus.setCollisionAllowed(false);\n  world.addJoint(torsoToLeftHumerus);\n  RevoluteJoint torsoToRightHumerus=new RevoluteJoint(torso,rightHumerus,new Vector2(0.4,-0.4));\n  torsoToRightHumerus.setLimitEnabled(false);\n  torsoToRightHumerus.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  torsoToRightHumerus.setReferenceAngle(Math.toRadians(0.0));\n  torsoToRightHumerus.setMotorEnabled(false);\n  torsoToRightHumerus.setMotorSpeed(Math.toRadians(0.0));\n  torsoToRightHumerus.setMaximumMotorTorque(0.0);\n  torsoToRightHumerus.setCollisionAllowed(false);\n  world.addJoint(torsoToRightHumerus);\n  RevoluteJoint rightHumerusToRightUlna=new RevoluteJoint(rightHumerus,rightUlna,new Vector2(0.43,-0.82));\n  rightHumerusToRightUlna.setLimitEnabled(false);\n  rightHumerusToRightUlna.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  rightHumerusToRightUlna.setReferenceAngle(Math.toRadians(0.0));\n  rightHumerusToRightUlna.setMotorEnabled(false);\n  rightHumerusToRightUlna.setMotorSpeed(Math.toRadians(0.0));\n  rightHumerusToRightUlna.setMaximumMotorTorque(0.0);\n  rightHumerusToRightUlna.setCollisionAllowed(false);\n  world.addJoint(rightHumerusToRightUlna);\n  RevoluteJoint leftHumerusToLeftUlna=new RevoluteJoint(leftHumerus,leftUlna,new Vector2(-0.4,-0.81));\n  leftHumerusToLeftUlna.setLimitEnabled(false);\n  leftHumerusToLeftUlna.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  leftHumerusToLeftUlna.setReferenceAngle(Math.toRadians(0.0));\n  leftHumerusToLeftUlna.setMotorEnabled(false);\n  leftHumerusToLeftUlna.setMotorSpeed(Math.toRadians(0.0));\n  leftHumerusToLeftUlna.setMaximumMotorTorque(0.0);\n  leftHumerusToLeftUlna.setCollisionAllowed(false);\n  world.addJoint(leftHumerusToLeftUlna);\n  RevoluteJoint torsoToRightFemur=new RevoluteJoint(torso,rightFemur,new Vector2(0.16,-1.25));\n  torsoToRightFemur.setLimitEnabled(false);\n  torsoToRightFemur.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  torsoToRightFemur.setReferenceAngle(Math.toRadians(0.0));\n  torsoToRightFemur.setMotorEnabled(false);\n  torsoToRightFemur.setMotorSpeed(Math.toRadians(0.0));\n  torsoToRightFemur.setMaximumMotorTorque(0.0);\n  torsoToRightFemur.setCollisionAllowed(false);\n  world.addJoint(torsoToRightFemur);\n  RevoluteJoint torsoToLeftFemur=new RevoluteJoint(torso,leftFemur,new Vector2(-0.13,-1.25));\n  torsoToLeftFemur.setLimitEnabled(false);\n  torsoToLeftFemur.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  torsoToLeftFemur.setReferenceAngle(Math.toRadians(0.0));\n  torsoToLeftFemur.setMotorEnabled(false);\n  torsoToLeftFemur.setMotorSpeed(Math.toRadians(0.0));\n  torsoToLeftFemur.setMaximumMotorTorque(0.0);\n  torsoToLeftFemur.setCollisionAllowed(false);\n  world.addJoint(torsoToLeftFemur);\n  RevoluteJoint rightFemurToRightTibia=new RevoluteJoint(rightFemur,rightTibia,new Vector2(0.17,-1.9));\n  rightFemurToRightTibia.setLimitEnabled(false);\n  rightFemurToRightTibia.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  rightFemurToRightTibia.setReferenceAngle(Math.toRadians(0.0));\n  rightFemurToRightTibia.setMotorEnabled(false);\n  rightFemurToRightTibia.setMotorSpeed(Math.toRadians(0.0));\n  rightFemurToRightTibia.setMaximumMotorTorque(0.0);\n  rightFemurToRightTibia.setCollisionAllowed(false);\n  world.addJoint(rightFemurToRightTibia);\n  RevoluteJoint leftFemurToLeftTibia=new RevoluteJoint(leftFemur,leftTibia,new Vector2(-0.14,-1.9));\n  leftFemurToLeftTibia.setLimitEnabled(false);\n  leftFemurToLeftTibia.setLimits(Math.toRadians(0.0),Math.toRadians(0.0));\n  leftFemurToLeftTibia.setReferenceAngle(Math.toRadians(0.0));\n  leftFemurToLeftTibia.setMotorEnabled(false);\n  leftFemurToLeftTibia.setMotorSpeed(Math.toRadians(0.0));\n  leftFemurToLeftTibia.setMaximumMotorTorque(0.0);\n  leftFemurToLeftTibia.setCollisionAllowed(false);\n  world.addJoint(leftFemurToLeftTibia);\n}\n", "docstring": "creates game objects and adds them to the world .", "partition": "test"}
{"idx": "5882", "code": "public void readData(DataInput din) throws IOException {\n  byteCount=din.readByte();\n  status=din.readUnsignedShort();\n  eventCount=din.readUnsignedShort();\n  messageCount=din.readUnsignedShort();\n  events=new byte[byteCount - 6];\n  if (events.length > 0) {\n    din.readFully(events,0,events.length);\n  }\n}\n", "docstring": "readdata - - input the modbus message from din . if there was a header , such as for modbus / tcp , it will have been read already .", "partition": "test"}
{"idx": "5883", "code": "public E remove(int index){\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    Object[] elements=getArray();\n    int len=elements.length;\n    E oldValue=get(elements,index);\n    int numMoved=len - index - 1;\n    if (numMoved == 0)     setArray(Arrays.copyOf(elements,len - 1));\n else {\n      Object[] newElements=new Object[len - 1];\n      System.arraycopy(elements,0,newElements,0,index);\n      System.arraycopy(elements,index + 1,newElements,index,numMoved);\n      setArray(newElements);\n    }\n    return oldValue;\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "docstring": "removes the element at the specified position in this list . shifts any subsequent elements to the left ( subtracts one from their indices ) . returns the element that was removed from the list .", "partition": "test"}
{"idx": "5884", "code": "void createEdges(Number[] v){\n  graph.addEdge(new Double(Math.random()),v[0],v[1],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[3],v[0],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[0],v[4],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[4],v[5],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[5],v[3],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[2],v[1],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[4],v[1],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[8],v[2],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[3],v[8],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[6],v[7],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[7],v[5],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[0],v[9],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[9],v[8],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[7],v[6],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[6],v[5],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[4],v[2],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[5],v[4],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[4],v[10],EdgeType.DIRECTED);\n  graph.addEdge(new Double(Math.random()),v[10],v[4],EdgeType.DIRECTED);\n}\n", "docstring": "create edges for this demo graph", "partition": "test"}
{"idx": "5885", "code": "@SuppressWarnings(\"rawtypes\") public DataResponse paginateList(Map<String,String> requestParams,PaginateRequest paginateRequest,Object query,String defaultSort,Map properties){\n  if (paginateRequest == null) {\n    paginateRequest=new PaginateRequest();\n  }\n  if (paginateRequest.getStart() == null) {\n    paginateRequest.setStart(RequestUtil.getInteger(requestParams,\"start\",0));\n  }\n  if (paginateRequest.getSize() == null) {\n    paginateRequest.setSize(RequestUtil.getInteger(requestParams,\"size\",10));\n  }\n  if (paginateRequest.getOrder() == null) {\n    paginateRequest.setOrder(requestParams.get(\"order\"));\n  }\n  if (paginateRequest.getSort() == null) {\n    paginateRequest.setSort(requestParams.get(\"sort\"));\n  }\n  Integer start=paginateRequest.getStart();\n  if (start == null || start < 0) {\n    start=0;\n  }\n  Integer size=paginateRequest.getSize();\n  if (size == null || size < 0) {\n    size=10;\n  }\n  String sort=paginateRequest.getSort();\n  if (sort == null) {\n    sort=defaultSort;\n  }\n  String order=paginateRequest.getOrder();\n  if (order == null) {\n    order=\"asc\";\n  }\n  if (sort != null && !properties.isEmpty()) {\n    Object qp=properties.get(sort);\n    if (qp == null) {\n      throw new ActivitiIllegalArgumentException(\"Value for param \'sort\' is not valid, \'\" + sort + \"\' is not a valid property\");\n    }\n    if (query instanceof AbstractQuery) {\n      AbstractQuery queryObject=(AbstractQuery)query;\n      QueryProperty queryProperty=(QueryProperty)qp;\n      queryObject.orderBy(queryProperty);\n      if (order.equals(\"asc\")) {\n        queryObject.asc();\n      }\n else       if (order.equals(\"desc\")) {\n        queryObject.desc();\n      }\n else {\n        throw new ActivitiIllegalArgumentException(\"Value for param \'order\' is not valid : \'\" + order + \"\', must be \'asc\' or \'desc\'\");\n      }\n    }\n else     if (query instanceof org.activiti.idm.engine.impl.AbstractQuery) {\n      org.activiti.idm.engine.impl.AbstractQuery queryObject=(org.activiti.idm.engine.impl.AbstractQuery)query;\n      org.activiti.idm.api.QueryProperty queryProperty=(org.activiti.idm.api.QueryProperty)qp;\n      queryObject.orderBy(queryProperty);\n      if (order.equals(\"asc\")) {\n        queryObject.asc();\n      }\n else       if (order.equals(\"desc\")) {\n        queryObject.desc();\n      }\n else {\n        throw new ActivitiIllegalArgumentException(\"Value for param \'order\' is not valid : \'\" + order + \"\', must be \'asc\' or \'desc\'\");\n      }\n    }\n  }\n  DataResponse response=new DataResponse();\n  response.setStart(start);\n  response.setSort(sort);\n  response.setOrder(order);\n  if (query instanceof AbstractQuery) {\n    AbstractQuery queryObject=(AbstractQuery)query;\n    List list=processList(queryObject.listPage(start,size));\n    response.setTotal(queryObject.count());\n    response.setSize(list.size());\n    response.setData(list);\n  }\n else   if (query instanceof org.activiti.idm.engine.impl.AbstractQuery) {\n    org.activiti.idm.engine.impl.AbstractQuery queryObject=(org.activiti.idm.engine.impl.AbstractQuery)query;\n    List list=processList(queryObject.listPage(start,size));\n    response.setTotal(queryObject.count());\n    response.setSize(list.size());\n    response.setData(list);\n  }\n  return response;\n}\n", "docstring": "uses the pagination parameters form the request and makes sure to order the result and set all pagination attributes for the response to render", "partition": "test"}
{"idx": "5886", "code": "private static <T extends Component>T buildRow(final JPanel panel,final String labelText,final String hint,final T component,final boolean isLast){\n  component.setPreferredSize(new Dimension(COLORPANEL_WIDTH,COLORPANEL_HEIGHT));\n  final JPanel rowPanel=new JPanel(new BorderLayout());\n  rowPanel.setBorder(new EmptyBorder(0,2,isLast ? 2 : 0,2));\n  rowPanel.add(new JLabel(labelText),BorderLayout.CENTER);\n  rowPanel.add(CHintCreator.createHintPanel(component,hint),BorderLayout.EAST);\n  panel.add(rowPanel);\n  return component;\n}\n", "docstring": "builds a single row of components in the panel .", "partition": "test"}
{"idx": "5887", "code": "public void curveTo(double x1,double y1,double x2,double y2,double x3,double y3){\n  if (size() == 0) {\n    throw new IllegalPathStateException(\"curveTo only allowed when not empty\");\n  }\n  Node lastPoint=get(size() - 1);\n  lastPoint.mask|=C2_MASK;\n  lastPoint.x[2]=x1;\n  lastPoint.y[2]=y1;\n  if ((lastPoint.mask & C1C2_MASK) == C1C2_MASK) {\n    lastPoint.keepColinear=Math.abs(Geom.angle(lastPoint.x[0],lastPoint.y[0],lastPoint.x[1],lastPoint.y[1]) - Geom.angle(lastPoint.x[2],lastPoint.y[2],lastPoint.x[0],lastPoint.y[0])) < 0.001;\n  }\n  add(new Node(C1_MASK,x3,y3,x2,y2,x3,y3));\n}\n", "docstring": "adds a cubic curve to the bezier path . < p > this is a convenience method for adding a node with control point c0 and c1 ( incoming curve ) to the bezier path , and also specifying the control point c2 ( outgoing curve ) of the previous node . < p > the bezier path must already have at least one node .", "partition": "test"}
{"idx": "5888", "code": "private void writeMetaBits() throws IOException {\n  final byte buf[]=genMetabitsData();\n  final long addr=m_metaBitsAddr < 0 ? physicalAddress(m_metaBitsAddr) : ((long)m_metaBitsAddr) << ALLOCATION_SCALEUP;\n  if (addr == 0) {\n    throw new IllegalStateException(\"Invalid metabits address: \" + m_metaBitsAddr);\n  }\n  assert addr > 0;\n  try {\n    if (log.isDebugEnabled())     log.debug(\"writing metabits at: \" + addr);\n    m_writeCacheService.write(addr,ByteBuffer.wrap(buf),0,false,m_metaBitsAddr < 0 ? m_metaBitsAddr : 0);\n  }\n catch (  InterruptedException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "docstring": "writemetabits must be called after all allocations have been made , the last one being the allocation for the metabits themselves ( allowing for an extension ! ) . ticket # 936 : the meta - bits allocation is currently made from the fixedallocator region . this works well providing the required allocation bits is less than the maximum fixedallocator slot size . while this is neat , there are problems at scale for maximum slot sizes less than 64k . to address the 8k bits in a 1k alloctor , 13 bits are required , this leaves 19 bits to index an allocator , or 18 bits without the sign = > 256k maximum index . to be able to commit changes to all 256k allocators requires 512k metabits = > 64k bytes . we would like to associate the 64k allocations with the root block , so a single 128k allocation would be split into 64k demi - spaces , one for each root block . while a negative address indicates a standard rw allocation a ositive address can be used to indicate an explicitly allocated region . the trick is to ensure that the region is allocated on a 128k boundary , then the lower bits can indicate which demi - space is used with a simple xor . note that we must ensure that any previous demi - space write is removed from the wcs .", "partition": "test"}
{"idx": "5889", "code": "private void openCounterDataInputStream() throws DataFallbackException {\n  if (dInput == null) {\n    if (LOG.isDebugEnabled())     LOG.debug(\"openDataInputStream() ; Opening the reader for the \" + counterFile.getName() + \" file\");\n    try {\n      dInput=new BufferedReader(new FileReader(counterFile));\n    }\n catch (    IOException e) {\n      throw new DataFallbackException(e.getMessage());\n    }\n  }\n}\n", "docstring": "create a stream to read from the counter file", "partition": "test"}
{"idx": "5890", "code": "public String readNextWord(){\n  if (tokenizer.hasMoreTokens()) {\n    return tokenizer.nextToken();\n  }\n else {\n    return null;\n  }\n}\n", "docstring": "read the next word from the parsed sentence .", "partition": "test"}
{"idx": "5891", "code": "public static final void toString(StringBuffer output,String str){\n  if (str == null) {\n    output.append(\"null\");\n    return;\n  }\n  output.append(toString(str));\n}\n", "docstring": "provides a java string literal representing the parameter string . this includes surrounding double quotes , and quoted special characters , including utf escape sequences when necessary . < p > this function works only for ascii character encoding , and assumes this is the default encoding .", "partition": "test"}
{"idx": "5892", "code": "@Override public void buildAssociations(Instances data) throws Exception {\n  buildAssociations((Object)data);\n  return;\n}\n", "docstring": "method that generates all large item sets with a minimum support , and from these all association rules with a minimum metric ( i . e . confidence , lift etc . ) .", "partition": "test"}
{"idx": "5893", "code": "public static String replaceFirst(String s,String sub,String with){\n  int i=s.indexOf(sub);\n  if (i == -1) {\n    return s;\n  }\n  return s.substring(0,i) + with + s.substring(i + sub.length());\n}\n", "docstring": "replaces the very first occurrence of a substring with supplied string .", "partition": "test"}
{"idx": "5894", "code": "private LocationHelper(){\n}\n", "docstring": "prevent initializing this class .", "partition": "test"}
{"idx": "5895", "code": "public void addObject(String s) throws Exception {\n  inspect(Class.forName(s));\n}\n", "docstring": "add the name of the class to methodize", "partition": "test"}
{"idx": "5896", "code": "public static void main(String[] args) throws Exception {\n  final JFrame frame=new HTMLTest(args);\n  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n  frame.pack();\n  frame.setVisible(true);\n}\n", "docstring": "the main program for the htmltest class", "partition": "test"}
{"idx": "5897", "code": "@Override public int hashCode(){\n  return rawString.hashCode();\n}\n", "docstring": "returns the hashcode for the raw string .", "partition": "test"}
{"idx": "5898", "code": "public final void testAddAllHelperTextColorsFromArray(){\n  int helperTextColor1=Color.BLACK;\n  int helperTextColor2=Color.GRAY;\n  int[] helperTextColors1=new int[2];\n  helperTextColors1[0]=helperTextColor1;\n  helperTextColors1[1]=helperTextColor2;\n  PasswordEditText passwordEditText=new PasswordEditText(getContext());\n  passwordEditText.addAllHelperTextColors(helperTextColors1);\n  passwordEditText.addAllHelperTextColors(helperTextColors1);\n  Collection<Integer> helperTextColors2=passwordEditText.getHelperTextColors();\n  assertEquals(helperTextColors1.length,helperTextColors2.size());\n  Iterator<Integer> iterator=helperTextColors2.iterator();\n  assertEquals(helperTextColor1,(int)iterator.next());\n  assertEquals(helperTextColor2,(int)iterator.next());\n}\n", "docstring": "tests the functionality of the method , which allows to add all helper text colors , which are contained by an array .", "partition": "test"}
{"idx": "5899", "code": "public static boolean writeToFile(String filename,String message,boolean append){\n  boolean result;\n  BufferedWriter writer;\n  try {\n    writer=new BufferedWriter(new FileWriter(filename,append));\n    writer.write(message);\n    writer.newLine();\n    writer.flush();\n    writer.close();\n    result=true;\n  }\n catch (  Exception e) {\n    result=false;\n  }\n  return result;\n}\n", "docstring": "writes the given message to the specified file . the message is either appended or replaces the current content of the file .", "partition": "test"}
{"idx": "5900", "code": "public int hashCode(){\n  return (9 * colorModel.hashCode()) + (14 * sampleModel.hashCode());\n}\n", "docstring": "returns the hash code for this imagetypespecifier .", "partition": "test"}
{"idx": "5901", "code": "public void writeFile(String name,String mimeType,String fileName,byte[] data) throws IOException {\n  if (data == null) {\n    throw new IllegalArgumentException(\"Data cannot be null.\");\n  }\n  if (fileName == null || fileName.isEmpty()) {\n    throw new IllegalArgumentException(\"File name cannot be null or empty.\");\n  }\n  out.writeBytes(PREFIX);\n  out.writeBytes(boundary);\n  out.writeBytes(NEWLINE);\n  out.writeBytes(\"Content-Disposition: form-data; name=\\\"\" + name + \"\\\"; filename=\\\"\"+ fileName+ \"\\\"\");\n  out.writeBytes(NEWLINE);\n  if (mimeType != null) {\n    out.writeBytes(\"Content-Type: \" + mimeType);\n    out.writeBytes(NEWLINE);\n  }\n  out.writeBytes(NEWLINE);\n  out.write(data,0,data.length);\n  out.writeBytes(NEWLINE);\n  out.flush();\n}\n", "docstring": "writes the given bytes .", "partition": "test"}
{"idx": "5902", "code": "@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) private void onConfigurationChanged(Configuration newConfig){\n  final Locale newLocale=newConfig.locale;\n  if (newLocale.equals(mSystemLocale)) {\n    return;\n  }\n  mSystemLocale=newLocale;\n  ensureSupportedLocale();\n}\n", "docstring": "handles updating the system locale . < p > only used on api > = 15 to work around language issues with google tts .", "partition": "test"}
{"idx": "5903", "code": "private static Boolean findConvexPolygon(final PlanetModel planetModel,final Edge currentEdge,final GeoCompositePolygon rval,final EdgeBuffer edgeBuffer,final List<GeoPolygon> holes,final GeoPoint testPoint){\n  final Set<Edge> includedEdges=new HashSet<>();\n  includedEdges.add(currentEdge);\n  Edge firstEdge=currentEdge;\n  Edge lastEdge=currentEdge;\n  while (true) {\n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      break;\n    }\n    final Edge newLastEdge=edgeBuffer.getNext(lastEdge);\n    if (isWithin(newLastEdge.endPoint,includedEdges)) {\n      final SidedPlane returnBoundary;\n      if (firstEdge.startPoint != newLastEdge.endPoint) {\n        returnBoundary=new SidedPlane(firstEdge.endPoint,firstEdge.startPoint,newLastEdge.endPoint);\n      }\n else {\n        returnBoundary=null;\n      }\n      boolean foundPointInside=false;\n      final Iterator<Edge> edgeIterator=edgeBuffer.iterator();\n      while (edgeIterator.hasNext()) {\n        final Edge edge=edgeIterator.next();\n        if (!includedEdges.contains(edge) && edge != newLastEdge) {\n          if (edge.startPoint != newLastEdge.endPoint) {\n            if (isWithin(edge.startPoint,includedEdges,newLastEdge,returnBoundary)) {\n              foundPointInside=true;\n              break;\n            }\n          }\n          if (edge.endPoint != firstEdge.startPoint) {\n            if (isWithin(edge.endPoint,includedEdges,newLastEdge,returnBoundary)) {\n              foundPointInside=true;\n              break;\n            }\n          }\n        }\n      }\n      if (!foundPointInside) {\n        includedEdges.add(newLastEdge);\n        lastEdge=newLastEdge;\n        continue;\n      }\n    }\n    break;\n  }\n  while (true) {\n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      break;\n    }\n    final Edge newFirstEdge=edgeBuffer.getPrevious(firstEdge);\n    if (isWithin(newFirstEdge.startPoint,includedEdges)) {\n      final SidedPlane returnBoundary;\n      if (newFirstEdge.startPoint != lastEdge.endPoint) {\n        returnBoundary=new SidedPlane(lastEdge.startPoint,lastEdge.endPoint,newFirstEdge.startPoint);\n      }\n else {\n        returnBoundary=null;\n      }\n      boolean foundPointInside=false;\n      final Iterator<Edge> edgeIterator=edgeBuffer.iterator();\n      while (edgeIterator.hasNext()) {\n        final Edge edge=edgeIterator.next();\n        if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n          if (edge.startPoint != lastEdge.endPoint) {\n            if (isWithin(edge.startPoint,includedEdges,newFirstEdge,returnBoundary)) {\n              foundPointInside=true;\n              break;\n            }\n          }\n          if (edge.endPoint != newFirstEdge.startPoint) {\n            if (isWithin(edge.endPoint,includedEdges,newFirstEdge,returnBoundary)) {\n              foundPointInside=true;\n              break;\n            }\n          }\n        }\n      }\n      if (!foundPointInside) {\n        includedEdges.add(newFirstEdge);\n        firstEdge=newFirstEdge;\n        continue;\n      }\n    }\n    break;\n  }\n  if (includedEdges.size() < 2) {\n    return false;\n  }\n  final List<GeoPoint> points=new ArrayList<GeoPoint>(includedEdges.size() + 1);\n  final BitSet internalEdges=new BitSet(includedEdges.size());\n  final boolean returnIsInternal;\n  if (firstEdge.startPoint == lastEdge.endPoint) {\n    if (includedEdges.size() < 3) {\n      return false;\n    }\n    Edge edge=firstEdge;\n    points.add(edge.startPoint);\n    int k=0;\n    while (true) {\n      if (edge == lastEdge) {\n        break;\n      }\n      points.add(edge.endPoint);\n      internalEdges.set(k++,edge.isInternal);\n      edge=edgeBuffer.getNext(edge);\n    }\n    returnIsInternal=lastEdge.isInternal;\n    for (int i=0; i < points.size(); i++) {\n      final GeoPoint start=points.get(i);\n      final GeoPoint end=points.get(getLegalIndex(i + 1,points.size()));\n      final Plane planeToFind=new Plane(start,end);\n      int endPointIndex=-1;\n      for (int j=0; j < points.size(); j++) {\n        final int index=getLegalIndex(j + i + 2,points.size());\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex=index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        return false;\n      }\n    }\n    edgeBuffer.clear();\n  }\n else {\n    final SidedPlane returnSidedPlane=new SidedPlane(firstEdge.endPoint,false,firstEdge.startPoint,lastEdge.endPoint);\n    final Edge returnEdge=new Edge(firstEdge.startPoint,lastEdge.endPoint,returnSidedPlane,true);\n    final List<Edge> edges=new ArrayList<Edge>(includedEdges.size());\n    returnIsInternal=true;\n    Edge edge=firstEdge;\n    points.add(edge.startPoint);\n    int k=0;\n    while (true) {\n      points.add(edge.endPoint);\n      internalEdges.set(k++,edge.isInternal);\n      edges.add(edge);\n      if (edge == lastEdge) {\n        break;\n      }\n      edge=edgeBuffer.getNext(edge);\n    }\n    for (int i=0; i < points.size(); i++) {\n      final GeoPoint start=points.get(i);\n      final GeoPoint end=points.get(getLegalIndex(i + 1,points.size()));\n      final Plane planeToFind=new Plane(start,end);\n      int endPointIndex=-1;\n      for (int j=0; j < points.size(); j++) {\n        final int index=getLegalIndex(j + i + 2,points.size());\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex=index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        return false;\n      }\n    }\n    edgeBuffer.replace(edges,returnEdge);\n  }\n  if (testPoint != null && holes != null && holes.size() > 0) {\n    final GeoPolygon testPolygon=new GeoConvexPolygon(planetModel,points,null,internalEdges,returnIsInternal);\n    if (testPolygon.isWithin(testPoint)) {\n      return null;\n    }\n  }\n  final GeoPolygon realPolygon=new GeoConvexPolygon(planetModel,points,holes,internalEdges,returnIsInternal);\n  if (testPoint != null && (holes == null || holes.size() == 0)) {\n    if (realPolygon.isWithin(testPoint)) {\n      return null;\n    }\n  }\n  rval.addShape(realPolygon);\n  return true;\n}\n", "docstring": "look for a convex polygon at the specified edge . if we find it , create one and adjust the edge buffer .", "partition": "test"}
{"idx": "5904", "code": "private static boolean isGMTish(String name){\n  if (name.length() < 3) {\n    return false;\n  }\n  char c1=name.charAt(0);\n  char c2=name.charAt(1);\n  char c3=name.charAt(2);\n  if (!((c1 == \'G\' || c1 == \'g\') && (c2 == \'M\' || c2 == \'m\') && (c3 == \'T\' || c3 == \'t\')) && !((c1 == \'U\' || c1 == \'u\') && (c2 == \'T\' || c2 == \'t\') && (c3 == \'C\' || c3 == \'c\')) && !((c1 == \'U\' || c1 == \'u\') && (c2 == \'T\' || c2 == \'t\') && (c3 == \'1\'))) {\n    return false;\n  }\n  if (name.length() == 3) {\n    return true;\n  }\n  String offset=name.substring(3);\n  if (offset.startsWith(\"+\")) {\n    return offset.equals(\"+0\") || offset.equals(\"+00\") || offset.equals(\"+00:00\");\n  }\n else {\n    return offset.equals(\"-0\") || offset.equals(\"-00\") || offset.equals(\"-00:00\");\n  }\n}\n", "docstring": "tells if a offset or time zone is gmt . gmt is a fuzzy term , it used to referred both to utc and ut1 .", "partition": "test"}
{"idx": "5905", "code": "protected void addWholeMatch(StringBuilder sb,String surface,String analyzed){\n  sb.append(\"<b>\");\n  sb.append(surface);\n  sb.append(\"</b>\");\n}\n", "docstring": "called while highlighting a single result , to append the whole matched token to the provided fragments list .", "partition": "test"}
{"idx": "5906", "code": "public void start(){\n  stopAt=System.currentTimeMillis() + MAX_PROCESSING_TIME;\n}\n", "docstring": "start the timer to make sure processing doesn \"'\" t take too long .", "partition": "test"}
{"idx": "5907", "code": "private Object[] singleRow(int row){\n  Object[] res=new Object[this.nFields];\n  for (int i=0; i < this.nFields; i+=1) {\n    if (this.isNull == null || !this.isNull[row * this.nFields + i]) {\n      res[i]=ArrayFuncs.newInstance(this.types[i],1);\n      System.arraycopy(this.data[i],row,res[i],0,1);\n    }\n  }\n  return res;\n}\n", "docstring": "extract a single row from a table . this returns an array of objects each of which is an array of length 1 .", "partition": "test"}
{"idx": "5908", "code": "public static String removeChars(String src,String chars){\n  int i=src.length();\n  StringBuilder sb=new StringBuilder(i);\n  for (int j=0; j < i; j++) {\n    char c=src.charAt(j);\n    if (chars.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "removes all characters contained in provided string .", "partition": "test"}
{"idx": "5909", "code": "private void addAllColumns() throws SQLException {\n  DatabaseMetaData metaData=getDatabaseMetaData();\n  List<String> columns=new ArrayList<>();\n  try (ResultSet rs=metaData.getColumns(null,null,normalizeObjectName(statementModel.getTableName()),null)){\n    while (rs.next()) {\n      columns.add(quoteObjectName(rs.getString(IDX_COLUMN_NAME)));\n    }\n  }\n   columnNames=columns.toArray(new String[0]);\n  addReturningClause();\n}\n", "docstring": "adds all available table columns to the query as generated keys .", "partition": "test"}
{"idx": "5910", "code": "public void loadHamNSpam(Connection conn) throws java.sql.SQLException {\n  PreparedStatement pstmt=null;\n  ResultSet rs=null;\n  try {\n    pstmt=conn.prepareStatement(sqlQueries.getSqlString(\"selectHamTokens\",true));\n    rs=pstmt.executeQuery();\n    Map<String,Integer> ham=getHamTokenCounts();\n    while (rs.next()) {\n      String token=rs.getString(1);\n      int count=rs.getInt(2);\n      if (count > 1) {\n        ham.put(token,count);\n      }\n    }\n    log(\"Ham tokens count: \" + ham.size());\n    rs.close();\n    pstmt.close();\n    pstmt=conn.prepareStatement(sqlQueries.getSqlString(\"selectSpamTokens\",true));\n    rs=pstmt.executeQuery();\n    Map<String,Integer> spam=getSpamTokenCounts();\n    while (rs.next()) {\n      String token=rs.getString(1);\n      int count=rs.getInt(2);\n      if (count > 1) {\n        spam.put(token,count);\n      }\n    }\n    log(\"Spam tokens count: \" + spam.size());\n    rs.close();\n    pstmt.close();\n    pstmt=conn.prepareStatement(sqlQueries.getSqlString(\"selectMessageCounts\",true));\n    rs=pstmt.executeQuery();\n    if (rs.next()) {\n      setHamMessageCount(rs.getInt(1));\n      setSpamMessageCount(rs.getInt(2));\n    }\n    rs.close();\n    pstmt.close();\n  }\n  finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      java.sql.SQLException se) {\n        log(\"Failed to close statement after selecting spam tokens.\",se);\n      }\n      rs=null;\n    }\n    if (pstmt != null) {\n      try {\n        pstmt.close();\n      }\n catch (      java.sql.SQLException se) {\n        log(\"Failed to close statement selecting message counts.\",se);\n      }\n      pstmt=null;\n    }\n  }\n}\n", "docstring": "loads the token frequencies from the database .", "partition": "test"}
{"idx": "5911", "code": "static private void copyStream(final InputStream content,final OutputStream outstr) throws IOException {\n  final byte[] buf=new byte[GZIP_BUFFER];\n  while (true) {\n    final int rdlen=content.read(buf);\n    if (rdlen <= 0) {\n      break;\n    }\n    outstr.write(buf,0,rdlen);\n  }\n}\n", "docstring": "copy the input stream to the output stream .", "partition": "test"}
{"idx": "5912", "code": "public void checkAndSetupStreamsDrawer(){\n  setupListViewAdapter();\n}\n", "docstring": "initiates the streams drawer if the streams in the drawer is 0 .", "partition": "test"}
{"idx": "5913", "code": "public void testFpTypeOverrideSimple() throws Exception {\n  ObjectMapper m=new ObjectMapper();\n  m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n  BigDecimal dec=new BigDecimal(\"0.1\");\n  Number result=m.readValue(dec.toString(),Number.class);\n  assertEquals(BigDecimal.class,result.getClass());\n  assertEquals(dec,result);\n  Object value=m.readValue(dec.toString(),Object.class);\n  assertEquals(BigDecimal.class,result.getClass());\n  assertEquals(dec,value);\n}\n", "docstring": "test for verifying [ jackson - 72 ", "partition": "test"}
{"idx": "5914", "code": "private com.codename1.ui.Component copyComponent(com.codename1.ui.Component cmp){\n  com.codename1.ui.Container cnt=builder.createContainer(res,copiedResourceName);\n  com.codename1.ui.Component dest=builder.findByName(cmp.getName(),cnt);\n  if (dest != null && dest.getParent() != null) {\n    removeComponentSync(dest.getParent(),dest);\n  }\n  return dest;\n}\n", "docstring": "creates a copy of the given component and its hierarchy", "partition": "test"}
{"idx": "5915", "code": "@Override public BigDecimal calculateTotalPendingAdvance(final BigDecimal totalAdvancePaid,final Date billDate,final WorkOrderEstimate workOrderEstimate,final Long billId){\n  final CChartOfAccounts advanceCOA=contractorAdvanceService.getContractorAdvanceAccountcodeForWOE(workOrderEstimate.getId());\n  BigDecimal totalPendingBalance=BigDecimal.ZERO;\n  BigDecimal totalAdvanceAdjusted=BigDecimal.ZERO;\n  if (advanceCOA != null && totalAdvancePaid != null && totalAdvancePaid.compareTo(BigDecimal.ZERO) > 0) {\n    totalAdvanceAdjusted=getTotalAdvanceAdjustedForWOE(billDate,workOrderEstimate.getId(),advanceCOA.getId(),billId);\n    if (totalAdvanceAdjusted != null && totalAdvanceAdjusted.compareTo(BigDecimal.ZERO) > 0 && totalAdvanceAdjusted.compareTo(BigDecimal.ZERO) > 0)     totalPendingBalance=totalAdvanceAdjusted.subtract(totalAdvanceAdjusted);\n else     totalPendingBalance=totalAdvancePaid;\n  }\n  return totalPendingBalance;\n}\n", "docstring": "the method return bigdecimal", "partition": "test"}
{"idx": "5916", "code": "private void scrollBy(final int increment){\n  index+=increment;\n  if (index < 0) {\n    index=0;\n  }\n  if (index >= items.size()) {\n    index=items.size() - 1;\n  }\n  redraw();\n}\n", "docstring": "scroll the selected item", "partition": "test"}
{"idx": "5917", "code": "public static boolean symbolNeedsQuoting(CharSequence symbol,boolean quoteOperators){\n  int length=symbol.length();\n  if (length == 0) {\n    throw new EmptySymbolException();\n  }\n  if (!isIdentifierKeyword(symbol)) {\n    char c=symbol.charAt(0);\n    if (!quoteOperators && isOperatorPart(c)) {\n      for (int ii=0; ii < length; ii++) {\n        c=symbol.charAt(ii);\n        if (!isOperatorPart(c)) {\n          return true;\n        }\n      }\n      return false;\n    }\n else     if (isIdentifierStart(c)) {\n      for (int ii=0; ii < length; ii++) {\n        c=symbol.charAt(ii);\n        if ((c == '\\'' || c < 32 || c > 126) || !isIdentifierPart(c)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "determines whether the text of a symbol requires ( single ) quotes .", "partition": "test"}
{"idx": "5918", "code": "public static long parseCommitCounterFile(final String name,final String ext) throws NumberFormatException {\n  if (name == null)   throw new IllegalArgumentException();\n  if (ext == null)   throw new IllegalArgumentException();\n  final int len=name.length() - ext.length();\n  final String fileBaseName=name.substring(0,len);\n  final long commitCounter=Long.parseLong(fileBaseName);\n  return commitCounter;\n}\n", "docstring": "parse out the commitcounter from the file name .", "partition": "test"}
{"idx": "5919", "code": "public static Document loadDocument(File file) throws Exception {\n  DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n  DocumentBuilder builder=factory.newDocumentBuilder();\n  return builder.parse(file);\n}\n", "docstring": "loads a xml document from a file and returns the corresponding dom document .", "partition": "test"}
{"idx": "5920", "code": "private Node newFloatingComment(){\n  Node c=new Node(Token.EMPTY);\n  linkCommentToNode(c);\n  return c;\n}\n", "docstring": "returns a new comment attached to an empty node", "partition": "test"}
{"idx": "5921", "code": "public Boolean isHod(final Long assignId){\n  final List<HeadOfDepartments> hodList=employeeDepartmentRepository.getAllHodDepartments(assignId);\n  return !hodList.isEmpty();\n}\n", "docstring": "returns true if the given employee is an hod", "partition": "test"}
{"idx": "5922", "code": "public Munger singleLabelMode(String... languages){\n  return singleLabelMode(Arrays.asList(languages));\n}\n", "docstring": "build a munger that will load only a single label per entity . note that if there isn \"'\" t a label in one of the languages then there will be no label for the entity .", "partition": "test"}
{"idx": "5923", "code": "public StatValue[] matchSpec(StatSpec spec){\n  if (spec.getCombineType() == StatSpec.GLOBAL) {\n    StatValue[] allValues=matchSpec(new RawStatSpec(spec));\n    if (allValues.length == 0) {\n      return allValues;\n    }\n else {\n      ComboValue cv=new ComboValue(allValues);\n      return new StatValue[]{cv};\n    }\n  }\n else {\n    List l=new ArrayList();\n    StatArchiveReader.StatArchiveFile[] archives=getArchives();\n    for (int i=0; i < archives.length; i++) {\n      StatArchiveFile f=archives[i];\n      if (spec.archiveMatches(f.getFile())) {\n        f.matchSpec(spec,l);\n      }\n    }\n    StatValue[] result=new StatValue[l.size()];\n    return (StatValue[])l.toArray(result);\n  }\n}\n", "docstring": "returns an array of stat values that match the specified spec . if nothing matches then an empty array is returned .", "partition": "test"}
{"idx": "5924", "code": "private void assignClusterNums(int[] cl_num) throws Exception {\n  if (m_children != null && m_children.size() < 2) {\n    throw new Exception(\"assignClusterNums: tree not built correctly!\");\n  }\n  m_clusterNum=cl_num[0];\n  cl_num[0]++;\n  if (m_children != null) {\n    for (int i=0; i < m_children.size(); i++) {\n      CNode child=m_children.get(i);\n      child.assignClusterNums(cl_num);\n    }\n  }\n}\n", "docstring": "recursively assigns numbers to the nodes in the tree .", "partition": "test"}
{"idx": "5925", "code": "protected void closeSubpath(){\n  mPSStream.println(CLOSEPATH_STR);\n  mPenX=mStartPathX;\n  mPenY=mStartPathY;\n}\n", "docstring": "close the current subpath by appending a straight line from the current point to the subpath \"'\" s starting point .", "partition": "test"}
{"idx": "5926", "code": "public TvShowEpisodeScrapeTask(List<TvShowEpisode> episodes,MediaScraper mediaScraper){\n  super(BUNDLE.getString(\"tvshow.scraping\"),episodes.size(),TaskType.BACKGROUND_TASK);\n  this.episodes=episodes;\n  this.mediaScraper=mediaScraper;\n  this.scrapeThumb=true;\n}\n", "docstring": "instantiates a new tv show episode scrape task .", "partition": "test"}
{"idx": "5927", "code": "public ModelMBeanNotificationInfo(String[] notifTypes,String name,String description){\n  this(notifTypes,name,description,null);\n}\n", "docstring": "constructs a modelmbeannotificationinfo object with a default descriptor .", "partition": "test"}
{"idx": "5928", "code": "public void cleanBuildTask(long id) throws NotFoundException {\n  FutureBuildTask task=tasks.remove(id);\n  if (task == null) {\n    throw new NotFoundException(String.format(\"Invalid build task id: %d\",id));\n  }\n  task.cancel(true);\n  cleanup(task);\n}\n", "docstring": "clean - up all resources and files allocated for the given build task .", "partition": "test"}
{"idx": "5929", "code": "public void moveTo(final int lonCenter,final int latCenter){\n  double mLatCenter=GeoMath.latE7ToMercator(latCenter);\n  double mTop=GeoMath.latE7ToMercator(top);\n  int newBottom=GeoMath.mercatorToLatE7(mLatCenter - (mTop - bottomMercator) / 2);\n  try {\n    translate((lonCenter - left - (int)(width / 2L)),newBottom - bottom);\n  }\n catch (  OsmException e) {\n    e.printStackTrace();\n  }\n}\n", "docstring": "performs a translation so the center of this bounding box will be at ( loncenter | latcenter ) .", "partition": "test"}
{"idx": "5930", "code": "public void sendEvent(final String name,final Map<String,String> properties){\n  final String eventName=String.format(TfsTelemetryConstants.PLUGIN_ACTION_EVENT_NAME_FORMAT,name);\n  final PropertyMapBuilder builder=new PropertyMapBuilder(properties);\n  logger.debug(String.format(\"sendEvent(%s, %s)\",name,builder.toString()));\n  if (telemetryClient != null) {\n    telemetryClient.trackEvent(eventName,builder.build(),null);\n  }\n}\n", "docstring": "call sendevent to track an occurrence of a named event .", "partition": "test"}
{"idx": "5931", "code": "public void handleHeaderColumnPressed(Point p){\n  JTableHeader th=TABLE.getTableHeader();\n  int col=th.columnAtPoint(p);\n  int c=TABLE.convertColumnIndexToModel(col);\n  if (c != -1) {\n    TABLE.setPressedColumnIndex(c);\n    th.repaint(th.getHeaderRect(col));\n  }\n}\n", "docstring": "tell the table something is pressed .", "partition": "test"}
{"idx": "5932", "code": "private static List<FixedRecord> createFixedRecords(int count){\n  List<FixedRecord> records=new ArrayList<>();\n  for (int i=0; i < count; i++) {\n    records.add(new FixedRecord(i));\n  }\n  return records;\n}\n", "docstring": "create a list of count 16 - byte records .", "partition": "test"}
{"idx": "5933", "code": "public TrackedEntityInstanceQueryParams addAttributesIfNotExist(List<QueryItem> attrs){\n  for (  QueryItem attr : attrs) {\n    if (attributes != null && !attributes.contains(attr)) {\n      attributes.add(attr);\n    }\n  }\n  return this;\n}\n", "docstring": "add the given attributes to this params if they are not already present .", "partition": "test"}
{"idx": "5934", "code": "protected final void deleteDBFFDCFiles(String directoryToDelete) throws AdeException {\n  try {\n    final File dirToDelete=new File(directoryToDelete);\n    String[] fileList=dirToDelete.list();\n    if (fileList.length == 0) {\n      dirToDelete.delete();\n    }\n else {\n      for (int i=0; i < fileList.length; i++) {\n        final File f=new File(dirToDelete,fileList[i]);\n        if (f.isDirectory()) {\n          final String filePath=f.getPath();\n          deleteDBFFDCFiles(filePath);\n          continue;\n        }\n        f.delete();\n      }\n      fileList=dirToDelete.list();\n      if (fileList.length == 0) {\n        dirToDelete.delete();\n      }\n    }\n  }\n catch (  Exception e) {\n    throw new AdeInternalException(\"Failed to delete the backed-up Ade DB directory\",e);\n  }\n}\n", "docstring": "deletes the backed - up db directory . note that a directory can be deleted only if there are no files in it", "partition": "test"}
{"idx": "5935", "code": "public static void checkSerializedEquality(Object object){\n  Object object2=serializeAndRecover(object);\n  Assert.assertEquals(\"Equals check\",object,object2);\n  Assert.assertEquals(\"HashCode check\",object.hashCode(),object2.hashCode());\n}\n", "docstring": "verifies that serialization preserves equals and hashcode . serializes the object , then recovers it and checks equals and hash code .", "partition": "test"}
{"idx": "5936", "code": "public String documentationReferenceGuideUrl(){\n  return properties.getProperty(\"doc.guide.ref.url\");\n}\n", "docstring": "returns the url of the product wiki page .", "partition": "test"}
{"idx": "5937", "code": "public static double mean(final List<Double> list){\n  double sum=0;\n  for (  Double number : list) {\n    sum+=number;\n  }\n  return sum / list.size();\n}\n", "docstring": "gets the average from a list of numbers .", "partition": "test"}
{"idx": "5938", "code": "public static String toHex(byte[] data){\n  try {\n    return new String(Hex.encode(data),\"US-ASCII\");\n  }\n catch (  UnsupportedEncodingException e) {\n  }\n  return null;\n}\n", "docstring": "convert a byte array to hexadecimal", "partition": "test"}
{"idx": "5939", "code": "@VisibleForTesting public void processEnableFullscreenRunnableForTest(){\n  if (mHandler.hasMessages(MSG_ID_ENABLE_FULLSCREEN_AFTER_LOAD)) {\n    mHandler.removeMessages(MSG_ID_ENABLE_FULLSCREEN_AFTER_LOAD);\n    enableFullscreenAfterLoad();\n  }\n}\n", "docstring": "removes the enable fullscreen runnable from the ui queue and runs it immediately .", "partition": "test"}
{"idx": "5940", "code": "private static String fromHtmlEntity(String str){\n  Character ch=map.get(str);\n  return (ch != null) ? ch.toString() : str;\n}\n", "docstring": "find the html entity and convert it back to a regular character if the entity exists , otherwise return the same string .", "partition": "test"}
{"idx": "5941", "code": "public void unlockUI(ProcessInfo pi){\n  boolean notPrint=pi != null && pi.getAD_Process_ID() != m_curTab.getAD_Process_ID() && pi.isReportingProcess() == false;\n  setBusy(false,notPrint);\n  if (notPrint) {\n    m_curTab.dataRefresh();\n    if (pi.isTimeout())     Env.setContext(m_ctx,m_curWindowNo,\"Processed\",\"Y\");\n    m_curGC.dynamicDisplay(0);\n    setStatusLine(pi.getSummary(),pi.isError());\n    if (pi.isError())     ADialog.error(m_curWindowNo,this,null,pi.getSummary());\n    ProcessInfoUtil.setLogFromDB(pi);\n    String logInfo=pi.getLogInfo();\n    if (logInfo.length() > 0)     ADialog.info(m_curWindowNo,this,Env.getHeader(m_ctx,m_curWindowNo),pi.getTitle(),logInfo);\n  }\n else {\n    setStatusLine(pi.getSummary(),pi.isError());\n    if (pi.isError())     ADialog.error(m_curWindowNo,this,null,pi.getSummary());\n  }\n}\n", "docstring": "unlock user interface . called from the worker when processing is done", "partition": "test"}
{"idx": "5942", "code": "private Map<URI,StorageSystem> buildArrayMap(StorageSystem vplexSystem,List<VolumeDescriptor> descriptors,VolumeDescriptor.Type[] types){\n  Map<URI,StorageSystem> arrayMap=new HashMap<URI,StorageSystem>();\n  if (types != null) {\n    descriptors=VolumeDescriptor.filterByType(descriptors,types,new VolumeDescriptor.Type[]{});\n  }\n  for (  VolumeDescriptor desc : descriptors) {\n    if (arrayMap.containsKey(desc.getDeviceURI()) == false) {\n      if (vplexSystem == null) {\n        StorageSystem array=getDataObject(StorageSystem.class,desc.getDeviceURI(),_dbClient);\n        arrayMap.put(desc.getDeviceURI(),array);\n      }\n else {\n        Set<URI> connectedSystems=ConnectivityUtil.getStorageSystemAssociationsByNetwork(_dbClient,vplexSystem.getId(),StoragePort.PortType.backend);\n        if (connectedSystems.contains(desc.getDeviceURI())) {\n          StorageSystem array=getDataObject(StorageSystem.class,desc.getDeviceURI(),_dbClient);\n          arrayMap.put(desc.getDeviceURI(),array);\n        }\n      }\n    }\n  }\n  return arrayMap;\n}\n", "docstring": "build a map of uri to cached storagesystem for the underlying arrays .", "partition": "test"}
{"idx": "5943", "code": "public byte[] encrypt(byte[] plainTextAsBytes,CharSequence password) throws KeyCrypterException {\n  try {\n    byte[] salt=new byte[SALT_LENGTH];\n    secureRandom.nextBytes(salt);\n    ParametersWithIV key=(ParametersWithIV)getAESPasswordKey(password,salt);\n    BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));\n    cipher.init(true,key);\n    byte[] encryptedBytes=new byte[cipher.getOutputSize(plainTextAsBytes.length)];\n    final int processLength=cipher.processBytes(plainTextAsBytes,0,plainTextAsBytes.length,encryptedBytes,0);\n    final int doFinalLength=cipher.doFinal(encryptedBytes,processLength);\n    return concat(salt,Arrays.copyOf(encryptedBytes,processLength + doFinalLength));\n  }\n catch (  Exception e) {\n    throw new KeyCrypterException(\"Could not encrypt bytes \'\" + Utils.bytesToHexString(plainTextAsBytes) + \"\'\",e);\n  }\n}\n", "docstring": "password based encryption using aes - cbc 256 bits .", "partition": "test"}
{"idx": "5944", "code": "public final ArrayList<WifiRecord> loadWifisByBssid(final String bssid,final Integer session){\n  final ArrayList<WifiRecord> wifis=new ArrayList<>();\n  String selectSql;\n  if (session != null) {\n    selectSql=Schema.COL_BSSID + \" = \\\"\" + bssid+ \"\\\" AND \"+ Schema.COL_SESSION_ID+ \" =\\\"\"+ session+ \"\\\"\";\n  }\n else {\n    selectSql=Schema.COL_BSSID + \" = \\\"\" + bssid+ \"\\\"\";\n  }\n  final Cursor cursor=contentResolver.query(ContentProvider.CONTENT_URI_WIFI,null,selectSql,null,null);\n  final int columnIndex=cursor.getColumnIndex(Schema.COL_BSSID);\n  final int columnIndex2=cursor.getColumnIndex(Schema.COL_SSID);\n  final int columnIndex3=cursor.getColumnIndex(Schema.COL_CAPABILITIES);\n  final int columnIndex4=cursor.getColumnIndex(Schema.COL_FREQUENCY);\n  final int columnIndex5=cursor.getColumnIndex(Schema.COL_LEVEL);\n  final int columnIndex6=cursor.getColumnIndex(Schema.COL_TIMESTAMP);\n  final int columnIndex7=cursor.getColumnIndex(Schema.COL_BEGIN_POSITION_ID);\n  final int columnIndex8=cursor.getColumnIndex(Schema.COL_END_POSITION_ID);\n  final int columnIndex9=cursor.getColumnIndex(Schema.COL_KNOWN_WIFI);\n  while (cursor.moveToNext()) {\n    final WifiRecord wifi=new WifiRecord();\n    wifi.setBssid(cursor.getString(columnIndex));\n    wifi.setSsid(cursor.getString(columnIndex2));\n    wifi.setCapabilities(cursor.getString(columnIndex3));\n    wifi.setFrequency(cursor.getInt(columnIndex4));\n    wifi.setLevel(cursor.getInt(columnIndex5));\n    wifi.setOpenBmapTimestamp(cursor.getLong(columnIndex6));\n    wifi.setBeginPosition(loadPositionById(cursor.getString(columnIndex7)));\n    wifi.setEndPosition(loadPositionById(cursor.getString(columnIndex8)));\n    wifi.setCatalogStatus(CatalogStatus.values()[cursor.getInt(columnIndex9)]);\n    wifis.add(wifi);\n  }\n  cursor.close();\n  return wifis;\n}\n", "docstring": "gets wifis by bssid", "partition": "test"}
{"idx": "5945", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return AFTER_ID;\ncase 2:\n  return MAX_JOBS;\ndefault :\nreturn null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "5946", "code": "@Override public void deinstall(JEditorPane editor){\n  super.deinstall(editor);\n  editor.removeKeyListener(this);\n}\n", "docstring": "deinstalls the editor for the kit .", "partition": "test"}
{"idx": "5947", "code": "public boolean isSecure(){\n  return mTlsCipher != null && !mTlsCipher.isEmpty();\n}\n", "docstring": "check if sip transport uses tls . ring should always use srtp if tls is enabled .", "partition": "test"}
{"idx": "5948", "code": "public void sample(Record rec){\n  totalRecs++;\n  if (samples.size() < MAX_SAMPLES) {\n    samples.add(new Sample(rec,schema));\n    updateNewValueInterval(rec);\n  }\n else {\n    double flip=random.nextDouble();\n    if (flip < (double)MAX_SAMPLES / totalRecs) {\n      samples.set(random.nextInt(MAX_SAMPLES),new Sample(rec,schema));\n      updateNewValueInterval(rec);\n    }\n  }\n}\n", "docstring": "keep a record as a sample , with certain probability . this method is designed to uniformly sample all records of a table under the situation where the total number of records is unknown in advance . a client should call this method when iterating through each record of a table .", "partition": "test"}
{"idx": "5949", "code": "public TenantCreateParam prepareTenantParam(KeystoneTenant tenant){\n  TenantCreateParam param=new TenantCreateParam(CinderConstants.TENANT_NAME_PREFIX + \" \" + tenant.getName(),prepareUserMappings(tenant.getId()));\n  param.setDescription(getProperTenantDescription(tenant.getDescription()));\n  return param;\n}\n", "docstring": "prepares tenantcreateparam class filled with information from given tenant .", "partition": "test"}
{"idx": "5950", "code": "private void forceInternalError(){\n  throw new InternalError(\"gotcha\");\n}\n", "docstring": "not really any good way to convince java to do this , so i \"'\" m just gonna throw it directly .", "partition": "test"}
{"idx": "5951", "code": "@Override public void drawHighlight(Graphics g,int w,int h){\n  g.setColor(Color.black);\n  FontMetrics fm=g.getFontMetrics();\n  int l=(int)(m_x * w) - fm.stringWidth(m_id) / 2;\n  int t=(int)(m_y * h) - fm.getHeight() / 2;\n  g.fillRect(l - 2,t - 2,fm.stringWidth(m_id) + 8,fm.getHeight() + fm.getDescent() + 8);\n  drawNode(g,w,h);\n}\n", "docstring": "call this function to draw the node highlighted .", "partition": "test"}
{"idx": "5952", "code": "public static ImageEncoder newInstance(String format){\n  ImageEncoder imageEncoder=null;\n  String className=(String)encoders.get(format);\n  if (className == null) {\n    throw new IllegalArgumentException(\"Unsupported image format - \" + format);\n  }\n  try {\n    Class imageEncoderClass=Class.forName(className);\n    imageEncoder=(ImageEncoder)imageEncoderClass.newInstance();\n  }\n catch (  Exception e) {\n    throw new IllegalArgumentException(e.toString());\n  }\n  return imageEncoder;\n}\n", "docstring": "used to retrieve an imageencoder for a specific image format .", "partition": "test"}
{"idx": "5953", "code": "public double empiricalHSICincompleteCholesky(TetradMatrix Gy,TetradMatrix Gx,TetradMatrix Gz,int m){\n  int ky=Gy.columns();\n  int kx=Gx.columns();\n  int kz=Gz.columns();\n  TetradMatrix H=KernelUtils.constructH(m);\n  TetradMatrix Gcy=H.times(Gy);\n  TetradMatrix Gcx=H.times(Gx);\n  TetradMatrix Gcz=H.times(Gz);\n  TetradMatrix A=new TetradMatrix(ky,kx);\n  TetradMatrix Gcyt=Gcy.transpose();\n  A=Gcyt.times(Gcx);\n  TetradMatrix B=Gcy.times(A);\n  TetradMatrix Kyx=new TetradMatrix(m,m);\n  TetradMatrix Gcxt=new TetradMatrix(kx,m);\n  Gcxt=Gcx.transpose();\n  Kyx=B.times(Gcxt);\n  double empHSIC=0.0;\n  double xy=0.0;\n  for (int i=0; i < m; i++) {\n    empHSIC+=matrixProductEntry(B,Gcxt,i,i);\n  }\n  TetradMatrix Gytz=Gcyt.times(Gcz);\n  TetradMatrix Gczt=Gcz.transpose();\n  TetradMatrix Gztx=Gczt.times(Gcx);\n  TetradMatrix Gztz=Gczt.times(Gcz);\n  TetradMatrix Gztzr=Gztz.copy();\n  for (int i=0; i < kz; i++) {\n    Gztzr.set(i,i,Gztz.get(i,i) + this.regularizer);\n  }\n  TetradMatrix ZI=Gztzr.inverse();\n  TetradMatrix ZIzt=ZI.times(Gczt);\n  TetradMatrix Gzr=Gcz.copy();\n  for (int i=0; i < m; i++) {\n    for (int j=0; j < kz; j++) {\n      Gzr.set(i,j,Gcz.get(i,j) * (-1.0 / this.regularizer));\n    }\n  }\n  TetradMatrix Zinv=Gzr.times(ZIzt);\n  for (int i=0; i < m; i++) {\n    Zinv.set(i,i,Zinv.get(i,i) + (1.0 / this.regularizer));\n  }\n  TetradMatrix Gztzinv=Gczt.times(Zinv);\n  TetradMatrix Gzinvz=Zinv.times(Gcz);\n  TetradMatrix Gztinv2z=Gztzinv.times(Gzinvz);\n  TetradMatrix Gytzztzinv2z=Gytz.times(Gztinv2z);\n  TetradMatrix Gytzztzinv2zztx=Gytzztzinv2z.times(Gztx);\n  TetradMatrix Gyytzztzinv2zztx=Gcy.times(Gytzztzinv2zztx);\n  double second=0.0;\n  for (int i=0; i < m; i++) {\n    second+=matrixProductEntry(Gyytzztzinv2zztx,Gcxt,i,i);\n  }\n  empHSIC-=2 * second;\n  TetradMatrix Gxtz=Gcxt.times(Gcz);\n  TetradMatrix Gxtzztinv2z=Gxtz.times(Gztinv2z);\n  TetradMatrix Gyytzztzinv2zztxxtzztinv2z=Gyytzztzinv2zztx.times(Gxtzztinv2z);\n  for (int i=0; i < m; i++) {\n    empHSIC+=matrixProductEntry(Gyytzztzinv2zztxxtzztinv2z,Gczt,i,i);\n  }\n  double betaz=0.0;\n  for (int i=0; i < (m - 1); i++) {\n    for (int j=(i + 1); j < m; j++) {\n      betaz+=Math.pow(matrixProductEntry(Gcz,Gczt,i,j),2);\n      betaz+=Math.pow(matrixProductEntry(Gcz,Gczt,j,i),2);\n    }\n  }\n  empHSIC*=(m / (betaz * (m - 1)));\n  return empHSIC;\n}\n", "docstring": "empirical unconditional hilbert - schmidt dependence measure for x and y given z using incomplete cholesky decomposition to approximate gram matrices", "partition": "test"}
{"idx": "5954", "code": "public static File parse(String[] options,String option,File defValue) throws Exception {\n  String value=Utils.getOption(option,options);\n  if (value.isEmpty())   return defValue;\n else   return new File(value);\n}\n", "docstring": "parses a file option , uses default if option is missing .", "partition": "test"}
{"idx": "5955", "code": "public boolean isAcctBalanced(){\n  if (m_lines.size() == 0)   return true;\n  BigDecimal balance=getAcctBalance();\n  boolean retValue=balance.signum() == 0;\n  if (retValue)   log.finer(toString());\n else   log.warning(\"NO - Diff=\" + balance + \" - \"+ toString());\n  return retValue;\n}\n", "docstring": "are the lines accounting balanced", "partition": "test"}
{"idx": "5956", "code": "public void ensureCapacity(int minCapacity){\n  int oldCapacity=capacity;\n  if (minCapacity > oldCapacity) {\n    int newCapacity=(oldCapacity * 3) / 2 + 1;\n    if (newCapacity < minCapacity)     newCapacity=minCapacity;\n    BitVector vector=toBitVector();\n    vector.setSize(newCapacity * bitsPerElement);\n    this.bits=vector.elements();\n    this.capacity=newCapacity;\n  }\n}\n", "docstring": "ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory . if necessary , allocates new internal memory and increases the capacity of the receiver .", "partition": "test"}
{"idx": "5957", "code": "private String detailBase(final Method method){\n  final Class<?> clazz=method.getDeclaringClass();\n  final String detailBase=MessageUtils.bundleNameForClass(clazz);\n  if (isBlank(detailBase)) {\n    throw new IllegalStateException(\"no bundle name defined for \" + clazz);\n  }\n  return detailBase;\n}\n", "docstring": "get the name of the message bundle to use when getting the message for the specified method", "partition": "test"}
{"idx": "5958", "code": "public void finished() throws IOException {\n  outputStream.close();\n}\n", "docstring": "do all required cleanup now that we \"'\" re finished with the currently - open . zip", "partition": "test"}
{"idx": "5959", "code": "public final void lock(){\n  SunToolkit.awtLock();\n}\n", "docstring": "locks the queue for read / write access .", "partition": "test"}
{"idx": "5960", "code": "@Override public Object createStatement(Object proxy,Method method,Object[] args,Object statement,long time){\n  try {\n    Object result=null;\n    String name=method.getName();\n    String sql=null;\n    Constructor<?> constructor=null;\n    if (compare(CREATE_STATEMENT,name)) {\n      constructor=getConstructor(CREATE_STATEMENT_IDX,Statement.class);\n    }\n else     if (compare(PREPARE_STATEMENT,name)) {\n      sql=(String)args[0];\n      constructor=getConstructor(PREPARE_STATEMENT_IDX,PreparedStatement.class);\n      if (sql != null) {\n        prepareStatement(sql,time);\n      }\n    }\n else     if (compare(PREPARE_CALL,name)) {\n      sql=(String)args[0];\n      constructor=getConstructor(PREPARE_CALL_IDX,CallableStatement.class);\n      prepareCall(sql,time);\n    }\n else {\n      return statement;\n    }\n    result=constructor.newInstance(new Object[]{new StatementProxy(statement,sql)});\n    return result;\n  }\n catch (  Exception x) {\n    log.warn(\"Unable to create statement proxy for slow query report.\",x);\n  }\n  return statement;\n}\n", "docstring": "creates a statement interceptor to monitor query response times", "partition": "test"}
{"idx": "5961", "code": "public UpdateResponse remove(long id) throws IOException, SolrServerException {\n  UpdateResponse res=solrClient.deleteById(String.valueOf(id));\n  solrClient.commit(false,true,true);\n  return res;\n}\n", "docstring": "deletes a solrdocument with the given id .", "partition": "test"}
{"idx": "5962", "code": "public void switchSetup(){\n  int retVal;\n  retVal=m_SetupFileChooser.showOpenDialog(this);\n  if (retVal != JFileChooser.APPROVE_OPTION) {\n    return;\n  }\n  m_DbUtils.initialize(m_SetupFileChooser.getSelectedFile());\n  m_URL=m_DbUtils.getDatabaseURL();\n  m_User=m_DbUtils.getUsername();\n  m_Password=m_DbUtils.getPassword();\n  m_TextURL.setText(m_URL);\n}\n", "docstring": "lets the user select a props file for changing the database connection parameters .", "partition": "test"}
{"idx": "5963", "code": "private ClientDetailsEntity loadClientObject(final OIDCAuthorizationRequestContext authorizationRequest){\n  log.debug(\"Loading client by id {}\",authorizationRequest.getClientId());\n  return clientService.loadClientByClientId(authorizationRequest.getClientId());\n}\n", "docstring": "load client object client details entity .", "partition": "test"}
{"idx": "5964", "code": "public void addFieldProperty(String name,String accessorField){\n  fieldProperties.add(new LegacyFieldPropDesc(name,accessorField));\n}\n", "docstring": "adds the named event property backed by the named accessor field .", "partition": "test"}
{"idx": "5965", "code": "private void parseNoWildCards(){\n  this.fSegments=new String[1];\n  this.fSegments[0]=this.fPattern;\n  this.fBound=this.fLength;\n}\n", "docstring": "this method parses the given pattern into segments seperated by wildcard \"'\" * \"'\" characters . since wildcards are not being used in this case , the pattern consists of a single segment .", "partition": "test"}
{"idx": "5966", "code": "public Map<String,String> environment(){\n  String base64=toStringBase64();\n  if (base64 == null || base64.length() == 0) {\n    return Collections.emptyMap();\n  }\n  Map<String,String> environment=Maps.newHashMap();\n  environment.put(BaggageUtils.BAGGAGE_ENVIRONMENT_VARIABLE,base64);\n  return environment;\n}\n", "docstring": "encodes the baggage to strings to set as environment variables , which will then be picked up in a child process", "partition": "test"}
{"idx": "5967", "code": "@Override public void drawSeries(Canvas canvas,Paint paint,List<Float> points,List<Double> values,XYSeriesRenderer seriesRenderer,SupportSeriesRender supportSeriesRender,float yAxisValue,int seriesIndex,int startIndex){\n  int seriesNr=mDataset.getSeriesCount();\n  int length=points.size();\n  paint.setColor(seriesRenderer.getColor());\n  paint.setStyle(Style.FILL);\n  float halfDiffX=getHalfDiffX(points,length,seriesNr);\n  for (int i=0; i < length; i+=2) {\n    float x=points.get(i);\n    float y=points.get(i + 1);\n    drawBar(canvas,x,yAxisValue,x,y,halfDiffX,seriesNr,seriesIndex,paint);\n  }\n  paint.setColor(seriesRenderer.getColor());\n}\n", "docstring": "the graphical representation of a series .", "partition": "test"}
{"idx": "5968", "code": "public void listenModLog(String username,String token){\n  if (!hasServer()) {\n    return;\n  }\n  if (modLogListen.containsKey(username)) {\n    return;\n  }\n  this.token=token;\n  long userId=getUserId(username);\n  modLogListen.put(username,userId);\n  LOGGER.info(\"[PubSub] LISTEN ModLog \" + username + \" \"+ userId);\n  if (userId != -1) {\n    sendListenModLog(userId,true);\n  }\n}\n", "docstring": "start receiving the modlog for the given channel ( username ) . the token is requires to authenticate .", "partition": "test"}
{"idx": "5969", "code": "public static boolean isValidClassName(String className){\n  if (className.indexOf('(') >= 0) {\n    return false;\n  }\n  return true;\n}\n", "docstring": "return whether or not the given class name is valid .", "partition": "test"}
{"idx": "5970", "code": "@SuppressWarnings(\"deprecation\") public void newMinute(){\n  if (!inSyncWithInternalFastClock) {\n    return;\n  }\n  if (correctFastClock || synchronizeWithInternalClock) {\n    Date now=clock.getTime();\n    if (now.getMinutes() != 0) {\n      curDays=now.getDate();\n      curHours=now.getHours();\n      curMinutes=now.getMinutes();\n      long millis=now.getTime();\n      long elapsedMS=millis % MSECPERMINUTE;\n      double frac_min=elapsedMS / (double)MSECPERMINUTE;\n      curFractionalMinutes=(int)CORRECTION - (int)(CORRECTION * frac_min);\n      setClock();\n    }\n  }\n else   if (setInternal && !correctFastClock && !synchronizeWithInternalClock) {\n    inSyncWithInternalFastClock=false;\n    initiateRead();\n  }\n}\n", "docstring": "corrects the loconet fast clock", "partition": "test"}
{"idx": "5971", "code": "private <T extends DiscoveredSystemObject>boolean isDataCollectionScanJobSchedulingNeeded(long lastScanTime,boolean inProgress){\n  long systemTime=System.currentTimeMillis();\n  long refreshInterval=getRefreshInterval(ControllerServiceImpl.SCANNER);\n  if (inProgress) {\n    return false;\n  }\n  if (lastScanTime > 0 && (systemTime - lastScanTime < refreshInterval * 1000)) {\n    _logger.info(\"Skipping scanner job; attempt to schedule faster than refresh interval allows\");\n    return false;\n  }\n  return true;\n}\n", "docstring": "if the job is in progress , don \"'\" t schedule the job . if not in progress , then schedule if refresh interval is satisfied .", "partition": "test"}
{"idx": "5972", "code": "private void removeBreakpoints(final Set<BreakpointAddress> breakpointAddressSet,final BreakpointStorage storage){\n  if (breakpointAddressSet.size() != 0) {\n    final Set<Breakpoint> breakpoints=storage.getBreakPointsByAddress(breakpointAddressSet);\n    storage.removeBreakpoints(breakpointAddressSet);\n    for (    final BreakpointManagerListener listener : listeners) {\n      try {\n        listener.breakpointsRemoved(breakpoints);\n      }\n catch (      final Exception e) {\n        CUtilityFunctions.logException(e);\n      }\n    }\n  }\n}\n", "docstring": "remove the given set of breakpoints .", "partition": "test"}
{"idx": "5973", "code": "public void replaceCreationTemplate(Guid guid,String templateName,AttrSet attrSet) throws ConfigManagerException {\n  if (guid == null) {\n    guid=new Guid(_rootDN);\n  }\n  DN dn=DN.valueOf(guid.getDn());\n  String org=\"\";\n  List<RDN> rdns=new ArrayList<>();\n  for (  RDN rdn : dn) {\n    rdns.add(0,rdn);\n  }\n  for (  RDN rdn : rdns) {\n    org=org + \"/\" + LDAPUtils.rdnValue(rdn);\n  }\n  String service=CREATIONPATH + \"/\" + templateName;\n  Map map=convertToMap(attrSet);\n  try {\n    replaceServiceAttributes(org,service,map);\n  }\n catch (  SMSException e) {\n    String args[]=new String[1];\n    args[0]=e.toString();\n    throw new ConfigManagerException(i18n.getString(IUMSConstants.ERROR_CM,args));\n  }\ncatch (  SSOException se) {\n    String args[]=new String[1];\n    args[0]=se.toString();\n    throw new ConfigManagerException(i18n.getString(IUMSConstants.ERROR_CM,args));\n  }\n}\n", "docstring": "replaces an existing template .", "partition": "test"}
{"idx": "5974", "code": "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n  stream.defaultReadObject();\n  MarshalledInstance mi=(MarshalledInstance)stream.readObject();\n  try {\n    listener=(RemoteEventListener)mi.get(false);\n  }\n catch (  Throwable e) {\n    if (e instanceof Error && ThrowableConstants.retryable(e) == ThrowableConstants.BAD_OBJECT) {\n      throw (Error)e;\n    }\n    logger.log(Level.WARNING,\"failed to recover event listener\",e);\n  }\n}\n", "docstring": "unmarshals the event listener .", "partition": "test"}
{"idx": "5975", "code": "public ScServer createClusterServer(String ssn,String clusterName,String osId) throws StorageCenterAPIException {\n  Parameters params=new Parameters();\n  params.add(\"Name\",clusterName);\n  params.add(\"StorageCenter\",ssn);\n  params.add(\"Notes\",NOTES_STRING);\n  params.add(\"OperatingSystem\",osId);\n  RestResult rr=restClient.post(\"StorageCenter/ScServerCluster\",params.toJson());\n  if (!checkResults(rr)) {\n    String error=String.format(\"Error creating cluster server \'%s\': %s\",clusterName,rr.getErrorMsg());\n    throw new StorageCenterAPIException(error);\n  }\n  return gson.fromJson(rr.getResult(),ScServer.class);\n}\n", "docstring": "creates a new cluster server definition .", "partition": "test"}
{"idx": "5976", "code": "public void testMinimalCompletionStage(){\n  CompletableFuture<Integer> f=new CompletableFuture<>();\n  CompletionStage<Integer> g=f.minimalCompletionStage();\n  AtomicInteger x=new AtomicInteger(0);\n  AtomicReference<Throwable> r=new AtomicReference<Throwable>();\n  checkIncomplete(f);\n  g.whenComplete(null);\n  f.complete(1);\n  checkCompletedNormally(f,1);\n  assertEquals(x.get(),1);\n  assertNull(r.get());\n}\n", "docstring": "minimalcompletionstage returns a completablefuture that is completed normally , with the same value , when source is .", "partition": "test"}
{"idx": "5977", "code": "private void writeDirectoryPostResource(Element postResourceEl,String path){\n  postResourceEl.setAttribute(\"className\",DIR_RESOURCE_SET);\n  postResourceEl.setAttribute(\"base\",path.replace(\"&\",\"&amp;\"));\n}\n", "docstring": "write directory post resource", "partition": "test"}
{"idx": "5978", "code": "static PotionType fromName(String name){\n  for (  PotionTypeTable table : values()) {\n    if (name.equalsIgnoreCase(table.name))     return table.type;\n  }\n  return PotionType.valueOf(name.toUpperCase());\n}\n", "docstring": "converts a vanilla potion id to an equivalent bukkit potiontype", "partition": "test"}
{"idx": "5979", "code": "public synchronized void removeCurlMesh(CurlMesh mesh){\n  while (mCurlMeshes.remove(mesh))   ;\n}\n", "docstring": "removes curlmesh from this renderer .", "partition": "test"}
{"idx": "5980", "code": "private List<Datum> sampleNbestList(int sourceId,Sequence<IString> source,SentenceLevelMetric<IString,String> scoreMetric,List<RichTranslation<IString,String>> translations,List<Sequence<IString>> references){\n  int[] sourceIds=new int[1];\n  sourceIds[0]=sourceId;\n  List<Sequence<IString>> sources=new ArrayList<>(1);\n  sources.add(source);\n  List<List<RichTranslation<IString,String>>> translationList=new ArrayList<List<RichTranslation<IString,String>>>(1);\n  translationList.add(translations);\n  List<List<Sequence<IString>>> referenceList=new ArrayList<List<Sequence<IString>>>(1);\n  referenceList.add(references);\n  return sampleNbestLists(sourceIds,sources,scoreMetric,translationList,referenceList);\n}\n", "docstring": "select pro samples from a single instance .", "partition": "test"}
{"idx": "5981", "code": "public boolean isClosed(){\n  return map.isClosed();\n}\n", "docstring": "check whether this map is closed .", "partition": "test"}
{"idx": "5982", "code": "public void insertThinkTime(){\n  ScriptStep thinkTimeScriptStep=ScriptStepFactory.createThinkTime(getMinThinkTime(),getMaxThinkTime());\n  steps.add(getInsertIndex(),thinkTimeScriptStep);\n  minThinkTime=\"\";\n  maxThinkTime=\"\";\n  reindexScriptSteps();\n}\n", "docstring": "does something to insert think time into the script .", "partition": "test"}
{"idx": "5983", "code": "public void addNode(final Instruction instruction){\n  instructions.add(instruction);\n  if (prevInstruction != null) {\n    addEdge(prevInstruction,instruction);\n  }\n  prevInstruction=instruction;\n}\n", "docstring": "add new node and set prev instruction pointing to this instruction", "partition": "test"}
{"idx": "5984", "code": "public void ensureCapacity(int minimumCapacity){\n  if (minimumCapacity <= _capacity)   return;\n  if (minimumCapacity > 0x1000) {\n    _capacity=(minimumCapacity + 0xfff) & ~0xfff;\n  }\n else {\n    while (_capacity < minimumCapacity) {\n      _capacity+=_capacity;\n    }\n  }\n  byte[] bytes=new byte[_capacity];\n  System.arraycopy(_buffer,0,bytes,0,_length);\n  _buffer=bytes;\n}\n", "docstring": "ensure the buffer can hold at least \"'\" minimumcapacity \"'\" bytes .", "partition": "test"}
{"idx": "5985", "code": "public <T>JSONAPIDocument<List<T>> readDocumentCollection(InputStream dataStream,Class<T> clazz){\n  try {\n    resourceCache.init();\n    JsonNode rootNode=objectMapper.readTree(dataStream);\n    ValidationUtils.ensureNotError(objectMapper,rootNode);\n    ValidationUtils.ensureCollection(rootNode);\n    resourceCache.cache(parseIncluded(rootNode));\n    List<T> resourceList=new ArrayList<>();\n    for (    JsonNode element : rootNode.get(DATA)) {\n      T pojo=readObject(element,clazz,true);\n      resourceList.add(pojo);\n    }\n    JSONAPIDocument<List<T>> result=new JSONAPIDocument<>(resourceList,objectMapper);\n    if (rootNode.has(META)) {\n      result.setMeta(mapMeta(rootNode.get(META)));\n    }\n    if (rootNode.has(LINKS)) {\n      result.setLinks(new Links(mapLinks(rootNode.get(LINKS))));\n    }\n    return result;\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    resourceCache.clear();\n  }\n}\n", "docstring": "reads json api spec document and converts it into collection of target type objects .", "partition": "test"}
{"idx": "5986", "code": "public void addTargetedBySwarm(int entityId,int weaponId){\n  hitBySwarmsEntity.addElement(new Integer(entityId));\n  hitBySwarmsWeapon.addElement(new Integer(weaponId));\n}\n", "docstring": "add a targeting by a swarm volley from a specified entity", "partition": "test"}
{"idx": "5987", "code": "private boolean isCheckpointExists(Connection conn,String key) throws SQLException {\n  PreparedStatement st=null;\n  ResultSet rs=null;\n  try {\n    st=conn.prepareStatement(chkExistsSql);\n    st.setString(1,key);\n    rs=st.executeQuery();\n    return rs.next();\n  }\n  finally {\n    U.close(rs,log);\n    U.close(st,log);\n  }\n}\n", "docstring": "checks specified checkpoint existing .", "partition": "test"}
{"idx": "5988", "code": "public OMScalingRaster(double ullat,double ullon,double lrlat,double lrlon,ImageIcon ii){\n  this(ullat,ullon,lrlat,lrlon,ii.getImage());\n}\n", "docstring": "create an omraster , lat / lon placement with an imageicon .", "partition": "test"}
{"idx": "5989", "code": "public static void copyStream(InputStream is,OutputStream os,byte[] buffer,int bufferSize,String confid,double fileSize,Context context) throws IOException {\n  double downloaded=0;\n  int[] update=new int[3];\n  try {\n    for (; ; ) {\n      int count=is.read(buffer,0,bufferSize);\n      downloaded+=count;\n      if (count == -1) {\n        if (context != null) {\n        }\n        break;\n      }\n      os.write(buffer,0,count);\n      if (context != null) {\n        update[0]=(int)downloaded;\n        update[1]=(int)fileSize;\n        update[2]=(int)((downloaded / fileSize) * 100);\n      }\n    }\n  }\n catch (  IOException e) {\n    throw e;\n  }\n}\n", "docstring": "copy from one stream to another . throws ioexception in the event of error ( for example , sd card is full )", "partition": "test"}
{"idx": "5990", "code": "@Override public void writeHeader() throws IOException {\n  os=new PDFWriter(new BufferedOutputStream(ros),PDF_VERSION);\n  delayImageQueue=new PDFImageDelayQueue(os);\n  delayPaintQueue=new PDFPaintDelayQueue(os,delayImageQueue);\n  fontTable=new PDFFontTable(os);\n  PDFDocInfo info=os.openDocInfo(\"DocInfo\");\n  info.setTitle(getProperty(TITLE));\n  info.setAuthor(getProperty(AUTHOR));\n  info.setSubject(getProperty(SUBJECT));\n  info.setKeywords(getProperty(KEYWORDS));\n  info.setCreator(getCreator());\n  info.setProducer(producer == null ? \"\" : producer);\n  if (!isDeviceIndependent()) {\n    Calendar now=Calendar.getInstance();\n    info.setCreationDate(now);\n    info.setModificationDate(now);\n  }\n  info.setTrapped(\"False\");\n  os.close(info);\n  PDFCatalog catalog=os.openCatalog(\"Catalog\",\"RootPage\");\n  catalog.setOutlines(\"Outlines\");\n  catalog.setPageMode(\"UseOutlines\");\n  catalog.setViewerPreferences(\"Preferences\");\n  catalog.setOpenAction(new Object[]{os.ref(\"Page1\"),os.name(\"Fit\")});\n  os.close(catalog);\n  PDFViewerPreferences prefs=os.openViewerPreferences(\"Preferences\");\n  prefs.setFitWindow(true);\n  prefs.setCenterWindow(false);\n  os.close(prefs);\n  alphaIndex=1;\n  extGStates=new HashMap<Float,String>();\n  if (!isMultiPage()) {\n    openPage(getSize(),null);\n  }\n}\n", "docstring": "writes the catalog , docinfo , preferences , and ( as we use only single page output the page tree .", "partition": "test"}
{"idx": "5991", "code": "protected String parseString(int closingCharacter) throws IOException, RDFParseException {\n  StringBuilder sb=getBuilder();\n  while (true) {\n    int c=readCodePoint();\n    if (c == closingCharacter) {\n      break;\n    }\n else     if (c == -1) {\n      throwEOFException();\n    }\n    appendCodepoint(sb,c);\n    if (c == '\\\\') {\n      c=readCodePoint();\n      if (c == -1) {\n        throwEOFException();\n      }\n      appendCodepoint(sb,c);\n    }\n  }\n  return sb.toString();\n}\n", "docstring": "parses a \" normal string \" . this method requires that the opening character has already been parsed .", "partition": "test"}
{"idx": "5992", "code": "private void codeUnwrapReturnValue(Class<?> type,DataOutputStream out) throws IOException {\n  if (type.isPrimitive()) {\n    PrimitiveTypeInfo prim=PrimitiveTypeInfo.get(type);\n    out.writeByte(opc_checkcast);\n    out.writeShort(cp.getClass(prim.wrapperClassName));\n    out.writeByte(opc_invokevirtual);\n    out.writeShort(cp.getMethodRef(prim.wrapperClassName,prim.unwrapMethodName,prim.unwrapMethodDesc));\n    if (type == int.class || type == boolean.class || type == byte.class || type == char.class || type == short.class) {\n      out.writeByte(opc_ireturn);\n    }\n else     if (type == long.class) {\n      out.writeByte(opc_lreturn);\n    }\n else     if (type == float.class) {\n      out.writeByte(opc_freturn);\n    }\n else     if (type == double.class) {\n      out.writeByte(opc_dreturn);\n    }\n else {\n      throw new AssertionError();\n    }\n  }\n else {\n    out.writeByte(opc_checkcast);\n    out.writeShort(cp.getClass(dotToSlash(type.getName())));\n    out.writeByte(opc_areturn);\n  }\n}\n", "docstring": "generate code for unwrapping a return value of the given type from the invocation handler \"'\" s \" invoke \" method ( as type object ) to its correct type . the code is written to the supplied stream .", "partition": "test"}
{"idx": "5993", "code": "private String formatLink(String[] parts){\n  String anchor, text;\n  if (parts.length < 2) {\n    anchor=\"\";\n    text=\"Checker Framework\";\n  }\n else {\n    anchor=parts[0];\n    text=parts[1];\n  }\n  return String.format(\"<A HREF=\\\"http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html%s\\\">%s</A>\",anchor,text);\n}\n", "docstring": "formats a link , given an array of tokens .", "partition": "test"}
{"idx": "5994", "code": "public boolean fixUtils(String[] utils) throws Exception {\n  for (  String util : utils) {\n    if (!checkUtil(util)) {\n      if (checkUtil(\"busybox\")) {\n        if (hasUtil(util,\"busybox\")) {\n          fixUtil(util,RootTools.utilPath);\n        }\n      }\n else {\n        if (checkUtil(\"toolbox\")) {\n          if (hasUtil(util,\"toolbox\")) {\n            fixUtil(util,RootTools.utilPath);\n          }\n        }\n else {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n", "docstring": "this will check an array of binaries , determine if they exist and determine that it has either the permissions 755 , 775 , or 777 . if an applet is not setup correctly it will try and fix it . ( this is for busybox applets or toolbox applets )", "partition": "test"}
{"idx": "5995", "code": "@Override protected void initialize(){\n  List<String> patterns;\n  super.initialize();\n  m_Patterns=new ArrayList<Pattern>();\n  patterns=read();\n  for (  String pattern : patterns) {\n    m_Patterns.add(Pattern.compile(pattern));\n  }\n}\n", "docstring": "performs intialization of the scheme .", "partition": "test"}
{"idx": "5996", "code": "public static String[] lsDirectories(String directory) throws Exception {\n  String[] tmp=ls(directory);\n  ArrayList<String> files=new ArrayList<>();\n  for (  String s : tmp) {\n    if (isDirectory(directory + File.separator + s))     files.add(s);\n  }\n  return files.toArray(new String[files.size()]);\n}\n", "docstring": "list the directories contained within a directory .", "partition": "test"}
{"idx": "5997", "code": "public static void encode(Appendable out,int value) throws IOException {\n  value=toVLQSigned(value);\n  do {\n    int digit=value & VLQ_BASE_MASK;\n    value>>>=VLQ_BASE_SHIFT;\n    if (value > 0) {\n      digit|=VLQ_CONTINUATION_BIT;\n    }\n    out.append(Base64.toBase64(digit));\n  }\n while (value > 0);\n}\n", "docstring": "writes a vlq encoded value to the provide appendable .", "partition": "test"}
{"idx": "5998", "code": "public mxICellOverlay removeCellOverlay(Object cell,mxICellOverlay overlay){\n  if (overlay == null) {\n    removeCellOverlays(cell);\n  }\n else {\n    mxICellOverlay[] arr=getCellOverlays(cell);\n    if (arr != null) {\n      List<mxICellOverlay> list=Arrays.asList(arr);\n      if (list.remove(overlay)) {\n        removeCellOverlayComponent(overlay,cell);\n      }\n      arr=(mxICellOverlay[])list.toArray();\n      overlays.put(cell,arr);\n    }\n  }\n  return overlay;\n}\n", "docstring": "removes and returns the given overlay from the given cell . this method fires a removeoverlay event . if no overlay is given , then all overlays are removed using removeoverlays .", "partition": "test"}
{"idx": "5999", "code": "public void removeForeignKey(int idx){\n  foreignKeys.remove(idx);\n}\n", "docstring": "removes the indicated foreign key .", "partition": "test"}
{"idx": "6000", "code": "public java.lang.StringBuffer insert(int offset,int i){\n  internal.insert(offset,i);\n  return this;\n}\n", "docstring": "inserts the string representation of the second int argument into this string buffer . the second argument is converted to a string as if by the method string . valueof , and the characters of that string are then inserted into this string buffer at the indicated offset . the offset argument must be greater than or equal to 0 , and less than or equal to the length of this string buffer .", "partition": "test"}
{"idx": "6001", "code": "public void addGefaehrdungsUmsetzung(GefaehrdungsUmsetzung gefaehrdung){\n  if (!allGefaehrdungsUmsetzungen.contains(gefaehrdung)) {\n    allGefaehrdungsUmsetzungen.add(gefaehrdung);\n  }\n}\n", "docstring": "adds a gefaehrdung to the list of all gefaehrdungen if gefaehrdung not already exits .", "partition": "test"}
{"idx": "6002", "code": "String normalizeClassPath(String classPath,boolean generateRelative){\n  char sep=CauchoUtil.getPathSeparatorChar();\n  int head=0;\n  int tail=0;\n  CharBuffer cb=CharBuffer.allocate();\n  while (head < classPath.length()) {\n    tail=classPath.indexOf(sep,head);\n    if (tail < 0)     tail=classPath.length();\n    if (tail > head) {\n      String segment=classPath.substring(head,tail);\n      segment=normalizePath(segment,generateRelative);\n      if (segment != null) {\n        if (cb.length() != 0)         cb.append(sep);\n        cb.append(segment);\n      }\n    }\n    head=tail + 1;\n  }\n  return cb.close();\n}\n", "docstring": "converts any relative classpath references to the full path .", "partition": "test"}
{"idx": "6003", "code": "public static double pow(final double x,final double y){\n  if (y == 0) {\n    return 1.0;\n  }\n else {\n    final long yBits=Double.doubleToRawLongBits(y);\n    final int yRawExp=(int)((yBits & MASK_DOUBLE_EXPONENT) >> 52);\n    final long yRawMantissa=yBits & MASK_DOUBLE_MANTISSA;\n    final long xBits=Double.doubleToRawLongBits(x);\n    final int xRawExp=(int)((xBits & MASK_DOUBLE_EXPONENT) >> 52);\n    final long xRawMantissa=xBits & MASK_DOUBLE_MANTISSA;\n    if (yRawExp > 1085) {\n      if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {\n        return Double.NaN;\n      }\n else       if (xRawExp == 1023 && xRawMantissa == 0) {\n        if (yRawExp == 2047) {\n          return Double.NaN;\n        }\n else {\n          return 1.0;\n        }\n      }\n else {\n        if ((y > 0) ^ (xRawExp < 1023)) {\n          return Double.POSITIVE_INFINITY;\n        }\n else {\n          return +0.0;\n        }\n      }\n    }\n else {\n      if (yRawExp >= 1023) {\n        final long yFullMantissa=IMPLICIT_HIGH_BIT | yRawMantissa;\n        if (yRawExp < 1075) {\n          final long integralMask=(-1L) << (1075 - yRawExp);\n          if ((yFullMantissa & integralMask) == yFullMantissa) {\n            final long l=yFullMantissa >> (1075 - yRawExp);\n            return FastMath.pow(x,(y < 0) ? -l : l);\n          }\n        }\n else {\n          final long l=yFullMantissa << (yRawExp - 1075);\n          return FastMath.pow(x,(y < 0) ? -l : l);\n        }\n      }\n      if (x == 0) {\n        return y < 0 ? Double.POSITIVE_INFINITY : +0.0;\n      }\n else       if (xRawExp == 2047) {\n        if (xRawMantissa == 0) {\n          return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;\n        }\n else {\n          return Double.NaN;\n        }\n      }\n else       if (x < 0) {\n        return Double.NaN;\n      }\n else {\n        final double tmp=y * HEX_40000000;\n        final double ya=(y + tmp) - tmp;\n        final double yb=y - ya;\n        final double lns[]=new double[2];\n        final double lores=log(x,lns);\n        if (Double.isInfinite(lores)) {\n          return lores;\n        }\n        double lna=lns[0];\n        double lnb=lns[1];\n        final double tmp1=lna * HEX_40000000;\n        final double tmp2=(lna + tmp1) - tmp1;\n        lnb+=lna - tmp2;\n        lna=tmp2;\n        final double aa=lna * ya;\n        final double ab=lna * yb + lnb * ya + lnb * yb;\n        lna=aa + ab;\n        lnb=-(lna - aa - ab);\n        double z=1.0 / 120.0;\n        z=z * lnb + (1.0 / 24.0);\n        z=z * lnb + (1.0 / 6.0);\n        z=z * lnb + 0.5;\n        z=z * lnb + 1.0;\n        z*=lnb;\n        final double result=exp(lna,z,null);\n        return result;\n      }\n    }\n  }\n}\n", "docstring": "power function . compute x ^ y .", "partition": "test"}
{"idx": "6004", "code": "protected Node stringConversion(Node node){\n  TypeElement stringElement=elements.getTypeElement(\"java.lang.String\");\n  if (!TypesUtils.isString(node.getType())) {\n    Node converted=new StringConversionNode(node.getTree(),node,stringElement.asType());\n    addToConvertedLookupMap(converted);\n    insertNodeAfter(converted,node);\n    return converted;\n  }\n else {\n    return node;\n  }\n}\n", "docstring": "convert the input node to string type , if it isn \"'\" t already .", "partition": "test"}
{"idx": "6005", "code": "private void validate() throws URISyntaxException {\n  String s=getScheme();\n  if ((s != null) && (s.compareTo(\"file\") == 0)) {\n    return;\n  }\n  if (getLocalVmId() == -1) {\n    throw new URISyntaxException(uri.toString(),\"Local vmid required\");\n  }\n}\n", "docstring": "check that the vmidentifier includes a unique numerical identifier for the target jvm .", "partition": "test"}
{"idx": "6006", "code": "public synchronized void finishWriting(){\n  doneWriting=true;\n  notifyAll();\n}\n", "docstring": "stream will close after the already written bytes are read .", "partition": "test"}
{"idx": "6007", "code": "private long offset2PhysicalAddress(final long offset){\n  return offset + headerSize;\n}\n", "docstring": "adjusts the offset by the headersize , such that writing to a zero offset would not corrupt the header .", "partition": "test"}
{"idx": "6008", "code": "@Override public void internalEntityDecl(String name,XMLString text,XMLString nonNormalizedText,Augmentations augs) throws XNIException {\n  try {\n    if (fDeclHandler != null) {\n      fDeclHandler.internalEntityDecl(name,text.toString());\n    }\n  }\n catch (  SAXException e) {\n    throw new XNIException(e);\n  }\n}\n", "docstring": "an internal entity declaration .", "partition": "test"}
{"idx": "6009", "code": "public static boolean isAuthorized(String logName,String operation,Object credential){\n  return authorizer.isAuthorized(logName,operation,credential);\n}\n", "docstring": "returns true if a given log record should be published .", "partition": "test"}
{"idx": "6010", "code": "public Object next(){\n  if (pos < size)   return Array.get(array,pos++);\n  throw new NoSuchElementException(\"No more elements: \" + pos + \" / \"+ size);\n}\n", "docstring": "move to next element in the array .", "partition": "test"}
{"idx": "6011", "code": "public PermissionRequestObject onRational(Func3 rationalFunc){\n  mRationalFunc=rationalFunc;\n  return this;\n}\n", "docstring": "called for the first denied permission if there is need to show the rational", "partition": "test"}
{"idx": "6012", "code": "public GenericPrincipal(String userName,String password,List<String> roles,Map<String,List<GenericPrincipal.Attribute>> writeEntries,Map<String,List<GenericPrincipal.Attribute>> readEntries,Map<String,List<GenericPrincipal.Attribute>> executeTasks){\n  this.userName=userName;\n  this.password=password;\n  this.writeEntries=writeEntries;\n  this.readEntries=readEntries;\n  this.executeTasks=executeTasks;\n  if (roles != null) {\n    this.roles=new String[roles.size()];\n    this.roles=roles.toArray(this.roles);\n    if (this.roles.length > 0)     Arrays.sort(this.roles);\n  }\n  writeMatchObjects=new HashMap<String,MatchObject>();\n  readMatchObjects=new HashMap<String,MatchObject>();\n  executeMatchObjects=new HashMap<String,MatchObject>();\n  userDefinedRoles=new ArrayList<String>();\n}\n", "docstring": "construct a new principal for the specified username and password , with the specified role names ( as strings ) .", "partition": "test"}
{"idx": "6013", "code": "public static int roll1D6(){\n  return rand.nextInt(6) + 1;\n}\n", "docstring": "simulates rolling a dice with 6 sides .", "partition": "test"}
{"idx": "6014", "code": "static byte[] septetStream2octetStream(byte[] septets){\n  int octetLength=(int)Math.ceil(((septets.length * 7)) / 8.0);\n  byte[] octets=new byte[octetLength];\n  for (int i=0; i < septets.length; i++) {\n    for (int j=0; j < 7; j++) {\n      if ((septets[i] & (1 << j)) != 0) {\n        int bitIndex=(i * 7) + j;\n        octets[bitIndex >>> 3]|=1 << (bitIndex & 7);\n      }\n    }\n  }\n  return octets;\n}\n", "docstring": "convert a list of septet values into an octet stream , with a number of empty bits at the start .", "partition": "test"}
{"idx": "6015", "code": "public CTaggingPanel(final JFrame parent,final ZyGraph graph,final ITagManager manager){\n  super(new BorderLayout());\n  m_tagsTree=new CTagsTree(parent,graph,manager);\n  final JScrollPane pane=new JScrollPane(m_tagsTree);\n  pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n  pane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n  add(pane);\n  setBorder(new TitledBorder(new LineBorder(Color.LIGHT_GRAY,1,true),\"Tagging\"));\n  setDoubleBuffered(true);\n}\n", "docstring": "creates a new panel object .", "partition": "test"}
{"idx": "6016", "code": "@Override public double height(final int markerIndex){\n  MathUtils.checkRangeInclusive(markerIndex,1,markerArray.length - 1);\n  return markerArray[markerIndex].markerHeight;\n}\n", "docstring": "return marker height given index", "partition": "test"}
{"idx": "6017", "code": "public double distance(Instance first,Instance second,PerformanceStats stats){\n  return Math.sqrt(distance(first,second,Double.POSITIVE_INFINITY,stats));\n}\n", "docstring": "calculates the distance ( or similarity ) between two instances . need to pass this returned distance later on to postprocess method to set it on correct scale . < br / > p . s . : please don \"'\" t mix the use of this function with distance ( instance first , instance second ) , as that already does post processing . please consider passing double . positive_infinity as the cutoffvalue to this function and then later on do the post processing on all the distances .", "partition": "test"}
{"idx": "6018", "code": "public void findSameAsChaining(Resource subj,Set<Resource> currentSameAs,Resource[] contxts) throws InferenceEngineException {\n  try {\n    CloseableIteration<Statement,QueryEvaluationException> subjIter=RyaDAOHelper.query(ryaDAO,subj,OWL.SAMEAS,null,conf,contxts);\n    while (subjIter.hasNext()) {\n      Statement st=subjIter.next();\n      if (!currentSameAs.contains(st.getObject())) {\n        Resource castedObj=(Resource)st.getObject();\n        currentSameAs.add(castedObj);\n        findSameAsChaining(castedObj,currentSameAs,contxts);\n      }\n    }\n    subjIter.close();\n    CloseableIteration<Statement,QueryEvaluationException> objIter=RyaDAOHelper.query(ryaDAO,null,OWL.SAMEAS,subj,conf,contxts);\n    while (objIter.hasNext()) {\n      Statement st=objIter.next();\n      if (!currentSameAs.contains(st.getSubject())) {\n        Resource sameAsSubj=st.getSubject();\n        currentSameAs.add(sameAsSubj);\n        findSameAsChaining(sameAsSubj,currentSameAs,contxts);\n      }\n    }\n    objIter.close();\n  }\n catch (  QueryEvaluationException e) {\n    throw new InferenceEngineException(e);\n  }\n}\n", "docstring": "todo : this chaining can be slow at query execution . the other option is to perform this in the query itself , but that will be constrained to how many levels we decide to go", "partition": "test"}
{"idx": "6019", "code": "public static void reindex(Connection conn) throws SQLException {\n  init(conn);\n  removeAllTriggers(conn,TRIGGER_PREFIX);\n  removeIndexFiles(conn);\n  Statement stat=conn.createStatement();\n  ResultSet rs=stat.executeQuery(\"SELECT * FROM \" + SCHEMA + \".INDEXES\");\n  while (rs.next()) {\n    String schema=rs.getString(\"SCHEMA\");\n    String table=rs.getString(\"TABLE\");\n    createTrigger(conn,schema,table);\n    indexExistingRows(conn,schema,table);\n  }\n}\n", "docstring": "re - creates the full text index for this database . calling this method is usually not needed , as the index is kept up - to - date automatically .", "partition": "test"}
{"idx": "6020", "code": "private void resizeTables(){\n  if (mObjectDataUsed > mObjectData.length - MAX_DATA_SIZE) {\n    mObjectData=Arrays.copyOf(mObjectData,mObjectData.length * 2);\n  }\n  if (mObjectCount < mTypes.length) {\n    return;\n  }\n  mObjectOffset=Arrays.copyOf(mObjectOffset,mObjectOffset.length * 2);\n  mTypes=Arrays.copyOf(mTypes,mTypes.length * 2);\n  mObjects=Arrays.copyOf(mObjects,mObjects.length * 2);\n  mRect=Arrays.copyOf(mRect,mRect.length * 2);\n}\n", "docstring": "resize tables as the number of objects grow", "partition": "test"}
{"idx": "6021", "code": "protected static double convertPercentileToX(double percentileLevelIteratedTo){\n  double x=1 / (1.0D - (percentileLevelIteratedTo / 100.0D));\n  return Math.log10(x);\n}\n", "docstring": "x = 1 / ( 1 - percentage )", "partition": "test"}
{"idx": "6022", "code": "public static String queueNameFromDBName(String dbName){\n  String[] tokens=dbName.split(\"_\",3);\n  return tokens[2];\n}\n", "docstring": "extracts the queue name given a pinlater queue database name .", "partition": "test"}
{"idx": "6023", "code": "public String UseThis(int type,String id,String context){\n  int i=FindSym(type,id,context);\n  if (i == symtab.size())   return id;\n else   return ((SymTabEntry)symtab.elementAt(i)).useThis;\n}\n", "docstring": "routines for returning disambiguated names .", "partition": "test"}
{"idx": "6024", "code": "private float angle(TouchState s){\n  return (float)Math.toDegrees(Math.atan2(s.yDown - s.yCurrent,s.xDown - s.xCurrent));\n}\n", "docstring": "angle between the current touch coordinates and the down coordinates", "partition": "test"}
{"idx": "6025", "code": "private int uint16FromData(int offset){\n  return twoBytesToInt(Arrays.copyOfRange(data(),offset,offset + 2),Constants.CC2540_BYTE_ORDER);\n}\n", "docstring": "parse a little - endian uint16 from the data at the given offset .", "partition": "test"}
{"idx": "6026", "code": "protected static Pair<String,String> asrRegister(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue1,final String registerNodeValue2){\n  final String shifterOperand=environment.getNextVariableString();\n  final String shifterCarryOut=environment.getNextVariableString();\n  final String isZeroCondition=environment.getNextVariableString();\n  final String isLessCondition=environment.getNextVariableString();\n  final String isGtEqCondition=environment.getNextVariableString();\n  final String shifterCarryOutTmp1=environment.getNextVariableString();\n  final String shifterCarryOutTmp2=environment.getNextVariableString();\n  final String shifterCarryOutTmp3=environment.getNextVariableString();\n  final String shifterCarryOutTmp4=environment.getNextVariableString();\n  final String shifterOperandTmp1=environment.getNextVariableString();\n  final String shifterOperandTmp2=environment.getNextVariableString();\n  final String shifterOperandTmp3=environment.getNextVariableString();\n  final String shifterOperandTmp4=environment.getNextVariableString();\n  final String tmpRsRegister=environment.getNextVariableString();\n  final String negativeTmpRsRegister=environment.getNextVariableString();\n  final String tmpVar1=environment.getNextVariableString();\n  final String tmpVar2=environment.getNextVariableString();\n  final String tmpVar3=environment.getNextVariableString();\n  final String tmpVar4=environment.getNextVariableString();\n  final String tmpVar5=environment.getNextVariableString();\n  final String tmpVar6=environment.getNextVariableString();\n  final String tmpVar7=environment.getNextVariableString();\n  final String tmpVar8=environment.getNextVariableString();\n  final String tmpVar9=environment.getNextVariableString();\n  final String tmpVar10=environment.getNextVariableString();\n  final String tmpVar11=environment.getNextVariableString();\n  long baseOffset=offset;\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dWordSize,registerNodeValue2,dWordSize,String.valueOf(0xFFL),dWordSize,tmpRsRegister));\n  instructions.add(ReilHelpers.createSub(baseOffset++,dWordSize,zeroSet,dWordSize,tmpRsRegister,dWordSize,negativeTmpRsRegister));\n  instructions.add(ReilHelpers.createBisz(baseOffset++,dWordSize,tmpRsRegister,byteSize,isZeroCondition));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,byteSize,\"C\",byteSize,isZeroCondition,byteSize,shifterCarryOutTmp1));\n  instructions.add(ReilHelpers.createSub(baseOffset++,dWordSize,String.valueOf(0),byteSize,isZeroCondition,dWordSize,tmpVar1));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dWordSize,tmpVar1,dWordSize,registerNodeValue2,dWordSize,shifterOperandTmp1));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dWordSize,tmpRsRegister,dWordSize,String.valueOf(0xFFFFFFE0L),dWordSize,tmpVar2));\n  instructions.add(ReilHelpers.createBisz(baseOffset++,dWordSize,tmpVar2,byteSize,isLessCondition));\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dWordSize,registerNodeValue1,dWordSize,bitMaskHighestBitSet,dWordSize,tmpVar3));\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,tmpVar3,dWordSize,negativeTmpRsRegister,dWordSize,tmpVar4));\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,bitMaskHighestBitSet,dWordSize,negativeTmpRsRegister,dWordSize,tmpVar5));\n  instructions.add(ReilHelpers.createSub(baseOffset++,dWordSize,tmpVar4,dWordSize,tmpVar5,dWordSize,tmpVar6));\n  instructions.add(ReilHelpers.createSub(baseOffset++,dWordSize,zeroSet,byteSize,isLessCondition,dWordSize,tmpVar7));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dWordSize,tmpVar6,dWordSize,tmpVar7,dWordSize,shifterOperandTmp2));\n  instructions.add(ReilHelpers.createSub(baseOffset++,dWordSize,tmpRsRegister,byteSize,oneSet,dWordSize,tmpVar8));\n  instructions.add(ReilHelpers.createSub(baseOffset++,dWordSize,zeroSet,dWordSize,tmpVar8,dWordSize,tmpVar8));\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,registerNodeValue1,dWordSize,tmpVar8,dWordSize,tmpVar9));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,dWordSize,tmpVar9,byteSize,isLessCondition,byteSize,shifterCarryOutTmp2));\n  instructions.add(ReilHelpers.createOr(baseOffset++,byteSize,isZeroCondition,byteSize,isLessCondition,byteSize,tmpVar10));\n  instructions.add(ReilHelpers.createBisz(baseOffset++,byteSize,tmpVar10,byteSize,isGtEqCondition));\n  instructions.add(ReilHelpers.createBsh(baseOffset++,dWordSize,registerNodeValue1,dWordSize,minusThirtyOneSet,byteSize,tmpVar11));\n  instructions.add(ReilHelpers.createSub(baseOffset++,byteSize,zeroSet,byteSize,isGtEqCondition,dWordSize,shifterOperandTmp3));\n  instructions.add(ReilHelpers.createAnd(baseOffset++,byteSize,tmpVar11,byteSize,isGtEqCondition,byteSize,shifterCarryOutTmp3));\n  instructions.add(ReilHelpers.createOr(baseOffset++,byteSize,shifterCarryOutTmp1,byteSize,shifterCarryOutTmp2,byteSize,shifterCarryOutTmp4));\n  instructions.add(ReilHelpers.createOr(baseOffset++,byteSize,shifterCarryOutTmp3,byteSize,shifterCarryOutTmp4,byteSize,shifterCarryOut));\n  instructions.add(ReilHelpers.createOr(baseOffset++,dWordSize,shifterOperandTmp1,dWordSize,shifterOperandTmp2,dWordSize,shifterOperandTmp4));\n  instructions.add(ReilHelpers.createOr(baseOffset++,dWordSize,shifterOperandTmp3,dWordSize,shifterOperandTmp4,dWordSize,shifterOperand));\n  return new Pair<String,String>(shifterOperand,shifterCarryOut);\n}\n", "docstring": "< rm > , asr < rs > operation : if rs [ 7 : 0 ", "partition": "test"}
{"idx": "6027", "code": "private static String removeQuotesEncolosingOption(String fileName,String option) throws Exception {\n  String option1=removeQuoteCharactersIfNecessary(fileName,option,\'\"\');\n  if (!option1.equals(option)) {\n    return option1;\n  }\n  return removeQuoteCharactersIfNecessary(fileName,option,\'\\\'\');\n}\n", "docstring": "removes the surrounding quote characters as needed . it first attempts to remove surrounding double quotes . if successful , the resultant string is returned . if no surrounding double quotes are found , it attempts to remove surrounding single quote characters . if successful , the resultant string is returned . if not the original string is returnred .", "partition": "test"}
{"idx": "6028", "code": "@Override public String generateLabel(XYDataset dataset,int series){\n  ParamChecks.nullNotPermitted(dataset,\"dataset\");\n  String label=MessageFormat.format(this.formatPattern,createItemArray(dataset,series));\n  return label;\n}\n", "docstring": "generates a label for the specified series . this label will be used for the chart legend .", "partition": "test"}
{"idx": "6029", "code": "private boolean matchStrings(String pattern,String str,Map<String,String> uriTemplateVariables){\n  AntPathStringMatcher matcher=new AntPathStringMatcher(pattern,str,uriTemplateVariables);\n  return matcher.matchStrings();\n}\n", "docstring": "tests whether or not a string matches against a pattern . the pattern may contain two special characters : < br > \"'\" * \"'\" means zero or more characters < br > \"'\" ? \"'\" means one and only one character", "partition": "test"}
{"idx": "6030", "code": "@Nullable public Dimension adjust(@NotNull Dimension newPreferredSize,@Nullable Dimension oldPreferredSize,@NotNull EditorImpl editor){\n  if (oldPreferredSize == null || mySkip) {\n    return newPreferredSize;\n  }\n  if (newPreferredSize.height != oldPreferredSize.height) {\n    return newPreferredSize;\n  }\n  stripTimings();\n  myTimings.add(System.currentTimeMillis());\n  if (myTimings.size() < FREQUENT_SIZE_CHANGES_NUMBER) {\n    return newPreferredSize;\n  }\n  boolean increaseWidth=newPreferredSize.width > oldPreferredSize.width;\n  Dimension result;\n  if (increaseWidth) {\n    final int spaceWidth=EditorUtil.getSpaceWidth(Font.PLAIN,editor);\n    newPreferredSize.width+=myReserveColumns * spaceWidth;\n    myReserveColumns+=3;\n    result=newPreferredSize;\n  }\n else {\n    result=oldPreferredSize;\n  }\n  scheduleSizeUpdate(editor);\n  return result;\n}\n", "docstring": "asks to adjust new preferred size appliance if necessary .", "partition": "test"}
{"idx": "6031", "code": "public RVMField findDeclaredField(Atom fieldName,Atom fieldDescriptor){\n  for (  RVMField field : declaredFields) {\n    if (field.getName() == fieldName && field.getDescriptor() == fieldDescriptor) {\n      return field;\n    }\n  }\n  return null;\n}\n", "docstring": "find description of a field of this class .", "partition": "test"}
{"idx": "6032", "code": "public Quarter(Date time,TimeZone zone){\n  this(time,zone,Locale.getDefault());\n}\n", "docstring": "constructs a quarter , based on a date / time and time zone .", "partition": "test"}
{"idx": "6033", "code": "private Util(){\n}\n", "docstring": "this class is never instantiated", "partition": "test"}
{"idx": "6034", "code": "default B withDefault(String key,float value){\n  return withDefault(key,Float.toString(value));\n}\n", "docstring": "if there is no field with the specified key , then associate the given value with the specified key .", "partition": "test"}
{"idx": "6035", "code": "public static boolean readBoolean(final JSONArray jsonArray,final int index,final boolean required,final boolean notNull) throws JSONException {\n  if (required) {\n    return jsonArray.getBoolean(index);\n  }\n  if (notNull && jsonArray.isNull(index)) {\n    throw new JSONException(String.format(Locale.US,NULL_VALUE_FORMAT_ARRAY,index));\n  }\n  boolean value=false;\n  if (!jsonArray.isNull(index)) {\n    value=jsonArray.getBoolean(index);\n  }\n  return value;\n}\n", "docstring": "reads the boolean value from the json array for specified index", "partition": "test"}
{"idx": "6036", "code": "protected static void autoBoxing(MethodVisitor mv,Type fieldType){\nswitch (fieldType.getSort()) {\ncase Type.BOOLEAN:\n    mv.visitMethodInsn(INVOKESTATIC,\"java/lang/Boolean\",\"valueOf\",\"(Z)Ljava/lang/Boolean;\");\n  break;\ncase Type.BYTE:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Byte\",\"valueOf\",\"(B)Ljava/lang/Byte;\");\nbreak;\ncase Type.CHAR:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Character\",\"valueOf\",\"(C)Ljava/lang/Character;\");\nbreak;\ncase Type.SHORT:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Short\",\"valueOf\",\"(S)Ljava/lang/Short;\");\nbreak;\ncase Type.INT:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Integer\",\"valueOf\",\"(I)Ljava/lang/Integer;\");\nbreak;\ncase Type.FLOAT:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Float\",\"valueOf\",\"(F)Ljava/lang/Float;\");\nbreak;\ncase Type.LONG:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Long\",\"valueOf\",\"(J)Ljava/lang/Long;\");\nbreak;\ncase Type.DOUBLE:\nmv.visitMethodInsn(INVOKESTATIC,\"java/lang/Double\",\"valueOf\",\"(D)Ljava/lang/Double;\");\nbreak;\n}\n}\n", "docstring": "append the call of proper autoboxing method for the given primitif type .", "partition": "test"}
{"idx": "6037", "code": "public final void openPdfFile(final byte[] data) throws PdfException {\n  final RandomAccessBuffer pdf_datafile;\n  try {\n    if (PdfFileReader.alwaysCacheInMemory == -1 || data.length < PdfFileReader.alwaysCacheInMemory) {\n      pdf_datafile=new RandomAccessDataBuffer(data);\n    }\n else {\n      try {\n        final File file=File.createTempFile(\"page\",\".bin\",new File(ObjectStore.temp_dir));\n        tempFileName=file.getAbsolutePath();\n        final java.io.FileOutputStream a=new java.io.FileOutputStream(file);\n        a.write(data);\n        a.flush();\n        a.close();\n        pdf_datafile=new RandomAccessFileBuffer(tempFileName,\"r\");\n      }\n catch (      final Exception e) {\n        throw new RuntimeException(\"Unable to create temporary file in \" + ObjectStore.temp_dir + \' \'+ e);\n      }\n    }\n    objectReader.init(pdf_datafile);\n  }\n catch (  final Exception e) {\n    LogWriter.writeLog(\"Exception \" + e + \" accessing file\");\n    throw new PdfException(\"Exception \" + e + \" accessing file\");\n  }\n}\n", "docstring": "open pdf file using a byte stream - by default files under 16384 bytes are cached to disk but this can be altered by setting pdffilereader . alwayscacheinmemory to a maximimum size or - 1 ( always keep in memory )", "partition": "test"}
{"idx": "6038", "code": "public static void main(String[] args){\n  if (args.length < 2) {\n    LOGGER.error(\"There must be at least two arguments\");\n    return;\n  }\n  int lastIndex=args.length - 1;\n  Path[] files=getFiles(args);\n  Main main=new Main();\n  main.generate(files[lastIndex],Arrays.copyOf(files,lastIndex));\n}\n", "docstring": "generate allure report data from directories with allure report results .", "partition": "test"}
{"idx": "6039", "code": "@Nullable E awaitMatch(int start){\n  for (int step=0, totalSpins=0; (step < ARENA_LENGTH) && (totalSpins < SPINS); step++) {\n    int index=(start + step) & ARENA_MASK;\n    AtomicReference<Object> slot=arena[index];\n    Object found=slot.get();\n    if (found == FREE) {\n      if (slot.compareAndSet(FREE,WAITER)) {\n        int slotSpins=0;\n        for (; ; ) {\n          found=slot.get();\n          if ((found != WAITER) && slot.compareAndSet(found,FREE)) {\n            @SuppressWarnings(\"unchecked\") E e=(E)found;\n            return e;\n          }\n else           if ((slotSpins >= SPINS_PER_STEP) && (found == WAITER) && (slot.compareAndSet(WAITER,FREE))) {\n            totalSpins+=slotSpins;\n            break;\n          }\n          slotSpins++;\n        }\n      }\n    }\n else     if ((found != WAITER) && slot.compareAndSet(found,FREE)) {\n      @SuppressWarnings(\"unchecked\") E e=(E)found;\n      return e;\n    }\n  }\n  return null;\n}\n", "docstring": "waits for ( by spinning ) to have an element transfered from another thread . a marker is filled into an empty slot in the arena and spun on until it is replaced with an element or a per - slot spin limit is reached . this search and wait strategy is repeated by selecting another slot until a total spin limit is reached .", "partition": "test"}
{"idx": "6040", "code": "private ArrayList<Signature> constructOneSignatures(SetDBIDs[][] partitions,final long[][] markers){\n  final int dim=partitions.length;\n  ArrayList<Signature> signatures=new ArrayList<>();\n  for (int d=0; d < dim; d++) {\n    final DBIDs[] parts=partitions[d];\n    if (parts == null) {\n      continue;\n    }\n    final long[] marked=markers[d];\n    for (int start=BitsUtil.nextSetBit(marked,0); start >= 0; ) {\n      int end=BitsUtil.nextClearBit(marked,start + 1);\n      end=(end == -1) ? dim : end;\n      int[] signature=new int[dim << 1];\n      Arrays.fill(signature,-1);\n      signature[d << 1]=start;\n      signature[(d << 1) + 1]=end - 1;\n      HashSetModifiableDBIDs sids=unionDBIDs(parts,start,end);\n      if (LOG.isDebugging()) {\n        LOG.debug(\"1-signature: \" + d + \" \"+ start+ \"-\"+ (end - 1));\n      }\n      signatures.add(new Signature(signature,sids));\n      start=(end < dim) ? BitsUtil.nextSetBit(marked,end + 1) : -1;\n    }\n  }\n  return signatures;\n}\n", "docstring": "construct the 1 - signatures by merging adjacent dense bins .", "partition": "test"}
{"idx": "6041", "code": "public static int findEndTrimNewlineChars(CharSequence s){\n  for (int i=s.length(); i > 0; ) {\n    if (s.charAt(i - 1) != '\\n') {\n      return i;\n    }\n    i--;\n    if (i > 0 && s.charAt(i - 1) == '\\r') {\n      i--;\n    }\n  }\n  return 0;\n}\n", "docstring": "finds and returns the end of the given character sequence after trimming new line characters from the right . the following character sequences are treated as newline characters : \" \\ n \" , \" \\ r \\ n \" .", "partition": "test"}
{"idx": "6042", "code": "private void calcCoordinates(final float x,final float[][] Trm,float charSpacing){\n  final float[][] trm=new float[3][3];\n  for (int xx=0; xx < 3; xx++) {\n    System.arraycopy(Trm[xx],0,trm[xx],0,3);\n  }\n  x1=x;\n  x2=trm[2][0] - (charSpacing * trm[0][0]);\n  if (glyphData.isHorizontal()) {\n    if (trm[1][0] < 0) {\n      x1=x + trm[1][0] - (charSpacing * trm[0][0]);\n      x2=trm[2][0];\n    }\n else     if (trm[1][0] > 0) {\n      x1=x;\n      x2=trm[2][0];\n    }\n  }\n else   if (trm[1][0] > 0) {\n    x1=trm[2][0];\n    x2=x + trm[1][0] - (charSpacing * trm[0][0]);\n  }\n else   if (trm[1][0] < 0) {\n    x2=trm[2][0];\n    x1=x + trm[1][0] - (charSpacing * trm[0][0]);\n  }\n}\n", "docstring": "calculate the x coords for text here y coords are calculated in the method processtextarray ( final byte [ ", "partition": "test"}
{"idx": "6043", "code": "public void printEntry(Writer w){\n  try {\n    String indent=\"                      \";\n    int indentWidth=indent.length();\n    HardcopyWriter ww=(HardcopyWriter)w;\n    int textSpace=ww.getCharactersPerLine() - indentWidth - 1;\n    String newLine=\"\\n\";\n    w.write(newLine,0,1);\n    String s=\"   ID:                \" + _id;\n    w.write(s,0,s.length());\n    if (!(_consistNumber.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Consist number:    \" + _consistNumber;\n      w.write(s,0,s.length());\n    }\n    if (!(_roadName.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Road name:         \" + _roadName;\n      w.write(s,0,s.length());\n    }\n    if (!(_roadNumber.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Road number:       \" + _roadNumber;\n      w.write(s,0,s.length());\n    }\n    if (!(_model.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Model:             \" + _model;\n      w.write(s,0,s.length());\n    }\n    if (!(_loco1DccAddress.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Lead Address:      \" + _loco1DccAddress + \"  \"+ _loco1Direction;\n      w.write(s,0,s.length());\n    }\n    if (!(_loco2DccAddress.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Rear Address:      \" + _loco2DccAddress + \"  \"+ _loco2Direction;\n      w.write(s,0,s.length());\n    }\n    if (!(_loco3DccAddress.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Mid1 Address:      \" + _loco3DccAddress + \"  \"+ _loco3Direction;\n      w.write(s,0,s.length());\n    }\n    if (!(_loco4DccAddress.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Mid2 Address:      \" + _loco4DccAddress + \"  \"+ _loco4Direction;\n      w.write(s,0,s.length());\n    }\n    if (!(_loco5DccAddress.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Mid3 Address:      \" + _loco5DccAddress + \"  \"+ _loco5Direction;\n      w.write(s,0,s.length());\n    }\n    if (!(_loco6DccAddress.equals(\"\"))) {\n      w.write(newLine,0,1);\n      s=\"   Mid4 Address:      \" + _loco6DccAddress + \"  \"+ _loco6Direction;\n      w.write(s,0,s.length());\n    }\n    if (!(_comment.equals(\"\"))) {\n      Vector<String> commentVector=wrapComment(_comment,textSpace);\n      int k=0;\n      w.write(newLine,0,1);\n      s=\"   Comment:           \" + commentVector.elementAt(k);\n      w.write(s,0,s.length());\n      k++;\n      while (k < commentVector.size()) {\n        String token=commentVector.elementAt(k);\n        if (!token.equals(\"\\n\")) {\n          s=indent + token;\n        }\n else {\n          s=token;\n        }\n        w.write(s,0,s.length());\n        k++;\n      }\n    }\n    w.write(newLine,0,1);\n  }\n catch (  IOException e) {\n    log.error(\"Error printing ConsistRosterEntry: \" + e);\n  }\n}\n", "docstring": "prints the roster information . updated to allow for multiline comment field . created separate write statements for text and line feeds to work around the hardcopywriter bug that misplaces borders", "partition": "test"}
{"idx": "6044", "code": "protected java.util.Date fromJulian(int julian){\n  YMD ymd=new YMD(julian);\n  GregorianCalendar cal=new GregorianCalendar(ymd.year,ymd.month - 1,ymd.day);\n  return cal.getTime();\n}\n", "docstring": "convert a julian to it \"'\" s java date equivalent .", "partition": "test"}
{"idx": "6045", "code": "public synchronized boolean removeLast(K obj){\n  if (peekLast() != obj) {\n    return false;\n  }\n  array=Arrays.copyOf(array,array.length - 1);\n  return true;\n}\n", "docstring": "remove the last element , if it matches .", "partition": "test"}
{"idx": "6046", "code": "private boolean serializeCompactRDFStructProp(XMPNode node,int indent,boolean hasRDFResourceQual) throws XMPException, IOException {\n  boolean hasAttrFields=false;\n  boolean hasElemFields=false;\n  boolean emitEndTag=true;\n  for (Iterator ic=node.iterateChildren(); ic.hasNext(); ) {\n    XMPNode field=(XMPNode)ic.next();\n    if (canBeRDFAttrProp(field)) {\n      hasAttrFields=true;\n    }\n else {\n      hasElemFields=true;\n    }\n    if (hasAttrFields && hasElemFields) {\n      break;\n    }\n  }\n  if (hasRDFResourceQual && hasElemFields) {\n    throw new XMPException(\"Can\'t mix rdf:resource qualifier and element fields\",XMPError.BADRDF);\n  }\n  if (!node.hasChildren()) {\n    write(\" rdf:parseType=\\\"Resource\\\"/>\");\n    writeNewline();\n    emitEndTag=false;\n  }\n else   if (!hasElemFields) {\n    serializeCompactRDFAttrProps(node,indent + 1);\n    write(\"/>\");\n    writeNewline();\n    emitEndTag=false;\n  }\n else   if (!hasAttrFields) {\n    write(\" rdf:parseType=\\\"Resource\\\">\");\n    writeNewline();\n    serializeCompactRDFElementProps(node,indent + 1);\n  }\n else {\n    write(\'>\');\n    writeNewline();\n    writeIndent(indent + 1);\n    write(RDF_STRUCT_START);\n    serializeCompactRDFAttrProps(node,indent + 2);\n    write(\">\");\n    writeNewline();\n    serializeCompactRDFElementProps(node,indent + 1);\n    writeIndent(indent + 1);\n    write(RDF_STRUCT_END);\n    writeNewline();\n  }\n  return emitEndTag;\n}\n", "docstring": "serializes a struct property .", "partition": "test"}
{"idx": "6047", "code": "public default UtilityTable queryUtil(BNetwork network,String queryVar,Assignment evidence){\n  return queryUtil(new Query.UtilQuery(network,Arrays.asList(queryVar),evidence));\n}\n", "docstring": "computes the utility table for the query variable ( typically an action variable ) , given the provided evidence", "partition": "test"}
{"idx": "6048", "code": "public static float[] stringListToNumeric(List<String> scoreList) throws NumberFormatException {\n  float[] scores=new float[scoreList.size()];\n  int scoreId=0;\n  for (  String score : scoreList) {\n    float floatScore=(float)Double.parseDouble(score);\n    if (Float.isNaN(floatScore)) {\n      throw new NumberFormatException(\"Unparseable number: \" + score);\n    }\n    scores[scoreId++]=floatScore;\n  }\n  return scores;\n}\n", "docstring": "converts a string list of scores to float .", "partition": "test"}
{"idx": "6049", "code": "@Override public void next(){\n  currentImage=Optional.of(addIndexAndGetImageByOffset(+1));\n  eventBus.post(new SourceHasPendingUpdateEvent(this));\n}\n", "docstring": "assigns the output socket to the next image . ( wraps around )", "partition": "test"}
{"idx": "6050", "code": "protected void parse(DataInputStream stream) throws Exception {\n  int size=stream.readInt();\n  int ret, read=0;\n  data=new byte[size];\n  while (size > 0) {\n    ret=stream.read(data,read,size);\n    size-=ret;\n    read+=ret;\n  }\n}\n", "docstring": "loading method . ( see nbt_tag )", "partition": "test"}
{"idx": "6051", "code": "private List<Activity> findBestInsertion(List<Activity> partialRoute,boolean allowAsMajor){\n  int startIndex=1;\n  int endIndex=partialRoute.size() - 1;\n  if (allowAsMajor) {\n    startIndex=0;\n    endIndex=partialRoute.size();\n  }\n  List<Activity> newList=partialRoute;\n  double best=Double.POSITIVE_INFINITY;\n  List<Activity> bestList=null;\n  for (int i=startIndex; i <= endIndex; i++) {\n    List<Activity> tmpList=new ArrayList<>(newList);\n    Activity tmpActivity=getRelocationActivity();\n    tmpList.add(i,tmpActivity);\n    double tmp=evaluateList(tmpList);\n    if (tmp < best) {\n      if (i == 0) {\n        tmpActivity.setType(\"major\");\n        tmpActivity.setEndTime(Time.parseTime(\"08:00:00\"));\n      }\n else       if (i == partialRoute.size()) {\n        tmpActivity.setType(\"major\");\n      }\n else {\n        tmpActivity.setType(\"minor\");\n        tmpActivity.setMaximumDuration(Time.parseTime(\"00:20:00\"));\n      }\n      best=tmp;\n      bestList=tmpList;\n    }\n  }\n  return bestList;\n}\n", "docstring": "find the best insertion position for a relocated activity in a given list of current activities .", "partition": "test"}
{"idx": "6052", "code": "public void writeShort(int value) throws IOException {\n  checkWritePrimitiveTypes();\n  primitiveTypes.writeShort(value);\n}\n", "docstring": "writes a short ( 16 bit ) to the target stream .", "partition": "test"}
{"idx": "6053", "code": "private boolean isInitialized(){\n  return poolNames != null && !poolNames.isEmpty();\n}\n", "docstring": "checks if is initialized .", "partition": "test"}
{"idx": "6054", "code": "public void onRegisterClick(View view){\n  Intent register=new Intent(Intent.ACTION_VIEW,Uri.parse(getString(R.string.welcome_link_url)));\n  setResult(RESULT_CANCELED);\n  startActivity(register);\n}\n", "docstring": "starts and activity to open the \"'\" new account \"'\" page in the owncloud web site", "partition": "test"}
{"idx": "6055", "code": "private void registerExtraValidSubject(String subject){\n  extraValidSubjects.add(subject);\n  restoredStatements.addAll(unknownSubjects.removeAll(subject));\n}\n", "docstring": "register an extra valid subject . these subjects are ok if we hit them .", "partition": "test"}
{"idx": "6056", "code": "public static String trimLine(String line){\n  int idx=line.indexOf(\"//\");\n  if (idx != -1) {\n    line=line.substring(0,idx);\n  }\n  return line.trim();\n}\n", "docstring": "trims a line and removes comments", "partition": "test"}
{"idx": "6057", "code": "public double distance2(double p1,double p2){\n  return (p1 - p2) * (p1 - p2);\n}\n", "docstring": "calculates the square of the euclidean distance between two 1d points represented by real values .", "partition": "test"}
{"idx": "6058", "code": "public Iterator<T> iterator(){\n  return orderList.iterator();\n}\n", "docstring": "non - thread safe iterator . removing is not allowed .", "partition": "test"}
{"idx": "6059", "code": "private void verifyDomainsIsNotInUse(StringSet domains){\n  checkForActiveTenantsUsingDomains(domains);\n  checkForVdcRolesUsingDomains(domains);\n  checkForTenantRolesUsingDomains(domains);\n  checkForUserGroupsUsingDomains(domains);\n}\n", "docstring": "check if given domains are in use or not , if any of them is in use , throw exception .", "partition": "test"}
{"idx": "6060", "code": "private Hashtable<IPoint,List<ICircle>> filter(Hashtable<IPoint,ICircle[]> circleIntersections){\n  Hashtable<IPoint,List<ICircle>> real=new Hashtable<IPoint,List<ICircle>>();\n  for (  IPoint pt : circleIntersections.keySet()) {\n    ICircle[] circs=circleIntersections.get(pt);\n    for (int i=0; i < circs.length - 1; i++) {\n      for (int j=i + 1; j < circs.length; j++) {\n        IPoint[] pts=intersects(circs[i],circs[j]);\n        if (pts != null) {\n          for (          IPoint p : pts) {\n            report(real,p,circs[i],circs[j]);\n          }\n        }\n      }\n    }\n  }\n  return real;\n}\n", "docstring": "this method implements the algebraic intersection detection method to determine whether the circles are actually intersecting . some false positives may occur , and thus must be filtered out .", "partition": "test"}
{"idx": "6061", "code": "public void initWithoutJUnitForFixture(Class fixture,Method method){\n  this.testClass=fixture;\n  this.testMethodName=method.getName();\n}\n", "docstring": "initializes matsimtestutils without requiring the method of a class to be a junit test . this should be used for \" fixtures \" only that provide a scenario common to several test cases .", "partition": "test"}
{"idx": "6062", "code": "protected JavaType findSerializationType(Annotated a,boolean useStaticTyping,JavaType declaredType){\n  Class<?> serClass=_annotationIntrospector.findSerializationType(a);\n  if (serClass != null) {\n    Class<?> rawDeclared=declaredType.getRawClass();\n    if (serClass.isAssignableFrom(rawDeclared)) {\n      declaredType=declaredType.widenBy(serClass);\n    }\n else {\n      if (!rawDeclared.isAssignableFrom(serClass)) {\n        throw new IllegalArgumentException(\"Illegal concrete-type annotation for method \'\" + a.getName() + \"\': class \"+ serClass.getName()+ \" not a super-type of (declared) class \"+ rawDeclared.getName());\n      }\n      declaredType=_config.constructSpecializedType(declaredType,serClass);\n    }\n    useStaticTyping=true;\n  }\n  JavaType secondary=BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config,a,declaredType);\n  if (secondary != declaredType) {\n    useStaticTyping=true;\n    declaredType=secondary;\n  }\n  if (!useStaticTyping) {\n    JsonSerialize.Typing typing=_annotationIntrospector.findSerializationTyping(a);\n    if (typing != null) {\n      useStaticTyping=(typing == JsonSerialize.Typing.STATIC);\n    }\n  }\n  return useStaticTyping ? declaredType : null;\n}\n", "docstring": "method that will try to determine statically defined type of property being serialized , based on annotations ( for overrides ) , and alternatively declared type ( if static typing for serialization is enabled ) . if neither can be used ( no annotations , dynamic typing ) , returns null .", "partition": "test"}
{"idx": "6063", "code": "private static void convert(AScene scene,InputStream in,OutputStream out) throws IOException, DefException, ParseException {\n  IndexUnit iu=JavaParser.parse(in);\n  extractScene(iu,scene);\n  try (Writer w=new BufferedWriter(new OutputStreamWriter(out))){\n    IndexFileWriter.write(scene,w);\n  }\n }\n", "docstring": "augment given scene with information from stubfile , reading stubs from input stream and writing jaif to output stream .", "partition": "test"}
{"idx": "6064", "code": "public static void load(marytts.modules.synthesis.Voice maryVoice) throws NoSuchPropertyException {\n  if (mary2freettsVoices == null)   mary2freettsVoices=new HashMap<marytts.modules.synthesis.Voice,com.sun.speech.freetts.Voice>();\n  if (freetts2maryVoices == null)   freetts2maryVoices=new HashMap<com.sun.speech.freetts.Voice,marytts.modules.synthesis.Voice>();\n  if (mary2freettsVoices.containsKey(maryVoice))   return;\n  load(maryVoice,createFreeTTSVoice(maryVoice));\n}\n", "docstring": "add a freetts voice for a given mary voice . this is used by load ( ) , but can also be called separately . repeated registration of the same voice will be ignored , so it is safe to call this several times with the same maryvoice . this depends on the mary property \" freetts . lexicon . preload \" setting - - if that results to false , nothing will be loaded ; if the setting is missing , a nosuchpropertyexception will be thrown .", "partition": "test"}
{"idx": "6065", "code": "public void append(int key,double value){\n  if (mSize != 0 && key <= mKeys[mSize - 1]) {\n    put(key,value);\n    return;\n  }\n  int pos=mSize;\n  if (pos >= mKeys.length) {\n    int n=ArrayUtils.idealIntArraySize(pos + 1);\n    int[] nkeys=new int[n];\n    double[] nvalues=new double[n];\n    System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n    System.arraycopy(mValues,0,nvalues,0,mValues.length);\n    mKeys=nkeys;\n    mValues=nvalues;\n  }\n  mKeys[pos]=key;\n  mValues[pos]=value;\n  mSize=pos + 1;\n}\n", "docstring": "puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .", "partition": "test"}
{"idx": "6066", "code": "public synchronized void addIncrementalClassifierListener(IncrementalClassifierListener cl){\n  m_incrementalClassifierListeners.add(cl);\n}\n", "docstring": "add an incremental classifier listener", "partition": "test"}
{"idx": "6067", "code": "public float readR4() throws java.io.IOException {\n  return Float.intBitsToFloat((int)readDWORD());\n}\n", "docstring": "reads an r4 from the file and returns it in a float . advances the file pointer by 4 .", "partition": "test"}
{"idx": "6068", "code": "public static boolean filesExistOnDestButNotSrc(Configuration conf,Path src,Path dest,Optional<PathFilter> filter) throws IOException {\n  Set<FileStatus> srcFileStatuses=getFileStatusesRecursive(conf,src,filter);\n  Set<FileStatus> destFileStatuses=getFileStatusesRecursive(conf,dest,filter);\n  Map<String,Long> srcFileSizes=null;\n  Map<String,Long> destFileSizes=null;\n  try {\n    srcFileSizes=getRelPathToSizes(src,srcFileStatuses);\n    destFileSizes=getRelPathToSizes(dest,destFileStatuses);\n  }\n catch (  ArgumentException e) {\n    throw new IOException(\"Invalid file statuses!\",e);\n  }\n  for (  String file : destFileSizes.keySet()) {\n    if (!srcFileSizes.containsKey(file)) {\n      LOG.warn(String.format(\"%s exists on %s but not in %s\",file,dest,src));\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "checks to see if filenames exist on a destination directory that don \"'\" t exist in the source directory . mainly used for checking if a distcp - update can work .", "partition": "test"}
{"idx": "6069", "code": "protected void convertOrder(SqlSelect select,Blackboard bb,RelCollation collation,List<SqlNode> orderExprList,SqlNode offset,SqlNode fetch){\n  if (select.getOrderList() == null || select.getOrderList().getList().isEmpty()) {\n    assert collation.getFieldCollations().isEmpty();\n    if ((offset == null || ((SqlLiteral)offset).bigDecimalValue().equals(BigDecimal.ZERO)) && fetch == null) {\n      return;\n    }\n  }\n  bb.setRoot(LogicalSort.create(bb.root,collation,offset == null ? null : convertExpression(offset),fetch == null ? null : convertExpression(fetch)),false);\n  if (orderExprList.size() > 0 && !bb.top) {\n    final List<RexNode> exprs=new ArrayList<>();\n    final RelDataType rowType=bb.root.getRowType();\n    final int fieldCount=rowType.getFieldCount() - orderExprList.size();\n    for (int i=0; i < fieldCount; i++) {\n      exprs.add(rexBuilder.makeInputRef(bb.root,i));\n    }\n    bb.setRoot(LogicalProject.create(bb.root,exprs,rowType.getFieldNames().subList(0,fieldCount)),false);\n  }\n}\n", "docstring": "converts a query \"'\" s order by clause , if any .", "partition": "test"}
{"idx": "6070", "code": "public void tickBlock(BlockPos pos){\n  List<BlockPos> validCoords=new ArrayList<>();\n  for (int xOffset=-TICK_RANGE; xOffset <= TICK_RANGE; xOffset++) {\n    for (int zOffset=-TICK_RANGE; zOffset <= TICK_RANGE; zOffset++) {\n      if (xOffset == 0 && zOffset == 0)       continue;\n      if (isValidSwapPosition(pos.add(xOffset,0,zOffset)))       validCoords.add(pos.add(xOffset,0,zOffset));\n    }\n  }\n  if (!validCoords.isEmpty() && !world.isRemote) {\n    BlockPos toSwap=validCoords.get(rand.nextInt(validCoords.size()));\n    world.setBlockState(toSwap,stateToSet,1 | 2);\n  }\n}\n", "docstring": "tick a specific block position , finding the valid blocks immediately adjacent to it and then replacing one at random .", "partition": "test"}
{"idx": "6071", "code": "private void configureMessageLabel(JLabel label){\n  Color color=(Color)DefaultLookup.get(optionPane,this,\"OptionPane.messageForeground\");\n  if (color != null) {\n    label.setForeground(color);\n  }\n  Font messageFont=(Font)DefaultLookup.get(optionPane,this,\"OptionPane.messageFont\");\n  if (messageFont != null) {\n    label.setFont(messageFont);\n  }\n}\n", "docstring": "configures any necessary colors / fonts for the specified label used representing the message .", "partition": "test"}
{"idx": "6072", "code": "default Filterable<T> removeAll(final Stream<? extends T> stream){\n  final Set<T> set=stream.collect(Collectors.toSet());\n  return filterNot(null);\n}\n", "docstring": "remove all elements in the supplied stream from this filterable", "partition": "test"}
{"idx": "6073", "code": "public void drawLine(List<mxPoint> pts,Map<String,Object> style){\n  Color penColor=mxUtils.getStyleStrokeColor(style,Color.BLACK);\n  float penWidth=mxUtils.getStyleStrokeWidth(style,(float)1);\n  if (penColor != null && penWidth > 0) {\n    String shape=mxUtils.getString(style,mxConstants.STYLE_SHAPE,\"\");\n    if (shape.equals(mxConstants.SHAPE_ARROW)) {\n      setStroke(penWidth,style);\n      mxPoint p0=pts.get(0);\n      mxPoint pe=pts.get(pts.size() - 1);\n      Rectangle bounds=new Rectangle(p0.getPoint());\n      bounds.add(pe.getPoint());\n      Color fillColor=mxUtils.getStyleFillColor(style);\n      Paint fillPaint=getFillPaint(bounds,fillColor,style);\n      boolean shadow=mxUtils.isTrue(style,mxConstants.STYLE_SHADOW,false);\n      drawArrow(pts,fillColor,fillPaint,penColor,shadow);\n    }\n else {\n      Object startMarker=style.get(mxConstants.STYLE_STARTARROW);\n      Object endMarker=style.get(mxConstants.STYLE_ENDARROW);\n      float startSize=(float)(mxUtils.getFloat(style,mxConstants.STYLE_STARTSIZE,mxConstants.DEFAULT_MARKERSIZE));\n      float endSize=(float)(mxUtils.getFloat(style,mxConstants.STYLE_ENDSIZE,mxConstants.DEFAULT_MARKERSIZE));\n      boolean rounded=mxUtils.isTrue(style,mxConstants.STYLE_ROUNDED,false);\n      drawConnector(pts,penWidth,penColor,startMarker,startSize,endMarker,endSize,rounded,style);\n    }\n  }\n}\n", "docstring": "draws the given lines as segments between all points of the given list of mxpoints .", "partition": "test"}
{"idx": "6074", "code": "private static MeteringRectangle[] regionsForNormalizedCoord(float nx,float ny,float fraction,final Rect cropRegion,int sensorOrientation){\n  int minCropEdge=Math.min(cropRegion.width(),cropRegion.height());\n  int halfSideLength=(int)(0.5f * fraction * minCropEdge);\n  PointF nsc=CameraUtil.normalizedSensorCoordsForNormalizedDisplayCoords(nx,ny,sensorOrientation);\n  int xCenterSensor=(int)(cropRegion.left + nsc.x * cropRegion.width());\n  int yCenterSensor=(int)(cropRegion.top + nsc.y * cropRegion.height());\n  Rect meteringRegion=new Rect(xCenterSensor - halfSideLength,yCenterSensor - halfSideLength,xCenterSensor + halfSideLength,yCenterSensor + halfSideLength);\n  meteringRegion.left=CameraUtil.clamp(meteringRegion.left,cropRegion.left,cropRegion.right);\n  meteringRegion.top=CameraUtil.clamp(meteringRegion.top,cropRegion.top,cropRegion.bottom);\n  meteringRegion.right=CameraUtil.clamp(meteringRegion.right,cropRegion.left,cropRegion.right);\n  meteringRegion.bottom=CameraUtil.clamp(meteringRegion.bottom,cropRegion.top,cropRegion.bottom);\n  return new MeteringRectangle[]{new MeteringRectangle(meteringRegion,CAMERA2_REGION_WEIGHT)};\n}\n", "docstring": "compute 3a regions for a sensor - referenced touch coordinate . returns a meteringrectangle [ ", "partition": "test"}
{"idx": "6075", "code": "@Override public void flush() throws IOException {\n  flushBuffer();\n  _outputStream.flush();\n}\n", "docstring": "flushes the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .", "partition": "test"}
{"idx": "6076", "code": "public Vector(double comp[]) throws NegativeArraySizeException {\n  int n=comp.length;\n  if (n <= 0)   throw new NegativeArraySizeException(\"Vector components cannot be empty\");\n  components=new double[n];\n  System.arraycopy(comp,0,components,0,n);\n}\n", "docstring": "create a vector of given dimension . note : the supplied array of components must not be changed .", "partition": "test"}
{"idx": "6077", "code": "public long lonToPixel(double lon){\n  return (long)((lon + 180) / 360 * Math.pow(2,zoom) * 256);\n}\n", "docstring": "convert longitude to pixel value", "partition": "test"}
{"idx": "6078", "code": "public static boolean worldFileValuesAppearGeographic(AVList values){\n  double xLocation;\n  double yLocation;\n  double xPixelSize;\n  double yPixelSize;\n  Object o=values.getValue(WORLD_FILE_X_LOCATION);\n  if (o != null && o instanceof Double)   xLocation=(Double)o;\n else   return false;\n  o=values.getValue(WORLD_FILE_Y_LOCATION);\n  if (o != null && o instanceof Double)   yLocation=(Double)o;\n else   return false;\n  o=values.getValue(WORLD_FILE_X_PIXEL_SIZE);\n  if (o != null && o instanceof Double)   xPixelSize=(Double)o;\n else   return false;\n  o=values.getValue(WORLD_FILE_Y_PIXEL_SIZE);\n  if (o != null && o instanceof Double)   yPixelSize=(Double)o;\n else   return false;\n  return (Angle.isValidLongitude(xPixelSize) && Angle.isValidLatitude(yPixelSize) && Angle.isValidLongitude(xLocation)&& Angle.isValidLatitude(yLocation));\n}\n", "docstring": "indicates whether world file values appear to be in latitude and longitude .", "partition": "test"}
{"idx": "6079", "code": "public void storeInRegister(int registerNumber) throws IOException {\n  print(\"register\",new String[]{Integer.toString(registerNumber)});\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "6080", "code": "public void remove(SessionID sessionID){\n  remoteSessionSet.remove(sessionID);\n}\n", "docstring": "remove a remote session .", "partition": "test"}
{"idx": "6081", "code": "public Iterator<AbstractPage> childIterator(final boolean dirtyNodesOnly){\n  if (dirtyNodesOnly) {\n    return new DirtyChildIterator(this);\n  }\n else {\n    return new ChildIterator();\n  }\n}\n", "docstring": "iterator visits the direct child nodes in the external key ordering .", "partition": "test"}
{"idx": "6082", "code": "public HMACT64(byte[] key){\n  super(\"HMACT64\");\n  int length=Math.min(key.length,BLOCK_LENGTH);\n  for (int i=0; i < length; i++) {\n    ipad[i]=(byte)(key[i] ^ IPAD);\n    opad[i]=(byte)(key[i] ^ OPAD);\n  }\n  for (int i=length; i < BLOCK_LENGTH; i++) {\n    ipad[i]=IPAD;\n    opad[i]=OPAD;\n  }\n  try {\n    md5=MessageDigest.getInstance(\"MD5\");\n  }\n catch (  Exception ex) {\n    throw new IllegalStateException(ex.getMessage());\n  }\n  engineReset();\n}\n", "docstring": "creates an hmact64 instance which uses the given secret key material .", "partition": "test"}
{"idx": "6083", "code": "public boolean startsWith(String string){\n  if (string == null)   return false;\n  int strlen=string.length();\n  if (_length < strlen)   return false;\n  char[] buffer=_buffer;\n  int offset=_offset;\n  while (--strlen >= 0) {\n    if (buffer[offset + strlen] != string.charAt(strlen))     return false;\n  }\n  return true;\n}\n", "docstring": "returns true if the charsegment starts with the string .", "partition": "test"}
{"idx": "6084", "code": "private void writeRawBytesInternal(final ByteBuffer value) throws IOException {\n  int length=value.remaining();\n  if (limit - position >= length) {\n    value.get(buffer,position,length);\n    position+=length;\n    totalBytesWritten+=length;\n  }\n else {\n    final int bytesWritten=limit - position;\n    value.get(buffer,position,bytesWritten);\n    length-=bytesWritten;\n    position=limit;\n    totalBytesWritten+=bytesWritten;\n    refreshBuffer();\n    while (length > limit) {\n      value.get(buffer,0,limit);\n      output.write(buffer,0,limit);\n      length-=limit;\n      totalBytesWritten+=limit;\n    }\n    value.get(buffer,0,length);\n    position=length;\n    totalBytesWritten+=length;\n  }\n}\n", "docstring": "write a bytebuffer that isn \"'\" t backed by an array .", "partition": "test"}
{"idx": "6085", "code": "public boolean isSrcClass(SootClass clz){\n  return srcClasses.contains(clz.getName());\n}\n", "docstring": "return true if the class was loaded from the application src / directory .", "partition": "test"}
{"idx": "6086", "code": "private void processLDIF(Connection conn,String path) throws UpgradeException {\n  ChangeRecordReader reader=null;\n  try {\n    if (DEBUG.messageEnabled()) {\n      DEBUG.message(\"Processing LDIF file under \" + path);\n    }\n    Map<String,String> tags=new HashMap<String,String>(2);\n    tags.put(\"@SM_CONFIG_ROOT_SUFFIX@\",baseDN);\n    tags.put(\"@DB_NAME@\",\"userRoot\");\n    String content=AMSetupServlet.readFile(path);\n    String tagSwapped=StringUtils.tagSwap(content,tags);\n    reader=new LDIFChangeRecordReader(new ByteArrayInputStream(tagSwapped.getBytes(Charset.forName(\"UTF-8\"))));\n    ChangeRecordWriter writer=new ConnectionChangeRecordWriter(conn);\n    while (reader.hasNext()) {\n      writer.writeChangeRecord(reader.readChangeRecord());\n    }\n  }\n catch (  IOException ioe) {\n    DEBUG.error(\"An error occurred while processing \" + path,ioe);\n    throw new UpgradeException(ioe);\n  }\n finally {\n    IOUtils.closeIfNotNull(reader);\n  }\n}\n", "docstring": "reads in the ldif file , and writes the changerecords on the ldap connection .", "partition": "test"}
{"idx": "6087", "code": "private void printProgress(long row,long rowFrom,long rowTill){\n  long rowsProcessed=row + chunkSize - rowFrom;\n  if (rowsProcessed > (rowTill - rowFrom))   rowsProcessed=(rowTill - rowFrom);\n  print(String.format(\"%d%%\",(int)(((double)(rowsProcessed) / (double)(rowTill - rowFrom)) * 100.0f)));\n}\n", "docstring": "render ( print ) progress bar .", "partition": "test"}
{"idx": "6088", "code": "void postRemoteReleaseLock(Object objectName) throws InterruptedException {\n  if (!acquireDestroyReadLock(0)) {\n    return;\n  }\n  try {\n    checkDestroyed();\n    drainPermittedRequests();\n    grantLock(objectName);\n  }\n catch (  LockServiceDestroyedException e) {\n  }\ncatch (  LockGrantorDestroyedException e) {\n  }\n finally {\n    releaseDestroyReadLock();\n  }\n}\n", "docstring": "drain currently permitted requests and grant lock to next requestor . < p > acquires destroyreadlock . synchronizes on suspendlock , granttokens , and the grant token .", "partition": "test"}
{"idx": "6089", "code": "public final ArrayList<PositionRecord> loadPositions(final int session,final Double minLat,final Double maxLat,final Double minLon,final Double maxLon){\n  final ArrayList<PositionRecord> positions=new ArrayList<>();\n  String selection=Schema.COL_SESSION_ID + \" = ?\";\n  Cursor cursor=null;\n  List<String> selectionArgs=null;\n  if (minLat != null & maxLat != null && minLon != null && maxLon != null) {\n    selectionArgs=new ArrayList<>();\n    selectionArgs.add(String.valueOf(session));\n    selectionArgs.add(String.valueOf(minLat));\n    selectionArgs.add(String.valueOf(maxLat));\n    selectionArgs.add(String.valueOf(minLon));\n    selectionArgs.add(String.valueOf(maxLon));\n    selection+=\"AND (\" + Schema.COL_LATITUDE + \" > ? AND \"+ Schema.COL_LATITUDE+ \" < ?) AND (\"+ Schema.COL_LONGITUDE+ \" > ? AND \"+ Schema.COL_LONGITUDE+ \" < ?)\";\n    cursor=contentResolver.query(ContentProvider.CONTENT_URI_POSITION,null,selection,selectionArgs.toArray(new String[0]),Schema.COL_TIMESTAMP);\n  }\n else {\n    Log.v(TAG,\"No boundaries provided, loading all positions\");\n    cursor=contentResolver.query(ContentProvider.CONTENT_URI_POSITION,null,null,null,Schema.COL_TIMESTAMP);\n  }\n  while (cursor.moveToNext()) {\n    positions.add(positionFromCursor(cursor));\n  }\n  cursor.close();\n  return positions;\n}\n", "docstring": "loads positions within certain arrea", "partition": "test"}
{"idx": "6090", "code": "public static CheckBox createToggle(String text,Image icon){\n  CheckBox cb=new CheckBox(text,icon);\n  cb.setToggle(true);\n  return cb;\n}\n", "docstring": "shorthand for creating the check box setting the icon / text and making it into a toggle button", "partition": "test"}
{"idx": "6091", "code": "public long addCompletedBatch(RequestBatch requestBatch){\n  long completedBatchId=insertBatchAsCompleted(requestBatch);\n  for (  Request request : requestBatch.getRequests()) {\n    request.setBatchId(completedBatchId);\n    File file=new File(request.getDestinationPath());\n    long length=file.exists() ? file.length() : 0;\n    insertRequestAsCompletedDownload(request.getDestinationPath(),length,request);\n  }\n  return completedBatchId;\n}\n", "docstring": "adds this batch to the downloads system .", "partition": "test"}
{"idx": "6092", "code": "public static DefaultJobDefinition retryableFixedDelayJobDefinition(final String jobType,final String jobName,final String description,final Duration fixedDelay,final int restarts,final int retries,final Optional<Duration> retryDelay,final Optional<Duration> maxAge){\n  return new DefaultJobDefinition(jobType,jobName,description,maxAge,Optional.of(fixedDelay),Optional.empty(),restarts,retries,retryDelay);\n}\n", "docstring": "create a jobdefinition that is using fixed delays specify , when and how often the job should be triggered .", "partition": "test"}
{"idx": "6093", "code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return MESSAGE;\ndefault :\n  return null;\n}\n}\n", "docstring": "find the _fields constant that matches fieldid , or null if its not found .", "partition": "test"}
{"idx": "6094", "code": "public static void putLong(long addr,long val){\n  if (UNALIGNED)   UNSAFE.putLong(addr,val);\n else   putLongByByte(addr,val,BIG_ENDIAN);\n}\n", "docstring": "stores given integer value . alignment aware .", "partition": "test"}
{"idx": "6095", "code": "public static File createMinimalSplit(String inputFolder,int numFolds,int numAvailableJCas,boolean isSequence) throws Exception {\n  File outputFolder=new File(inputFolder,\"output\");\n  int splitNum=(int)Math.ceil(numFolds / (double)numAvailableJCas);\n  CollectionReaderDescription createReader=CollectionReaderFactory.createReaderDescription(BinaryCasReader.class,BinaryCasReader.PARAM_SOURCE_LOCATION,inputFolder,BinaryCasReader.PARAM_PATTERNS,\"*.bin\");\n  AnalysisEngineDescription multiplier=AnalysisEngineFactory.createEngineDescription(FoldClassificationUnitCasMultiplier.class,FoldClassificationUnitCasMultiplier.PARAM_REQUESTED_SPLITS,splitNum,FoldClassificationUnitCasMultiplier.PARAM_USE_SEQUENCES,isSequence);\n  AnalysisEngineDescription xmiWriter=AnalysisEngineFactory.createEngineDescription(BinaryCasWriter.class,BinaryCasWriter.PARAM_TARGET_LOCATION,outputFolder.getAbsolutePath(),BinaryCasWriter.PARAM_FORMAT,\"6+\");\n  AnalysisEngineDescription both=AnalysisEngineFactory.createEngineDescription(multiplier,xmiWriter);\n  SimplePipeline.runPipeline(createReader,both);\n  isNumberOfCasCreatedLargerEqualNumFolds(outputFolder,numFolds);\n  return outputFolder;\n}\n", "docstring": "takes the available cas and creates more cases from them to conform to the minimal requested amount of cas objects to have sufficient for running a cross - validation . computes a rule - of - thumb value to split each of the found cas into n sub - cases and the end the total created number is compared to the requested number of cas and an exception thrown if too few cas were created .", "partition": "test"}
{"idx": "6096", "code": "public org.w3c.dom.Element signXML(org.w3c.dom.Document doc,java.lang.String certAlias) throws XMLSignatureException {\n  return signXML(doc,certAlias,null);\n}\n", "docstring": "sign the xml document using enveloped signatures .", "partition": "test"}
{"idx": "6097", "code": "public boolean displayPopup(){\n  if (m_popupClass == null)   return false;\n  try {\n    Window win=SwingUtilities.getWindowAncestor(this);\n    CFieldPopup popup=null;\n    if (win instanceof Dialog) {\n      Constructor<?> constructor=m_popupClass.getConstructor(new Class<?>[]{Dialog.class,String.class,Boolean.class});\n      popup=(CFieldPopup)constructor.newInstance(new Object[]{(Dialog)win,m_title,new Boolean(true)});\n    }\n else     if (win instanceof Frame) {\n      Constructor<?> constructor=m_popupClass.getConstructor(new Class[]{Frame.class,String.class,Boolean.class});\n      popup=(CFieldPopup)constructor.newInstance(new Object[]{(Frame)win,m_title,new Boolean(true)});\n    }\n    if (popup == null)     return false;\n    popup.setValue(m_editor.getItem());\n    popup.setFormat(m_editor.getFormat());\n    popup.show();\n    m_editor.setItem(popup.getValue());\n    popup=null;\n  }\n catch (  Exception e) {\n    notifyUser(e);\n  }\n  return false;\n}\n", "docstring": "display popup . called from adempierecombopopup and allows to implement alternative actions than showing the popup", "partition": "test"}
{"idx": "6098", "code": "public AbstractSdfWriter(final PrereadType prereadType,final boolean hasQuality,boolean hasNames,boolean compressed,final SequenceType type){\n  mPrereadType=prereadType;\n  mPrereadArm=PrereadArm.UNKNOWN;\n  mSdfId=new SdfId();\n  mNameHandler=new SequenceNameHandler();\n  mSequenceType=type;\n  mFirstValid=mSequenceType.firstValid();\n  mResidueCounts=new long[mSequenceType.numberKnownCodes() + mSequenceType.firstValid()];\n  mNHistogram=new long[MAX_HISTOGRAM];\n  mPosHistogram=new long[MAX_HISTOGRAM];\n  mQSAveragePerPos=new double[MAX_HISTOGRAM];\n  mPositionCounts=new long[MAX_HISTOGRAM];\n  mGlobalQSAverage=0.0;\n  mDataHashFunction=new PrereadHashFunction();\n  mQualityHashFunction=new PrereadHashFunction();\n  mNameHashFunction=new PrereadHashFunction();\n  mNameSuffixHashFunction=new PrereadHashFunction();\n  mHasQuality=hasQuality;\n  mHasNames=hasNames;\n  mCompressed=compressed;\n  mSeqDataChecksum=new CRC32();\n  mQualDataChecksum=new CRC32();\n}\n", "docstring": "creates a writer for processing sequences from provided data source .", "partition": "test"}
{"idx": "6099", "code": "FiringPlan guessBestFiringPlanUnderHeat(Entity shooter,@Nullable EntityState shooterState,Targetable target,@Nullable EntityState targetState,int maxHeat,IGame game){\n  if (maxHeat < 0) {\n    maxHeat=0;\n  }\n  FiringPlan alphaStrike=guessFullFiringPlan(shooter,shooterState,target,targetState,game);\n  if (alphaStrike.getHeat() <= maxHeat && !(shooter instanceof Infantry) && !(shooter instanceof BattleArmor)) {\n    return alphaStrike;\n  }\n  FiringPlan heatPlans[]=calcFiringPlansUnderHeat(shooter,alphaStrike);\n  Arrays.sort(heatPlans);\n  if (heatPlans.length > 0) {\n    return heatPlans[0];\n  }\n else {\n    return new FiringPlan(target);\n  }\n}\n", "docstring": "guesses the \"'\" best \"'\" firing plan under a certain heat no twisting is done", "partition": "test"}
{"idx": "6100", "code": "public static VolumeGroupRestRep map(VolumeGroup from){\n  if (from == null) {\n    return null;\n  }\n  VolumeGroupRestRep rep=new VolumeGroupRestRep();\n  mapDataObjectFields(from,rep);\n  rep.setDescription(from.getDescription());\n  rep.setRoles(from.getRoles());\n  rep.setParent(toRelatedResource(ResourceTypeEnum.VOLUME_GROUP,from.getParent()));\n  rep.setMigrationGroupBy(from.getMigrationGroupBy());\n  rep.setMigrationType(from.getMigrationType());\n  return rep;\n}\n", "docstring": "map an volumegroup to volumegrouprestrep", "partition": "test"}
{"idx": "6101", "code": "public void addActionListener(ActionListener newListener){\n  m_listeners.add(newListener);\n}\n", "docstring": "register a listener to be notified when plotting completes", "partition": "test"}
{"idx": "6102", "code": "@Deprecated public ShapelessRecipe addIngredient(int count,Material ingredient,int rawdata){\n  Validate.isTrue(ingredients.size() + count <= 9,\"Shapeless recipes cannot have more than 9 ingredients\");\n  if (rawdata == -1) {\n    rawdata=Short.MAX_VALUE;\n  }\n  while (count-- > 0) {\n    ingredients.add(new ItemStack(ingredient,1,(short)rawdata));\n  }\n  return this;\n}\n", "docstring": "adds multiples of the specified ingredient .", "partition": "test"}
{"idx": "6103", "code": "public String order(){\n  return mOrderBy.length() > 0 ? mOrderBy.toString() : null;\n}\n", "docstring": "returns the order string produced by this object .", "partition": "test"}
{"idx": "6104", "code": "public static byte[] encodingToBytes(final String str,final String encoding){\n  if (str == null) {\n    return null;\n  }\n  try {\n    return str.getBytes(encoding);\n  }\n catch (  final UnsupportedEncodingException e) {\n    throw new Error(encoding + \" not supported! Original exception: \" + e);\n  }\n}\n", "docstring": "convert a string to a byte array using the specified encoding .", "partition": "test"}
{"idx": "6105", "code": "public static boolean looksLikeABGRepeat(String val){\n  return BACKGROUND_REPEATS.indexOf(val) >= 0;\n}\n", "docstring": "description of the method", "partition": "test"}
{"idx": "6106", "code": "public void before() throws Throwable {\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n    ProcessBuilder processBuilder=new ProcessBuilder();\n    processBuilder.command(\"logcat\",\"-c\");\n    processBuilder.redirectErrorStream();\n    Process process=processBuilder.start();\n    process.waitFor();\n    if (process.exitValue() != 0) {\n      Log.e(LOG_TAG,\"Error while clearing logcat, exitValue=\" + process.exitValue());\n    }\n  }\n}\n", "docstring": "clear logcat buffer prior to test run .", "partition": "test"}
{"idx": "6107", "code": "public void addMeta(char meta,String replacement){\n  metaCharacterSet.set(meta);\n  replacementMap.put(new String(new char[]{meta}),replacement);\n}\n", "docstring": "add a metacharacter and its replacement .", "partition": "test"}
{"idx": "6108", "code": "private Matches lookupDo(Template tmpl,int maxMatches){\n  if (maxMatches < 0)   throw new IllegalArgumentException(\"negative maxMatches\");\n  int totalMatches=0;\n  ArrayList matches=null;\n  ItemIter iter=matchingItems(tmpl);\n  if (maxMatches > 0 || iter.dupsPossible)   matches=new ArrayList();\n  if (iter.dupsPossible) {\n    while (iter.hasNext()) {\n      Item item=iter.next();\n      if (!matches.contains(item))       matches.add(item);\n    }\n    totalMatches=matches.size();\n    if (maxMatches > 0) {\n      for (int i=matches.size(); --i >= maxMatches; )       matches.remove(i);\n      for (int i=matches.size(); --i >= 0; ) {\n        matches.set(i,copyItem((Item)matches.get(i)));\n      }\n    }\n else {\n      matches=null;\n    }\n  }\n else {\n    while (iter.hasNext()) {\n      Item item=iter.next();\n      totalMatches++;\n      if (--maxMatches >= 0)       matches.add(copyItem(item));\n    }\n  }\n  return new Matches(matches,totalMatches);\n}\n", "docstring": "the code that does the real work of lookup . we do a deep copy of the items being returned , both to avoid having them modified while being marshalled ( by a concurrent update method ) , and to substitute replacements for embedded entryclass and servicetype instances , to minimize data sent back to the client . if duplicates are possible from the iterator , we save all matches , weeding out duplicates as we go , then trim to maxmatches and deep copy .", "partition": "test"}
{"idx": "6109", "code": "public static List<History> findHistoryByJob(EntityManager em,JPAEntity job,BigInteger limit){\n  requireArgument(em != null,\"Entity manager cannot be null.\");\n  requireArgument(job != null,\"The job cannot be null.\");\n  TypedQuery<History> query=em.createNamedQuery(\"History.findByJob\",History.class);\n  if (limit != null) {\n    query.setMaxResults(limit.intValue());\n  }\n  try {\n    query.setParameter(\"entity\",job);\n    return query.getResultList();\n  }\n catch (  NoResultException ex) {\n    return new ArrayList<History>(0);\n  }\n}\n", "docstring": "finds all history records for the given job .", "partition": "test"}
{"idx": "6110", "code": "private void updatePendingNodes(final int newLandmarkIndex,final RouterPriorityQueue<Node> pendingNodes){\n  final List<Double> newEstRemTravCosts=new ArrayList<>();\n  final List<Node> nodesToBeUpdated=new ArrayList<>();\n  final InternalLandmarkData landmarkData=new InternalLandmarkData();\n  for (  Node node : pendingNodes) {\n    final AStarNodeData role=getData(node);\n    final PreProcessLandmarks.LandmarksData ppRole=preprocess.getNodeData(node);\n    landmarkData.setDelegate(ppRole);\n    final double newEstRemTravCost=estimateRemainingTravelCost(landmarkData,newLandmarkIndex);\n    if (newEstRemTravCost > role.getExpectedRemainingCost()) {\n      nodesToBeUpdated.add(node);\n      newEstRemTravCosts.add(newEstRemTravCost);\n    }\n  }\n  for (  Node node : nodesToBeUpdated) {\n    pendingNodes.remove(node);\n  }\n  for (int i=0; i < nodesToBeUpdated.size(); i++) {\n    final Node node=nodesToBeUpdated.get(i);\n    final AStarNodeData data=getData(node);\n    data.setExpectedRemainingCost(newEstRemTravCosts.get(i));\n    pendingNodes.add(node,getPriority(data));\n  }\n}\n", "docstring": "if a landmark has been added to the set of the active landmarks , this function re - evaluates the estimated remaining travel time based on the new set of active landmarks of the nodes contained in pendingnodes . if this estimation improved , the node \"'\" s position in the pendingnodes queue is updated .", "partition": "test"}
{"idx": "6111", "code": "@Override public String toString(){\n  StringBuffer buff=new StringBuffer();\n  if (m_correlations == null) {\n    buff.append(\"Correlation attribute evaluator has not been built yet.\");\n  }\n else {\n    buff.append(\"\\tCorrelation Ranking Filter\");\n    if (m_detailedOutput && m_detailedOutputBuff.length() > 0) {\n      buff.append(\"\\n\\tDetailed output for nominal attributes\");\n      buff.append(m_detailedOutputBuff);\n    }\n  }\n  return buff.toString();\n}\n", "docstring": "describe the attribute evaluator", "partition": "test"}
{"idx": "6112", "code": "private void drawOverflowIndicator(final Graphics g,int maxX){\n  int width=25;\n  int height=10;\n  int xOffset=10;\n  int stepSize=width / 5;\n  int dotSize=3;\n  int x=maxX - width - xOffset;\n  int y=button.getSize().height - height;\n  g.setColor(LIGHTER_GRAY);\n  g.fillRect(x,y,width,width);\n  g.setColor(Color.GRAY);\n  g.drawRoundRect(x,y,width,width,5,5);\n  g.setColor(Color.BLACK);\n  g.fillOval(x + stepSize,y + 4,dotSize,dotSize);\n  g.fillOval(x + stepSize * 2,y + 4,dotSize,dotSize);\n  g.fillOval(x + stepSize * 3,y + 4,dotSize,dotSize);\n  g.dispose();\n}\n", "docstring": "draws indicator in case the expression text overflows on the y axis .", "partition": "test"}
{"idx": "6113", "code": "public void writeLine(long time,float[] column){\n  String str=Long.toString(time);\n  for (int i=0; i < column.length; ++i) {\n    str+=\", \" + column[i];\n  }\n  writer.println(str);\n}\n", "docstring": "write a line of values to the file with a timestamp", "partition": "test"}
{"idx": "6114", "code": "public static boolean isPEM(InputStream is){\n  try {\n    String startPEM=\"-----BEGIN\";\n    int headerLength=100;\n    byte[] preamble=new byte[headerLength];\n    if (is.read(preamble,0,headerLength) > 0) {\n      String startArray=new String(preamble);\n      return startArray.startsWith(startPEM);\n    }\n    return false;\n  }\n catch (  Exception e) {\n    throw new DSSException(\"Unable to read InputStream\");\n  }\n}\n", "docstring": "this method returns true if the inputstream contains a pem encoded item", "partition": "test"}
{"idx": "6115", "code": "public CloseListener(Object resource){\n  _resource=resource;\n}\n", "docstring": "creates the new close listener .", "partition": "test"}
{"idx": "6116", "code": "@Override public IndexRequest routing(String routing){\n  if (routing != null && routing.length() == 0) {\n    this.routing=null;\n  }\n else {\n    this.routing=routing;\n  }\n  return this;\n}\n", "docstring": "controls the shard routing of the request . using this value to hash the shard and not the id .", "partition": "test"}
{"idx": "6117", "code": "public byte[] receive() throws NetworkException {\n  try {\n    packet.setLength(DatagramConnection.DEFAULT_DATAGRAM_SIZE);\n    connection.receive(packet);\n    int packetLength=packet.getLength();\n    byte[] data=new byte[packetLength];\n    System.arraycopy(packet.getData(),0,data,0,packetLength);\n    return data;\n  }\n catch (  IOException e) {\n    throw new NetworkException(\"Failed to receive datagram packet!\",e);\n  }\n}\n", "docstring": "receive data with a specific buffer size", "partition": "test"}
{"idx": "6118", "code": "@Override protected void forceDeleteAttributeAt(int position){\n  double[] newValues=new double[m_AttValues.length - 1];\n  System.arraycopy(m_AttValues,0,newValues,0,position);\n  if (position < m_AttValues.length - 1) {\n    System.arraycopy(m_AttValues,position + 1,newValues,position,m_AttValues.length - (position + 1));\n  }\n  m_AttValues=newValues;\n}\n", "docstring": "deletes an attribute at the given position ( 0 to numattributes ( ) - 1 ) .", "partition": "test"}
{"idx": "6119", "code": "protected byte[] engineWrap(Key key) throws IllegalBlockSizeException, InvalidKeyException {\n  throw new UnsupportedOperationException();\n}\n", "docstring": "wrap a key . < p > this concrete method has been added to this previously - defined abstract class . ( for backwards compatibility , it cannot be abstract . ) it may be overridden by a provider to wrap a key . such an override is expected to throw an illegalblocksizeexception or invalidkeyexception ( under the specified circumstances ) , if the given key cannot be wrapped . if this method is not overridden , it always throws an unsupportedoperationexception .", "partition": "test"}
{"idx": "6120", "code": "@Deprecated public JavaPluginLoader(Server instance){\n  Validate.notNull(instance,\"Server cannot be null\");\n  server=instance;\n}\n", "docstring": "this class was not meant to be constructed explicitly", "partition": "test"}
{"idx": "6121", "code": "public void addSeparator(){\n  if (log.isLoggable(PlatformLogger.Level.FINER)) {\n    log.finer(\"addSeparator is not implemented\");\n  }\n}\n", "docstring": "addseparator routines are not used in peers . shared code invokes additem ( \" - \" ) for adding separators", "partition": "test"}
{"idx": "6122", "code": "private static Class<?> loadClass(URL[] urls,String name) throws ClassNotFoundException {\n  ClassLoader parent=getRMIContextClassLoader();\n  if (loaderLog.isLoggable(Log.VERBOSE)) {\n    loaderLog.log(Log.VERBOSE,\"(thread context class loader: \" + parent + \")\");\n  }\n  SecurityManager sm=System.getSecurityManager();\n  if (sm == null) {\n    try {\n      Class<?> c=Class.forName(name,false,parent);\n      if (loaderLog.isLoggable(Log.VERBOSE)) {\n        loaderLog.log(Log.VERBOSE,\"class \\\"\" + name + \"\\\" found via \"+ \"thread context class loader \"+ \"(no security manager: codebase disabled), \"+ \"defined by \"+ c.getClassLoader());\n      }\n      return c;\n    }\n catch (    ClassNotFoundException e) {\n      if (loaderLog.isLoggable(Log.BRIEF)) {\n        loaderLog.log(Log.BRIEF,\"class \\\"\" + name + \"\\\" not found via \"+ \"thread context class loader \"+ \"(no security manager: codebase disabled)\",e);\n      }\n      throw new ClassNotFoundException(e.getMessage() + \" (no security manager: RMI class loader disabled)\",e.getException());\n    }\n  }\n  Loader loader=lookupLoader(urls,parent);\n  try {\n    if (loader != null) {\n      loader.checkPermissions();\n    }\n  }\n catch (  SecurityException e) {\n    try {\n      Class<?> c=loadClassForName(name,false,parent);\n      if (loaderLog.isLoggable(Log.VERBOSE)) {\n        loaderLog.log(Log.VERBOSE,\"class \\\"\" + name + \"\\\" found via \"+ \"thread context class loader \"+ \"(access to codebase denied), \"+ \"defined by \"+ c.getClassLoader());\n      }\n      return c;\n    }\n catch (    ClassNotFoundException unimportant) {\n      if (loaderLog.isLoggable(Log.BRIEF)) {\n        loaderLog.log(Log.BRIEF,\"class \\\"\" + name + \"\\\" not found via \"+ \"thread context class loader \"+ \"(access to codebase denied)\",e);\n      }\n      throw new ClassNotFoundException(\"access to class loader denied\",e);\n    }\n  }\n  try {\n    Class<?> c=loadClassForName(name,false,loader);\n    if (loaderLog.isLoggable(Log.VERBOSE)) {\n      loaderLog.log(Log.VERBOSE,\"class \\\"\" + name + \"\\\" \"+ \"found via codebase, \"+ \"defined by \"+ c.getClassLoader());\n    }\n    return c;\n  }\n catch (  ClassNotFoundException e) {\n    if (loaderLog.isLoggable(Log.BRIEF)) {\n      loaderLog.log(Log.BRIEF,\"class \\\"\" + name + \"\\\" not found via codebase\",e);\n    }\n    throw e;\n  }\n}\n", "docstring": "load a class from the rmi class loader corresponding to the given codebase url path in the current execution context .", "partition": "test"}
{"idx": "6123", "code": "public static final List<INaviRawModule> loadRawModules(final AbstractSQLProvider provider) throws CouldntLoadDataException {\n  Preconditions.checkNotNull(provider,\"IE00416: Provider argument can not be null\");\n  final CConnection connection=provider.getConnection();\n  final List<INaviRawModule> modules=new ArrayList<INaviRawModule>();\n  if (!PostgreSQLHelpers.hasTable(connection,CTableNames.RAW_MODULES_TABLE)) {\n    return modules;\n  }\n  final String query=\"SELECT id, name FROM \" + CTableNames.RAW_MODULES_TABLE + \" ORDER BY id\";\n  try (ResultSet resultSet=connection.executeQuery(query,true)){\n    while (resultSet.next()) {\n      final int rawModuleId=resultSet.getInt(\"id\");\n      final String name=PostgreSQLHelpers.readString(resultSet,\"name\");\n      final boolean isComplete=PostgreSQLDatabaseFunctions.checkRawModulesTables(provider.getConnection(),PostgreSQLHelpers.getDatabaseName(provider.getConnection()),rawModuleId);\n      final int functionCount=isComplete ? PostgreSQLDatabaseFunctions.getRawModuleFunctionCount(connection,rawModuleId) : 0;\n      final CRawModule module=new CRawModule(rawModuleId,name,functionCount,isComplete,provider);\n      modules.add(module);\n    }\n  }\n catch (  final SQLException e) {\n    throw new CouldntLoadDataException(e);\n  }\n  return modules;\n}\n", "docstring": "loads the raw modules of a database .", "partition": "test"}
{"idx": "6124", "code": "void write(ImageOutputStream ios) throws IOException {\n  length=2 + data.length;\n  writeTag(ios);\n  ios.write(data);\n}\n", "docstring": "writes the data for this segment to the stream in valid jpeg format , directly from the data array .", "partition": "test"}
{"idx": "6125", "code": "private static List<RegisterDescription> parseRegisterInformation(final Node node) throws MessageParserException {\n  final List<RegisterDescription> registers=new ArrayList<>();\n  final NodeList nodes=node.getChildNodes();\n  for (int i=0; i < nodes.getLength(); ++i) {\n    final Node child=nodes.item(i);\n    final String registerName=getAttribute(child,\"name\");\n    final String registerSize=getAttribute(child,\"size\");\n    final String registerEditable=getAttribute(child,\"editable\");\n    registers.add(new RegisterDescription(registerName,Integer.valueOf(registerSize),Boolean.valueOf(registerEditable)));\n  }\n  return registers;\n}\n", "docstring": "parses register information from the target information string .", "partition": "test"}
{"idx": "6126", "code": "public NamedThreadFactory(String namePrefix){\n  this.namePrefix=Objects.requireNonNull(namePrefix);\n  group=getThreadGroup();\n  daemon=true;\n}\n", "docstring": "creates a daemon thread with the specified name prefix . thread names will be nameprefix - < threadid > . thread id is incremented each time a thread is created using this factory .", "partition": "test"}
{"idx": "6127", "code": "public void test_metric_cpu_num_uint16(){\n  final IGangliaMetadataMessage decl=new GangliaMetadataMessage(\"bigdata10\",\"cpu_num\",false,GangliaMessageTypeEnum.UINT16,\"cpu_num\",\"CPUs\",GangliaSlopeEnum.zero,1200,0,AbstractMetrics.getMap(IGangliaAttributes.GROUP_CPU,\"CPU Count\",\"Total number of CPUs\"));\n  assertEncodeDecode(null,decl);\n  final IGangliaMetricMessage expected=new GangliaMetricMessage(GangliaMessageTypeEnum.UINT16,\"bigdata10\",\"cpu_num\",false,\"%hu\",Integer.valueOf(4));\n  final byte[] actualData=assertEncodeDecode(decl,expected);\n  final byte[] expectedData=new byte[]{0,0,0,-127,0,0,0,9,98,105,103,100,97,116,97,49,48,0,0,0,0,0,0,7,99,112,117,95,110,117,109,0,0,0,0,0,0,0,0,3,37,104,117,0,0,0,0,4};\n  if (!Arrays.equals(expectedData,actualData)) {\n    fail(\"expect: \" + Arrays.toString(expectedData) + \", actual=\"+ Arrays.toString(actualData));\n  }\n}\n", "docstring": "unit test for a cpu_num message .", "partition": "test"}
{"idx": "6128", "code": "public int addColumn(Object newCol,int length) throws FitsException {\n  if (this.nFields > 0 && Array.getLength(newCol) != this.nRows) {\n    throw new FitsException(\"New column has different number of rows\");\n  }\n  if (this.nFields == 0) {\n    this.nRows=Array.getLength(newCol);\n  }\n  Object[] newData=new Object[this.nFields + 1];\n  int[] newOffsets=new int[this.nFields + 1];\n  int[] newLengths=new int[this.nFields + 1];\n  Class<?>[] newTypes=new Class[this.nFields + 1];\n  String[] newNulls=new String[this.nFields + 1];\n  System.arraycopy(this.data,0,newData,0,this.nFields);\n  System.arraycopy(this.offsets,0,newOffsets,0,this.nFields);\n  System.arraycopy(this.lengths,0,newLengths,0,this.nFields);\n  System.arraycopy(this.types,0,newTypes,0,this.nFields);\n  System.arraycopy(this.nulls,0,newNulls,0,this.nFields);\n  this.data=newData;\n  this.offsets=newOffsets;\n  this.lengths=newLengths;\n  this.types=newTypes;\n  this.nulls=newNulls;\n  newData[this.nFields]=newCol;\n  this.offsets[this.nFields]=this.rowLen + 1;\n  this.lengths[this.nFields]=length;\n  this.types[this.nFields]=ArrayFuncs.getBaseClass(newCol);\n  this.rowLen+=length + 1;\n  if (this.isNull != null) {\n    boolean[] newIsNull=new boolean[this.nRows * (this.nFields + 1)];\n    int add=0;\n    for (int i=0; i < this.isNull.length; i+=1) {\n      if (i % this.nFields == 0) {\n        add+=1;\n      }\n      if (this.isNull[i]) {\n        newIsNull[i + add]=true;\n      }\n    }\n    this.isNull=newIsNull;\n  }\n  this.nFields+=1;\n  this.buffer=null;\n  return this.nFields;\n}\n", "docstring": "this version of addcolumn allows the user to override the default length associated with each column type .", "partition": "test"}
{"idx": "6129", "code": "Deque<Block> schedule(Block entry){\n  Deque<Block> code=dfs(entry);\n  Deque<Block> scheduled=new ArrayDeque<Block>();\n  SetMap<Block,Edge> pred=preds(code);\n  Map<Block,Block> idom=idoms(code,pred);\n  EdgeMap<Block> loops=findLoops(code,idom,pred);\n  if (!loops.isEmpty())   verboseStatus(\"LOOPS \" + loops);\n  for (  Block b : code) {\n    if (!scheduled.contains(b))     scheduled.add(b);\n    if (loops.containsKey(b))     schedule_loop(b,loops,scheduled);\n  }\n  Deque<Block> branch_analysis=new ArrayDeque<Block>();\n  branch_analysis.addAll(scheduled);\n  Set<Block> already_seen=new HashSet<Block>();\n  while (branch_analysis.size() > 1) {\n    Block b=branch_analysis.removeFirst();\n    Expr last=b.last();\n    Block next=branch_analysis.peekFirst();\n    if (isBranch(last) && last.succ[0].to != next && last.succ[1].to == next)     invert(last);\n    already_seen.add(b);\n    b.is_backwards_branch_target=false;\n    for (    Edge s : b.succ()) {\n      s.to.is_backwards_branch_target|=s.is_backwards_branch=already_seen.contains(s.to);\n    }\n  }\n  if (verbose_mode)   for (  Block b : code)   if (b.is_backwards_branch_target)   verboseStatus(\".. backwards branch target:\" + b);\n  return scheduled;\n}\n", "docstring": "layout blocks . normal forward flow is laid out in reverse postorder . loops are handled specially to keep blocks in the loop body close to each other . loop exit blocks are postponed until after the loop .", "partition": "test"}
{"idx": "6130", "code": "public void addTransaction(SIPServerTransaction serverTransaction) throws IOException {\n  if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))   logger.logDebug(\"added transaction \" + serverTransaction);\n  serverTransaction.map();\n  addTransactionHash(serverTransaction);\n}\n", "docstring": "add a new server transaction to the set of existing transactions . add it to the top of the list so an incoming ack has less work to do in order to find the transaction .", "partition": "test"}
{"idx": "6131", "code": "private void delayRetry(int multiplier){\n  debug(\"Sleeping before next retry...\");\n  try {\n    Thread.sleep(1000 * multiplier);\n  }\n catch (  InterruptedException e) {\n    warn(e,\"Thread sleeping failed.\\nContinuing with the next retry.\");\n  }\n}\n", "docstring": "dalays the current thread . logs any errors . the delay is 1000 millis * the given multiplier . used within a loop , the iterator index can be used to give progressively longer delays .", "partition": "test"}
{"idx": "6132", "code": "public void testSplitAndJoinSemicolonNestedInPipeProperties(){\n  Properties outer=PropertyUtils.splitPropertiesOnPipe(ONE_THEN_TWO_OUTER_A);\n  assertEquals(ONE_SEMI_TWO,outer.getProperty(\"outer-b\"));\n  assertEquals(2,outer.size());\n  try {\n    assertEquals(ONE_THEN_TWO_OUTER_A,PropertyUtils.joinOnPipe(PropertyUtils.toMap(outer)));\n    return;\n  }\n catch (  ComparisonFailure deviation1) {\n  }\n  try {\n    assertEquals(TWO_THEN_ONE_OUTER_A,PropertyUtils.joinOnPipe(PropertyUtils.toMap(outer)));\n    return;\n  }\n catch (  ComparisonFailure deviation2) {\n  }\n  try {\n    assertEquals(ONE_THEN_TWO_OUTER_B,PropertyUtils.joinOnPipe(PropertyUtils.toMap(outer)));\n    return;\n  }\n catch (  ComparisonFailure deviation3) {\n  }\n  try {\n    assertEquals(TWO_THEN_ONE_OUTER_B,PropertyUtils.joinOnPipe(PropertyUtils.toMap(outer)));\n    return;\n  }\n catch (  ComparisonFailure deviation4) {\n  }\n  assertEquals(TWO_THEN_ONE_OUTER_A,PropertyUtils.joinOnPipe(PropertyUtils.toMap(outer)));\n}\n", "docstring": "test split and join of nested properties ( using pipe ) .", "partition": "test"}
{"idx": "6133", "code": "public void testIntBooleanMap() throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  String JSON=\"{ \\\"1\\\" : true, \\\"-1\\\" : false }\";\n  Map<String,Integer> result=mapper.readValue(JSON,new TypeReference<HashMap<Integer,Boolean>>(){\n  }\n);\n  assertNotNull(result);\n  assertEquals(HashMap.class,result.getClass());\n  assertEquals(2,result.size());\n  assertEquals(Boolean.TRUE,result.get(Integer.valueOf(1)));\n  assertEquals(Boolean.FALSE,result.get(Integer.valueOf(-1)));\n  assertNull(result.get(\"foobar\"));\n  assertNull(result.get(0));\n}\n", "docstring": "let \"'\" s also check that it is possible to do type conversions to allow use of non - string map keys .", "partition": "test"}
{"idx": "6134", "code": "protected ByteArrayOutputStream parseBytes(ByteArrayOutputStream bos) throws IOException {\n  int ch;\n  for (ch=skipWhitespace(); ch >= 0 && ch != '<'; ch=skipWhitespace()) {\n    int b1=ch;\n    int b2=read();\n    int b3=read();\n    int b4=read();\n    if (b4 != '=') {\n      int chunk=((base64Decode[b1] << 18) + (base64Decode[b2] << 12) + (base64Decode[b3] << 6)+ (base64Decode[b4]));\n      bos.write(chunk >> 16);\n      bos.write(chunk >> 8);\n      bos.write(chunk);\n    }\n else     if (b3 != '=') {\n      int chunk=((base64Decode[b1] << 10) + (base64Decode[b2] << 4) + (base64Decode[b3] >> 2));\n      bos.write(chunk >> 8);\n      bos.write(chunk);\n    }\n else {\n      int chunk=((base64Decode[b1] << 2) + (base64Decode[b2] >> 4));\n      bos.write(chunk);\n    }\n  }\n  if (ch == '<')   _peek=ch;\n  return bos;\n}\n", "docstring": "parses a byte array .", "partition": "test"}
{"idx": "6135", "code": "public void reset(){\n  if (mDownloadBandwidth != null) {\n    mDownloadBandwidth.reset();\n  }\n  mCurrentBandwidthConnectionQuality.set(ConnectionQuality.UNKNOWN);\n}\n", "docstring": "resets the bandwidth average for this instance of the bandwidth manager .", "partition": "test"}
{"idx": "6136", "code": "public void testMergeSecurityRoleIntoEmptyDocument() throws Exception {\n  String srcXml=\"<web-app></web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  String mergeXml=\"<web-app>\" + \"  <security-role>\" + \"    <role-name>role1</role-name>\"+ \"  </security-role>\"+ \"</web-app>\";\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(mergeXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.merge(mergeWebXml);\n  List<String> securityRoleNames=WebXmlUtils.getSecurityRoleNames(srcWebXml);\n  assertEquals(1,securityRoleNames.size());\n  assertEquals(\"role1\",securityRoleNames.get(0));\n}\n", "docstring": "tests whether a single security role is correctly inserted into an empty descriptor .", "partition": "test"}
{"idx": "6137", "code": "private DiffPart decodeFullRevision(final int blockSize_L) throws UnsupportedEncodingException, DecodingException {\n  if (blockSize_L < 1) {\n    throw new DecodingException(\"Invalid value for blockSize_L: \" + blockSize_L);\n  }\n  int l=r.read(blockSize_L);\n  ByteArrayOutputStream output=new ByteArrayOutputStream();\n  for (int i=0; i < l; i++) {\n    output.write(r.readByte());\n  }\n  DiffPart part=new DiffPart(DiffAction.FULL_REVISION_UNCOMPRESSED);\n  part.setText(output.toString(WIKIPEDIA_ENCODING));\n  return part;\n}\n", "docstring": "decodes a fullrevision operation .", "partition": "test"}
{"idx": "6138", "code": "private synchronized static void removeChildCharacterData(Node node,boolean deep){\n  NodeList list=node.getChildNodes();\n  for (int i=list.getLength(); i >= 0; i--) {\n    Node n=list.item(i);\n    if (n == null)     continue;\n    if (n instanceof CharacterData)     node.removeChild(XMLCaster.toRawNode(n));\n else     if (deep)     removeChildCharacterData(n,deep);\n  }\n}\n", "docstring": "remove children from type characterdata from a node , this includes text , comment and cdatasection nodes", "partition": "test"}
{"idx": "6139", "code": "private void loadCorpus(String source,String target,String align) throws IOException {\n  logger.info(\"Counting the number of corpus positions\");\n  TimeKeeper timer=TimingUtils.start();\n  int numSourcePositions=0;\n  int numTargetPositions=0;\n  numSentences=0;\n  ParallelCorpus corpus=new ParallelCorpus(1);\n  try (LineNumberReader fReader=IOTools.getReaderFromFile(source)){\n    LineNumberReader eReader=IOTools.getReaderFromFile(target);\n    LineNumberReader aReader=IOTools.getReaderFromFile(align);\n    for (String fLine; (fLine=fReader.readLine()) != null; ) {\n      String eLine=eReader.readLine();\n      String aLine=aReader.readLine();\n      AlignedSentence example=corpus.getSentence(fLine,eLine,aLine);\n      if (example != null) {\n        numSourcePositions+=example.sourceLength();\n        numTargetPositions+=example.targetLength();\n        ++numSentences;\n      }\n    }\n  }\n   final int initialVocabularySize=corpus.getVocabulary().size();\n  timer.mark(\"Counting corpus positions\");\n  logger.info(\"Source positions: {}  Target positions: {}  Sentences: {}\",numSourcePositions,numTargetPositions,numSentences);\n  final int srcLength=numSourcePositions + numSentences;\n  if (srcLength < 0)   throw new RuntimeException(\"Maximum source bitext size exceeded\");\n  srcBitext=new int[srcLength];\n  f2e=new int[srcLength];\n  final int tgtLength=numTargetPositions + numSentences;\n  if (tgtLength < 0)   throw new RuntimeException(\"Maximum target bitext size exceeded\");\n  tgtBitext=new int[tgtLength];\n  e2f=new int[tgtLength];\n  try (LineNumberReader fReader=IOTools.getReaderFromFile(source)){\n    LineNumberReader eReader=IOTools.getReaderFromFile(target);\n    LineNumberReader aReader=IOTools.getReaderFromFile(align);\n    int srcOffset=0;\n    int tgtOffset=0;\n    for (String fLine; (fLine=fReader.readLine()) != null; ) {\n      String eLine=eReader.readLine();\n      String aLine=aReader.readLine();\n      AlignedSentence sentence=corpus.getSentence(fLine,eLine,aLine);\n      if (sentence == null) {\n        logger.info(\"Discarding parallel example {}\",fReader.getLineNumber());\n      }\n else {\n        System.arraycopy(sentence.source,0,srcBitext,srcOffset,sentence.sourceLength());\n        System.arraycopy(sentence.f2e,0,f2e,srcOffset,sentence.f2e.length);\n        System.arraycopy(sentence.target,0,tgtBitext,tgtOffset,sentence.targetLength());\n        System.arraycopy(sentence.e2f,0,e2f,tgtOffset,sentence.e2f.length);\n        srcOffset+=sentence.sourceLength();\n        tgtOffset+=sentence.targetLength();\n        srcBitext[srcOffset]=toSentenceOffset(tgtOffset);\n        tgtBitext[tgtOffset]=toSentenceOffset(srcOffset);\n        ++srcOffset;\n        ++tgtOffset;\n      }\n    }\n  }\n   this.vocabulary=corpus.getVocabulary();\n  assert initialVocabularySize == vocabulary.size();\n  timer.mark(\"Loading corpus\");\n  logger.info(\"Done loading corpus: {}\",timer);\n}\n", "docstring": "streaming loader , which does not double peak memory like the loader that creates a suffix array from a parallel corpus .", "partition": "test"}
{"idx": "6140", "code": "public static float mixFriction(float friction1,float friction2){\n  return MathUtils.sqrt(friction1 * friction2);\n}\n", "docstring": "friction mixing law . feel free to customize this . todo djm : add customization", "partition": "test"}
{"idx": "6141", "code": "public String serialize(Object obj,String contentType) throws ApiException {\n  if (contentType.startsWith(\"application/json\")) {\n    return json.serialize(obj);\n  }\n else {\n    throw new ApiException(400,\"can not serialize object into Content-Type: \" + contentType);\n  }\n}\n", "docstring": "serialize the given java object into string according the given content - type ( only json is supported for now ) .", "partition": "test"}
{"idx": "6142", "code": "private boolean compileSWsequenceZR(int baseRegister,int[] offsets,int[] registers){\n  for (int i=0; i < registers.length; i++) {\n    if (registers[i] != _zr) {\n      return false;\n    }\n  }\n  for (int i=1; i < offsets.length; i++) {\n    if (offsets[i] != offsets[i - 1] + 4) {\n      return false;\n    }\n  }\n  int offset=offsets[0];\n  int length=offsets.length;\n  do {\n    int copyLength=Math.min(length,FastMemory.zero.length);\n    mv.visitFieldInsn(Opcodes.GETSTATIC,Type.getInternalName(FastMemory.class),\"zero\",\"[I\");\n    loadImm(0);\n    loadMemoryInt();\n    prepareMemIndex(baseRegister,offset,false,32);\n    loadImm(copyLength);\n    mv.visitMethodInsn(Opcodes.INVOKESTATIC,Type.getInternalName(System.class),\"arraycopy\",arraycopyDescriptor);\n    length-=copyLength;\n    offset+=copyLength;\n  }\n while (length > 0);\n  return true;\n}\n", "docstring": "compile a sequence sw $ zr , n ( $ reg ) sw $ zr , n + 4 ( $ reg ) sw $ zr , n + 8 ( $ reg ) . . . into system . arraycopy ( fastmemory . zero , 0 , memoryint , ( n + $ reg ) > > 2 , length )", "partition": "test"}
{"idx": "6143", "code": "private boolean isNativeVolumeExpansionSupported(Volume vplexVolume,Long newSize){\n  boolean useNativeVolumeExpansion=true;\n  StringSet assocVolumeIds=vplexVolume.getAssociatedVolumes();\n  if (null == assocVolumeIds) {\n    s_logger.warn(\"VPLEX volume {} has no backend volumes. It was probably ingested \'Virtual Volume Only\'.\",vplexVolume.forDisplay());\n    useNativeVolumeExpansion=false;\n  }\n else {\n    for (    String assocVolumeId : assocVolumeIds) {\n      Volume assocVolume=_permissionsHelper.getObjectById(URI.create(assocVolumeId),Volume.class);\n      try {\n        super.verifyVolumeExpansionRequest(assocVolume,newSize);\n      }\n catch (      Exception e) {\n        useNativeVolumeExpansion=false;\n        break;\n      }\n    }\n  }\n  return useNativeVolumeExpansion;\n}\n", "docstring": "determines if the vplex volume can be expanded by natively expanding the backend volumes .", "partition": "test"}
{"idx": "6144", "code": "public void updateGUI(RosterEntry r){\n  roadName.setText(r.getRoadName());\n  roadNumber.setText(r.getRoadNumber());\n  mfg.setText(r.getMfg());\n  owner.setText(r.getOwner());\n  model.setText(r.getModel());\n  comment.setText(r.getComment());\n  decoderModel.setText(r.getDecoderModel());\n  decoderFamily.setText(r.getDecoderFamily());\n  decoderComment.setText(r.getDecoderComment());\n  dateUpdated.setText(r.getDateUpdated());\n  maxSpeedSpinner.setValue(Integer.valueOf(r.getMaxSpeedPCT()));\n}\n", "docstring": "file gui from roster contents", "partition": "test"}
{"idx": "6145", "code": "public static Double oizp(Number value){\n  if (value == null) {\n    return null;\n  }\n  return (value.doubleValue() >= 0d) ? 1d : 0d;\n}\n", "docstring": "function which will return one if the argument is zero or a positive number , and zero if not .", "partition": "test"}
{"idx": "6146", "code": "public TerminalSize with(TerminalSize size){\n  if (equals(size)) {\n    return this;\n  }\n  return size;\n}\n", "docstring": "returns itself if it is equal to the supplied size , otherwise the supplied size . you can use this if you have a size field which is frequently recalculated but often resolves to the same size ; it will keep the same object in memory instead of swapping it out every cycle .", "partition": "test"}
{"idx": "6147", "code": "private boolean isGzipAllowed(final HttpServletRequest request){\n  return !DispatcherStreamLocator.isIncludedRequest(request) && WroUtil.isGzipSupported(request);\n}\n", "docstring": "checks if the request supports gzip and is not a include request ( these cannot be gzipped )", "partition": "test"}
{"idx": "6148", "code": "public ReplayProcessor(int bufferSize,boolean unbounded){\n  if (unbounded) {\n    this.buffer=new UnboundedBuffer<>(bufferSize);\n  }\n else {\n    this.buffer=new BoundedBuffer<>(bufferSize);\n  }\n  SUBSCRIBERS.lazySet(this,EMPTY);\n}\n", "docstring": "constructs a replayprocessor with bounded or unbounded buffering .", "partition": "test"}
{"idx": "6149", "code": "protected void onShowConversations(@NonNull List<C> conversations){\n  if (DEBUG) {\n    Log.d(TAG,\"Showing \" + conversations.size() + \" conversations\");\n  }\n  mView.showConversations(new ArrayList<>(conversations));\n}\n", "docstring": "by default displays the current conversations in the view , this method can be updated to modify the conversations list before it is shown , can be used to filter the list or augment it", "partition": "test"}
{"idx": "6150", "code": "public void enqueueJob(final Runnable job){\nsynchronized (mSleepSync) {\n    if (hasJob()) {\n      throw new IllegalStateException(\"Job already enqueued\");\n    }\n    setJob(job);\n    mSleepSync.notifyAll();\n  }\n}\n", "docstring": "enqueue a job for this thread", "partition": "test"}
{"idx": "6151", "code": "public void startElement(String uri,String localName,String qName,Attributes attributes) throws org.xml.sax.SAXException {\n  if (qName.equals(PrintData.XML_TAG)) {\n    String name=attributes.getValue(PrintData.XML_ATTRIBUTE_NAME);\n    if (m_pd == null) {\n      m_pd=new PrintData(m_ctx,name);\n      push(m_pd);\n    }\n else {\n      PrintData temp=new PrintData(m_ctx,name);\n      m_curPD.addNode(temp);\n      push(temp);\n    }\n  }\n else   if (qName.equals(PrintData.XML_ROW_TAG)) {\n    m_curPD.addRow(false,0);\n  }\n else   if (qName.equals(PrintDataElement.XML_TAG)) {\n    m_curPDEname=attributes.getValue(PrintDataElement.XML_ATTRIBUTE_NAME);\n    m_curPDEvalue=new StringBuffer();\n  }\n}\n", "docstring": "receive notification of the start of an element .", "partition": "test"}
{"idx": "6152", "code": "public void drawString(String str,int x,int y,int textDecoration){\n  if (str.length() == 0 || (str.length() == 1 && str.charAt(0) == ' ')) {\n    return;\n  }\n  Object nativeFont=null;\n  if (current != null) {\n    nativeFont=current.getNativeFont();\n  }\n  if (current instanceof CustomFont) {\n    current.drawString(this,str,x,y);\n  }\n else {\n    impl.drawString(nativeGraphics,nativeFont,str,x + xTranslate,y + yTranslate,textDecoration);\n  }\n}\n", "docstring": "draw a string using the current font and color in the x , y coordinates . the font is drawn from the top position and not the baseline .", "partition": "test"}
{"idx": "6153", "code": "public void updateNonceParameters(){\n  if (mNextNonce.equals(mNonce)) {\n    mCnonceCounter++;\n  }\n else {\n    mCnonceCounter=1;\n    mNonce=mNextNonce;\n  }\n}\n", "docstring": "update the nonce parameters", "partition": "test"}
{"idx": "6154", "code": "@Override public void acceptInstance(InstanceEvent e){\n  if (e.getStatus() == InstanceEvent.FORMAT_AVAILABLE) {\n    m_connectedFormat=e.getStructure();\n    m_stopRequested.set(false);\n    try {\n      init(new Instances(e.getStructure(),0));\n    }\n catch (    IllegalArgumentException ex) {\n      if (m_log != null) {\n        String message=\"ERROR: There is a problem with the incoming instance structure\";\n        stopWithErrorMessage(message,ex);\n        return;\n      }\n    }\n    String buffSize=m_bufferSize;\n    try {\n      buffSize=m_env.substitute(buffSize);\n      m_bufferSizeI=Integer.parseInt(buffSize);\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n    }\n    m_incrementalBuffer=new ArrayList<InstanceHolder>(m_bufferSizeI);\n    m_bufferFiles=new ArrayList<File>();\n    m_streamCounter=0;\n    return;\n  }\n  m_busy=true;\n  if (e.getInstance() != null) {\n    if (m_streamCounter == 0) {\n      if (m_log != null) {\n        m_log.statusMessage(statusMessagePrefix() + \"Starting streaming sort...\");\n        m_log.logMessage(\"[Sorter] \" + statusMessagePrefix() + \" Using streaming buffer size: \"+ m_bufferSizeI);\n      }\n    }\n    InstanceHolder tempH=new InstanceHolder();\n    tempH.m_instance=e.getInstance();\n    tempH.m_fileNumber=-1;\n    if (m_stringAttIndexes != null) {\n      copyStringAttVals(tempH);\n    }\n    m_incrementalBuffer.add(tempH);\n    m_streamCounter++;\n  }\n  if (e.getInstance() == null || e.getStatus() == InstanceEvent.BATCH_FINISHED) {\n    emitBufferedInstances();\n    return;\n  }\n else   if (m_incrementalBuffer.size() == m_bufferSizeI) {\n    try {\n      sortBuffer(true);\n    }\n catch (    Exception ex) {\n      String msg=statusMessagePrefix() + \"ERROR: unable to write to temp file.\";\n      stopWithErrorMessage(msg,ex);\n      m_busy=false;\n      return;\n    }\n  }\n  m_busy=false;\n}\n", "docstring": "accept and process an instance event", "partition": "test"}
{"idx": "6155", "code": "private void matchVPools(URI rpSystemId){\n  List<URI> storagePoolIds=ConnectivityUtil.getRPSystemStoragePools(_dbClient,rpSystemId);\n  StringBuffer errorMessage=new StringBuffer();\n  if (storagePoolIds != null && !storagePoolIds.isEmpty()) {\n    List<StoragePool> storagePools=_dbClient.queryObject(StoragePool.class,storagePoolIds);\n    ImplicitPoolMatcher.matchModifiedStoragePoolsWithAllVirtualPool(storagePools,_dbClient,_coordinator,errorMessage);\n  }\n}\n", "docstring": "recalculate all virtual pools matching storage pools that have rp protection as creation of a protection system creates new relationships and constraints on the matching pools of an rp system .", "partition": "test"}
{"idx": "6156", "code": "public static BigDecimal calculateFee(Player player,int price){\n  BigDecimal fee=BigDecimal.valueOf(price);\n  fee=fee.multiply(BigDecimal.valueOf(TRADING_FEE_PERCENTAGE));\n  if (player.isBadBoy()) {\n    fee=fee.multiply(BigDecimal.valueOf(1 + TRADING_FEE_PLAYER_KILLER_PENALTY));\n  }\n  BigDecimal feeBonus=BigDecimal.ONE;\n  feeBonus=BigDecimal.valueOf(Math.exp(-player.getTradescore() / FEE_BONUS_CONSTANT));\n  fee=fee.multiply(feeBonus);\n  return fee.max(BigDecimal.ONE);\n}\n", "docstring": "calculates the trading fee a player has to pay when selling for a certain price", "partition": "test"}
{"idx": "6157", "code": "private void addSearchHistory(){\n  addSearchHistory(tfSearchEditor.getText());\n}\n", "docstring": "adds current search pattern in the search history list", "partition": "test"}
{"idx": "6158", "code": "ArrayList<SourceFile> trimFileList(ArrayList<SourceFile> files){\n  HashMap<String,String> names=new HashMap<String,String>();\n  ArrayList<SourceFile> list=new ArrayList<SourceFile>();\n  int size=files.size();\n  for (int i=0; i < size; i++) {\n    boolean addIt=false;\n    SourceFile fi=files.get(i);\n    String fName=fi.getRawName();\n    if (m_swfFilter == null) {\n      if (names.get(fName) == null)       addIt=true;\n    }\n else {\n      addIt=m_swfFilter.containsSource(fi);\n    }\n    if (addIt) {\n      names.put(fName,fName);\n      list.add(fi);\n    }\n  }\n  return list;\n}\n", "docstring": "walk the file list looking for name collisions . if we find one , then we remove it", "partition": "test"}
{"idx": "6159", "code": "public static String join(double[] self,String separator){\n  StringBuilder buffer=new StringBuilder();\n  boolean first=true;\n  if (separator == null)   separator=\"\";\n  for (  double next : self) {\n    if (first) {\n      first=false;\n    }\n else {\n      buffer.append(separator);\n    }\n    buffer.append(next);\n  }\n  return buffer.toString();\n}\n", "docstring": "concatenates the string representation of each items in this array , with the given string as a separator between each item .", "partition": "test"}
{"idx": "6160", "code": "public EntityQuery orderBy(String... fields){\n  this.orderBy=Arrays.asList(fields);\n  return this;\n}\n", "docstring": "the fields of the named entity to order the resultset by ; optionally add a \" asc \" for ascending or \" desc \" for descending note : each successive call to any of the orderby ( . . . ) methods will replace the currently set orderby fields for the query .", "partition": "test"}
{"idx": "6161", "code": "public StemmedString(String orig,String stemmed){\n  strOrig=orig;\n  strStemmed=stemmed;\n}\n", "docstring": "create a stemmedstring from two strings", "partition": "test"}
{"idx": "6162", "code": "public LogNetworkStreamMerger(LogRequest req,MediaType mediaType,LogSvcPropertiesLoader propertiesLoader){\n  logger.trace(\"In LogNetworkStreamMerger\'s constructor\");\n  this.request=req;\n  this.mediaType=mediaType;\n  this.propertiesLoader=propertiesLoader;\n  List<LogNetworkReader> readers=getLogNetworkStreams();\n  int size=readers.size();\n  logHeads=new LogMessage[size];\n  this.logStreamList=new LogNetworkReader[size];\n  int index=0;\n  for (  LogNetworkReader reader : readers) {\n    logStreamList[index]=reader;\n    logHeads[index]=null;\n    index++;\n  }\n}\n", "docstring": "merges all logs on each node based on time stamp", "partition": "test"}
{"idx": "6163", "code": "public static String packCipherSuites(String[] ciphers){\n  String cipherSet=null;\n  if (ciphers != null) {\n    StringBuffer buf=new StringBuffer();\n    for (int i=0; i < ciphers.length; i++) {\n      buf.append(ciphers[i]);\n      if (i < ciphers.length - 1) {\n        buf.append(',');\n      }\n    }\n    cipherSet=buf.toString();\n  }\n  return cipherSet;\n}\n", "docstring": "converts an array of ciphers into a single string .", "partition": "test"}
{"idx": "6164", "code": "public ExtensionFileFilter(String description,String extension){\n  this.description=description;\n  this.extensions=new HashSet<String>();\n  extensions.add(extension.toLowerCase());\n  defaultExtension=extension;\n}\n", "docstring": "creates a new instance .", "partition": "test"}
{"idx": "6165", "code": "private static boolean isAnArgument(final String arg){\n  return (arg.startsWith(\"-\") && (arg.length() > 1) && !Character.isDigit(arg.charAt(1)));\n}\n", "docstring": "given a string like \" - foo \" or \" - 5 \" or \" - 123 . mxml \" , this determines whether the string is an argument or . . . not an argument ( e . g . numeral )", "partition": "test"}
{"idx": "6166", "code": "private synchronized static void removeChildren(Node node,short type,boolean deep){\n  NodeList list=node.getChildNodes();\n  for (int i=list.getLength(); i >= 0; i--) {\n    Node n=list.item(i);\n    if (n == null)     continue;\n    if (n.getNodeType() == type || type == UNDEFINED_NODE)     node.removeChild(XMLCaster.toRawNode(n));\n else     if (deep)     removeChildren(n,type,deep);\n  }\n}\n", "docstring": "removes child elements from a specific type", "partition": "test"}
{"idx": "6167", "code": "public boolean isValidSavepoint(Savepoint sp){\n  if (isSource())   return false;\n  boolean result=false;\n  if (sp != null)   result=true;\n  return result;\n}\n", "docstring": "checks whether a savepoint is valid", "partition": "test"}
{"idx": "6168", "code": "public static void columnsFor(ResultSet resultSet,TableEditor editor) throws SQLException {\n  List<Column> columns=new ArrayList<>();\n  columnsFor(resultSet,null);\n  editor.setColumns(columns);\n}\n", "docstring": "use the supplied table editor to create columns for the supplied result set .", "partition": "test"}
{"idx": "6169", "code": "private static void write(Collection<String> src,File out) throws IOException {\n  try (Writer writer=new BufferedWriter(new FileWriter(out))){\n    for (    String line : src)     writer.write(line + '\\n');\n  }\n }\n", "docstring": "write source code to file .", "partition": "test"}
{"idx": "6170", "code": "private long resetUidValidity() throws IOException {\n  long timestamp=System.currentTimeMillis();\n  setUidValidity(timestamp);\n  return timestamp;\n}\n", "docstring": "sets and returns a new uidvalidity for this folder .", "partition": "test"}
{"idx": "6171", "code": "public final ArrayList<Move> pseudoLegalMoves(Position pos){\n  ArrayList<Move> moveList=getMoveListObj();\n  final boolean wtm=pos.whiteMove;\n  for (int x=0; x < 8; x++) {\n    for (int y=0; y < 8; y++) {\n      int sq=Position.getSquare(x,y);\n      int p=pos.getPiece(sq);\n      if ((p == Piece.EMPTY) || (Piece.isWhite(p) != wtm)) {\n        continue;\n      }\n      if ((p == Piece.WROOK) || (p == Piece.BROOK) || (p == Piece.WQUEEN)|| (p == Piece.BQUEEN)) {\n        if (addDirection(moveList,pos,sq,7 - x,1))         return moveList;\n        if (addDirection(moveList,pos,sq,7 - y,8))         return moveList;\n        if (addDirection(moveList,pos,sq,x,-1))         return moveList;\n        if (addDirection(moveList,pos,sq,y,-8))         return moveList;\n      }\n      if ((p == Piece.WBISHOP) || (p == Piece.BBISHOP) || (p == Piece.WQUEEN)|| (p == Piece.BQUEEN)) {\n        if (addDirection(moveList,pos,sq,Math.min(7 - x,7 - y),9))         return moveList;\n        if (addDirection(moveList,pos,sq,Math.min(x,7 - y),7))         return moveList;\n        if (addDirection(moveList,pos,sq,Math.min(x,y),-9))         return moveList;\n        if (addDirection(moveList,pos,sq,Math.min(7 - x,y),-7))         return moveList;\n      }\n      if ((p == Piece.WKNIGHT) || (p == Piece.BKNIGHT)) {\n        if (x < 6 && y < 7 && addDirection(moveList,pos,sq,1,10))         return moveList;\n        if (x < 7 && y < 6 && addDirection(moveList,pos,sq,1,17))         return moveList;\n        if (x > 0 && y < 6 && addDirection(moveList,pos,sq,1,15))         return moveList;\n        if (x > 1 && y < 7 && addDirection(moveList,pos,sq,1,6))         return moveList;\n        if (x > 1 && y > 0 && addDirection(moveList,pos,sq,1,-10))         return moveList;\n        if (x > 0 && y > 1 && addDirection(moveList,pos,sq,1,-17))         return moveList;\n        if (x < 7 && y > 1 && addDirection(moveList,pos,sq,1,-15))         return moveList;\n        if (x < 6 && y > 0 && addDirection(moveList,pos,sq,1,-6))         return moveList;\n      }\n      if ((p == Piece.WKING) || (p == Piece.BKING)) {\n        if (x < 7 && addDirection(moveList,pos,sq,1,1))         return moveList;\n        if (x < 7 && y < 7 && addDirection(moveList,pos,sq,1,9))         return moveList;\n        if (y < 7 && addDirection(moveList,pos,sq,1,8))         return moveList;\n        if (x > 0 && y < 7 && addDirection(moveList,pos,sq,1,7))         return moveList;\n        if (x > 0 && addDirection(moveList,pos,sq,1,-1))         return moveList;\n        if (x > 0 && y > 0 && addDirection(moveList,pos,sq,1,-9))         return moveList;\n        if (y > 0 && addDirection(moveList,pos,sq,1,-8))         return moveList;\n        if (x < 7 && y > 0 && addDirection(moveList,pos,sq,1,-7))         return moveList;\n        int k0=wtm ? Position.getSquare(4,0) : Position.getSquare(4,7);\n        if (Position.getSquare(x,y) == k0) {\n          int aCastle=wtm ? Position.A1_CASTLE : Position.A8_CASTLE;\n          int hCastle=wtm ? Position.H1_CASTLE : Position.H8_CASTLE;\n          int rook=wtm ? Piece.WROOK : Piece.BROOK;\n          if (((pos.getCastleMask() & (1 << hCastle)) != 0) && (pos.getPiece(k0 + 1) == Piece.EMPTY) && (pos.getPiece(k0 + 2) == Piece.EMPTY)&& (pos.getPiece(k0 + 3) == rook)&& !sqAttacked(pos,k0)&& !sqAttacked(pos,k0 + 1)) {\n            moveList.add(getMoveObj(k0,k0 + 2,Piece.EMPTY));\n          }\n          if (((pos.getCastleMask() & (1 << aCastle)) != 0) && (pos.getPiece(k0 - 1) == Piece.EMPTY) && (pos.getPiece(k0 - 2) == Piece.EMPTY)&& (pos.getPiece(k0 - 3) == Piece.EMPTY)&& (pos.getPiece(k0 - 4) == rook)&& !sqAttacked(pos,k0)&& !sqAttacked(pos,k0 - 1)) {\n            moveList.add(getMoveObj(k0,k0 - 2,Piece.EMPTY));\n          }\n        }\n      }\n      if ((p == Piece.WPAWN) || (p == Piece.BPAWN)) {\n        int yDir=wtm ? 8 : -8;\n        if (pos.getPiece(sq + yDir) == Piece.EMPTY) {\n          addPawnMoves(moveList,sq,sq + yDir);\n          if ((y == (wtm ? 1 : 6)) && (pos.getPiece(sq + 2 * yDir) == Piece.EMPTY)) {\n            addPawnMoves(moveList,sq,sq + yDir * 2);\n          }\n        }\n        if (x > 0) {\n          int toSq=sq + yDir - 1;\n          int cap=pos.getPiece(toSq);\n          if (cap != Piece.EMPTY) {\n            if (Piece.isWhite(cap) != wtm) {\n              if (cap == (wtm ? Piece.BKING : Piece.WKING)) {\n                returnMoveList(moveList);\n                moveList=getMoveListObj();\n                moveList.add(getMoveObj(sq,toSq,Piece.EMPTY));\n                return moveList;\n              }\n else {\n                addPawnMoves(moveList,sq,toSq);\n              }\n            }\n          }\n else           if (toSq == pos.getEpSquare()) {\n            addPawnMoves(moveList,sq,toSq);\n          }\n        }\n        if (x < 7) {\n          int toSq=sq + yDir + 1;\n          int cap=pos.getPiece(toSq);\n          if (cap != Piece.EMPTY) {\n            if (Piece.isWhite(cap) != wtm) {\n              if (cap == (wtm ? Piece.BKING : Piece.WKING)) {\n                returnMoveList(moveList);\n                moveList=getMoveListObj();\n                moveList.add(getMoveObj(sq,toSq,Piece.EMPTY));\n                return moveList;\n              }\n else {\n                addPawnMoves(moveList,sq,toSq);\n              }\n            }\n          }\n else           if (toSq == pos.getEpSquare()) {\n            addPawnMoves(moveList,sq,toSq);\n          }\n        }\n      }\n    }\n  }\n  return moveList;\n}\n", "docstring": "generate and return a list of pseudo - legal moves . pseudo - legal means that the moves don \"'\" t necessarily defend from check threats .", "partition": "test"}
{"idx": "6172", "code": "private void handleStaticSiteRequest(StaticSiteRequest.PointRequest request,TransportNetwork transportNetwork,TaskStatistics ts){\n  StaticComputer computer=new StaticComputer(request,transportNetwork,ts);\n  if (request.request.bucket != null)   computer.run();\n else {\n    try {\n      PipedInputStream pis=new PipedInputStream();\n      PipedOutputStream pos=new PipedOutputStream(pis);\n      finishPriorityTask(request,pis);\n      computer.write(pos);\n      pos.close();\n    }\n catch (    IOException e) {\n      LOG.error(\"Could not write static output to broker\",e);\n    }\n  }\n  deleteRequest(request);\n}\n", "docstring": "handle a fancy new - fangled static site request", "partition": "test"}
{"idx": "6173", "code": "public synchronized void removeRoom(String room){\n  if (!Helper.validateStream(room)) {\n    return;\n  }\n  room=room.toLowerCase();\n  if (rooms.remove(room)) {\n    unsubRoom(room);\n    removeEmotes(room);\n    prevEmotesets.remove(room);\n  }\n}\n", "docstring": "remove subscription to a room . this also removes all current ffz event emotes from that room .", "partition": "test"}
{"idx": "6174", "code": "public void addAll(final Collection elements){\n  adjusting=true;\n  Set oldSelection=new HashSet(selection);\n  boolean rv=selection.addAll(elements);\n  adjusting=false;\n  if (rv) {\n    fireSelectionChanged(oldSelection,selection);\n  }\n  oldSelection=null;\n}\n", "docstring": "add all of the specified elements to the selection .", "partition": "test"}
{"idx": "6175", "code": "public boolean hasFeature(int feature){\n  return ((feature >= MODE_FIRST && feature <= MODE_LAST) || (feature >= FEATURE_FIRST && feature <= FEATURE_LAST)) && (feature == MODE_OFF || mCapabilities.get(feature));\n}\n", "docstring": "checks if a particular feature or mode is supported by the system .", "partition": "test"}
{"idx": "6176", "code": "public Set<Integer> backupPartitions(UUID nodeId){\n  Set<Integer> set=backup.get(nodeId);\n  return set == null ? Collections.<Integer>emptySet() : set;\n}\n", "docstring": "get backup partitions for specified node id .", "partition": "test"}
{"idx": "6177", "code": "public java.lang.StringBuffer insert(int offset,java.lang.String str){\n  internal.insert(offset,str);\n  return this;\n}\n", "docstring": "inserts the string into this string buffer . the characters of the string argument are inserted , in order , into this string buffer at the indicated offset , moving up any characters originally above that position and increasing the length of this string buffer by the length of the argument . if str is null , then the four characters \" null \" are inserted into this string buffer . the character at index k in the new character sequence is equal to : the character at index k in the old character sequence , if k is less than offset the character at index k - offset in the argument str , if k is not less than offset but is less than offset + str . length ( ) the character at index k - str . length ( ) in the old character sequence , if k is not less than offset + str . length ( ) the offset argument must be greater than or equal to 0 , and less than or equal to the length of this string buffer .", "partition": "test"}
{"idx": "6178", "code": "public Loader load(String imageUrl){\n  ImageUrl=imageUrl;\n  return this;\n}\n", "docstring": "just pass http url and then you have to call view ( imageview )", "partition": "test"}
{"idx": "6179", "code": "private void buildPTR(){\n  double[] temp_row;\n  double[][] PTRA;\n  int k;\n  PivotTransform pt;\n  PTR=Matrix.identity(n,n);\n  PTRA=PTR.getArray();\n  k=pivotTransformQueue.size();\n  while (k-- > 0) {\n    pt=pivotTransformQueue.removeLast();\n    temp_row=PTRA[pt.pos1];\n    PTRA[pt.pos1]=PTRA[pt.pos2];\n    PTRA[pt.pos2]=temp_row;\n  }\n}\n", "docstring": "build the pivot - transform - reverse matrix ptr . we start with a n x n identity matrix and for each recorded pivot transformation swap the according rows , reversing the sequence and starting with the last pivot transformation .", "partition": "test"}
{"idx": "6180", "code": "public Bidi createLineBidi(int lineStart,int lineLimit){\n  AttributedString astr=new AttributedString(\"\");\n  Bidi newBidi=new Bidi(astr.getIterator());\n  return bidiBase.setLine(this,bidiBase,newBidi,newBidi.bidiBase,lineStart,lineLimit);\n}\n", "docstring": "create a bidi object representing the bidi information on a line of text within the paragraph represented by the current bidi . this call is not required if the entire paragraph fits on one line .", "partition": "test"}
{"idx": "6181", "code": "public void restartAndInstallIfNecessary(){\n  File patchesDir=new File(mySdkHandler.getLocation(),PatchInstallerUtil.PATCHES_DIR_NAME);\n  StudioLoggerProgressIndicator progress=new StudioLoggerProgressIndicator(PatchInstallerFactory.class);\n  if (patchesDir.exists()) {\n    File[] subDirs=patchesDir.listFiles(null);\n    for (    File patchDir : subDirs) {\n      processPatch(mySdkHandler.getLocation(),progress,patchDir);\n    }\n  }\n}\n", "docstring": "find any pending patches under the given sdk root that require studio to be restarted , and if there are any , restart and install them . if they have already been installed ( as indicated by the patch itself being missing , and the revision mentioned in source . properties matching that in the pending xml , do the install complete actions ( write package . xml and fire listeners ) and clean up .", "partition": "test"}
{"idx": "6182", "code": "public static double[][] align(int[] real,double[] pred){\n  int missing=numberOfMissingLabels(real);\n  double[] _real=new double[real.length - missing];\n  double[] _pred=new double[real.length - missing];\n  int offset=0;\n  for (int i=0; i < real.length; i++) {\n    if (real[i] == -1 || pred[i] == -1.0 || Double.isNaN(pred[i])) {\n      offset++;\n      continue;\n    }\n    _real[i - offset]=real[i];\n    _pred[i - offset]=pred[i];\n  }\n  double[][] res=new double[2][0];\n  res[0]=_real;\n  res[1]=_pred;\n  return res;\n}\n", "docstring": "helper function for missing values in the labels and missing predictions ( i . e . , from abstaining classifiers ) . aligns the predictions with the real labels , discarding labels and predictions that are missing .", "partition": "test"}
{"idx": "6183", "code": "public static boolean isCategory(int M_Product_Category_ID,int M_Product_ID){\n  if (M_Product_ID == 0 || M_Product_Category_ID == 0)   return false;\n  Integer product=new Integer(M_Product_ID);\n  Integer category=(Integer)s_products.get(product);\n  if (category != null)   return category.intValue() == M_Product_Category_ID;\n  String sql=\"SELECT M_Product_Category_ID FROM M_Product WHERE M_Product_ID=?\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,M_Product_ID);\n    ResultSet rs=pstmt.executeQuery();\n    if (rs.next())     category=new Integer(rs.getInt(1));\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    s_log.log(Level.SEVERE,sql,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n  if (category != null) {\n    s_products.put(product,category);\n    s_log.fine(\"M_Product_ID=\" + M_Product_ID + \"(\"+ category+ \") in M_Product_Category_ID=\"+ M_Product_Category_ID+ \" - \"+ (category.intValue() == M_Product_Category_ID));\n    return category.intValue() == M_Product_Category_ID;\n  }\n  s_log.log(Level.SEVERE,\"Not found M_Product_ID=\" + M_Product_ID);\n  return false;\n}\n", "docstring": "is product in category", "partition": "test"}
{"idx": "6184", "code": "public AllStatsTableMulti(DatasetGenerator datasetGenerator,Locker locker){\n  ArgumentChecking.notNull(datasetGenerator,\"datasetGenerator\");\n  initComponents();\n  table.setDefaultRenderer(JLabel.class,new Renderer());\n  table.setColumnSelectionAllowed(false);\n  table.setRowSelectionAllowed(false);\n  table.setGridColor(GRID_COLOR);\n  JTableHeader header=table.getTableHeader();\n  header.setReorderingAllowed(false);\n  GUIUtilities.setTableHeader(header);\n  model=new Model(datasetGenerator);\n  table.setModel(model);\n  this.locker=locker;\n}\n", "docstring": "it creates a new instance of this panel .", "partition": "test"}
{"idx": "6185", "code": "public void append(File file,FTPDataTransferListener listener) throws IllegalStateException, FileNotFoundException, IOException, FTPIllegalReplyException, FTPException, FTPDataTransferException, FTPAbortedException {\n  if (!file.exists()) {\n    throw new FileNotFoundException(file.getAbsolutePath());\n  }\n  InputStream inputStream=null;\n  try {\n    inputStream=new FileInputStream(file);\n  }\n catch (  IOException e) {\n    throw new FTPDataTransferException(e);\n  }\n  try {\n    append(file.getName(),inputStream,0,listener);\n  }\n catch (  IllegalStateException e) {\n    throw e;\n  }\ncatch (  IOException e) {\n    throw e;\n  }\ncatch (  FTPIllegalReplyException e) {\n    throw e;\n  }\ncatch (  FTPException e) {\n    throw e;\n  }\ncatch (  FTPDataTransferException e) {\n    throw e;\n  }\ncatch (  FTPAbortedException e) {\n    throw e;\n  }\n finally {\n    if (inputStream != null) {\n      try {\n        inputStream.close();\n      }\n catch (      Throwable t) {\n        ;\n      }\n    }\n  }\n}\n", "docstring": "this method uploads a file to the remote server . calling this method blocks the current thread until the operation is completed . the operation could be interrupted by another thread calling abortcurrentdatatransfer ( ) . the method will break with a ftpabortedexception .", "partition": "test"}
{"idx": "6186", "code": "public static boolean isScopedName(String name){\n  return name.indexOf('.') != -1;\n}\n", "docstring": "used to detect scoped attributes .", "partition": "test"}
{"idx": "6187", "code": "public Input(IoBuffer buf){\n  super(buf);\n  amf3_mode=0;\n  stringReferences=new ArrayList<String>();\n  classReferences=new ArrayList<ClassReference>();\n}\n", "docstring": "creates input object for amf3 from byte buffer", "partition": "test"}
{"idx": "6188", "code": "public static Properties loadConfigFile(String path){\n  Properties property=null;\n  File file=new File(path);\n  if (file.exists() && file.canRead()) {\n    try {\n      property=new Properties();\n      property.load(new FileReader(file.getAbsolutePath()));\n    }\n catch (    FileNotFoundException e) {\n      e.printStackTrace();\n    }\ncatch (    IOException e) {\n      e.printStackTrace();\n    }\n  }\n  return property;\n}\n", "docstring": "searching the specified configuration file and return a properties", "partition": "test"}
{"idx": "6189", "code": "protected static void toEPLViews(StringWriter writer,List<View> views){\n  if ((views != null) && (views.size() != 0)) {\n    writer.write(\'.\');\n    String delimiter=\"\";\n    for (    View view : views) {\n      writer.write(delimiter);\n      view.toEPL(writer);\n      delimiter=\".\";\n    }\n  }\n}\n", "docstring": "renders the views onto the projected stream .", "partition": "test"}
{"idx": "6190", "code": "protected void removeDatabaseListeners(){\n  databaseListeners.clear();\n}\n", "docstring": "removes all database listeners added .", "partition": "test"}
{"idx": "6191", "code": "public void addGenericAttr(GenericAttr g){\n  generic.addElement(g);\n}\n", "docstring": "add a generic attribute to the field . a generic attribute contains a stream of uninterpreted bytes which is ignored by the vm ( as long as its name doesn \"'\" t conflict with other names for attributes that are understood by the vm )", "partition": "test"}
{"idx": "6192", "code": "private List<FahrzeitEvent> addFahrtInfoToFahrzeitEvents(List<FahrtEvent> fahrtEvents,List<FahrzeitEvent> fahrzeitEvents,boolean keepFahrzeitEventsWithoutFahrtEvent){\n  List<FahrzeitEvent> fahrzeitEventsOut=new LinkedList<FahrzeitEvent>();\n  Map<String,FahrtEvent> rblDateKursDateTimeIst2FahrtEventMap=new HashMap<String,FahrtEvent>();\n  Set<String> searchStrings=new TreeSet<String>();\n  for (  FahrtEvent fahrtEvent : fahrtEvents) {\n    String searchId=String.valueOf(fahrtEvent.getRblDate()) + String.valueOf(fahrtEvent.getKurs()) + fahrtEvent.getDepartureDateIst()+ fahrtEvent.getDepartureTimeIst();\n    if (searchStrings.contains(searchId)) {\n      log.warn(\"Search string already exists. This should not happen. \" + searchId);\n    }\n else {\n      searchStrings.add(searchId);\n      rblDateKursDateTimeIst2FahrtEventMap.put(searchId,fahrtEvent);\n    }\n  }\n  int numberOfMissingFahrtEvents=0;\n  for (  FahrzeitEvent fahrzeitEvent : fahrzeitEvents) {\n    String searchId=String.valueOf(fahrzeitEvent.getRblDate()) + String.valueOf(fahrzeitEvent.getKurs()) + fahrzeitEvent.getDepartureDateIst()+ fahrzeitEvent.getDepartureTimeIst();\n    FahrtEvent fahrtEvent=rblDateKursDateTimeIst2FahrtEventMap.get(searchId);\n    if (fahrtEvent == null) {\n      numberOfMissingFahrtEvents++;\n      if (keepFahrzeitEventsWithoutFahrtEvent) {\n        fahrzeitEventsOut.add(fahrzeitEvent);\n      }\n    }\n else {\n      fahrzeitEvent.add(fahrtEvent);\n      fahrzeitEventsOut.add(fahrzeitEvent);\n    }\n  }\n  log.info(numberOfMissingFahrtEvents + \" fahrzeit events could not be linked to a fahrt event\");\n  log.info(\"Returning \" + fahrzeitEventsOut.size() + \" fahrzeitEvents\");\n  return fahrzeitEventsOut;\n}\n", "docstring": "link fahrzeit events to the corresponding fahrt event", "partition": "test"}
{"idx": "6193", "code": "private static Object newInstanceNoServiceLoader(Class<?> providerClass){\n  if (System.getSecurityManager() == null) {\n    return null;\n  }\n  try {\n    Method creationMethod=providerClass.getDeclaredMethod(\"newTransformerFactoryNoServiceLoader\");\n    return creationMethod.invoke(null,(Object[])null);\n  }\n catch (  NoSuchMethodException exc) {\n    return null;\n  }\ncatch (  Exception exc) {\n    return null;\n  }\n}\n", "docstring": "try to construct using newtransformerfactorynoserviceloader method if available .", "partition": "test"}
{"idx": "6194", "code": "private void checkUUID(String uuid,int code){\n  checkHash(UUID.fromString(uuid),code);\n}\n", "docstring": "check unique id and generated hash code .", "partition": "test"}
{"idx": "6195", "code": "@Override protected void prepareWrite(WritableByteChannel channel) throws Exception {\n  os=Channels.newOutputStream(channel);\n}\n", "docstring": "creates the output stream that elements will be written to .", "partition": "test"}
{"idx": "6196", "code": "public void run(){\n  try {\n    boolean cleanRemoteSessions=false;\nsynchronized (this) {\n      Collection<StateInfo> infos=new ArrayList<>();\n      infos.addAll(servers.values());\n      infos.addAll(sites.values());\n      for (      StateInfo info : infos) {\n        info.isUp=checkServerUp(info);\n        if (!info.isUp) {\n          down.add(info.id);\n        }\n else {\n          if (!down.isEmpty() && down.remove(info.id)) {\n            cleanRemoteSessions=true;\n          }\n        }\n      }\n    }\n    if (cleanRemoteSessions) {\n      foreignSessionHandler.cleanUpRemoteSessions();\n    }\n  }\n catch (  Exception ex) {\n    sessionDebug.error(\"cleanRemoteSessions Background thread has encountered an Exception: \" + ex.getMessage(),ex);\n  }\n}\n", "docstring": "monitoring logic used by background thread", "partition": "test"}
{"idx": "6197", "code": "private void writeObject(java.io.ObjectOutputStream p_stream) throws java.io.IOException {\n  p_stream.defaultWriteObject();\n  p_stream.writeInt(trace_angle_restriction.get_no());\n}\n", "docstring": "writes an instance of this class to a file", "partition": "test"}
{"idx": "6198", "code": "public Builder addHeader(String name,String value){\n  headers.add(new Header(name,value));\n  return this;\n}\n", "docstring": "adds the supplied request header .", "partition": "test"}
{"idx": "6199", "code": "public static double normalCDF(double x){\n  return (0.5 * (1.0 + (erf(x / (Math.sqrt(2.0))))));\n}\n", "docstring": "computes an approximation to normalcdf ( x ) .", "partition": "test"}
{"idx": "6200", "code": "public void removeResult(String name){\n  StringBuffer buff=m_Results.get(name);\n  if (buff != null) {\n    m_Results.remove(name);\n    m_Model.removeElement(name);\n    m_Objs.remove(name);\n    System.gc();\n  }\n}\n", "docstring": "removes one of the result buffers from the history . any windows currently displaying the contents of the buffer are not affected .", "partition": "test"}
{"idx": "6201", "code": "private void addEntry(){\n  filterModel.addNewEntry();\n  extentModel.populate(null);\n  removeFTCButton.setEnabled(false);\n  addExtentButton.setEnabled(false);\n  removeExtentButton.setEnabled(false);\n}\n", "docstring": "adds a new feature type constraint entry .", "partition": "test"}
{"idx": "6202", "code": "double[][] CalcTheoreticalSVValues(Variogram vario,double MaximumDisplyDistanst){\n  double[][] res=new double[2 * NumberOfLags + 1][2];\n  for (int i=0; i < res.length; i++) {\n    res[i][0]=i * MaximumDisplyDistanst / (2 * NumberOfLags);\nswitch (vario.Type) {\ncase EXPONENTIAL:\n      if (res[i][0] != 0) {\n        res[i][1]=vario.Nugget + vario.Sill * (1 - Math.exp(-res[i][0] / vario.Range));\n      }\n else {\n        res[i][1]=vario.Nugget;\n      }\n    break;\ncase GAUSSIAN:\n  if (res[i][0] != 0) {\n    res[i][1]=vario.Nugget + vario.Sill * (1 - Math.exp(-3 * (Math.pow(res[i][0],2)) / (Math.pow(vario.Range,2))));\n  }\n else {\n    res[i][1]=vario.Nugget;\n  }\nbreak;\ncase SPHERICAL:\nif (res[i][0] > vario.Range) {\nres[i][1]=vario.Nugget + vario.Sill;\n}\n else if (res[i][0] > 0 && res[i][0] <= vario.Range) {\nres[i][1]=vario.Nugget + vario.Sill * (1.5 * res[i][0] / vario.Range - 0.5 * Math.pow((res[i][0] / vario.Range),3));\n}\n else {\nres[i][1]=vario.Nugget;\n}\nbreak;\n}\n}\nreturn res;\n}\n", "docstring": "calculates the points for drawing the theoretical variogram", "partition": "test"}
{"idx": "6203", "code": "public DExportPrivateKeyOpenSsl(JFrame parent,String entryAlias,PasswordQualityConfig passwordQualityConfig){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  this.entryAlias=entryAlias;\n  this.passwordQualityConfig=passwordQualityConfig;\n  initComponents();\n}\n", "docstring": "creates a new dexportprivatekeyopenssl dialog .", "partition": "test"}
{"idx": "6204", "code": "public BigDecimal sum(String sqlExpression){\n  return aggregate(sqlExpression,AGGREGATE_SUM);\n}\n", "docstring": "sum sqlexpression for items that match query criteria", "partition": "test"}
{"idx": "6205", "code": "@Override public int calculateOffsetX(){\n  return (int)(Math.cos(this.angle) * this.distance) - this.shadowSize;\n}\n", "docstring": "calculates the x - offset for drawing the shadow image relative to the source .", "partition": "test"}
{"idx": "6206", "code": "private <T>void runTestWrite(XmlWriter<T> writer,List<T> bundle,List<String> expected) throws Exception {\n  File tmpFile=tmpFolder.newFile(\"foo.txt\");\n  try (FileOutputStream fileOutputStream=new FileOutputStream(tmpFile)){\n    writeBundle(writer,bundle,fileOutputStream.getChannel());\n  }\n   List<String> lines=new ArrayList<>();\n  try (BufferedReader reader=new BufferedReader(new FileReader(tmpFile))){\n    for (; ; ) {\n      String line=reader.readLine();\n      if (line == null) {\n        break;\n      }\n      line=line.trim();\n      if (line.length() > 0) {\n        lines.add(line);\n      }\n    }\n    assertEquals(expected,lines);\n  }\n }\n", "docstring": "write a bundle with an xmlwriter and verify the output is expected .", "partition": "test"}
{"idx": "6207", "code": "public String addDays(Object odays,String format){\n  int days=FunctionHandler.getInt(odays);\n  Calendar now=Calendar.getInstance();\n  now.add(Calendar.DAY_OF_YEAR,days);\n  DateFormat formatter=getFormatter(format);\n  return formatter.format(now.getTime());\n}\n", "docstring": "get the date x days from now .", "partition": "test"}
{"idx": "6208", "code": "private static File createTempFile(Context context,@Nullable String mimeType) throws IOException {\n  File externalCacheDir=context.getExternalCacheDir();\n  File internalCacheDir=context.getCacheDir();\n  File cacheDir;\n  if (externalCacheDir == null && internalCacheDir == null) {\n    throw new IOException(\"No cache directory available\");\n  }\n  if (externalCacheDir == null) {\n    cacheDir=internalCacheDir;\n  }\n else   if (internalCacheDir == null) {\n    cacheDir=externalCacheDir;\n  }\n else {\n    cacheDir=externalCacheDir.getFreeSpace() > internalCacheDir.getFreeSpace() ? externalCacheDir : internalCacheDir;\n  }\n  return File.createTempFile(TEMP_FILE_PREFIX,getFileExtensionForType(mimeType),cacheDir);\n}\n", "docstring": "create a temporary file in the cache directory on either internal or external storage , whichever is available and has more free space .", "partition": "test"}
{"idx": "6209", "code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(4);\n  newVector.addElement(new Option(\"\\tRandom number seed for cross validation\\n\" + \"\\t(default = 1)\",\"S\",1,\"-S <seed>\"));\n  newVector.addElement(new Option(\"\\tNumber of folds for cross validation\\n\" + \"\\t(default = 10)\",\"F\",1,\"-F <folds>\"));\n  newVector.addElement(new Option(\"\\tUse training data for evaluation rather than cross validaton\",\"D\",0,\"-D\"));\n  newVector.addElement(new Option(\"\\tMinimum number of objects in a bucket\\n\" + \"\\t(passed on to \" + \"OneR, default = 6)\",\"B\",1,\"-B <minimum bucket size>\"));\n  return newVector.elements();\n}\n", "docstring": "returns an enumeration describing the available options .", "partition": "test"}
{"idx": "6210", "code": "public boolean removeEntry(int xIndex,int dataSetIndex){\n  if (dataSetIndex >= mDataSets.size())   return false;\n  T dataSet=mDataSets.get(dataSetIndex);\n  Entry e=dataSet.getEntryForXIndex(xIndex);\n  return removeEntry(e,dataSetIndex);\n}\n", "docstring": "removes the entry object at the given xindex from the dataset at the specified index . returns true if an entry was removed , false if no entry was found that meets the specified requirements .", "partition": "test"}
{"idx": "6211", "code": "private void runReadTest(byte[] input,CompressionMode mode) throws IOException {\n  runReadTest(input,mode,mode);\n}\n", "docstring": "run a single read test , writing and reading back input with the given compression mode .", "partition": "test"}
{"idx": "6212", "code": "public static void close(@Nullable Context rsrc,@Nullable IgniteLogger log){\n  if (rsrc != null)   try {\n    rsrc.close();\n  }\n catch (  NamingException e) {\n    warn(log,\"Failed to close resource: \" + e.getMessage());\n  }\n}\n", "docstring": "closes given resource logging possible checked exception .", "partition": "test"}
{"idx": "6213", "code": "public WritableRaster createCompatibleWritableRaster(int w,int h){\n  if (w <= 0 || h <= 0) {\n    throw new RasterFormatException(\"negative \" + ((w <= 0) ? \"width\" : \"height\"));\n  }\n  SampleModel sm=sampleModel.createCompatibleSampleModel(w,h);\n  return new IntegerInterleavedRaster(sm,new Point(0,0));\n}\n", "docstring": "creates a raster with the same band layout but using a different width and height , and with new zeroed data arrays .", "partition": "test"}
{"idx": "6214", "code": "public static String[] schedulerCommandArgs(Config config,Config runtime,List<Integer> freePorts){\n  if (freePorts.size() < PORTS_REQUIRED_FOR_SCHEDULER) {\n    throw new RuntimeException(\"Failed to find enough ports for executor\");\n  }\n  for (  int port : freePorts) {\n    if (port == -1) {\n      throw new RuntimeException(\"Failed to find available ports for executor\");\n    }\n  }\n  int httpPort=freePorts.get(0);\n  List<String> commands=new ArrayList<>();\n  commands.add(\"--cluster\");\n  commands.add(Context.cluster(config));\n  commands.add(\"--role\");\n  commands.add(Context.role(config));\n  commands.add(\"--environment\");\n  commands.add(Context.environ(config));\n  commands.add(\"--topology_name\");\n  commands.add(Context.topologyName(config));\n  commands.add(\"--topology_bin\");\n  commands.add(Context.topologyBinaryFile(config));\n  commands.add(\"--http_port\");\n  commands.add(Integer.toString(httpPort));\n  return commands.toArray(new String[0]);\n}\n", "docstring": "util method to get the arguments to the heron scheduler .", "partition": "test"}
{"idx": "6215", "code": "public DocumentAnalysisRequest addDocument(SolrInputDocument doc){\n  documents.add(doc);\n  return this;\n}\n", "docstring": "adds a document to be analyzed .", "partition": "test"}
{"idx": "6216", "code": "public final Key doPhase(Key key,boolean lastPhase) throws InvalidKeyException, IllegalStateException {\n  chooseFirstProvider();\n  return spi.engineDoPhase(key,lastPhase);\n}\n", "docstring": "executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement .", "partition": "test"}
{"idx": "6217", "code": "public SimpleSystemPermissionSet(){\n}\n", "docstring": "creates a new empty simplesystempermissionset .", "partition": "test"}
{"idx": "6218", "code": "@Override public final void addBezierCurveY(final float x,final float y,final float x3,final float y3){\n  elements.add(new QuadCurveTo(x,y,x3,y3));\n  currentPos[0]=x3;\n  currentPos[1]=y3;\n}\n", "docstring": "add a curve to the shape", "partition": "test"}
{"idx": "6219", "code": "public void readBucketsFromPrefs(){\n  SharedPreferences prefs=mContext.getSharedPreferences(SHARED_PREFS,0);\n  Set<String> buckets=prefs.getStringSet(PREF_BUCKETS_IDS,new TreeSet<String>());\n  mBuckets.clear();\n  for (  String bucketId : buckets) {\n    AutoMixBucket bucket=restoreBucketFromId(bucketId);\n    mBuckets.add(bucket);\n  }\n}\n", "docstring": "restore the automix buckets stored in sharedpreferences", "partition": "test"}
{"idx": "6220", "code": "@Override public void acceptAppOffer(Offer offer){\n  int index=getIndex(offer,appOffers);\n  if (index != -1) {\n    appOffers.remove(index);\n    appOfferStream.onNext(offer);\n  }\n  index=getIndex(offer,acceptedOffers);\n  if (index == -1) {\n    acceptedOffers.add(offer);\n  }\n}\n", "docstring": "accept app offer remove from app offers list update corresponding app usage", "partition": "test"}
{"idx": "6221", "code": "private void injectDependencies(){\n  EasyMVPApplication easyMVPApplication=(EasyMVPApplication)getApplication();\n  List<Object> activityScopeModules=(getModules() != null) ? getModules() : new ArrayList<>();\n  activityScopeModules.add(new ActivityModule(this));\n  activityScopeGraph=easyMVPApplication.buildGraphWithAditionalModules(activityScopeModules);\n  inject(this);\n}\n", "docstring": "generates activity scope graph using activitymodule plus additional modules provided by inheritance .", "partition": "test"}
{"idx": "6222", "code": "public void writeRequest(){\n  Object lock=new Object();\nsynchronized (lock) {\nsynchronized (this) {\n      boolean goAheadWithWrite=writerLocks.size() == 0 && currentReaders == 0 && currentWriters == 0;\n      if (goAheadWithWrite) {\n        ++currentWriters;\n        return;\n      }\n      writerLocks.addLast(lock);\n    }\n    try {\n      lock.wait();\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}\n", "docstring": "request the write lock . block until a write operation can be performed safely . write requests are guaranteed to be executed in the order received . pending read requests take precedence over all write requests . this call must be followed by a call to writedone ( ) when the write operation completes .", "partition": "test"}
{"idx": "6223", "code": "public long readLocalDate() throws IOException {\n  expectStartTag(\"date\");\n  if (localCalendar == null)   localCalendar=Calendar.getInstance();\n  long value=parseDate(localCalendar);\n  expectEndTag(\"date\");\n  return value;\n}\n", "docstring": "reads a date value from the input stream .", "partition": "test"}
{"idx": "6224", "code": "public void removeSelectionListener(final SelectionListener listener){\n  checkWidget();\n  listeners.remove(listener);\n}\n", "docstring": "removes the listener from the collection of listeners who will be notified when the user changes the receiver \"'\" s value .", "partition": "test"}
{"idx": "6225", "code": "private synchronized String readInputStream(InputStreamReader inputStreamReader) throws IOException, BadLocationException {\n  BufferedReader bufferedReader=null;\n  try {\n    bufferedReader=new BufferedReader(inputStreamReader);\n    String newLine=\"\\n\";\n    StringBuffer sb=new StringBuffer();\n    String line;\n    while ((line=bufferedReader.readLine()) != null) {\n      sb.append(line + newLine);\n    }\n    return sb.toString();\n  }\n  finally {\n    if (null != bufferedReader)     bufferedReader.close();\n    if (null != inputStreamReader)     inputStreamReader.close();\n  }\n}\n", "docstring": "read an imputstream reader", "partition": "test"}
{"idx": "6226", "code": "private List<Map<String,Object>> typeParameters(List<TypeParameter> tpl,Declaration from){\n  if (tpl != null && !tpl.isEmpty()) {\n    List<Map<String,Object>> l=new ArrayList<>(tpl.size());\n    for (    TypeParameter tp : tpl) {\n      l.add(typeParameterMap(tp,from));\n    }\n    return l;\n  }\n  return null;\n}\n", "docstring": "create a list of maps from the list of type parameters .", "partition": "test"}
{"idx": "6227", "code": "private static boolean withinTwo(INode n,INode goal){\n  DoubleLinkedList<IMove> moves=n.validMoves();\n  for (Iterator<IMove> it=moves.iterator(); it.hasNext(); ) {\n    IMove move=it.next();\n    INode successor=n.copy();\n    move.execute(successor);\n    if (withinOne(successor,goal)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "see if within two moves of solution .", "partition": "test"}
{"idx": "6228", "code": "public PennTreebankReader(String treebankHome,String[] sections,String parseViewName) throws Exception {\n  super(CorpusReaderConfigurator.buildResourceManager(PENN_TREEBANK_WSJ,treebankHome));\n  this.parseViewName=parseViewName;\n  combinedWSJHome=treebankHome;\n  if (sections == null)   this.sections=IOUtils.lsDirectories(combinedWSJHome);\n else {\n    this.sections=new String[sections.length];\n    System.arraycopy(sections,0,this.sections,0,sections.length);\n  }\n  updateCurrentFiles();\n}\n", "docstring": "reads the specified sections from penn treebank", "partition": "test"}
{"idx": "6229", "code": "@Override public void closeWrite() throws IOException {\n  if (_isCloseWrite) {\n    return;\n  }\n  _isCloseWrite=true;\n  OutputStream os=_os;\n  _os=null;\n  boolean isShutdownOutput=false;\n  if (_s instanceof SSLSocket) {\n    log.finer(L.l(\"sslSocket can not be half-closed\"));\n    return;\n  }\n else   if (_s != null) {\n    try {\n      _s.shutdownOutput();\n      isShutdownOutput=true;\n    }\n catch (    UnsupportedOperationException e) {\n      log.log(Level.FINEST,e.toString(),e);\n    }\ncatch (    Exception e) {\n      log.finer(e.toString());\n      log.log(Level.FINEST,e.toString(),e);\n    }\n  }\n  if (!isShutdownOutput && os != null) {\n    os.close();\n  }\n}\n", "docstring": "closes the write half of the stream .", "partition": "test"}
{"idx": "6230", "code": "protected void applyRowChangeData(RowChangeData data,List<ReplOption> options,String sourceDbmsType) throws ReplicatorException {\n  if (options != null) {\n    try {\n      if (applySessionVariables(null,options)) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Applying changed session variables\");\n        }\n        executePendingBatch();\n        statement.executeBatch();\n        statement.clearBatch();\n      }\n    }\n catch (    SQLException e) {\n      throw new ApplierException(\"Failed to apply session variables\",e);\n    }\n  }\n  List<ReplOption> rowOptions=data.getOptions();\n  if (rowOptions != null) {\n    try {\n      if (applySessionVariables(null,rowOptions)) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Applying changed row option variables\");\n        }\n        executePendingBatch();\n        statement.executeBatch();\n        statement.clearBatch();\n      }\n    }\n catch (    SQLException e) {\n      throw new ApplierException(\"Failed to apply session variables\",e);\n    }\n  }\n  for (  OneRowChange row : data.getRowChanges()) {\n    applyOneRowChangePrepared(row,sourceDbmsType);\n  }\n}\n", "docstring": "apply one or more row changes .", "partition": "test"}
{"idx": "6231", "code": "public void receiveRedundancy(){\n  try {\n    while (true) {\n      if (mIn.read(mInBuffer) <= 0)       return;\n    }\n  }\n catch (  IOException e) {\n  }\n}\n", "docstring": "receive socket redundancy data", "partition": "test"}
{"idx": "6232", "code": "MVStore(HashMap<String,Object> config){\n  Object o=config.get(\"compress\");\n  this.compressionLevel=o == null ? 0 : (Integer)o;\n  String fileName=(String)config.get(\"fileName\");\n  o=config.get(\"pageSplitSize\");\n  if (o == null) {\n    pageSplitSize=fileName == null ? 4 * 1024 : 16 * 1024;\n  }\n else {\n    pageSplitSize=(Integer)o;\n  }\n  o=config.get(\"backgroundExceptionHandler\");\n  this.backgroundExceptionHandler=(UncaughtExceptionHandler)o;\n  meta=new MVMap<String,String>(StringDataType.INSTANCE,StringDataType.INSTANCE);\n  HashMap<String,Object> c=New.hashMap();\n  c.put(\"id\",0);\n  c.put(\"createVersion\",currentVersion);\n  meta.init(this,c);\n  fileStore=(FileStore)config.get(\"fileStore\");\n  if (fileName == null && fileStore == null) {\n    cache=null;\n    cacheChunkRef=null;\n    return;\n  }\n  if (fileStore == null) {\n    fileStoreIsProvided=false;\n    fileStore=new FileStore();\n  }\n else {\n    fileStoreIsProvided=true;\n  }\n  retentionTime=fileStore.getDefaultRetentionTime();\n  boolean readOnly=config.containsKey(\"readOnly\");\n  o=config.get(\"cacheSize\");\n  int mb=o == null ? 16 : (Integer)o;\n  if (mb > 0) {\n    CacheLongKeyLIRS.Config cc=new CacheLongKeyLIRS.Config();\n    cc.maxMemory=mb * 1024L * 1024L;\n    o=config.get(\"cacheConcurrency\");\n    if (o != null) {\n      cc.segmentCount=(Integer)o;\n    }\n    cache=new CacheLongKeyLIRS<Page>(cc);\n    cc.maxMemory/=4;\n    cacheChunkRef=new CacheLongKeyLIRS<PageChildren>(cc);\n  }\n  o=config.get(\"autoCommitBufferSize\");\n  int kb=o == null ? 1024 : (Integer)o;\n  autoCommitMemory=kb * 1024 * 19;\n  o=config.get(\"autoCompactFillRate\");\n  autoCompactFillRate=o == null ? 50 : (Integer)o;\n  char[] encryptionKey=(char[])config.get(\"encryptionKey\");\n  try {\n    if (!fileStoreIsProvided) {\n      fileStore.open(fileName,readOnly,encryptionKey);\n    }\n    if (fileStore.size() == 0) {\n      creationTime=getTimeAbsolute();\n      lastCommitTime=creationTime;\n      storeHeader.put(\"H\",2);\n      storeHeader.put(\"blockSize\",BLOCK_SIZE);\n      storeHeader.put(\"format\",FORMAT_WRITE);\n      storeHeader.put(\"created\",creationTime);\n      writeStoreHeader();\n    }\n else {\n      readStoreHeader();\n    }\n  }\n catch (  IllegalStateException e) {\n    panic(e);\n  }\n finally {\n    if (encryptionKey != null) {\n      Arrays.fill(encryptionKey,(char)0);\n    }\n  }\n  lastCommitTime=getTimeSinceCreation();\n  o=config.get(\"autoCommitDelay\");\n  int delay=o == null ? 1000 : (Integer)o;\n  setAutoCommitDelay(delay);\n}\n", "docstring": "create and open the store .", "partition": "test"}
{"idx": "6233", "code": "public static boolean isValidVector(Vector2f vector){\n  if (vector == null)   return false;\n  if (Float.isNaN(vector.x) || Float.isNaN(vector.y))   return false;\n  if (Float.isInfinite(vector.x) || Float.isInfinite(vector.y))   return false;\n  return true;\n}\n", "docstring": "check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .", "partition": "test"}
{"idx": "6234", "code": "protected int maxDepth(Layout.Node node){\n  int depth=0;\n  for (int i=0; i < node.numChildren(); i++) {\n    Layout.Node child=node.getChild(i);\n    depth=Math.max(depth,maxDepth(child));\n  }\n  return depth + 1;\n}\n", "docstring": "compute the depth of the graph .", "partition": "test"}
{"idx": "6235", "code": "private static URL[] pathToURLs(String path) throws MalformedURLException {\nsynchronized (pathToURLsCache) {\n    Object[] v=(Object[])pathToURLsCache.get(path);\n    if (v != null) {\n      return (URL[])v[0];\n    }\n  }\n  StringTokenizer st=new StringTokenizer(path);\n  URL[] urls=new URL[st.countTokens()];\n  for (int i=0; st.hasMoreTokens(); i++) {\n    urls[i]=new URL(st.nextToken());\n  }\nsynchronized (pathToURLsCache) {\n    pathToURLsCache.put(path,new Object[]{urls,new SoftReference(path)});\n  }\n  return urls;\n}\n", "docstring": "convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid .", "partition": "test"}
{"idx": "6236", "code": "private void addFinal(Object[] stacks){\n  Object[] input=new Object[inputSize], output=new Object[outputSize];\n  for (int i=0; i < stacks.length; i++) {\n    if (i < inputSize) {\n      input[i]=stacks[i];\n    }\n else     if (!(i - inputSize > outputSize)) {\n      output[i - inputSize]=stacks[i];\n    }\n else {\n      throw new RuntimeException(\"Recipe is too big!\");\n    }\n  }\n  addRecipe(input,output);\n}\n", "docstring": "separates the recipe into an input and output list", "partition": "test"}
{"idx": "6237", "code": "protected void fireConnectionClosed(){\n  ConnectionEvent evt=new ConnectionEvent(this);\n  for (  ConnectionEventListener listener : connectionEventListeners) {\n    listener.connectionClosed(evt);\n  }\n}\n", "docstring": "helper method to fire the connectionclosed event .", "partition": "test"}
{"idx": "6238", "code": "public static void putIntVolatile(Object obj,long off,int val){\n  UNSAFE.putIntVolatile(obj,off,val);\n}\n", "docstring": "stores integer value with volatile semantic .", "partition": "test"}
{"idx": "6239", "code": "public static URI createUriFromServerSet(Set<InetSocketAddress> serverInetSet,String path,String protocol) throws URISyntaxException {\n  InetSocketAddress inetSocketAddress=ServiceUtils.selectRandomItem(serverInetSet);\n  String address=inetSocketAddress.getHostString();\n  int port=inetSocketAddress.getPort();\n  URI uri=new URI(protocol,null,address,port,path,null,null);\n  return uri;\n}\n", "docstring": "returns the uri of a random server .", "partition": "test"}
{"idx": "6240", "code": "public PlotNavigator(Plot plot,String... axesNames){\n  this(plot,Arrays.asList(axesNames));\n}\n", "docstring": "initializes a new instance that is responsible for zooming and panning the axes with the specified names of the specified plot .", "partition": "test"}
{"idx": "6241", "code": "public void addColumn(Class classType,boolean readOnly,String header){\n  m_modelHeaderClass.add(classType);\n  setColumnReadOnly(m_modelHeaderClass.size() - 1,readOnly);\n  addColumn(header);\n  WListItemRenderer renderer=(WListItemRenderer)getItemRenderer();\n  renderer.setColumnClass((renderer.getNoColumns() - 1),classType);\n  return;\n}\n", "docstring": "set the attributes of the column .", "partition": "test"}
{"idx": "6242", "code": "PointComparator(int dimension){\n  this.dimension=dimension;\n}\n", "docstring": "constructs a new comparator on the given dimension", "partition": "test"}
{"idx": "6243", "code": "public static void addElement(Document doc,Element rootElement,String elementName,String typeIn,String isArrayIn,String partitionerIn){\n  Element element=doc.createElement(\"element\");\n  rootElement.appendChild(element);\n  Element name=doc.createElement(\"name\");\n  name.appendChild(doc.createTextNode(elementName));\n  element.appendChild(name);\n  Element type=doc.createElement(\"type\");\n  type.appendChild(doc.createTextNode(typeIn));\n  element.appendChild(type);\n  if (isArrayIn.equals(\"true\")) {\n    element.appendChild(doc.createElement(\"isArray\"));\n  }\n  if (partitionerIn != null) {\n    Element partitioner=doc.createElement(\"partitioner\");\n    partitioner.appendChild(doc.createTextNode(partitionerIn));\n    element.appendChild(partitioner);\n  }\n}\n", "docstring": "helper method to add elements to the test data schema", "partition": "test"}
{"idx": "6244", "code": "public final void addInstanceOf(String className){\n  Reject.ifNull(className);\n  String value=className.trim();\n  if (!value.matches(CLASS_RE)) {\n    throw new IllegalArgumentException(\"\\\"\" + value + \"\\\" is not a valid Java class name\");\n  }\n  instanceOfInterfaces.add(value);\n}\n", "docstring": "add an class name which property values must implement .", "partition": "test"}
{"idx": "6245", "code": "public boolean isDisplayedExpectingComponents(){\n  boolean result=false;\n  if (conditions.isConditionMet(visibilityOf(window))) {\n    if (components.isEmpty()) {\n      closeButton.click();\n    }\n else {\n      result=true;\n    }\n  }\n  return result;\n}\n", "docstring": "this check contains a workaround for an issue in aem 6 . 1 , when after the deploy occasionally insert window contains an empty list .", "partition": "test"}
{"idx": "6246", "code": "private void processRunStartedTag(String identifier){\n  Pattern numTestsPattern=Pattern.compile(\"Running (\\\\d+) test[s]? from .*\");\n  Matcher numTests=numTestsPattern.matcher(identifier);\n  if (numTests.find()) {\n    try {\n      mNumTestsExpected=Integer.parseInt(numTests.group(1));\n    }\n catch (    NumberFormatException e) {\n      Log.e(LOG_TAG,\"Unable to determine number of tests expected, received: \" + numTests.group(1));\n    }\n  }\n  if (mNumTestsExpected > 0) {\n    reportTestRunStarted();\n    mNumTestsRun=0;\n    mTestRunInProgress=true;\n  }\n}\n", "docstring": "parses and stores the test identifier ( class and test name ) .", "partition": "test"}
{"idx": "6247", "code": "public StyledString insert(char ch,int offset) throws StringIndexOutOfBoundsException {\n  if (offset < 0 || offset > builder.length()) {\n    throw new StringIndexOutOfBoundsException(\"Invalid offset (\" + offset + \")\");\n  }\n  builder.insert(offset,ch);\n  return this;\n}\n", "docstring": "inserts the character at the given offset . the inserted character will get the styler that is already at the given offset .", "partition": "test"}
{"idx": "6248", "code": "public void addRoot(ProtoElement root){\n  roots.add(root);\n}\n", "docstring": "add a root element to the model . root elements are collected during merging and used to compute the transitively reachable set of referenced elements .", "partition": "test"}
{"idx": "6249", "code": "public void expandToObjectAndSelect(Object elementOrTreePath,int level){\n  if (checkBusy()) {\n    return;\n  }\n  Object parent=getParentElement(elementOrTreePath);\n  if (((parent != null) && getExpandedState(parent)) || isRootElement(elementOrTreePath)) {\n    Widget w=internalGetWidgetToSelect(elementOrTreePath);\n    if (null != w) {\n      List<Object> selectionList=new ArrayList<>();\n      selectionList.add(w);\n      setSelection(selectionList);\n      objectToSelect.set(null);\n    }\n else {\n      objectToSelect.set(elementOrTreePath);\n    }\n  }\n else {\n    objectToSelect.set(elementOrTreePath);\n    List<Object> objectsToExpand=createObjectList(parent,new ArrayList<>());\n    if (!objectsToExpand.isEmpty()) {\n      objectsToBeExpanded.addAll(objectsToExpand);\n      Widget w=internalExpand(elementOrTreePath,true);\n      if (w != null) {\n        internalExpandToLevel(w,level);\n      }\n    }\n else {\n      Widget w=internalGetWidgetToSelect(elementOrTreePath);\n      if (null != w) {\n        List<Object> selectionList=new ArrayList<>();\n        selectionList.add(w);\n        setSelection(selectionList);\n        objectToSelect.set(null);\n      }\n    }\n  }\n}\n", "docstring": "expands all ancestors of the given element or tree path so that the given element becomes visible in this viewer \"'\" s tree control , and then expands the subtree rooted at the given element to the given level . the element will be then selected .", "partition": "test"}
{"idx": "6250", "code": "public void appendCell(float value){\n  appendCell(String.valueOf(value));\n}\n", "docstring": "appends a new cell to the current row containing the provided float value .", "partition": "test"}
{"idx": "6251", "code": "public SVNChangeSetCollector(ISynchronizePageConfiguration configuration){\n  super(configuration);\n}\n", "docstring": "constructs a new svnchangesetcollector used to collect incoming change sets", "partition": "test"}
{"idx": "6252", "code": "public void ensureMaxSize(int maxWidth,int maxHeight,boolean keepProportions){\n  int width=canvas.getWidth();\n  int height=canvas.getHeight();\n  if (keepProportions) {\n    if (width > height) {\n      if (width > maxWidth) {\n        height=Math.round(height*=maxWidth / (double)width);\n        width=maxWidth;\n      }\n    }\n else {\n      if (height > maxHeight) {\n        width=Math.round(width*=maxHeight / (double)height);\n        height=maxHeight;\n      }\n    }\n  }\n else {\n    width=Math.min(width,maxWidth);\n    height=Math.min(height,maxHeight);\n  }\n  resize(width,height);\n}\n", "docstring": "ensure a max size for the image", "partition": "test"}
{"idx": "6253", "code": "public static boolean isNormalized(CharSequence src,java.text.Normalizer.Form form,int option){\n  return NormalizerBase.isNormalized(src.toString(),form,option);\n}\n", "docstring": "determines if the given sequence of char values is normalized .", "partition": "test"}
{"idx": "6254", "code": "@Override public String toString(boolean freq){\n  StringBuffer result=new StringBuffer();\n  result.append(m_attribute.name() + \" \");\nswitch (m_comparison) {\ncase EQUAL:\n    result.append(\"=\");\n  break;\ncase LESS_THAN_OR_EQUAL_TO:\nresult.append(\"<=\");\nbreak;\ncase GREATER_THAN:\nresult.append(\">\");\nbreak;\ndefault :\nbreak;\n}\nresult.append(\" \" + Utils.doubleToString(m_splitPoint,4));\nif (freq) {\nresult.append(\":\" + m_frequency);\n}\nreturn result.toString();\n}\n", "docstring": "a string representation of this item , ( i . e . < attribute name > < comparison operator > < item value > ) . this default implementation just prints the attribute name and ( optionally ) frequency information .", "partition": "test"}
{"idx": "6255", "code": "public static String unescapeSom(String s){\n  int idx=s.indexOf('\\\\');\n  if (idx < 0)   return s;\n  StringBuilder sb=new StringBuilder();\n  int last=0;\n  while (idx >= 0) {\n    sb.append(s.substring(last,idx));\n    last=idx + 1;\n    idx=s.indexOf('\\\\',idx + 1);\n  }\n  sb.append(s.substring(last));\n  return sb.toString();\n}\n", "docstring": "unescapes a som string fragment replacing \" \\ . \" with \" . \" .", "partition": "test"}
{"idx": "6256", "code": "void saveAsync(ColumnEntity entity,Duration ttl,Consumer<ColumnEntity> callBack) throws ExecuteAsyncQueryException, UnsupportedOperationException ;\n", "docstring": "saves an entity asynchronously", "partition": "test"}
{"idx": "6257", "code": "private static CopyState readCopyState(DataInput in) throws IOException {\n  byte[] infosBytes=new byte[in.readVInt()];\n  in.readBytes(infosBytes,0,infosBytes.length);\n  long gen=in.readVLong();\n  long version=in.readVLong();\n  Map<String,FileMetaData> files=CopyFilesHandler.readFilesMetaData(in);\n  int count=in.readVInt();\n  Set<String> completedMergeFiles=new HashSet<>();\n  for (int i=0; i < count; i++) {\n    completedMergeFiles.add(in.readString());\n  }\n  long primaryGen=in.readVLong();\n  return new CopyState(files,version,gen,infosBytes,completedMergeFiles,primaryGen,null);\n}\n", "docstring": "pulls copystate off the wire", "partition": "test"}
{"idx": "6258", "code": "private void beforeName() throws IOException {\n  JsonScope context=peek();\n  if (context == JsonScope.NONEMPTY_OBJECT) {\n    out.write(\',\');\n  }\n else   if (context != JsonScope.EMPTY_OBJECT) {\n    throw new IllegalStateException(\"Nesting problem: \" + stack);\n  }\n  newline();\n  replaceTop(JsonScope.DANGLING_NAME);\n}\n", "docstring": "inserts any necessary separators and whitespace before a name . also adjusts the stack to expect the name \"'\" s value .", "partition": "test"}
{"idx": "6259", "code": "@Transactional public void redeem(final String tokenNumber,final String service){\n  final Token token=tokenRepository.findByTokenNumberAndService(tokenNumber,service);\n  if (token == null)   throw new ApplicationRuntimeException(\"Token \" + tokenNumber + \" does not exist!\");\n  redeem(token);\n}\n", "docstring": "checks whether a token can be redeemed and then redeems it i . e . removes it from the database . if the token does not exist or has expired , it throws an exception .", "partition": "test"}
{"idx": "6260", "code": "public int lightenColor(int color,float factor){\n  float r=Color.red(color) * factor;\n  float g=Color.green(color) * factor;\n  float b=Color.blue(color) * factor;\n  int ir=Math.min(255,(int)r);\n  int ig=Math.min(255,(int)g);\n  int ib=Math.min(255,(int)b);\n  int ia=Color.alpha(color);\n  return (Color.argb(ia,ir,ig,ib));\n}\n", "docstring": "lighten the given color by the factor", "partition": "test"}
{"idx": "6261", "code": "private static String toDatabaseString(final OperandSize size){\nswitch (size) {\ncase BYTE:\n    return \"b1\";\ncase WORD:\n  return \"b2\";\ncase DWORD:\nreturn \"b4\";\ncase QWORD:\nreturn \"b8\";\ncase OWORD:\nreturn \"b16\";\ncase ADDRESS:\nreturn \"b4\";\ndefault :\nthrow new IllegalArgumentException(String.format(\"Error: Unknown operand size %s\",size));\n}\n}\n", "docstring": "returns the database string of a given operand size .", "partition": "test"}
{"idx": "6262", "code": "static String fileNameOfClass(final String className,String typeSuffix){\n  return className.replace(\'.\',\'/\') + \".\" + typeSuffix;\n}\n", "docstring": "get the file name of a class .", "partition": "test"}
{"idx": "6263", "code": "public void writePv(ProcessVar pv,int recursiveDepth){\n  writePv(pv,recursiveDepth,false);\n}\n", "docstring": "write a process variable as xml to an output stream", "partition": "test"}
{"idx": "6264", "code": "private static void assertQualNS(String qualNS) throws XMPException {\n  if (qualNS == null || qualNS.length() == 0) {\n    throw new XMPException(\"Empty qualifier namespace URI\",XMPError.BADSCHEMA);\n  }\n}\n", "docstring": "parameterasserts that a qualifier namespace is set .", "partition": "test"}
{"idx": "6265", "code": "public static StringBuilder formatTo(StringBuilder buf,float[] d,String sep,NumberFormat nf){\n  if (d == null) {\n    return buf.append(\"null\");\n  }\n  if (d.length == 0) {\n    return buf;\n  }\n  buf.append(nf.format(d[0]));\n  for (int i=1; i < d.length; i++) {\n    buf.append(sep);\n    buf.append(nf.format(d[i]));\n  }\n  return buf;\n}\n", "docstring": "formats the float array d with the specified number format .", "partition": "test"}
{"idx": "6266", "code": "public int removeViewpoints(int[] indices){\n  for (int i=indices.length - 1; i >= 0; --i)   viewpointList.remove(indices[i]);\n  viewpointIndex=indices[0] - 1;\n  if (viewpointList.size() == 0) {\n    viewpointIndex=-1;\n  }\n else   if (viewpointIndex < 0) {\n    viewpointIndex=viewpointList.size() - 1;\n  }\n  return (viewpointIndex);\n}\n", "docstring": "remove a viewpoint from the list", "partition": "test"}
{"idx": "6267", "code": "private void updateColor(){\n  try {\n    BreakpointConditionParser.evaluate(inputField.getText());\n    inputField.setBackground(Color.WHITE);\n  }\n catch (  final InvalidFormulaException e) {\n    inputField.setBackground(Color.RED);\n  }\n}\n", "docstring": "updates the color of the input field depending on whether the entered formula string is valid or not .", "partition": "test"}
{"idx": "6268", "code": "public void removeIgnoredView(View v){\n  ignoredViews.remove(v);\n}\n", "docstring": "remove a view from ignored views ;", "partition": "test"}
{"idx": "6269", "code": "public boolean writeHeader(OutputStream os){\n  try {\n    writeInt(os,CACHE_MAGIC);\n    writeString(os,key);\n    writeString(os,etag == null ? \"\" : etag);\n    writeLong(os,serverDate);\n    writeLong(os,lastModified);\n    writeLong(os,ttl);\n    writeLong(os,softTtl);\n    writeStringStringMap(responseHeaders,os);\n    os.flush();\n    return true;\n  }\n catch (  IOException e) {\n    VinciLog.d(\"%s\",e.toString());\n    return false;\n  }\n}\n", "docstring": "writes the contents of this cacheheader to the specified outputstream .", "partition": "test"}
{"idx": "6270", "code": "private static boolean ensureCurrent(LeasedResource resource){\n  return resource.getExpiration() > SystemTime.timeMillis();\n}\n", "docstring": "utility method that check for valid resource", "partition": "test"}
{"idx": "6271", "code": "public void toggleSectionSelected(int sectionIndex){\n  setSectionSelected(sectionIndex,!isSectionSelected(sectionIndex));\n}\n", "docstring": "toggle selection state of an entire section", "partition": "test"}
{"idx": "6272", "code": "public String combine(List<String> files,String outFile) throws Exception {\n  ArrayList<String> cmd=new ArrayList<String>();\n  cmd.add(soxBin);\n  for (  String file : files) {\n    cmd.add(file);\n  }\n  cmd.add(outFile);\n  int rc=execSox(cmd,callback);\n  if (rc != 0) {\n    throw new Exception(\"exit code: \" + rc);\n  }\n  return outFile;\n}\n", "docstring": "simple combiner sox file [ 0 ", "partition": "test"}
{"idx": "6273", "code": "void stopScrollingInstance(){\n  if (log.isLoggable(PlatformLogger.Level.FINER)) {\n    log.finer(\"Stop scrolling on \" + this);\n  }\n  i_scroller.stop();\n}\n", "docstring": "tell the instance scroller to stop scrolling . see 6243382 for more information", "partition": "test"}
{"idx": "6274", "code": "@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"FE_FLOATING_POINT_EQUALITY\",justification=\"OK to compare floating point\") protected void newInternalMinute(){\n  double origCurrent=mCurrentIntensity;\n  int origState=mState;\n  int steps=getNumberOfSteps();\n  if ((mTransitionDuration > 0) && (steps > 0)) {\n    double stepsPerMinute=steps / mTransitionDuration;\n    double stepSize=1 / (double)steps;\n    double intensityDiffPerMinute=stepSize * stepsPerMinute;\n    if (Math.abs(mCurrentIntensity - mTransitionTargetIntensity) != 0) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"before Target: \" + mTransitionTargetIntensity + \" Current: \"+ mCurrentIntensity);\n      }\n      if (mTransitionTargetIntensity > mCurrentIntensity) {\n        mCurrentIntensity=mCurrentIntensity + intensityDiffPerMinute;\n        if (mCurrentIntensity >= mTransitionTargetIntensity) {\n          mCurrentIntensity=mTransitionTargetIntensity;\n          if (mCurrentIntensity >= getMaxIntensity()) {\n            mState=ON;\n          }\n else {\n            mState=INTERMEDIATE;\n          }\n        }\n      }\n else {\n        mCurrentIntensity=mCurrentIntensity - intensityDiffPerMinute;\n        if (mCurrentIntensity <= mTransitionTargetIntensity) {\n          mCurrentIntensity=mTransitionTargetIntensity;\n          if (mCurrentIntensity <= getMinIntensity()) {\n            mState=OFF;\n          }\n else {\n            mState=INTERMEDIATE;\n          }\n        }\n      }\n      sendIntensity(mCurrentIntensity);\n      if (log.isDebugEnabled()) {\n        log.debug(\"after Target: \" + mTransitionTargetIntensity + \" Current: \"+ mCurrentIntensity);\n      }\n    }\n  }\n  if (origCurrent != mCurrentIntensity) {\n    firePropertyChange(\"CurrentIntensity\",Double.valueOf(origCurrent),Double.valueOf(mCurrentIntensity));\n    if (log.isDebugEnabled()) {\n      log.debug(\"firePropertyChange intensity \" + origCurrent + \" -> \"+ mCurrentIntensity);\n    }\n  }\n  if (origState != mState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(origState),Integer.valueOf(mState));\n    if (log.isDebugEnabled()) {\n      log.debug(\"firePropertyChange intensity \" + origCurrent + \" -> \"+ mCurrentIntensity);\n    }\n  }\n}\n", "docstring": "layout time has changed to a new minute . process effect that might be having on intensity . currently , this implementation assumes there \"'\" s a fixed number of steps between min and max brightness .", "partition": "test"}
{"idx": "6275", "code": "public void execute2(KahanObject in1,double in2){\n  if (Double.isInfinite(in1._sum) || Double.isInfinite(in2)) {\n    in1.set(Double.isInfinite(in2) ? in2 : in1._sum,0);\n    return;\n  }\n  double correction=in2 + in1._correction;\n  double sum=in1._sum + correction;\n  in1.set(sum,correction - (sum - in1._sum));\n}\n", "docstring": "simplified version of execute ( data in1 , double in2 ) without exception handling and casts .", "partition": "test"}
{"idx": "6276", "code": "public static Response newFixedLengthResponse(String msg){\n  return newFixedLengthResponse(Status.OK,NanoHTTPD.MIME_HTML,msg);\n}\n", "docstring": "create a text response with known length .", "partition": "test"}
{"idx": "6277", "code": "@Override public XMLEvent peek() throws XMLStreamException {\n  log.log(Level.FINE,\"peek()\");\n  if (!hasNext()) {\n    throw new XMLStreamException(\"The reader is depleted!\");\n  }\n  log.log(Level.FINE,\"peek(): {0}\",nextEvent);\n  return nextEvent;\n}\n", "docstring": "check the next xmlevent without reading it from the stream . returns null if the stream is at eof or has no more xmlevents . a call to peek ( ) will be equal to the next return of next ( ) .", "partition": "test"}
{"idx": "6278", "code": "public static String replaceEndPoint(String url,String endPoint){\n  return endPoint + url.replaceFirst(DEFAULT_ENDPOINT,\"\");\n}\n", "docstring": "replace the url end point ( schema + host + port ) with the given end point .", "partition": "test"}
{"idx": "6279", "code": "private void makeOkPath(){\n  path1.reset();\n  int w2=getMeasuredWidth() / 2;\n  int h2=getMeasuredHeight() / 2;\n  double a=Math.cos(Math.toRadians(25)) * getRadius();\n  double c=Math.sin(Math.toRadians(25)) * getRadius();\n  double l=Math.cos(Math.toRadians(53)) * 2 * a;\n  double b=Math.sin(Math.toRadians(53)) * l;\n  double m=Math.cos(Math.toRadians(53)) * l;\n  path1.moveTo((float)(w2 - a),(float)(h2 - c));\n  path1.lineTo((float)(w2 - a + m),(float)(h2 - c + Math.sin(Math.toRadians(53)) * l));\n  path1.lineTo((float)(w2 + a),(float)(h2 - c));\n  pathMeasure1.setPath(path1,false);\n  mMarkOklength=pathMeasure1.getLength();\n}\n", "docstring": "make the path to show", "partition": "test"}
{"idx": "6280", "code": "protected List<String> addWhitespace(List<String> list){\n  List<String> whitespaceList=new ArrayList<>();\n  for (  String value : list) {\n    whitespaceList.add(addWhitespace(value));\n  }\n  return whitespaceList;\n}\n", "docstring": "adds leading and trailing whitespace characters to all members in this list .", "partition": "test"}
{"idx": "6281", "code": "public static String computeQualifiedWidgetTypeName(Node widgetNode){\n  if (widgetNode.getNodeType() != Node.ELEMENT_NODE) {\n    return null;\n  }\n  String typeName=widgetNode.getLocalName();\n  if (typeName.length() == 0 || Character.isLowerCase(typeName.charAt(0))) {\n    return null;\n  }\n  String packageName=UiBinderUtilities.getPackageName(widgetNode.getNamespaceURI());\n  return packageName != null ? JavaUtilities.getQualifiedTypeName(typeName,packageName) : null;\n}\n", "docstring": "computes the fully qualified name for the widget - derived type at the given node .", "partition": "test"}
{"idx": "6282", "code": "private static boolean processFtypAtom(ParsableByteArray atomData){\n  atomData.setPosition(Atom.HEADER_SIZE);\n  int majorBrand=atomData.readInt();\n  if (majorBrand == BRAND_QUICKTIME) {\n    return true;\n  }\n  atomData.skipBytes(4);\n  while (atomData.bytesLeft() > 0) {\n    if (atomData.readInt() == BRAND_QUICKTIME) {\n      return true;\n    }\n  }\n  return false;\n}\n", "docstring": "process an ftyp atom to determine whether the media is quicktime .", "partition": "test"}
{"idx": "6283", "code": "public String delete(String url,final int expectedStatusCode){\n  return delete(url,Collections.<String,String>emptyMap(),expectedStatusCode);\n}\n", "docstring": "issue an http delete and assert the response status code .", "partition": "test"}
{"idx": "6284", "code": "protected void runningSum(Set<Map.Entry<Double,Double>> c,double value,double[] sums){\n  double offset=CONST - Math.log(m_Width);\n  double logFactor=Math.log(m_Threshold) - Math.log(1 - m_Threshold);\n  double logSumOfWeights=Math.log(m_SumOfWeights);\n  Iterator<Map.Entry<Double,Double>> itr=c.iterator();\n  while (itr.hasNext()) {\n    Map.Entry<Double,Double> entry=itr.next();\n    if (entry.getValue() > 0) {\n      double diff=(entry.getKey() - value) / m_Width;\n      double logDensity=offset - 0.5 * diff * diff;\n      double logWeight=Math.log(entry.getValue());\n      sums[0]=logOfSum(sums[0],logWeight + logDensity);\n      sums[1]=logOfSum(sums[1],logWeight);\n      if (logDensity + logSumOfWeights < logOfSum(logFactor + sums[0],logDensity + sums[1])) {\n        break;\n      }\n    }\n  }\n}\n", "docstring": "compute running sum of density values and weights .", "partition": "test"}
{"idx": "6285", "code": "@Override public CategoricalTable copy(){\n  Map<Value,Double> newTable=new HashMap<Value,Double>();\n  for (  Value v : table.keySet()) {\n    newTable.put(v,table.get(v));\n  }\n  return new CategoricalTable(variable,newTable);\n}\n", "docstring": "returns a copy of the probability table", "partition": "test"}
{"idx": "6286", "code": "public Configuration subConfig(String prefix,String keyPrefix){\n  Configuration sub=new Configuration();\n  addToSubConf(sub,prefix.length() > 0 ? prefix + \".\" + keyPrefix : keyPrefix);\n  return sub;\n}\n", "docstring": "return a sub configuration from this instance that has the keys equal to either prefix . keyprefix or keyprefix . the entries of keyprefix are added first , so they are the defaults if prefix is not found .", "partition": "test"}
{"idx": "6287", "code": "public Map<String,String> mapNameToDisplayName(Set<String> names) throws SMSException, SSOException {\n  final Map<String,String> map=new HashMap<>(names.size());\n  for (  String name : names) {\n    if (smsConsoleServiceConfig.isServiceVisible(name)) {\n      final ServiceSchemaManager serviceSchemaManager=serviceSchemaManagerFactory.build(name);\n      String displayName=getLocalizedServiceName(serviceSchemaManager,name);\n      String resourceName=serviceSchemaManager.getResourceName();\n      if (!name.equals(displayName) && !StringUtils.isBlank(resourceName)) {\n        map.put(resourceName,displayName);\n      }\n    }\n  }\n  return map;\n}\n", "docstring": "maps service internal names to displayable ( localized ) names via their resource names . services without resource names are not included in the returned map .", "partition": "test"}
{"idx": "6288", "code": "@Override public String toString(){\n  return \"DistributionLocator \" + getId();\n}\n", "docstring": "returns a string representation of the object .", "partition": "test"}
{"idx": "6289", "code": "public static final boolean executePotentialWork(final Object data,final ImageView imageView){\n  final BitmapWorkerTask bitmapWorkerTask=getBitmapWorkerTask(imageView);\n  if (bitmapWorkerTask != null) {\n    final Object bitmapData=bitmapWorkerTask.mKey;\n    if (bitmapData == null || !bitmapData.equals(data)) {\n      bitmapWorkerTask.cancel(true);\n    }\n else {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "returns true if the current work has been canceled or if there was no work in progress on this image view . returns false if the work in progress deals with the same data . the work is not stopped in that case .", "partition": "test"}
{"idx": "6290", "code": "public static void queueBitmap(String key,Bitmap bmp){\n  mBitmapQueue.put(key,bmp);\n}\n", "docstring": "temporarily store a bitmap", "partition": "test"}
{"idx": "6291", "code": "public void addListener(AfterServerStartListener listener){\n  _afterStartListeners.add(listener);\n}\n", "docstring": "adds a new afterstart listener for post - startup cleanup", "partition": "test"}
{"idx": "6292", "code": "private int makeAvailable() throws IOException {\n  if (pos != -1) {\n    return 0;\n  }\n  total+=tail - head - pad;\n  System.arraycopy(buffer,tail - pad,buffer,0,pad);\n  head=0;\n  tail=pad;\n  for (; ; ) {\n    int bytesRead=input.read(buffer,tail,bufSize - tail);\n    if (bytesRead == -1) {\n      final String msg=\"Stream ended unexpectedly\";\n      throw new FileUploadException(MalformedStreamException,msg);\n    }\n    tail+=bytesRead;\n    findSeparator();\n    int av=available();\n    if (av > 0 || pos != -1) {\n      return av;\n    }\n  }\n}\n", "docstring": "attempts to read more data .", "partition": "test"}
{"idx": "6293", "code": "public RelationNotification(String notifType,Object sourceObj,long sequence,long timeStamp,String message,String id,String typeName,ObjectName objectName,List<ObjectName> unregMBeanList) throws IllegalArgumentException {\n  super(notifType,sourceObj,sequence,timeStamp,message);\n  if (!isValidBasicStrict(notifType,sourceObj,id,typeName) || !isValidCreate(notifType)) {\n    throw new IllegalArgumentException(\"Invalid parameter.\");\n  }\n  relationId=id;\n  relationTypeName=typeName;\n  relationObjName=safeGetObjectName(objectName);\n  unregisterMBeanList=safeGetObjectNameList(unregMBeanList);\n}\n", "docstring": "creates a notification for either a relation creation ( relationsupport object created internally in the relation service , or an mbean added as a relation ) or for a relation removal from the relation service .", "partition": "test"}
{"idx": "6294", "code": "public boolean localHostOrDomainIs(String host,String domain){\n  return domain.startsWith(host);\n}\n", "docstring": "is true if the host name matches exactly the specified host name , or if there is no domain name part in the host name , but the unqualified host name matches .", "partition": "test"}
{"idx": "6295", "code": "protected double entropy(double[][] dataZs,double[][] dataWs){\n  double entropy=0.0;\n  int numInstances=dataZs.length;\n  for (int j=0; j < m_numClasses; j++) {\n    double m=0.0;\n    double sum=0.0;\n    for (int i=0; i < numInstances; i++) {\n      m+=dataZs[i][j] * dataWs[i][j];\n      sum+=dataWs[i][j];\n    }\n    m/=sum;\n    for (int i=0; i < numInstances; i++) {\n      entropy+=dataWs[i][j] * Math.pow(dataZs[i][j] - m,2);\n    }\n  }\n  return entropy;\n}\n", "docstring": "helper function to compute entropy from z / w values .", "partition": "test"}
{"idx": "6296", "code": "protected void writeDistribution(Parameter parameter,boolean isRef,XMLWriter writer){\nswitch (parameter.priorType) {\ncase UNIFORM_PRIOR:\n    String id=parameter.taxaId + \"-uniformDist\";\n  if (isRef) {\n    writer.writeIDref(UniformDistributionModelParser.UNIFORM_DISTRIBUTION_MODEL,id);\n  }\n else {\n    writer.writeOpenTag(UniformDistributionModelParser.UNIFORM_DISTRIBUTION_MODEL,new Attribute[]{new Attribute.Default<String>(XMLParser.ID,id)});\n    writer.writeOpenTag(UniformDistributionModelParser.LOWER);\n    writer.writeText(Double.toString(parameter.uniformLower));\n    writer.writeCloseTag(UniformDistributionModelParser.LOWER);\n    writer.writeOpenTag(UniformDistributionModelParser.UPPER);\n    writer.writeText(Double.toString(parameter.uniformUpper));\n    writer.writeCloseTag(UniformDistributionModelParser.UPPER);\n    writer.writeCloseTag(UniformDistributionModelParser.UNIFORM_DISTRIBUTION_MODEL);\n  }\nbreak;\ncase EXPONENTIAL_PRIOR:\nwriter.writeOpenTag(ExponentialDistributionModel.EXPONENTIAL_DISTRIBUTION_MODEL);\nwriter.writeOpenTag(DistributionModelParser.MEAN);\nwriter.writeText(Double.toString(parameter.mean));\nwriter.writeCloseTag(DistributionModelParser.MEAN);\nwriter.writeOpenTag(DistributionModelParser.OFFSET);\nwriter.writeText(Double.toString(parameter.offset));\nwriter.writeCloseTag(DistributionModelParser.OFFSET);\nwriter.writeCloseTag(ExponentialDistributionModel.EXPONENTIAL_DISTRIBUTION_MODEL);\nbreak;\ncase NORMAL_PRIOR:\nwriter.writeOpenTag(NormalDistributionModelParser.NORMAL_DISTRIBUTION_MODEL);\nwriter.writeOpenTag(NormalDistributionModelParser.MEAN);\nwriter.writeText(Double.toString(parameter.mean));\nwriter.writeCloseTag(NormalDistributionModelParser.MEAN);\nwriter.writeOpenTag(NormalDistributionModelParser.STDEV);\nwriter.writeText(Double.toString(parameter.stdev));\nwriter.writeCloseTag(NormalDistributionModelParser.STDEV);\nwriter.writeCloseTag(NormalDistributionModelParser.NORMAL_DISTRIBUTION_MODEL);\nbreak;\ncase LOGNORMAL_PRIOR:\nwriter.writeOpenTag(LogNormalDistributionModelParser.LOGNORMAL_DISTRIBUTION_MODEL,new Attribute[]{new Attribute.Default<Boolean>(LogNormalDistributionModelParser.MEAN_IN_REAL_SPACE,parameter.isMeanInRealSpace()),new Attribute.Default<Boolean>(LogNormalDistributionModelParser.STDEV_IN_REAL_SPACE,parameter.isMeanInRealSpace())});\nwriter.writeOpenTag(LogNormalDistributionModelParser.MEAN);\nwriter.writeText(Double.toString(parameter.mean));\nwriter.writeCloseTag(LogNormalDistributionModelParser.MEAN);\nwriter.writeOpenTag(LogNormalDistributionModelParser.STDEV);\nwriter.writeText(Double.toString(parameter.stdev));\nwriter.writeCloseTag(LogNormalDistributionModelParser.STDEV);\nwriter.writeOpenTag(LogNormalDistributionModelParser.OFFSET);\nwriter.writeText(Double.toString(parameter.offset));\nwriter.writeCloseTag(LogNormalDistributionModelParser.OFFSET);\nwriter.writeCloseTag(LogNormalDistributionModelParser.LOGNORMAL_DISTRIBUTION_MODEL);\nbreak;\ncase GAMMA_PRIOR:\nwriter.writeOpenTag(GammaDistributionModel.GAMMA_DISTRIBUTION_MODEL);\nwriter.writeOpenTag(DistributionModelParser.SHAPE);\nwriter.writeText(Double.toString(parameter.shape));\nwriter.writeCloseTag(DistributionModelParser.SHAPE);\nwriter.writeOpenTag(DistributionModelParser.SCALE);\nwriter.writeText(Double.toString(parameter.scale));\nwriter.writeCloseTag(DistributionModelParser.SCALE);\nwriter.writeOpenTag(DistributionModelParser.OFFSET);\nwriter.writeText(Double.toString(parameter.offset));\nwriter.writeCloseTag(DistributionModelParser.OFFSET);\nwriter.writeCloseTag(GammaDistributionModel.GAMMA_DISTRIBUTION_MODEL);\nbreak;\ndefault :\nthrow new IllegalArgumentException(\"Unknown Distribution Model for \" + parameter.getName());\n}\n}\n", "docstring": "write the distribution for * distributionmodel", "partition": "test"}
{"idx": "6297", "code": "public void saveWorkingInstancesToFileQ(){\n  if (m_IOThread == null) {\n    m_FileChooser.setCapabilitiesFilter(m_FilterEditor.getCapabilitiesFilter());\n    m_FileChooser.setAcceptAllFileFilterUsed(false);\n    int returnVal=m_FileChooser.showSaveDialog(this);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n      Instances inst=new Instances(m_Instances);\n      inst.setClassIndex(m_AttVisualizePanel.getColoringIndex());\n      saveInstancesToFile(m_FileChooser.getSaver(),inst);\n    }\n    FileFilter temp=m_FileChooser.getFileFilter();\n    m_FileChooser.setAcceptAllFileFilterUsed(true);\n    m_FileChooser.setFileFilter(temp);\n  }\n else {\n    JOptionPane.showMessageDialog(this,\"Can\'t save at this time,\\n\" + \"currently busy with other IO\",\"Save Instances\",JOptionPane.WARNING_MESSAGE);\n  }\n}\n", "docstring": "queries the user for a file to save instances as , then saves the instances in a background process . this is done in the io thread , and an error message is popped up if the io thread is busy .", "partition": "test"}
{"idx": "6298", "code": "public int read(char cbuf[],int off,int len) throws IOException {\n  if ((off < 0) || (off > cbuf.length) || (len < 0)|| ((off + len) > cbuf.length)|| ((off + len) < 0))   throw new IndexOutOfBoundsException();\n  if (len == 0)   return 0;\n  if (next >= length)   return -1;\n  int n=Math.min(length - next,len);\n  text.getChars(next,next + n,cbuf,off);\n  next+=n;\n  return n;\n}\n", "docstring": "reads characters into a portion of an array .", "partition": "test"}
{"idx": "6299", "code": "private boolean adjustIndent(){\n  AlignmentImpl alignment=CoreFormatterUtil.getAlignment(myCurrentBlock);\n  WhiteSpace whiteSpace=myCurrentBlock.getWhiteSpace();\n  if (alignment == null || myAlignmentsToSkip.contains(alignment)) {\n    if (whiteSpace.containsLineFeeds()) {\n      adjustSpacingByIndentOffset();\n    }\n else {\n      whiteSpace.arrangeSpaces(myCurrentBlock.getSpaceProperty());\n    }\n    return true;\n  }\n  BlockAlignmentProcessor alignmentProcessor=ALIGNMENT_PROCESSORS.get(alignment.getAnchor());\n  if (alignmentProcessor == null) {\n    LOG.error(String.format(\"Can\'t find alignment processor for alignment anchor %s\",alignment.getAnchor()));\n    return true;\n  }\n  BlockAlignmentProcessor.Context context=new BlockAlignmentProcessor.Context(myDocument,alignment,myCurrentBlock,myAlignmentMappings,myBackwardShiftedAlignedBlocks,getIndentOptionsToUse(myCurrentBlock,myDefaultIndentOption),myRightMargin);\n  BlockAlignmentProcessor.Result result=alignmentProcessor.applyAlignment(context);\n  final LeafBlockWrapper offsetResponsibleBlock=alignment.getOffsetRespBlockBefore(myCurrentBlock);\nswitch (result) {\ncase TARGET_BLOCK_PROCESSED_NOT_ALIGNED:\n    return true;\ncase TARGET_BLOCK_ALIGNED:\n  storeAlignmentMapping();\nreturn true;\ncase BACKWARD_BLOCK_ALIGNED:\nif (offsetResponsibleBlock == null) {\nreturn true;\n}\nSet<LeafBlockWrapper> blocksCausedRealignment=new HashSet<LeafBlockWrapper>();\nmyBackwardShiftedAlignedBlocks.clear();\nmyBackwardShiftedAlignedBlocks.put(offsetResponsibleBlock,blocksCausedRealignment);\nblocksCausedRealignment.add(myCurrentBlock);\nstoreAlignmentMapping(myCurrentBlock,offsetResponsibleBlock);\nmyCurrentBlock=offsetResponsibleBlock.getNextBlock();\nonCurrentLineChanged();\nreturn false;\ncase RECURSION_DETECTED:\nmyCurrentBlock=offsetResponsibleBlock;\ncase UNABLE_TO_ALIGN_BACKWARD_BLOCK:\nmyAlignmentsToSkip.add(alignment);\nreturn false;\ndefault :\nreturn true;\n}\n}\n", "docstring": "adjusts indent of the current block .", "partition": "test"}
{"idx": "6300", "code": "@Override public void appendCode(Type declaringType,TypeTuple inputTypes,Type outputType,List<Variable> inputVars,StringBuilder b){\n  b.append(field.toCode(declaringType,inputVars));\n}\n", "docstring": "adds the text for an initialization of a variable from a field to the stringbuilder .", "partition": "test"}
{"idx": "6301", "code": "public ForwardPlanner(DialogueSystem system){\n  this.system=system;\n}\n", "docstring": "constructs a forward planner for the dialogue system .", "partition": "test"}
{"idx": "6302", "code": "private JButton addButton(String text,Container container,float alignment){\n  JButton button=new JButton(text);\n  button.setAlignmentX(alignment);\n  container.add(button);\n  return button;\n}\n", "docstring": "adds a preconfigured jbutton to the specified container using the specified alignment constraint . does not modify the button \"'\" s border .", "partition": "test"}
{"idx": "6303", "code": "private boolean noMatchForTagInAttributes(AttributeSet attr,HTML.Tag t,Object tagValue){\n  if (attr != null && attr.isDefined(t)) {\n    Object newValue=attr.getAttribute(t);\n    if ((tagValue == null) ? (newValue == null) : (newValue != null && tagValue.equals(newValue))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "searches the attribute set for a tag , both of which are passed in as a parameter . returns true if no match is found and false otherwise .", "partition": "test"}
{"idx": "6304", "code": "public String businessObjectDataKeyToString(BusinessObjectDataKey businessObjectDataKey){\n  if (businessObjectDataKey == null) {\n    return null;\n  }\n  return businessObjectDataKeyToString(businessObjectDataKey.getNamespace(),businessObjectDataKey.getBusinessObjectDefinitionName(),businessObjectDataKey.getBusinessObjectFormatUsage(),businessObjectDataKey.getBusinessObjectFormatFileType(),businessObjectDataKey.getBusinessObjectFormatVersion(),businessObjectDataKey.getPartitionValue(),businessObjectDataKey.getSubPartitionValues(),businessObjectDataKey.getBusinessObjectDataVersion());\n}\n", "docstring": "returns a string representation of the business object data key .", "partition": "test"}
{"idx": "6305", "code": "private Usage createTalkUsage(Context context){\n  if (talkUsage != null) {\n    return talkUsage;\n  }\n  TypeToken<List<Usage>> token=new TypeToken<List<Usage>>(){\n  }\n;\n  List<Usage> initTalkIO=JsonUtils.parseJsonFile(context,\"talk_io.json\",token);\n  talkUsage=initTalkIO.get(0);\n  return talkUsage;\n}\n", "docstring": "get talk incoming / outgoing info from the json file and save in cache", "partition": "test"}
{"idx": "6306", "code": "@Nullable public GrCall enclosingCall(String name,GdslMembersHolderConsumer consumer){\n  final PsiElement place=consumer.getPlace();\n  if (place == null)   return null;\n  GrCall call=PsiTreeUtil.getParentOfType(place,GrCall.class,true);\n  if (call == null)   return null;\n  while (call != null && !name.equals(getInvokedMethodName(call))) {\n    call=PsiTreeUtil.getParentOfType(call,GrCall.class,true);\n  }\n  if (call == null)   return null;\n  final GrArgumentList argumentList=call.getArgumentList();\n  if (argumentList != null) {\n    for (    GrExpression arg : argumentList.getExpressionArguments()) {\n      if (arg instanceof GrClosableBlock && PsiTreeUtil.findCommonParent(place,arg) == arg) {\n        return call;\n      }\n    }\n  }\n  if (call instanceof GrMethodCallExpression) {\n    for (    GrExpression arg : call.getClosureArguments()) {\n      if (arg instanceof GrClosableBlock && PsiTreeUtil.findCommonParent(place,arg) == arg) {\n        return call;\n      }\n    }\n  }\n  return null;\n}\n", "docstring": "returns enclosing method call of a given context \"'\" s place", "partition": "test"}
{"idx": "6307", "code": "public static void genOvfenvIsoImage(String ovfenvPropKVStr,String isoFilePath){\n  byte[] bOvfenvPropKVStr=ovfenvPropKVStr.getBytes();\n  String propFilePath=\"/tmp/ovf-env.properties\";\n  File propFile=new File(propFilePath);\n  try {\n    FileUtils.writePlainFile(propFilePath,bOvfenvPropKVStr);\n  }\n catch (  Exception e1) {\n    propFile.delete();\n    log.error(\"Write to prop file failed with exception: {}\",e1.getMessage());\n    throw new IllegalStateException(\"Failed to generate ovfenv prop file.\");\n  }\n  try {\n    File isoFile=new File(isoFilePath);\n    String[] genISOImageCommand={GENISO_CMD,\"--label\",\"CDROM\",\"-f\",propFilePath,\"-o\",isoFilePath,\"ovf-env.properties\",\"4096\"};\n    Exec.Result result=Exec.sudo(CMD_TIMEOUT,genISOImageCommand);\n    if (!result.exitedNormally() || result.getExitValue() != 0) {\n      log.error(\"Generating ISO image failed with exit value: {}, error: {}\",result.getExitValue(),result.getStdError());\n      throw new IllegalStateException(\"Failed to generate ISO image.\");\n    }\n  }\n catch (  Exception e) {\n    throw e;\n  }\n finally {\n    propFile.delete();\n  }\n}\n", "docstring": "generate ovfenv iso image which will be then saved to ovfenv partition", "partition": "test"}
{"idx": "6308", "code": "public static void createActionableEvent(DbClient dbClient,EventUtils.EventCode eventCode,URI tenant,String name,String description,String warning,DataObject resource,List<URI> affectedResources,String approveMethod,Object[] approveParameters){\n  createActionableEvent(dbClient,eventCode,tenant,name,description,warning,resource,affectedResources,approveMethod,approveParameters,null,null);\n}\n", "docstring": "creates an actionable event and persists to the database", "partition": "test"}
{"idx": "6309", "code": "public Rational(ByteProvider byteProvider) throws IOException {\n  MXFPropertyPopulator.populateField(byteProvider,this,\"numerator\");\n  MXFPropertyPopulator.populateField(byteProvider,this,\"denominator\");\n}\n", "docstring": "instantiates a new rational .", "partition": "test"}
{"idx": "6310", "code": "public synchronized void removeNotifications(String type) throws InstanceNotFoundException {\n  Vector<Integer> v=getNotificationIDs(type);\n  if (v.isEmpty())   throw new InstanceNotFoundException(\"Timer notifications to remove not in the list of notifications\");\n  for (  Integer i : v)   removeNotification(i);\n}\n", "docstring": "removes all the timer notifications corresponding to the specified type from the list of notifications .", "partition": "test"}
{"idx": "6311", "code": "private void unifyViaAtom(Atomic parentAtom){\n  Atomic childAtom=getRuleConclusionAtom();\n  Query parent=parentAtom.getParentQuery();\n  Map<String,String> unifiers=childAtom.getUnifiers(parentAtom);\n  head.unify(unifiers);\n  body.unify(unifiers);\n  Set<String> childFVs=body.getVarSet();\n  Set<String> parentBVs=parentAtom.getVarNames();\n  Set<String> parentVars=parent.getVarSet();\n  parentBVs.forEach(null);\n  childFVs.forEach(null);\n}\n", "docstring": "propagate variables to child via a relation atom ( atom variables are bound )", "partition": "test"}
{"idx": "6312", "code": "static void addUuid(SsfNode node,UUID uuid){\n  node.set(\"UUIDMost\",uuid.getMostSignificantBits());\n  node.set(\"UUIDLeast\",uuid.getLeastSignificantBits());\n}\n", "docstring": "adds uuid value to given node as uuidmost and uuidleast tags .", "partition": "test"}
{"idx": "6313", "code": "public FluxConcatArray<T> concatAdditionalSourceFirst(Publisher<? extends T> source){\n  int n=array.length;\n  @SuppressWarnings(\"unchecked\") Publisher<? extends T>[] newArray=new Publisher[n + 1];\n  System.arraycopy(array,0,newArray,1,n);\n  newArray[0]=source;\n  return new FluxConcatArray<>(delayError,newArray);\n}\n", "docstring": "returns a new instance which has the additional first source to be concatenated together with the current array of sources . < p > this operation doesn \"'\" t change the current fluxconcatarray instance .", "partition": "test"}
{"idx": "6314", "code": "public void shutdown(){\n  shutdownServerThread();\n  shutdownSessions();\n}\n", "docstring": "closes the server socket and all client sockets .", "partition": "test"}
{"idx": "6315", "code": "private boolean isLocalId(String localId){\n  if (!localId.startsWith(\"local_\")) {\n    return false;\n  }\n  for (int i=6; i < localId.length(); ++i) {\n    char c=localId.charAt(i);\n    if (!(c >= \'0\' && c <= \'9\') && !(c >= \'a\' && c <= \'f\')) {\n      return false;\n    }\n  }\n  return true;\n}\n", "docstring": "returns true if localid has the right basic format for a local id .", "partition": "test"}
{"idx": "6316", "code": "public ServerSocketBar bind(ServerSocketBar ss) throws ConfigException, IOException {\nsynchronized (_sslInitLock) {\n    if (_stdServerSocket != null)     throw new ConfigException(L.l(\"Can\'t create duplicte ssl factory.\"));\n    try {\n      initConfig();\n    }\n catch (    RuntimeException e) {\n      e.printStackTrace();\n      throw e;\n    }\n    _stdServerSocket=ss;\n    initSSL();\n    return this;\n  }\n}\n", "docstring": "creates the server socket .", "partition": "test"}
{"idx": "6317", "code": "private void resetOutputBuilders(){\n  ansi=Ansi.ansi();\n  stringBuilder=new StringBuilder();\n}\n", "docstring": "reset both output builders .", "partition": "test"}
{"idx": "6318", "code": "public String read(ByteBuffer buf,DictionaryCache dict){\n  StringBuilder out=new StringBuilder();\n  if (pre != null)   out.append(pre);\n  if (type == VOID)   return out.toString();\n  if (type == NULL) {\n    out.append(\"null\");\n    return out.toString();\n  }\n  if (type == BYTE) {\n    out.append(buf.get());\n    return out.toString();\n  }\n  if (type == SHORT) {\n    out.append(buf.getShort());\n    return out.toString();\n  }\n  if (type == INT) {\n    out.append(buf.getInt());\n    return out.toString();\n  }\n  if (type == LONG) {\n    out.append(buf.getLong());\n    return out.toString();\n  }\n  if (type == DOUBLE) {\n    out.append(buf.getDouble());\n    return out.toString();\n  }\n  if (type == BOOLEAN) {\n    out.append((buf.get() == 0 ? \"false\" : \"true\"));\n    return out.toString();\n  }\n  if (type == STRING) {\n    short pos=buf.getShort();\n    if (pos > -1) {\n      out.append(\"\\\"\");\n      out.append(dict.get(pos));\n      out.append(\"\\\"\");\n    }\n else {\n      int size=0;\n      int val=buf.get() & 0xFF;\n      while (val == 255) {\n        size+=val;\n        val=buf.get() & 0xFF;\n      }\n      size+=val;\n      byte[] data=new byte[size];\n      buf.get(data);\n      out.append(\"\\\"\");\n      out.append(new String(data,StandardCharsets.UTF_8));\n      out.append(\"\\\"\");\n    }\n    return out.toString();\n  }\n  return null;\n}\n", "docstring": "read this segment from a byte buffer using the given dictionary for lookups . the dictionary may be null if no dictionary values were used when writing data for this segment .", "partition": "test"}
{"idx": "6319", "code": "public void write(String filename){\n  logger.info(\"write carrier plans\");\n  try {\n    openFile(filename);\n    writeXmlHead();\n    startCarriers(this.writer);\n    for (    Carrier carrier : carriers) {\n      startCarrier(carrier,this.writer);\n      writeVehicles(carrier,this.writer);\n      writeShipments(carrier,this.writer);\n      writePlans(carrier,this.writer);\n      endCarrier(this.writer);\n    }\n    endCarriers(this.writer);\n    close();\n    logger.info(\"done\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    logger.error(e);\n    System.exit(1);\n  }\n}\n", "docstring": "writes carriers and their plans into a xml - file .", "partition": "test"}
{"idx": "6320", "code": "public void removeResourceListener(ResourceEventsListener listener){\n  resourceListeners.remove(listener);\n}\n", "docstring": "un - registers a listener to the system", "partition": "test"}
{"idx": "6321", "code": "public void testHasMainActivity() throws Exception {\n  mEnabled.add(LauncherActivityDetector.ISSUE_MORE_THAN_ONE_LAUNCHER);\n  mEnabled.add(LauncherActivityDetector.ISSUE_MISSING_LAUNCHER);\n  mEnabled.add(LauncherActivityDetector.ISSUE_LAUNCHER_ACTIVITY_IN_LIBRARY);\n  String expected=\"No warnings.\";\n  String result=lintProject(xml(FN_ANDROID_MANIFEST_XML,\"\" + \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\" + \"<manifest package=\\\"com.example.android.custom-lint-rules\\\"\\n\"+ \"          xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\">\\n\"+ \"    <application>\\n\"+ \"        <activity android:name=\\\"com.example.android.custom-lint-rules\"+ \".OtherActivity\\\">\\n\"+ \"        </activity>\\n\"+ \"\\n\"+ \"        <activity android:name=\\\"com.example.android.custom-lint-rules\"+ \".MainActivity\\\">\\n\"+ \"            <intent-filter>\\n\"+ \"                <action android:name=\\\"android.intent.action.MAIN\\\"/>\\n\"+ \"                <category android:name=\\\"android.intent.category.LAUNCHER\\\"/>\\n\"+ \"            </intent-filter>\\n\"+ \"        </activity>\\n\"+ \"    </application>\\n\"+ \"</manifest>\"));\n  assertEquals(expected,result);\n}\n", "docstring": "test that a manifest with an activity with a launcher intent has no warnings .", "partition": "test"}
{"idx": "6322", "code": "protected void writeHeader(RandomAccessFile file,int size) throws IOException {\n  String str;\n  int offset=0;\n  byte[] buffer=new byte[5];\n  str=Integer.toString(getSize());\n  for (int i=0; i < (5 - str.length()); i++) {\n    buffer[i]=(byte)'0';\n  }\n  offset+=(5 - str.length());\n  for (int i=0; i < str.length(); i++) {\n    buffer[i + offset]=(byte)str.charAt(i);\n  }\n  file.write(buffer);\n}\n", "docstring": "this is called by superclass when attempt to write data from file .", "partition": "test"}
{"idx": "6323", "code": "public String buildJavaVendor(){\n  return properties.getProperty(\"build.java.vendor\");\n}\n", "docstring": "returns the vendor for the java version used to generate this build .", "partition": "test"}
{"idx": "6324", "code": "final void treeify(Node<K,V>[] tab){\n  TreeNode<K,V> root=null;\n  for (TreeNode<K,V> x=this, next; x != null; x=next) {\n    next=(TreeNode<K,V>)x.next;\n    x.left=x.right=null;\n    if (root == null) {\n      x.parent=null;\n      x.red=false;\n      root=x;\n    }\n else {\n      K k=x.key;\n      int h=x.hash;\n      Class<?> kc=null;\n      for (TreeNode<K,V> p=root; ; ) {\n        int dir, ph;\n        K pk=p.key;\n        if ((ph=p.hash) > h)         dir=-1;\n else         if (ph < h)         dir=1;\n else         if ((kc == null && (kc=comparableClassFor(k)) == null) || (dir=compareComparables(kc,k,pk)) == 0)         dir=tieBreakOrder(k,pk);\n        TreeNode<K,V> xp=p;\n        if ((p=(dir <= 0) ? p.left : p.right) == null) {\n          x.parent=xp;\n          if (dir <= 0)           xp.left=x;\n else           xp.right=x;\n          root=balanceInsertion(root,x);\n          break;\n        }\n      }\n    }\n  }\n  moveRootToFront(tab,root);\n}\n", "docstring": "forms tree of the nodes linked from this node .", "partition": "test"}
{"idx": "6325", "code": "private void addCategoryToTree(DefaultMutableTreeNode node,String[] names){\n  if (names.length == 0) {\n    return;\n  }\n  boolean matched=false;\n  for (@SuppressWarnings(\"unchecked\") Enumeration<DefaultMutableTreeNode> e=node.children(); e.hasMoreElements(); ) {\n    DefaultMutableTreeNode childNode=e.nextElement();\n    String nodeName=(String)childNode.getUserObject();\n    if (nodeName.equals(names[0])) {\n      if (names.length > 1) {\n        addCategoryToTree(childNode,Arrays.copyOfRange(names,1,names.length));\n        matched=true;\n      }\n else {\n      }\n    }\n  }\n  if (!matched) {\n    DefaultMutableTreeNode root=node;\n    for (int i=0; i < names.length; i++) {\n      DefaultMutableTreeNode newNode=new DefaultMutableTreeNode(names[i]);\n      root.add(newNode);\n      root=newNode;\n    }\n  }\n}\n", "docstring": "this recursive method is a hack : directoryitems flattens the directory structure , but it provides useful functionality , so this method will reconstruct the directory structure for the jtree .", "partition": "test"}
{"idx": "6326", "code": "private void editNote(int noteId){\n  hideSoftKeyboard();\n  Intent intent=new Intent(MainActivity.this,NoteActivity.class);\n  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);\n  intent.putExtra(\"id\",String.valueOf(noteId));\n  startActivity(intent);\n}\n", "docstring": "method used to enter note edition mode", "partition": "test"}
{"idx": "6327", "code": "public final Entry addEntry(Position inputPosition,Position outputPosition){\n  Entry entry=new Entry(inputPosition,outputPosition);\n  entries.add(entry);\n  return entry;\n}\n", "docstring": "adds an entry to the source map ( entry must be added in order ) .", "partition": "test"}
{"idx": "6328", "code": "public void unHideActionBar(View view){\n  if (toolbarAutoHider != null)   toolbarAutoHider.showComponent();\n}\n", "docstring": "onclick handler - unhide action bar", "partition": "test"}
{"idx": "6329", "code": "public static String formatTimeDelta(long time,CharSequence sep){\n  final StringBuilder sb=new StringBuilder();\n  final Formatter fmt=new Formatter(sb);\n  for (int i=TIME_UNIT_SIZES.length - 1; i >= 0; --i) {\n    if (i == 0 && sb.length() > 4) {\n      continue;\n    }\n    if (sb.length() > 0) {\n      sb.append(sep);\n    }\n    final long acValue=time / TIME_UNIT_SIZES[i];\n    time=time % TIME_UNIT_SIZES[i];\n    if (!(acValue == 0 && sb.length() == 0)) {\n      fmt.format(\"%0\" + TIME_UNIT_DIGITS[i] + \"d%s\",Long.valueOf(acValue),TIME_UNIT_NAMES[i]);\n    }\n  }\n  fmt.close();\n  return sb.toString();\n}\n", "docstring": "formats a time delta in human readable format .", "partition": "test"}
{"idx": "6330", "code": "public void run(){\n  Log.d(LOG,\"run(): sampleRate=\" + sampleRate + \", channels=\"+ channels+ \", bufferSizeInBytes=\"+ bufferSizeInBytes+ \" (\"+ bufferSizeInMs+ \" ms)\");\n  isPlaying=false;\n  AudioTrack atrack=null;\n  try {\n    atrack=new AudioTrack(AudioManager.STREAM_MUSIC,sampleRate,channels == 1 ? AudioFormat.CHANNEL_CONFIGURATION_MONO : AudioFormat.CHANNEL_CONFIGURATION_STEREO,AudioFormat.ENCODING_PCM_16BIT,bufferSizeInBytes,AudioTrack.MODE_STREAM);\n    atrack.setPlaybackPositionUpdateListener(this);\n    atrack.setPositionNotificationPeriod(msToSamples(200,sampleRate,channels));\n    if (playerCallback != null)     playerCallback.playerAudioTrackCreated(atrack);\n    this.audioTrack=atrack;\n  }\n catch (  Throwable t) {\n    Log.e(LOG,\"Cannot create AudioTrack: \" + t);\n    stop();\n    if (playerCallback != null)     playerCallback.playerException(t);\n  }\n  while (!stopped) {\n    int ln=acquireSamples();\n    if (stopped || ln == 0) {\n      releaseSamples();\n      break;\n    }\n    int writtenNow=0;\n    do {\n      if (writtenNow != 0) {\n        Log.d(LOG,\"too fast for playback, sleeping...\");\n        try {\n          Thread.sleep(50);\n        }\n catch (        InterruptedException e) {\n        }\n      }\n      int written=atrack.write(lsamples,writtenNow,ln);\n      if (written < 0) {\n        Log.e(LOG,\"error in playback feed: \" + written);\n        stopped=true;\n        break;\n      }\n      writtenTotal+=written;\n      int buffered=writtenTotal - atrack.getPlaybackHeadPosition() * channels;\n      if (!stopped && !isPlaying) {\n        if (buffered * 2 >= bufferSizeInBytes) {\n          Log.d(LOG,\"start of AudioTrack - buffered \" + buffered + \" samples\");\n          atrack.play();\n          isPlaying=true;\n        }\n else {\n          Log.d(LOG,\"start buffer not filled enough - AudioTrack not started yet\");\n        }\n      }\n      writtenNow+=written;\n      ln-=written;\n    }\n while (ln > 0 && !stopped);\n    releaseSamples();\n  }\n  if (!stopped && stoppedByEOF)   waitForLastTone();\n  if (isPlaying)   atrack.pause();\n  atrack.flush();\n  atrack.release();\n  stopped=true;\n  Log.d(LOG,\"run() stopped.\");\n}\n", "docstring": "the main execution loop which should be executed in its own thread .", "partition": "test"}
{"idx": "6331", "code": "public static double[] deconvolve(final double[] p,final double rate){\n  final double[] r=Arrays.copyOf(p,p.length);\n  for (int k=0; k < p.length; k++) {\n    for (int j=0; j < p.length; j++) {\n      if (k + j < p.length) {\n        r[k + j]-=rate * p[k] * p[j];\n      }\n    }\n  }\n  double sum=0;\n  for (  final double q : r) {\n    sum+=q;\n  }\n  sum=1 / sum;\n  for (int k=0; k < r.length; k++) {\n    r[k]*=sum;\n  }\n  return r;\n}\n", "docstring": "takes a probability distribution and reduces higher - order terms by contributions arising from combinations of lower order terms . it assumes the input distribution is suitable for this operation .", "partition": "test"}
{"idx": "6332", "code": "public static double calculateColumnTotal(Values2D data,int column,int[] validRows){\n  ParamChecks.nullNotPermitted(data,\"data\");\n  double total=0.0;\n  int rowCount=data.getRowCount();\n  for (int v=0; v < validRows.length; v++) {\n    int row=validRows[v];\n    if (row < rowCount) {\n      Number n=data.getValue(row,column);\n      if (n != null) {\n        total+=n.doubleValue();\n      }\n    }\n  }\n  return total;\n}\n", "docstring": "returns the total of the values in one column of the supplied data table by taking only the row numbers in the array into account .", "partition": "test"}
{"idx": "6333", "code": "public boolean openAnalysis(File f,SaveType saveType){\n  if (!f.exists() || !f.canRead()) {\n    throw new IllegalArgumentException(\"Can\'t read \" + f.getPath());\n  }\n  mainFrameLoadSaveHelper.prepareForFileLoad(f,saveType);\n  mainFrameLoadSaveHelper.loadAnalysis(f);\n  return true;\n}\n", "docstring": "opens the analysis . also clears the source and summary panes . makes comments enabled false . sets the savetype and adds the file to the recent menu .", "partition": "test"}
{"idx": "6334", "code": "public void childrenRemoved(BeanContextMembershipEvent bcme){\n  findAndUndo(bcme.iterator());\n}\n", "docstring": "method for beancontextmembership interface .", "partition": "test"}
{"idx": "6335", "code": "public String process(Item item) throws ProcessException {\n  int count=0;\n  Item ss=item.getItemAs(Relation.SYLLABLE);\n  Item firstSyllable=LAST_LAST_SYLLABLE_PATH.findItem(item);\n  for (Item p=ss; p != null; p=p.getNext()) {\n    if (p.equalsShared(firstSyllable)) {\n      break;\n    }\n    count++;\n  }\n  return Integer.toString(rail(count));\n}\n", "docstring": "performs some processing on the given item .", "partition": "test"}
{"idx": "6336", "code": "private void removeInstancesFromContainers(ArrayList<Container> containers,Map<Integer,List<InstanceId>> allocation,Map<String,Integer> componentsToScaleDown){\n  ArrayList<RamRequirement> ramRequirements=getRAMInstances(componentsToScaleDown);\n  for (  RamRequirement ramRequirement : ramRequirements) {\n    String component=ramRequirement.getComponentName();\n    int numInstancesToRemove=-componentsToScaleDown.get(component);\n    for (int j=0; j < numInstancesToRemove; j++) {\n      Pair<Integer,InstanceId> idPair=removeRRInstance(containers,component);\n      List<InstanceId> instances=allocation.get(idPair.first);\n      instances.remove(idPair.second);\n      allocation.put(idPair.first,instances);\n    }\n  }\n}\n", "docstring": "removes instances from containers during scaling down", "partition": "test"}
{"idx": "6337", "code": "protected void drawNormalMessage(DrawHandler drawHandler,PointDouble send,PointDouble receive,RelationDrawer.ArrowEndType arrowEndType,boolean fillArrow,DrawingInfo drawingInfo){\n  Line line=new Line(send,receive);\n  drawHandler.drawLine(line);\n  drawHandler.setLineType(LineType.SOLID);\n  RelationDrawer.drawArrowToLine(receive,drawHandler,line,false,arrowEndType,fillArrow,false);\n  double height=send.y - drawingInfo.getVerticalStart(sendTick);\n  double topLeftX;\n  AlignHorizontal hAlignment;\n  if (from == getFirstLifeline()) {\n    topLeftX=send.x;\n    hAlignment=AlignHorizontal.LEFT;\n  }\n else {\n    topLeftX=receive.x;\n    hAlignment=AlignHorizontal.RIGHT;\n  }\n  if (duration == 0) {\n    hAlignment=AlignHorizontal.CENTER;\n  }\n  topLeftX+=LIFELINE_TEXT_PADDING;\n  TextSplitter.drawText(drawHandler,textLines,topLeftX,send.y - height,Math.abs(send.x - receive.x) - LIFELINE_TEXT_PADDING * 2,height,hAlignment,AlignVertical.BOTTOM);\n}\n", "docstring": "draws a message which is sent between two different lifelines", "partition": "test"}
{"idx": "6338", "code": "private void killConsist(){\n  if (validLocoAdr(locoTextField1.getText()) < 0) {\n    return;\n  }\n  int locoAddr=getLocoAddr(locoTextField1,adrButton1);\n  sendNceBinaryCommand(locoAddr,NceBinaryCommand.LOCO_CMD_KILL_CONSIST,(byte)0);\n}\n", "docstring": "kills consist using lead loco address", "partition": "test"}
{"idx": "6339", "code": "public ListenKey startListening() throws IOException {\n  return startListening(null,0);\n}\n", "docstring": "listen on the default address", "partition": "test"}
{"idx": "6340", "code": "@Nonnull public static Set<Flag> parse(@Nonnegative final int bitmask){\n  Check.notNegative(bitmask,\"bitmask\");\n  final Set<Flag> flags=new HashSet<Flag>();\n  for (  final Flag flag : values()) {\n    if ((bitmask & flag.getNumber()) != 0) {\n      flags.add(flag);\n    }\n  }\n  return flags;\n}\n", "docstring": "parses a sum of flags as numerical values ( bitmask ) and translates it to set of enum values .", "partition": "test"}
{"idx": "6341", "code": "@SuppressWarnings(\"fallthrough\") private void parse() throws SAXException, IOException {\n  init();\n  try {\n    mHandCont.setDocumentLocator(this);\n    mHandCont.startDocument();\n    if (mPh != PH_MISC_DTD) {\n      mPh=PH_MISC_DTD;\n    }\n    int evt=EV_NULL;\n    do {\n      wsskip();\nswitch (evt=step()) {\ncase EV_ELM:\ncase EV_ELMS:\n        mPh=PH_DOCELM;\n      break;\ncase EV_COMM:\ncase EV_PI:\n    break;\ncase EV_DTD:\n  if (mPh >= PH_DTD_MISC) {\n    panic(FAULT);\n  }\nmPh=PH_DTD_MISC;\nbreak;\ndefault :\npanic(FAULT);\n}\n}\n while (mPh < PH_DOCELM);\ndo {\nswitch (evt) {\ncase EV_ELM:\ncase EV_ELMS:\nif (mIsNSAware == true) {\nmHandCont.startElement(mElm.value,mElm.name,\"\",mAttrs);\n}\n else {\nmHandCont.startElement(\"\",\"\",mElm.name,mAttrs);\n}\nif (evt == EV_ELMS) {\nevt=step();\nbreak;\n}\ncase EV_ELME:\nif (mIsNSAware == true) {\nmHandCont.endElement(mElm.value,mElm.name,\"\");\n}\n else {\nmHandCont.endElement(\"\",\"\",mElm.name);\n}\nwhile (mPref.list == mElm) {\nmHandCont.endPrefixMapping(mPref.name);\nmPref=del(mPref);\n}\nmElm=del(mElm);\nif (mElm == null) {\nmPh=PH_DOCELM_MISC;\n}\n else {\nevt=step();\n}\nbreak;\ncase EV_TEXT:\ncase EV_WSPC:\ncase EV_CDAT:\ncase EV_COMM:\ncase EV_PI:\ncase EV_ENT:\nevt=step();\nbreak;\ndefault :\npanic(FAULT);\n}\n}\n while (mPh == PH_DOCELM);\ndo {\nif (wsskip() == EOS) {\nbreak;\n}\nswitch (step()) {\ncase EV_COMM:\ncase EV_PI:\nbreak;\ndefault :\npanic(FAULT);\n}\n}\n while (mPh == PH_DOCELM_MISC);\nmPh=PH_AFTER_DOC;\n}\n catch (SAXException saxe) {\nthrow saxe;\n}\ncatch (IOException ioe) {\nthrow ioe;\n}\ncatch (RuntimeException rte) {\nthrow rte;\n}\ncatch (Exception e) {\npanic(e.toString());\n}\n finally {\nmHandCont.endDocument();\ncleanup();\n}\n}\n", "docstring": "parse the xml document content using specified handlers and an input source .", "partition": "test"}
{"idx": "6342", "code": "public void addMatchString(String matchString){\n  matchStrings.add(matchString);\n}\n", "docstring": "add string to see if it matches in the query", "partition": "test"}
{"idx": "6343", "code": "public String timeAgo(final long millis){\n  return time(System.currentTimeMillis() - millis);\n}\n", "docstring": "get time ago that milliseconds date occurred", "partition": "test"}
{"idx": "6344", "code": "public static byte[] hexStringToByteArray(String input){\n  if ((input == null) || (input.length() % 2 != 0)) {\n    throw new IllegalArgumentException(\"The input must not be null and \" + \"shall have an even number of hexadecimal characters. Found: \" + input);\n  }\n  byte[] output=new byte[input.length() / 2];\n  for (int i=0; i < output.length; i++) {\n    output[i]=(byte)((Character.digit(input.charAt(i * 2),16) << 4) + Character.digit(input.charAt(i * 2 + 1),16));\n  }\n  return output;\n}\n", "docstring": "converts a string with an even number of hexadecimal characters to a byte array .", "partition": "test"}
{"idx": "6345", "code": "private boolean stopTrackingJob(JobStatus jobStatus){\n  boolean removed;\n  boolean rocking;\nsynchronized (mJobs) {\n    removed=mJobs.remove(jobStatus);\n    rocking=mReadyToRock;\n  }\n  if (removed && rocking) {\n    for (int i=0; i < mControllers.size(); i++) {\n      StateController controller=mControllers.get(i);\n      controller.maybeStopTrackingJob(jobStatus);\n    }\n  }\n  return removed;\n}\n", "docstring": "called when we want to remove a jobstatus object that we \"'\" ve finished executing . returns the object removed .", "partition": "test"}
{"idx": "6346", "code": "public double coefficientOfVariance(){\n  return Math.sqrt(variance()) / mean();\n}\n", "docstring": "returns the coefficient of variance .", "partition": "test"}
{"idx": "6347", "code": "public String toString(){\n  StringBuilder buf=new StringBuilder();\n  buf.append(this.coefficient);\n  if (this.variables.length > 0) {\n    buf.append(\"*\");\n  }\n  for (  int variable : this.variables) {\n    buf.append(\"(V\");\n    buf.append(variable);\n    buf.append(\")\");\n  }\n  return buf.toString();\n}\n", "docstring": "prints out a representation of the term .", "partition": "test"}
{"idx": "6348", "code": "public SkeletonVersionChecker(int defaultVersion){\n  myExplicitVersion=createTreeMap();\n  myDefaultVersion=defaultVersion;\n  load();\n}\n", "docstring": "creates an instance , loads requirements file .", "partition": "test"}
{"idx": "6349", "code": "@Override public AttributeSchemaImpl upgradeAttribute(AttributeSchemaImpl newAttr) throws UpgradeException {\n  return updateDefaultValues(newAttr,Collections.singleton(OLDEST_VERSION));\n}\n", "docstring": "this is called when the service is added for the first time and it will change the default install value of an attribute .", "partition": "test"}
{"idx": "6350", "code": "public static String toDalvikName(String canonicalName){\n  final boolean isArray=(canonicalName.charAt(0) == \'[\');\n  if (isArray) {\n    return canonicalName.replace(\'.\',\'/\');\n  }\n else {\n    if (canonicalName.equals(\"char\"))     return \"C\";\n else     if (canonicalName.equals(\"int\"))     return \"I\";\n else     if (canonicalName.equals(\"byte\"))     return \"B\";\n else     if (canonicalName.equals(\"boolean\"))     return \"Z\";\n else     if (canonicalName.equals(\"float\"))     return \"F\";\n else     if (canonicalName.equals(\"double\"))     return \"D\";\n else     if (canonicalName.equals(\"short\"))     return \"S\";\n else     if (canonicalName.equals(\"long\"))     return \"J\";\n else     if (canonicalName.equals(\"void\"))     return \"V\";\n else     return \"L\" + canonicalName.replace(\'.\',\'/\') + \";\";\n  }\n}\n", "docstring": "convert a canonical java class name to dalvik flavor .", "partition": "test"}
{"idx": "6351", "code": "public void unregisterClient(ClientProxyMembershipID proxyID,AcceptorImpl acceptor,boolean clientDisconnectedCleanly){\n  unregisterClient(proxyID);\n  if (acceptor != null) {\n    CacheClientNotifier ccn=acceptor.getCacheClientNotifier();\n    if (ccn != null) {\n      try {\n        ccn.unregisterClient(proxyID,clientDisconnectedCleanly);\n      }\n catch (      CancelException ignore) {\n      }\n    }\n  }\n}\n", "docstring": "unregisters a client to be monitored .", "partition": "test"}
{"idx": "6352", "code": "private String doubleQuotesHandling(String resource){\n  return resource.replaceAll(\"\\\"\",Matcher.quoteReplacement(\"\\\\\\\"\"));\n}\n", "docstring": "this method handles double quotes .", "partition": "test"}
{"idx": "6353", "code": "public static int allocateNewContainer(ArrayList<Container> containers,Resource capacity,int paddingPercentage){\n  containers.add(new Container(capacity,paddingPercentage));\n  return containers.size();\n}\n", "docstring": "allocate a new container of a given capacity", "partition": "test"}
{"idx": "6354", "code": "public static boolean isLocalResourceUri(Uri uri){\n  final String scheme=getSchemeOrNull(uri);\n  return LOCAL_RESOURCE_SCHEME.equals(scheme);\n}\n", "docstring": "check if uri represents local resource", "partition": "test"}
{"idx": "6355", "code": "protected String doWaitForPath(String filePath){\n  String path=null;\n  long waitTimeMillis=0;\n  assertTrue(\"OBB \" + filePath + \" is not currently mounted!\",mSm.isObbMounted(filePath));\n  while (path == null) {\n    try {\n      Thread.sleep(WAIT_TIME_INCR);\n      waitTimeMillis+=WAIT_TIME_INCR;\n      if (waitTimeMillis > MAX_WAIT_TIME) {\n        fail(\"Timed out waiting to get path of OBB file \" + filePath);\n      }\n    }\n catch (    InterruptedException e) {\n    }\n    path=mSm.getMountedObbPath(filePath);\n  }\n  Log.i(LOG_TAG,\"Got OBB path: \" + path);\n  return path;\n}\n", "docstring": "helper to synchronously wait until we can get a path for a given obb file", "partition": "test"}
{"idx": "6356", "code": "private void validateMessage(String expectedType,String type,long returnCode,String service,String payload) throws ReplicatorException {\n  if (!type.equals(expectedType)) {\n    throw new ReplicatorException(\"Server should have returned message of type \\\"\" + Protocol.TYPE_FILTERED + \"\\\", but returned \\\"\"+ type+ \"\\\" instead\");\n  }\n else   if (returnCode != 0) {\n    throw new ReplicatorException(\"Server returned a non-zero code (\" + returnCode + \"), payload: \"+ payload);\n  }\n else   if (!service.equals(messageGenerator.getService())) {\n    throw new ReplicatorException(\"Server returned unexpected service name in the message: received \\\"\" + service + \"\\\", but expected \\\"\"+ messageGenerator.getService()+ \"\\\"\");\n  }\n}\n", "docstring": "protocol safety checks for the server returned message .", "partition": "test"}
{"idx": "6357", "code": "private void closeDatabases(){\n  s_logger.log(Level.INFO,\"\");\n  s_logger.log(Level.INFO,\"migrateCloseDatabases\");\n  m_source.close();\n  m_target.close();\n  m_source.reset();\n  m_source=null;\n  m_target.reset();\n  m_target=null;\n  m_direction=null;\n  m_objectType=null;\n  m_objectTypes=null;\n  m_sourceMap=null;\n  m_targetMap=null;\n  m_objectList=new ArrayList<String>();\n  m_trackingList=new ArrayList<String>();\n  m_tempIndexes=null;\n  m_counterPrg=null;\n  m_counterDrp=null;\n  m_counterUpd=null;\n  m_counterAdd=null;\n  m_totalPrg=null;\n  m_totalDrp=null;\n  m_totalUpd=null;\n  m_totalAdd=null;\n  m_detailType=null;\n  m_detailTypes=null;\n  m_detailCounterDrp=null;\n  m_detailCounterUpd=null;\n  m_detailCounterAdd=null;\n  System.gc();\n}\n", "docstring": "closes target and source databases", "partition": "test"}
{"idx": "6358", "code": "public static byte[] MD5(final byte[] message,final int offset,final int length){\n  MessageDigest digest;\n  try {\n    digest=MessageDigest.getInstance(\"MD5\");\n    digest.update(message,offset,length);\n    final byte[] md5=digest.digest();\n    return md5;\n  }\n catch (  final NoSuchAlgorithmException e) {\n    if (Cfg.EXCEPTION) {\n      Check.log(e);\n    }\n  }\n  return null;\n}\n", "docstring": "calcola il md5 del messaggio , usando la crypto api .", "partition": "test"}
{"idx": "6359", "code": "private int runMetastoreCompareJob(Optional<Path> inputTableListPath,Path outputPath) throws InterruptedException, IOException, ClassNotFoundException, TemplateRenderException {\n  LOG.info(\"Starting job for step 1...\");\n  int result;\n  if (inputTableListPath.isPresent()) {\n    result=runMetastoreCompareJobWithTextInput(inputTableListPath.get(),outputPath);\n  }\n else {\n    result=runMetastoreCompareJob(outputPath);\n  }\n  if (result == 0) {\n    LOG.info(\"Job for step 1 finished successfully! To view logging data, run the following \" + \"commands in Hive: \\n\\n\" + VelocityUtils.renderTemplate(STEP1_HQL_TEMPLATE,velocityContext));\n  }\n  return result;\n}\n", "docstring": "runs the job to scan the metastore for directory locations .", "partition": "test"}
{"idx": "6360", "code": "public void deleteSubPeopleContainers(Set peopleContainers) throws AMException, SSOException {\n  Iterator iter=peopleContainers.iterator();\n  while (iter.hasNext()) {\n    String peopleContainerDN=(String)iter.next();\n    AMPeopleContainer peopleContainer=new AMPeopleContainerImpl(super.token,peopleContainerDN);\n    peopleContainer.delete();\n  }\n}\n", "docstring": "deletes sub people containers in this people container .", "partition": "test"}
{"idx": "6361", "code": "private void testFindRecentMessageUidsInMailbox() throws Exception {\n  LOG.info(\"findRecentMessageUidsInMailbox\");\n  List<MessageUid> recentMessages=messageMapper.findRecentMessageUidsInMailbox(MBOXES.get(1));\n  assertEquals(MESSAGE_NO.size() - 1,recentMessages.size());\n}\n", "docstring": "test of findrecentmessageuidsinmailbox method , of class hbasemessagemapper .", "partition": "test"}
{"idx": "6362", "code": "private void addErrorMessage(String message){\n  if (message != null) {\n    m_errorMessages.append(message);\n  }\n  m_errorMessages.append(\"\\r\\n\");\n}\n", "docstring": "return list of error messages found while parsing last template .", "partition": "test"}
{"idx": "6363", "code": "public void write(String key,byte[] newValue) throws Exception {\n  Map<String,byte[]> entry=new HashMap<>();\n  entry.put(key,newValue);\n  write(entry);\n}\n", "docstring": "performs the best effort of updating zk node { basepath } / { key } to the provided value . the semantics provided are as follows : the value is written regardless of the current value associated with the key . if the key doesn \"'\" t exist and we lose the race to create the key , we will throw an exception .", "partition": "test"}
{"idx": "6364", "code": "public String query(String handler,SolrQueryRequest req) throws Exception {\n  try (SolrCore core=getCoreInc()){\n    SolrQueryResponse rsp=new SolrQueryResponse();\n    SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n    core.execute(core.getRequestHandler(handler),req,rsp);\n    if (rsp.getException() != null) {\n      throw rsp.getException();\n    }\n    StringWriter sw=new StringWriter(32000);\n    QueryResponseWriter responseWriter=core.getQueryResponseWriter(req);\n    responseWriter.write(sw,req,rsp);\n    req.close();\n    return sw.toString();\n  }\n  finally {\n    req.close();\n    SolrRequestInfo.clearRequestInfo();\n  }\n}\n", "docstring": "processes a \" query \" using a user constructed solrqueryrequest , and closes the request at the end .", "partition": "test"}
{"idx": "6365", "code": "private boolean bothLinksHaveSameLinkStats(Link linkA,Link linkB){\n  boolean bothLinksHaveSameLinkStats=true;\n  if (linkA.getFreespeed() != linkB.getFreespeed()) {\n    bothLinksHaveSameLinkStats=false;\n  }\n  if (linkA.getCapacity() != linkB.getCapacity()) {\n    bothLinksHaveSameLinkStats=false;\n  }\n  return bothLinksHaveSameLinkStats;\n}\n", "docstring": "compare link attributes . return whether they are the same or not .", "partition": "test"}
{"idx": "6366", "code": "public String generateSanitizedId(){\n  String result=generateId();\n  result=result.replace(':','-');\n  result=result.replace('_','-');\n  result=result.replace('.','-');\n  return result;\n}\n", "docstring": "generate a unique id - that is friendly for a url or file system", "partition": "test"}
{"idx": "6367", "code": "private Object parseElement(Node element) throws XmlParseException {\n  try {\n    return parseElementRaw(element);\n  }\n catch (  Exception e) {\n    throw new XmlParseException(\"Failed to parse: \" + element.getNodeName(),e);\n  }\n}\n", "docstring": "parses a ( non - top ) xml element .", "partition": "test"}
{"idx": "6368", "code": "public static String format(Money money){\n  long microAmount=0;\n  if (money != null) {\n    microAmount=money.getMicroAmount();\n  }\n else {\n    return PLACEHOLDER_NULL;\n  }\n  double amount=(double)microAmount / MICRO_UNITS;\n  return String.format(FORMAT_MONEY,amount);\n}\n", "docstring": "formats a given monetary value in a default format ( 2 decimals , padded left to 10 characters ) .", "partition": "test"}
{"idx": "6369", "code": "private void deleteInstance(EntryClass eclass){\n  int idx=entryClasses.indexOf(eclass);\n  eclass=(EntryClass)entryClasses.get(idx);\n  int num=eclass.getNumInstances() - 1;\n  if (num == 0)   entryClasses.remove(idx);\n  eclass.setNumInstances(num);\n}\n", "docstring": "delete an instance of the entryclass , and remove the class from entryclasses if this is the last such instance .", "partition": "test"}
{"idx": "6370", "code": "public void logWarning(String message){\n  logger.warning(logPrefix + message);\n}\n", "docstring": "logs a warning message using the logger of this interpreter .", "partition": "test"}
{"idx": "6371", "code": "public static String readAsString(InputStream is) throws IOException {\n  StringBuffer buf=new StringBuffer();\n  byte[] b=new byte[8192];\n  int nread=-1;\n  while ((nread=is.read(b)) >= 0) {\n    String s=new String(b,0,nread);\n    buf.append(s);\n  }\n  return buf.toString();\n}\n", "docstring": "reads an input stream into a single string result .", "partition": "test"}
{"idx": "6372", "code": "public ArrayFieldVector(int size,T preset){\n  this(preset.getField(),size);\n  Arrays.fill(data,preset);\n}\n", "docstring": "construct a vector with preset values .", "partition": "test"}
{"idx": "6373", "code": "public static synchronized void unregisterTransactionServicePlugin(TransactionServicePlugin l){\n  if (service_ != null) {\n    service_.removeTSListener(l);\n  }\n  tsListenersList_.remove(l);\n}\n", "docstring": "remove a transaction service listener .", "partition": "test"}
{"idx": "6374", "code": "protected static void isort(int level[],float BC[]){\n  float temp;\n  int temp2;\n  for (int i=0; i < BC.length - 1; i++) {\n    int j=i;\n    temp=BC[j + 1];\n    temp2=level[j + 1];\n    if (temp == 0) {\n      continue;\n    }\n    int prej=j + 1;\n    while (j > -1 && (temp < BC[j] || BC[j] == 0)) {\n      if (BC[j] == 0) {\n        j--;\n        continue;\n      }\n else {\n        BC[prej]=BC[j];\n        level[prej]=level[j];\n        prej=j;\n        j--;\n      }\n    }\n    BC[prej]=temp;\n    level[prej]=temp2;\n  }\n}\n", "docstring": "this methods sorts the vertices in level [ ", "partition": "test"}
{"idx": "6375", "code": "public void testIsConsistentModelClass(){\n  SessionNode node1=new SessionNode(Type1.class);\n  SessionNode node2=new SessionNode(Type2.class);\n  SessionNode node3=new SessionNode(Type3.class);\n  SessionNode node4=new SessionNode(new Class[]{Type1.class,Type2.class});\n  SessionNode node6=new SessionNode(new Class[]{Type1.class,Type2.class,Type3.class});\n  SessionNode node7=new SessionNode(new Class[]{Type1.class,Type4.class});\n  List parents=new ArrayList();\n  parents.add(node1);\n  parents.add(node2);\n  parents.add(node3);\n  parents.remove(node1);\n  parents.remove(node2);\n  parents.remove(node3);\n  parents.add(node4);\n  assertTrue(node1.isConsistentModelClass(Type1.class,parents,false));\n  parents.add(node6);\n  assertTrue(node1.isConsistentModelClass(Type1.class,parents,false));\n  parents.remove(node6);\n  parents.add(node7);\n  assertTrue(!node1.isConsistentModelClass(Type1.class,parents,false));\n}\n", "docstring": "tests whether model classes can identified correctly as consistent .", "partition": "test"}
{"idx": "6376", "code": "public void findAndInit(Object someObj){\n  if (someObj instanceof com.bbn.openmap.MapBean) {\n    logger.fine(\"ProjectionStack found a MapBean.\");\n    setMapBean((MapBean)someObj);\n  }\n}\n", "docstring": "look at the object received in a maphandler status message and connect to it if necessary .", "partition": "test"}
{"idx": "6377", "code": "public void removeAllLayers(){\n  _layers.removeAllElements();\n  refreshLayers=true;\n  super.repaint();\n}\n", "docstring": "removes all layers from the map", "partition": "test"}
{"idx": "6378", "code": "private void writeObject(ObjectOutputStream oos) throws IOException {\n  oos.defaultWriteObject();\n  writeStroke(oos,stroke,OMGraphicAdapter.BASIC_STROKE);\n  writeTextureMask(oos,textureMask);\n}\n", "docstring": "write this object to a stream .", "partition": "test"}
{"idx": "6379", "code": "public boolean equals(Object obj){\n  if (obj instanceof MRfQResponseLineQty) {\n    MRfQResponseLineQty cmp=(MRfQResponseLineQty)obj;\n    if (!cmp.isValidAmt() || !isValidAmt())     return false;\n    BigDecimal cmpNet=cmp.getNetAmt();\n    if (cmpNet == null)     return false;\n    BigDecimal net=cmp.getNetAmt();\n    if (net == null)     return false;\n    return cmpNet.compareTo(net) == 0;\n  }\n  return false;\n}\n", "docstring": "is net amount equal ?", "partition": "test"}
{"idx": "6380", "code": "public ReflectiveAttribute(Class<O> objectType,Class<A> fieldType,String fieldName){\n  super(objectType,fieldType,fieldName);\n  Field field;\n  try {\n    field=getField(objectType,fieldName);\n    if (!field.isAccessible()) {\n      field.setAccessible(true);\n    }\n  }\n catch (  Exception e) {\n    throw new IllegalStateException(\"Invalid attribute definition: No such field \'\" + fieldName + \"\' in object \'\"+ objectType.getName()+ \"\'\");\n  }\n  if (!fieldType.isAssignableFrom(field.getType())) {\n    throw new IllegalStateException(\"Invalid attribute definition: The type of field \'\" + fieldName + \"\', type \'\"+ field.getType()+ \"\', in object \'\"+ objectType.getName()+ \"\', is not assignable to the type indicated: \"+ fieldType.getName());\n  }\n  this.field=field;\n}\n", "docstring": "creates an attribute which reads values from the field indicated using reflection .", "partition": "test"}
{"idx": "6381", "code": "private void processEvent(EventLogControl check,final String name,final DTNHost host1,final DTNHost host2,final Message message){\n  String descString;\n  if (!check.showEvent()) {\n    return;\n  }\n  descString=name + \" \" + (host1 != null ? host1 : \"\")+ (host2 != null ? (HOST_DELIM + host2) : \"\")+ (message != null ? \" \" + message : \"\");\n  if (regExp != null && !descString.matches(regExp)) {\n    return;\n  }\n  if (check.pauseOnEvent()) {\n    gui.setPaused(true);\n    if (host1 != null) {\n      gui.setFocus(host1);\n    }\n  }\n  addEvent(name,host1,host2,message,check.pauseOnEvent());\n}\n", "docstring": "processes a log event", "partition": "test"}
{"idx": "6382", "code": "public boolean removeMembershipListener(MembershipListener listener){\n  return membershipListeners.remove(listener) != null;\n}\n", "docstring": "remove listener from the list to receive notification when a provile is added or removed .", "partition": "test"}
{"idx": "6383", "code": "public static Uri addMessageToUri(ContentResolver resolver,Uri uri,String address,String body,String subject,Long date,boolean read,boolean deliveryReport,long threadId){\n  ContentValues values=new ContentValues(7);\n  values.put(ADDRESS,address);\n  if (date != null) {\n    values.put(DATE,date);\n  }\n  values.put(READ,read ? Integer.valueOf(1) : Integer.valueOf(0));\n  values.put(SUBJECT,subject);\n  values.put(BODY,body);\n  if (deliveryReport) {\n    values.put(STATUS,STATUS_PENDING);\n  }\n  if (threadId != -1L) {\n    values.put(THREAD_ID,threadId);\n  }\n  return resolver.insert(uri,values);\n}\n", "docstring": "add an sms to the given uri with thread_id specified .", "partition": "test"}
{"idx": "6384", "code": "private void present(){\n  glUseProgram(quadProgram);\n  glBindBuffer(GL_ARRAY_BUFFER,vbo);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_2D,tex);\n  glDrawArrays(GL_TRIANGLES,0,6);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_2D,0);\n  glBindBuffer(GL_ARRAY_BUFFER,0);\n  glUseProgram(0);\n}\n", "docstring": "present the final image on the screen / viewport .", "partition": "test"}
{"idx": "6385", "code": "public static Calendar next(Calendar self){\n  Calendar result=(Calendar)self.clone();\n  result.add(Calendar.DAY_OF_YEAR,1);\n  return result;\n}\n", "docstring": "increment a calendar by one day .", "partition": "test"}
{"idx": "6386", "code": "protected void angularObjectClientBind(NotebookSocket conn,HashSet<String> userAndRoles,Notebook notebook,Message fromMessage) throws Exception {\n  String noteId=fromMessage.getType(\"noteId\");\n  String varName=fromMessage.getType(\"name\");\n  Object varValue=fromMessage.get(\"value\");\n  String paragraphId=fromMessage.getType(\"paragraphId\");\n  Note note=notebook.getNote(noteId);\n  if (paragraphId == null) {\n    throw new IllegalArgumentException(\"target paragraph not specified for \" + \"angular value bind\");\n  }\n  if (note != null) {\n    final InterpreterGroup interpreterGroup=findInterpreterGroupForParagraph(note,paragraphId);\n    final AngularObjectRegistry registry=interpreterGroup.getAngularObjectRegistry();\n    if (registry instanceof RemoteAngularObjectRegistry) {\n      RemoteAngularObjectRegistry remoteRegistry=(RemoteAngularObjectRegistry)registry;\n      pushAngularObjectToRemoteRegistry(noteId,paragraphId,varName,varValue,remoteRegistry,interpreterGroup.getId(),conn);\n    }\n else {\n      pushAngularObjectToLocalRepo(noteId,paragraphId,varName,varValue,registry,interpreterGroup.getId(),conn);\n    }\n  }\n}\n", "docstring": "push the given angular variable to the target interpreter angular registry given a noteid and a paragraph id", "partition": "test"}
{"idx": "6387", "code": "public static <T>void removeAll(List<T> list,List<Integer> indexes){\n  if (list == null || indexes == null) {\n    return;\n  }\n  Collections.sort(indexes,Collections.reverseOrder());\n  final int size=list.size();\n  for (  Integer index : indexes) {\n    if (index >= 0 && index < size) {\n      list.remove((int)index);\n    }\n  }\n}\n", "docstring": "removes from the given list the elements at the given indexes . ignores indexes which are out of bounds of list .", "partition": "test"}
{"idx": "6388", "code": "public CProjectTree(final JFrame parent,final CDatabaseManager databaseManager){\n  Preconditions.checkNotNull(databaseManager,\"IE01840: Database manager object can\'t be null\");\n  m_treeModel=new CProjectTreeModel(this);\n  setModel(m_treeModel);\n  CProjectTreeDragHandlerInitializer.initialize(parent,this,databaseManager);\n  addMouseListener(new InternalMouseListener());\n  setScrollsOnExpand(false);\n  setRootVisible(false);\n  m_rootNode=new CRootNode(this,databaseManager);\n  m_treeModel.setRoot(m_rootNode);\n  setCellRenderer(new IconNodeRenderer());\n  m_popup.add(CActionProxy.proxy(new CAddDatabaseAction(this)));\n}\n", "docstring": "creates a new project tree component .", "partition": "test"}
{"idx": "6389", "code": "public boolean isObject(){\n  return typeString.startsWith(OBJECT);\n}\n", "docstring": "determine if the expression is an object . ( a thing , not a person )", "partition": "test"}
{"idx": "6390", "code": "private void autoRequestMods(){\n  if (!c.autoRequestModsEnabled()) {\n    return;\n  }\n  Set<String> joinedChannels=c.getJoinedChannels();\n  for (  String channel : joinedChannels) {\n    if (!modsAlreadyRequested.contains(channel)) {\n      LOGGER.info(\"Auto-requesting mods for \" + channel);\n      modsAlreadyRequested.add(channel);\n      requestModsSilent(channel);\n      return;\n    }\n  }\n}\n", "docstring": "if enabled in the settings , requests / mods for one currently joined channel ( and only one ) , ignoring the ones it was already requested for .", "partition": "test"}
{"idx": "6391", "code": "public void buildDepreciation(){\n  if (!isDepreciated()) {\n    return;\n  }\n  StringBuffer sb=new StringBuffer();\n  load(get_TrxName());\n  MAssetAcct assetacct=getA_AssetAcct(null,get_TrxName());\n  MDepreciation depreciation_C=MDepreciation.get(getCtx(),assetacct.getA_Depreciation_ID());\n  MDepreciation depreciation_F=MDepreciation.get(getCtx(),assetacct.getA_Depreciation_F_ID());\n  int offset_C=0, offset_F=0;\n  BigDecimal assetCost=getActualCost();\n  BigDecimal accumDep_C=getA_Accumulated_Depr(false);\n  BigDecimal accumDep_F=getA_Accumulated_Depr(true);\n  int lifePeriods_C=getUseLifeMonths(false) + offset_C;\n  int lifePeriods_F=getUseLifeMonths(true) + offset_F;\n  int lifePeriods=(lifePeriods_C > lifePeriods_F ? lifePeriods_C : lifePeriods_F);\n  BigDecimal exp_C=Env.ZERO;\n  BigDecimal exp_F=Env.ZERO;\n  if (CLogMgt.isLevelFine()) {\n    sb.append(\"currentPeriod=\" + getA_Current_Period() + \", AssetServiceDate=\"+ getAssetDepreciationDate()+ \"\\n\");\n    sb.append(\"offset: C|F=\" + offset_C + \"|\"+ offset_F+ \"\\n\");\n    sb.append(\"life: C|F=\" + lifePeriods_C + \"|\"+ lifePeriods_F+ \" + offset =\"+ lifePeriods+ \"\\n\");\n  }\n  truncDepreciation();\n  int A_Current_Period=getA_Current_Period();\n  for (int currentPeriod=A_Current_Period, cnt=1; currentPeriod <= lifePeriods; currentPeriod++, cnt++) {\n    exp_C=Env.ZERO;\n    exp_F=Env.ZERO;\n    String help=\"\" + accumDep_C + \"|\"+ accumDep_F+ \" + \";\n    if (lifePeriods_C > currentPeriod || !depreciation_C.requireLastPeriodAdjustment()) {\n      setFiscal(false);\n      exp_C=depreciation_C.invoke(this,assetacct,currentPeriod,accumDep_C);\n      accumDep_C=accumDep_C.add(exp_C);\n    }\n else     if (lifePeriods_C == currentPeriod) {\n      exp_C=assetCost.subtract(accumDep_C);\n      accumDep_C=assetCost;\n    }\n    if (lifePeriods_F > currentPeriod || !depreciation_F.requireLastPeriodAdjustment()) {\n      setFiscal(true);\n      exp_F=depreciation_F.invoke(this,assetacct,currentPeriod,accumDep_F);\n      accumDep_F=accumDep_F.add(exp_F);\n    }\n else     if (lifePeriods_F == currentPeriod) {\n      exp_F=assetCost.subtract(accumDep_F);\n      accumDep_F=assetCost;\n    }\n    help+=\"\" + exp_C + \"|\"+ exp_F+ \" = \"+ accumDep_C+ \"|\"+ accumDep_F;\n    int months=0;\n    months=months + (currentPeriod - A_Current_Period);\n    Timestamp dateAcct=TimeUtil.getMonthLastDay(TimeUtil.addMonths(getDateAcct(),months));\n    MDepreciationExp.createDepreciation(this,currentPeriod,dateAcct,exp_C,exp_F,accumDep_C,accumDep_F,help,get_TrxName());\n    if (CLogMgt.isLevelFine()) {\n      String info=\"\" + cnt + \": period=\"+ currentPeriod+ \"/\"+ lifePeriods_C+ \"|\"+ lifePeriods_F+ \", exp=\"+ exp_C+ \"|\"+ exp_F+ \", accumDep=\"+ accumDep_C+ \"|\"+ accumDep_F+ \", DateAcct=\"+ dateAcct;\n      log.fine(\"=> \" + info + Env.NL+ Env.NL);\n      sb.append(info + Env.NL);\n    }\n  }\n  log.fine(sb.toString());\n  m_buildDepreciation=false;\n}\n", "docstring": "build depreciation ( a_depreciation_exp ) entries . more exactly , is deleting not processed entries . and create new ones again . warning : is not modifying workfile ( this )", "partition": "test"}
{"idx": "6392", "code": "@Override public boolean contains(Object value){\n  final Iterator<Comparable> iter=new StepIterator(this,1);\n  if (value == null) {\n    return false;\n  }\n  while (iter.hasNext()) {\n    if (DefaultTypeTransformation.compareEqual(value,iter.next()))     return true;\n  }\n  return false;\n}\n", "docstring": "iterates over all values and returns true if one value matches .", "partition": "test"}
{"idx": "6393", "code": "public synchronized void renameFile(JDBCSequentialFile file,String newFileName) throws SQLException {\n  try {\n    connection.setAutoCommit(false);\n    renameFile.setString(1,newFileName);\n    renameFile.setInt(2,file.getId());\n    renameFile.executeUpdate();\n    connection.commit();\n  }\n catch (  SQLException e) {\n    connection.rollback();\n    throw e;\n  }\n}\n", "docstring": "updates the filename field to the new value .", "partition": "test"}
{"idx": "6394", "code": "public static void handleErrorViolations(Formatter formatter,long numErrors){\n  ExitCode exitCode=formatter.getExitStatus(numErrors);\n  if (exitCode != ExitCode.SUCCESS) {\n    System.exit(exitCode.ordinal());\n  }\n}\n", "docstring": "non - zero exit status when any violation messages have severity . error , controlled by - - max - severity", "partition": "test"}
{"idx": "6395", "code": "public void remove(final Sensor sensor){\n  Set<Sensor> oldSelection=new HashSet<Sensor>(selection);\n  boolean rv=selection.remove(sensor);\n  if (rv) {\n    fireSelectionChanged(oldSelection,selection);\n  }\n}\n", "docstring": "remove the specified sensor from this sensor selection model .", "partition": "test"}
{"idx": "6396", "code": "protected void printWay(MapWay way,DefaultEntityViewInfo pInfo,boolean asArea){\n  List<MapNode> nodes=getWayNodes(way);\n  if (nodes != null) {\n    boolean asOneway=false;\n    NameInfo textInfo=null;\n    if (scale >= pInfo.minNameScale * displayFactor) {\n      asOneway=way.isOneway();\n      if (way.getName() != null && pInfo.nameColor != null) {\n        textInfo=new NameInfo(way.getName(),pInfo.nameColor,pInfo.printOrder);\n      }\n    }\n    printLine(imageBdr,nodes,pInfo,asArea,asOneway,textInfo);\n  }\n}\n", "docstring": "prints a way entity .", "partition": "test"}
{"idx": "6397", "code": "public Element fullPath(ManagedObjectReference obj) throws InvalidPropertyFaultMsg, RuntimeFaultFaultMsg, FinderException {\n  List<ObjectContent> set=ancestrySet(obj);\n  Map<MoRef,Element> childToParent=new HashMap<>();\n  for (  ObjectContent cont : set) {\n    MoRef key=new MoRef(cont.getObj());\n    ManagedObjectReference parentRef=getParent(cont);\n    Element parent;\n    if (parentRef != null) {\n      parent=Element.make(parentRef,getName(cont));\n    }\n else {\n      parent=Element.make(cont.getObj(),getName(cont));\n    }\n    childToParent.put(key,parent);\n  }\n  MoRef next=new MoRef(obj);\n  List<String> path=new ArrayList<>();\n  while (true) {\n    Element parent=childToParent.get(next);\n    path.add(parent.path);\n    if (next.equals(new MoRef(parent.object))) {\n      break;\n    }\n    next=new MoRef(parent.object);\n  }\n  Collections.reverse(path);\n  StringBuilder sb=new StringBuilder();\n  for (  String s : path) {\n    sb.append('/');\n    sb.append(s);\n  }\n  return Element.make(obj,sb.toString());\n}\n", "docstring": "walks up the tree until a root object is found .", "partition": "test"}
{"idx": "6398", "code": "private boolean noObjectWasClickedOn(){\n  boolean pickedNodeNull=(pickedNode == null);\n  boolean cameraPicked=(pickedNode instanceof PCamera);\n  return (pickedNodeNull || cameraPicked);\n}\n", "docstring": "encapsulate logic for determining the case where no object ( neuron node , synpase node , etc ) was clicked on at the beginning of this drag sequence .", "partition": "test"}
{"idx": "6399", "code": "@Override public int hashCode(){\n  throw new UnsupportedOperationException(\"hashCode() is not supported because sets are mutable\");\n}\n", "docstring": "this operation is not supported because sets are mutable .", "partition": "test"}
{"idx": "6400", "code": "public Builder measurementMappings(Map<String,String> measurementMappings){\n  Map<String,Pattern> mappingsByPattern=new HashMap<String,Pattern>();\n  for (  Map.Entry<String,String> entry : measurementMappings.entrySet()) {\n    try {\n      final Pattern pattern=Pattern.compile(entry.getValue());\n      mappingsByPattern.put(entry.getKey(),pattern);\n    }\n catch (    PatternSyntaxException e) {\n      throw new RuntimeException(\"Could not compile regex: \" + entry.getValue(),e);\n    }\n  }\n  this.measurementMappings=mappingsByPattern;\n  return this;\n}\n", "docstring": "map measurement to a defined measurement name , where the key is the measurement name and the value is the reqex the measurement should be mapped by .", "partition": "test"}
{"idx": "6401", "code": "public static String validateCreditCardNumber(String creditCardNumber,String creditCardType){\n  if (creditCardNumber == null || creditCardType == null)   return \"CreditCardNumberError\";\n  String ccStartList=\"\";\n  String ccLengthList=\"\";\n  if (creditCardType.equals(X_C_Payment.CREDITCARDTYPE_MasterCard)) {\n    ccStartList=\"51,52,53,54,55\";\n    ccLengthList=\"16\";\n  }\n else   if (creditCardType.equals(X_C_Payment.CREDITCARDTYPE_Visa)) {\n    ccStartList=\"4\";\n    ccLengthList=\"13,16\";\n  }\n else   if (creditCardType.equals(X_C_Payment.CREDITCARDTYPE_Amex)) {\n    ccStartList=\"34,37\";\n    ccLengthList=\"15\";\n  }\n else   if (creditCardType.equals(X_C_Payment.CREDITCARDTYPE_Discover)) {\n    ccStartList=\"6011\";\n    ccLengthList=\"16\";\n  }\n else   if (creditCardType.equals(X_C_Payment.CREDITCARDTYPE_Diners)) {\n    ccStartList=\"300,301,302,303,304,305,36,38\";\n    ccLengthList=\"14\";\n  }\n else {\n    ccStartList=\"2014,2149\";\n    ccLengthList=\"15\";\n    ccStartList+=\",3088,3096,3112,3158,3337,3528\";\n    ccLengthList+=\",16\";\n    ccStartList+=\",2131,1800\";\n    ccLengthList+=\",15\";\n  }\n  String ccNumber=checkNumeric(creditCardNumber);\n  int ccLength=ccNumber.length();\n  boolean ccLengthOK=false;\n  StringTokenizer st=new StringTokenizer(ccLengthList,\",\",false);\n  while (st.hasMoreTokens() && !ccLengthOK) {\n    int l=Integer.parseInt(st.nextToken());\n    if (ccLength == l)     ccLengthOK=true;\n  }\n  if (!ccLengthOK) {\n    s_log.fine(\"validateCreditCardNumber Length=\" + ccLength + \" <> \"+ ccLengthList);\n    return \"CreditCardNumberError\";\n  }\n  boolean ccIdentified=false;\n  st=new StringTokenizer(ccStartList,\",\",false);\n  while (st.hasMoreTokens() && !ccIdentified) {\n    if (ccNumber.startsWith(st.nextToken()))     ccIdentified=true;\n  }\n  if (!ccIdentified)   s_log.fine(\"validateCreditCardNumber Type=\" + creditCardType + \" <> \"+ ccStartList);\n  String check=validateCreditCardNumber(ccNumber);\n  if (check.length() != 0)   return check;\n  if (!ccIdentified)   return \"CreditCardNumberProblem?\";\n  return \"\";\n}\n", "docstring": "validate credit card number . - check card type and length", "partition": "test"}
{"idx": "6402", "code": "public static void extract(File zipFile,File destDir) throws IOException {\n  ZipFile zf=new ZipFile(zipFile);\n  try {\n    extract(zf,destDir);\n  }\n  finally {\n    zf.close();\n  }\n}\n", "docstring": "extract the contents of a zipfile to a directory .", "partition": "test"}
{"idx": "6403", "code": "public Config(String file){\n  this(new File(CONFIG_DIR,file.contains(\".\") ? file : file.concat(\".conf\")));\n}\n", "docstring": "creates a new config within the config directory , using the filename provided .", "partition": "test"}
{"idx": "6404", "code": "public GotoLineDialog(JTextComponent text){\n  super(ActionUtils.getFrameFor(text),false);\n  initComponents();\n  this.text=text;\n  setLocationRelativeTo(text.getRootPane());\n}\n", "docstring": "creates new form gotolinedialog", "partition": "test"}
{"idx": "6405", "code": "private static void attemptRetryOnException(String logPrefix,Request<?> request,VolleyError exception) throws VolleyError {\n  RetryPolicy retryPolicy=request.getRetryPolicy();\n  int oldTimeout=request.getTimeoutMs();\n  try {\n    retryPolicy.retry(exception);\n  }\n catch (  VolleyError e) {\n    request.addMarker(String.format(\"%s-giveup [timeout=%s]\",logPrefix,oldTimeout));\n    throw e;\n  }\n  request.addMarker(String.format(\"%s-retry [timeout=%s]\",logPrefix,oldTimeout));\n}\n", "docstring": "attempts to prepare the request for a retry . if there are no more attempts remaining in the request \"'\" s retry policy , a timeout exception is thrown .", "partition": "test"}
{"idx": "6406", "code": "private void sendRequestTeardown() throws IOException {\n  String request=\"TEARDOWN rtsp://\" + mParameters.host + \":\"+ mParameters.port+ mParameters.path+ \" RTSP/1.0\\r\\n\"+ addHeaders();\n  Log.i(TAG,request.substring(0,request.indexOf(\"\\r\\n\")));\n  mOutputStream.write(request.getBytes(\"UTF-8\"));\n  mOutputStream.flush();\n}\n", "docstring": "forges and sends the teardown request", "partition": "test"}
{"idx": "6407", "code": "public int length(){\n  return this.filledLength;\n}\n", "docstring": "gets the current filled and readable length of the array .", "partition": "test"}
{"idx": "6408", "code": "@Override public boolean equals(Object o){\n  if (o instanceof Prefix) {\n    return value.equals(((Prefix)o).value);\n  }\n  return false;\n}\n", "docstring": "equals method to be consistent with comparable", "partition": "test"}
{"idx": "6409", "code": "private void notifyWifiState(){\nsynchronized (mWifiMonitor) {\n    Log.v(LOG_TAG,\"notify wifi state changed.\");\n    mWifiMonitor.notify();\n  }\n}\n", "docstring": "send a notification via the mwifimonitor when the wifi state changes .", "partition": "test"}
{"idx": "6410", "code": "private boolean arrayKeyValueExists(String key,String value){\n  if (visitedPost.containsKey(key)) {\n    for (    String s : visitedPost.get(key)) {\n      if (s.equals(value)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "docstring": "checks whether the value exists in an arraylist of certain key .", "partition": "test"}
{"idx": "6411", "code": "public void removeDiagramChangeListener(mxDiagramChangeListener listener){\n  if (diagramChangeListeners != null) {\n    diagramChangeListeners.remove(listener);\n  }\n}\n", "docstring": "removes the given listener from the list of diagram change listeners .", "partition": "test"}
{"idx": "6412", "code": "public static ConnectivityGrid ConnectivityGridFactory(int key,double maxRange){\n  if (gridobjects.containsKey((Integer)key)) {\n    return (ConnectivityGrid)gridobjects.get((Integer)key);\n  }\n else {\n    ConnectivityGrid newgrid=new ConnectivityGrid((int)Math.ceil(maxRange * cellSizeMultiplier));\n    gridobjects.put((Integer)key,newgrid);\n    return newgrid;\n  }\n}\n", "docstring": "returns a connectivity grid object based on a hash value", "partition": "test"}
{"idx": "6413", "code": "public static String stripLeadingDollar(String str){\n  return (str.charAt(0) == '$') ? str.substring(1) : str;\n}\n", "docstring": "removes any leading $ from the given string .", "partition": "test"}
{"idx": "6414", "code": "public PNormNormalization(double p){\n  if (p <= 0 || Double.isNaN(p))   throw new IllegalArgumentException(\"p must be greater than zero, not \" + p);\n  this.p=p;\n}\n", "docstring": "creates a new p norm", "partition": "test"}
{"idx": "6415", "code": "@Override public void start(Stage stage) throws Exception {\n  CategoryDataset dataset=createDataset();\n  JFreeChart chart=createChart(dataset);\n  ChartViewer viewer=new ChartViewer(chart);\n  viewer.addChartMouseListener(this);\n  stage.setScene(new Scene(viewer));\n  stage.setTitle(\"JFreeChart: BarChartFXDemo1.java\");\n  stage.setWidth(700);\n  stage.setHeight(390);\n  stage.show();\n}\n", "docstring": "adds a chart viewer to the stage and displays it .", "partition": "test"}
{"idx": "6416", "code": "@Override public void acceptDataPoint(ChartEvent e){\n  if (e.getReset()) {\n    m_xCount=0;\n    m_max=1;\n    m_min=0;\n  }\n  if (m_outputFrame != null) {\n    boolean refresh=false;\n    if (e.getLegendText() != null & e.getLegendText() != m_legendText) {\n      m_legendText=e.getLegendText();\n      refresh=true;\n    }\n    if (e.getMin() != m_min || e.getMax() != m_max) {\n      m_oldMax=m_max;\n      m_oldMin=m_min;\n      m_max=e.getMax();\n      m_min=e.getMin();\n      refresh=true;\n      m_yScaleUpdate=true;\n    }\n    if (refresh) {\n      m_legendPanel.repaint();\n      m_scalePanel.repaint();\n    }\n    acceptDataPoint(e.getDataPoint());\n  }\n  m_xCount++;\n}\n", "docstring": "accept a data point ( encapsulated in a chart event ) to plot", "partition": "test"}
{"idx": "6417", "code": "public void sub(NamedRangeSet other){\n  List<NamedRange> newRanges=new ArrayList<NamedRange>();\n  OUTER_LOOP:   for (  NamedRange range : ranges) {\n    NamedRange thisRange=new NamedRange(range.start,range.end,range.name);\n    for (    NamedRange otherRange : other.ranges) {\n      if (otherRange.start <= thisRange.start && otherRange.end >= thisRange.end) {\n        continue OUTER_LOOP;\n      }\n      if (otherRange.end < thisRange.start || otherRange.start > thisRange.end) {\n      }\n else       if (otherRange.start <= thisRange.start) {\n        thisRange.start=otherRange.end + 1;\n      }\n else       if (otherRange.end >= thisRange.end) {\n        thisRange.end=otherRange.start - 1;\n      }\n else {\n        newRanges.add(new NamedRange(thisRange.start,otherRange.start - 1,thisRange.name));\n        thisRange.start=otherRange.end + 1;\n      }\n    }\n    newRanges.add(thisRange);\n  }\n  ranges=newRanges;\n}\n", "docstring": "assumptions : ranges are disjoint , non - contiguous , and ordered . names of ranges are not necessarily preserved .", "partition": "test"}
{"idx": "6418", "code": "public static boolean isMacOs(){\n  return osName.indexOf(\"Mac OS\") > -1;\n}\n", "docstring": "is operating system mac os ?", "partition": "test"}
{"idx": "6419", "code": "public DViewAsn1Dump(JDialog parent,X509CRL crl) throws Asn1Exception, IOException {\n  super(res.getString(\"DViewAsn1Dump.Crl.Title\"));\n  this.crl=crl;\n  initComponents();\n}\n", "docstring": "creates new dviewasn1dump dialog where the parent is a dialog .", "partition": "test"}
{"idx": "6420", "code": "public static String rightTrim(final String value){\n  validate(value,NULL_STRING_PREDICATE,NULL_STRING_MSG_SUPPLIER);\n  return value.replaceAll(\"\\\\s+$\",\"\");\n}\n", "docstring": "remove all spaces on right .", "partition": "test"}
{"idx": "6421", "code": "public synchronized void putMessage(Object obj){\n  fifo.addElement(obj);\n  numMessage++;\n  notifyAll();\n}\n", "docstring": "add a message in the buffer", "partition": "test"}
{"idx": "6422", "code": "public void dispose(){\n  if (isDisposed()) {\n    return;\n  }\n  setDisposed(true);\n  if (!menu) {\n    super.dispose();\n  }\n}\n", "docstring": "closes the current form and returns to the previous form , releasing the edt in the process", "partition": "test"}
{"idx": "6423", "code": "public double signed_distance(PlaPointFloat p_point){\n  double dx=point_b.v_x - point_a.v_x;\n  double dy=point_b.v_y - point_a.v_y;\n  double det=dy * (p_point.v_x - point_a.v_x) - dx * (p_point.v_y - point_a.v_y);\n  double length=Math.sqrt(dx * dx + dy * dy);\n  return det / length;\n}\n", "docstring": "returns the signed distance of this line from p_point . the result will be positive , if the line is on the left of p_point , else negative .", "partition": "test"}
{"idx": "6424", "code": "public static void expandReal(String numberString,WordRelation wordRelation,Item tokenItem){\n  int stringLength=numberString.length();\n  int position;\n  if (numberString.charAt(0) == \'-\') {\n    wordRelation.addWord(tokenItem,\"minus\");\n    expandReal(numberString.substring(1,stringLength),wordRelation,tokenItem);\n  }\n else   if (numberString.charAt(0) == \'+\') {\n    wordRelation.addWord(tokenItem,\"plus\");\n    expandReal(numberString.substring(1,stringLength),wordRelation,tokenItem);\n  }\n else   if ((position=numberString.indexOf(\'e\')) != -1 || (position=numberString.indexOf(\'E\')) != -1) {\n    expandReal(numberString.substring(0,position),wordRelation,tokenItem);\n    wordRelation.addWord(tokenItem,\"e\");\n    expandReal(numberString.substring(position + 1),wordRelation,tokenItem);\n  }\n else   if ((position=numberString.indexOf(\'.\')) != -1) {\n    String beforeDot=numberString.substring(0,position);\n    if (beforeDot.length() > 0) {\n      expandReal(beforeDot,wordRelation,tokenItem);\n    }\n    wordRelation.addWord(tokenItem,\"point\");\n    String afterDot=numberString.substring(position + 1);\n    if (afterDot.length() > 0) {\n      expandDigits(afterDot,wordRelation,tokenItem);\n    }\n  }\n else {\n    expandNumber(numberString,wordRelation,tokenItem);\n  }\n}\n", "docstring": "expands the given number string as a real number .", "partition": "test"}
{"idx": "6425", "code": "public static double[] ones(int L){\n  double m[]=new double[L];\n  Arrays.fill(m,1.);\n  return m;\n}\n", "docstring": "ones - return a vector full of 1s .", "partition": "test"}
{"idx": "6426", "code": "public void testSettingANullDeployableProperty(){\n  Deployable deployableElement=new Deployable();\n  WAR war=new WAR(\"/some/file.war\");\n  Map<String,String> properties=new HashMap<String,String>();\n  properties.put(\"context\",null);\n  deployableElement.setProperties(properties);\n  deployableElement.setPropertiesOnDeployable(war,createDefaultProject(\"war\",null));\n  assertEquals(\"\",war.getContext());\n}\n", "docstring": "setting a null property is the way maven2 operates when the user specifies an empty property . we need to verify that the cargo plugin intercepts that and replaces the null with an empty string .", "partition": "test"}
{"idx": "6427", "code": "private NaviLogger(){\n}\n", "docstring": "you are not supposed to instantiate this class .", "partition": "test"}
{"idx": "6428", "code": "public static DeleteSubCommandHandler create(SubCommandArgumentParser parser,ManagedObjectPath<?,?> p,SetRelationDefinition<?,?> r) throws ArgumentException {\n  return new DeleteSubCommandHandler(parser,p,r,p.child(r));\n}\n", "docstring": "creates a new delete - xxx sub - command for a set relation .", "partition": "test"}
{"idx": "6429", "code": "protected void removeCycles(){\n  int visited[]=new int[m_nodes.size()];\n  for (int i=0; i < graphMatrix.length; i++) {\n    if (visited[i] == 0) {\n      removeCycles2(i,visited);\n      visited[i]=1;\n    }\n  }\n}\n", "docstring": "the following two methods remove cycles from the graph .", "partition": "test"}
{"idx": "6430", "code": "public String toString(ObjectMatrix3D matrix){\n  StringBuffer buf=new StringBuffer();\n  boolean oldPrintShape=this.printShape;\n  this.printShape=false;\n  for (int slice=0; slice < matrix.slices(); slice++) {\n    if (slice != 0)     buf.append(sliceSeparator);\n    buf.append(toString(matrix.viewSlice(slice)));\n  }\n  this.printShape=oldPrintShape;\n  if (printShape)   buf.insert(0,shape(matrix) + \"\\n\");\n  return buf.toString();\n}\n", "docstring": "returns a string representation of the given matrix .", "partition": "test"}
{"idx": "6431", "code": "public synchronized void kill(){\n  running=false;\n  closed=true;\n  try {\n    STDIN.close();\n  }\n catch (  IOException e) {\n  }\n  try {\n    process.destroy();\n  }\n catch (  Exception e) {\n  }\n}\n", "docstring": "try to clean up as much as possible from a shell that \"'\" s gotten itself wedged . hopefully the streamgobblers will croak on their own when the other side of the pipe is closed .", "partition": "test"}
{"idx": "6432", "code": "public static Metrics create(Map<String,String> dimensionMap){\n  Map<String,String> map=Maps.newTreeMap();\n  map.putAll(dimensionMap);\n  return new Metrics(Collections.unmodifiableMap(map));\n}\n", "docstring": "creates a metrics object with the dimensions map immutable", "partition": "test"}
{"idx": "6433", "code": "protected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n  Object annotation=readLocation();\n  String className=classDesc.getName();\n  ClassLoader defaultLoader=skipDefaultResolveClass ? null : latestUserDefinedLoader();\n  String codebase=null;\n  if (!useCodebaseOnly && annotation instanceof String) {\n    codebase=(String)annotation;\n  }\n  try {\n    return RMIClassLoader.loadClass(codebase,className,defaultLoader);\n  }\n catch (  AccessControlException e) {\n    return checkSunClass(className,e);\n  }\ncatch (  ClassNotFoundException e) {\n    try {\n      if (Character.isLowerCase(className.charAt(0)) && className.indexOf('.') == -1) {\n        return super.resolveClass(classDesc);\n      }\n    }\n catch (    ClassNotFoundException e2) {\n    }\n    throw e;\n  }\n}\n", "docstring": "resolveclass is extended to acquire ( if present ) the location from which to load the specified class . it will find , load , and return the class .", "partition": "test"}
{"idx": "6434", "code": "public boolean contains(final CreatureRespawnPoint point){\n  if (point == null) {\n    return false;\n  }\n  final IRPZone entityZone=point.getZone();\n  return zone.equals(entityZone) && shape.contains(point.getX(),point.getY());\n}\n", "docstring": "checks whether a respawn point is within this area .", "partition": "test"}
{"idx": "6435", "code": "public void add(int i,byte[] buffer,int offset,int length){\n  if (_length + length > _capacity)   ensureCapacity(_length + length);\n  System.arraycopy(_buffer,i,_buffer,i + length,_length - i);\n  System.arraycopy(buffer,offset,_buffer,i,length);\n  _length+=length;\n}\n", "docstring": "inserts a byte array", "partition": "test"}
{"idx": "6436", "code": "public boolean isUseAntiAlias(){\n  return useAntiAlias;\n}\n", "docstring": "checks if is use anti alias .", "partition": "test"}
{"idx": "6437", "code": "private void loadLevelFile(String tableName,String columnName,String cubeName,String schemaName){\n  String baseLocation=CarbonUtil.getCarbonStorePath(schemaName,cubeName);\n  baseLocation=baseLocation + File.separator + schemaName+ File.separator+ cubeName;\n  if (loadFolderList.size() == 0) {\n    checkAndUpdateFolderList(baseLocation);\n  }\n  try {\n    File[] filesArray=null;\n    for (    File loadFoler : loadFolderList) {\n      filesArray=getFilesArray(loadFoler,tableName + \'_\' + columnName);\n      if (null != filesArray) {\n        for (int i=0; i < filesArray.length; i++) {\n          readLevelFileAndUpdateCache(filesArray[i],tableName + \'_\' + columnName);\n        }\n      }\n    }\n  }\n catch (  IOException e) {\n    LOGGER.error(\"Problem while populating the cache\");\n  }\n}\n", "docstring": "below method will be used to fill the level cache", "partition": "test"}
{"idx": "6438", "code": "protected void doValidateZeroLongFile(String path,String filename,long size,boolean checkContents){\n  File inFile=new File(path,filename);\n  DataInputStream inStream=null;\n  Log.i(LOG_TAG,\"Validating file \" + filename + \" at \"+ path);\n  try {\n    inStream=new DataInputStream(new FileInputStream(inFile));\n    if (checkContents) {\n      for (long i=0; i < size; ++i) {\n        if (inStream.readLong() != 0) {\n          fail(\"Unexpected value read in OBB file\" + filename);\n        }\n      }\n    }\n    if (inStream != null) {\n      inStream.close();\n    }\n    Log.i(LOG_TAG,\"File \" + filename + \" successfully verified for \"+ size+ \" zeros\");\n  }\n catch (  IOException e) {\n    fail(\"IOError with file \" + inFile + \":\"+ e.toString());\n  }\n}\n", "docstring": "helper to validate the contents of a \" long \" file on our obbs the format of the files are sequential 0 \"'\" s of type long", "partition": "test"}
{"idx": "6439", "code": "protected void write(DataOutputStream stream) throws Exception {\n  Iterator<NBT_Tag> iter=elements.iterator();\n  while (iter.hasNext()) {\n    NBT_Tag ret=iter.next();\n    ret.save(stream);\n  }\n  TAG_End end=new TAG_End(\"\");\n  end.save(stream);\n}\n", "docstring": "saving method . ( see nbt_tag )", "partition": "test"}
{"idx": "6440", "code": "public String applyMask(String mask,String value){\n  return (String)getMaskOrGetCursorIndex(mask,value,0,true);\n}\n", "docstring": "makes a masked value of a value", "partition": "test"}
{"idx": "6441", "code": "private void computeDuration(){\n  duration=System.currentTimeMillis() - start;\n  total_duration+=duration;\n}\n", "docstring": "computes the duration by subtracting start to the current time in milliseconds", "partition": "test"}
{"idx": "6442", "code": "public int handleNITFHeader(BinaryFile binFile){\n  try {\n    byte[] nitfArray=binFile.readBytes(4,false);\n    String nitf=new String(nitfArray);\n    binFile.seek(RPF_DATE_LOCATION);\n    nitfArray=binFile.readBytes(2,false);\n    nitf=new String(nitfArray);\n    if (nitf.equalsIgnoreCase(\"19\") || nitf.equalsIgnoreCase(\"20\"))     return 0;\n    binFile.seek(RPF_DATE_LOCATION + TOC_NITF_HEADER_LENGTH);\n    nitfArray=binFile.readBytes(2,false);\n    nitf=new String(nitfArray);\n    if (nitf.equalsIgnoreCase(\"19\") || nitf.equalsIgnoreCase(\"20\"))     return TOC_NITF_HEADER_LENGTH;\n    binFile.seek(RPF_DATE_LOCATION + FRAME_SHORT_NITF_HEADER_LENGTH);\n    nitfArray=binFile.readBytes(2,false);\n    nitf=new String(nitfArray);\n    if (nitf.equalsIgnoreCase(\"19\") || nitf.equalsIgnoreCase(\"20\"))     return FRAME_SHORT_NITF_HEADER_LENGTH;\n    binFile.seek(RPF_DATE_LOCATION + FRAME_LONG_NITF_HEADER_LENGTH);\n    nitfArray=binFile.readBytes(2,false);\n    nitf=new String(nitfArray);\n    if (nitf.equalsIgnoreCase(\"19\") || nitf.equalsIgnoreCase(\"20\"))     return FRAME_LONG_NITF_HEADER_LENGTH;\n  }\n catch (  IOException e) {\n    Debug.error(\"RpfHeader: File IO Error while handling NITF header:\\n\" + e);\n    return -1;\n  }\ncatch (  FormatException f) {\n    Debug.error(\"RpfHeader: File IO Format error while reading header information:\\n\" + f);\n    return -1;\n  }\n  return -1;\n}\n", "docstring": "checks to see if the file is in nitf or not , and then puts the file pointer in the right place to start reading the header for the file . if the file is in nitf format , it skips the nitf header , and if it isn \"'\" t , it resets the pointer to the beginning .", "partition": "test"}
{"idx": "6443", "code": "public BufferedImage takeScreenshot(){\n  Debug.setDebugLevel(3);\n  File scrFile=driver.getScreenshotAs(OutputType.FILE);\n  BufferedImage bufferedImage=null;\n  try {\n    bufferedImage=ImageIO.read(scrFile);\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n  return bufferedImage;\n}\n", "docstring": "convenience method that takes a screenshot of the device and returns a bufferedimage for further processing .", "partition": "test"}
{"idx": "6444", "code": "private void pickCenterOverlap(ScoutWidget[] list){\n  for (int i=0; i < list.length; i++) {\n    ScoutWidget scoutWidget=list[i];\n    float centerX=scoutWidget.getX() + scoutWidget.getWidth() / 2;\n    float centerY=scoutWidget.getY() + scoutWidget.getHeight() / 2;\n    for (int j=0; j < list.length; j++) {\n      if (i == j)       continue;\n      ScoutWidget widget=list[j];\n      if (scoutWidget.isGuideline()) {\n        continue;\n      }\n      if (!widget.isGuideline() && ScoutWidget.distance(scoutWidget,widget) > MAX_DIST_FOR_CENTER_OVERLAP) {\n        continue;\n      }\n      if (!widget.isGuideline() || widget.isVerticalGuideline()) {\n        if (Math.abs(widget.getX() - centerX) < CENTER_ERROR) {\n          scoutWidget.setEdgeCentered(1,widget,Direction.WEST);\n        }\n        if (Math.abs(widget.getX() + widget.getWidth() - centerX) < CENTER_ERROR) {\n          scoutWidget.setEdgeCentered(1,widget,Direction.EAST);\n        }\n      }\n      if (!widget.isGuideline() || widget.isHorizontalGuideline()) {\n        if (Math.abs(widget.getY() - centerY) < CENTER_ERROR) {\n          scoutWidget.setEdgeCentered(0,widget,Direction.NORTH);\n        }\n        if (Math.abs(widget.getY() + widget.getHeight() - centerY) < CENTER_ERROR) {\n          scoutWidget.setEdgeCentered(0,widget,Direction.SOUTH);\n        }\n      }\n    }\n  }\n}\n", "docstring": "find and connect widgets centered over other widgets", "partition": "test"}
